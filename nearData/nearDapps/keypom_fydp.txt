*GitHub Repository "keypom/fydp"*

'''--- .vscode/settings.json ---
{
    "cSpell.words": [
        "fayyr",
        "nearcon",
        "POAP",
        "unscalable"
    ],
    "rust-analyzer.linkedProjects": [
        "./contract/Cargo.toml"
    ]
}
'''
'''--- Cargo.toml ---
# [package]
# name = "cross-contract-calls"
# version = "0.0.0"
# authors = ["Near Inc <hello@nearprotocol.com>"]
# edition = "2018"

[workspace]
members = [
  "contract"
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
<p align="center">
  <img src="assets/claimed-linkdrop.png" alt="Logo" style="width: 35%; height: 35%">
  <br />
</p>

<div align="center">
  <h1>
  Keypom
  </h1>
  Limitless possibilities in the palm of your hand.
</div>

<div align="center">
<br />

[![made by BenKurrek](https://img.shields.io/badge/made%20by-BenKurrek-ff1414.svg?style=flat-square)](https://github.com/BenKurrek)
[![made by mattlockyer](https://img.shields.io/badge/made%20by-MattLockyer-ff1414.svg?style=flat-square)](https://github.com/mattlockyer)

</div>

<details open="open">
<summary>Table of Contents</summary>

- [About](#about)
  - [Introduction](#introduction)
  - [Comparable Solutions](#comparable-solutions)
- [Our Solution](#our-solution)
  - [Drop Customization](#shared-drop-customization)
  - [Primary Market Public Sale for Keys](#primary-market-public-sale-for-keys)
  - [Simple Drops](#simple-drops)
  - [NFT Drops](#non-fungible-token-drops)
  - [FT Drops](#fungible-token-drops)
  - [Function Call Drops](#function-call-drops)
    - [How It Works](#how-do-fc-drops-work)
    - [Security](#security-for-fc-drops)
    - [User-Provided Args](#user-provided-arguments)
    - [Use Cases](#fc-drop-use-cases)
  - [Password Protected Keys](#password-protected-keys)
  - [dApp Free Trials for Users](#dapp-free-trials-for-users)
- [Costs](#costs)
  - [Per Drop](#per-drop)
  - [Per Key](#per-key)
  - [Deleting Keys and Drops](#deleting-keys-and-drops)
  - [Automatic Refunds](#automatic-refunds-when-keys-are-used)
  - [Account Balances](#account-balances-for-smooth-ux)
- [How Linkdrops Work](#how-linkdrops-work)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Deploy Scripts](#deploy-scripts)  
- [Query Information From Keypom](#query-information-from-keypom)
  - [Key Specific](#key-specific)
  - [Drop Specific](#drop-specific)    
- [Running Tests](#running-the-keypom-tests)
- [Contributing](#contributing)
- [Acknowledgements](#acknowledgements)

</details>

---

# About

<tr>
<td>

> To view our debut talk at NEARCON 2022, click [here](https://www.youtube.com/watch?v=J-BOnfhHV50).

Keypom is an access key factory created as a result of 3 common problems that arose in the ecosystem.

1. People want a *cheap, customizable, and unique* onboarding experience for users.
2. Companies don't want to expose **full access keys** in their backend servers.
3. dApps want a *smooth UX* with zero barrier to entry onboarding.

The contract was initially created as a way to handle the 1 $NEAR minimum deposit required for creating linkdrops using the [regular linkdrop contract](https://github.com/near/near-linkdrop/blob/f24f2608e1558db773f2408a28849d330abb3881/src/lib.rs#L18). 

If users wanted to create linkdrops, they needed to attach a **minimum** of 1 $NEAR. This made it costly and unscalable for projects that wanted to mass onboard onto NEAR. Keypom, on the other hand, has been highly optimized to allow for the lowest possible costs.

## Introduction

Blockchain technology comes with many benefits such as sovereign ownership, digital rights, privacy, freedom, 
peer to peer coordination and much more. The problem with this technology, however, is that there is an extremely 
high barrier to entry for an everyday individual. None of it matters if nobody can onboard.

It’s confusing to create and fund a crypto wallet. People are unfamiliar with the process, technical jargon, 
and the general flow. NEAR’s account model is powerful, but extremely underutilized because it’s complex for 
developers to take full advantage of. Keypom wraps this up in a single API call.

With NEAR’s goal of onboarding 1 billion users to Web3, there needs to be a solution to this high barrier to 
entry for developers building on NEAR and users onboarding to their apps and the NEAR ecosystem.

Below is a table outlining the minimum costs to onboard a new user onto NEAR with a named account.

|                      | 1 Account       | 1,000 Accounts  | 1,000,000 Accounts |
|----------------------|-----------------|-----------------|--------------------|
| Traditional Linkdrop | ~1 NEAR         | ~1,003 NEAR     | ~1,002,840 NEAR    |
| Keypom               | ~0.0035 NEAR    | ~3.5 NEAR       | ~3,500 NEAR        |
|                      | ~99.65% Cheaper | ~99.65% Cheaper | ~99.65% Cheaper    |

Keypom allows anyone to create highly customizable onboarding experiences for their users. These experiences 
can be both for new, or existing users. If someone already has a wallet, they can still use a Keypom link to 
experience an app, and then transfer the assets later.

## Comparable Solutions

|                                              | **Keypom** | **NEAR Drop** | **Satori** |
|----------------------------------------------|------------|---------------|------------|
| NEAR Drop                                    |      ✅     |       ✅       |      ❌     |
| FT Drop                                      |      ✅     |       ❌       |      ❌     |
| NFT Drop                                     |      ✅     |       ❌       |      ✅     |
| Function Call Drop                           |      ✅     |       ❌       |      ❌     |
| Embeddable in Dapps                          |      ✅     |       ❌       |      ❌     |
| Wallet Selector Integration                  |      ✅     |       ❌       |      ❌     |
| No Fee                                       |      ✅     |     Maybe?    |      ❌     |
| No Backend / 3rd Party                       |      ✅     |       ✅       |      ❌     |
| Campaigns                                    |      ✅     |       ✅       |      ✅     |
| Multi-Step e.g. Tickets click > scan > claim |      ✅     |       ❌       |      ❌     |
| Password Protected Drops                     |      ✅     |       ❌       |      ❌     |
| Timed Drops e.g. recurring payments          |      ✅     |       ❌       |      ❌     |
| Custom Names e.g. user.myapp.near            |      ✅     |       ❌       |      ❌     |

# Our Solution

Keypom allows for the creation of highly customizable access keys. These keys can be thought of as having their
own *smart contracts*. Each access key derives from what's known as a *drop*. These drops outline the different 
functionalities and behaviors the key will have. A drop can be thought of as a bucket that access keys belong to.
You can create many different buckets and fill them each with their own keys. Each key will act in accordance to the
drop, or bucket, it belongs to.

A drop can be one of four different types:

1. Simple drop.
2. Non Fungible Token drop.
3. Fungible Token drop.
4. Function Call drop.

# Shared Drop Customization

While each *type* of drop has its own set of customizable features, there are some that are shared by **all drops**
These are outlined below.

```rust
/// Each time a key is used, how much $NEAR should be sent to the claiming account (can be 0).
pub deposit_per_use: u128,

/// How much Gas should be attached when the key is used. The default is 100 TGas as this is
/// what's used by the NEAR wallet.
pub required_gas: Gas,

/// The drop as a whole can have a config as well
pub config: Option<DropConfig>,

/// Metadata for the drop in the form of stringified JSON. The format is completely up to the
/// user and there are no standards for format.
pub metadata: LazyOption<DropMetadata>,
```

Within the config, there are a suite of features that can be customized as well:

```rust
/// How many uses can each key have before it's deleted. If None, default to 1.
pub uses_per_key: Option<u64>,

/// Override the global root account that sub-accounts will have (near or testnet). This allows
/// users to create specific drops that can create sub-accounts of a predefined root.
/// For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then
/// be `ACCOUNT.fayyr.near`
pub root_account_id: Option<AccountId>,

// /Any time based configurations
pub time: Option<TimeConfig>,

/// Public sale config options
pub sale: Option<PublicSaleConfig>,

/// Any usage specific configurations
pub usage: Option<UsageConfig>,
```

## Time Based Customizations

Keypom allows users to customize time-based configurations as outlined below.

```rust
pub struct TimeConfig {
    /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub start: Option<u64>,

    /// Block timestamp that keys must be before. If None, keys can be used indefinitely
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub end: Option<u64>,

    /// Time interval between each key use. If None, there is no delay between key uses.
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub throttle: Option<u64>,

    /// Interval of time after the `start_timestamp` that must pass before a key can be used.
    /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
    /// With the throttle timestamp. It only pertains to the start timestamp and the current
    /// timestamp. The last_used timestamp is not taken into account.
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub interval: Option<u64>,
}
```

## Usage Based Customizations

In addition to time-based configurations, the funder can customize behaviors pertaining to
key usages.

```rust
pub struct UsageConfig {
    /// Can the access key only call the claim method_name? Default to both method_name callable
    pub permissions: Option<ClaimPermissions>,
    /// If claim is called, refund the deposit to the owner's balance. If None, default to false.
    pub refund_deposit: Option<bool>,
    /// Should the drop be automatically deleted when all the keys are used? This is defaulted to false and
    /// Must be overwritten
    pub auto_delete_drop: Option<bool>,
    /// When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.
    pub auto_withdraw: Option<bool>,
    /// When calling `create_account` on the root account, which keypom args should be attached to the payload.
    pub account_creation_fields: Option<KeypomArgs>,
}
```

## Primary Market Public Sale for Keys

The last type of customization available to the funder is the ability to create a public sale for access keys in a drop.
The funder can create a drop and let people add keys to it on an as-needed basis. The sale configurations are outlined below.

```rust
pub struct PublicSaleConfig {
    /// Maximum number of keys that can be added to this drop. If None, there is no max.
    pub max_num_keys: Option<u64>,
 
    /// Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
    /// Automatically sent to the funder's balance. If None, the keys are free to the public.
    pub price_per_key: Option<u128>,
 
    /// Which accounts are allowed to add keys?
    pub allowlist: Option<LookupSet<AccountId>>,
 
    /// Which accounts are NOT allowed to add keys?
    pub blocklist: Option<LookupSet<AccountId>>,

    /// Should the revenue generated be sent to the funder's account balance or
    /// automatically withdrawn and sent to their NEAR wallet?
    pub auto_withdraw_funds: Option<bool>,

    /// Minimum block timestamp before the public sale starts. If None, keys can be added immediately
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub start: Option<u64>,

    /// Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub end: Option<u64>,
}
```                

### Use-Cases for Public Sales

Giving the funder the ability to sell access keys to a drop introduces a ton of awesome use-cases and has a slew of benefits:
- Everything is decentralized and on-chain. There is no need to trust a third party to hold the keys.
- Keys are created on an as-needed basis. This *drastically reduces up-front costs* for the drop funder.
- Since keys are created only when users want them, there is no chance that through distribution, the private key
  gets compromised. The key is created *when the user purchases it*.
- Everything *can* remain anonymous and private since people can purchase access keys with their crypto wallets.

Having a public sale allows for an on-chain distribution mechanism for access keys. Let's look at two examples where this can be used.

#### Example 1: Ticketing

Imagine there is an event organizer that wants to host with a guest-list of 100,000 people. Without doing a public sale, the organizer would
need to spend a lot of $NEAR up-front to create all 100 thousand access keys. At this point, they would need to find a way to distribute all the keys.

With a public sale, the organizer can set a price per key, an allowlist, a blocklist, and even a start date for when the sale goes live. At this point,
the keys would be lazily purchased by people coming to the event. This not only reduces the up-front cost for the funder but it can also provide more accurate
data on how many people are actually coming to the event.

#### Example 2: Selling Function Calls

Access keys can be used for much more than just POAPs, onboarding or tickets. When using FC Drops, the keys can execute functions on external contracts. This feature can be used in conjunction with the public sale to create a marketplace for gated function calls. 

Imagine a simple guest-book smart contract that only allowed people to sign the book if they had a valid Keypom access key. Whoever signed the guest-book had access to all VIP events at NEARCon. You could lock access to signing the guest-book behind a Keypom drop and setup a public sale.

#### Example 3: NFT Collections

A very common scenario is an artist launching a new NFT collection. The artist can setup a custom marketplace whereby the keys are lazily minted and sold to the public. 
They can then create a custom website that takes a Keypom link and brings the user through a unique, creative experience before the NFT is minted and a wallet is optionally 
created. People that purchase the links can either use them to send the NFT to their existing wallet or create an entirely new wallet.

## Simple Drops

The most basic type of drop is the simple kind. Any keys that are part of a simple drop can
only be used for 1 thing: **transferring $NEAR**. Once the key is claimed, the claiming account
will receive the $NEAR specified in the `deposit_per_use`. Simple drops are a great way to send 
$NEAR to claiming accounts while not storing a lot of information on the contract. Below are a 
couple use cases.

### Backend Servers

Let's say you have a backend server that should send 10 $NEAR to the first 3
people that redeem an NFT. Rather than exposing your full access key in the backend server,
you could create a simple drop that either has 3 keys or 1 key that is claimable 3 times.
In the drop, you'd specify that each time the key is claimed, the specified account would
receive 10 $NEAR.

### Recurring Payments

Recurring payments are quite a common situation. If you need to send someone 10 $NEAR once a
month for 6 months, you could create a simple drop that has a usage config with an `interval` of 1 month.
In addition, you can set the time based config to have a `start` of  next week. Everytime the key is used, 
10 $NEAR is sent to the account. If the contractor missed a month's payment, they can claim the key late but 
can never use the key more than what is intended.

<p align="center">
  <img src="assets/flowcharts/recurring_payments.png" style="width: 65%; height: 65%" alt="Logo">
</p>

### Quick Onboarding

If you need to quickly onboard users onto NEAR, you could create a simple drop with a
small amount of $NEAR (enough to create a wallet) and set the usage's permissions to be
`create_account_and_claim`. This means that the key can only be used to create accounts.
You can then add keys as you wish to the drop and give them out to users so they can create
accounts and be onboarded onto NEAR.

### Lazy Registering Keys

A unique use-case for simple drops is the ability to lazy register key uses. This allows the funder to batch
create many keys at a time while only paying for basic fees such as the storage used and the key's allowance.
The funder would **not** need to pay for the `deposit_per_use` of each key up front. They can instead register individual
key uses as they are needed.

With this scenario, if an organization wanted to onboard users with a linkdrop valued at 10 $NEAR, they could create 1000 keys
without needing to pay 1000 * 10 = 10,000 $NEAR up-front. They could then register keys on an as-needed basis. If they need to
register 25 keys at a time, they can do this by simply calling the `register_uses` function.

## Non-Fungible Token Drops

Non-Fungible Token drops are a special type that allows users to "preload" the drop with NFTs.
These tokens will then be *automatically* sent to the **claiming user**. The claiming flow
is fairly similar to simple drops in that users can either create an account or claim to an
existing one.

NFT drops are essentially a wrapper around simple drops. All the functionalities that simple
drops have are carried over but now, users can receive an NFT as well as $NEAR. This brings
introduces some customization and uniqueness to the use-cases.

### How does it work?

Every drop has a field known as `registered_uses`. This tells the contract how many uses the
drop has across all its keys. For basic simple drops that are *not* lazy registering keys, this field 
doesn't matter since all the uses are paid for up-front when the drop is created or when keys are added. 
With NFT drops, however, there is a 2 step process:
- Firstly, the drop is created and all the $NEAR required is pre-paid for. This is the same as
simple drops, however, the `registered_uses` are set to 0.
- Once the drop is created, the owner must send the contract the NFTs in order for keys to be
usable. This process is done through the `nft_transfer_call` workflow baked into the NFT standards.
It's up to the owner to facilitate this process.

Whenever the contract receives tokens, it will push the ID to a vector. These IDs are **popped** off
whenever a key is used. A user will receive the most recent token sent to the contract as the
vector is acting like a *stack*.

### NFT Config

Along with the default global configurations for drops, if you'd like to create an NFT drop,
you must specify the following pieces of information when the drop is created.

```rust
pub struct NFTDataConfig {
    /// Which account ID will be sending the NFTs to the contract. If this is not specified, anyone can send NFTs for the specific drop.
    pub sender_id: Option<AccountId>,
    /// Which contract will the NFTs live on
    pub contract_id: AccountId,
}
```

By specifying this information, the drop is locked into only accepting NFTs from the specific contract and optionally from a specified sender account.

### Use Cases

NFT drops work really well for when you want to send a *pre-existing* NFT to a user along with
some $NEAR. Since NFT drops are a light wrapper around simple drops, most of the use-cases are
the same although people can now get NFTs as well. This means you can onboard a user with some
$NEAR **and** they *get an NFT* too.

## Fungible Token Drops

A Fungible Token drop is also a light wrapper around the simple drop. It works very similarly to how its NFT
counterpart does. First, you'll need to create the drop and then you can fund it with assets and register
key uses.

You can preload a drop with as many FTs as you'd like even if you don't have the keys yet. This will spike the
`registered_uses` and then you can create keys and slowly eat away from this "total supply" overtime. If the
drop runs out, you can send it more FTs to top up. All the keys in the FT drop will share from this supply
and everytime a key is used, the `registered_uses` will decrement and the "total supply" will get smaller.

### How does it work?

As mentioned in the NFT section, every drop has a field known as `registered_uses`. This tells the contract
how many uses the drop has across all its keys. For basic simple drops that are *not* lazy registering keys, this field 
doesn't matter since all the uses are paid for up-front when the drop is created or when keys are added.
With FT drops, however, there is a 2 step process:
- Firstly, the drop is created and all the $NEAR required is pre-paid for. This is the same as
simple drops, however, the `registered_uses` are set to 0.
- Once the drop is created, the owner must send the contract the FTs in order for keys to be
usable. This process is done through the `ft_transfer_call` workflow baked into the FT standards.
It's up to the owner to facilitate this process.

### FT Config

Along with the default global configurations for drops, if you'd like to create a FT drop,
you must specify the following pieces of information when the drop is created.

```rust
pub struct FTDataConfig {
    /// The contract that the FTs live on.
    pub contract_id: AccountId,
    /// The account ID that will be sending the FTs to the contract. If this is not specified, anyone can send FTs for the specific drop.
    pub sender_id: Option<AccountId>,
    /// How many FTs should the contract send *each time* a key is used.
    pub balance_per_use: U128,
}
```

By specifying this information, the drop is locked into only accepting FTs from the specific contract and optionally from a specified sender account.
you can send as many FTs as you'd like and can over-pay, you *must* send at **least** enough FTs in one call to cover
1 use. As an example, if a drop is created such that 10 FTs will be sent when a key is used, you must send **at least 10**
and cannot break it up into separate calls where you send 5 one time and 5 another.

### Use Cases

FT drops have some awesome flexibility due to the fact that they support all the functionalities of the Simple drops, just with
more use-cases and possibilities. Let's look at some use cases to see how fungible token drops can be used.

#### Recurring Payments

Recurring payments are quite a common situation. Let's say you need to send someone $50 USDC every week. You
could create a key with 5 uses that has a time config `interval` of 1 week. You would then pre-load maybe the
first week's deposit of $50 USDC and register 1 use or you could send $500 USDC for the first 10 weeks. At that
point, you would simply hand over the key to the user and they can claim once a week.

#### Backend Servers

Taking the recurring payments problem to another level, imagine that instead of leaving the claims up to the
contractor, you wanted to automatically pay them through a backend server. They would give you their NEAR account
and you would send them FTs. The problem is that you don't want to expose your full access key in the server.
By creating a FT drop, you can store **only the function call access key** created by Keypom in the server.
Your backend would them use the key to call the `claim` function and pass in the user's account ID to send
them the FTs.

#### Creating a Wallet with FTs

Another awesome use-case is to allow users to be onboarded onto NEAR and **also** receive FTs. As an example,
You could do a promotion where you're giving away $10 USDC to the first 100 users that sign up to your mailing
list. You can also give away QR codes at events that contain a new fungible token that you're launching. You can
simply create a FT drop and pre-load it with the FT of your choice. In addition, you can give it 0.02 $NEAR for
new wallets that are created.

You can pair this with setting the usage config's `refund_deposit` flag to true which would make it so that if anyone claims
the fungible tokens and they *already have a wallet*, it will automatically refund you the 0.02 $NEAR. That money should
only be used for the creation of new wallets. Since your focus is on the fungible tokens, you don't want to **force users**
to create a new wallet if they have one already by specifying the usage permissions to be `create_account_and_claim` but instead,
you want to be refunded in case they do.

## Function Call Drops

Function call drops are by far the most powerful feature that Keypom provides. FC drops allow **any** method on **any**
contract to be executed (with some exceptions). In addition, there are a huge variety of customizations and features you can choose from when
defining the drop that come on top of the global options. The possibilities are almost endless. State of the art NFT ticketing,
lazy minting NFTs, auto registration into DAOs, analytics for marketing at events and much more.

### How do FC Drops work?

Unlike NFT and FT drops, the function calls must have everything paid for **upfront**. There is no two step process
so the creation is similar to Simple drops. Once the drop is created and keys are added, you can immediately start using it.

#### Function Call Config

When creating the drop, you have quite a lot of customization available. At the top level, there is a FC drop global
config similar to how the *general* config works.

```rust
pub struct FCConfig {
    /// How much GAS should be attached to the function call if it's a regular claim.
    /// If this is used, you *cannot* go through conventional linkdrop apps such as mynearwallet
    /// since those *always* attach 100 TGas no matter what. In addition, you will only be able to
    /// call `claim` if this is specified. You cannot have an `attached_gas` parameter and also
    /// call `create_account_and_claim.
    pub attached_gas: Option<Gas>,
}
```

#### Method Data

In addition to the global config, the user can specify a set of what's known as `MethodData`. This represents the
information for the function being called. Within this data, there are also a few optional configurations you can use
to extend your use cases. You'll see how powerful these can be in the use cases [section](#use-cases).

```rust
pub struct MethodData {
    /// Contract that will be called
    pub receiver_id: AccountId,
    /// Method to call on receiver_id contract
    pub method_name: String,
    /// Arguments to pass in (stringified JSON)
    pub args: String,
    /// Amount of yoctoNEAR to attach along with the call
    pub attached_deposit: U128,
    /// Specifies what field the claiming account ID should go in when calling the function
    /// If None, this isn't attached to the args
    pub account_id_field: Option<String>,
    /// Specifies what field the drop ID should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    /// If Some(String), attach drop ID to args. Else, don't attach.
    pub drop_id_field: Option<String>,
    /// Specifies what field the key ID should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    /// If Some(String), attach key ID to args. Else, don't attach.
    pub key_id_field: Option<String>,
    // Specifies what field the funder id should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    // If Some(string), attach the funder ID to the args. Else, don't attach.
    pub funder_id_field: Option<String>,
    // What permissions does the user have when providing custom arguments to the function call?
    // By default, the user cannot provide any custom arguments
    pub user_args_rule: Option<UserArgsRule>,
}
```

The MethodData keeps track of the method being called, receiver, arguments, and attached deposit. In addition, there are
some optional fields that can be used to extend the use cases. If you have a contract that requires some more context from
Keypom such as the funder ID, drop ID, key ID, and account ID that used the key, these can all be specified.

We've kept it generic such that you can specify the actual argument name that these will be passed in as. For example, if you
had a contract that would lazy mint an NFT and it required the account to be passed in as `receiver_id`, you could specify
an `account_id_field` set to `receiver_id` such that Keypom will automatically pass in the account ID that used the key under the
field `receiver_id`. Similarly, inserting fields into nested arguments is quite trivial. 

Let's say you wanted to insert the account ID that claimed the drop into the `receiver_id` under metadata for the following args:
    
```json
args: {
    "token_id": "foobar",
    "metadata": {
        "receiver_id": INSERT_HERE
    }
}
```

You could specify the `account_id_field` as `metadata.receiver_id` and Keypom will automatically create the `receiver_id` field and insert it into `metadata`. This would work whether or not `metadata` was already present in the args.

> **NOTE:** The location for inserting the arguments *cannot* collide with another entry. In the above example, `token_id.receiver_id` could *NOT* be specified since `token_id` is mapped to `foobar` already.

This logic extends to the drop ID, and key Id as well.

#### Key Uses

For **every key use**, you can specify a *vector* of `MethodData` which allows you to execute multiple function calls each
time a key is used. These calls are scheduled 1 by 1 using a simple for loop. This means that most of the time, the function
calls will be executed in the order specified in the vector but it is not *guaranteed*.

It's important to note that the Gas available is split evenly between *all* the function calls and if there are too many,
you might run into issues with not having enough Gas. You're responsible for ensuring that this doesn't happen.

The vector of `MethodData` is *optional* for each key use. If a key use has `null` rather than `Some(Vector<MethodData>)`,
it will decrement the uses and work as normal such that the `timestamp, `start` etc. are enforced. The only
difference is that after the key uses are decremented and these checks are performed, the execution **finishes early**. The null
case does **not** create an account or send *any* funds. It doesn't invoke any function calls and simply *returns once the
checks are done*. This makes the null case act as a "burner" where you disregard any logic. This has many uses which will
be explored in the use cases [section](#use-cases).

If a key has more than 1 use, you can specify a *different vector* of `MethodData` for **each use**. As an example, you could
specify that the first use will result in a null case and the second use will result in a lazy minting function being called.
If you have multiple uses but want them all to do the same thing, you don't have to repeat the same data. Passing in only 1
vector of `MethodData` will result in  **all the uses** inheriting that data.

### Security for FC Drops

Since all FC drops will be signed by the Keypom contract, there are a few restrictions in place to avoid malicious behaviors.
To avoid users from stealing registered assets from other drops, the following methods cannot be called via FC Drops:

```rust
/// Which methods are prohibited from being called by an FC drop
const DEFAULT_PROHIBITED_FC_METHODS: [&str; 6] = [
    "nft_transfer",
    "nft_transfer_call",
    "nft_approve",
    "nft_transfer_payout",
    "ft_transfer",
    "ft_transfer_call",
];
```

In addition, the Keypom contract cannot be the receiver of any function call. This is to avoid people
from calling private methods through FC Drops.

#### Keypom Arguments

When a key is used and a function is called, there is a data structure that is **automatically** attached to the arguments.
This is known as the `keypom_args`. It contains the information that the drop creator specified in the `MethodData`. 

```rust
pub struct KeypomArgs {
    pub account_id_field: Option<String>,
    pub drop_id_field: Option<String>,
    pub key_id_field: Option<String>,
    pub funder_id_field: Option<String>
}
```

##### Motivation

Let's say there was an exclusive NFT contract that allowed the Keypom contract to mint NFTs as part of an FC drop. Only Keypom
was given access to mint the NFTs so they could be given out as linkdrops. The organizer only wanted links that were part of their
drop to be valid. For this reason, the NFT contract would only mint if Keypom called the `nft_mint` function and there was a field 
`series` passed in and it was equal to the drop ID created by the organizer.

Let's say the owner created an exclusive drop that happened to have a drop ID of 5. They could then go to the NFT contract
and restrict NFTs to only be minted if:
- `series` had a value of 5.
- The Keypom contract was the one calling the function.

In order for this to work, when creating the drop, the owner would need to specify that the`drop_id_field` was set to a value of `series`
such that the drop ID is correctly passed into the function.

The problem with this approach is that the NFT contract has no way of knowing which arguments were sent by the **user** when the drop 
was created `as part of the MethodData `args` and which arguments are automatically populated by the Keypom contract. There is nothing 
stopping a malicious user from creating a new drop that has an ID of 6 but hardcoding in the actual arguments that `series` should have 
a value of 5. In this case, the malicious drop would have *no* `drop_id_field` and the NFT contract would have no way of knowing that the 
`series` value is malicious.

This can be prevented if a new field is introduced representing what was automatically injected by the Keypom contract itself. At the
end of the day, Keypom will **always** send correct information to the receiving contracts. If those contracts have a way to know what has
been sent by Keypom and what has been manually set by users, the problem is solved. In the above scenario, the NFT contract would simply add
an assertion that the `keypom_args` had the `account_id_field` set to `Some(series)` meaning that the incoming `series` field was set by Keypom
and not by a malicious user.

### User Provided Arguments

In the `MethodData`, there is an optional field that determines whether or not users can provide their own arguments when claiming a linkdrop and what that behaviour will look like. This is known as the `user_args_rule` and can be one of the following:

```rs
/// When a user provides arguments for FC drops in `claim` or `create_account_and_claim`, what behaviour is expected?
/// For `AllUser`, any arguments provided by the user will completely overwrite any previous args provided by the drop creator.
/// For `FunderPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator. If there are any duplicate args, the drop funder's arguments will be used.
/// For `UserPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator, but if there are any duplicate keys, the user's arguments will overwrite the drop funder's.
pub enum UserArgsRule {
    AllUser,
    FunderPreferred,
    UserPreferred
}
```

By default, if `user_args_rule` is `None` / not provided, any user provided arguments will be completely disregarded. It would act as if the user provided *no args* in the first place.

These user arguments must be passed in via the `fc_args` field in `claim` and `create_account_and_claim`. This field is of type `Option<Vec<Option<String>>>` indicating that it's optional to provide the args and for each claim, a set of args can be provided. If, for a specific method, args shouldn't be passed in, the vector can have `None` as the value. The order of the args must match the order of the methods that will be executed.

> **NOTE:** If a user provides `fc_args`, the length of the vector *MUST* match the number of methods being executed during the claim.

#### All User

If `user_args_rule` is set to `AllUser`, any arguments provided by the user will completely *overwrite* any previous args provided by the drop creator. If no args as passed in by the user, the drop creator's original args will be used.

As an example, if the method data was:

```js
args: JSON.stringify({
    "foo": "bar",
    "baz": {
        "foo": "bar
    }
})
```

And the user provided the following args:

```js
fc_args: JSON.stringify({
    "new_field": "new_value"
})
```

Keypom would completely overwrite the funder's previous args and use the user's `fc_args` instead.

#### Funder Preferred

If `user_args_rule` is set to `FunderPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator. If there are any duplicate args, the drop funder's arguments will be prioritized / used.

As an example, if the funder args were:

```js
args: JSON.stringify({
    "funder_field": "funder_value",
    "object": {
        "funder_field": "funder_value"
    }
})
```

And the user provided the following args:

```js
fc_args: JSON.stringify({
    "funder_field": "user_value",
    "object": {
        "funder_field": "user_value",
        "user_field": "user_value"
    }
})
```

Keypom would take the user args and merge them together with the funder's but prioritize any fields that are funder specified. The resulting output would be:

```js
args: JSON.stringify({
    "funder_field": "funder_value",
    "object": {
        "funder_field": "funder_value",
        "user_field": "user_value"
    }
})
```

#### User Preferred

If `user_args_rule` is set to `UserPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator, but if there are any duplicate keys, the *user's arguments* will overwrite the drop funder's.

As an example, if the funder args were:

```js
args: JSON.stringify({
    "funder_field": "funder_value",
    "object": {
        "funder_field": "funder_value"
    }
})
```

And the user provided the following args:

```js
fc_args: JSON.stringify({
    "object": {
        "funder_field": "user_value",
        "user_field": "user_value"
    }
})
```

Keypom would take the user args and merge them together with the funder's but prioritize any fields that are *user specified*. The resulting output would be:

```js
args: JSON.stringify({
    "funder_field": "funder_value",
    "object": {
        "funder_field": "user_value",
        "user_field": "user_value"
    }
})
```

### FC Drop Use Cases

Function call drops are the bread and butter of the Keypom contract. They are the most powerful and complex drops that can currently be created.
With this complexity, there are an almost infinite number of use-cases that arise.

#### Proof of Attendance Protocols

A very common use case in the space is what's known as Proof of Attendance. Often times when people go to events, they want a way to prove
that they were there. Some traditional approaches would be to submit your wallet address and you would be sent an NFT or some other form of
proof at a later date. The problem with this is that it has a very high barrier to entry. Not everyone has a wallet.

With Keypom, you can create a function call drop that allows people to onboard onto NEAR if they don't have a wallet or if they do, they can
simply use that. As part of the onboarding / claiming process, they would receive some sort of proof of attendance such as an NFT. This can
be lazy minted on-demand such that storage isn't paid up-front for all the tokens.

At this point, the event organizers or the funder can distribute links to people that attend the event in-person. These links would then be
claimed by users and they would receive the proof of attendance.

#### Auto Registration into DAOs

DAOs are a raging topic in crypto. The problem with DAOs, however, is there is a barrier to entry for users that aren't familiar with the
specific chain they're built on top of. Users might not have wallets or understand how to interact with contracts. On the contrary, they
might be very well versed or immersed in the DAO's topics. They shouldn't be required to create a wallet and learn the onboarding process.

With Keypom, you can create a function call drop with the main purpose of registering users into a DAO. For people that have a wallet,
this will act as an easy way of registering them with the click of a link. For users that don't have a wallet and are unfamiliar with
NEAR, they can be onboarded and registered into the DAO with the same click of a link.

#### Multisig Contracts

Another amazing use-case for Keypom is allowing multisig contracts to have ZERO barrier to entry. Often times when using a multisig contract,
you will entrust a key to a trusted party. This party might have no idea what NEAR is or how to interact with your contract. With Keypom,
you can create a drop that will allow them to sign their transaction with a click of a link. No NEAR wallet is needed and no knowledge of the
chain is required.

At the end of the day, from the users perspective, they are given a link and when they click it, their portion of the multisig transaction is
signed. The action is only performed on the multisig contract once all links have been clicked. This is an extremely powerful way of doing
accomplishing multisig transactions with zero barrier to entry.

The users don't even need to create a new account. They can simply call `claim` when the link is clicked which will fire the cross-contract call
to the multisig contract and pass in the keypom arguments that will be cross-checked by that contract.

#### NFT Ticketing

The problem with current NFT ticketing systems is that they require users to have a wallet. This is a huge barrier to entry for people that
are attending events but don't have wallets. In addition, there is often no proof of attendance for the event as the NFT is burned in order
to get into the event which requires an internet connection.

Keypom aims to solve these problems by having a ticketing system that has the following features.
- No wallet is needed to enter the event or receive a POAP.
- No wifi is needed at the door.
- An NFT is minted on-demand for each user that attends the event.
- Users can optionally onboard onto NEAR if they don't have a wallet.

In addition, some way to provide analytics to event organizers that contains information such as links that were:
- Given out but not clicked at all.
- Clicked but not attended.
- Partially claimed indicating the number of people that attended but did not onboard or receive a POAP.
- Fully claimed indicating the number of people that attended and received a POAP.

In order to accomplish this, you can create a drop that has 3 uses per key. These uses would be:
1. Array(`null`)
2. Array(`null`)
3. Array(function call to POAP contract to lazy mint an NFT)

The event organizer would create the links and distribute them to people however they see fit. When a user receives the link, the first
claim is automatically fired. This is a `null` case so nothing happens except for the fact that the key uses are decremented. At this point,
the organizer knows that the user has clicked the link since the uses have been decremented.

The next claim happens **only** when the user is at the door. Keypom would expose a QR code that can only be scanned by the bouncer's phone.
This QR code would appear once the first link is clicked and contains the private key for the link. At the event, they wouldn't need any wifi
to get in as they only need to show the bouncer the QR code. Once the bouncer scans it, the site would ensure that they have exactly 2 out of
the 3 uses left. If they don't, they're not let in. At that point, a use is decremented from the key and the next time they visit the
ticket page (when they have internet), they would be able to claim the final use and be onboarded / receive a POAP.

<p align="center">
  <img src="assets/flowcharts/ticketing.png" style="width: 65%; height: 65%" alt="Logo">
</p>

## Password Protected Keys

Password protecting key uses is an extremely powerful feature that can unlock many use-cases. Keypom has baked flexibility and customization
into the contract such that almost all use-cases involving password protection can be accomplished. Whenever a key is added to a drop, it can
have a unique password for each individual use, or it can one password for all uses in general.

### How Does It Work?

The Keypom implementation has been carefully designed so that users can't look at the NEAR Explorer to view what was passed into the contract
either when the drop was created or when a key was used to try and copy those passwords. We also want passwords to be unique across keys so that
if you know the password for 1 key, it doesn't work on a different key. In order to accomplish this, we use the concept of hashing.

Imagine you have a drop with 2 keys and you want to password protect each key. Rather than forcing the drop funder to input a unique password for 
each key and having them remember each one, we can have them input a single **base password** and derive unique passwords from it that are paired 
with the key's public key.

This is the most scalable option as it allows the drop funder to only need to remember 1 password and they can derive all the other ones using the
hashing algorithm and public key.

In the above scenario, let's say the funder inputs the base password as `mypassword1`. If a user wanted to claim the first key, they would need to input
into the contract:

`hash("mypassword1" + key1_public_key)`

The funder would need to give the user this hash somehow (such as embedding it into the link or having an app that can derive it). It's important to note 
that the funder should probably **NOT** give them the base password otherwise the user could derive the passwords for all other keys (assuming those keys have 
the same base password).

### What is Stored On-Chain?

How does Keypom verify that the user passed in the correct password? If the funder were to simply pass in `hash("mypassword1" + key1_public_key)` into the
contract as an argument when the key is created, users could just look at the NEAR Explorer and copy that value. 

Instead, the funder needs to pass in a double hash when the key is created: `hash(hash("mypassword1" + key1_public_key))`. 

This is the value that is stored on-chain and when the user tries to claim the key, they would pass in just the single hash: `hash("mypassword1" + key1_public_key)`.  
The contract would then compute `hash(hash("mypassword1" + key1_public_key))` and compare it to the value stored on-chain. If they match, the key is claimed.

Using this method, the base password is not exposed to the user, nobody can look on-chain or at the NEAR explorer and derive the password, and the password is unique
across multiple keys.

## Passwords Per Key Use

Unlike the passwords per key which is the same for all uses of a key, the drop creator can specify a password for each individual key use. This password follows
the same pattern as the passwords per key in that the funder inputs a `hash(hash(SOMETHING))` and then the user would input `hash(SOMETHING)` and the contract
would hash this and compare it to the value stored on-chain.

The difference is that each individual key use can have a different value stored on-chain such that the user can be forced to input a different hash each time.
This `SOMETHING` that is hashed can be similar to the global password per key example but this time, the desired key use is added: `hash("mypassword1" + key1_public_key + use_number)`

In order to pass in the passwords per use, a new data structure is introduced so you only need to pass in passwords for the uses that have them. This is known as the 
`JsonPasswordForUse` and is as follows:

```rust
pub struct JsonPasswordForUse {
    /// What is the password for this use (such as `hash("mypassword1" + key1_public_key + use_number)`)
    pub pw: String,
    /// Which use does this pertain to
    pub key_use: u64
}
````

## Adding Your First Password

Whenever keys are added to Keypom, if there's passwords involved, they must be passed in using the following format. 

```rust
passwords_per_use: Option<Vec<Option<Vec<JsonPasswordForUse>>>>,
passwords_per_key: Option<Vec<Option<String>>>,
```

Each key that is being added either has a password, or doesn't. This is through the `Vec<Option<>`. This vector **MUST** be the same length as the number of keys created.This doesn't 
mean that every key needs a password, but the Vector must be the same length as the keys.

As an example, if you wanted to add 3 keys to a drop and wanted only the first and last key to have a password_per_key, you would pass in:
```rust
passwords_per_key: Some(vec![Some(hash(hash(STUFF))), None, Some(hash(hash(STUFF2)))])
```

## Complex Example

To help solidify the concept of password protected keys, let's go through a complex example. Imagine Alice created a drop with a `uses_per_key` of 3.
She wants to create 4 keys: 
- Key A: No password protection.
- Key B: Password for uses 1 and 2.
- Key C: Password for use 1 only.
- Key D: Password that doesn't depend on the use.

In this case, for Keys B and C, they will have the same base password but Alice wants to switch things up and have a different base password for Key D.
When these keys are added on-chain, the `passwords_per_key` will be passed in as such:

```rust
passwords_per_key: Some(vec![
    None, // Key A
    None, // Key B
    None, // Key C
    // Key D
    Some(
        hash(hash("key_d_base_password" + key_d_public_key))
    ), 
]),
```
The passwords for Key B and Key C will be passed in as such:

```rust
passwords_per_use: Some(vec![
    None, // Key A

    // Key B
    vec![
        {
            pw: hash(hash("keys_bc_base_password" + key_b_public_key + "1")),
            key_use: 1
        },
        {
            pw: hash(hash("keys_bc_base_password" + key_b_public_key + "2")),
            key_use: 2
        }
    ]

    // Key C
    vec![
        {
            pw: hash(hash("keys_bc_base_password" + key_c_public_key + "1")),
            key_use: 1
        }
    ]

    None // Key D
]),
```

The drop funder would then give the keys out to people:

### Key A
Alice gives Bob Key A and he would be able to claim it 3 times with no password required.

### Key D
Alice gives Charlie Key D and he would be able to claim it 3 times with the hashed global key password: `hash("key_d_base_password" + key_d_public_key)`.
When Charlie uses the key, he would input the password `hash("key_d_base_password" + key_d_public_key)` and the contract would hash that and check to see
if it matches what is stored on-chain (which it does).

If anyone tried to look at what Charlie passes in through the explorer, it wouldn't work since his hash contains the public key for key D and as such it is only
valid for Key D.

Similarly, if Charlie tried to look at the explorer when Alice created the keys and attempted to pass in `hash(hash("key_d_base_password" + key_d_public_key))`, 
the contract would attempt to hash this and it would NOT match up with what's in the storage.

### Key B
Alice gives Eve Key B and she would need a password for claim 1 and 2. For the first claim, she needs to pass in: `hash("keys_bc_base_password" + key_b_public_key + "1")`.
The contract would then check and see if the hashed version of this matches up with what's stored on-chain for that use.

The second time Eve uses the key, she needs to pass in `hash("keys_bc_base_password" + key_b_public_key + "2")` and the same check is done.

If Eve tries to pass in `hash("keys_bc_base_password" + key_b_public_key + "1")` for the second key use, the contract would hash it and check:

```
hash(hash("keys_bc_base_password" + key_b_public_key + "1")) == hash(hash("keys_bc_base_password" + key_b_public_key + "2"))
```

Which is incorrect and the key would not be claimed.

Once Eve uses the key 2 times, the last claim is not password protected and she's free to claim it.

Key C is similar to Key B except that it only has 1 password for the first use.

## Use-Cases

Password protecting key uses is a true game changer for a lot of use-cases spanning from ticketing to simple marketing and engagement.

#### Ticketing and POAPs

Imagine you had an event and wanted to give out exclusive POAPs to people that came. You didn't want to force users to: 
- Have a NEAR wallet
- Have wifi at the door.
- Burn NFTs or tokens to get into the event.

The important thing to note is that by using password protected key uses, you can **GUARANTEE** that anyone that received a POAP had to
**PHYSICALLY** show up to the event. This is because the POAP would be guarded by a password.

You could create a ticketing event using Keypom as outlined in the [Ticketing](#nft-ticketing) section and have a key with 2 uses. The first use 
would be password protected and the second use is not. The first use will get you through the door and into the event and the second
contains the exclusive POAP and can onboard you. This means that anyone with the ticket, or key, can only receive the POAP if they know the password.

You can have a scanner app that would scan people's tickets (tickets are just the private key). In this scanner app, the *base password* is stored and 
whenever the ticket is scanned, the public key is taken and the following hash is created:

`hash(base password + public key)`

This hash is then used to claim a use of the key and you will be let into the party. The scanner app can deterministically generate all the
necessary hashes for all the tickets by simply scanning the QR code (which has the private key exposed). The tickets are worthless unless
you actually show up to the event and are scanned.

Once you're scanned, you can refresh your ticket page and the use the second key claim which is not password protected. This use contains the
exclusive POAP and you can onboard onto NEAR.

#### Marketing and Engagement

Let's say that you're at an event and want people to show up to your talks and learn about your project. You can have a scanner app similar to the
one mentioned in the ticketing scenario that derives the password for any use on any key.

At the beginning of the event, you can give out a bunch of keys that have progressively increasing rewards gated by a password. At the end, the last
key use contains a special reward that is only unlocked if the user has claimed all the previous key uses.

In order for these uses to be unlocked, People must show up to your talks and get scanned. The scanner will derive the necessary password and unlock 
the rewards. Users will only get the exclusive reward if they come to ALL your talks.

This idea can be further expanded outside the physical realm to boost engagement on your websites as an example:

You want users to interact with new features of your site or join your mailing list.

You can have links where uses are ONLY unlocked if the user interacts with special parts of your site such as buying a new NFT or joining your mailing list 
or clicking an easter egg button on your site etc.

## dApp Free Trials for Users

In the upcoming Keypom V2.0, dApps will be able to integrate the Keypom wallet selector plugging to allow for free trials for their users. One of the biggest pain-points with Web3 at the moment is the fact that users need to fund wallets *before* they interact with a dApp.

In Web2, a user can find value in an application by using it before they go through the messy onboarding process. Why can't Web3 be the same?

Keypom will allow apps to create links that will automatically sign users into their applications and give them a free trial of the app. The user will be able to interact with things, spend $NEAR, sign transactions and gather assets through the trial. A unique feature of this is that the user will *never be redirected to the NEAR wallet* to approve transactions.

Keypom will provide a seamless user experience where users can find value in applications. Once the free trial is over and users have collected assets / $NEAR through interacting with the dApp, they can *THEN* choose to onboard.

With Keypom's technology, users will be locked into only interacting with the dApp specified in the link. Users can't rug the application and steal the $NEAR embedded in the link. The funds are allocated for 1 thing and 1 thing only: free trials of that one specific dApp.

<p align="center">
  <img src="assets/flowcharts/trial_accounts.png" style="width: 65%; height: 65%" alt="Logo">
</p>

# Costs

It is important to note that the Keypom contract is 100% **FEE FREE** and will remain that way for the *forseeable future*. This contract is a public good and is meant to inspire change in the NEAR ecosystem.

With that being said, there are several mandatory costs that must be taken into account when using Keypom. These costs are broken down into two categories: per key and per drop.

> **NOTE:** Creating an empty drop and then adding 100 keys in separate calls will incur the same cost as creating a drop with 100 keys in the same call.

## Per Drop

When creating an empty drop, there is only one cost to keep in mind regardless of the drop type:
- Storage cost (**~0.006 $NEAR** for simple drops)

## Per Key
Whenever keys are added to a drop (either when the drop is first created or at a later date), the costs are outlined below.

### Key Costs for Simple Drop

- $NEAR sent whenever the key is used (can be 0).
- Access key allowance (**~0.0187 $NEAR per use**).
- Storage for creating access key (**0.001 $NEAR**).
- Storage cost (**~0.006 $NEAR** for simple drops)

### Additional Costs for NFT Drops

Since keys aren't registered for use until **after** the contract has received the NFT, we don't know how much storage the token IDs will use on the contract. To combat this, the Keypom contract will automatically measure the storage used up for storing each token ID in the `nft_on_transfer` function and that $NEAR will be taken from the funder's balance.

### Additional Costs for FT Drops

Since accounts claiming FTs may or may not be registered on the Fungible Token contract, Keypom will automatically try to register **all** accounts. This means that the drop creators must front the cost of registering users depending on the `storage_balance_bounds` returned from the FT contract. This applies to every use for every key.

In addition, Keypom must be registered on the FT contract. If you create a FT drop and are the first person to ever do so for a specific FT contract on Keypom, Keypom will be automatically registered when the drop is created. This is a one time cost and once it is done, no other account will need to register Keypom for that specific FT contract.

### Additional Costs for FC Drops

Drop creators have a ton of customization available to them when creation Function Call drops. A cost that they might incur is the attached deposit being sent alongside the function call. Keypom will charge creators for all the attached deposits they specify.

> **NOTE:** The storage costs are dynamically calculated and will vary depending on the information you store on-chain.

## Deleting Keys and Drops

Creators have the ability to delete drops and keys at any time. In this case, **all** the initial costs they incurred for the remaining keys will be refunded to them (minus Gas fees of course).

## Automatic Refunds When Keys are Used

One way that Keypom optimizes the fee structure is by performing automatic refunds for some of the initial costs that creators pay for when keys are used. All the storage that is freed along with any unused allowance is automatically sent back to the creator whenever a key is used. This model drastically reduces the overall costs of creating drops and creates incentives for the keys to be used. 

## Account Balances for Smooth UX

In order to make the UX of using Keypom seamless, the contract introduces a debiting account model. All costs and refunds go through your account's balance which is stored on the contract. This balance can be topped up or withdrawn at any moment using the `add_to_balance()`  and `withdraw_from_balance()` functions.

This account balance is not *required*, however. You can create a drop by attaching a deposit to the call. Keep in mind that this will create an account balance for you behind the scenes, however.

</td>
</tr>
</table>

## Built With

- [near-sdk-rs](https://github.com/near/near-sdk-rs)
- [near-api-js](https://github.com/near/near-api-js)

# How Linkdrops Work

For some background as to how linkdrops works on NEAR: 

*The funder that has an account and some $NEAR:* 
- creates a keypair locally `(pubKey1, privKey1)`. The blockchain doesn't know of this key's existence yet since it's all local for now.
- calls `send` on the contract and passes in the `pubKey1` as an argument as well as the desired `balance` for the linkdrop.
    - The contract will map the `pubKey1` to the desired `balance` for the linkdrop.
    - The contract will then add the `pubKey1` as a **function call access key** with the ability to call `claim` and `create_account_and_claim`. This means that anyone with the `privKey1` that was created locally, can claim this linkdrop. 
- Funder will then create a link to send to someone that contains this `privKey1`. The link follows the following format: 
```
    wallet.testnet.near.org/linkdrop/{fundingContractAccountId}/{linkdropKeyPairSecretKey}?redirectUrl={redirectUrl}
```
* `fundingContractAccountId`: The contract accountId that was used to send the funds.
* `linkdropKeyPairSecretKey`: The corresponding secret key to the public key sent to the contract.
* `redirectUrl`: The url that wallet will redirect to after funds are successfully claimed to an existing account. The URL is sent the accountId used to claim the funds as a query param.

*The receiver of the link that is claiming the linkdrop:* 
- Receives the link which includes `privKey1` and sends them to the NEAR wallet.
- Wallet creates a new keypair `(pubKey2, privKey2)` locally. The blockchain doesn't know of this key's existence yet since it's all local for now.
- Receiver will then choose an account ID such as `new_account.near`. 
- Wallet will then use the `privKey1` which has access to call `claim` and `create_account_and_claim` in order to call `create_account_and_claim` on the contract.
    - It will pass in `pubKey2` which will be used to create a full access key for the new account.
- The contract will create the new account and transfer the funds to it alongside any NFT or fungible tokens pre-loaded.

</p>

# Getting Started

There are several ways to get started using Keypom. You can use the NEAR CLI, our Keypom application, our Keypom SDK and more. In this section, we will go over how you can interact with Keypom and create drops using the NEAR-API-JS library and write simple node scripts.

## Prerequisites

In order to successfully interact with this contract using the deploy scripts, you should have the following: 

- [NEAR account](https://docs.near.org/concepts/basics/account)
- [Node JS](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

## Deploy Scripts

There are 4 deploy scripts that have been made available for you to use and easily create Keypom links. These are for:
- Simple Drops
- NFT Drops
- FT Drops
- Function Call Drops

Each drop type deploy script has a version using `NEAR-API-JS`, and a version using the `Keypom-JS SDK`.

The file tree for these scripts is shown below. 

```bash
/deploy
├── ft
│   └── configurations.js
│   └── ft-create-sdk.js
│   └── ft-create.js
│
├── function-call
│   └── configurations.js
│   └── fc-create-sdk.js
│   └── fc-create.js
│
├── nft
│   └── configurations.js
│   └── nft-create-sdk-minted.js
│   └── nft-create-sdk-owned.js
│   └── nft-create.js
│
├── simple
│   └── configurations.js
│   └── simple-create-sdk.js
│   └── simple-create.js
│
├── utils
```

In order to use these scripts, open the `deploy/` directory and modify the `configurations.js` file for the drop you want to create. In this file, you can specify important information such as the number of keys you wish to create, the amount of $NEAR you want to send, how many uses per key etc.

You must specify the account that you will fund the drops with under the `FUNDING_ACCOUNT_ID` variable. This account needs to have keys stored in your `~/.near-credentials` folder. To do this, simply run `near login` on your terminal and follow the prompts using the NEAR CLI.

Once the `configurations.js` file has been modified to your liking, navigate back to the
root directory and run the deploy script.

For simple drops:
```
// Using NEAR-API-JS
yarn simple

// Using SDK
yarn simple-sdk
```
For FT drops:
```
// Using NEAR-API-JS
yarn ft

// Using SDK
yarn ft-sdk
```
For NFT drops:
```
// Using NEAR-API-JS
yarn nft

// Using SDK
yarn nft-sdk
```
For Function Call drops:
```
// Using NEAR-API-JS
yarn fc

// Using SDK
yarn fc-sdk
```

# Query Information From Keypom

Keypom allows users to query a suite of different information from the contract. This information can be broken down into two separate objects that are returned. JsonDrops and JsonKeys.
```rs
pub struct JsonDrop {
    // Drop ID for this drop
    pub drop_id: DropId,
    // owner of this specific drop
    pub owner_id: AccountId,
    // Balance for all keys of this drop. Can be 0 if specified.
    pub deposit_per_use: U128,
    // Every drop must have a type
    pub drop_type: JsonDropType,
    // The drop as a whole can have a config as well
    pub config: Option<DropConfig>,
    // Metadata for the drop
    pub metadata: Option<DropMetadata>,
    // How many uses are registered
    pub registered_uses: u64,
    // Ensure this drop can only be used when the function has the required gas to attach
    pub required_gas: Gas,
    // Keep track of the next nonce to give out to a key
    pub next_key_id: u64,
}

pub struct JsonKeyInfo {
    // Drop ID for the specific drop
    pub drop_id: DropId,
    pub pk: PublicKey,
    // How many uses this key has left. Once 0 is reached, the key is deleted
    pub remaining_uses: u64,
    // When was the last time the key was used
    pub last_used: u64,
    // How much allowance does the key have left. When the key is deleted, this is refunded to the funder's balance.
    pub allowance: u128,
    // Nonce for the current key.
    pub key_id: u64,
}
```

## Key Specific
- **`get_key_balance(key: PublicKey)`**: Returns the $NEAR that will be sent to the claiming account when the key is used 
- **`get_key_total_supply()`**: Returns the total number of keys currently on the contract
- **`get_keys(from_index: Option<U128>, limit: Option<u64>)`**: Paginate through all keys on the contract and return a vector of key info
- **`get_key_information(key: PublicKey)`**: Return the key info for a specific key
- **`get_key_information_batch(keys: Vec<PublicKey>)`**: Return a vector of key info for a set of public keys

## Drop Specific
- **`get_drop_information(drop_id: Option<DropId>, key: Option<PublicKey>)`**: Return the drop info for a specific drop. This can be queried for by either passing in the drop ID or a public key.
- **`get_key_supply_for_drop(drop_id: DropId)`**: Return the total number of keys for a specific drop
- **`get_keys_for_drop(drop_id: DropId, from_index: Option<U128>, limit: Option<u64>)`**: Paginate through all keys for a specific drop and return a vector of key info
- **`get_drop_supply_for_owner(account_id: AccountId)`**: Return the total number of drops for a specific account
- **`get_drops_for_owner(account_id: AccountId, from_index: Option<U128>, limit: Option<u64>)`**: Paginate through all drops for a specific account and return a vector of drop info 
- **`get_nft_supply_for_drop(drop_id: DropId)`**: Get the total number of NFTs registered for a given drop.
- **`get_nft_token_ids_for_drop(drop_id: DropId, from_index: Option<U128>, limit: Option<u64>)`**: Paginate through token IDs for a given drop
- **`get_next_drop_id()`**: Get the next drop ID that will be used for a new drop

### Utility
- **`get_root_account()`**: Get the global root account that all created accounts with be based off.
- **`get_user_balance()`**: Get the current user balance for a specific account.

# Running the Keypom Tests

We have put together a suite of test cases that can be found in the `__tests__` folder. These range anywhere from simple config tests all the way to full blown ticketing and POAPs.

In the `__tests__` folder, there are sub-folders with each type of test. Some of these sub-folders contain a `utils` folder with some utility functions used.

All the tests use `workspaces-js`. In order to run all the tests, run the following command.

```bash
yarn && yarn test
```

This will run through each test 1 by 1. If you wish to only run a set of specific tests, the full list of commands can be found below.

```bash
"test:internals"
"test:stage1"
"test:stage1:simple"
"test:ticketing"
"test:poaps"
"test:configs"
"test:nft-drops"
"test:ft-drops"
"test:profiling"
"test:passwords"
```

# Contributing

First off, thanks for taking the time to contribute! Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**.

Please try to create bug reports that are:

- _Reproducible._ Include steps to reproduce the problem.
- _Specific._ Include as much detail as possible: which version, what environment, etc.
- _Unique._ Do not duplicate existing opened issues.
- _Scoped to a Single Bug._ One bug per report.

Please adhere to this project's [code of conduct](docs/CODE_OF_CONDUCT.md).

You can use [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli) to check for common markdown style inconsistency.

# License

This project is licensed under the **GPL License**.

# Acknowledgements

Thanks for these awesome resources that were used during the development of the **Keypom Contract**:

- <https://github.com/dec0dOS/amazing-github-template>
- <https://github.com/near/near-linkdrop>
- <https://github.com/near/near-wallet/blob/master/packages/frontend/docs/Linkdrop.md>

'''
'''--- __tests__/claims/constants-tweaking.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    // ************** NFT SETUP **************
    // let nftAccounts: NearAccount[] = []

    // const nftContract1 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract1)
    // const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract2)
    // const nftContract3 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract3)
    // const nftContract4 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract4)
    // const nftContract5 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract5)
    // const nftContract6 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract6)
    // const nftContract7 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract7)
    // const nftContract8 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract8)
    // const nftContract9 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract9)
    // const nftContract10 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract10)
    // const nftContract11 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract11)
    // const nftContract12 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract12)
    // const nftContract13 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract13)
    // const nftContract14 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract14)
    // const nftContract15 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract15)
    // const nftContract16 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract16)
    // const nftContract17 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // nftAccounts.push(nftContract17)
    // // const nftContract18 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // // nftAccounts.push(nftContract18)
    //
    // for(let i = 0; i < nftAccounts.length; i++){
    //     await nftAccounts[i].call(nftAccounts[i], 'new_default_meta', { owner_id: nftAccounts[i]});
    //     await functionCall({
    //         signer: funder,
    //         receiver: nftAccounts[i],
    //         methodName: 'nft_mint',
    //         args: {
    //             token_id: "token1",
    //             metadata: {
    //                 title: "my token"
    //             },
    //             receiver_id: funder.accountId
    //         },
    //         attachedDeposit: NEAR.parse("1").toString(),
    //         shouldLog: false
    //     })
    // }
    
     // ************** FT Setup **************
     let ftAccounts: NearAccount[] = []

     const ftContract1 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);

     const ftContract2 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract3 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract4 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract5 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract6 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract7 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract8 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
     const ftContract9 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);

    //  const ftContract10 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract11 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract12 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract13 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract14 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract15 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract16 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    //  const ftContract17 = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);

     ftAccounts.push(ftContract1)

     ftAccounts.push(ftContract2)
     ftAccounts.push(ftContract3)
     ftAccounts.push(ftContract4)
     ftAccounts.push(ftContract5)
     ftAccounts.push(ftContract6)
     ftAccounts.push(ftContract7)
     ftAccounts.push(ftContract8)
     ftAccounts.push(ftContract9)

    //  ftAccounts.push(ftContract10)
    //  ftAccounts.push(ftContract11)
    //  ftAccounts.push(ftContract12)
    //  ftAccounts.push(ftContract13)
    //  ftAccounts.push(ftContract14)
    //  ftAccounts.push(ftContract15)
    //  ftAccounts.push(ftContract16)
    //  ftAccounts.push(ftContract17)

    for(let i = 0; i < ftAccounts.length; i++){
        console.log(`Initializing ${ftAccounts[i].accountId}`)
        await ftAccounts[i].call(ftAccounts[i], 'new_default_meta', { owner_id: ftAccounts[i], total_supply: totalSupply.toString() });
        await functionCall({signer: ftAccounts[i], receiver: ftAccounts[i], methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("10").toString(), shouldLog: false})
        await functionCall({signer: ftAccounts[i], receiver: ftAccounts[i], methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("10").toString(), shouldLog: false})
        await functionCall({signer: ftAccounts[i], receiver: ftAccounts[i], methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    }

    
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    // t.context.accounts = { root, funder, keypomV3, 
    //     nftContract1, 
    //     nftContract2, 
    //     nftContract3, 
    //     nftContract4, 
    //     nftContract5, 
    //     nftContract6, 
    //     nftContract7, 
    //     nftContract8, 
    //     nftContract9, 
    //     nftContract10, 
    //     nftContract11, 
    //     nftContract12, 
    //     nftContract13, 
    //     nftContract14, 
    //     nftContract15, 
    //     nftContract16,
    //     nftContract17,
    //     ali };
    t.context.accounts = { root, funder, keypomV3, 
        ftContract1, 

        ftContract2, 
        ftContract3, 
        ftContract4, 
        ftContract5, 
        ftContract6, 
        ftContract7, 
        ftContract8, 
        ftContract9, 

        // ftContract10, 
        // ftContract11, 
        // ftContract12, 
        // ftContract13, 
        // ftContract14, 
        // ftContract15, 
        // ftContract16,
        // ftContract17,
        ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// EXPECTED CAAC FAILIURE BEHAVIOUR
// Failed CAAC:
// - no assets transferred
// - Check if key is properly deleted in the case that it’s 0 remaining uses and check if it isn’t deleted in other case
// - Make sure drop is deleted ONLY if it’s empty of keys and has no funded assets in it (i.e FTs & NFTs)
// - If drop is deleted, only NEAR assets and FT registration cost should be refunded back to user balance

// - account creation failed -> should refund ALL assets & key is decremented
// - account creation succeeded but asset claims failed -> should refund assets that failed and do nothing for ones that weren’t

// test('Sanity Check', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAssetAmount: number = 1
//     const ftRegistrationCost: number =  1

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     const ftAsset1: ExtFTData = {
//         ft_contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("1").toString(),
//         ft_amount: ftRegistrationCost.toString()
//     }

//     // bunch of asset IDs
//     const nftAssets: ExtNFTData[] = []
//     const expectedNFTs: InternalNFTData[] = []
//     // 12 was ok with long
//     for(let i = 1; i <= 14; i++){
//         let num: string = (i < 10) ? '0' + i.toString() : i.toString();
//         // let new_contract_id: string = num + "1690235236996169023523699616902352369961690235236996.test.near";
//         let new_contract_id: string = num + "abc.test.near";
//         nftAssets.push({nft_contract_id: new_contract_id})
//         expectedNFTs.push({contract_id: new_contract_id, token_ids: []})
//     }
//     console.log(nftAssets)

//     const asset_data_per_use = {
//         // Max amount of spoof NFTs that will still pass
//         1: {
//             assets: nftAssets
//         },
//         // Max number of FT assets under 300T in estimation
//         2: {
//             assets: [ftAsset1, ftAsset1, ftAsset1, ftAsset1, ftAsset1,
//                      ftAsset1, ftAsset1, ftAsset1, ftAsset1]
//         },
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("1").toString(),
//     })

//     await sendFTs(funder, "10", keypomV3, ftContract1, dropId)
    

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '10',
//         }],
//         expectedNftData: expectedNFTs,
//     })

//     // 2 uses at the start
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 2)

//     // starting claim NEAR and FT balance
//     let preClaimFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
//     let userPreClaimFTBal= await ftContract1.view("ft_balance_of", {account_id: ali.accountId});
//     let userPreClaimNEARBal: {available: NEAR} = await ali.balance()

//     // First failed claim
//     let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key uses should have decremented
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 1)

//     // Second failed claim
//     result = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key should be deleted but drop should still exist
//     t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), false)

// });

// test('NFT Const Tweaking', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, 
//         nftContract2, 
//         nftContract3, 
//         nftContract4, 
//         nftContract5, 
//         nftContract6, 
//         nftContract7, 
//         nftContract8, 
//         nftContract9, 
//         nftContract10, 
//         nftContract11, 
//         nftContract12, 
//         nftContract13, 
//         nftContract14, 
//         nftContract15, 
//         nftContract16,
//         nftContract17,
//          ali} = t.context.accounts;
    
//     let nftAccounts: NearAccount[] = [ nftContract1, 
//         nftContract2, 
//         nftContract3, 
//         nftContract4, 
//         nftContract5, 
//         nftContract6, 
//         nftContract7, 
//         nftContract8, 
//         nftContract9, 
//         nftContract10, 
//         nftContract11, 
//         nftContract12, 
//         nftContract13, 
//         nftContract14, 
//         nftContract15, 
//         nftContract16,
//         nftContract17,
//         ]
    
//     let initialBal = await keypomV3.balance();

//     const nearAssetAmount: number = 1
//     const ftRegistrationCost: number =  1

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     // ******************* EMPTIES *******************
//     // const nftAssets: ExtNFTData[] = []
//     // const expectedNFTs: InternalNFTData[] = []
//     // for(let i = 1; i <= 17; i++){
//     //     let num: string = (i < 10) ? '0' + i.toString() : i.toString();
//     //     let new_contract_id: string = num + "1690235236996169023523699616902352369961690235236996.test.near";
//     //     // let new_contract_id: string = num + "abc.test.near";
//     //     nftAssets.push({nft_contract_id: new_contract_id})
//     //     expectedNFTs.push({contract_id: new_contract_id, token_ids: []})
//     // }

//     // const asset_data_per_use = {
//     //     // Max amount of spoof NFTs that will still pass226/18
//     //     1: {
//     //         assets: nftAssets
//     //     },
//     // }

//     // ******************* ACTUAL *******************
//     // const nftAsset1: ExtNFTData = {
//     //     nft_contract_id: nftContract1.accountId
//     // }

//     // const asset_data_per_use = {
//     //     // Max amount of spoof NFTs that will still pass226/18
//     //     1: {
//     //         assets: Array(17).fill(nftAsset1)
//     //     },
//     // }

//     // ******************* BIG BOY *******************
//     let nftAssets: ExtNFTData[] = [];
//     let expectedNftAssets: InternalNFTData[] = [];
//     for(let i = 0 ; i < nftAccounts.length; i++){
//         nftAssets.push({nft_contract_id: nftAccounts[i].accountId})
//         expectedNftAssets.push({contract_id: nftAccounts[i].accountId, token_ids: ["token1"]})
//     }

//     const asset_data_per_use = {
//         // Max amount of spoof NFTs that will still pass226/18
//         1: {
//             assets: nftAssets
//         },
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("1").toString(),
//     })

    
     
//     // ******************* ACTUAL *******************
//     // let tokenIds: string[] = [];

//     // for(let i = 1; i<=17; i++){
//     //     // let tokenId = `token-1-${i}`
//     //     let tokenId = `token1`

//     //     await functionCall({
//     //         signer: funder,
//     //         receiver: nftContract1,
//     //         methodName: 'nft_mint',
//     //         args: {
//     //             token_id: tokenId,
//     //             metadata: {
//     //                 title: "my token",
//     //                 description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
//     //                 media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
//     //             },
//     //             receiver_id: funder.accountId
//     //         },
//     //         attachedDeposit: NEAR.parse("0.01").toString(),
//     //         shouldLog: true
//     //     })

//     //     await functionCall({
//     //         signer: funder,
//     //         receiver: nftContract1,
//     //         methodName: 'nft_transfer_call',
//     //         args: {
//     //             receiver_id: keypomV3.accountId,
//     //             token_id: tokenId,
//     //             msg: dropId
//     //         },
//     //         attachedDeposit: "1"
//     //     })

//     //     tokenIds.push(tokenId)
//     // }

//     // ******************* BIG BOY *******************
//     let tokenIds: string[] = [];

//     for(let i = 0; i < nftAccounts.length; i++){
//         // let tokenId = `token-1-${i}`
//         let tokenId = `token1`

//         await functionCall({
//             signer: funder,
//             receiver: nftAccounts[i],
//             methodName: 'nft_transfer_call',
//             args: {
//                 receiver_id: keypomV3.accountId,
//                 token_id: tokenId,
//                 msg: dropId
//             },
//             attachedDeposit: "1"
//         })

//         tokenIds.push(tokenId)
//     }
    
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedNftData: expectedNftAssets,
//     })

//     // ******************* EMPTIES *******************
//     // await assertKeypomInternalAssets({
//     //     keypom: keypomV3,
//     //     dropId,
//     //     expectedNftData: expectedNFTs,
//     // })

//     // First legit claim to get to 2nd use
//     let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//     })
//     t.is(result.response, "true")

//     // Key should be deleted but drop should still exist
//     t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), true)

// });

test('FT Const Tweaking', async t => {
    const {funder, keypomV3, root,  
        ftContract1, 
        ftContract2, 
        ftContract3, 
        ftContract4, 
        ftContract5, 
        ftContract6, 
        ftContract7, 
        ftContract8, 
        ftContract9, 
        ftContract10, 
        ftContract11, 
        ftContract12, 
        ftContract13, 
        ftContract14, 
        ftContract15, 
        ftContract16,
        ftContract17,
         ali} = t.context.accounts;
    
    let ftAccounts: NearAccount[] = [ 
        ftContract1, 
        ftContract2, 
        ftContract3, 
        ftContract4, 
        ftContract5, 
        ftContract6, 
        ftContract7, 
        ftContract8, 
        ftContract9, 
        ]
    
    let initialBal = await keypomV3.balance();

    const nearAssetAmount: number = 1
    const ftRegistrationCost: number =  1

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);
    let under_max = 2;

    // ******************* EMPTIES *******************
    // let ftAssets: ExtFTData[] = []
    // let expectedFTs: {contract_id: string, balance_avail: string}[] = []
    // for(let i = 1; i <= 9; i++){
    //     let num: string = (i < 10) ? '0' + i.toString() : i.toString();
    //     let new_contract_id: string = num + "1690235236996169023523699616902352369961690235236996.test.near";
    //     // let new_contract_id: string = num + "abc.test.near";
    //     ftAssets.push({ft_contract_id: new_contract_id, registration_cost: "0", ft_amount: "0"})
    //     expectedFTs.push({contract_id: new_contract_id, balance_avail: "0"})
    // }

    // const asset_data_per_use = {
    //     // Max amount of spoof NFTs that will still pass226/18
    //     1: {
    //         assets: ftAssets
    //     },
    // }

    // ******************* ACTUAL *******************
    // const nftAsset1: ExtNFTData = {
    //     nft_contract_id: nftContract1.accountId
    // }

    // const asset_data_per_use = {
    //     // Max amount of spoof NFTs that will still pass226/18
    //     1: {
    //         assets: Array(17).fill(nftAsset1)
    //     },
    // }

    // ******************* BIG BOY *******************
    let ftAssets: ExtFTData[] = [];
    let expectedFtAssets: {contract_id: string, balance_avail: string}[] = [];
    for(let i = 0 ; i < ftAccounts.length - under_max; i++){
        ftAssets.push({ft_contract_id: ftAccounts[i].accountId, registration_cost: NEAR.parse("1").toString(), ft_amount: "1"});
        expectedFtAssets.push({contract_id: ftAccounts[i].accountId, balance_avail: "1"})
    }

    const asset_data_per_use = [
        // Max amount of spoof NFTs that will still pass226/18
        {
            assets: ftAssets
        },
    ]
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{public_key: keyPairs.publicKeys[0]}]
            // public_keys: [keyPairs.publicKeys[0]]
        },
        attachedDeposit: NEAR.parse("10").toString(),
    })

     
    // ******************* ACTUAL *******************
    // let tokenIds: string[] = [];

    // for(let i = 1; i<=17; i++){
    //     // let tokenId = `token-1-${i}`
    //     let tokenId = `token1`

    //     await functionCall({
    //         signer: funder,
    //         receiver: nftContract1,
    //         methodName: 'nft_mint',
    //         args: {
    //             token_id: tokenId,
    //             metadata: {
    //                 title: "my token",
    //                 description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
    //                 media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
    //             },
    //             receiver_id: funder.accountId
    //         },
    //         attachedDeposit: NEAR.parse("0.01").toString(),
    //         shouldLog: true
    //     })
 
    //     await functionCall({
    //         signer: funder,
    //         receiver: nftContract1,
    //         methodName: 'nft_transfer_call',
    //         args: {
    //             receiver_id: keypomV3.accountId,
    //             token_id: tokenId,
    //             msg: dropId
    //         },
    //         attachedDeposit: "1"
    //     })

    //     tokenIds.push(tokenId)
    // }

    // ******************* BIG BOY *******************
    for(let i = 0; i < ftAccounts.length - under_max; i++){
        console.log(`Sending FTs from ${ftAccounts[i].accountId}`)
        await sendFTs(funder, "1", keypomV3, ftAccounts[i], dropId)
    }
    
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: expectedFtAssets
    })

    // ******************* EMPTIES *******************
    // await assertKeypomInternalAssets({
    //     keypom: keypomV3,
    //     dropId,
    //     expectedFtData: expectedFtAssets,
    //     expectedNftData: []
    // })

    // First legit claim to get to 2nd use
    let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
        keypom: keypomV3,
        root,
        keyPair: keyPairs.keys[0],
        createAccount: true,
    })
    t.is(result.response, "true")

    // Key should be deleted but drop should still exist
    t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)

});

'''
'''--- __tests__/claims/create-account-and-claim.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');

    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    let nftAccounts: NearAccount[] = []

    const nftContract1 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    nftAccounts.push(nftContract1)
    

    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });

    for(let i = 0; i < nftAccounts.length; i++){
        await nftAccounts[i].call(nftAccounts[i], 'new_default_meta', { owner_id: nftAccounts[i]});
        await functionCall({
            signer: funder,
            receiver: nftAccounts[i],
            methodName: 'nft_mint',
            args: {
                token_id: "token1",
                metadata: {
                    title: "my token"
                },
                receiver_id: funder.accountId
            },
            attachedDeposit: NEAR.parse("1").toString(),
            shouldLog: false
        })
    }

    // const ftContract1 = await root.createSubAccount('ft_contract_1');
    // const ftContract2 = await root.createSubAccount('ft_contract_2');

    // await ftContract1.deploy(`./__tests__/ext-wasm/ft.wasm`);
    // await ftContract2.deploy(`./__tests__/ext-wasm/ft.wasm`);

    
    // await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    // await ftContract2.call(ftContract2, 'new_default_meta', { owner_id: ftContract2, total_supply: totalSupply.toString() });

    // Deposit storage
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // // Send FTs
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    // // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, nftContract1, ali };
    t.context.accounts = { root, funder, keypomV3, 
        nftContract1,
        ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// EXPECTED CAAC FAILIURE BEHAVIOUR
// Failed CAAC:
// - no assets transferred
// - Check if key is properly deleted in the case that it’s 0 remaining uses and check if it isn’t deleted in other case
// - Make sure drop is deleted ONLY if it’s empty of keys and has no funded assets in it (i.e FTs & NFTs)
// - If drop is deleted, only NEAR assets and FT registration cost should be refunded back to user balance

// - account creation failed -> should refund ALL assets & key is decremented
// - account creation succeeded but asset claims failed -> should refund assets that failed and do nothing for ones that weren’t

// account creation failed -> should refund ALL assets & key is decremented (NFT version)
// test('Account Creation Fail in CAAC - drop still contains NFTs', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     const nftAsset1 = {
//         nft_contract_id: nftContract.accountId
//     }

//     const asset_data_per_use = {
//         1: {
//             assets: [nftAsset1]
//         },
//         2: {
//             assets: [null]
//         }
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("1").toString(),
//     })

//     // 12TGas for NFT asset, 20 tokens + other gas = 293TGas
//     let tokenIds: string[]= [];
//     let numTokens = 1;
//     for (let i = 1; i < numTokens+1; i++) {
//         let tokenId = `token-1-${i}`

//         await functionCall({
//             signer: funder,
//             receiver: nftContract,
//             methodName: 'nft_mint',
//             args: {
//                 token_id: tokenId,
//                 metadata: {
//                     title: "my token"
//                 },
//                 receiver_id: funder.accountId
//             },
//             attachedDeposit: NEAR.parse("0.01").toString(),
//             shouldLog: true
//         })

//         await functionCall({
//             signer: funder,
//             receiver: nftContract,
//             methodName: 'nft_transfer_call',
//             args: {
//                 receiver_id: keypomV3.accountId,
//                 token_id: tokenId,
//                 msg: dropId
//             },
//             attachedDeposit: "1"
//         })

//         tokenIds.push(tokenId)
//     }

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedNftData: [{
//             contract_id: nftContract.accountId,
//             token_ids: tokenIds
//         },],
//     })

//     // 2 uses at the start
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 2)

//     // First failed claim
//     let result: {response: string|undefined, actualReceiverId: string | undefined} = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key uses should have decremented
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 1)

//     // Second failed claim
//     result = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Token should still be owned by Keypom
//     let token: {token_id: string, owner_id: string} = await nftContract.view('nft_token', {token_id: tokenIds[0]});
//     console.log(`${token.token_id} is owned by ${token.owner_id}`)
//     t.is(token.owner_id, keypomV3.accountId)

//     // Key should be deleted but drop should still exist
//     t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), false)

//     // Drop should still have assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedNftData: [{
//             contract_id: nftContract.accountId,
//             token_ids: tokenIds
//         },],
//     })

// });

// account creation failed -> should refund ALL assets & key is decremented (FT and NEAR asset version)
// test('Account Creation Fail in CAAC - drop still contains FTs, refund NEAR from FT and NEAR assets', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAssetAmount: number = 1
//     const ftRegistrationCost: number =  1

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     const ftAsset1: ExtFTData = {
//         ft_contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("1").toString(),
//         ft_amount: ftRegistrationCost.toString()
//     }

//     const nearAsset1 = {
//         yoctonear: NEAR.parse(nearAssetAmount.toString()).toString()
//     }

//     const asset_data_per_use = {
//         1: {
//             assets: [ftAsset1, nearAsset1]
//         },
//         2: {
//             assets: [null]
//         }
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("1").toString(),
//     })

//     await sendFTs(funder, "1", keypomV3, ftContract1, dropId)
    

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '1',
//         }]
//     })

//     // 2 uses at the start
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 2)

//     // starting claim NEAR and FT balance
//     let preClaimFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
//     let userPreClaimFTBal= await ftContract1.view("ft_balance_of", {account_id: ali.accountId});
//     let userPreClaimNEARBal: {available: NEAR} = await ali.balance()

//     // First failed claim
//     let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key uses should have decremented
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 1)

//     // Ensure no asset transfer
//     let userPostClaimFTBal = await ftContract1.view("ft_balance_of", {account_id: ali.accountId});
//     let userPostClaimNEARBal: {available: NEAR} = await ali.balance()
//     console.log(`Pre NEAR: ${userPreClaimNEARBal.available} and Post NEAR: ${userPostClaimNEARBal.available}`)
//     t.is(userPreClaimFTBal == userPostClaimFTBal, true)
//     t.is(userPreClaimNEARBal.available.toString() == userPostClaimNEARBal.available.toString(), true)

//     // NEAR asset and FT registration cost should have been refunded here
//     let refundedFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
//     let refund = formatNearAmount((BigInt(refundedFunderBal) - BigInt(preClaimFunderBal)).toString(), 5);
//     const EXPECTED_REFUND_NEAR: number = ftRegistrationCost + nearAssetAmount;
//     t.is(refund.toString() >= EXPECTED_REFUND_NEAR.toString(), true)

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '1',
//         }]
//     })

//     // Second failed claim
//     result = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         receiverId: ali.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key should be deleted but drop should still exist
//     t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), false)

//     // Drop should still have assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '1',
//         }]
//     })

// });

// account creation succeeded but asset claims failed -> should refund assets that failed and do nothing for ones that weren’t
// test('Asset Claim Failure in CAAC', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAssetAmount: number = 1
//     const ftRegistrationCost: number =  1

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     const ftAsset1: ExtFTData = {
//         ft_contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("1").toString(),
//         ft_amount: ftRegistrationCost.toString()
//     }

//     const ftAsset2: ExtFTData = {
//         ft_contract_id: "foo-contract",
//         registration_cost: NEAR.parse("1").toString(),
//         ft_amount: '0'
//     }

//     const nearAsset1 = {
//         yoctonear: NEAR.parse(nearAssetAmount.toString()).toString()
//     }

//     const asset_data_per_use = {
//         1: {
//             assets: [ftAsset1, nearAsset1, ftAsset2]
//         },
//         2: {
//             assets: [null]
//         }
//     }
    
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("1").toString(),
//     })

//     await sendFTs(funder, "1", keypomV3, ftContract1, dropId)
    

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '1',
//         },
//         {
//             contract_id: "foo-contract",
//             balance_avail: '0'
//         }
//     ]
//     })

//     // 2 uses at the start
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 2)

//     // starting claim balance
//     let preClaimFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

//     // First claim
//     let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
//         keypom: keypomV3,
//         root,
//         keyPair: keyPairs.keys[0],
//         createAccount: true,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key uses should have decremented
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 1)

//     // Ensure proper asset transfer
//     let userPostClaimFTBal: number = await ftContract1.view("ft_balance_of", {account_id: result.actualReceiverId});
//     // CAAC, starting FT bal was 0
//     t.is(userPostClaimFTBal == 1, true)
    
//     //ensure refund from failed ft claim is sent back, but NOT near asset
//     let refundedFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
//     let refund = formatNearAmount((BigInt(refundedFunderBal) - BigInt(preClaimFunderBal)).toString(), 5);
//     console.log(`Refunded Amount: ${refund}`)
//     const EXPECTED_REFUND_NEAR: number = ftRegistrationCost;
//     // Ensure NEAR asset was not refunded
//     t.is(refund.toString() >= EXPECTED_REFUND_NEAR.toString() && refund.toString() < (EXPECTED_REFUND_NEAR + nearAssetAmount).toString(), true)

//     // Second claim, check refund of next registration cost

// });

// test('Account Creation Fail in CAAC - Refund Registration and NEAR Asset Costs', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "my-drop-id";
//     const numKeys = 1;
//     // Always create a new keypair for CAAC
//     let keyPairs = await generateKeyPairs(numKeys);

//     const ftAsset1: ExtFTData = {
//         ft_contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("1").toString(),
//         ft_amount: "1"
//     }

//     const nftAsset1 = {
//         nft_contract_id: nftContract.accountId
//     }

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     // FT claim to work: no more assets and thus drop deleted
//     // Dont let near asset claim to fail - expect a refund here as well
//     const assets_per_use = {
//         1: [ftAsset1],
//         2: [nearAsset1]
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: [keyPairs.publicKeys[0]]
//         },
//         attachedDeposit: NEAR.parse("3").toString(),
//     })

//     // let tokenIds: string[]= [];
//     // let numTokens = 1;
//     // for (let i = 1; i < numTokens+1; i++) {
//     //     let tokenId = `token-1-${i}`

//     //     await functionCall({
//     //         signer: funder,
//     //         receiver: nftContract,
//     //         methodName: 'nft_mint',
//     //         args: {
//     //             token_id: tokenId,
//     //             metadata: {
//     //                 title: "my token"
//     //             },
//     //             receiver_id: funder.accountId
//     //         },
//     //         attachedDeposit: NEAR.parse("0.01").toString(),
//     //         shouldLog: true
//     //     })

//     //     await functionCall({
//     //         signer: funder,
//     //         receiver: nftContract,
//     //         methodName: 'nft_transfer_call',
//     //         args: {
//     //             receiver_id: keypomV3.accountId,
//     //             token_id: tokenId,
//     //             msg: dropId
//     //         },
//     //         attachedDeposit: "1"
//     //     })

//     //     tokenIds.push(tokenId)
//     // }

//     await sendFTs(funder, "1", keypomV3, ftContract1, dropId)
    

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '1',
//         }],
//         // expectedNftData:[{
//         //     contract_id: nftContract.accountId,
//         //     token_ids: tokenIds
//         // }]
//     })

//     // 2 uses at the start
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 2)

//     let startingFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

//     // First successful claim
//     let result: {response: string|undefined, newAccountId: string} = await claimWithRequiredGas({
//         keypomV3,
//         root,
//         key: keyPairs.keys[0],
//         publicKey: keyPairs.publicKeys[0],
//         createAccount: true,
//     })

//     // Key uses should have decremented
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining, 1)

//     // Assert Assets
//     await assertKeypomInternalAssets({
//         keypom: keypomV3,
//         dropId,
//         expectedFtData: [{
//             contract_id: ftContract1.accountId,
//             balance_avail: '0',
//         }],
//         // expectedNftData:[{
//         //     contract_id: nftContract.accountId,
//         //     token_ids: []
//         // }]
//     })

//     // Second failed claim
//     result = await claimWithRequiredGas({
//         keypomV3,
//         root,
//         key: keyPairs.keys[0],
//         publicKey: keyPairs.publicKeys[0],
//         createAccount: true,
//         newAccountId: root.accountId,
//         shouldPanic: true
//     })
//     t.is(result.response, "false")

//     // Key should be deleted but drop should still exist
//     t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), true)

//     let endingFunderBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
//     // refund amount, rounded to 5 decimal places
//     let refund = BigInt(endingFunderBal) - BigInt(startingFunderBal);
//     let rounded = formatNearAmount(refund.toString(), 5)
//     const DROP_DEPOSIT: number = 0.01621
//     // 1 NEAR from failed NEAR asset claim
//     const EXPECTED_REFUND_NEAR: number = 1 + DROP_DEPOSIT;
//     t.is(rounded.toString() == EXPECTED_REFUND_NEAR.toString(), true)
// });
'''
'''--- __tests__/claims/ft-claim.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtKeyInfo, InternalFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    await keypomV3.call(keypomV3, 'new', {root_account: root.accountId});
    await root.call(root, 'new', {});

    // Test users
    const funder = await root.createSubAccount('funder');

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    const ftContract2 = await root.createSubAccount('ft_contract_2');
    const ftContract3 = await root.createSubAccount('ft_contract_3');
    
    await ftContract1.deploy(`./out/ft.wasm`);
    await ftContract2.deploy(`./out/ft.wasm`);
    await ftContract3.deploy(`./out/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    await ftContract2.call(ftContract2, 'new_default_meta', { owner_id: ftContract2, total_supply: totalSupply.toString() });
    await ftContract3.call(ftContract3, 'new_default_meta', { owner_id: ftContract3, total_supply: totalSupply.toString() });
    
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, ftContract1, ftContract2, ftContract3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Failed Multi Claim', async t => {
    const {funder, ftContract1, ftContract2, ftContract3, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0").toString(),
        ft_amount: "1"
    }
    const ftAsset2: ExtFTData = {
        ft_contract_id: "bar",
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("0").toString()
    }
    const ftAsset3: ExtFTData = {
        ft_contract_id: "baz",
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("0").toString()
    }

    const dropId = "failed-multiclaim";
    const assets_per_use = {
        1: [ftAsset1, ftAsset2, ftAsset3],
        2: [ftAsset1],
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    await sendFTs(funder, "1", keypomV3, ftContract1, dropId);

    let keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
    console.log('keypomFTBal: ', keypomFTBal)
    t.is(keypomFTBal, '1')
    
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after: ', dropInfo)

    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;
        
        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, '1');
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    await keypomV3.setKey(keyPairs.keys[0]);
    let newAccountId = `new-account.${root.accountId}`;
    let keyPk = keyPairs.publicKeys[0];
    let keyInfo: ExtKeyInfo = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    t.is(keyInfo.uses_remaining, 2);

    let response = await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'create_account_and_claim',
        args: {new_account_id: newAccountId, new_public_key: keyPk},
        //args: {account_id: root.accountId},
        gas: keyInfo.required_gas,
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");
    
    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log(`dropInfo: ${JSON.stringify(dropInfo)}`)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;
        
        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, '1');
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    t.is(keyInfo.uses_remaining, 1);

    response = await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'claim',
        //args: {new_account_id: newAccountId, new_public_key: keyPk},
        args: {account_id: root.accountId},
        gas: keyInfo.required_gas,
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    try {
        keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
        console.log('keyInfo: ', keyInfo)
        t.fail("Key should have been deleted");
    } catch(e) {
        t.pass();
    }

    // Drop should not be deleted since there's 1 FT still in it
    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    t.assert(endingDropInfo != null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

// test('Overpay, Withdraw, Delete', async t => {
//     const {funder, ftContract1, ftContract2, ftContract3, keypomV3} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftAsset1: FTAsset = {
//         contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("1").toString()
//     }
//     const ftAsset2: FTAsset = {
//         contract_id: ftContract2.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("2").toString()
//     }
//     const ftAsset3: FTAsset = {
//         contract_id: ftContract3.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("3").toString()
//     }

//     const dropId = "underpay, withdraw, delete";
//     const assets_per_use = {
//         1: [ftAsset1, ftAsset2],
//         2: [ftAsset2, ftAsset3],
//         3: [ftAsset1, ftAsset3]
//     }
//     let keyPairs = await generateKeyPairs(50);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId, 
//             assets_per_use, 
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })
//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         t.is(ftAsset.ft.balance_avail, '0');
//     }

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 50)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 51);

//     await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

//     let keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal: ', keypomFTBal)
//     t.is(keypomFTBal, NEAR.parse("1000").toString());
    
//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         if (ftAsset.ft.contract_id === ftContract1.accountId) {
//             t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
//         } else {
//             t.is(ftAsset.ft.balance_avail, '0');
//         }
//     }

//     try {
//         await functionCall({
//             signer: funder,
//             receiver: keypomV3,
//             methodName: 'delete_keys',
//             args: {drop_id: dropId},
//             gas: LARGE_GAS,
//             attachedDeposit: "0"
//         })
//         t.fail('Delete keys should have failed since not all assets are withdrawn')
//     } catch(e) {
//         t.pass();
//     }

//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after failed deletion: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         if (ftAsset.ft.contract_id === ftContract1.accountId) {
//             t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
//         } else {
//             t.is(ftAsset.ft.balance_avail, '0');
//         }
//     }

//     keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 50)

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 51);

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'withdraw_ft_balance',
//         args: {
//             drop_id: dropId, 
//             ft_contract_id: ftContract1.accountId, 
//             tokens_to_withdraw: NEAR.parse("1000").toString()
//         },
//         gas: LARGE_GAS,
//         attachedDeposit: "0"
//     })

//     keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal: ', keypomFTBal)
//     t.is(keypomFTBal, '0')

//     let funderFTBal = await ftContract1.view('ft_balance_of', {account_id: funder.accountId});
//     console.log('funderFTBal: ', funderFTBal)
//     t.is(funderFTBal, NEAR.parse("1000").toString());

//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after failed deletion: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;
        
//         t.is(ftAsset.ft.balance_avail, '0');
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'delete_keys',
//         args: {drop_id: dropId},
//         gas: LARGE_GAS,
//         attachedDeposit: "0"
//     })

//     try {
//         keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Drop should have been deleted so method should panic')
//     } catch (e) {
//         t.pass();
//     }

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     // After keys have been deleted, 50 * 6 * 0.0125 = 3.75 should be returned to the funder
//     let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
//     t.assert(NEAR.from(userBal).gte(NEAR.parse("3.75")))

//     let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo (after drop is deleted): ', dropInfo)
//     t.is(endingDropInfo, null);
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Create & Delete Empty Drop', async t => {
//     const {funder, ftContract1, ftContract2, ftContract3, keypomV3} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftAsset1: FTAsset = {
//         contract_id: ftContract1.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("1").toString()
//     }
//     const ftAsset2: FTAsset = {
//         contract_id: ftContract2.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("2").toString()
//     }
//     const ftAsset3: FTAsset = {
//         contract_id: ftContract3.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         amount: NEAR.parse("3").toString()
//     }

//     const dropId = "overpay, withdraw, delete";
//     const assets_per_use = {
//         1: [ftAsset1, ftAsset2],
//         2: [ftAsset2, ftAsset3],
//         3: [ftAsset1, ftAsset3]
//     }
//     let keyPairs = await generateKeyPairs(0);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId, 
//             assets_per_use, 
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })
//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         t.is(ftAsset.ft.balance_avail, '0');
//     }

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 0)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

//     let keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal: ', keypomFTBal)
//     t.is(keypomFTBal, NEAR.parse("1000").toString());
    
//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         if (ftAsset.ft.contract_id === ftContract1.accountId) {
//             t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
//         } else {
//             t.is(ftAsset.ft.balance_avail, '0');
//         }
//     }

//     try {
//         await functionCall({
//             signer: funder,
//             receiver: keypomV3,
//             methodName: 'delete_keys',
//             args: {drop_id: dropId},
//             gas: LARGE_GAS,
//             attachedDeposit: "0"
//         })
//         t.fail('Delete keys should have failed since not all assets are withdrawn')
//     } catch(e) {
//         t.pass();
//     }

//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after failed deletion: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;

//         if (ftAsset.ft.contract_id === ftContract1.accountId) {
//             t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
//         } else {
//             t.is(ftAsset.ft.balance_avail, '0');
//         }
//     }

//     keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 0)

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'withdraw_ft_balance',
//         args: {
//             drop_id: dropId, 
//             ft_contract_id: ftContract1.accountId, 
//             tokens_to_withdraw: NEAR.parse("1000").toString()
//         },
//         gas: LARGE_GAS,
//         attachedDeposit: "0"
//     })

//     keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal: ', keypomFTBal)
//     t.is(keypomFTBal, '0')

//     let funderFTBal = await ftContract1.view('ft_balance_of', {account_id: funder.accountId});
//     console.log('funderFTBal: ', funderFTBal)
//     t.is(funderFTBal, NEAR.parse("1000").toString());

//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after failed deletion: ', dropInfo)
//     for (var asset of dropInfo.internal_assets_data) {
//         let ftAsset = asset as InternalFTData;
        
//         t.is(ftAsset.ft.balance_avail, '0');
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'delete_keys',
//         args: {drop_id: dropId},
//         gas: LARGE_GAS,
//         attachedDeposit: "0"
//     })

//     try {
//         keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Drop should have been deleted so method should panic')
//     } catch (e) {
//         t.pass();
//     }

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo (after drop is deleted): ', dropInfo)
//     t.is(endingDropInfo, null);
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

'''
'''--- __tests__/claims/near-claim.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtNearData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Single NEAR Claim', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nearAsset1],
//     }
//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })
//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     //t.is((dropInfo.internal_assets_data[0] as ExtNearData).yoctonear, NEAR.parse("1").toString());

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)
//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     await keypomV3.setKey(keyPairs.keys[0]);
//     let newAccountId = `new-account.${root.accountId}`;
//     let keyPk = keyPairs.publicKeys[0];
//     const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
    
//     let response = await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'create_account_and_claim',
//         args: {new_account_id: newAccountId, new_public_key: keyPk},
//         gas: keyInfo.required_gas
//     })
//     console.log('response: ', response)
//     t.is(response, "true");

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
//     console.log('doesExist: ', doesExist)
//     t.is(doesExist, true);

//     try {
//         const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//         console.log('keyInfo (Should have panicked): ', keyInfo)
//         t.fail('Key should have been deleted');
//     } catch (e) {
//         t.pass();
//     }

//     let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo (after drop is deleted): ', endingDropInfo)
//     t.is(endingDropInfo, null);
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

test('Claim to invalid account', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [nearAsset1],
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    t.is(dropInfo.internal_assets_data.length, 1);
    //t.is((dropInfo.internal_assets_data[0] as ExtNearData).yoctonear, NEAR.parse("1").toString());

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    await keypomV3.setKey(keyPairs.keys[0]);
    let newAccountId = `new-account.${root.accountId}`;
    let keyPk = keyPairs.publicKeys[0];
    const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    
    let response = await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'claim',
        args: {account_id: newAccountId},
        gas: keyInfo.required_gas,
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);

    try {
        const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
        console.log('keyInfo (Should have panicked): ', keyInfo)
        t.fail('Key should have been deleted');
    } catch (e) {
        t.pass();
    }

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

// test('Multi Null Claim', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "Null Claim";
//     const assets_per_use = {
//         1: [null, null, null, null, null, null, null, null, null],
//         2: [null, null, null, null, null, null, null, null, null],
//         3: [null, null, null, null, null, null, null, null, null],
//     }
//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })
//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     t.is(dropInfo.internal_assets_data[0], null);

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)
//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     await keypomV3.setKey(keyPairs.keys[0]);
//     let newAccountId = `new-account.${root.accountId}`;
//     let keyPk = keyPairs.publicKeys[0];
//     let keyInfo: {required_gas: string, uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
//     t.is(keyInfo.uses_remaining, 3);
    
//     await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'claim',
//         args: {account_id: newAccountId},
//         gas: keyInfo.required_gas
//     })

//     keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
//     t.is(keyInfo.uses_remaining, 2);

//     await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'claim',
//         args: {account_id: newAccountId},
//         gas: keyInfo.required_gas
//     })
    
//     keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
//     t.is(keyInfo.uses_remaining, 1);
    
//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'create_account_and_claim',
//         args: {new_account_id: newAccountId, new_public_key: keyPk},
//         gas: keyInfo.required_gas
//     })

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
//     console.log('doesExist: ', doesExist)
//     t.is(doesExist, true);

//     try {
//         const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//         console.log('keyInfo (Should have panicked): ', keyInfo)
//         t.fail('Key should have been deleted');
//     } catch (e) {
//         t.pass();
//     }

//     let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo (after drop is deleted): ', endingDropInfo)
//     t.is(endingDropInfo, null);
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Tons of null claims', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "Null Claim";
//     const assets_per_use = {
//         1: [
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//             null, null, null, null, null, null, null, null, null,
//         ],
//     }
//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })
//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     t.is(dropInfo.internal_assets_data[0], null);

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)
//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     await keypomV3.setKey(keyPairs.keys[0]);
//     let newAccountId = `new-account.${root.accountId}`;
//     let keyPk = keyPairs.publicKeys[0];
//     let keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
    
//     await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'create_account_and_claim',
//         args: {new_account_id: newAccountId, new_public_key: keyPk},
//         gas: keyInfo.required_gas
//     })

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
//     console.log('doesExist: ', doesExist)
//     t.is(doesExist, true);

//     try {
//         const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//         console.log('keyInfo (Should have panicked): ', keyInfo)
//         t.fail('Key should have been deleted');
//     } catch (e) {
//         t.pass();
//     }

//     let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo (after drop is deleted): ', endingDropInfo)
//     t.is(endingDropInfo, null);
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });
'''
'''--- __tests__/claims/nft-claim.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtNearData, InternalNFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

  test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });

    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Lots of Failed Claims', async t => {
    const {funder, keypomV3, nftContract, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })

    const nftAsset1 = {
        nft_contract_id: nftContract.accountId
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1]
    }

    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys,
        }
    })

    // This token exists!!
    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_transfer_call',
        args: {
            receiver_id: keypomV3.accountId,
            token_id: "token1",
            msg: dropId
        },
        attachedDeposit: "1"
    })

    // None of these tokens exist
    for (let i = 0; i < 5; i++) {
        await functionCall({
            signer: nftContract,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                sender_id: funder.accountId,
                token_id: `token${i+5}`,
                msg: dropId
            }
        })
    }

    // First transfer should succeed, next 5 should fail because token doesn't exist, the last should fail because there aren't enough tokens sent
    await keypomV3.setKey(keyPairs.keys[0]);
    let keyPk = keyPairs.publicKeys[0];
    const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    
    let response = await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'claim',
        args: {account_id: nftContract.accountId},
        gas: keyInfo.required_gas,
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log(`dropInfo: ${JSON.stringify(dropInfo)}`)
    t.is(dropInfo.internal_assets_data.length, 1);
    t.is((dropInfo.internal_assets_data[0] as InternalNFTData).nft.token_ids.length, 5);

    let tokensForOwner = await nftContract.view('nft_supply_for_owner', {account_id: nftContract.accountId});
    console.log('tokensForOwner: ', tokensForOwner)
    t.is(tokensForOwner, '1');

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/claims/null-claim.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Single Null Claim', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "Null Claim";
    const assets_per_use = {
        1: [null],
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    t.is(dropInfo.internal_assets_data.length, 1);
    t.is(dropInfo.internal_assets_data[0], null);

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    await keypomV3.setKey(keyPairs.keys[0]);
    let newAccountId = `new-account.${root.accountId}`;
    let keyPk = keyPairs.publicKeys[0];
    const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    
    await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'create_account_and_claim',
        args: {new_account_id: newAccountId, new_public_key: keyPk},
        gas: keyInfo.required_gas
    })

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);

    try {
        const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
        console.log('keyInfo (Should have panicked): ', keyInfo)
        t.fail('Key should have been deleted');
    } catch (e) {
        t.pass();
    }

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Multi Null Claim', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "Null Claim";
    const assets_per_use = {
        1: [null, null, null, null, null, null, null, null, null],
        2: [null, null, null, null, null, null, null, null, null],
        3: [null, null, null, null, null, null, null, null, null],
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    t.is(dropInfo.internal_assets_data.length, 1);
    t.is(dropInfo.internal_assets_data[0], null);

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    await keypomV3.setKey(keyPairs.keys[0]);
    let newAccountId = `new-account.${root.accountId}`;
    let keyPk = keyPairs.publicKeys[0];
    let keyInfo: {required_gas: string, uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    t.is(keyInfo.uses_remaining, 3);
    
    await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'claim',
        args: {account_id: newAccountId},
        gas: keyInfo.required_gas
    })

    keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    t.is(keyInfo.uses_remaining, 2);

    await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'claim',
        args: {account_id: newAccountId},
        gas: keyInfo.required_gas
    })
    
    keyInfo = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    t.is(keyInfo.uses_remaining, 1);
    
    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'create_account_and_claim',
        args: {new_account_id: newAccountId, new_public_key: keyPk},
        gas: keyInfo.required_gas
    })

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);

    try {
        const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
        console.log('keyInfo (Should have panicked): ', keyInfo)
        t.fail('Key should have been deleted');
    } catch (e) {
        t.pass();
    }

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Tons of null claims', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "Null Claim";
    const assets_per_use = {
        1: [
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
        ],
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    t.is(dropInfo.internal_assets_data.length, 1);
    t.is(dropInfo.internal_assets_data[0], null);

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    await keypomV3.setKey(keyPairs.keys[0]);
    let newAccountId = `new-account.${root.accountId}`;
    let keyPk = keyPairs.publicKeys[0];
    let keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)
    
    await functionCall({
        signer: keypomV3,
        receiver: keypomV3,
        methodName: 'create_account_and_claim',
        args: {new_account_id: newAccountId, new_public_key: keyPk},
        gas: keyInfo.required_gas
    })

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let doesExist = await (keypomV3.getAccount(newAccountId)).exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);

    try {
        const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
        console.log('keyInfo (Should have panicked): ', keyInfo)
        t.fail('Key should have been deleted');
    } catch (e) {
        t.pass();
    }

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/claims/testing-utils.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, InternalNFTData } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');

    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);

    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });
    // await nftContract2.call(nftContract2, 'new_default_meta', { owner_id: nftContract2 });

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    // const ftContract2 = await root.createSubAccount('ft_contract_2');

    // await functionCall({
    //     signer: funder,
    //     receiver: nftContract,
    //     methodName: 'nft_mint',
    //     args: {
    //         token_id: "token1",
    //         metadata: {
    //             title: "my token"
    //         },
    //         receiver_id: funder.accountId
    //     },
    //     attachedDeposit: NEAR.parse("1").toString(),
    //     shouldLog: false
    // })

    // await functionCall({
    //     signer: funder,
    //     receiver: nftContract2,
    //     methodName: 'nft_mint',
    //     args: {
    //         token_id: "token1",
    //         metadata: {
    //             title: "my token"
    //         },
    //         receiver_id: funder.accountId
    //     },
    //     attachedDeposit: NEAR.parse("1").toString(),
    //     shouldLog: false
    // })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract, ftContract1, ali };
    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// EXPECTED CAAC FAILIURE BEHAVIOUR
// Failed CAAC:
// - no assets transferred
// - Check if key is properly deleted in the case that it’s 0 remaining uses and check if it isn’t deleted in other case
// - Make sure drop is deleted ONLY if it’s empty of keys and has no funded assets in it (i.e FTs & NFTs)
// - If drop is deleted, only NEAR assets and FT registration cost should be refunded back to user balance

// - account creation failed -> should refund ALL assets & key is decremented
// - account creation succeeded but asset claims failed -> should refund assets that failed and do nothing for ones that weren’t

// account creation failed -> should refund ALL assets & key is decremented (NFT version)
test('CAAC', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_for_all_uses = {
        assets: [null],
        num_uses: 1
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses,
            public_keys: [keyPairs.publicKeys[0]]
        },
    })

    t.is(await doesDropExist(keypomV3, dropId), false)

    // CAAC using just createAccount flag
    let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
        keypom: keypomV3,
        root,
        keyPair: keyPairs.keys[0],
        createAccount: true,
    })

    // Key should be deleted but drop should still exist
    t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test('Force CAAC Failure', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }

    const assets_per_use = {
        1: [null]
    }

    const asset_data_for_all_uses = {
        assets: [null],
        num_uses: 1
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses,
            public_keys: [keyPairs.publicKeys[0]]
        },
    })

    t.is(await doesDropExist(keypomV3, dropId), false)

    // CAAC using just createAccount flag
    let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
        keypom: keypomV3,
        root,
        keyPair: keyPairs.keys[0],
        createAccount: true,
        receiverId: ali.accountId,
        shouldPanic: true
    })

    // Key should be deleted but drop should still exist
    t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test('Claim Normal', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_for_all_uses = {
        assets: [null],
        num_uses: 1
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses,
            public_keys: [keyPairs.publicKeys[0]]
        },
    })

    t.is(await doesDropExist(keypomV3, dropId), false)

    // CAAC using just createAccount flag
    let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
        keypom: keypomV3,
        root,
        keyPair: keyPairs.keys[0],
        receiverId: ali.accountId
    })

    // Key should be deleted but drop should still exist
    t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test('Claim Implicit', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2, ali} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }

    const assets_per_use = {
        1: [nearAsset1]
    }

    const asset_data_for_all_uses = {
        assets: [null],
        num_uses: 1
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses,
            public_keys: [keyPairs.publicKeys[0]]
        },
    })

    t.is(await doesDropExist(keypomV3, dropId), false)

    // Implicit claimflags
    let result: {response: string|undefined, actualReceiverId: string|undefined} = await claimWithRequiredGas({
        keypom: keypomV3,
        root,
        keyPair: keyPairs.keys[0],
        useImplicitAccount: true
    })

    // Key should be deleted but drop should still exist
    t.is(await doesKeyExist(keypomV3,keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)
});
'''
'''--- __tests__/config-tests/OLD-config-tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, generateKeyPairs } from "../utils/general";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

const ONE_SECOND_NS = 1e9;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init empty/default linkdrop contract
    await root.call(root, 'new', {});
    //init new keypom contract and setting keypom as the owner. 
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    
    
    // Test users, ali.test.near
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    
    // Custom-root.near, deploy contracts to it and init new linkdrop
    const customRoot = await root.createSubAccount('custom-root');
    await customRoot.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    await customRoot.call(customRoot, 'new', {});
    
    // Add 10k $NEAR to owner's account
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    
    //get current keypom (contract) balances 
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, owner, ali, customRoot };
    t.context.keypomInitialBalance = keypomBalance.available;
    t.context.keypomInitialStateStaked = keypomBalance.stateStaked;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Testing Delete On Empty Config', async t => {
    //initializing accounts, adding a balance of 10N to owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 key pairs, and then create a new config specifying that the drop is deleted when empty
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        usage: {
            auto_delete_drop: true
        }
    }

    // Creating the drop that should be deleted when empty
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // Creating the drop that should NOT be deleted when empty by passing in NO config
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[1]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config: null,
    },{gas: LARGE_GAS});

    // Set ali's NEAR account balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })
    
    //adding 2 full access keys
    for(var i = 0; i < 2; i++) {
        //set access key to be used for following transactions
        await keypom.setKey(keys[i]);
        //claim wallet gas to ali's account. wallet gas is 1NEAR, looping through twice should give him 2NEAR
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
        //after this, the access key should be deleted as it has been used. This means adding the new one is fresh. 
    }

    //ali's balance should be 2N after claiming wallet gas (constant) twice
    let aliBal = await ali.availableBalance();
    console.log('aliBal: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());
    
    //gets number of drops for given account owner, this should now be one as the first drop (drop_id = 0) should have been deleted as it was empty
    const dropSupplyForOwner = await getDropSupplyForOwner(keypom, owner.accountId);
    console.log('dropSupplyForOwner: ', dropSupplyForOwner)
    t.is(dropSupplyForOwner, 1);
    
    //drop_id 1 should still exist despite using all its keys as the delete_on_empty defaults to false and
    //drop_id 1 (second drop created) was not given explicit delete_on_empty
    const keySupplyForDrop = await getKeySupplyForDrop(keypom, "1")
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);
});

test('Testing Start Timestamp', async t => {
    //add 10NEAR to owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate key pair and get starting timestamp
    //set the starting timestamp to be 30s from now, so that you can only claim after 30s
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        time: {
            start: (Date.now() * 1000000) + ONE_SECOND_NS * 30,
        }
    }

    //create drop with custom starting timestamp
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // Set ali's NEAR account balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    //set access key to be used for following transactions
    await keypom.setKey(keys[0]);
    //give full access to the key above since failing a transaction would lead to not enough allowance on a regular function call access key
    await keypom.updateAccessKey(
        publicKeys[0],  // public key
        {
            nonce: 0,
            permission: 'FullAccess'
        }
    )
    // THIS SHOULD FAIL BECAUSE THE START TIMESTAMP HASN'T BEEN REACHED
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //get ali's initial balance (set to 0 earlier)
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());
    
    //verify that there is still only one key since the claim attempt above failed
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    // Wait 30 seconds and call the claim method again
    await new Promise(r => setTimeout(r, 30000));
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    
    //now that the key has been used, the total key supply should now be 0
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);

    //ensure that, now that the claim has gone through, that ali's NEAR wallet balance is now 1NEAR
    aliBal = await ali.availableBalance();
    console.log('aliBal After: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());
});

test('Testing Throttle Timestamp', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        uses_per_key: 2,
        time: {
            throttle: ONE_SECOND_NS * 30,
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // Set ali's NEAR wallet balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    //set first key as the key to be used to sign txns
    await keypom.setKey(keys[0]);
    // TWO CONSECUTIVE CLAIMS SHOULD FAIL BECAUSE THE THROTTLE TIMESTAMP HASN'T BEEN REACHED
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //ali should have claimed 1NEAR as the first transaction went through. Checking this here.
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);
    
    //since the key was used once, it should still have one more use on it
    let keyInformation: JsonKeyInfo = await getKeyInformation(keypom, publicKeys[0]);
    console.log('keyInformation: ', keyInformation)
    t.is(keyInformation.remaining_uses, 1);

    // Wait 30 seconds and call the claim method again
    await new Promise(r => setTimeout(r, 30000));
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //now that all key uses were used up, the key should be deleted
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);

    //ali's balance, now that he's claimed twice, should be 2NEAR
    aliBal = await ali.availableBalance();
    console.log('aliBal After: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());
});

test('Testing On Claim Refund Deposit', async t => {
    //add 10NEAR to contract owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    //adding 10NEAR to owner's keypom debit balance
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 keypairs and a config with on claim refund deposit = true
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        usage: {
            refund_deposit: true,
        }
    }

    // Creating the drop that should be deleted, this should cause owner's keypom wallet balance to be 9NEAR as they had to front the cost of 1 key at 1NEAR
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // Withdrawing all owner's balance to their NEAR wallet, keypom wallet balance is now 0NEAR
    await owner.call(keypom, 'withdraw_from_balance', {});
    
    //set key to be used to sign txns
    await keypom.setKey(keys[0]);
    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // When CLAIM is called, refund the `deposit_per_use` to the owner's account directly.
    //refund_on_claim is used when owner only wants CAAC to be used. 
    //If claim is used, the key is deleted and the deposit for said key is sent back to owner
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //confirm that ali's NEAR wallet balance is still 0 as he does not receive the funds for calling claim instead of CAAC
    let aliBal = await ali.availableBalance();
    console.log('aliBal: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    //owner's Keypom wallet balance should be at least 1NEAR as thats what should have been refunded when claim was called
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.assert(NEAR.parse("1").gte(NEAR.from(userBal)))
    
    //key was used but drop does not delete as it was not set to true in the config
    const dropSupplyForOwner = await getDropSupplyForOwner(keypom, owner.accountId);
    console.log('dropSupplyForOwner: ', dropSupplyForOwner)
    t.is(dropSupplyForOwner, 1);
    
    //the drop should no longer have any keys however, as claim was called
    const keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);
});

test('Testing Custom Drop Root', async t => {
    //create accounts and add 10NEAR to owner's keypom balance
    const { keypom, owner, ali, customRoot } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 set of keypairs and set a custom root ID, one for no-config and one for config
    let {keys: keysNoConfig, publicKeys: publicKeysNoConfig} = await generateKeyPairs(1);
    let {keys: keysConfig, publicKeys: publicKeysConfig} = await generateKeyPairs(2);
    //create config that customizes root id
    let config: DropConfig  = {
    root_account_id: customRoot.accountId,
    }
    //customRoot.accountId = customRoot.test.near

    // Creating the drop that points to the custom root using publicKeysConfig
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeysConfig, 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});
    
    // Creating the regular drop using publicKeysNoConfig
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeysNoConfig, 
        deposit_per_use: NEAR.parse("1").toString(),
        config: null,
    },{gas: LARGE_GAS});

    //generate another keypair to use in create account and claim
    let { keys: keys2, publicKeys: pks2 } = await generateKeyPairs(1);
    //foo.customRoot.test.near
    let newAccountCorrect = await keypom.getAccount(`foo.${customRoot.accountId}`);
    //foo.customRoot.test.near.test.near --> this cannot be created from a customRoot.accountId.test.near
    let newAccountIncorrect = await keypom.getAccount(`foo.${customRoot.accountId}.test.near`);
    console.log(`foo.${customRoot.accountId}.test.near: `)
    
    //non-config key set as the key being used
    await keypom.setKey(keysNoConfig[0]);
    // SHOULD NOT WORK as you are using a nonConfig key & drop to deposit to a new account with a custom root
    await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `foo.${customRoot.accountId}`, new_public_key : pks2[0]}, {gas: WALLET_GAS});
    let doesExist = await newAccountCorrect.exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, false);

    //set config key as the key being used
    await keypom.setKey(keysConfig[0]);
    //drain owner balance 
    await owner.call(keypom, 'withdraw_from_balance', {});
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    t.is(ownerBal, "0");

    ////incorrect account ID should not work
    await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `foo.${customRoot.accountId}.test.near`, new_public_key : pks2[0]}, {gas: WALLET_GAS});
    doesExist = await newAccountIncorrect.exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, false);

    //the failed CAAC should cause a refund per deposit to be refunded to owner
    //this is since the CAAC fails on linkdrop XCC and NOT keypom internal checks
    ownerBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('ownerBal: ', ownerBal)
    t.assert(NEAR.from(ownerBal).gte(NEAR.parse("1")));

    //reset owner balance again
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    t.is(ownerBal, "0");

    //set second config key to be used as first one would have been deleted
    await keypom.setKey(keysConfig[1]);

    //this second custom root create account and claim should go through as the config key is being used
    await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `foo.${customRoot.accountId}`, new_public_key : pks2[0]}, {gas: WALLET_GAS});
    doesExist = await newAccountCorrect.exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);

    //owner balance should be less than 1NEAR as they don't get refunded anymore. 
    ownerBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('ownerBal: ', ownerBal)
    t.assert(NEAR.from(ownerBal).lte(NEAR.parse("1")));
});

test('Testing Auto Withdraw', async t => {
    //creating accounts, adding 100NEAR to owner's keypom wallet balance
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});

    //generate 4 keypairs
    let {keys, publicKeys} = await generateKeyPairs(4);
    //first config with 1 use/key
    let config1: DropConfig = {
        uses_per_key: 1,
    }
    //second config with auto_withdraw on, 1 use per key, and drop delete on empty enabled
    let config2: DropConfig = {
        uses_per_key: 1,
        usage: {
            auto_withdraw: true,
            auto_delete_drop: true
        }
    }
    //create drop with publickeys[0] and first config with no auto-withdraw and delete-on-empty
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config: config1,
    },{gas: LARGE_GAS});

    //second drop with publickeys[1] and second config with autowithdraw and delete-on-empty
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[1]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config: config2,
    },{gas: LARGE_GAS});
    //owner has 8NEAR in their keypom wallet from here onwards

    // Loop through 2 times and claim the keys [0, 1]
    for (let i = 0; i < 2; i++) {
        await keypom.setKey(keys[i]);
        //1st run --> 1/1key uses used on keys[0], key should be deleted but drop still exists
        //2nd run --> 1/1 key uses used on keys[1], key AND drop should be deleted as per config2
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
        //ali should have received 2NEAR here

    }

    // Get the owner's Keypom balance and make sure it hasn't been auto withdrawn SINCE NOT ALL OWNER'S DROP HASNT BEEN DELETED
    let userBal: String = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.assert(userBal > "0");
    
    // Delete the first drop manually, second drop was auto-deleted
    await owner.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    
    //get number of active drops for owner, should be 0 after first drop manual delete and second drop auto delete
    let dropSupplyForOwner = await getDropSupplyForOwner(keypom, owner.accountId);
    console.log('dropSupplyForOwner: ', dropSupplyForOwner)
    t.is(dropSupplyForOwner, 0);

    //create another drop using config2; auto-delete on, 1NEAR deposited per use
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[2]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config: config2,
    },{gas: LARGE_GAS});

    //add 1000NEAR to owner's keypom balance
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("1000").toString()});
    let shouldBeRefunded: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('shouldBeRefunded: ', userBal)
    t.assert(NEAR.parse("1000").lte(NEAR.from(shouldBeRefunded)));
    
    //owner's starting NEAR wallet balance
    let b1 = await owner.availableBalance();
    console.log('b1: ', b1.toString())

    //set keys[2] as the key being used
    await keypom.setKey(keys[2]);

    //claim to Ali's account
    //once they key is used (and is the only and last key on this drop) and delted, the remaining balance in owner's Keypom wallet is refunded back to their NEAR wallet. 
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //b1 = 1000NEAR. b2 should be 0NEAR as the drop was deleted. This means the balance change should be 10000NEAR, or owner's starting balance
    let b2 = await owner.availableBalance();
    console.log('b2: ', b2.toString())
    t.assert(assertBalanceChange(b1, b2, NEAR.from(shouldBeRefunded), 0.01), "balance didn't decrement properly with 1% precision");

    //make sure that the owner's Keypom wallet balance is 0
    userBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //get number of drops for owner remaining, assert that it is 0
    dropSupplyForOwner = await getDropSupplyForOwner(keypom, owner.accountId);
    console.log('dropSupplyForOwner: ', dropSupplyForOwner)
    t.is(dropSupplyForOwner, 0);
});

test('Testing Custom Drop ID', async t => {
    //adding 1000NEAR to owner balance
    const { keypom, owner, ali, customRoot } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("1000").toString()});

    // Creating the drop has custom drop id of 1
    //this will fail, custom drop ID's < a billion WILL FAIL. This is to prevent interference with general incrementing nonce drop IDs.
    try {
        await owner.call(keypom, 'create_drop', {
            deposit_per_use: NEAR.parse("1").toString(),
            drop_id: "1"
        },{gas: LARGE_GAS});
    } catch(e) {}

    //get next drop ID and drop supply per owner.
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    //since the last create_drop failed, the nextDropID should still be 0 and there should still be 0 drops for that owner
    console.log('viewFunctions.nextDropId: ', viewFunctions.nextDropId)
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.nextDropId, 0);
    t.is(viewFunctions.dropSupplyForOwner, 0);

    ////create a normal drop, no custom dropID. this means the dropID will be 0
    await owner.call(keypom, 'create_drop', {
         
        deposit_per_use: NEAR.parse("1").toString()
    },{gas: LARGE_GAS});

    //now that the first drop was created properly, the next dropID should be 1 and there shoudl be 1 drop for owner
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions.nextDropId: ', viewFunctions.nextDropId)
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.nextDropId, 1);
    t.is(viewFunctions.dropSupplyForOwner, 1);

    //this should succeed as dropID > a billion
    await owner.call(keypom, 'create_drop', {
         
        deposit_per_use: NEAR.parse("1").toString(),
        drop_id: "2000000000"
    },{gas: LARGE_GAS});

    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    //nextDropID does not increment as a custom dropID was used
    console.log('viewFunctions.nextDropId: ', viewFunctions.nextDropId)
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.nextDropId, 1);
    t.is(viewFunctions.dropSupplyForOwner, 2);

    //adding another non-custom-dropID drop should go through
    await owner.call(keypom, 'create_drop', {
         
        deposit_per_use: NEAR.parse("1").toString()
    },{gas: LARGE_GAS});

    //both nextDropID and drop supply should increment here
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions.nextDropId: ', viewFunctions.nextDropId)
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.nextDropId, 2);
    t.is(viewFunctions.dropSupplyForOwner, 3);

    //adding a duplicate dropID should not work
    try {
        await owner.call(keypom, 'create_drop', {
             
            deposit_per_use: NEAR.parse("1").toString(),
            drop_id: "2000000000"
        },{gas: LARGE_GAS});
    } catch(e) {}

    //nextDropID does not increment, neither does dropSupply
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions.nextDropId: ', viewFunctions.nextDropId)
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.nextDropId, 2);
    t.is(viewFunctions.dropSupplyForOwner, 3);
});

test('Testing Valid Config', async t => {
    //adding 100NEAR to owner balance
    const { keypom, owner, ali } = t.context.accounts;
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});

    //zero uses per key cannot be used.
    let config: DropConfig = {
        uses_per_key: 0,
    }
    try {
        await owner.call(keypom, 'create_drop', {
             
            deposit_per_use: NEAR.parse("1").toString(),
            config,
        },{gas: LARGE_GAS});
    } catch(e) {}

    //both the start_timestamp and end timestamps are greater than the current block
    let config1: DropConfig = {
        time: {
            start: 500,
        }
    }
    try {
        await owner.call(keypom, 'create_drop', {
             
            deposit_per_use: NEAR.parse("1").toString(),
            config: config1,
        },{gas: LARGE_GAS});
    } catch(e) {}

    //end timestamp 0 not possible
    let config2: DropConfig = {
        time: {
            end: 0,
        }
    }
    try {
        await owner.call(keypom, 'create_drop', {
             
            deposit_per_use: NEAR.parse("1").toString(),
            config: config2,
        },{gas: LARGE_GAS});
    } catch(e) {}

    //end timestamp occurs before start, invalid
    let config3: DropConfig = {
        time: {
            start: (Date.now() * 1000000) + ONE_SECOND_NS * 30,
            end: (Date.now() * 1000000) + ONE_SECOND_NS * 10,
        }
    }

    try {
        await owner.call(keypom, 'create_drop', {
             
            deposit_per_use: NEAR.parse("1").toString(),
            config: config3,
        },{gas: LARGE_GAS});
    } catch(e) {}

    //none of these configs should work, hence there are no drops for that owner and nextDropID is still 0
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions.dropSupplyForOwner: ', viewFunctions.dropSupplyForOwner)
    t.is(viewFunctions.dropSupplyForOwner, 0);
    t.is(viewFunctions.nextDropId, 0);
});

test('Testing End Timestamp', async t => {
    //add 10 NEAR to balance
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 keypairs and make a config where timestamp is 10s from now
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        time: {
            end: (Date.now() * 1000000) + ONE_SECOND_NS * 15,
        }
    }

    //use config to create drop
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys, 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    //should have 2 keys in this specific drop
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 2);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    //set keys[0] to be used
    await keypom.setKey(keys[0]);
    // THIS SHOULD PASS as its before the end timestamp
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //should now only have 1 key in the key supply for this drop
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    // Wait 15 seconds
    await new Promise(r => setTimeout(r, 15000));

    // THIS SHOULD FAIL as the end timestamp is violated
    try {
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    } catch(e) {}
    
    //claim above failed, key supply stays at 1
    //note since claim failed for INTERNAL reasons, the key is NOT deleted.
    //all internal checks are performed before the key is deleted and the XCC is initiated
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);
});

test('Testing End Timestamp Key Drainage', async t => {
    //add 10NEAR to owner wallet
    const { keypom, owner, ali } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair, create config with end timestamp 5s from now
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        time: {
            end: (Date.now() * 1000000) + ONE_SECOND_NS * 10,
        }
    }

    //create drop with created config
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys, 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    //key supply in this drop should now be one
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    // Wait 5 seconds for start timestamp to pass
    await new Promise(r => setTimeout(r, 10000));

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })
    let alib1 = await ali.availableBalance();

    //use key[0]
    await keypom.setKey(keys[0]);

    // Loop 50 times and try to claim
    for (let i = 0; i < 50; i++) {
        try {
            //will fail as end_timestamp was violated
            await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
        } catch(e) {}
    }

    //since the key was never claimed, there is one key left for the drop, the same one originally initialized
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    //check if ali's balance has risen, it should not since the claims all failed
    let alib2 = await ali.availableBalance();
    t.assert(assertBalanceChange(alib1, alib2, new NEAR(0), 0.01), "balance didn't increment properly with 1% precision");
    
});

test('Testing Claim Interval', async t => {
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //create 1 keypair, config with 5uses/key, a start timestamp of 5s from now, and a 10s claim interval
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        uses_per_key: 5,
        time: {
            start: (Date.now() * 1000000) + ONE_SECOND_NS * 10,
            interval: ONE_SECOND_NS * 10,
        }
    }

    //create drop
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    //key supply in this drop should now be one
    let numKeysDrop1 = await getKeySupplyForDrop(keypom, "0");
    console.log('getKeySupplyForDrop: ', numKeysDrop1)
    t.is(numKeysDrop1, 1);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    //use keys[0]
    await keypom.setKey(keys[0]);
    // THIS SHOULD FAIL BECAUSE THE INTERVAL HASN'T BEEN REACHED
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //confirm that the claim did not work
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    //wait 5 seconds to reach start timestamp [NOTE THIS WAS PASSING WITHOUT THIS I THINK...]
    await new Promise(r => setTimeout(r, 10000));

    // Wait 50 seconds
    //5 uses in the key and 10s/use means after 50s the keys can be claimed all at once
    await new Promise(r => setTimeout(r, 50000));

    // Loop through and claim all 5 times
    for (let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    }

    //all claims should have gone through, expect key to be deleted
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);

    //aliBal should now be 5 after claiming 5 times at 1NEAR per key use
    aliBal = await ali.availableBalance();
    console.log('aliBal After: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("5").toString());
});

test('Testing All Time Based Configs Together', async t => {
    //create owner with 10NEAR balance
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 key pair and a config with 5uses per key, a start timestamp of 30s from now, a claim interval of 10s and throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        uses_per_key: 5,
        time: {
            start: (Date.now() * 1000000) + ONE_SECOND_NS * 30,
            interval: ONE_SECOND_NS * 10,
            throttle: ONE_SECOND_NS * 30
        }
    }

    //create drop using above defined keys and config
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    //set keys[0] to be claimed
    await keypom.setKey(keys[0]);
    // THIS SHOULD FAIL BECAUSE THE INTERVAL HASN'T BEEN REACHED
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //make sure above claim failed
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    // Wait 60 seconds to pass total claim interval AND start timestamp
    await new Promise(r => setTimeout(r, 60000));

    // Loop through and claim all 5 times But ONLY ONE should be claimed due to throttle timestamp
    for (let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    }

    //ali should only have 1NEAR after those claims as only the first one through
    aliBal = await ali.availableBalance();
    console.log('aliBal After: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // Wait 30 seconds for throttle timestamp to pass
    await new Promise(r => setTimeout(r, 30000));

    // Loop through and claim remaining 4 times with a pause that matches throttle timestamp. This should claim the remaning used on the key
    for (let i = 0; i < 4; i++) {
        await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
        // Wait 30 seconds
        await new Promise(r => setTimeout(r, 30000));
    }

    //ali shoud now howvae 5NEAR after the key was claimed 5 times.
    aliBal = await ali.availableBalance();
    console.log('aliBal After: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("5").toString());
});

test('Testing Account Creation Keypom Args With Custom Drop Root', async t => {
    const { keypom, owner, ali } = t.context.accounts;
    const customKeypomRoot = await keypom.createSubAccount('custom', {initialBalance: NEAR.parse("10").toString()});
    // initialize the custom root with the account factory and add keypom account as the approved creator and the drop funder as the approved funder.
    await customKeypomRoot.deploy(`./__tests__/ext-wasm/account_factory.wasm`);
    await customKeypomRoot.call(customKeypomRoot, 'new', {});
    await customKeypomRoot.call(customKeypomRoot, 'add_approved_creator', {account_id: keypom.accountId});
    await customKeypomRoot.call(customKeypomRoot, 'add_approved_funder', {account_id: owner.accountId});

    let config: DropConfig  = {
        root_account_id: customKeypomRoot.accountId,
        usage: {
            account_creation_fields: {
                funder_id_field: "funder_id"
            }
        }
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    // First create the invalid drop that has the wrong funder_id_field
    await ali.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("2").toString()});

    await keypom.setKey(keys[0]);

    //foo.customKeypomRoot.test.near
    let newAccount = await keypom.getAccount(`foo.${customKeypomRoot.accountId}`);

    // Set the key to be used to claim the drop
    // SHOULD NOT WORK since the funder that is auto passed in is incorrect.
    await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `foo.${customKeypomRoot.accountId}`, new_public_key : publicKeys[0]}, {gas: WALLET_GAS});

    let doesExist = await newAccount.exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, false);

    // Now create the correct drop (using the correct funder)
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("2").toString()});
    
    // Set the key to be used to claim the drop
    await keypom.setKey(keys[0]);
    // SHOULD NOT WORK since the funder that is auto passed in is incorrect.
    await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `foo.${customKeypomRoot.accountId}`, new_public_key : publicKeys[0]}, {gas: WALLET_GAS});

    doesExist = await newAccount.exists();
    console.log('doesExist: ', doesExist)
    t.is(doesExist, true);
});
'''
'''--- __tests__/config-tests/time-configs.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData, assertFTBalance, delay } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })

    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, keypomV3, ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Time Config
//     Start timestamp
//     End Timestamp
//     Throttle timestamp
//     Interval (both with & without start specified)

test('Start, End and Interval', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    const ONE_SECOND_NS = 1e9
    const ONE_SECOND_MS = 1e3
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("0.2").toString()
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1],
            uses: 4,
            config: {
                time:{
                    // Date.now() return ms, convert to ns
                    // 3s buffer added to allow drop creation to complete
                    start: (Date.now() * 1e6) + ONE_SECOND_NS * 13,
                    end: (Date.now() * 1e6) + ONE_SECOND_NS * 80,
                    interval: ONE_SECOND_NS * 15
                }
            }
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 
    

    // ******************* Claiming *******************
    let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 4, true)

    // This should fail as start req not met
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
        shouldPanic: true
    })

    // This should fail as start + interval are violated
    await delay(10*ONE_SECOND_MS)
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
        shouldPanic: true
    })

    // Start + Interval is Respected
    await delay(10*ONE_SECOND_MS)
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId
    })

    keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 3, true)

    // This should fail as interval is not respected
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
        shouldPanic: true
    })

    // Let multiple Intervals Pass, then claim multiple times
    await delay(30*ONE_SECOND_MS);
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId
    })
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId
    })
    keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 1, true)

    // Wait out beyond end time
    await delay(40*ONE_SECOND_MS);
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
        shouldPanic: true
    })
  
    // Key and Drop should still exist here
    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), true)
    t.is(await doesDropExist(keypomV3, dropId), true)
    keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 1, true)
});
    

test('Throttle', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    const ONE_SECOND_NS = 1e9
    const ONE_SECOND_MS = 1e3
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("0.2").toString()
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1],
            uses: 2,
            config: {
                time:{
                    // Date.now() return ms, convert to ns
                    // 3s buffer added to allow drop creation to complete
                    throttle: 30 * ONE_SECOND_NS
                }
            }
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 
    
    // ******************* Claiming *******************
    let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 2, true)

    // This should work
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
    })

    keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 1, true)

    // This should fail as throttle is violated
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId,
        shouldPanic: true
    })

    keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 1, true)

    // Throttle is respected, key should be depleted
    await delay(30*ONE_SECOND_MS)
    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        receiverId: ali.accountId
    })
  
    // Key and Drop should still exist here
    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), false)
});

test('Interval Without Start', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    const ONE_SECOND_NS = 1e9
    const ONE_SECOND_MS = 1e3
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("0.2").toString()
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1],
            uses: 3,
            config: {
                time:{
                    interval: ONE_SECOND_NS * 15
                }
            }
        },
    ]

    // Drop creation should fail... I feel like this should just allow creation and set start as drop creation time
    try{
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'create_drop',
            args: {
                drop_id: dropId,
                asset_data: asset_data_per_use,
                key_data: [{
                    public_key: keyPairs.publicKeys[0],
                }],
            },
        }) 
        t.fail()
    }
    catch{
        t.pass()
    }
    
    

    // ******************* Claiming *******************
    // let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    // t.is(keyInfo.uses_remaining == 3, true)

    // // This should fail as interval will be 15s from drop creation
    // await claimWithRequiredGas({
    //     keypom: keypomV3,
    //     keyPair: keyPairs.keys[0],
    //     root,
    //     receiverId: ali.accountId,
    //     shouldPanic: true
    // })

    // keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    // t.is(keyInfo.uses_remaining == 3, true)

    // // This should work as interval would have been respected
    // await delay(10*ONE_SECOND_MS)
    // await claimWithRequiredGas({
    //     keypom: keypomV3,
    //     keyPair: keyPairs.keys[0],
    //     root,
    //     receiverId: ali.accountId,
    // })

    // keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    // t.is(keyInfo.uses_remaining == 2, true)

    // // Will fail as interval is not respected
    // await claimWithRequiredGas({
    //     keypom: keypomV3,
    //     keyPair: keyPairs.keys[0],
    //     root,
    //     receiverId: ali.accountId,
    //     shouldPanic: true
    // })

    // keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    // t.is(keyInfo.uses_remaining == 2, true)

    // // Wait Multiple Intervals, Claim x2
    // await delay(30*ONE_SECOND_MS)
    // await claimWithRequiredGas({
    //     keypom: keypomV3,
    //     keyPair: keyPairs.keys[0],
    //     root,
    //     receiverId: ali.accountId
    // })
    // await claimWithRequiredGas({
    //     keypom: keypomV3,
    //     keyPair: keyPairs.keys[0],
    //     root,
    //     receiverId: ali.accountId
    // })
  
    // // Key should be done now
    // t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    // t.is(await doesDropExist(keypomV3, dropId), false)
});
'''
'''--- __tests__/config-tests/usage-configs.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData, assertFTBalance } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })

    const keypom_args_linkdrop = await root.createSubAccount(`keypom-args-linkdrop`)
    await keypom_args_linkdrop.deploy(`./__tests__/ext-wasm/create-account-keypom-injected-args-linkdrop.wasm`)
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    
    await ftContract1.deploy(`./__tests__/ext-wasm/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
     
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
   

    await root.call(root, 'new', {});
    await keypom_args_linkdrop.call(keypom_args_linkdrop, 'new', {})
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, ftContract1, keypomV3, ali, keypom_args_linkdrop };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Usage Config
//    Different permissions for keys
//    Auto delete drop when empty
//    Account creation fields being properly sent

// test('Different Permission for Keys + Auto Delete when Empty', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
//     let initialBal = await keypomV3.balance();

//     const dropId = "my-drop-id";
//     const numKeys = 1;
//     let keyPairs = await generateKeyPairs(numKeys);

//     // ******************* Creating Drop *******************
//     const nearAsset1: ExtNearData = {
//         yoctonear: NEAR.parse("0.2").toString()
//     }

//     const asset_data_per_use = [
//         {
//             assets: [nearAsset1],
//             uses: 1,
//             config: {
//                 permissions: "claim"
//             }
//         },
//         {
//             assets: [nearAsset1],
//             uses: 1,
//             config: {
//                 permissions: "create_account_and_claim"
//             }
//         },
//         {
//             assets: [nearAsset1],
//             uses: 2
//         },
//     ]

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data: asset_data_per_use,
//             key_data: [{
//                 public_key: keyPairs.publicKeys[0],
//             }],
//         },
//     }) 

//     // ******************* Claiming *******************
//     let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining == 4, true)
//     // First claim is limited to claim, try CAAC
//     try{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             createAccount: true
//         })
//         t.fail()
//     }catch{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             receiverId: ali.accountId
//         })
//     }

//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining == 3, true)

//     // Second Claim is limited to CAAC, try claim
//     try{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             receiverId: ali.accountId
//         })
//         t.fail()
//     }catch{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             createAccount: true
//         })
//     }

//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining == 2, true)

//     // Next Two Claims not limited
//     // Claim
//     try{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             receiverId: ali.accountId
//         })
//     }catch{
//         t.fail()
//     }

//     keyInfo = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
//     t.is(keyInfo.uses_remaining == 1, true)

//     //CAAC
//     try{
//         await claimWithRequiredGas({
//             keypom: keypomV3,
//             keyPair: keyPairs.keys[0],
//             root,
//             createAccount: true
//         })
//     }catch{
//         t.fail()
//     }

//     t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
//     t.is(await doesDropExist(keypomV3, dropId), false)
//     let finalBal = await keypomV3.balance();
//     t.deepEqual(initialBal.stateStaked, finalBal.stateStaked)
// });

test('Account creation fields being properly sent', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, keypom_args_linkdrop} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("0.2").toString()
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1],
            uses: 1,
            config: {
                account_creation_keypom_args: {
                    drop_id_field: "keypom_drop_id"
                },
                root_account_id: keypom_args_linkdrop.accountId
            }
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    // ******************* Claiming *******************
    let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: keyPairs.publicKeys[0]});
    t.is(keyInfo.uses_remaining == 1, true)

    //CAAC
    try{
        await claimWithRequiredGas({
            keypom: keypomV3,
            keyPair: keyPairs.keys[0],
            root,
            createAccount: true,
            receiverId: "abcdefghijklmnopqrstuvwxyz1234567.keypom-args-linkdrop.test.near"
        })
    }catch{
        t.fail()
    }

    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), false)
    let finalBal = await keypomV3.balance();
    t.deepEqual(initialBal.stateStaked, finalBal.stateStaked)
});

'''
'''--- __tests__/creation/create-and-add.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Panic Ensure No Keys Added (duplicate keys)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(70);
//     keyPairs.publicKeys.push(keyPairs.publicKeys[0]);

//     // First 70 are good and the last is repeated. No keys should be added
//     // And the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     // // PK already exists on the contract
//     // await functionCall({
//     //     signer: funder,
//     //     receiver: keypomV3,
//     //     methodName: 'add_keys',
//     //     args: {
//     //         drop_id: dropId,
//     //         public_keys: keyPairs.publicKeys
//     //     },
//     //     attachedDeposit: NEAR.parse("10").toString()
//     // })

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Panic Ensure No Keys Added (too many actions)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(101);

//     // There are more than 100 actions so the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Adding Keys', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftAsset: FTAsset = {
//         contract_id: "foo.bar",
//         registration_cost: NEAR.parse("1").toString(),
//         amount: NEAR.parse("1").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [ftAsset],
//     }
//     let keyPairs = await generateKeyPairs(1);

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//     })

//     keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 2)

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 3);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Not enough $NEAR attached', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     const nearAsset2 = {
//         yoctonear: NEAR.parse("2").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nearAsset1],
//         2: [nearAsset1, nearAsset2],
//         3: [nearAsset1, nearAsset2, nearAsset2],
//     }

//     let keyPairs = await generateKeyPairs(70);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Not enough $NEAR attached', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }
 
//     const nearAsset2 = {
//         yoctonear: NEAR.parse("2").toString()
//     }
    
//     const ftAsset1 = {
//         contract_id: "foo.bar",
//         registration_cost: NEAR.parse("1").toString(),
//         amount: NEAR.parse("1").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nearAsset1, ftAsset1, null]
//     }

//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     let dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

test('Not enough $NEAR attached', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }
 
    //const nearAsset2 = {
    //     yoctonear: NEAR.parse("2").toString()
    // }
    
    // const ftAsset1 = {
    //     contract_id: "foo.bar",
    //     registration_cost: NEAR.parse("1").toString(),
    //     amount: NEAR.parse("1").toString()
    // }

    const dropId = "drop-id";
    // Create an object with keys from 1 -> 1000 and every value is [nearAsset1]
    const assets_per_use = {
        ...Array.from(Array(1000).keys()).reduce((acc, cur) => {
            acc[cur + 1] = [nearAsset1]
            return acc
        }
        , {})
    }
    console.log('assets_per_use: ', assets_per_use)

    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    let dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/creation/drop-payment.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, ExtNearData, InternalNFTData, InternalFTData } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('20.2 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, ali };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// 1. Deposit can cover all
// 2. Balance can cover all
// 3. Deposit not enough, but with balance, it can be covered
// 3.5. Balance is not enough, but with deposit, it can be covered
// 4. Neither is enough

test('Paying all with Deposit', async t => {
    const {funder, keypomV3, root,
         ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1: ExtNearData = {
        yoctonear: toYocto("6")
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1]
        },
    ]

    let preCreateBalance: {available: NEAR} = await funder.balance()
    // Expect Balance here to be about 10 NEAR
    t.is(parseInt(formatNearAmount(preCreateBalance.available.toString(), 1)) == 10, true)
    console.log(`Pre Bal: ${formatNearAmount(preCreateBalance.available.toString(), 5)}`)
    
    // This will nearly drain balance
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{public_key: keyPairs.publicKeys[0]}]
            // public_keys: [keyPairs.publicKeys[0]]
        },
        attachedDeposit: NEAR.parse("10").toString(),
    })

    let postCreateBalance: {available: NEAR} = await funder.balance()
    console.log(`Post Bal: ${formatNearAmount(postCreateBalance.available.toString(), 5)}`)
    let amountUsed = BigInt(preCreateBalance.available.toString()) - BigInt(postCreateBalance.available.toString())

    // Amount used should be around 6 NEAR. Failure here would show an invalid/unsuccessful refund
    t.is(amountUsed > BigInt(NEAR.parse("6").toString()), true)
    t.is(amountUsed < BigInt(NEAR.parse("7").toString()), true)
});

test('Paying all with Balance', async t => {
    const {funder, keypomV3, root,
         ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1: ExtNearData = {
        yoctonear: toYocto("6")
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1]
        },
    ]

    let preCreateNearBalance: {available: NEAR} = await funder.balance()

    let preCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    console.log(`Pre Keypom Bal: ${preCreateBal}`)

    // This will nearly drain balance
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{public_key: keyPairs.publicKeys[0]}]
            // public_keys: [keyPairs.publicKeys[0]]
        },
    })

    let postCreateNearBalance: {available: NEAR} = await funder.balance()
    let postCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let refund = formatNearAmount((BigInt(preCreateBal) - BigInt(postCreateBal)).toString(), 5);

    // Ensure NEAR balance has not changed witin 2 dec places as Gas is estimated to be 0.001 NEAR for creating drop
    let nearBalChange = formatNearAmount((BigInt(preCreateNearBalance.available.toString()) - BigInt(postCreateNearBalance.available.toString())).toString(), 2)
    t.is(nearBalChange == "0", true)

    // Amount used should be around 6 NEAR. Failure here would show an invalid/unsuccessful refund  
    t.is(refund > "6", true)
    t.is(refund < "7", true)
});

test('Paying with Both', async t => {
    const {funder, keypomV3, root,
         ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    const nearAsset1: ExtNearData = {
        yoctonear: toYocto("15")
    }

    const asset_data_per_use = [
        {
            assets: [nearAsset1]
        },
    ]

    // Pre drop creation near and keypom balances
    let preCreateNearBalance: {available: NEAR} = await funder.balance()
    let preCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    
    // Expect Balance here to be about 10 NEAR
    t.is(parseInt(formatNearAmount(preCreateNearBalance.available.toString(), 1)) == 10, true)
    
    // This will nearly drain balance
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{public_key: keyPairs.publicKeys[0]}]
            // public_keys: [keyPairs.publicKeys[0]]
        },
        attachedDeposit: NEAR.parse("10").toString(),
    })

    // get near and keypom balances after drop creation
    let postCreateNearBalance: {available: NEAR} = await funder.balance()
    let postCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

    // get changes in both, rounded to nearest 0.1 just as a rough estimate and eliminate factors such as gas
    let balanceChange = formatNearAmount((BigInt(preCreateBal) - BigInt(postCreateBal)).toString(), 1);
    let NEARamountUsed = formatNearAmount((BigInt(preCreateNearBalance.available.toString()) - BigInt(postCreateNearBalance.available.toString())).toString(), 1)

    // Amount used should be around 10 NEAR
    console.log(NEARamountUsed)
    t.is(NEARamountUsed == "10", true)
    // Keypom Balance should make up for rest, roughly 5 NEAR
    console.log(balanceChange)
    t.is(balanceChange == "5", true)
});

'''
'''--- __tests__/creation/edge-creation.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, InternalNFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })

    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);

    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });
    await nftContract2.call(nftContract2, 'new_default_meta', { owner_id: nftContract2 });

    // const ftContract1 = await root.createSubAccount('ft_contract_1');
    // const ftContract2 = await root.createSubAccount('ft_contract_2');

    // await ftContract1.deploy(`./__tests__/ext-wasm/ft.wasm`);
    // await ftContract2.deploy(`./__tests__/ext-wasm/ft.wasm`);

    
    // await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    // await ftContract2.call(ftContract2, 'new_default_meta', { owner_id: ftContract2, total_supply: totalSupply.toString() });

    // Deposit storage
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // Send FTs
    // await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    // await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    await functionCall({
        signer: funder,
        receiver: nftContract2,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract, nftContract2,  };
    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Multi-assets 
test('Ensuring drop creation gas limit is accurate', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 1;
    let keyPairs = await generateKeyPairs(numKeys + 1);

    const nftAsset1 = {
        nft_contract_id: nftContract.accountId
    }

    const assets_per_use = {
        1: [nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1, 
            nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1, 
            nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1,
            nftAsset1, nftAsset1, nftAsset1, nftAsset1, nftAsset1]
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys.slice(0, -1)
        },
        attachedDeposit: NEAR.parse("10").toString(),
    })

    // 12TGas for NFT asset, 20 tokens + other gas = 293TGas
    let tokenIds: string[]= [];
    let numTokens = 20;
    for (let i = 1; i < numTokens+1; i++) {
        let tokenId = `token-1-${i}`

        await functionCall({
            signer: funder,
            receiver: nftContract,
            methodName: 'nft_mint',
            args: {
                token_id: tokenId,
                metadata: {
                    title: "my token"
                },
                receiver_id: funder.accountId
            },
            attachedDeposit: NEAR.parse("0.01").toString(),
            shouldLog: true
        })

        await functionCall({
            signer: funder,
            receiver: nftContract,
            methodName: 'nft_transfer_call',
            args: {
                receiver_id: keypomV3.accountId,
                token_id: tokenId,
                msg: dropId
            },
            attachedDeposit: "1"
        })

        tokenIds.push(tokenId)
    }

    // Assert Assets
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract.accountId,
            token_ids: tokenIds
        },],
    })

    console.log(`new PK: ${keyPairs.publicKeys[-1]}`)
    // CAAC
    await claimWithRequiredGas({
        keypomV3,
        root,
        key: keyPairs.keys[0],
        publicKey: keyPairs.publicKeys[0],
        createAccount: true,
    })

    // After a succesful claim, Keypom keys should be back to just the one FAK
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

});

// Lots of Keys
// test('Bunch of Keys', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     // must be multiple of 100
//     const numKeys = 10000;
//     let keyPairs = await generateKeyPairs(numKeys);
    
//     const assets_per_use = {
//         1: [null],
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: []
//         },
//         attachedDeposit: NEAR.parse("0.01").toString(),
//     })

//     let keysAdded = 0
//     while(keysAdded < numKeys){
//         let keyPairs = await generateKeyPairs(100);
//         // PK already exists on the contract
//         await functionCall({
//             signer: funder,
//             receiver: keypomV3,
//             methodName: 'add_keys',
//             args: {
//                 drop_id: dropId,
//                 public_keys: keyPairs.publicKeys
//             },
//             attachedDeposit: NEAR.parse("1.4518865").toString()
//         })
//         keysAdded += 100;
//         console.log(`Keys added: ${keysAdded}`)
//     }
    

//     // Keys should not have changed from last time since drop creation has failed
//     let keypomKeys2 = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys2.keys.length, numKeys + 1);
// });

// Empty
// test('Empty', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2, nftContract, nftContract2} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
    
//     const assets_per_use = {
//         1: [null],
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: []
//         },
//         attachedDeposit: NEAR.parse("0.01").toString(),
//     })
    
//     // Keys should not have changed from last time since drop creation has failed
//     let keypomKeys2 = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys2.keys.length, 0);
// });

'''
'''--- __tests__/creation/failed-creation.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection, claimWithRequiredGas } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, InternalNFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });

    const ftContract1 = await root.createSubAccount('ft_contract_1');

    await ftContract1.deploy(`./__tests__/ext-wasm/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract, ftContract1 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Not enough balance / deposit
test('Insufficient Balance + Deposit', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "drop-id";
    let keyPairs = await generateKeyPairs(90);

    const nearAsset1 = {
        yoctonear: NEAR.parse("10").toString()
    }
    const assets_per_use = {
        1: [nearAsset1],
    }

    // 90*10NEAR per use; balance + deposit must be more than 900 NEAR. This will panic
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: "0",
        shouldPanic: true
    })

    try {
        let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Should have panicked')
    } catch (e) {
        t.pass()
    }

    // Checking no keys were added, balances did not change etc. 
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
    t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
});

// Conflicting public keys
test('Conflicting Keys', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const dropId = "drop-id";
    const assets_per_use = {
        1: [null],
    }
    let keyPairs = await generateKeyPairs(70);
    keyPairs.publicKeys.push(keyPairs.publicKeys[0]);

    // First 70 are good and the last is repeated. No keys should be added
    // And the contract should panic
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString(),
        shouldPanic: true
    })

    try {
        let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Should have panicked')
    } catch (e) {
        t.pass()
    }

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
    t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
});

// Conflicting drop IDs
test('Conflicting DropIDs', async t => {
    const {funder, keypomV3, root} = t.context.accounts;

    const dropId = "drop-id";
    const assets_per_use = {
        1: [null],
    }
    let keyPairs = await generateKeyPairs(5);

    // Add 5 keys
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString(),
        shouldPanic: false
    })

    // 1 FAK, 5 newly added LAK
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 6);

    let initialBadBal = await keypomV3.balance();

    // Creating second drop with identical drop ID
    let keyPairs2 = await generateKeyPairs(5);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs2.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString(),
        shouldPanic: false
    })

    // Keys should not have changed from last time since drop creation has failed
    let keypomKeys2 = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys2.keys.length, 6);

    let finalBal = await keypomV3.balance();
    displayBalances(initialBadBal, finalBal);
    t.deepEqual(finalBal.stateStaked, initialBadBal.stateStaked);
});

// Really really really long drop ID
test('Really long DropIDs', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    // Massive Drop ID, this far exceeds the 2048Byte limit and will panic
    const dropId = "Tying shoelaces is a fundamental skill that most people learn at an early age, and it is an important step towards becoming self-sufficient. Although it may seem like a simple task, mastering the art of tying shoes can ensure a secure and comfortable fit throughout the day. Here's a step-by-step guide to help you tie your shoes with ease and confidence. Start by holding one shoelace in each hand, making sure the lengths are equal. Cross the laces over each other, creating an X shape. Take the lace on the right side and pass it over the lace on the left side, threading it through the space between the two laces. Now, pull both ends of the laces firmly to tighten the knot, ensuring the knot is positioned near the base of the shoelaces. Congratulations, you've successfully tied the first part! Moving on, create two loops with the laces, holding one loop in each hand. Cross the loops over each other, forming another X shape. Take the loop in your right hand and pass it over the loop in your left hand, threading it through the space between the loops. Hold the loops firmly and pull them outward to tighten the knot, making sure the loops are of equal size. This is the crucial moment when your shoes start taking shape. To complete the process, grab the loops and give them a slight tug to secure the knot firmly. Optionally, you can tuck the loops under the shoelace knot for a cleaner look and to prevent tripping. Now, you're ready to confidently walk, run, or engage in any activity without worrying about loose shoelaces. Congratulations, you've mastered the basic bunny ears method! However, if you prefer an alternative method, you can try the Ian knot method, which is faster but may take some time to learn. Here's a brief overview of the Ian knot: Start by crossing the laces over each other, just like in the previous method. Take the lace on the right side and pass it under the lace on the left side. Next, bring the end of the right lace through the space between the laces, creating a loop aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!";
    const assets_per_use = {
        1: [null],
    }
    let keyPairs = await generateKeyPairs(5);

    // Add 5 keys
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldPanic: true
    })
    

    // Keys should not have changed from last time since drop creation has failed
    let keypomKeys2 = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys2.keys.length, 1);

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
    t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
});

// Invalid args passed in (use number out of bounds)
test('Undefined Uses', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    // Massive Drop ID, this far exceeds the 2048Byte limit and will panic
    const dropId = "drop-id";
    // Uses missing 4 and 5 - 3 are swapped
    const assets_per_use = {
        1: [null],
        2: [null],
        5: [null],
        3: [null],
        // Adding this line will cause the drop creation to pass - order does not matter, simply that there are no missing uses
        // 4: [null],
    }
    let keyPairs = await generateKeyPairs(2);

    // Add 2 keys
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldPanic: true
    })

    // Keys should not have changed from last time since drop creation has failed
    let keypomKeys2 = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys2.keys.length, 1);

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
    t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
});

// Too many assets in a use leading to gas problems (try to force a panic as late down the road as possible i.e first 15 uses are fine but last one is not).

// Create function call drop with invalid permissions (pointing to keypom, invalid method names etc…)
'''
'''--- __tests__/creation/fc-creation.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { claimWithRequiredGas, displayBalances, functionCall, generateKeyPairs } from "../utils/general";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    console.log('root: ', root)
    
    const keypomV3 = await root.createSubAccount('keypom');
    console.log('keypomV3: ', keypomV3.accountId)

    // Test users
    const funder = await root.createSubAccount('funder');
    console.log('funder: ', funder.accountId)
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    console.log('Deployed contracts: ', keypomV3.accountId)
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Panic Ensure No Keys Added (duplicate keys)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(70);
//     keyPairs.publicKeys.push(keyPairs.publicKeys[0]);

//     // First 70 are good and the last is repeated. No keys should be added
//     // And the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     // // PK already exists on the contract
//     // await functionCall({
//     //     signer: funder,
//     //     receiver: keypomV3,
//     //     methodName: 'add_keys',
//     //     args: {
//     //         drop_id: dropId,
//     //         public_keys: keyPairs.publicKeys
//     //     },
//     //     attachedDeposit: NEAR.parse("10").toString()
//     // })

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Panic Ensure No Keys Added (too many actions)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(101);

//     // There are more than 100 actions so the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Adding Keys', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftAsset: FTAsset = {
//         contract_id: "foo.bar",
//         registration_cost: NEAR.parse("1").toString(),
//         amount: NEAR.parse("1").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [ftAsset],
//     }
//     let keyPairs = await generateKeyPairs(1);

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//     })

//     keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 2)

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 3);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Not enough $NEAR attached', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     const nearAsset2 = {
//         yoctonear: NEAR.parse("2").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nearAsset1],
//         2: [nearAsset1, nearAsset2],
//         3: [nearAsset1, nearAsset2, nearAsset2],
//     }

//     let keyPairs = await generateKeyPairs(70);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

test('Initial Test', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    let method1 = {
        receiver_id: keypomV3.accountId,
        method_name: 'create_drop',
        args: JSON.stringify({}),
        attached_deposit: NEAR.parse("1").toString(),
        attached_gas: "10000000000000",
    }

    const fcAsset1 = {
        methods: [method1, method1, method1, method1]
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [fcAsset1, fcAsset1, fcAsset1]
    }

    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("100").toString()
    })

    await claimWithRequiredGas({
        keypomV3,
        root,
        key: keyPairs.keys[0],
        publicKey: keyPairs.publicKeys[0]
    })

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/creation/near-creation.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Panic Ensure No Keys Added (duplicate keys)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(70);
//     keyPairs.publicKeys.push(keyPairs.publicKeys[0]);

//     // First 70 are good and the last is repeated. No keys should be added
//     // And the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     // // PK already exists on the contract
//     // await functionCall({
//     //     signer: funder,
//     //     receiver: keypomV3,
//     //     methodName: 'add_keys',
//     //     args: {
//     //         drop_id: dropId,
//     //         public_keys: keyPairs.publicKeys
//     //     },
//     //     attachedDeposit: NEAR.parse("10").toString()
//     // })

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Panic Ensure No Keys Added (too many actions)', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [null],
//     }
//     let keyPairs = await generateKeyPairs(101);

//     // There are more than 100 actions so the contract should panic
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

// test('Adding Keys', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftAsset: FTAsset = {
//         contract_id: "foo.bar",
//         registration_cost: NEAR.parse("1").toString(),
//         amount: NEAR.parse("1").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [ftAsset],
//     }
//     let keyPairs = await generateKeyPairs(1);

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//     })

//     keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 2)

//     keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 3);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Not enough $NEAR attached', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nearAsset1 = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     const nearAsset2 = {
//         yoctonear: NEAR.parse("2").toString()
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nearAsset1],
//         2: [nearAsset1, nearAsset2],
//         3: [nearAsset1, nearAsset2, nearAsset2],
//     }

//     let keyPairs = await generateKeyPairs(70);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString(),
//         shouldPanic: true
//     })

//     try {
//         let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//         console.log('keysForDrop: ', keysForDrop)
//         t.fail('Should have panicked')
//     } catch (e) {
//         t.pass()
//     }

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
//     t.deepEqual(finalBal.stateStaked, initialBal.stateStaked);
// });

test('Not enough $NEAR attached', async t => {
    const {funder, keypomV3, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const nearAsset1 = {
        yoctonear: NEAR.parse("1").toString()
    }
 
    const nearAsset2 = {
        yoctonear: NEAR.parse("2").toString()
    }
    
    const ftAsset1 = {
        contract_id: "foo.bar",
        registration_cost: NEAR.parse("1").toString(),
        amount: NEAR.parse("1").toString()
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [nearAsset1, ftAsset1, null]
    }

    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 1)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 2);

    let dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/creation/nft-creation.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, InternalNFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });

    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Simple NFT Creation', async t => {
//     const {funder, keypomV3, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nftAsset1 = {
//         nft_contract_id: "foobar.test.near"
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nftAsset1]
//     }

//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log(`dropInfo: ${JSON.stringify(dropInfo)}`)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     t.is((dropInfo.internal_assets_data[0] as InternalNFTData).nft.token_ids.length, 0);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Add NFTs to created drop', async t => {
//     const {funder, keypomV3, nftContract, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nftAsset1 = {
//         nft_contract_id: nftContract.accountId
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nftAsset1]
//     }

//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys,
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: nftContract,
//         methodName: 'nft_transfer_call',
//         args: {
//             receiver_id: keypomV3.accountId,
//             token_id: "token1",
//             msg: dropId
//         },
//         attachedDeposit: "1"
//     })

//     let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
//     t.assert(NEAR.parse(userBal).lt(NEAR.from("10")));

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log(`dropInfo: ${JSON.stringify(dropInfo)}`)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     t.is((dropInfo.internal_assets_data[0] as InternalNFTData).nft.token_ids.length, 1);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Add a Ton of NFTs', async t => {
//     const {funder, keypomV3, nftContract, root} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const nftAsset1 = {
//         nft_contract_id: nftContract.accountId
//     }

//     const dropId = "drop-id";
//     const assets_per_use = {
//         1: [nftAsset1]
//     }

//     let keyPairs = await generateKeyPairs(1);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             assets_per_use,
//             public_keys: keyPairs.publicKeys,
//         },
//         attachedDeposit: NEAR.parse("10").toString()
//     })

//     // loop 50 times
//     for (let i = 0; i < 50; i++) {
//         await functionCall({
//             signer: nftContract,
//             receiver: keypomV3,
//             methodName: 'nft_on_transfer',
//             args: {
//                 sender_id: funder.accountId,
//                 token_id: `token${i}`,
//                 msg: dropId
//             }
//         })
//     }

//     let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
//     t.assert(NEAR.parse(userBal).lt(NEAR.from("10")));

//     let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
//     console.log('keysForDrop: ', keysForDrop)
//     t.is(keysForDrop, 1)

//     let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
//     t.is(keypomKeys.keys.length, 2);

//     let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log(`dropInfo: ${JSON.stringify(dropInfo)}`)
//     t.is(dropInfo.internal_assets_data.length, 1);
//     t.is((dropInfo.internal_assets_data[0] as InternalNFTData).nft.token_ids.length, 50);

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });
'''
'''--- __tests__/creation/nft-funding.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    const nftContract1 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    await nftContract1.call(nftContract1, 'new_default_meta', { owner_id: nftContract1});

    const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    await nftContract2.call(nftContract2, 'new_default_meta', { owner_id: nftContract2});
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, keypomV3, nftContract1, nftContract2, ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Sending really long token IDs
// Sending a TON of token IDs
// Sending tokens to a non NFT drop
// Sending tokens to the wrong drop

// Ensure user is being charged and balance decrements
// Ensure tokens are being added to drop info
// Ensure that if the internal vector gets really long for token IDs, there isn’t a gas hit (measure gas for the case of a ton of token IDs)

test('Really Long TokenID', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nftAsset1: ExtNFTData = {
        nft_contract_id: nftContract1.accountId
    }

    const asset_data_per_use = [
        {
            assets: [nftAsset1]
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            public_keys: [keyPairs.publicKeys[0]]
        },
    }) 

    // ******************* Adding Assets *******************
    let token_id = `${Date.now().toString().repeat(45)}`

    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

    await functionCall({
        signer: nftContract1,
        receiver: keypomV3,
        methodName: 'nft_on_transfer',
        args: {
            sender_id: funder.accountId,
            token_id,
            msg: dropId
        }
    })

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    t.is(balChange > "0", true)

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids: [token_id]
        }],
    })
});

test('A bunch of TokenIDs', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nftAsset1: ExtNFTData = {
        nft_contract_id: nftContract1.accountId
    }

    const asset_data_per_use = {
        assets: Array(17).fill(nftAsset1),
        num_uses: 10
    };
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            public_keys: [keyPairs.publicKeys[0]]
        },
    }) 

    // ******************* Adding Assets *******************
    let preCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

    const NUM_TOKENS: number = 170
    let token_ids: string[] = []
    for(let i = 1; i <= NUM_TOKENS; i++){
        let token_id: string = `my-drop-token-of-number-${i}`
        await functionCall({
            signer: nftContract1,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                sender_id: funder.accountId,
                token_id,
                msg: dropId
            }
        })
        token_ids.push(token_id);
    }

    let postCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preCreateBal) - BigInt(postCreateBal)).toString(), 5);

    t.is(balChange > "0", true)
    console.log(balChange)
    t.is(token_ids.length == NUM_TOKENS, true)

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids
        }],
    })
});

// ************** This covers case of asset ID not being present **************
test('Tokens to a non-NFT drop', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data = {
        assets: [nearAsset1],
        num_uses: 1
    };

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            public_keys: [keyPairs.publicKeys[0]]
        },
    }) 

    // ******************* Adding Assets *******************
    let token_id: string = `my-drop-token`

    let preCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    try{
        await functionCall({
            signer: funder,
            receiver: nftContract1,
            methodName: 'nft_mint',
            args: {
                token_id,
                metadata: {
                    title: "my token",
                    description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
                    media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
                },
                receiver_id: funder.accountId
            },
            attachedDeposit: NEAR.parse("0.01").toString(),
            shouldLog: true
        })
    
        await functionCall({
            signer: funder,
            receiver: nftContract1,
            methodName: 'nft_transfer_call',
            args: {
                receiver_id: keypomV3.accountId,
                token_id,
                msg: dropId
            },
            attachedDeposit: "1"
        })
    }catch(e){ 
    }
    

    let postCreateBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preCreateBal) - BigInt(postCreateBal)).toString(), 5);
    console.log(balChange)
    // No asset transfer thus no balance change
    t.is(balChange == "0", true)

    // Token should NOT show up in expected assets
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [],
    })
});

// ************** This covers case of sending assets to not your drop **************
test('Tokens to the Wrong Drop - Others with Same Assets', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, nftContract2, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const wrongDropId = "wrong-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nftAsset1: ExtNFTData = {
        nft_contract_id: nftContract1.accountId
    }

    const asset_data = [
        {
            assets: [nftAsset1]
        },
    ]

    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: wrongDropId,
            asset_data,
            public_keys: [keyPairs.publicKeys[0]]
        },
    }) 

    // ******************* Adding Assets *******************
    let token_id = `${Date.now().toString().repeat(45)}`

    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    try{
        await functionCall({
            signer: nftContract1,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                sender_id: funder.accountId,
                token_id,
                msg: wrongDropId
            }
        })
    }catch(e){

    }

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    t.is(balChange == "0", true)

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId: wrongDropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids: []
        }],
    })
});

'''
'''--- __tests__/deletion/ft-multi-use.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertFTBalance, assertKeypomInternalAssets, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, InternalFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await keypomV3.call(keypomV3, 'new', {root_account: root.accountId});
    // Test users
    const funder = await root.createSubAccount('funder');

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    const ftContract2 = await root.createSubAccount('ft_contract_2');
    const ftContract3 = await root.createSubAccount('ft_contract_3');
    
    await ftContract1.deploy(`./out/ft.wasm`);
    await ftContract2.deploy(`./out/ft.wasm`);
    await ftContract3.deploy(`./out/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    await ftContract2.call(ftContract2, 'new_default_meta', { owner_id: ftContract2, total_supply: totalSupply.toString() });
    await ftContract3.call(ftContract3, 'new_default_meta', { owner_id: ftContract3, total_supply: totalSupply.toString() });
    
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, ftContract1, ftContract2, ftContract3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Underpay, Withdraw, Delete', async t => {
    const {funder, ftContract1, ftContract2, ftContract3, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("1").toString()
    }
    const ftAsset2: ExtFTData = {
        ft_contract_id: ftContract2.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("2").toString()
    }
    const ftAsset3: ExtFTData = {
        ft_contract_id: ftContract3.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("3").toString()
    }

    const dropId = "underpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset1, ftAsset2],
        2: [ftAsset2, ftAsset3],
        3: [ftAsset1, ftAsset3]
    }
    let keyPairs = await generateKeyPairs(50);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract2.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract3.accountId,
                balance_avail: '0',
        }]
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await sendFTs(funder, "5", keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '5'
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '5',
            },{
                contract_id: ftContract2.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract3.accountId,
                balance_avail: '0',
        }]
    })

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '5',
            },{
                contract_id: ftContract2.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract3.accountId,
                balance_avail: '0',
        }]
    })

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: '5'
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '0'
    });

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: funder.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract2.accountId,
                balance_avail: '0',
            },{
                contract_id: ftContract3.accountId,
                balance_avail: '0',
        }]
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    // After keys have been deleted, 50 * (0.0125 * 6) = 3.75 should be returned to the funder
    let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
    console.log('userBal: ', userBal)
    t.assert(NEAR.from(userBal).gte(NEAR.parse("3.75")))

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Overpay, Withdraw, Delete', async t => {
    const {funder, ftContract1, ftContract2, ftContract3, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("1").toString()
    }
    const ftAsset2: ExtFTData = {
        ft_contract_id: ftContract2.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("2").toString()
    }
    const ftAsset3: ExtFTData = {
        ft_contract_id: ftContract3.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("3").toString()
    }

    const dropId = "underpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset1, ftAsset2],
        2: [ftAsset2, ftAsset3],
        3: [ftAsset1, ftAsset3]
    }
    let keyPairs = await generateKeyPairs(50);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        t.is(ftAsset.ft.balance_avail, '0');
    }

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

    let keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
    console.log('keypomFTBal: ', keypomFTBal)
    t.is(keypomFTBal, NEAR.parse("1000").toString());
    
    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after failed deletion: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: NEAR.parse("1000").toString()
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
    console.log('keypomFTBal: ', keypomFTBal)
    t.is(keypomFTBal, '0')

    let funderFTBal = await ftContract1.view('ft_balance_of', {account_id: funder.accountId});
    console.log('funderFTBal: ', funderFTBal)
    t.is(funderFTBal, NEAR.parse("1000").toString());

    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after failed deletion: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;
        
        t.is(ftAsset.ft.balance_avail, '0');
    }

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    // After keys have been deleted, 50 * 6 * 0.0125 = 3.75 should be returned to the funder
    let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
    console.log('userBal: ', userBal)
    t.assert(NEAR.from(userBal).gte(NEAR.parse("3.75")))

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', dropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Create & Delete Empty Drop', async t => {
    const {funder, ftContract1, ftContract2, ftContract3, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("1").toString()
    }
    const ftAsset2: ExtFTData = {
        ft_contract_id: ftContract2.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("2").toString()
    }
    const ftAsset3: ExtFTData = {
        ft_contract_id: ftContract3.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("3").toString()
    }

    const dropId = "overpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset1, ftAsset2],
        2: [ftAsset2, ftAsset3],
        3: [ftAsset1, ftAsset3]
    }
    let keyPairs = await generateKeyPairs(0);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo: ExtDrop = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        t.is(ftAsset.ft.balance_avail, '0');
    }

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

    let keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
    console.log('keypomFTBal: ', keypomFTBal)
    t.is(keypomFTBal, NEAR.parse("1000").toString());
    
    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after failed deletion: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;

        if (ftAsset.ft.contract_id === ftContract1.accountId) {
            t.is(ftAsset.ft.balance_avail, NEAR.parse("1000").toString());
        } else {
            t.is(ftAsset.ft.balance_avail, '0');
        }
    }

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: NEAR.parse("1000").toString()
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    keypomFTBal = await ftContract1.view('ft_balance_of', {account_id: keypomV3.accountId});
    console.log('keypomFTBal: ', keypomFTBal)
    t.is(keypomFTBal, '0')

    let funderFTBal = await ftContract1.view('ft_balance_of', {account_id: funder.accountId});
    console.log('funderFTBal: ', funderFTBal)
    t.is(funderFTBal, NEAR.parse("1000").toString());

    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after failed deletion: ', dropInfo)
    for (var asset of dropInfo.internal_assets_data) {
        let ftAsset = asset as InternalFTData;
        
        t.is(ftAsset.ft.balance_avail, '0');
    }

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', dropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

'''
'''--- __tests__/deletion/ft-single-use.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertFTBalance, assertKeypomInternalAssets, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, InternalFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await keypomV3.call(keypomV3, 'new', {root_account: root.accountId});
    // Test users
    const funder = await root.createSubAccount('funder');

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    const ftContract2 = await root.createSubAccount('ft_contract_2');
    const ftContract3 = await root.createSubAccount('ft_contract_3');
    
    await ftContract1.deploy(`./out/ft.wasm`);
    await ftContract2.deploy(`./out/ft.wasm`);
    await ftContract3.deploy(`./out/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
    await ftContract2.call(ftContract2, 'new_default_meta', { owner_id: ftContract2, total_supply: totalSupply.toString() });
    await ftContract3.call(ftContract3, 'new_default_meta', { owner_id: ftContract3, total_supply: totalSupply.toString() });
    
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})

    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract2, receiver: ftContract2, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
    await functionCall({signer: ftContract3, receiver: ftContract3, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, ftContract1, ftContract2, ftContract3 };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Underpay, Withdraw, Delete', async t => {
    const {funder, ftContract1, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftContractData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
    }
    const ftAsset: ExtFTData = {
        ...ftContractData,
        ft_amount: NEAR.parse("1").toString()
    }

    const dropId = "underpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset],
    }
    let keyPairs = await generateKeyPairs(50);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString(),
    })

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await sendFTs(funder, "5", keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '5'
    });
    
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '5',
        }]
    })

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '5',
        }]
    })

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: '5'
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '0'
    });

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: funder.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    // After keys have been deleted, 50 * 0.0125 = 0.625 should be returned to the funder
    let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
    console.log('userBal: ', userBal)
    t.assert(NEAR.from(userBal).gte(NEAR.parse("0.625")))

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Overpay, Withdraw, Delete', async t => {
    const {funder, ftContract1, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftContractData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
    }
    const ftAsset: ExtFTData = {
        ...ftContractData,
        ft_amount: NEAR.parse("1").toString()
    }

    const dropId = "overpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset],
    }
    let keyPairs = await generateKeyPairs(50);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });
    
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: NEAR.parse("1000").toString(),
        }]
    })

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: NEAR.parse("1000").toString(),
        }]
    })

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 50)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 51);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: NEAR.parse("1000").toString()
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '0'
    });

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: funder.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    // After keys have been deleted, 50 * 0.0125 = 0.625 should be returned to the funder
    let userBal: string = await keypomV3.view('get_user_balance', {account_id: funder.accountId});
    console.log('userBal: ', userBal)
    t.assert(NEAR.from(userBal).gte(NEAR.parse("0.625")))

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Create & Delete Empty Drop', async t => {
    const {funder, ftContract1, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftContractData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
    }
    const ftAsset: ExtFTData = {
        ...ftContractData,
        ft_amount: NEAR.parse("1").toString()
    }

    const dropId = "overpay, withdraw, delete";
    const assets_per_use = {
        1: [ftAsset],
    }
    let keyPairs = await generateKeyPairs(0);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    await sendFTs(funder, NEAR.parse("1000").toString(), keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: NEAR.parse("1000").toString(),
        }]
    })

    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have failed since not all assets are withdrawn')
    } catch(e) {
        t.pass();
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: NEAR.parse("1000").toString(),
        }]
    })

    keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 0)

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_ft_balance',
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: NEAR.parse("1000").toString()
        },
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '0'
    });

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: funder.accountId,
        amountOwned: NEAR.parse("1000").toString()
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
            contract_id: ftContract1.accountId,
            balance_avail: '0',
        }]
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'delete_keys',
        args: {drop_id: dropId},
        gas: LARGE_GAS,
        attachedDeposit: "0"
    })

    try {
        keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
        console.log('keysForDrop: ', keysForDrop)
        t.fail('Drop should have been deleted so method should panic')
    } catch (e) {
        t.pass();
    }

    keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    t.is(keypomKeys.keys.length, 1);

    let endingDropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo (after drop is deleted): ', endingDropInfo)
    t.is(endingDropInfo, null);
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

// Add a test to ensure that if incorrect public keys are passed in and a panic occurs, keys aren't deleted
test('Panic In Deletion, Ensure Keys Are Not Deleted', async t => {
    const {funder, ftContract1, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftAsset: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("1").toString()
    }

    const dropId = "deletion-test";
    const assets_per_use = {
        1: [ftAsset],
    }
    let keyPairs = await generateKeyPairs(40);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    // First 40 PKs correctly belong to drop but the last 1 does not 
    let pksToDelete = keyPairs.publicKeys.concat((await generateKeyPairs(1)).publicKeys);
    try {
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: 'delete_keys',
            args: {drop_id: dropId, public_keys: pksToDelete},
            gas: LARGE_GAS,
            attachedDeposit: "0"
        })
        t.fail('Delete keys should have panicked because key not belonging to drop was passed in')
    } catch(e) {
        t.pass();
    }

    // Check 
    let keypomKeys = await keypomV3.viewAccessKeys(keypomV3.accountId);
    //console.log('keypomKeys: ', keypomKeys)
    // There should still be 40 keys + 1 FAK
    t.is(keypomKeys.keys.length, 41);

    let keysForDrop = await keypomV3.view('get_key_supply_for_drop', {drop_id: dropId});
    console.log('keysForDrop: ', keysForDrop)
    t.is(keysForDrop, 40)
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

'''
'''--- __tests__/deletion/key-deletion.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData, assertProperStorage } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata, ExtKeyInfo } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
import { viewAccessKeyData } from "@keypom/core";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, keypomV3, ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Passing in custom public keys belonging to drop
// Passing in invalid public keys
// Passing in limit
// Passing in no pub keys and no limit
// Passing in keep empty drop
// Deleting non-empty drop with keys & w/o keys
// Deleting a lot of multi-use keys that are partially used (vast range of keys). I.e 10 use key where 50 keys are deleted, all ranging from 1->10 uses left
// Deleting a drop with a TON of empty asset metadata (check for gas here and make sure it can’t panic)

// Ensure if panic, 
// No keys were deleted
// All state is kept, no data structures touched
// Net state added is zero and no user balance is incremented
// False is returned from function

// Ensure if no panic:
// Keys properly removed from Keypom account
// Keys removed from any data structures
// When drop is fully deleted, any cost that was put in should have been refunded (no more, no less). UNLESS keys have been claimed
// True is returned from function

test('Default - Delete on Empty', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [nearAsset1],
        uses: 1
    }];
    
    // if keep_empty_drop in delete_keys does not work, this will auto-delete
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string, required_gas: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    let userPreDeleteBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

    //Should delete drop here
    let deleteResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "delete_keys",
        args: {
            drop_id: dropId,
            public_keys: [keyPairs.publicKeys[0]],
        }
    })
    t.is(deleteResponse=="true", true)

    let userPostDeleteBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(userPostDeleteBal) - BigInt(userPreDeleteBal)).toString(), 5);
    console.log(balChange)
    t.is(balChange > "1", true)
   
    storageBools = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3,
        ownerlessDelete: true
    })
    // Ensure both fail and are no longer in storage
    console.log(storageBools.tokens_per_owner_check)
    console.log(storageBools.token_id_by_pk_check)
    t.is(!storageBools.tokens_per_owner_check && !storageBools.token_id_by_pk_check, true)

    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), false)
});

test('Passing in custom public keys belonging to drop', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [null],
        uses: 1
    }];
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    let deleteResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "delete_keys",
        args: {
            drop_id: dropId,
            public_keys: [keyPairs.publicKeys[0]],
        }
    })
    t.is(deleteResponse=="true", true)

    storageBools = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3,
        ownerlessDelete: true
    })
    // Ensure both fail and are no longer in storage
    t.is(!storageBools.tokens_per_owner_check && !storageBools.token_id_by_pk_check, true)

    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), false)
});

test('Passing in invalid public keys', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [null],
        uses: 1
    }];
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
    let preDeleteBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    

    let preDeleteKeypomBal = await keypomV3.balance();
    try{
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "delete_keys",
            args: {
                drop_id: dropId,
                public_keys: ["abcdefghijklmnopqrstuvwxyz123456789"],
            }
        })
        // Should not pass to here, if it does, fail
        t.fail()
    }catch(e){
        // Ensure storage has not changed
        storageBools = await assertProperStorage({
            keypom: keypomV3,
            expectedTokenId: found_key_info.token_id,
            keyPair: keyPairs.keys[0],
            expectedOwner: keypomV3
        })
        t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
    }
    let postDeleteBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let finalBal = await keypomV3.balance();

    t.deepEqual(preDeleteKeypomBal.stateStaked, finalBal.stateStaked)
    t.is(preDeleteBal == postDeleteBal, true)
    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), true)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test('Passing in limit', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 10;
    let keyPairs = await generateKeyPairs(numKeys);

    let key_data: {public_key: string}[] = []
    for(let i = 0; i < numKeys; i++){
        key_data.push({public_key: keyPairs.publicKeys[i]})
    }

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [null],
        uses: 1
    }];
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    let deleteResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "delete_keys",
        args: {
            drop_id: dropId,
            limit: 5,
        }
    })
    t.is(deleteResponse=="true", true)

    let allKeys: ExtKeyInfo[] = await keypomV3.view("get_keys_for_drop", {drop_id: dropId})
    t.is(allKeys.length == 5, true)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test('Passing in keep empty drop', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [null],
        uses: 1
    }];
    
    // if keep_empty_drop in delete_keys does not work, this will auto-delete
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    // Shoudl not delete drop here
    let deleteResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "delete_keys",
        args: {
            drop_id: dropId,
            public_keys: [keyPairs.publicKeys[0]],
            keep_empty_drop: true
        }
    })
    t.is(deleteResponse=="true", true)

    storageBools = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3,
        ownerlessDelete: true
    })
    // Ensure both fail and are no longer in storage
    t.is(!storageBools.tokens_per_owner_check && !storageBools.token_id_by_pk_check, true)

    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), true)
});

test(' Deleting a drop with a TON of empty asset metadata - check for gas and ensure no panic', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const asset_data_per_use = [{
        assets: [null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null,],
        uses: 1
    }];
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }]
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string, required_gas: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    console.log(`Required gas: ${found_key_info.required_gas}`)
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    let deleteResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "delete_keys",
        args: {
            drop_id: dropId,
            public_keys: [keyPairs.publicKeys[0]],
        }
    })
    t.is(deleteResponse=="true", true)

    storageBools = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3,
        ownerlessDelete: true
    })
    // Ensure both fail and are no longer in storage
    t.is(!storageBools.tokens_per_owner_check && !storageBools.token_id_by_pk_check, true)

    t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[0]), false)
    t.is(await doesDropExist(keypomV3, dropId), false)
});

// 10 use key where 50 keys are deleted, all ranging from 1->10 uses left
test('Deleting a lot of multi-use keys that are partially used', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 50;
    let keyPairs = await generateKeyPairs(numKeys);
    let key_data: {public_key: string}[]= []
    for(let i = 0; i < numKeys; i++){
        key_data.push({public_key: keyPairs.publicKeys[i]})
    }

    // ******************* Creating Drop *******************
    const asset_data_per_use = [{
        assets: [null],
        uses: 10
    }];
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data,
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string, required_gas: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    console.log(`Required gas: ${found_key_info.required_gas}`)
    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

    for(let i = 0; i < numKeys; i++){
        // Random number between 1-10
        let numClaims: number = Math.floor(Math.random() * (9) + 1)
        console.log(`CLAIMING THE ${i+1}th KEY ${numClaims} TIMES`)
        for(let count = 0; count < numClaims; count++){
            await claimWithRequiredGas({
                keypom: keypomV3,
                keyPair: keyPairs.keys[i],
                root,
                useImplicitAccount: true
            })
        }
        console.log(`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`)
    }

    for(let i = 0; i < numKeys; i++){
        found_key_info = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[i]})
        let deleteResponse = await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "delete_keys",
            args: {
                drop_id: dropId,
                public_keys: [keyPairs.publicKeys[i]],
            }
        })
        t.is(deleteResponse=="true", true)

        storageBools = await assertProperStorage({
            keypom: keypomV3,
            expectedTokenId: found_key_info.token_id,
            keyPair: keyPairs.keys[i],
            expectedOwner: keypomV3,
            ownerlessDelete: true
        })
        // Ensure both fail and are no longer in storage
        t.is(!storageBools.tokens_per_owner_check && !storageBools.token_id_by_pk_check, true)
    
        t.is(await doesKeyExist(keypomV3, keyPairs.publicKeys[i]), false)
    }

    t.is(await doesDropExist(keypomV3, dropId), false)
});

// NEED TO COMMENT OUT ALL LOGS INSIDE DELETE_KEYS PRIOR TO RUNNING THIS TEST
// test('Passing in no pub keys and no limit', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
        
//     let initialBal = await keypomV3.balance();
    
//     const dropId = "my-drop-id";
//     const numKeys = 101;
//     let keyPairs = await generateKeyPairs(numKeys);
    
//     let key_data: {public_key: string}[] = []
//     for(let i = 0; i < numKeys - 1; i++){
//         key_data.push({public_key: keyPairs.publicKeys[i]})
//     }
    
//     // ******************* Creating Drop *******************
//     const nearAsset1: ExtNearData = {
//         yoctonear: NEAR.parse("1").toString()
//     }
    
//     const asset_data_per_use = [{
//         assets: [null],
//         uses: 1
//     }];
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data: asset_data_per_use,
//             key_data
//         },
//     }) 

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             asset_data: asset_data_per_use,
//             key_data: [{
//                 public_key: keyPairs.publicKeys[100]
//             }]
//         },
//     }) 

//     let addedKeys: ExtKeyInfo[] = await keypomV3.view("get_keys_for_drop", {drop_id: dropId, limit: 150})
//     t.is(addedKeys.length == 101, true)

//     let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
//     let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
//         keypom: keypomV3,
//         expectedTokenId: found_key_info.token_id,
//         keyPair: keyPairs.keys[0],
//         expectedOwner: keypomV3
//     })
//     t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)

//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: "delete_keys",
//         args: {
//             drop_id: dropId,
//         }
//     })

//     let allKeys: ExtKeyInfo[] = await keypomV3.view("get_keys_for_drop", {drop_id: dropId})
//     t.is(allKeys.length == 1, true)
//     t.is(await doesDropExist(keypomV3, dropId), false)
// });

// test('Deleting non-empty drop with keys & w/o keys', async t => {
//     const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
//     let initialBal = await keypomV3.balance();

//     const dropId = "my-drop-id";
//     const numKeys = 2;
//     let keyPairs = await generateKeyPairs(numKeys);

//     // ******************* Creating Drop *******************
//     const nearAsset1: ExtNearData = {
//         yoctonear: NEAR.parse("1").toString()
//     }

//     const asset_data_per_use = [{
//         assets: [nearAsset1],
//         uses: 1
//     }];

//     let royalties: Record<string, number>={
//     }
//     // 100000 is 100% 
//     royalties[keypomV3.accountId] = 6500
//     royalties[funder.accountId] = 3000
//     royalties[bob.accountId] = 500

//     let metadata: TokenMetadata = {
//         title: "my token",
//         description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
//         media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
//         media_hash: undefined,
//         copies: undefined,
//         issued_at: undefined,
//         expires_at: undefined,
//         starts_at: undefined,
//         updated_at: undefined,
//         extra: undefined,
//         reference: undefined,
//         reference_hash: undefined
//     }
    
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             asset_data: asset_data_per_use,
//             key_data: [{
//                 public_key: keyPairs.publicKeys[0],
//             }],
//             drop_config: {
//                 nft_keys_config: {
//                     token_metadata: metadata,
//                     royalties
//                 }
//             }
//         },
//     }) 

//     let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
//     t.is(found_key_info.owner_id == keypomV3.accountId, true)

//     let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
//         keypom: keypomV3,
//         tokenId: found_key_info.token_id,
//         expectedRoyalties: royalties,
//         expectedMetadata: metadata
//     })
//     t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)

//     let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
//         keypom: keypomV3,
//         expectedTokenId: found_key_info.token_id,
//         keyPair: keyPairs.keys[0],
//         expectedOwner: keypomV3
//     })
//     console.log(storageBools.token_id_by_pk_check)
//     t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
// });

'''
'''--- __tests__/deletion/nft-deletion.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, assertNFTBalance, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, InternalNFTData } from "../utils/types";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });

    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_mint',
        args: {
            token_id: "token1",
            metadata: {
                title: "my token"
            },
            receiver_id: funder.accountId
        },
        attachedDeposit: NEAR.parse("1").toString(),
        shouldLog: false
    })

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, keypomV3, nftContract };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Delete a lot of NFTs with some invalid by passing in token IDs', async t => {
    const {funder, keypomV3, nftContract, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const nftAsset1 = {
        nft_contract_id: nftContract.accountId
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [nftAsset1]
    }

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: [],
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    // This token exists!!
    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_transfer_call',
        args: {
            receiver_id: keypomV3.accountId,
            token_id: "token1",
            msg: dropId
        },
        attachedDeposit: "1"
    })

    // loop 20 times
    let tokenIds = ["token1"]
    let numTokens = 3;
    for (let i = 0; i < numTokens; i++) {
        tokenIds.push(`token1${i}`);
        await functionCall({
            signer: nftContract,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                sender_id: funder.accountId,
                token_id: `token1${i}`,
                msg: dropId
            }
        })
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract.accountId,
            token_ids: tokenIds
        }]
    })

    let response = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_nft_tokens',
        args: {
            drop_id: dropId,
            nft_contract_id: nftContract.accountId,
            token_ids: tokenIds
        },
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract.accountId,
            token_ids: tokenIds
        }]
    })

    // None of the tokens should have been transferred
    await assertNFTBalance({
        nftContract,
        accountId: funder.accountId,
        tokensOwned: []
    });

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

test('Delete NFTs, some invalid using limit', async t => {
    const {funder, keypomV3, nftContract, root} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const nftAsset1 = {
        nft_contract_id: nftContract.accountId
    }

    const dropId = "drop-id";
    const assets_per_use = {
        1: [nftAsset1]
    }

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            assets_per_use,
            public_keys: [],
        },
        attachedDeposit: NEAR.parse("10").toString()
    })

    // This token exists!!
    await functionCall({
        signer: funder,
        receiver: nftContract,
        methodName: 'nft_transfer_call',
        args: {
            receiver_id: keypomV3.accountId,
            token_id: "token1",
            msg: dropId
        },
        attachedDeposit: "1"
    })

    let tokenIds = ["token1"]
    let numTokens = 3;
    for (let i = 0; i < numTokens; i++) {
        tokenIds.push(`token1${i}`);
        await functionCall({
            signer: nftContract,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                sender_id: funder.accountId,
                token_id: `token1${i}`,
                msg: dropId
            }
        })
    }

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract.accountId,
            token_ids: tokenIds
        }]
    })
    
    let response = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'withdraw_nft_tokens',
        args: {
            drop_id: dropId,
            nft_contract_id: nftContract.accountId
        },
        shouldPanic: true
    })
    console.log('response: ', response)
    t.is(response, "false");

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract.accountId,
            token_ids: tokenIds
        }]
    })

    // None of the tokens should have been transferred
    await assertNFTBalance({
        nftContract,
        accountId: funder.accountId,
        tokensOwned: []
    });

    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});
'''
'''--- __tests__/fc-drops/fc-drops.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, WALLET_GAS, claimWithRequiredGas, functionCall, generateKeyPairs } from "../utils/general";
const { readFileSync } = require('fs')

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    const nftContractNested = await root.devDeploy(`./__tests__/ext-wasm/nested-fields-nft.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });
    await nftContractNested.call(nftContractNested, 'new_default_meta', { owner_id: nftContractNested });

    // Test users
    const ali = await root.createSubAccount('ali');
    const funder = await root.createSubAccount('funder');
    const bob = await root.createSubAccount('bob');
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    let nftBalance = await nftContract.balance();
    console.log('nftContract available INITIAL: ', nftBalance.available.toString())
    console.log('nftContract staked INITIAL: ', nftBalance.staked.toString())
    console.log('nftContract stateStaked INITIAL: ', nftBalance.stateStaked.toString())
    console.log('nftContract total INITIAL: ', nftBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, nftContract, nftContractNested, funder, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

const TERA_GAS = 1000000000000;

test('All Funder Tests', async t => {
    const { keypom, nftContract, funder, ali, bob } = t.context.accounts;

    let method1 = {
        receiver_id: nftContract.accountId,
        method_name: 'nft_mint',
        args: JSON.stringify({
            token_id: '1',
            metadata: {
                title: "foo"
            }
        }),
        attached_deposit: NEAR.parse("1").toString(),
        attached_gas: (20 * TERA_GAS).toString(),
        keypom_args: {
            account_id_field: "receiver_id",
        },
    }

    const fcAsset1 = {
        methods: [method1]
    }

    const dropId = "drop-id";

    let {keys, publicKeys} = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses: {
                assets: [fcAsset1],
                num_uses: 3
            },
            public_keys: publicKeys
        },
        attachedDeposit: NEAR.parse("21").toString()
    })

    // This should pass and none of the user provided args should be used.
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({receiver_id: funder.accountId})]]
    });
    let bobSupply = await nftContract.view('nft_supply_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobSupply)
    t.is(bobSupply, '1');
});

test('User Preferred Tests', async t => {
    const { keypom, nftContract, funder, ali, bob } = t.context.accounts;

    let method1 = {
        receiver_id: nftContract.accountId,
        method_name: 'nft_mint',
        args: JSON.stringify({
            token_id: '1',
            metadata: {}
        }),
        attached_deposit: NEAR.parse("1").toString(),
        attached_gas: (20 * TERA_GAS).toString(),
        user_args_rule: "UserPreferred",
        keypom_args: {
            account_id_field: "receiver_id",
        },
    }

    const fcAsset1 = {
        methods: [method1]
    }

    const dropId = "drop-id";
    let {keys, publicKeys} = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses: {
                assets: [fcAsset1],
                num_uses: 4
            },
            public_keys: publicKeys
        },
        attachedDeposit: NEAR.parse("21").toString()
    })

    // Should go through with token ID equal to 1
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId
    });
    let bobTokens: Array<{token_id: string, metadata: {title: string}}> = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens)
    t.is(bobTokens[0].token_id, '1');

    // Token ID should be replaced with 2
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "2"})]]
    });
    bobTokens = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens)
    t.is(bobTokens[1].token_id, '2');

    // Token ID should be replaced with 3 and metadata should now be included
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "3", metadata: {title: "i injected this"}})]]
    });
    bobTokens = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens);
    t.is(bobTokens[2].token_id, '3');
    t.is(bobTokens[2].metadata.title, "i injected this");

    // Method should have skipped the function call because receiver ID already exists due to keypom args
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "4", receiver_id: ali.accountId})]],
    });
    bobTokens = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens);
    t.is(bobTokens.length, 3);

    const aliTokens: Array<{token_id: string}> = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens);
    t.is(aliTokens.length, 0);
});

test('Funder Preferred Tests', async t => {
    const { keypom, nftContract, funder, ali, bob } = t.context.accounts;

    let method1 = {
        receiver_id: nftContract.accountId,
        method_name: 'nft_mint',
        args: JSON.stringify({
            metadata: {
                title: "this was here"
            }
        }),
        attached_deposit: NEAR.parse("1").toString(),
        attached_gas: (20 * TERA_GAS).toString(),
        user_args_rule: "FunderPreferred",
        keypom_args: {
            account_id_field: "receiver_id",
        },
    }

    const fcAsset1 = {
        methods: [method1]
    }

    const dropId = "drop-id";
    let {keys, publicKeys} = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_for_all_uses: {
                assets: [fcAsset1],
                num_uses: 4
            },
            public_keys: publicKeys
        },
        attachedDeposit: NEAR.parse("21").toString()
    })

    // Should go through with token ID equal to 1
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "1"})]],
    });
    let bobTokens: Array<{token_id: string, metadata: {title: string, description: string}}> = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens)
    t.is(bobTokens[0].token_id, '1');

    // metadata should not be replaced
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "2", metadata: {title: "i injected this"}})]],
    });
    bobTokens = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens)
    t.is(bobTokens[1].token_id, '2');
    t.is(bobTokens[1].metadata.title, "this was here");

    // metadata should have appended fields
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify({token_id: "3", metadata: {title: "i injected this", description: "i injected this"}})]],
    });
    bobTokens = await nftContract.view('nft_tokens_for_owner', {account_id: bob.accountId});
    console.log('bobSupply: ', bobTokens)
    t.is(bobTokens[2].token_id, '3');
    t.is(bobTokens[2].metadata.title, "this was here");
    t.is(bobTokens[2].metadata.description, "i injected this");
});

test('User Marker Tests', async t => {
    const { keypom, nftContractNested: nftContract, funder, ali, bob } = t.context.accounts;

    // More tests:
    // https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ad88d2128047a170d744a09d4d61c2db
    
    let method1 = {
        receiver_id: nftContract.accountId,
        method_name: 'nft_mint',
        args: JSON.stringify({
            receiver_id: "INSERT_RECEIVER_ID",
            token_id: 'lower_case',
            metadata: {
                title: "INSERT_TITLE",
                description: "INSERT_DESCRIPTION",
                nested: "INSERT_NESTED"
            },
            long_args: [...readFileSync(`./__tests__/ext-wasm/nested-fields-nft.wasm`)].slice(0, 5000)
        }),
        attached_deposit: NEAR.parse("1").toString(),
        attached_gas: (20 * TERA_GAS).toString(),
        user_args_rule: "UserPreferred"
    }

    const fcAsset1 = {
        methods: [method1]
    }

    const dropId = "drop-id";
    const asset_data_per_use = {
        1: {
            assets: [fcAsset1]
        }
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data_per_use,
            public_keys: publicKeys
        },
        attachedDeposit: NEAR.parse("21").toString()
    })

    let fcArgs = {
        "lower_case": "inserted token id",
        "INSERT_RECEIVER_ID": ali.accountId,
        "INSERT_TITLE": "inserted title",
        "INSERT_DESCRIPTION": "inserted description",
        "INSERT_NESTED": {
            "account_id": bob.accountId,
            "key_id": "0",
            "funder_id": ali.accountId,
            "drop_id": "0"
        }
    }
    // This should pass and none of the user provided args should be used.
    await claimWithRequiredGas({
        keypom,
        root: keypom,
        keyPair: keys[0],
        receiverId: bob.accountId,
        fcArgs: [[JSON.stringify(fcArgs)]],
    });
    let aliTokens: Array<{token_id: string, metadata: {title: string, description: string, nested: {account_id: string, funder_id: string, key_id: string, drop_id: string}}}> = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 1);
    t.is(aliTokens[0].token_id, "lower_case");
    t.is(aliTokens[0].metadata.title, "inserted title");
    t.is(aliTokens[0].metadata.description, "inserted description");
    t.is(aliTokens[0].metadata.nested.account_id, bob.accountId);
    t.is(aliTokens[0].metadata.nested.funder_id, ali.accountId);
    t.is(aliTokens[0].metadata.nested.key_id, "0");
    t.is(aliTokens[0].metadata.nested.drop_id, "0");
});
'''
'''--- __tests__/ft-drops/ft-drops.ava.ts ---
//TEST COMMENT
import anyTest, { TestFn } from "ava";
import { BN } from "bn.js";
import { NEAR, NearAccount, tGas, Worker } from "near-workspaces";
import { assertBalanceChange, CONTRACT_METADATA, DEFAULT_GAS, GAS_PRICE, generateKeyPairs, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { DropConfig, FTData, JsonNFTData } from "../utils/types";
import { ftRegistrationFee, oneGtNear, sendFTs, totalSupply } from "./utils/ft-utils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const ftContract = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);

    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await ftContract.call(ftContract, 'new_default_meta', { owner_id: ftContract, total_supply: totalSupply.toString() });
    
    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const minter = await root.createSubAccount('minter');

    // Add 10k $NEAR to owner's account
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: "0"});

    // Mint the FTs
    await ftContract.call(ftContract, 'storage_deposit', { account_id: minter.accountId }, { attachedDeposit: NEAR.parse("1").toString() });
    await ftContract.call(ftContract, 'ft_transfer', { receiver_id: minter.accountId, amount: (oneGtNear * BigInt(1000)).toString() }, { attachedDeposit: "1" });
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, owner, ali, minter, ftContract };
    t.context.keypomInitialBalance = keypomBalance.available;
    t.context.keypomInitialStateStaked = keypomBalance.stateStaked;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Claim Multi FT Drop And Ensure Keypom Balance Increases', async t => {
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    //register keypom on ft contract
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    //view keypom initial ft contract balance, should be null
    let storageBal = await ftContract.view('storage_balance_of', { account_id: keypom.accountId });
    console.log('storageBal: ', storageBal)
    t.not(storageBal, null);
    
    //store keypom's initial balance. keypomInitialBalance is defined as keypom.balance.available() as defined in beforeEach
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 20NEAR to keypom's keypom wallet from its NEAR wallet
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

    //generate 6 key pairs and create ft data containing contract ID, sender ID, balance per use
    let {keys, publicKeys} = await generateKeyPairs(6);
    //FTData struct defined in models, contains contract ID of ft, sender/minter ID, balance per use (here is 1NEAR) and ft storage
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }
    //2 uses per key
    let config: DropConfig = {
        uses_per_key: 2,
    }

    // Creating the FT drop with 5 keys, each with 2 uses per key
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys.slice(0, 5), 
        //deposit per use defines amount of near per registered use
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS});
    //creating this drop shuld cost owner 20 $NEAR as there is 1 $NEAR deposit per use and then 1 $NEAR per ft claimed

    // Get roughly the min for storing those token IDs
    //this should withdraw 10 $NEAR, owner's keypom balance should now be 0 $NEAR
    await owner.call(keypom, 'withdraw_from_balance', {});
    // Should kickback and refund minter's balance because this isn't enough NEAR for 1 registered use (defined above as 1 $NEAR)
    await sendFTs(minter, (oneGtNear/BigInt(2)).toString(), keypom, ftContract, "0");
    //minter here is the one calling ft_transfer_call and sending the ft to keypom (3rd parameter)

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    //since no FTs were loaded onto the contract, there should be 0 registered uses DESPITE the drop already being created
    t.is(viewFunctions.dropInformation?.registered_uses, 0);

    //minter balance should be 1000 $NEAR as no amount was transfered out yet
    let minterBal = await ftContract.view('ft_balance_of', { account_id: minter.accountId });
    console.log('minterBal: ', minterBal)
    t.is(minterBal, (oneGtNear * BigInt(1000)).toString());

    // Register all 10 uses --> 10 $NEAR / 1 $NEAR per registered use
    //number of uses is defined by automatically using [amount_sent/amount_per_use]
    await sendFTs(minter, (oneGtNear*BigInt(10)).toString(), keypom, ftContract, "0");

    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    //registered uses should now have increased to 10
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 10);

    //minter should now only have 1000-10 balance as they sent 10 $NEAR to keypom 
    minterBal = await ftContract.view('ft_balance_of', { account_id: minter.accountId });
    console.log('minterBal: ', minterBal)
    t.is(minterBal, (oneGtNear * BigInt(990)).toString());

    //keypom's ft contract balance of should now be 10 $NEAR after being sent it by minter
    let keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal: ', keypomBal)
    t.is(keypomBal, (oneGtNear * BigInt(10)).toString());

    //create 5 users and claim a total of 2 $NEAR per user. 
    for(let i = 0; i < 5; i++) {
        await keypom.setKey(keys[i]);

        //claim 1 $NEAR each time
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[5]}, {gas: WALLET_GAS});
        await keypom.call(keypom, 'claim', {account_id: `${i}.test.near`}, {gas: WALLET_GAS});

        //ensure the user balance is now 2 $NEAR 
        let newUserBal = await ftContract.view('ft_balance_of', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('newUserBal: ', newUserBal)
        t.is(newUserBal, (oneGtNear * BigInt(2)).toString());
    }

    //after keypom has distributed all the FTs, its balance should now be 0
    keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal AFTER: ', keypomBal)
    t.is(keypomBal, "0");

    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    //a registered use was used each time claim or create_account_and_claim was called. This means with 5 users claiming twice, it should now be 0
    //in addition, the number of keys left in the drop should now be 0 as all 5 keys have used up their 2 uses and been automatically deleted
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 0);

    //CLARIFY THIS!!!!!
    //owner's balance should include some left over storage costs for the FTs?
    //could be pessimistic storage cost calcs leave some remaining balance on owner's account
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});

test('OverRegister FTs and add multi use key later', async t => {
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 20 $NEAR to owner's keypom balance from their NEAR wallet
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

    //generate 2 keypairs, create new FTData with contract and minter IDs and a 1 $NEAR per use
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    // Creating the FT drop with no keys and 1 $NEAR per use
    await owner.call(keypom, 'create_drop', {
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS});

    // Get roughly the min for storing those token IDs
    await owner.call(keypom, 'withdraw_from_balance', {});

    //this should increase registered uses up to 10
    //regisers = amount / FTData.balance_per_use
    await sendFTs(minter, (oneGtNear * BigInt(10)).toString(), keypom, ftContract, "0");

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    //at this point, there should be 0 keys as none have been added but 10 registered uses
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.keysForDrop?.length, 0);
    t.is(viewFunctions.dropInformation?.registered_uses, 10);

    //minter should now have 10 less FTs
    let minterBal = await ftContract.view('ft_balance_of', { account_id: minter.accountId });
    console.log('minterBal: ', minterBal)
    t.is(minterBal, (oneGtNear * BigInt(990)).toString());

    //keypom,after being sent it, should now have 10 FTs
    let keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal: ', keypomBal)
    t.is(keypomBal, (oneGtNear * BigInt(10)).toString());

    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});
    //add only first key to the drop, owner's keypom balance should decrement by 10 $NEAR as num_keys*deposit_per_use*uses_per_key
    await owner.call(keypom, 'add_keys', {drop_id: '0', public_keys: [publicKeys[0]]}, {gas: LARGE_GAS});
    await keypom.setKey(keys[0]);

    for(let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[1]}, {gas: WALLET_GAS});
        await keypom.call(keypom, 'claim', {account_id: `${i}.test.near`}, {gas: WALLET_GAS});

        //each new user should have 2 FTs
        let newUserBal = await ftContract.view('ft_balance_of', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('newUserBal: ', newUserBal)
        t.is(newUserBal, (oneGtNear * BigInt(2)).toString());
    }

    //keypom should no longer have any of these FTs
    keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal: ', keypomBal)
    t.is(keypomBal, "0");

    //minter's FT balance should remain unchanged as they had already done their part when sending the FTs to keypom
    minterBal = await ftContract.view('ft_balance_of', { account_id: minter.accountId });
    console.log('minterBal: ', minterBal)
    t.is(minterBal, (oneGtNear * BigInt(990)).toString());

    //the single key that was added should have been deleted, registered uses should also have gone back down to 0
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 0);

    //make sure that keypom contract did not lose $NEAR during this process
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
}); 

test('Deleting Keys and Drop', async t => {
    //register FT contract and get keypom's initial $NEAR wallet balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = await (await keypom.balance()).available;

    //generate 6 key pairs, create new FTData with 1 $NEAR balance per use
    let {keys, publicKeys} = await generateKeyPairs(6);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }
    
    console.log("adding to balance");
    // How much does it cost to create a drop?
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {   
        deposit_per_use: NEAR.parse("1").toString(),
        ft
    },{gas: LARGE_GAS});
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    //get net cost by subtracting balance added before from ownerBal after creating drop
    let netCostCreatingDrop = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDrop: ', netCostCreatingDrop.toString())

    //reset owner's Keypom balance between cost evaluations
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Measure how much $NEAR it costs to add a single key
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]],
        drop_id: '0'
    },{gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    //get net cost by subtracting balance added before from ownerBal after adding key
    let netCostAddingOneKey = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostAddingOneKey: ', netCostAddingOneKey.toString())
    
    //reset balance
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Remove the key and ensure the owner balance goes up by the same net cost
    await owner.call(keypom, 'delete_keys', {drop_id: "0", delete_on_empty: false});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('new ownerBal after del: ', ownerBal)
    t.is(NEAR.from(ownerBal).toString(), netCostAddingOneKey.toString());

    // Delete the drop and ensure the owner balance goes up by the net cost
    //delete.rs lines https://github.com/keypom/keypom/blob/5ce357df694818dfd46fbe14093c3e44a1421d69/contract/src/stage1/delete.rs#L166-L175  outlines that once all the keys are DELETED (not used), they're removed from owner
    //this means, unless if you pass in delete_on_tempy: false with the function call, it will "delete" the drop from owner
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'delete_keys', {drop_id: "0"});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('new ownerBal after del drop: ', ownerBal)
    t.is(NEAR.from(ownerBal).toString(), netCostCreatingDrop.toString());

    //withdraw all from balance
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    console.log('keypom staked FINAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked FINAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total FINAL: ', keypomBalance.total.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);

    // Creating a new drop with 1 key and checking if the net cost is equal to the cost of adding a single key + 1 drop
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]],
        deposit_per_use: NEAR.parse("1").toString(),
        ft
    },{gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    let netCostCreatingDropWithOneKey = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDropWithOneKey: ', netCostCreatingDropWithOneKey.toString())
    t.is(netCostCreatingDropWithOneKey.toString(), netCostAddingOneKey.add(netCostCreatingDrop).toString());
});

test('Refunding Assets and Deleting Multi Use Keys and Drops', async t => {
    //register on FT contract and then get keypom's intial $NEAR wallet balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = await (await keypom.balance()).available;
    console.log('keypomInitialBalance: ', keypomInitialBalance)

    //generate 2 keypairs and new FTData config costing 1 $NEAR per use 
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key config for drop
    let config: DropConfig = {
        uses_per_key: 10,
    }

    //create balance and get net cost of creating drop with 1 key
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS});
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating drop with key: ', ownerBal)
    let netCost = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDrop: ', netCost.toString())
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Send 10 FTs registers to the contract
    await sendFTs(minter, (oneGtNear * BigInt(10)).toString(), keypom, ftContract, "0");

    await keypom.setKey(keys[0]);

    // Use the key 5 out of 10 times
    for(let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[1]}, {gas: WALLET_GAS});

        let newUserBal = await ftContract.view('ft_balance_of', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('newUserBal: ', newUserBal)
        t.is(newUserBal, (oneGtNear * BigInt(1)).toString());
    }

    //only 5/10 FTs should have been claimed. Get balance of the remaining.
    let keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal: ', keypomBal)
    t.is(keypomBal, (oneGtNear * BigInt(5)).toString());

    //verify that the one key is still there as it hasn't used all of its uses, and make sure registered uses has decremented appropriately
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 5);
    t.is(viewFunctions.keysForDrop?.length, 1);

    //withdraw balance and refund remaining FT tokens back to senderID (minter)
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'refund_assets', {drop_id: "0"})
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.is(ownerBal, "0");

    //registered uses updates to 0 as no more FTs are present
    //key does not delete as it was not fully claimed
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 1);

    //keypom should no longer have any of the FTs
    keypomBal = await ftContract.view('ft_balance_of', { account_id: keypom.accountId });
    console.log('keypomBal: ', keypomBal)
    t.is(keypomBal, "0");

    //minter should now have those 5 unused FTs returned, for a total of 995
    let minterBal = await ftContract.view('ft_balance_of', { account_id: minter.accountId });
    console.log('minterBal: ', minterBal)
    t.is(minterBal, (oneGtNear * BigInt(995)).toString());

    //make sure owner gets refunded for unused keys being deleted (returning deposit_per_use*number_uses_remaining)
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'delete_keys', {drop_id: "0"});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal > "0");
    await owner.call(keypom, 'withdraw_from_balance', {});

    //make sure keypom's $NEAR balance has not decreased
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});

test('Paying with Attached Deposit. FT Contract Does Not Exist', async t => {
    //register keypom on FT contract and get keypom's initial balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //generate 2 keypairs, and fake FTData with FT contract that does not exist
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: "foobar.test.near",
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    // Creating the FT drop with 1 key and 10 uses, with fake FT contract
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("15").toString()});
    //create with attached deposit of 15 $NEAR

    //0 drops should exist
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId
    });
    console.log('viewFunctions.dropsForOwner: ', viewFunctions.dropsForOwner)
    t.is(viewFunctions.dropsForOwner?.length, 0);

    //since drop couldn't be added, owner's Keypom balance should not increase
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.is(ownerBal, "0");
}); 

test('Paying with Attached Deposit. Not enough deposit to cover callback registration fee', async t => {
    //register keypom on FT contract, keep track of initial balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //generate 2 key pairs, and a normal FTData config
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    //creating these FT drops work in two stages. 
    //One is create the keys and everything on the Keypom side.
    //The other to make a XCC to the FT contract and get costs for storage etc.
    //attached deposit here is only enough for the first stage; meaning the drop creation should fail and the owner should be refunded everything automatically
    //this means owner is only fronting cost of burning the gas
    let b1 = await owner.availableBalance();    
    console.log('b1: ', b1.toString())
    // Creating the FT drop with 10 key uses; should cost 10 $NEAR
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
        //10.202 is the exact amount needed for key deposit + storage etc. BUT not enough for second stage.
        //This should end up failing and refunding owner MINUS gas costs
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10.202").toString()});
    // Wait 5 seconds
    await new Promise(r => setTimeout(r, 5000));

    let b2 = await owner.availableBalance();
    console.log('b2: ', b2.toString())
    // Should only go down by about 20 TGas --> GAS cost used by owner to create drop (which failed)
    t.assert(assertBalanceChange(b1, b2, NEAR.parse("0.0021"), 0.02), "balance didn't decrement properly with 2% precision");

    //drop shouldn't have been added
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId
    });
    console.log('viewFunctions.dropsForOwner: ', viewFunctions.dropsForOwner)
    t.is(viewFunctions.dropsForOwner?.length, 0);

    //owner's balance should be 0
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.is(ownerBal, "0");
}); 

test('Paying with User Balance. FT Contract Does Not Exist', async t => {
   //register Keypom on ft contract
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //generate 2 key pairs, create FTData with phoney FT contract that does not exsit
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: "foobar.test.near",
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    //add 15 $NEAR to owner's Keypom balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("15").toString()});

    // Creating the FT drop with 10 key uses; owner has enough in their balance to create this drop successfully but the FT contract does not exist
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS});

    //confirm that drop was not created
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId
    });
    console.log('viewFunctions.dropsForOwner: ', viewFunctions.dropsForOwner)
    t.is(viewFunctions.dropsForOwner?.length, 0);

    //user should still have 15 $NEAR
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.is(ownerBal, NEAR.parse("15").toString());
}); 

// Add a test checking if you create 1 drop then another, the first one will cost more since FT contract needs to be registered
test('Automatically Register Keypom Contract', async t => {
    //get Keypom's initial balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //create 2 keypairs and FTData with 1 $gtNEAR balance per use
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: minter.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //add 100 $NEAR to owner's Keypom balance, create drop
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    // Creating the FT drop with 1 key
    //should implicitely register Keypom on ftContract since it is not registered
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft
    },{gas: LARGE_GAS});

    //log cost of creating drop with FT contract + registering Keypom on ftContract
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating drop with key: ', ownerBal)
    let netCostDrop1 = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostDrop1: ', netCostDrop1.toString())
    await owner.call(keypom, 'withdraw_from_balance', {});

    //repeat, this time Keypom is already registered on ftContract
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    // Creating the FT drop with 1 key
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[1]], 
        deposit_per_use: NEAR.parse("1").toString(),
        ft
    },{gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating second drop with key: ', ownerBal)
    let netCostDrop2 = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostDrop2: ', netCostDrop2.toString())
    await owner.call(keypom, 'withdraw_from_balance', {});
    t.assert(netCostDrop1.gt(netCostDrop2), "net cost of second drop should be less than first drop");

    //ensure storage balance is not NULL
    let storageBal = await ftContract.view('storage_balance_of', { account_id: keypom.accountId });
    console.log('storageBal: ', storageBal)
    t.not(storageBal, null);

    //delete keys as they are unclaimed. Should return ~ 2 $NEAR
    await owner.call(keypom, 'delete_keys', {drop_id: "0"});
    await owner.call(keypom, 'delete_keys', {drop_id: "1"});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal > "0");
    await owner.call(keypom, 'withdraw_from_balance', {});

    //ensure Keypom balance is not decreasing through this process
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
}); 

test('Anyone can send FTs since sender is optional', async t => {
    //get Keypom initial balance
    const { keypom, owner, ali, ftContract, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 10 $NEAR to owner's balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 keypairs, make JsonNFTData with genuine minter and nftSeries
    let {keys, publicKeys} = await generateKeyPairs(2);
    let ft: FTData = {
        contract_id: ftContract.accountId,
        balance_per_use: oneGtNear.toString()
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    // Creating the NFT drop with NO keys
    await owner.call(keypom, 'create_drop', {
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        config
    },{gas: LARGE_GAS});

    // Get roughly the min for storing those token IDs
    await owner.call(keypom, 'withdraw_from_balance', {});

    await sendFTs(minter, (oneGtNear * BigInt(10)).toString(), keypom, ftContract, "0");

    //NO keys, 10 registered uses as there are 10 NFTs associated with DropID 0
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.keysForDrop?.length, 0);
    t.is(viewFunctions.dropInformation?.registered_uses, 10);

    //delete keys and clear balance
    await ftContract.call(ftContract, 'storage_deposit', { account_id: owner.accountId }, { attachedDeposit: NEAR.parse("1").toString() });
    await owner.call(keypom, 'refund_assets', {drop_id: "0"}, {gas: LARGE_GAS});
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    //make sure Keypom has not lost $NEAR through this process.
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});
'''
'''--- __tests__/ft-drops/utils/ft-utils.ts ---
import { NEAR, NearAccount } from "near-workspaces"
import { LARGE_GAS } from "../../utils/general";

export const oneGtNear = BigInt("1000000000000000000000000")
export const totalSupply = oneGtNear * BigInt(1_000_000)
export const ftRegistrationFee = NEAR.parse("0.00125")

export async function sendFTs(
    minter: NearAccount,
    amount: String,
    keypom: NearAccount,
    ftContract: NearAccount,
    dropId: String
) {
    await minter.callRaw(ftContract, "ft_transfer_call", {
        receiver_id: keypom,
        amount,
        msg: dropId 
    },{gas: LARGE_GAS, attachedDeposit: "1"});
}
'''
'''--- __tests__/internals/test-internals.ava.ts ---
import anyTest, { TestFn } from "ava";
import { KeyPairEd25519, NEAR, NearAccount, Worker } from "near-workspaces";
import { assertBalanceChange, CONTRACT_METADATA, defaultCallOptions, DEFAULT_DEPOSIT } from "../utils/general";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
  }>;

test.beforeEach(async (t) => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the keypom contract.
    const keypom = await root.devDeploy(`./out/keypom.wasm`);

    // Init the contract
    await keypom.call(keypom, 'new', {root_account: 'testnet', owner_id: keypom, contract_metadata: CONTRACT_METADATA});

    // Create users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Initial nonce is 0', async t => {
    const { keypom } = t.context.accounts;
    //first drop id should be 0
    const result = await keypom.view('get_next_drop_id', {});
    t.is(result, 0);
});

test('Changing linkdrop contract', async t => {
    //get default root account for this environment, which should be testnet as defined in config file
    const { keypom } = t.context.accounts;
    let result = await keypom.view('get_root_account', {});
    t.is(result, 'testnet');

    //change root account to foo
    await keypom.call(keypom, 'set_root_account', {root_account: 'foo'});
    
    //ensure that new root account is foo
    result = await keypom.view('get_root_account', {});
    t.is(result, 'foo');
});

test('Setting Contract Metadata', async t => {
    //ensure that default contract metadata is equal to CONTRACT_METADATA
    const { keypom } = t.context.accounts;
    let result = await keypom.view('contract_source_metadata', {});
    t.deepEqual(result, CONTRACT_METADATA);

    //create new set of metadata
    let newMetadata = {
        "version": "0.0.1",
        "link": "foo"
    }
    //set new metadata as contract metadata and ensure that contract metadata has actually changed to new metadata
    await keypom.call(keypom, 'set_contract_metadata', {contract_metadata: newMetadata});
    
    result = await keypom.view('contract_source_metadata', {});
    t.deepEqual(result, newMetadata);
});

test('Setting gas price', async t => {
    //ensure gas price is default
    const { keypom } = t.context.accounts;
    let result = await keypom.view('get_gas_price', {});
    t.is(result, 100000000);

    //change to new gas price and check if the change succeeded. returns boolean
    await keypom.call(keypom, 'set_gas_price', {yocto_per_gas: 100});
    
    result = await keypom.view('get_gas_price', {});
    t.is(result, 100);
});

test('Deposit & withdraw to user balance', async t => {
    //set up keypom and ali accounts, make sure ali's initial balance is 0
    const { keypom, ali } = t.context.accounts;
    let result = await keypom.view('get_user_balance', {account_id: ali});
    t.is(result, '0');

    //add balance to ali's account, default balance in general.ts has default gas and default deposit values
    let b1 = await ali.availableBalance();
    //add_to_balance decrements NEAR wallet and adds it to Keypom wallet. This should give us a balance difference in the NEAR wallet equal to the Keypom balance added
    await ali.call(keypom, 'add_to_balance', {}, defaultCallOptions());
    let b2 = await ali.availableBalance();
    //assert that balance change is equal to default deposit vals
    t.assert(assertBalanceChange(b1, b2, new NEAR(DEFAULT_DEPOSIT), 0.01), "balance didn't decrement properly with 1% precision");

    //double check ali's balance is default deposit
    result = await keypom.view('get_user_balance', {account_id: ali});
    t.is(result, DEFAULT_DEPOSIT);

    //withdraw default balance from ali's account using withdraw_from_balance. change in balance should be default_deposit
    b1 = await ali.availableBalance();
    await ali.call(keypom, 'withdraw_from_balance', {});
    b2 = await ali.availableBalance();
    t.assert(assertBalanceChange(b1, b2, new NEAR(DEFAULT_DEPOSIT), 0.01), "balance didn't increment properly with 1% precision");

    //ali's new balance should now be 0, return boolean
    result = await keypom.view('get_user_balance', {account_id: ali});
    t.is(result, '0');
});

test('Withdrawing fees earned', async t => {
    //check fees collected by the contract, should start at 0
    const { keypom, ali } = t.context.accounts;
    let result = await keypom.view('get_fees_collected', {});
    t.is(result, '0');
    //set drop fees and then give ali the balance necessary to create the drop
    await keypom.call(keypom, 'set_fees', {drop_fee: NEAR.parse("1").toString(), key_fee: NEAR.parse('5 mN').toString()});
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("2").toString()});
    await ali.call(keypom, 'create_drop', {deposit_per_use: NEAR.parse('5 mN').toString()})
    
    //verify that set drop fee succeeded, one drop created and thus 1 $NEAR should have been collected in fees
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse("1").toString());
    
    //adding keys should cost 5mN
    let keyPair = await KeyPairEd25519.fromRandom();
    await ali.call(keypom, 'add_keys', {public_keys: [keyPair.publicKey.toString()], drop_id: '0'})

    //verify cost, total should now me 1.005N or 1005mN
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse('1005 mN').toString());

    //try to withdraw fees to non-existent testnet account, remaining fees on the contract should stay the same 
    result = await keypom.call(keypom, 'withdraw_fees', {withdraw_to: "no-exist.testnet"});
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse('1005 mN').toString());

    //withdraw to ali, should leave 0 balance on the contract; store b1 value as ref
    let b1 = await ali.availableBalance();
    result = await keypom.call(keypom, 'withdraw_fees', {withdraw_to: ali});
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse('0').toString());

    //get ali's new balance and see if it has changed by 1005mN; this indicates that balance out of contract = balace into ali's account
    let b2 = await ali.availableBalance();
    t.assert(assertBalanceChange(b1, b2, NEAR.parse('1005 mN'), 0.01), "balance didn't decrement properly with 1% precision");
});

test('Custom fees earned', async t => {
    //init new account and contract, fees collected 0
    const { keypom, ali } = t.context.accounts;
    let result = await keypom.view('get_fees_collected', {});
    t.is(result, '0');
    
    //set drop fee to 5N and key fee to 0N. Add 10N to Ali's balance and create drop using Ali's account
    await keypom.call(keypom, 'set_fees_per_user', {account_id: ali, drop_fee: NEAR.parse("5").toString(), key_fee: "0"});
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});
    await ali.call(keypom, 'create_drop', {deposit_per_use: NEAR.parse('5 mN').toString()})
    
    //make sure set_fees_per_user configured correctly and actually decremented 5N
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse("5").toString());
    
    //adding keypairs should incur a 0N cost
    let keyPair = await KeyPairEd25519.fromRandom();
    await ali.call(keypom, 'add_keys', {public_keys: [keyPair.publicKey.toString()], drop_id: '0'})

    //fees collected should remain unchanged from before as key_fee = 0N
    result = await keypom.view('get_fees_collected', {});
    t.is(result, NEAR.parse('5').toString());
});
'''
'''--- __tests__/nested-fc-fields/nested-fc-fields.ava.ts ---
import anyTest, { TestFn } from "ava";
import { ExecutionStatusBasic, NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, generateKeyPairs, LARGE_GAS, WALLET_GAS, displayFailureLog } from "../utils/general";
import { DropConfig, FCData } from "../utils/types";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    const nftContract = await root.devDeploy(`./__tests__/ext-wasm/nested-fields-nft.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftContract.call(nftContract, 'new_default_meta', { owner_id: nftContract });

    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const bob = await root.createSubAccount('bob');
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    let nftBalance = await nftContract.balance();
    console.log('nftContract available INITIAL: ', nftBalance.available.toString())
    console.log('nftContract staked INITIAL: ', nftBalance.staked.toString())
    console.log('nftContract stateStaked INITIAL: ', nftBalance.stateStaked.toString())
    console.log('nftContract total INITIAL: ', nftBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, nftContract, owner, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Top Level Fields', async t => {
    const { keypom, nftContract, owner, ali, bob } = t.context.accounts;

    const fcData: FCData = {
        methods: [
            [
                {
                    receiver_id: nftContract.accountId,
                    method_name: 'nft_mint',
                    args: JSON.stringify({
                        receiver_id: ali.accountId,
                        token_id: '1',
                        metadata: {}
                    }),
                    account_id_field: "account_id",
                    key_id_field: "key_id",
                    funder_id_field: "funder_id",
                    drop_id_field: "drop_id",
                    attached_deposit: NEAR.parse("1").toString(),
                }
            ]
        ]
    }

    const config: DropConfig = { 
        uses_per_key: 1
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), fc: fcData, config}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse('21').toString()});
    await keypom.setKey(keys[0]);

    // This should pass and none of the user provided args should be used.
    const res = await keypom.callRaw(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    displayFailureLog(res);

    let aliTokens: any = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 1);
    t.is(aliTokens[0].account_id, bob.accountId);
    t.is(aliTokens[0].funder_id, ali.accountId);
    t.is(aliTokens[0].key_id, "0");
    t.is(aliTokens[0].drop_id, "0");
});

test('Nested One Level Down', async t => {
    const { keypom, nftContract, owner, ali, bob } = t.context.accounts;

    const fcData: FCData = {
        methods: [
            [
                {
                    receiver_id: nftContract.accountId,
                    method_name: 'nft_mint',
                    args: JSON.stringify({
                        receiver_id: ali.accountId,
                        token_id: '1',
                        metadata: {}
                    }),
                    account_id_field: "metadata.account_id",
                    key_id_field: "metadata.key_id",
                    funder_id_field: "metadata.funder_id",
                    drop_id_field: "metadata.drop_id",
                    attached_deposit: NEAR.parse("1").toString(),
                }
            ]
        ]
    }

    const config: DropConfig = { 
        uses_per_key: 1
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), fc: fcData, config}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse('21').toString()});
    await keypom.setKey(keys[0]);

    // This should pass and none of the user provided args should be used.
    const res = await keypom.callRaw(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    displayFailureLog(res);

    let aliTokens: any = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 1);
    t.is(aliTokens[0].metadata.account_id, bob.accountId);
    t.is(aliTokens[0].metadata.funder_id, ali.accountId);
    t.is(aliTokens[0].metadata.key_id, "0");
    t.is(aliTokens[0].metadata.drop_id, "0");
});

test('Nested Two Levels Down', async t => {
    const { keypom, nftContract, owner, ali, bob } = t.context.accounts;

    const fcData: FCData = {
        methods: [
            [
                {
                    receiver_id: nftContract.accountId,
                    method_name: 'nft_mint',
                    args: JSON.stringify({
                        receiver_id: ali.accountId,
                        token_id: '1',
                        metadata: {
                            nested: {}
                        }
                    }),
                    account_id_field: "metadata.nested.account_id",
                    key_id_field: "metadata.nested.key_id",
                    funder_id_field: "metadata.nested.funder_id",
                    drop_id_field: "metadata.nested.drop_id",
                    attached_deposit: NEAR.parse("1").toString(),
                }
            ]
        ]
    }

    const config: DropConfig = { 
        uses_per_key: 1
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), fc: fcData, config}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse('21').toString()});
    await keypom.setKey(keys[0]);

    // This should pass and none of the user provided args should be used.
    const res = await keypom.callRaw(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    displayFailureLog(res);

    let aliTokens: any = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 1);
    t.is(aliTokens[0].metadata.nested.account_id, bob.accountId);
    t.is(aliTokens[0].metadata.nested.funder_id, ali.accountId);
    t.is(aliTokens[0].metadata.nested.key_id, "0");
    t.is(aliTokens[0].metadata.nested.drop_id, "0");
});

test('Nested Fields that Dont Exist', async t => {
    const { keypom, nftContract, owner, ali, bob } = t.context.accounts;

    const fcData: FCData = {
        methods: [
            [
                {
                    receiver_id: nftContract.accountId,
                    method_name: 'nft_mint',
                    args: JSON.stringify({
                        receiver_id: ali.accountId,
                        token_id: '1',
                    }),
                    account_id_field: "metadata.nested.account_id",
                    key_id_field: "metadata.nested.key_id",
                    funder_id_field: "metadata.nested.funder_id",
                    drop_id_field: "metadata.nested.drop_id",
                    attached_deposit: NEAR.parse("1").toString(),
                }
            ]
        ]
    }

    const config: DropConfig = { 
        uses_per_key: 1
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), fc: fcData, config}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse('21').toString()});
    await keypom.setKey(keys[0]);

    // This should pass and none of the user provided args should be used.
    const res = await keypom.callRaw(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    displayFailureLog(res);

    let aliTokens: any = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 1);
    t.is(aliTokens[0].metadata.nested.account_id, bob.accountId);
    t.is(aliTokens[0].metadata.nested.funder_id, ali.accountId);
    t.is(aliTokens[0].metadata.nested.key_id, "0");
    t.is(aliTokens[0].metadata.nested.drop_id, "0");
});

test('Nested Fields That Are Not an Object', async t => {
    const { keypom, nftContract, owner, ali, bob } = t.context.accounts;

    const fcData: FCData = {
        methods: [
            [
                {
                    receiver_id: nftContract.accountId,
                    method_name: 'nft_mint',
                    args: JSON.stringify({
                        receiver_id: ali.accountId,
                        token_id: '1',
                        metadata: {}
                    }),
                    account_id_field: "token_id.account_id",
                    key_id_field: "token_id.key_id",
                    funder_id_field: "token_id.funder_id",
                    drop_id_field: "token_id.drop_id",
                    attached_deposit: NEAR.parse("1").toString(),
                }
            ]
        ]
    }

    const config: DropConfig = { 
        uses_per_key: 1
    }

    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), fc: fcData, config}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse('21').toString()});
    await keypom.setKey(keys[0]);

    // This should pass and none of the user provided args should be used.
    await keypom.call(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    //displayFailureLog(res);

    let aliTokens: any = await nftContract.view('nft_tokens_for_owner', {account_id: ali.accountId});
    console.log('aliTokens: ', aliTokens)
    t.is(aliTokens.length, 0);
});
'''
'''--- __tests__/nft-drops/nft-drops.ava.ts ---
import anyTest, { TestFn } from "ava";
import { Account, NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, generateKeyPairs, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { DropConfig, JsonKeyInfo, JsonNFTData, JsonToken } from "../utils/types";
import { keypom_args, mintNFTs, nftMetadata, nftSeriesMetadata, sendNFTs } from "./utils/nft-utils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts to 2 dev accounts; the NFT series and keypom
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftSeries = await root.devDeploy(`./__tests__/ext-wasm/nft-series.wasm`);

    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftSeries.call(nftSeries, 'new', { owner_id: nftSeries, metadata: nftSeriesMetadata });

    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const minter = await root.createSubAccount('minter');

    // Add 10k $NEAR to owner's account
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: "0"});

    // Mint the NFT
    await nftSeries.call(nftSeries, 'create_series', { mint_id: 0, metadata: nftMetadata }, { attachedDeposit: NEAR.parse("1").toString() });
    await nftSeries.call(nftSeries, 'nft_mint', { mint_id: '0', receiver_id: minter, keypom_args }, { attachedDeposit: NEAR.parse("1").toString() });
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, owner, ali, minter, nftSeries };
    t.context.keypomInitialBalance = keypomBalance.available;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Claim Multi NFT Drop And Ensure Keypom Balance Increases', async t => {
    //get Keypopm initial balance
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 20 $NEAR to balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

    //generate 6 key pairs and JsonNFTData
    let {keys, publicKeys} = await generateKeyPairs(6);
    let nft: JsonNFTData = {
        sender_id: minter.accountId,
        contract_id: nftSeries.accountId
    }
    //2 uses per key
    let config: DropConfig = {
        uses_per_key: 2,
    }

    // Creating the NFT drop with 5 keys, 10 uses
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys.slice(0, 5), 
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
        config
    },{gas: LARGE_GAS});

    // Get roughly the min for storing those token IDs (0.009 $NEAR, 0.001 $NEAR per NFT tokenID) and add to owner's Keypom Balance
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("0.009").toString()});

    // Mint another 9 NFTs (there is now 10 in total, 1 was minted in the beforeEach setup)
    //minted and sent to minter
    await mintNFTs(minter, nftSeries, '0', 9);
    //transfer 10 NFTs from dropID 0 to Keypom from minter
    //nftSeries is the smart contract for said nft series, used to call mint on that contract
    //transfer from minter to keypom
    await sendNFTs(minter, ["1:1", "1:2", "1:3", "1:4", "1:5", "1:6", "1:7", "1:8", "1:9", "1:10"], keypom, nftSeries, "0");

    //registered uses here should be number of NFTs sent to Keypom
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 10);

    //confirm Keypom now owns 10 NFTs. Note this is cumulative as it is using a view function on the NFT contract.
    //if keypom already owned NFTs on this contract and more were minted, it would be a sum of the old + new
    let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos: ', tokenInfos)
    t.is(tokenInfos.length, 10);

    //update the first 5 keys to have FAKs, claim 2 each
    for(let i = 0; i < 5; i++) {
        await keypom.setKey(keys[i]);

        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[5]}, {gas: WALLET_GAS});
        await keypom.call(keypom, 'claim', {account_id: `${i}.test.near`}, {gas: WALLET_GAS});

        //get token info and check that ${i}.test.near owns those NFTs that have been claimed
        let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('tokenInfos: ', tokenInfos)
        t.is(tokenInfos[0].owner_id, `${i}.test.near`);
        t.is(tokenInfos[1].owner_id, `${i}.test.near`);
        t.is(tokenInfos.length, 2);
    }

    //Keypom should now own 0 NFTs from nftSeries as they have all been transfered
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos at END for keypom: ', tokenInfos)
    t.is(tokenInfos.length, 0);

    //minter should also have 0 NFTs from nftSeries as it was initially transfered to Keypom.
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: minter.accountId });
    console.log('tokenInfos at END for minter: ', tokenInfos)
    t.is(tokenInfos.length, 0);

    //registered uses and keys should now be both 0
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 0);

    //withdraw remaining drop owner's Keypom balance
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    //make sure Keypom's $NEAR wallet balance did not decrease
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});

test('OverRegister NFTs and add multi use key later', async t => {
    //get Keypom initial balance
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 10 $NEAR to owner's balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 keypairs, make JsonNFTData with genuine minter and nftSeries
    let {keys, publicKeys} = await generateKeyPairs(2);
    let nft: JsonNFTData = {
        sender_id: minter.accountId,
        contract_id: nftSeries.accountId
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    // Creating the NFT drop with NO keys
    await owner.call(keypom, 'create_drop', {
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
        config
    },{gas: LARGE_GAS});

    // Get roughly the min for storing those token IDs
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("0.009").toString()});

    // Mint another 9 NFTs (there is now 10 in total)
    await mintNFTs(minter, nftSeries, '0', 9);
    //send 10 the 10 NFTs to Keypom from minter
    await sendNFTs(minter, ["1:1", "1:2", "1:3", "1:4", "1:5", "1:6", "1:7", "1:8", "1:9", "1:10"], keypom, nftSeries, "0");

    //NO keys, 10 registered uses as there are 10 NFTs associated with DropID 0
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.keysForDrop?.length, 0);
    t.is(viewFunctions.dropInformation?.registered_uses, 10);

    //make sure Keypom owns 10 NFTs
    let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos: ', tokenInfos)
    t.is(tokenInfos.length, 10);

    //add 20 $NEAR to owner's balance, then add a key to the drop
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});
    await owner.call(keypom, 'add_keys', {drop_id: '0', public_keys: [publicKeys[0]]}, {gas: LARGE_GAS});
    await keypom.setKey(keys[0]);
    for(let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[1]}, {gas: WALLET_GAS});
        await keypom.call(keypom, 'claim', {account_id: `${i}.test.near`}, {gas: WALLET_GAS});

        //make sre each ${i}.test.near owns 2 NFTs
        let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('tokenInfos: ', tokenInfos)
        t.is(tokenInfos[0].owner_id, `${i}.test.near`);
        t.is(tokenInfos[1].owner_id, `${i}.test.near`);
        t.is(tokenInfos.length, 2);
    }
    //all 10 uses for publicKeys[0] should now be used. The key should be auto deleted from the drop

    //Keypom should no longer have any NFTs as they were all transfered
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos at END for keypom: ', tokenInfos)
    t.is(tokenInfos.length, 0);

    //minter sent all of its NFTs to Keypom and hence should have 0
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: minter.accountId });
    console.log('tokenInfos at END for minter: ', tokenInfos)
    t.is(tokenInfos.length, 0);

    //no more registered uses, the only key that was added to the drop has also used all 10 of its uses. 
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 0);

    //delete keys and clear balance
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    //make sure Keypom has not lost $NEAR through this process.
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});

test('Not enough funder balance stage 2', async t => {
    //stage 2 refers to adding NFTs to the drop. Here, we will withdraw the funder's balance before sending NFTs
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    let {keys, publicKeys} = await generateKeyPairs(2);
    let nft: JsonNFTData = {
        sender_id: minter.accountId,
        contract_id: nftSeries.accountId
    }

    // Creating the drop that should be deleted
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
    },{gas: LARGE_GAS});

    //drop owner needs to pay for storage of the NFTs that are sent to their drop.
    //Thus if we withdraw their balance before sending them NFTs, it should fail
    await owner.call(keypom, 'withdraw_from_balance', {});
    await sendNFTs(minter, ["1:1"], keypom, nftSeries, "0");

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation B4: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop B4: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);

    //since sending the NFT failed, Keypom is NOT the owner; instead it rolled back and restored minter as the owner
    let tokenInfo: JsonToken = await nftSeries.view('nft_token', { token_id: "1:1" });
    console.log('tokenInfo: ', tokenInfo)
    t.is(tokenInfo.owner_id, minter.accountId);

    //adding just enough balance to owner's accont so that they can pay for storage of the NFT they are being sent.
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("0.001").toString()});
    await sendNFTs(minter, ["1:1"], keypom, nftSeries, "0");

    //now owner should own the NFT and there should be 1 registered use for the drop
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 1);

    tokenInfo = await nftSeries.view('nft_token', { token_id: "1:1" });
    console.log('tokenInfo: ', tokenInfo)
    t.is(tokenInfo.owner_id, keypom.accountId);
});

test('Deleting Keys and Drop', async t => {
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //generate 6 key pairs, create normal JsonNFTData
    let {keys, publicKeys} = await generateKeyPairs(6);
    let nft: JsonNFTData = {
        sender_id: minter.accountId,
        contract_id: nftSeries.accountId
    }

    //adding 100 $NEAR to owner's balance, then create drop with the above NFTData
    console.log("adding to balance");
    // How much does it cost to create a drop?
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
    },{gas: LARGE_GAS});
    //get balance after creating drop
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    let netCostCreatingDrop = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDrop: ', netCostCreatingDrop.toString())

    // Measure how much $NEAR it costs to add a single key, should be any storage + deposit_per_use
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]],
        drop_id: '0'
    },{gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    let netCostAddingOneKey = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostAddingOneKey: ', netCostAddingOneKey.toString())
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Remove the key and ensure the owner balance goes up by the same net cost
    await owner.call(keypom, 'delete_keys', {drop_id: "0", delete_on_empty: false});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('new ownerBal after del: ', ownerBal)
    t.is(NEAR.from(ownerBal).toString(), netCostAddingOneKey.toString());

    // Delete the drop and ensure the owner balance goes up by the net cost
    await owner.call(keypom, 'withdraw_from_balance', {});
    //delete_on_empty is true by default, this makes this line delete the drop
    await owner.call(keypom, 'delete_keys', {drop_id: "0"});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('new ownerBal after del drop: ', ownerBal)
    t.is(NEAR.from(ownerBal).toString(), netCostCreatingDrop.toString());

    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    //keypom's NEAR wallet balances
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    console.log('keypom staked FINAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked FINAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total FINAL: ', keypomBalance.total.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);

    // Creating a new drop with 1 key and checking if the net cost is equal to the cost of adding a single key + 1 drop
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]],
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
    },{gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating key: ', ownerBal)
    let netCostCreatingDropWithOneKey = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDropWithOneKey: ', netCostCreatingDropWithOneKey.toString())
    t.is(netCostCreatingDropWithOneKey.toString(), netCostAddingOneKey.add(netCostCreatingDrop).toString());
});

test('Refunding Assets and Deleting Multi Use Keys and Drops', async t => {
    //get Keypopm's initial $NEAR wallet balance for reference
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //generate 2 keypairs, make normal NFT config
    let {keys, publicKeys} = await generateKeyPairs(2);
    let nft: JsonNFTData = {
        sender_id: minter.accountId,
        contract_id: nftSeries.accountId
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    //adding 100 $NEAR to owner's Keypom wallet and then creating drop using 1 key.
    //Use this process to figure out cost of creating a drop with 1 key
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[0]], 
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
        config
    },{gas: LARGE_GAS});
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner});
    console.log('ownerBal after creating drop with key: ', ownerBal)
    let netCost = NEAR.parse("100").sub(NEAR.from(ownerBal));
    console.log('netCostCreatingDrop: ', netCost.toString())

    // Send 9 NFT registers to the contract
    await mintNFTs(minter, nftSeries, '0', 9);
    await sendNFTs(minter, ["1:1", "1:2", "1:3", "1:4", "1:5", "1:6", "1:7", "1:8", "1:9", "1:10"], keypom, nftSeries, "0");

    await keypom.setKey(keys[0]);
    
    // Use the key 5 out of 10 times
    for(let i = 0; i < 5; i++) {
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : publicKeys[1]}, {gas: WALLET_GAS});

        let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: `${i}.test.near` });
        console.log(`account ID: ${i}.test.near`)
        console.log('tokenInfos: ', tokenInfos)
        t.is(tokenInfos[0].owner_id, `${i}.test.near`);
        t.is(tokenInfos.length, 1);
    }

    //Keypom should now only have 5 of the original 10 NFTs under its ownership
    let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    t.is(tokenInfos.length, 5);

    //key is not fully used, is not deleted
    //5 NFTs left, 5 registered uses left
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 5);
    t.is(viewFunctions.keysForDrop?.length, 1);

    //refund_assets sends the assets from drop X back to minter/sender
    //no $NEAR is refunded back to the owner for this
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'refund_assets', {drop_id: "0"}, {gas: LARGE_GAS});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.is(ownerBal, "0");

    //after refunding assets, there are no more registered uses.
    //However, keys are still 1 as it was never deleted nor claimed
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: FINAL ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: FINAL ', viewFunctions.keysForDrop)
    t.is(viewFunctions.dropInformation?.registered_uses, 0);
    t.is(viewFunctions.keysForDrop?.length, 1);

    //keypom surrendered its last 5 NFTs
    tokenInfos= await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    t.is(tokenInfos.length, 0);

    //minter should have been refunding the remaining 5 assets when refund_assets was called
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: minter.accountId });
    t.is(tokenInfos.length, 5);

    //nmaking sure Keypom does not lose value during this process
    await owner.call(keypom, 'withdraw_from_balance', {});
    await owner.call(keypom, 'delete_keys', {drop_id: "0"});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal > "0");
    await owner.call(keypom, 'withdraw_from_balance', {});

    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});

test('Anyone can send NFTs since sender is optional', async t => {
    //get Keypom initial balance
    const { keypom, owner, ali, nftSeries, minter } = t.context.accounts;
    const keypomInitialBalance = t.context.keypomInitialBalance;

    //add 10 $NEAR to owner's balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 2 keypairs, make JsonNFTData with genuine minter and nftSeries
    let {keys, publicKeys} = await generateKeyPairs(2);
    let nft: JsonNFTData = {
        contract_id: nftSeries.accountId
    }

    //10 uses per key
    let config: DropConfig = {
        uses_per_key: 10,
    }

    // Creating the NFT drop with NO keys
    await owner.call(keypom, 'create_drop', {
        deposit_per_use: NEAR.parse("1").toString(),
        nft,
        config
    },{gas: LARGE_GAS});

    // Get roughly the min for storing those token IDs
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Mint an NFT
    await mintNFTs(minter, nftSeries, '0', 9);
    //send the NFT to the contract (this should throw since the owner doesn't have enough balance)
    await sendNFTs(minter, ["1:1"], keypom, nftSeries, "0");

    //NO keys, 10 registered uses as there are 10 NFTs associated with DropID 0
    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.keysForDrop?.length, 0);
    t.is(viewFunctions.dropInformation?.registered_uses, 0);

    //make sure Keypom owns no NFTs and it successfully threw an error
    let tokenInfos: JsonToken[] = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos: ', tokenInfos)
    t.is(tokenInfos.length, 0);

    //add 20 $NEAR to owner's balance, then add a key to the drop
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

    //send the NFT to the contract (this should not throw anymore since $NEAR was added)
    await sendNFTs(minter, ["1:1"], keypom, nftSeries, "0");

    //NO keys, 10 registered uses as there are 10 NFTs associated with DropID 0
    viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
        drop_id: "0"
    });
    console.log('viewFunctions.dropInformation: ', viewFunctions.dropInformation)
    console.log('viewFunctions.keysForDrop: ', viewFunctions.keysForDrop)
    t.is(viewFunctions.keysForDrop?.length, 0);
    t.is(viewFunctions.dropInformation?.registered_uses, 1);

    //make sure Keypom owns 1 NFT
    tokenInfos = await nftSeries.view('nft_tokens_for_owner', { account_id: keypom.accountId });
    console.log('tokenInfos: ', tokenInfos)
    t.is(tokenInfos.length, 1);
    
    //delete keys and clear balance
    await owner.call(keypom, 'refund_assets', {drop_id: "0"}, {gas: LARGE_GAS});
    await owner.call(keypom, 'delete_keys', {drop_id: "0"})
    let ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal !== "0");
    await owner.call(keypom, 'withdraw_from_balance', {});
    ownerBal = await keypom.view('get_user_balance', {account_id: owner});
    t.assert(ownerBal === "0");

    //make sure Keypom has not lost $NEAR through this process.
    let keypomBalance = await keypom.balance();
    console.log('keypom available FINAL: ', keypomBalance.available.toString())
    t.assert(keypomBalance.available > keypomInitialBalance);
});
'''
'''--- __tests__/nft-drops/utils/nft-utils.ts ---
import { NEAR, NearAccount } from "near-workspaces"
import { LARGE_GAS } from "../../utils/general";

export const nftSeriesMetadata = {
    "spec": "nft-1.0.99",
    "name": "NFT Drop Series Contract",
    "symbol": "NCBNFT",
    "base_uri": "https://cloudflare-ipfs.com/ipfs/"
}

export const nftMetadata = {
    "media": "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
    "title": "This is my title",
    "description": "This is my description",
    "copies": 1000,
}

export const keypom_args = {
    "account_id_field": "receiver_id",
    "drop_id_field": "mint_id"
}

export async function sendNFTs(
    minter: NearAccount,
    tokenIds: String[],
    keypom: NearAccount,
    nftSeries: NearAccount,
    dropId: String
) {
    for(var i = 0; i < tokenIds.length; i++) {
        await minter.callRaw(nftSeries, "nft_transfer_call", {
            receiver_id: keypom,
            token_id: tokenIds[i],
            msg: dropId 
        },{gas: LARGE_GAS, attachedDeposit: "1"});
    }
}

export async function mintNFTs(
    minter: NearAccount,
    nftSeries: NearAccount,
    mintId: String,
    numToMint: number
) {
    for(var i = 0; i < numToMint; i++) {
        await nftSeries.call(
            nftSeries, 
            'nft_mint', 
            { 
                mint_id: mintId, 
                receiver_id: minter, 
                keypom_args,
            }, 
            { attachedDeposit: NEAR.parse("1").toString() }
        );
    }
}
'''
'''--- __tests__/nft-keys/nft-keys-basics.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData, assertProperStorage } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })

    const bob = await root.createSubAccount('bob');
    await bob.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    const nftContract1 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    await nftContract1.call(nftContract1, 'new_default_meta', { owner_id: nftContract1});

    const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    await nftContract2.call(nftContract2, 'new_default_meta', { owner_id: nftContract2});
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: bob,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, keypomV3, nftContract1, nftContract2, ali, bob };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Sending really long token IDs
// Sending a TON of token IDs
// Sending tokens to a non NFT drop
// Sending tokens to the wrong drop

// Ensure user is being charged and balance decrements
// Ensure tokens are being added to drop info
// Ensure that if the internal vector gets really long for token IDs, there isn’t a gas hit (measure gas for the case of a ton of token IDs)

test('Metadata and Royalties Helper Test', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* SETUP *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
                key_owner: funder
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})

    // **************** RECORD KEYS DIFFERENT ****************
    let diffKeysRoyalties: Record<string, number>={
    }
    // 100000 is 100% 
    diffKeysRoyalties[keypomV3.accountId] = 6500
    diffKeysRoyalties[ali.accountId] = 3000
    diffKeysRoyalties[bob.accountId] = 500
    
    let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: diffKeysRoyalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), false)
    
    // **************** RECORD VALUES DIFFERENT ****************
    let diffValuesRoyalties: Record<string, number>={
    }
    // 100000 is 100% 
    diffValuesRoyalties[keypomV3.accountId] = 3000
    diffValuesRoyalties[funder.accountId] = 6000
    diffValuesRoyalties[bob.accountId] = 1000

    royalties_and_metadata_same = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: diffValuesRoyalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), false)

    // **************** RECORD LENGTHS DIFFERENT ****************
    let shortRoyalties: Record<string, number>={
    }
    // 100000 is 100% 
    shortRoyalties[keypomV3.accountId] = 6500
    shortRoyalties[funder.accountId] = 3000

    royalties_and_metadata_same = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: shortRoyalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), false)

    // **************** RECORD LENGTHS DIFFERENT ****************
    let badMetadata: TokenMetadata = {
        title: "your token",
        description: 'abc',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }

    royalties_and_metadata_same = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: royalties,
        expectedMetadata: badMetadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), false)
    

    // **************** WORKING CASE ****************
    royalties_and_metadata_same = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: royalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)
});

test('Storage Helper Test', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* SETUP *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
                key_owner: funder
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})

    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: funder
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
});

// ONLY nft_supply_for_owner tested here as nft_tokens_for_owner is used and tested in other tested helper fns
test('NFT Supply', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 9;
    let keyPairs = await generateKeyPairs(numKeys);
    let key_data: {public_key: string, key_owner: NearAccount}[] = []

    // 4 Keys
    for(let i = 0; i < numKeys - 1; i++){
        key_data.push({
            public_key: keyPairs.publicKeys[i],
            key_owner: funder
        })
    }
    t.is(key_data.length == 8, true)

    // ******************* SETUP *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("0.01").toString()
    }

    const asset_data = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            key_data: key_data.slice(0, 4),
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 
    let num_tokens: number = await keypomV3.view("nft_supply_for_owner", {account_id: funder.accountId})
    console.log(num_tokens)
    t.is(num_tokens == 4, true)

    await claimWithRequiredGas({
        keypom: keypomV3,
        keyPair: keyPairs.keys[0],
        root,
        createAccount: true
    })

    num_tokens = await keypomV3.view("nft_supply_for_owner", {account_id: funder.accountId})
    t.is(num_tokens == 3, true)

    console.log(key_data.slice(4, 8))
    // add another drop with another 4 keys
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: "drop2",
            asset_data,
            key_data: key_data.slice(4, 8),
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    num_tokens = await keypomV3.view("nft_supply_for_owner", {account_id: funder.accountId})
    t.is(num_tokens == 7, true)

    // let all_found_tokens: {token_id: string, owner_id: string, metadata: TokenMetadata, royalty: Record<string, number>}[] = await keypomV3.view("nft_tokens_for_owner", {account_id: funder.accountId })
    // console.log(all_found_tokens)

    // royalty and storage check - order is all messed up in the array
        // for(let i = 0; i < all_found_tokens.length; i++){
        //     let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
        //         keypom: keypomV3,
        //         tokenId: all_found_tokens[i].token_id,
        //         expectedRoyalties: royalties,
        //         expectedMetadata: metadata
        //     })
        //     t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true);

        //     console.log(`Current: ${i}`)
        //     // first key was used
        //     try{
        //         let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        //             keypom: keypomV3,
        //             expectedTokenId: all_found_tokens[i].token_id,
        //             keyPair: keyPairs.keys[i],
        //             expectedOwner: funder
        //         })
        //         console.log(storageBools)
        //         t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
        //     }
        //     catch(e){
        //         if(i != 0){
        //             t.fail()
        //         }
        //     }
        //     console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~")

        // }
});

test('Ownerless Keys', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    t.is(found_key_info.owner_id == keypomV3.accountId, true)

    let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: royalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)

    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: keypomV3
    })
    console.log(storageBools.token_id_by_pk_check)
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
});

test('Owned Keys', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data_per_use = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
                key_owner: funder
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    t.is(found_key_info.owner_id == funder.accountId, true)

    let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
        keypom: keypomV3,
        tokenId: found_key_info.token_id,
        expectedRoyalties: royalties,
        expectedMetadata: metadata
    })
    t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)

    let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
        keypom: keypomV3,
        expectedTokenId: found_key_info.token_id,
        keyPair: keyPairs.keys[0],
        expectedOwner: funder
    })
    t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
});

test('Owned key transfer, approval, revoking - with owner account', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* SETUP *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
                key_owner: funder
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    t.is(found_key_info.owner_id == funder.accountId, true)

    // **************** APPROVE AND REVOKE TESTING ****************
    try{
        // Add and Revoke, then try Transferring - SHOULD FAIL
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "nft_approve",
            args:{
                token_id: found_key_info.token_id,
                account_id: ali.accountId
            }
        })
    
        let found_nft_info: {owner_id: string, approved_account_ids: Record<string, string>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), true);
    
        // Remove Ali from list of 
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "nft_revoke",
            args: {
                token_id: found_key_info.token_id,
                account_id: ali.accountId
            }
        })
    
        found_nft_info = await keypomV3.view("nft_token", {token_id: found_key_info.token_id});
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), false);
        
        // This should throw
        let newKeyPair = await generateKeyPairs(1);
        await functionCall({
            signer: ali,
            receiver: keypomV3,
            methodName: "nft_transfer",
            args: {
                token_id: found_key_info.token_id,
                receiver_id: bob.accountId,
                memo: newKeyPair.publicKeys[0]
            }
        })
        // If transfer does not throw error, fail the test.
        t.fail()
    }catch(e){
        // Ensure Revoke from Try block has worked
        let found_nft_info: {owner_id: string, approved_account_ids: Record<string, string>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), false);

        // If worked, re-approve
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "nft_approve",
            args:{
                token_id: found_key_info.token_id,
                account_id: ali.accountId
            }
        })
    
        found_nft_info = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), true);
    
    
        // **************** TRANSFER ****************
        let newKeyPair = await generateKeyPairs(1);
        await functionCall({
            signer: ali,
            receiver: keypomV3,
            methodName: "nft_transfer",
            args: {
                token_id: found_key_info.token_id,
                receiver_id: bob.accountId,
                memo: newKeyPair.publicKeys[0]
            }
        })

         // Ensure new owner + approved accounts list has reset
         let final_nft_token_info: {owner_id: string, royalty: Record<string, number>, metadata: TokenMetadata, approved_account_ids: Record<string, string>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
         t.is(final_nft_token_info.owner_id == bob.accountId, true)
         t.is(final_nft_token_info.approved_account_ids.hasOwnProperty(ali.accountId), false)
 
         // **************** ENSURE ROYALTIES AND METADATA HAVE NOT CHANGED ****************
         let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
             keypom: keypomV3,
             tokenId: found_key_info.token_id,
             expectedRoyalties: royalties,
             expectedMetadata: metadata
         })
         t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)

         let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
            keypom: keypomV3,
            expectedTokenId: found_key_info.token_id,
            keyPair: newKeyPair.keys[0],
            expectedOwner: bob
        })
        t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
    }
});

test('Owned key transfer, approval, revoking - with key', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali, bob} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* SETUP *******************
    const nearAsset1: ExtNearData = {
        yoctonear: NEAR.parse("1").toString()
    }

    const asset_data = [{
        assets: [nearAsset1],
        uses: 1
    }];

    let royalties: Record<string, number>={
    }
    // 100000 is 100% 
    royalties[keypomV3.accountId] = 6500
    royalties[funder.accountId] = 3000
    royalties[bob.accountId] = 500

    let metadata: TokenMetadata = {
        title: "my token",
        description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
        media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
        media_hash: undefined,
        copies: undefined,
        issued_at: undefined,
        expires_at: undefined,
        starts_at: undefined,
        updated_at: undefined,
        extra: undefined,
        reference: undefined,
        reference_hash: undefined
    }
    
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
                key_owner: funder
            }],
            drop_config: {
                nft_keys_config: {
                    token_metadata: metadata,
                    royalties
                }
            }
        },
    }) 

    let found_key_info: {owner_id: string, token_id: string} = await keypomV3.view("get_key_information", {key: keyPairs.publicKeys[0]})
    t.is(found_key_info.owner_id == funder.accountId, true)

    // **************** APPROVE AND REVOKE TESTING ****************
    try{
        // Add and Revoke, then try Transferring - SHOULD FAIL
        await keypomV3.setKey(keyPairs.keys[0]);
        await keypomV3.call(keypomV3, 'nft_approve', {token_id: found_key_info.token_id, account_id: ali.accountId});
        let found_nft_info: {owner_id: string, approved_account_ids: Record<string, string>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), true);

        await keypomV3.call(keypomV3, 'nft_revoke', {token_id: found_key_info.token_id, account_id: ali.accountId});
        found_nft_info = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), false);

        // This should throw
        let newKeyPair = await generateKeyPairs(1);
        await functionCall({
            signer: ali,
            receiver: keypomV3,
            methodName: "nft_transfer",
            args: {
                token_id: found_key_info.token_id,
                receiver_id: bob.accountId,
                memo: newKeyPair.publicKeys[0]
            }
        })
        // If transfer does not throw error, fail the test.
        t.fail()
    }catch(e){
        // Ensure Revoke from Try block has worked
        let found_nft_info: {owner_id: string, approved_account_ids: Record<string, string>, royalty: Record<string, number>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), false);

        // If worked, re-approve
        await keypomV3.call(keypomV3, 'nft_approve', {token_id: found_key_info.token_id, account_id: ali.accountId});
        found_nft_info = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(found_nft_info.approved_account_ids.hasOwnProperty(ali.accountId), true);
    
    
        // **************** TRANSFER ****************
        let newKeyPair = await generateKeyPairs(1);
        await functionCall({
            signer: ali,
            receiver: keypomV3,
            methodName: "nft_transfer",
            args: {
                token_id: found_key_info.token_id,
                receiver_id: bob.accountId,
                memo: newKeyPair.publicKeys[0]
            }
        })

        // Ensure owner has changed and approved accounts list has reset
        let final_nft_token_info: {owner_id: string, royalty: Record<string, number>, metadata: TokenMetadata, approved_account_ids: Record<string, string>} = await keypomV3.view("nft_token", {token_id: found_key_info.token_id})
        t.is(final_nft_token_info.owner_id == bob.accountId, true)
        t.is(final_nft_token_info.approved_account_ids.hasOwnProperty(ali.accountId), false)

        // **************** ENSURE ROYALTIES AND METADATA HAVE NOT CHANGED ****************
        let royalties_and_metadata_same: {royaltySame: boolean, metadataSame: boolean} = await assertNFTKeyData({
            keypom: keypomV3,
            tokenId: found_key_info.token_id,
            expectedRoyalties: royalties,
            expectedMetadata: metadata
        })
        t.is((royalties_and_metadata_same.royaltySame && royalties_and_metadata_same.metadataSame), true)

        let storageBools: {tokens_per_owner_check: boolean, token_id_by_pk_check: boolean} = await assertProperStorage({
            keypom: keypomV3,
            expectedTokenId: found_key_info.token_id,
            keyPair: newKeyPair.keys[0],
            expectedOwner: bob
        })
        t.is(storageBools.tokens_per_owner_check && storageBools.token_id_by_pk_check, true)
    }
});

'''
'''--- __tests__/passwords/password-tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { oneGtNear, totalSupply } from "../ft-drops/utils/ft-utils";
import { assertBalanceChange, CONTRACT_METADATA, generateKeyPairs, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { DropConfig, FTData } from "../utils/types";
import { generateGlobalPasswords, generateLocalPasswords, hash } from "./utils/pwUtils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy both contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });

    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const bob = await root.createSubAccount('bob');
    
    // Add 10k $NEAR to owner's account
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, owner, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Multi-use keys with local passwords', async t => {
    // Comment this if you want to see console logs
    //console.log = function() {}
    
    //generate 1 keypair, 3 uses per key config created
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        uses_per_key: 3,
    }

    //set base pw, create new keysWithPws data structure
    let basePassword = 'mypassword1';
    let keysWithPws: { [key: string]: number[] } = {};
    //set publicKeys[0] to have pws for use 1, 2, 3
    keysWithPws[publicKeys[0]] = [1, 2, 3];

    //generates an array of hash(hash(basePassword + publicKeys[i])) --> all PWs for all key use
    let passwords = generateLocalPasswords(publicKeys, keysWithPws, basePassword);
    console.log('passwords: ', passwords)

    //add 10 $NEAR to owner balance
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //create drop using public key, indicating 3 key uses
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys, 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
        passwords_per_use: passwords
    },{gas: LARGE_GAS});

    //use keys[0]
    await keypom.setKey(keys[0]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    // THIS SHOULD FAIL BECAUSE THE DOUBLE HASH (ACTUAL PW) IS PASSED IN [it's going to be hashed AGAIN on the contract]
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(hash(basePassword + publicKeys[0] + '1'), true)}, {gas: WALLET_GAS});

    //check if aliBal is empty, should be the case as none of his claims went through
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePassword + publicKeys[0] + '1')}, {gas: WALLET_GAS});

    // THIS SHOULD FAIL as he is reusing the same pw
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePassword + publicKeys[0] + '1')}, {gas: WALLET_GAS});

    //make sure Ali has only been able to claim ONCE
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePassword + publicKeys[0] + '2')}, {gas: WALLET_GAS});
    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePassword + publicKeys[0] + '3')}, {gas: WALLET_GAS});

    //Ali has now claimed 3 times and should have 3 $NEAR
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("3").toString());
});

test('2 keys have local (first with all use pw second with only 1 use pw), 1 has global, 1 has none. Global and local have different base pws', async t => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    //LOCAL KEYS ARE PER USE, GLOBAL ARE PER KEY!
    
    //create drop config with 2 uses per key, set base pw for global (pw per key) and local (pw per use)
    //create 4 keypairs for use later
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let {keys, publicKeys} = await generateKeyPairs(4);
    let config: DropConfig = {
        uses_per_key: 2,
    }
    let basePasswordLocal = 'mypassword1';
    let basePasswordGlobal = 'mypassword2';

    //LOCAL KEYS INDICATING DIFF PW PER USE
    //first two keypairs have a pw. publicKeys[0] has pw at [1,2]. the other has pw at [1]
    let keysWithPws: { [key: string]: number[] } = {};
    keysWithPws[publicKeys[0]] = [1, 2];
    keysWithPws[publicKeys[1]] = [1];

    //generate local and global pw's
    let localPasswords = generateLocalPasswords(publicKeys, keysWithPws, basePasswordLocal);
    console.log('localPasswords: ', localPasswords)
    let globalPasswords = generateGlobalPasswords(publicKeys, [publicKeys[2]], basePasswordGlobal);
    console.log('globalPasswords: ', globalPasswords)

    //add 100 $NEAR to owner
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});

    //create drop with pw per key and pw per use
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys, 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
        passwords_per_use: localPasswords,
        passwords_per_key: globalPasswords
    },{gas: LARGE_GAS});

    /*
    *   LOCAL KEY #1
    */
    await keypom.setKey(keys[0]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE THE DOUBLE HASH IS PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(hash(basePasswordLocal + publicKeys[0] + '1'), true)}, {gas: WALLET_GAS});

    //verify the two claims above have failed
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());
    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL, these keys with local pw can only be used once, then that key is deleted similar to claim w/o pw
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});

    //ensure ali only gained 1 $NEAR from 1 successful claim
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '2')}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    //alibal should now be 2 $NEAR
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());

    /*
    *   LOCAL KEY #2 
    */
    await keypom.setKey(keys[1]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE THE DOUBLE HASH IS PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(hash(basePasswordLocal + publicKeys[1] + '1'), true)}, {gas: WALLET_GAS});

    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[1] + '1')}, {gas: WALLET_GAS});
    // THIS SHOULD PASS SINCE THERE'S NO PASSWORD ON THE SECOND CLAIM
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});
    //no pw but passing in pw should still allow to claim

    //both claims passed, should now have 2 $NEAR balance
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());

    /*
    *   GLOBAL KEY #1 
    */
    await keypom.setKey(keys[2]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE IT'S A GLOBAL PW NOT LOCAL, does not need + '1'
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2] + '1')}, {gas: WALLET_GAS});

    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    //since global pw, both key uses should have the SAME PW.

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2])}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2])}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    //both should pass, alibal should now be 2 $NEAR
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());
});

test('Add keys after drop is created with passwords', async t => {
    //generate 5 keypairs, 2 use per key drop config
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let {keys, publicKeys} = await generateKeyPairs(5);
    let config: DropConfig = {
        uses_per_key: 2,
    }
    //set base for global and local pws
    let basePasswordLocal = 'mypassword1';
    let basePasswordGlobal = 'mypassword2';

    // keep track of the local pw's. First has 2 pw's, second has 1.
    let keysWithPws: { [key: string]: number[] } = {};
    keysWithPws[publicKeys[0]] = [1, 2];
    keysWithPws[publicKeys[1]] = [1];

    //generate local and global pw's 
    let localPasswords = generateLocalPasswords(publicKeys.slice(0, 4), keysWithPws, basePasswordLocal);
    console.log('localPasswords: ', localPasswords)
    let globalPasswords = generateGlobalPasswords(publicKeys.slice(0, 4), [publicKeys[2]], basePasswordGlobal);
    console.log('globalPasswords: ', globalPasswords)

    //add 100 $NEAR to owner's wallet
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});

    //create drop with no pw, and the last keypair
    await owner.call(keypom, 'create_drop', {
        public_keys: [publicKeys[4]], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    //add keys to the drop created above, specify the passwords here and add the other 4 keypairs created
    //reminder,publicKeys[0] has 2 local pws, publicsKeys[1] has 1 local pw, publicKeys[2] has 1 global and publicKeys[3] has no pw
    await owner.call(keypom, 'add_keys', {
        public_keys: publicKeys.slice(0, 4), 
        drop_id: '0',
        passwords_per_use: localPasswords,
        passwords_per_key: globalPasswords,
    },{gas: LARGE_GAS});

    /*
    *   LOCAL KEY #1 --> 2 local PWs
    */
    await keypom.setKey(keys[0]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE THE DOUBLE HASH IS PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(hash(basePasswordLocal + publicKeys[0] + '1'), true)}, {gas: WALLET_GAS});

    //get ali's $NEAR balance before any deposites go through
    let aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());
    // THIS SHOULD PASS, ali should gain 1 $NEAR
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL as this pw was already used, must pass in the next pw
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});

    //verify only one claim succeeded
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // THIS SHOULD PASS as the second pw is now being used
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '2')}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());

    /*
    *   LOCAL KEY #2 - ONLY FIRST USE HAS LOCAL PW
    */
    await keypom.setKey(keys[1]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE THE DOUBLE HASH IS PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(hash(basePasswordLocal + publicKeys[1] + '1'), true)}, {gas: WALLET_GAS});

    //ensure both claims above failed
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    // THIS SHOULD PASS
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[1] + '1')}, {gas: WALLET_GAS});
    // THIS SHOULD PASS SINCE THERE'S NO PASSWORD ON THE SECOND CLAIM
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordLocal + publicKeys[0] + '1')}, {gas: WALLET_GAS});

    //ensure both claims succeedded
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());

    /*
    *   GLOBAL KEY #1 - 1 single global pw
    */
    await keypom.setKey(keys[2]);

    // Set ali's balance to 0 so we can check if the claim works properly
    await ali.updateAccount({
        amount: "0"
    })

    // THIS SHOULD FAIL BECAUSE NO PASSWORD PASSED IN
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});
    // THIS SHOULD FAIL BECAUSE IT'S A GLOBAL PW NOT LOCAL
    //adding + '1' indicated that its local.
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2] + '1')}, {gas: WALLET_GAS});

    //ensure both cases above have failed
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("0").toString());

    // THIS SHOULD PASS AS THE GLOBAL PW IS USED
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2])}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("1").toString());

    // THIS SHOULD PASS AS GLOBAL PW WORKS FOR ALL CLAIMS ON THAT KEY
    await keypom.call(keypom, 'claim', {account_id: ali.accountId, password: hash(basePasswordGlobal + publicKeys[2])}, {gas: WALLET_GAS});
    aliBal = await ali.availableBalance();
    console.log('aliBal Before: ', aliBal.toString())
    t.is(aliBal.toString(), NEAR.parse("2").toString());
});

test('50 FT Keys Fails in Step 2 Check Storage', async t => {
    //This test combines FT drops with pw protected ones. Setup all necessary info for FT drop
    const { keypom, owner, ali, minter, root } = t.context.accounts;
    const ftContract = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    await ftContract.call(ftContract, 'new_default_meta', { owner_id: ftContract, total_supply: totalSupply.toString() });
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});

    let numKeys = 50;

    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: owner.accountId,
        balance_per_use: oneGtNear.toString()
    }
    let basePassword = 'mypassword1';
    
    //create 50 keypairs, give them all passwords on the first use (key X has pw on use 1)
    let {keys: keys1, publicKeys: publicKeys1} = await generateKeyPairs(numKeys);
    let keysWithPws: { [key: string]: number[] } = {};
    for (var i = 0; i < publicKeys1.length; i++) {
        keysWithPws[publicKeys1[i]] = [1];
    }
    //generate passwords
    let passwords = generateLocalPasswords(publicKeys1, keysWithPws, basePassword);

    //get keypom's initial $NEAR wallet balance
    let kpBalInit1 = await keypom.balance();
    
    //don't add any $NEAR to owner's account
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("0").toString()});

    // Creating the FT drop with 50 keys and password per use for 1 use
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys1, 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        passwords_per_use: passwords
    },{gas: LARGE_GAS});

    //get rid of drop owner's Keypom balance so that they don't have the funds to pay for FT storage
    console.log('Owner removes balance from keypom')
    await owner.call(keypom, 'withdraw_from_balance', {});

    //keypom's final balance should be more than or equal to when it started; KEYPOM SHOULD NOT LOSE MONEY HERE
    let kpBalFin1 = await keypom.balance();
    t.assert(kpBalFin1.available.gte(kpBalInit1.available));

    //second set of keys, 50 keys again and giving them all first use pw's
    let {keys: keys2, publicKeys: publicKeys2} = await generateKeyPairs(numKeys);
    keysWithPws = {};
    for (var i = 0; i < publicKeys1.length; i++) {
        keysWithPws[publicKeys2[i]] = [1];
    }
    passwords = generateLocalPasswords(publicKeys2, keysWithPws, basePassword);

    //get Keypom's initial balance again
    let kpBalInit2 = await keypom.balance();
    
    // console.log("adding to balance");
    //add just enough $NEAR for creating drop and adding FTs but not the storage?
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("51.511").toString()});

    // Creating the FT drop with 5 keys
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys2, 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        passwords_per_use: passwords
    },{gas: LARGE_GAS});

    console.log('Owner removes balance from keypom')
    await owner.call(keypom, 'withdraw_from_balance', {});

    let kpBalFin2 = await keypom.balance();
    t.assert(kpBalFin2.available.gte(kpBalInit2.available));
});

test('Create 50 key drop and delete after', async t => {
    const { keypom, owner, ali, minter, root } = t.context.accounts;
    const ftContract = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);
    await ftContract.call(ftContract, 'new_default_meta', { owner_id: ftContract, total_supply: totalSupply.toString() });
    await keypom.call(keypom, 'register_ft_contract', {account_id: ftContract.accountId}, {attachedDeposit: NEAR.parse("0.01")});

    let numKeys = 50;

    let ft: FTData = {
        contract_id: ftContract.accountId,
        sender_id: owner.accountId,
        balance_per_use: oneGtNear.toString()
    }
    let basePassword = 'mypassword1';
    
    let {keys: keys1, publicKeys: publicKeys1} = await generateKeyPairs(numKeys);
    let keysWithPws: { [key: string]: number[] } = {};
    for (var i = 0; i < publicKeys1.length; i++) {
        keysWithPws[publicKeys1[i]] = [1];
    }
    let passwords = generateLocalPasswords(publicKeys1, keysWithPws, basePassword);
    
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("55").toString()});

    // Creating the FT drop with 5 keys
    await owner.call(keypom, 'create_drop', {
        public_keys: publicKeys1, 
        deposit_per_use: NEAR.parse("1").toString(),
        ft,
        passwords_per_use: passwords
    },{gas: LARGE_GAS});

    console.log('Owner removes balance from keypom')
    await owner.call(keypom, 'withdraw_from_balance', {});

    let kpBalInit1 = await keypom.balance();
    console.log('keypom available INITIAL: ', kpBalInit1.available.toString())
    console.log('keypom staked INITIAL: ', kpBalInit1.staked.toString())
    console.log('keypom stateStaked INITIAL: ', kpBalInit1.stateStaked.toString())
    console.log('keypom total INITIAL: ', kpBalInit1.total.toString())

    await owner.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});

    let kpBalFin1 = await keypom.balance();
    console.log('keypom available FINAL: ', kpBalFin1.available.toString())
    console.log('keypom staked FINAL: ', kpBalFin1.staked.toString())
    console.log('keypom stateStaked FINAL: ', kpBalFin1.stateStaked.toString())
    console.log('keypom total FINAL: ', kpBalFin1.total.toString())
    t.assert(kpBalFin1.available.gte(kpBalInit1.available));
});
'''
'''--- __tests__/passwords/utils/pwUtils.ts ---
import { KeyPair, NEAR, NearAccount, PublicKey } from "near-workspaces";
import { generateKeyPairs, LARGE_GAS } from "../../utils/general";
import { createHash } from "crypto";

export function hash(string: string, double=false) {
    if (double) {
        return createHash('sha256').update(Buffer.from(string, 'hex')).digest('hex');
    }

    return createHash('sha256').update(Buffer.from(string)).digest('hex');
}

export function generateGlobalPasswords(
    pubKeys: string[],
    keysWithPws: string[],
    basePassword: string,
): Array<string | undefined>  {
    let passwords: Array<string | undefined> = [];
    for (var i = 0; i < pubKeys.length; i++) {
        if (keysWithPws.includes(pubKeys[i])) {
            passwords.push(hash(hash(basePassword + pubKeys[i]), true));
        } else {
            passwords.push(undefined);
        }
    }
    return passwords;
}

//generate 
export function generateLocalPasswords(
    // All pubKeys
    pubKeys: string[],
    // Keys with passwords
    keysWithPws: { [key: string]: number[] },
    basePassword: string
): Array<Array<{ pw: string; key_use: number } | undefined> | undefined> {
    let passwords: Array<Array<{ pw: string; key_use: number } | undefined> | undefined> = [];
    
    // Loop through each pubKey to generate either the password or null
    for (var i = 0; i < pubKeys.length; i++) {
        // If the key has a password
        if (Object.keys(keysWithPws).includes(pubKeys[i])) {
            //pw per use array init
            let passwordsPerUse: Array<{ pw: string; key_use: number }> = [];
            // Key has passwords per use so we should add all of them
            let keyUses = keysWithPws[pubKeys[i]];
            for (var j = 0; j < keyUses.length; j++) {
                let jsonPw = {
                    //ex. baseKey1use2
                    pw: hash(hash(basePassword + pubKeys[i] + keyUses[j].toString()), true),
                    key_use: keyUses[j]
                }
                passwordsPerUse.push(jsonPw);
            }
            passwords.push(passwordsPerUse);

        // Key has no password so we push undefined
        } else {
            passwords.push(undefined);
        }
    }

    return passwords;
}
'''
'''--- __tests__/poaps/poap-tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, generateKeyPairs, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { pagodaDistroPoapsSmall } from "./utils/distro";
import { createDistro, nftSeriesMetadata } from "./utils/nearconUtils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

const ticketDistribution = pagodaDistroPoapsSmall;
const numTix = Object.values(ticketDistribution).reduce((a, b) => a + b[0], 0);
const numSponsors = Object.keys(ticketDistribution).length;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    const nftSeries = await root.devDeploy(`./__tests__/ext-wasm/nft-series.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftSeries.call(nftSeries, 'new', { owner_id: nftSeries, metadata: nftSeriesMetadata });
    
    // Add Keypom as an approved minter
    await nftSeries.call(nftSeries, 'add_approved_minter', { account_id: keypom });

    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const bob = await root.createSubAccount('bob');
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });

    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    let nftBalance = await nftSeries.balance();
    console.log('nftSeries available INITIAL: ', nftBalance.available.toString())
    console.log('nftSeries staked INITIAL: ', nftBalance.staked.toString())
    console.log('nftSeries stateStaked INITIAL: ', nftBalance.stateStaked.toString())
    console.log('nftSeries total INITIAL: ', nftBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, nftSeries, owner, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Fully Claim all Pagoda POAPs', async t => {
    // Comment this if you want to see console logs
    //console.log = function() {}
    
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let ownerBal = "500";
    let depositPerUse = NEAR.parse('200 mN').toString();
    let keyPairsForSponsors = await createDistro(ticketDistribution, owner, keypom, nftSeries, ownerBal, depositPerUse);
    console.log('keyPairsForSponsors: ', keyPairsForSponsors)

    let { keys: keys2, publicKeys: pks2 } = await generateKeyPairs(1);

    let curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal before: ', curBal)

    let nonce = 0;
    // Iterate through each sponsor in the keyPairsForSponsors object
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        console.log(`Claiming ${keys.length} keys for ${sponsor}`);

        for(let i = 0; i < keys.length; i++) {
            await keypom.setKey(keys[i]);

            await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${nonce}-${i}.test.near`, new_public_key : pks2[0]}, {gas: WALLET_GAS});
        }
        nonce += 1;
    }
    
    curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal after: ', curBal)

    let keypomInfo = await keypom.balance();
    console.log('keypom available: ', keypomInfo.available.toString())
    console.log('keypom staked: ', keypomInfo.staked.toString())
    console.log('keypom stateStaked: ', keypomInfo.stateStaked.toString())
    console.log('keypom total: ', keypomInfo.total.toString())

    let nftSeriesInfo = await nftSeries.balance();
    console.log('nft Series available: ', nftSeriesInfo.available.toString())
    console.log('nft Series staked: ', nftSeriesInfo.staked.toString())
    console.log('nft Series stateStaked: ', nftSeriesInfo.stateStaked.toString())
    console.log('nft Series total: ', nftSeriesInfo.total.toString())

    let getSeries = await nftSeries.view('get_series', {});
    console.log('getSeries: ', getSeries)
    
    let supplySeries = await nftSeries.view('get_supply_series', {});
    console.log('supplySeries: ', supplySeries)
    t.is(supplySeries, numSponsors)

    let nftTotalSupply = await nftSeries.view('nft_total_supply', {});
    console.log('nftTotalSupply: ', nftTotalSupply)
    t.is(nftTotalSupply, numTix.toString())

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions: ', viewFunctions)
    t.is(viewFunctions.dropSupplyForOwner, numSponsors)
    t.is(viewFunctions.keyTotalSupply, 0)

    nonce = 0;
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        let nftTotalSupply = await nftSeries.view('nft_supply_for_series', {mint_id: nonce});
        console.log(`nftTotalSupply for ${sponsor}: ${nftTotalSupply}`);
        nonce += 1;
    }
});
'''
'''--- __tests__/poaps/utils/distro.ts ---
export const pagodaDistroPoaps = {
    "BucketHat": [
        100,
        100,
        100,
        100
    ],
    "Pizza": [
        100,
        100,
        100,
        100,
        100
    ]
}

export const pagodaDistroPoapsSmall = {
    "BucketHat": [
        3
    ],
    "Pizza": [
        5
    ]
}

export const pagodaDistroPoapsTiny = {
    "BucketHat": [
        1
    ]
}
'''
'''--- __tests__/poaps/utils/nearconUtils.ts ---
import { KeyPair, NEAR, NearAccount } from "near-workspaces";
import { generateKeyPairs, LARGE_GAS } from "../../utils/general";
import { DropConfig } from "../../utils/types";

export const nftSeriesMetadata = {
    "spec": "nft-1.0.99",
    "name": "NEARCON Beta Keypom NFTs",
    "symbol": "NCBNFT",
    "base_uri": "https://cloudflare-ipfs.com/ipfs/"
}

export async function createDistro(
    ticketDistribution: Record<string, number[]>, 
    owner: NearAccount, 
    keypom: NearAccount, 
    nftSeries: NearAccount, 
    ownerBalance: string,
    depositPerUse: string,
    ) {
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse(ownerBalance).toString()});

    let keyPairsForSponsors: Record<string, KeyPair[]> = {};
    let mint_id = 0;
    // Loop through each ticket in the distro and create the drop
    for (let [sponsor, tickets] of Object.entries(ticketDistribution)) {
        console.log(`Creating Series for ${sponsor}`);
        await nftSeries.call(nftSeries, 'create_series', {mint_id, metadata: pagodaNftMetadataPizza}, {attachedDeposit: NEAR.parse("0.02").toString()});

        // Creating the empty drop
        await owner.call(keypom, 'create_drop', {
            deposit_per_use: depositPerUse,
            fc: getNEARConFCData(nftSeries),
            config: null
        },{gas: LARGE_GAS});

        //Creating the tickets for the sponsor
        let finalKeys: KeyPair[] = [];
        for (let i = 0; i < tickets.length; i++) {
            console.log(`Creating ${tickets[i]} tix for ${sponsor}`);
            let {keys, publicKeys} = await generateKeyPairs(tickets[i]);
            // Add the keys vector to the final keys array
            finalKeys.push(...keys);

            await owner.call(keypom, 'add_keys', {
                public_keys: publicKeys, 
                drop_id: mint_id.toString()
            },{gas: LARGE_GAS});
        }

        console.log(`Finished. Incrementing Mint ID. Was ${mint_id} now ${mint_id + 1}`);
        keyPairsForSponsors[sponsor] = finalKeys;
        mint_id += 1;
    }

    let keypomBalance = await keypom.balance();
    console.log('keypom available after distro: ', keypomBalance.available.toString())
    console.log('keypom staked after distro: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked after distro: ', keypomBalance.stateStaked.toString())
    console.log('keypom total after distro: ', keypomBalance.total.toString())

    let nftBalance = await nftSeries.balance();
    console.log('nftSeries available after distro: ', nftBalance.available.toString())
    console.log('nftSeries staked after distro: ', nftBalance.staked.toString())
    console.log('nftSeries stateStaked after distro: ', nftBalance.stateStaked.toString())
    console.log('nftSeries total after distro: ', nftBalance.total.toString())

    return keyPairsForSponsors;
}

export const pagodaNftMetadataBucketHat = {
    "media": "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
    "title": "This is my bucket hat title",
    "description": "Thank you for supporting our Bucket Hat! Welcome to the NEAR ecosystem.",
    "copies": 1000,
};

export const pagodaNftMetadataPizza = {
    "media": "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
    "title": "This is my pizza poap title",
    "description": "Thank you for supporting our Pizza Poap! Welcome to the NEAR ecosystem.",
    "copies": 1000,
};

export const dropConfig: DropConfig = {
    uses_per_key: 3,
    usage: {
        refund_deposit: true
    }
}

export const keypomMetadata = {
    media: "https://cloudflare-ipfs.com/ipfs/bafybeiaqz47cjbptevqvap7cvkez4pajvpvmjpvu2gkgu534t3sqknryam",
    id: "nearcon-opening-night"
}

export function getNEARConFCData (receiver: NearAccount) {
    return {
        methods: [
            [{
                receiver_id: receiver,
                method_name: "nft_mint",
                args: "",
                attached_deposit: NEAR.parse("0.015").toString(),
                account_id_field: "receiver_id",
                drop_id_field: "mint_id"
            }]
        ]
    } 
}
'''
'''--- __tests__/profiling/profiling.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, claimWithRequiredGas, functionCall, generateKeyPairs } from "../utils/general";
import { keypom_args, nftMetadata, nftSeriesMetadata } from "./utils/nft-utils";
import { generatePasswordsForKey, hash } from "./utils/pwUtils";
import { oneGtNear, totalSupply } from "../ft-drops/utils/ft-utils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
}>;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts to 2 dev accounts; the NFT series and keypom
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    const nftSeries = await root.devDeploy(`./__tests__/ext-wasm/nft-series.wasm`);
    const ftContract = await root.devDeploy(`./__tests__/ext-wasm/ft.wasm`);

    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftSeries.call(nftSeries, 'new', { owner_id: nftSeries, metadata: nftSeriesMetadata });
    await ftContract.call(ftContract, 'new_default_meta', { owner_id: ftContract, total_supply: totalSupply.toString() });

    // Test users
    const ali = await root.createSubAccount('ali');
    const funder = await root.createSubAccount('funder');
    const minter = await root.createSubAccount('minter');

    // Mint the FTs
    await ftContract.call(ftContract, 'storage_deposit', { account_id: minter.accountId }, { attachedDeposit: NEAR.parse("1").toString() });
    await ftContract.call(ftContract, 'ft_transfer', { receiver_id: minter.accountId, amount: (oneGtNear * BigInt(1000)).toString() }, { attachedDeposit: "1" });
    
    // Add 10k $NEAR to funder's account
    await funder.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: "0"});

    // Mint the NFT
    await nftSeries.call(nftSeries, 'create_series', { mint_id: 0, metadata: nftMetadata }, { attachedDeposit: NEAR.parse("1").toString() });
    await nftSeries.call(nftSeries, 'add_approved_minter', { account_id: keypom.accountId });
    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, funder, ali, minter, ftContract, nftSeries };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// test('Single Null Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "drop-id";

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             key_data: [],
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             asset_data: [
//                 {
//                     uses: 1,
//                     assets: [null],
//                     config: {
//                         permissions: "claim",
//                     },
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('Double Null Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "drop-id";

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             key_data: [],
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             asset_data: [{
//                 config: {
//                     permissions: "claim"
//                 },
//                 assets: [null],
//                 uses: 2,
//             }],
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 2;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('Triple Null Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "drop-id";

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             key_data: [],
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             asset_data: [{
//                 assets: [null],
//                 uses: 3,
//                 config: {
//                     permissions: "claim"
//                 }
//             }],
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 3;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('Null + NFT Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";

//     let mintMethod = {
//         methods: [
//             {
//                 receiver_id: nftSeries.accountId,
//                 method_name: 'nft_mint',
//                 args: "",
//                 attached_deposit: NEAR.parse("0.0081").toString(),
//                 attached_gas: (8 * 1e12).toString(),
//                 keypom_args: {
//                     account_id_field: "receiver_id",
//                     drop_id_field: "mint_id",
//                 },
//             }
//         ]
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 1,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [mintMethod],
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + '1')
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('2x Null + NFT Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";

//     let mintMethod = {
//         methods: [
//             {
//                 receiver_id: nftSeries.accountId,
//                 method_name: 'nft_mint',
//                 args: "",
//                 attached_deposit: NEAR.parse("0.0081").toString(),
//                 attached_gas: (8 * 1e12).toString(),
//                 keypom_args: {
//                     account_id_field: "receiver_id",
//                     drop_id_field: "mint_id",
//                 },
//             }
//         ]
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 2,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [mintMethod],
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [2], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + '2')
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('2x Null + NFT Claim Claim Only', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";

//     let mintMethod = {
//         methods: [
//             {
//                 receiver_id: nftSeries.accountId,
//                 method_name: 'nft_mint',
//                 args: "",
//                 attached_deposit: NEAR.parse("0.0081").toString(),
//                 attached_gas: (8 * 1e12).toString(),
//                 keypom_args: {
//                     account_id_field: "receiver_id",
//                     drop_id_field: "mint_id",
//                 },
//             }
//         ]
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 2,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [mintMethod],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [2], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + '2')
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('Null + NFT Claim Claim Only', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";

//     let mintMethod = {
//         methods: [
//             {
//                 receiver_id: nftSeries.accountId,
//                 method_name: 'nft_mint',
//                 args: "",
//                 attached_deposit: NEAR.parse("0.0081").toString(),
//                 attached_gas: (8 * 1e12).toString(),
//                 keypom_args: {
//                     account_id_field: "receiver_id",
//                     drop_id_field: "mint_id",
//                 },
//             }
//         ]
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 1,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [mintMethod],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + '1')
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('Null + FT Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, ftContract, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";
//     const ftContractData = {
//         ft_contract_id: ftContract.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         ft_amount: NEAR.parse("1").toString()
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 1,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [ftContractData],
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 1;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('2x Null + FT Claim', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, ftContract, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";
//     const ftContractData = {
//         ft_contract_id: ftContract.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         ft_amount: NEAR.parse("1").toString()
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 2,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [ftContractData],
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 2;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

// test('2x Null + FT Claim Claim only', async t => {
//     //get Keypopm initial balance
//     const { keypom, funder, ali, ftContract, nftSeries, minter, root } = t.context.accounts;

//     //add 20 $NEAR to balance
//     console.log("adding to balance");
//     await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

//     const dropId = "0";
//     const ftContractData = {
//         ft_contract_id: ftContract.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//         ft_amount: NEAR.parse("1").toString()
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId,
//             drop_config: {
//                 delete_empty_drop: false
//             },
//             key_data: [],
//             asset_data: [
//                 {
//                     uses: 2,
//                     assets: [null],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//                 {
//                     uses: 1,
//                     assets: [ftContractData],
//                     config: {
//                         permissions: "claim"
//                     },
//                 },
//             ]
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     let numKeys = 1;
//     let useWithPw = 2;
//     let {keys, publicKeys} = await generateKeyPairs(numKeys);

//     let basePassword = 'mypassword1';
//     let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
//     for (var pk of publicKeys) {
//         let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
//         key_data.push({
//             public_key: pk,
//             password_by_use
//         })
//     }

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'add_keys',
//         args: {
//             drop_id: dropId,
//             key_data
//         },
//         attachedDeposit: NEAR.parse("20").toString()
//     })

//     await functionCall({
//         signer: funder,
//         receiver: keypom,
//         methodName: 'withdraw_from_balance',
//         args: {}
//     });

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         receiverId: ali.accountId,
//         password: hash(basePassword + publicKeys[0] + useWithPw.toString())
//     })

//     await claimWithRequiredGas({
//         keypom,
//         keyPair: keys[0],
//         root,
//         useImplicitAccount: true
//     })

//     let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
//     console.log('userBal: ', userBal)
// });

test('Null + FT Claim Claim only', async t => {
    //get Keypopm initial balance
    const { keypom, funder, ali, ftContract, nftSeries, minter, root } = t.context.accounts;

    //add 20 $NEAR to balance
    console.log("adding to balance");
    await funder.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("20").toString()});

    const dropId = "0";
    const ftContractData = {
        ft_contract_id: ftContract.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
        ft_amount: NEAR.parse("1").toString()
    }

    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            drop_config: {
                delete_empty_drop: false
            },
            key_data: [],
            asset_data: [
                {
                    uses: 1,
                    assets: [null],
                    config: {
                        permissions: "claim"
                    },
                },
                {
                    uses: 1,
                    assets: [ftContractData],
                    config: {
                        permissions: "claim"
                    },
                },
            ]
        },
        attachedDeposit: NEAR.parse("20").toString()
    })

    let numKeys = 1;
    let useWithPw = 1;
    let {keys, publicKeys} = await generateKeyPairs(numKeys);

    let basePassword = 'mypassword1';
    let key_data: Array<{public_key: string, password_by_use?: Record<number, string>}> = [];
    for (var pk of publicKeys) {
        let password_by_use = generatePasswordsForKey(pk, [useWithPw], basePassword);
        
        key_data.push({
            public_key: pk,
            password_by_use
        })
    }

    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'add_keys',
        args: {
            drop_id: dropId,
            key_data
        },
        attachedDeposit: NEAR.parse("20").toString()
    })

    await functionCall({
        signer: funder,
        receiver: keypom,
        methodName: 'withdraw_from_balance',
        args: {}
    });

    await claimWithRequiredGas({
        keypom,
        keyPair: keys[0],
        root,
        receiverId: ali.accountId,
        password: hash(basePassword + publicKeys[0] + useWithPw.toString())
    })

    await claimWithRequiredGas({
        keypom,
        keyPair: keys[0],
        root,
        useImplicitAccount: true
    })

    let userBal = await keypom.view('get_user_balance', {account_id: funder.accountId});
    console.log('userBal: ', userBal)
});
'''
'''--- __tests__/profiling/simple.json ---
{"0-keys":{"initialActual":"8999998913263863266100000000","finalActual":"8999998127797299519000000000","netActual":"785466563747100000000","initialBalance":"1000000000000000000000000000","finalBalance":"998967857369936281600000000","netCost":"1032142630063718400000000"}}
'''
'''--- __tests__/profiling/utils/nft-utils.ts ---
import { NEAR, NearAccount } from "near-workspaces"
import { LARGE_GAS } from "../../utils/general";

export const nftSeriesMetadata = {
    "spec": "nft-1.0.99",
    "name": "NFT Drop Series Contract",
    "symbol": "NCBNFT",
    "base_uri": "https://cloudflare-ipfs.com/ipfs/"
}

export const nftMetadata = {
    "media": "bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi",
    "title": "This is my title",
    "description": "This is my description",
    "copies": 1000,
}

export const keypom_args = {
    "account_id_field": "receiver_id",
    "drop_id_field": "mint_id"
}

export async function sendNFTs(
    minter: NearAccount,
    tokenIds: String[],
    keypom: NearAccount,
    nftSeries: NearAccount,
    dropId: String
) {
    for(var i = 0; i < tokenIds.length; i++) {
        await minter.callRaw(nftSeries, "nft_transfer_call", {
            receiver_id: keypom,
            token_id: tokenIds[i],
            msg: dropId 
        },{gas: LARGE_GAS, attachedDeposit: "1"});
    }
}

export async function mintNFTs(
    minter: NearAccount,
    nftSeries: NearAccount,
    mintId: String,
    numToMint: number
) {
    for(var i = 0; i < numToMint; i++) {
        await nftSeries.call(
            nftSeries, 
            'nft_mint', 
            { 
                mint_id: mintId, 
                receiver_id: minter, 
                keypom_args,
            }, 
            { attachedDeposit: NEAR.parse("1").toString() }
        );
    }
}
'''
'''--- __tests__/profiling/utils/pwUtils.ts ---
import { createHash } from "crypto";

export function hash(string: string, double=false) {
    if (double) {
        return createHash('sha256').update(Buffer.from(string, 'hex')).digest('hex');
    }

    return createHash('sha256').update(Buffer.from(string)).digest('hex');
}

//generate 
export function generatePasswordsForKey(
    pubKey: string,
    usesWithPassword: number[],
    basePassword: string
): Record<number, string> {
    let passwords: Record<number, string> = {}; 

    // Loop through usesWithPassword
    for (var use of usesWithPassword) {
        passwords[use] = hash(hash(basePassword + pubKey + use.toString()), true);
    }

    return passwords;
}
'''
'''--- __tests__/pub-sales/pub-sales.ava.ts ---
import anyTest, { TestFn } from "ava";
import { parseNearAmount } from "near-api-js/lib/utils/format";
import { NEAR, NearAccount, parseNEAR, Worker } from "near-workspaces";
import { oneGtNear, totalSupply } from "../ft-drops/utils/ft-utils";
import { assertBalanceChange, CONTRACT_METADATA, generateKeyPairs, getDropInformation, getKeySupplyForDrop, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { DropConfig, FTData } from "../utils/types";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

const ONE_SECOND_NS = 1e9;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy both contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });

    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const bob = await root.createSubAccount('bob');
    const eve = await root.createSubAccount('eve');
    
    // Add 10k $NEAR to owner's account
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: eve.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, owner, ali, bob, eve };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Pub Sale No Reqs', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(1);
    let config: DropConfig = {
        sale: {}
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // Open to the public therefore ali can add keys
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    let dropInfo = await getDropInformation(keypom, "0");
    console.log('dropInfo: ', dropInfo)
    t.assert(dropInfo.config?.sale != undefined);
});

test('Timed Sale', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        sale: {
            start: (Date.now() * 1000000) + ONE_SECOND_NS * 15,
            end: (Date.now() * 1000000) + ONE_SECOND_NS * 35,
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // SHOULD FAIL since the start hasn't been reached yet
    try {
        await ali.call(keypom, 'add_keys', {
            public_keys: [publicKeys[0]], 
            drop_id: "0"
        },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});
    } catch(e) {}

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 0);

    // Wait 10 seconds
    await new Promise(resolve => setTimeout(resolve, 10000));
    // Should now pass since start has been reached
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    userBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);

    // Wait 30 seconds
    await new Promise(resolve => setTimeout(resolve, 30000));
    // SHOULD FAIL since the end has been reached
    try {
        await ali.call(keypom, 'add_keys', {
            public_keys: [publicKeys[1]], 
            drop_id: "0"
        },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});
    } catch(e) {}

    //owner should have 0 NEAR since the sale was free
    ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    userBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);
});

test('Allowlist & Blocklist / Both', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali, bob, eve } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        sale: {
            allowlist: [ali.accountId],
            blocklist: [bob.accountId]
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // SHOULD FAIL since bob is in blocklist
    try {
        await bob.call(keypom, 'add_keys', {
            public_keys: [publicKeys[0]], 
            drop_id: "0"
        },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});
    } catch(e) {}

     // SHOULD FAIL since eve is NOT in allowlist
     try {
        await eve.call(keypom, 'add_keys', {
            public_keys: [publicKeys[0]], 
            drop_id: "0"
        },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});
    } catch(e) {}

    // Should pass since ali is in allowlist
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);
});

test('Auto Withdrawing Funds', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali, bob, eve } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        sale: {
            auto_withdraw_funds: true,
            // @ts-ignore
            price_per_key: parseNearAmount("1")
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // Should pass since no allowlist
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    // @ts-ignore
    t.is(ownerBal.toString(), parseNearAmount("1"));

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 1);
});

test('Max Number of Keys', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali, bob, eve } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(3);
    let config: DropConfig = {
        sale: {
            // @ts-ignore
            price_per_key: parseNearAmount("1"),
            max_num_keys: 2
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // Should pass since no allowlist
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[1]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    // Should fail since max number of keys is 2
    try {
        await ali.call(keypom, 'add_keys', {
            public_keys: [publicKeys[2]], 
            drop_id: "0"
        },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});
    } catch(e){}

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    // @ts-ignore
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    // @ts-ignore
    t.is(userBal, parseNearAmount("2"));

    //should still have 1 key as the single key that was added to the drop has two uses
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 2);
});

test('Claiming Keys Check Refund Goes to Funder', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali, bob, eve } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(3);
    let config: DropConfig = {
        sale: {
            // @ts-ignore
            price_per_key: parseNearAmount("5"),
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    await owner.call(keypom, 'withdraw_from_balance', {});
    // Set owner's NEAR wallet balance to 0 so we can check if the claim works properly
    await owner.updateAccount({
        amount: "0"
    })

    // Should pass since no allowlist
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    let ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    // @ts-ignore
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    // @ts-ignore
    t.is(userBal, parseNearAmount("5"));

    //set access key to be used for following transactions
    await keypom.setKey(keys[0]);
    //give full access to the key above; used to circumvent allowance bug in sandbox (should be fixed now so this can be deleted)
    await keypom.updateAccessKey(
        publicKeys[0],  // public key
        {
            nonce: 0,
            permission: 'FullAccess'
        }
    )
    await keypom.call(keypom, 'claim', {account_id: ali.accountId}, {gas: WALLET_GAS});

    //owner should have 0 NEAR since the sale was free
    ownerBal = await owner.availableBalance();
    console.log('ownerBal Before: ', ownerBal.toString())
    // @ts-ignore
    t.is(ownerBal.toString(), "0");

    //owner's Keypom wallet balance should be 5 $NEAR plus refund amount
    userBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    // @ts-ignore
    t.assert(NEAR.from("5").lte(NEAR.parse(userBal)));
});

test('Update Sale Configs', async t => {
    //create account and add balance of 10NEAR to owner
    const { keypom, owner, ali, bob, eve } = t.context.accounts;
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    //generate 1 keypair and create drop config to have 2 uses/key and a throttle timestamp of 30s
    let {keys, publicKeys} = await generateKeyPairs(2);
    let config: DropConfig = {
        sale: {
            allowlist: [ali.accountId],
        }
    }

    //create a drop with the created config
    await owner.call(keypom, 'create_drop', {
        public_keys: [], 
        deposit_per_use: NEAR.parse("1").toString(),
        config,
    },{gas: LARGE_GAS});

    // SHOULD FAIL since bob is in blocklist
    let canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, false);

    // Should pass since bob has been added to allowlist
    await owner.call(keypom, 'add_to_sale_allowlist', {drop_id: "0", account_ids: [bob.accountId]});
    canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, true);

    // Should fail since bob was removed to allowlost
    await owner.call(keypom, 'remove_from_sale_allowlist', {drop_id: "0", account_ids: [bob.accountId]});
    canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, false);

    // Should pass since allowlist is now empty and anyone should be able to add keys
    await owner.call(keypom, 'remove_from_sale_allowlist', {drop_id: "0", account_ids: [ali.accountId]});
    canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, true);

    // Bob is added to blocklist so he should not be able to add keys
    await owner.call(keypom, 'add_to_sale_blocklist', {drop_id: "0", account_ids: [bob.accountId]});
    canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, false);

    // Bob was removed from the blocklist so he should be able to add keys
    await owner.call(keypom, 'remove_from_sale_blocklist', {drop_id: "0", account_ids: [bob.accountId]});
    canBobAddKeys = await keypom.view('can_user_add_keys', {account_id: bob.accountId, drop_id: "0"});
    t.is(canBobAddKeys, true);

    await owner.call(keypom, 'withdraw_from_balance', {});

    // Should pass since anyone can add keys
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[0]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner's Keypom wallet balance should be 0 since the sale was free
    let userBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('userBal: ', userBal)
    t.is(userBal, "0");

    //owner should have 0 NEAR since the sale was free
    let ownerBal: string = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), "0");

    await owner.call(keypom, 'update_sale', {drop_id: "0", price_per_key: NEAR.parse("1").toString()}, {attachedDeposit: NEAR.parse("10").toString()});
    await owner.call(keypom, 'withdraw_from_balance', {});

    // Should pass since anyone can add keys
    await ali.call(keypom, 'add_keys', {
        public_keys: [publicKeys[1]], 
        drop_id: "0"
    },{gas: LARGE_GAS, attachedDeposit: NEAR.parse("10").toString()});

    //owner should have 0 NEAR since the sale was free
    ownerBal = await keypom.view('get_user_balance', {account_id: owner.accountId});
    console.log('ownerBal Before: ', ownerBal.toString())
    t.is(ownerBal.toString(), NEAR.parse("1").toString());

    //should have 2 keys added
    let keySupplyForDrop = await getKeySupplyForDrop(keypom, "0");
    console.log('keySupplyForDrop: ', keySupplyForDrop)
    t.is(keySupplyForDrop, 2);
});
'''
'''--- __tests__/stage1/test-simple.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, tGas, Worker } from "near-workspaces";
import { CONTRACT_METADATA, generateKeyPairs, getDropInformation, getKeyInformation, getKeySupplyForDrop, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { DropConfig, SimpleData } from "../utils/types";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
  }>;

  test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the keypom contract.
    const keypom = await root.devDeploy(`./out/keypom.wasm`);

    // Init the contract
    await keypom.call(keypom, 'new', {root_account: 'testnet', owner_id: keypom, contract_metadata: CONTRACT_METADATA});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

//testing drop empty initialization and that default values perform as expected
test('Create empty drop check views', async t => {
    const { keypom, ali } = t.context.accounts;
    //add 2NEAR to ali's keypom balance
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("2").toString()});
    //create a drop with Ali, doesn't front any cost. 
    await ali.call(keypom, 'create_drop', {deposit_per_use: NEAR.parse('5 mN').toString()});

    
    //store the results of all view functions into results
    let result = await queryAllViewFunctions({
        contract: keypom, 
        drop_id: "0", 
        account_id: ali.accountId
    });

    //pretty much all values should be 0
    t.is(result.keyTotalSupply, 0);
    t.deepEqual(result.keys, []);
    let jsonDrop = result.dropInformation!;
    t.is(jsonDrop.drop_id, '0');
    t.is(jsonDrop.owner_id, ali.accountId);
    t.is(jsonDrop.deposit_per_use, NEAR.parse('5 mN').toString());

    t.assert(jsonDrop.simple != undefined);
    t.assert(jsonDrop.nft == undefined);
    t.assert(jsonDrop.ft == undefined);
    t.assert(jsonDrop.fc == undefined);
    t.is(jsonDrop.config, null);
    t.is(jsonDrop.metadata, null);
    t.is(jsonDrop.registered_uses, 0);
    t.is(jsonDrop.required_gas, tGas(100));
    t.is(jsonDrop.next_key_id, 0);
    
    t.is(result.keySupplyForDrop, 0);
    t.deepEqual(result.keysForDrop, []);
    t.deepEqual(result.tokenIdsForDrop, []);
    t.deepEqual(result.dropSupplyForOwner, 1);
});

test('Testing Registered Uses Functionalities', async t => {
    const { keypom, ali, bob } = t.context.accounts;

    await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    
    const simple: SimpleData = {
        lazy_register: true
    }
    let {keys, publicKeys} = await generateKeyPairs(100);
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), simple}, {gas: WALLET_GAS});
    let dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 0);

    // Reset the balance of bob to make sure they don't receive $$
    await bob.updateAccount({
        amount: "0"
    })

    await keypom.setKey(keys[0]);
    //give full access to the key above since failing a transaction would lead to not enough allowance on a regular function call access key
    await keypom.updateAccessKey(
        publicKeys[0],  // public key
        {
            nonce: 0,
            permission: 'FullAccess'
        }
    )

    // THIS SHOULD FAIL SINCE NO KEYS ARE REGISTERED
    await keypom.call(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});

    let bobBal = await bob.availableBalance();
    console.log('aliBal Before: ', bobBal.toString())
    t.is(bobBal.toString(), NEAR.parse("0").toString());

    await ali.call(keypom, 'withdraw_from_balance', {});
    await ali.call(keypom, 'register_uses', {drop_id: "0", num_uses: 2}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse("150")});
    let aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.is(aliBal, NEAR.parse("148").toString());
    await ali.call(keypom, 'withdraw_from_balance', {});

    dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 2);

    // THIS SHOULD NOW PASS
    await keypom.call(keypom, 'claim', {account_id: bob.accountId}, {gas: WALLET_GAS});
    bobBal = await bob.availableBalance();
    console.log('Bob Bal Before: ', bobBal.toString())
    t.is(bobBal.toString(), NEAR.parse("1").toString());
    await ali.call(keypom, 'withdraw_from_balance', {});

    dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 1);

    try {
        await ali.call(keypom, 'unregister_uses', {drop_id: "0", num_uses: 100}, {gas: LARGE_GAS});
    } catch {}

    dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 1);

    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.is(aliBal, "0");

    await ali.call(keypom, 'unregister_uses', {drop_id: "0", num_uses: 1}, {gas: LARGE_GAS});

    dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 0);

    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.is(aliBal, NEAR.parse("1").toString());
});

test('Refunding Partially Registered Simple Drop', async t => {
    const { keypom, ali, bob } = t.context.accounts;
    
    const simple: SimpleData = {
        lazy_register: true
    }
    let {keys, publicKeys} = await generateKeyPairs(100);
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});

    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), simple}, {gas: WALLET_GAS});
    let aliBal: string = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    let diff = NEAR.parse('10').sub(NEAR.from(aliBal));
    console.log('diff: ', diff.toString())
    await ali.call(keypom, 'withdraw_from_balance', {});

    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.assert(NEAR.from(aliBal).lte(diff));
});

test('Batch Creating Keys and Deleting All of Them With Partial Registration', async t => {
    const { keypom, ali, bob } = t.context.accounts;
    
    const simple: SimpleData = {
        lazy_register: true
    }

    // Set ali's balance to 1000 so we can check if the claim works properly
    // Add 10k $NEAR to owner's account
    await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })

    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("100").toString()});
    
    let {keys, publicKeys: pks1} = await generateKeyPairs(100);
    await ali.call(keypom, 'create_drop', {public_keys: pks1, deposit_per_use: NEAR.parse('1').toString(), simple}, {gas: LARGE_GAS});
    let {publicKeys: pks2} = await generateKeyPairs(100);
    await ali.call(keypom, 'add_keys', {drop_id: "0", public_keys: pks2}, {gas: LARGE_GAS});
    let {publicKeys: pks3} = await generateKeyPairs(100);
    await ali.call(keypom, 'add_keys', {drop_id: "0", public_keys: pks3}, {gas: LARGE_GAS});
    
    let aliBal: string = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    let diff = NEAR.parse('100').sub(NEAR.from(aliBal));
    console.log('diff: ', diff.toString())
    await ali.call(keypom, 'withdraw_from_balance', {});

    await ali.call(keypom, 'register_uses', {drop_id: "0", num_uses: 150}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse("150")});
    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    t.is(aliBal, "0");

    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.assert(NEAR.from(aliBal).gte(NEAR.parse("100")));

    await ali.call(keypom, 'withdraw_from_balance', {});
    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.assert(NEAR.from(aliBal).gte(NEAR.parse("50")) && NEAR.from(aliBal).lte(NEAR.parse("70")));

    await ali.call(keypom, 'withdraw_from_balance', {});
    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.assert(NEAR.from(aliBal).lte(NEAR.parse("20")));
});

test('Refunding Over Registered Simple Drop', async t => {
    const { keypom, ali, bob } = t.context.accounts;
    
    const simple: SimpleData = {
        lazy_register: true
    }
        await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })

    let {keys, publicKeys} = await generateKeyPairs(5);
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});
        
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), simple}, {gas: WALLET_GAS});
    await ali.call(keypom, 'register_uses', {drop_id: "0", num_uses: 150}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse("150")});

    let dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 150);

    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    let aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.is(aliBal, NEAR.parse("160").toString());
});

test('Refunding Critically Registered Simple Drop', async t => {
    const { keypom, ali, bob } = t.context.accounts;
    
    const simple: SimpleData = {
        lazy_register: true
    }
        await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })

    let {keys, publicKeys} = await generateKeyPairs(5);
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("10").toString()});
        
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), simple}, {gas: WALLET_GAS});
    await ali.call(keypom, 'register_uses', {drop_id: "0", num_uses: 5}, {gas: LARGE_GAS, attachedDeposit: NEAR.parse("5")});

    let dropInfo = await getDropInformation(keypom,  "0");
    t.is(dropInfo.registered_uses, 5);

    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});
    let aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    t.is(aliBal, NEAR.parse("15").toString());
});

test('Attempt to Panic During Claim or CAAC', async t => {
    const { keypom, ali, bob } = t.context.accounts;

    let keypomBalanceBefore = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalanceBefore.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalanceBefore.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalanceBefore.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalanceBefore.total.toString())

    await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    
    let {keys, publicKeys} = await generateKeyPairs(1);
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("1000").toString()});

    let config: DropConfig = {
        uses_per_key: 1
    }
    await ali.call(keypom, 'create_drop', {public_keys: publicKeys, deposit_per_use: NEAR.parse('1').toString(), config},{gas: WALLET_GAS});

    await keypom.setKey(keys[0]);
    
    // Query for the access key's allowance
    let accessKeyInfo = await getKeyInformation(keypom, publicKeys[0]);
    console.log('accessKeyInfo: ', accessKeyInfo)
    
    // Drain contract by calling this 10 times
    for (let i = 0; i < config.uses_per_key!; i++) {
        try {
            await keypom.call(keypom, 'create_account_and_claim', {new_account_id: "foo", new_public_key: "foo"}, {gas: WALLET_GAS});
        }
        catch(e) {
            console.log(e);
        }
    }

    let accessKeyInfoAfter = await getKeyInformation(keypom, publicKeys[0]);
    console.log('accessKeyInfo After: ', accessKeyInfoAfter)

    t.assert(accessKeyInfoAfter.allowance < accessKeyInfo.allowance);

    // Delete the drop and withdraw all balance. Ensure keypom's available balance does not decrease
    await ali.call(keypom, 'delete_keys', {drop_id: "0"}, {gas: LARGE_GAS});

    let aliBal = await keypom.view('get_user_balance', {account_id: ali.accountId});
    console.log('aliBal: ', aliBal);
    await ali.call(keypom, 'withdraw_from_balance', {}, {gas: LARGE_GAS});

    let keypomBalanceAfter = await keypom.balance();
    console.log('keypom available AFTER: ', keypomBalanceAfter.available.toString())
    console.log('keypom staked AFTER: ', keypomBalanceAfter.staked.toString())
    console.log('keypom stateStaked AFTER: ', keypomBalanceAfter.stateStaked.toString())
    console.log('keypom total AFTER: ', keypomBalanceAfter.total.toString())

    t.assert(NEAR.from(keypomBalanceAfter.available.toString()).gte(NEAR.from(keypomBalanceBefore.available.toString())));
});

test('Not enough attached deposit during add_keys', async t => {
    const { keypom, ali, bob } = t.context.accounts;

    await ali.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })

    let {keys, publicKeys} = await generateKeyPairs(5);

    await ali.call(keypom, 'create_drop', {public_keys: [publicKeys[0]], deposit_per_use: NEAR.parse('100').toString()}, {gas: WALLET_GAS, attachedDeposit: NEAR.parse("101").toString()});

    await ali.call(keypom, 'withdraw_from_balance', {});

    let keypomBalanceBefore = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalanceBefore.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalanceBefore.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalanceBefore.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalanceBefore.total.toString())

    let aliBalBefore = await ali.balance();
    console.log('aliBalBefore available: ', aliBalBefore.available.toString())
    console.log('aliBalBefore staked: ', aliBalBefore.staked.toString())
    console.log('aliBalBefore stateStaked: ', aliBalBefore.stateStaked.toString())
    console.log('aliBalBefore total: ', aliBalBefore.total.toString())

    // Should fail due to not enough attached deposit
    try {
        await ali.call(keypom, 'add_keys', {drop_id: "0", public_keys: [publicKeys[1]]}, {gas: WALLET_GAS, attachedDeposit: NEAR.parse("50").toString()});
    } catch(e) {}

    let keypomBalanceAfter = await keypom.balance();
    console.log('keypomBalanceAfter available: ', keypomBalanceAfter.available.toString())
    console.log('keypomBalanceAfter staked: ', keypomBalanceAfter.staked.toString())
    console.log('keypomBalanceAfter stateStaked: ', keypomBalanceAfter.stateStaked.toString())
    console.log('keypomBalanceAfter total: ', keypomBalanceAfter.total.toString())

    let aliBalAfter = await ali.balance();
    console.log('aliBalAfter available: ', aliBalAfter.available.toString())
    console.log('aliBalAfter staked: ', aliBalAfter.staked.toString())
    console.log('aliBalAfter stateStaked: ', aliBalAfter.stateStaked.toString())
    console.log('aliBalAfter total: ', aliBalAfter.total.toString())

    let aliContractBal = await keypom.view('get_user_balance', {account_id: ali});
    console.log('aliContractBal: ', aliContractBal)

    t.assert(aliContractBal === "0");
    t.assert(NEAR.from(aliBalBefore.available).sub(NEAR.from(aliBalAfter.available)).lte(NEAR.parse("0.01")));
    t.assert(NEAR.from(keypomBalanceBefore.available).sub(NEAR.from(keypomBalanceAfter.available)).lte(NEAR.parse("0.01")));
    t.is(keypomBalanceBefore.stateStaked.toString(),keypomBalanceAfter.stateStaked.toString());
});
'''
'''--- __tests__/ticketing/ticketing-tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, displayFailureLog, generateKeyPairs, LARGE_GAS, queryAllViewFunctions, WALLET_GAS } from "../utils/general";
import { ticketDistroSmall } from "./utils/distro";
import { createDistro, dropConfig, getNEARConFCData, nftMetadata, nftSeriesMetadata } from "./utils/nearconUtils";

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    keypomInitialBalance: NEAR;
    keypomInitialStateStaked: NEAR;
}>;

const ticketDistribution = ticketDistroSmall;
const numTix = Object.values(ticketDistribution).reduce((a, b) => a + b[0], 0);
const numSponsors = Object.keys(ticketDistribution).length;

test.beforeEach(async (t) => {
    // Comment this if you want to see console logs
    //console.log = function() {}

    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy all 3 contracts
    const keypom = await root.devDeploy(`./out/keypom.wasm`);
    const nftSeries = await root.devDeploy(`./__tests__/ext-wasm/nft-series.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);
    
    // Init the 3 contracts
    await root.call(root, 'new', {});
    await keypom.call(keypom, 'new', { root_account: 'test.near', owner_id: keypom, contract_metadata: CONTRACT_METADATA });
    await nftSeries.call(nftSeries, 'new', { owner_id: nftSeries, metadata: nftSeriesMetadata });
    
    // Add Keypom as an approved minter
    await nftSeries.call(nftSeries, 'add_approved_minter', { account_id: keypom });
    
    // Test users
    const ali = await root.createSubAccount('ali');
    const owner = await root.createSubAccount('owner');
    const bob = await root.createSubAccount('bob');
    
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: owner.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: ali.accountId });
    await keypom.call(keypom, 'add_to_refund_allowlist', { account_id: bob.accountId });
    
    let keypomBalance = await keypom.balance();
    console.log('keypom available INITIAL: ', keypomBalance.available.toString())
    console.log('keypom staked INITIAL: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked INITIAL: ', keypomBalance.stateStaked.toString())
    console.log('keypom total INITIAL: ', keypomBalance.total.toString())

    let nftBalance = await nftSeries.balance();
    console.log('nftSeries available INITIAL: ', nftBalance.available.toString())
    console.log('nftSeries staked INITIAL: ', nftBalance.staked.toString())
    console.log('nftSeries stateStaked INITIAL: ', nftBalance.stateStaked.toString())
    console.log('nftSeries total INITIAL: ', nftBalance.total.toString())

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, keypom, nftSeries, owner, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Fully Claim all ticketing keys', async t => {
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let ownerBal = "500";
    let depositPerUse = NEAR.parse('3 mN').toString();
    let keyPairsForSponsors = await createDistro(ticketDistribution, owner, keypom, nftSeries, ownerBal, depositPerUse);
    console.log('keyPairsForSponsors: ', keyPairsForSponsors)
    
    let { keys: keys2, publicKeys: pks2 } = await generateKeyPairs(1);

    let curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal before: ', curBal)

    let nonce = 0;
    // Iterate through each sponsor in the keyPairsForSponsors object
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        console.log(`Claiming ${keys.length} keys for ${sponsor}`);

        for(let i = 0; i < keys.length; i++) {
            await keypom.setKey(keys[i]);

            await keypom.call(keypom, 'claim', { account_id: bob }, { gas: WALLET_GAS });
            await keypom.call(keypom, 'claim', { account_id: bob }, { gas: WALLET_GAS });
            const foo = await keypom.callRaw(keypom, 'create_account_and_claim', {new_account_id: `${nonce}-${i}.test.near`, new_public_key : pks2[0]}, {gas: WALLET_GAS});
            displayFailureLog(foo);
        }
        nonce += 1;
    }
    
    curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal after: ', curBal)

    let keypomInfo = await keypom.balance();
    console.log('keypom available: ', keypomInfo.available.toString())
    console.log('keypom staked: ', keypomInfo.staked.toString())
    console.log('keypom stateStaked: ', keypomInfo.stateStaked.toString())
    console.log('keypom total: ', keypomInfo.total.toString())

    let nftSeriesInfo = await nftSeries.balance();
    console.log('nft Series available: ', nftSeriesInfo.available.toString())
    console.log('nft Series staked: ', nftSeriesInfo.staked.toString())
    console.log('nft Series stateStaked: ', nftSeriesInfo.stateStaked.toString())
    console.log('nft Series total: ', nftSeriesInfo.total.toString())

    let getSeries = await nftSeries.view('get_series', {});
    console.log('getSeries: ', getSeries)
    
    let supplySeries = await nftSeries.view('get_supply_series', {});
    console.log('supplySeries: ', supplySeries)
    t.is(supplySeries, numSponsors);

    let nftTotalSupply = await nftSeries.view('nft_total_supply', {});
    console.log('nftTotalSupply: ', nftTotalSupply)
    t.is(nftTotalSupply, numTix.toString());

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions: ', viewFunctions)
    t.is(viewFunctions.dropSupplyForOwner, numSponsors)
    t.is(viewFunctions.keyTotalSupply, 0)

    nonce = 0;
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        let nftTotalSupply = await nftSeries.view('nft_supply_for_series', {mint_id: nonce});
        console.log(`nftTotalSupply for ${sponsor}: ${nftTotalSupply}`);
        nonce += 1;
    }
});

test('Claim 1 with invalid expected uses', async t => {
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;
    let ownerBal = "500";
    let depositPerUse = NEAR.parse('3 mN').toString();
    let keyPairsForSponsors = await createDistro(ticketDistribution, owner, keypom, nftSeries, ownerBal, depositPerUse);
    console.log('keyPairsForSponsors: ', keyPairsForSponsors)
    let { keys: keys2, publicKeys: pks2 } = await generateKeyPairs(1);

    let curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal before: ', curBal)

    let nonce = 0;
    // Iterate through each sponsor in the keyPairsForSponsors object
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        console.log(`Claiming ${keys.length} keys for ${sponsor}`);

        for(let i = 0; i < keys.length; i++) {
            await keypom.setKey(keys[i]);

            await keypom.call(keypom, 'claim', { account_id: bob, expected_uses: 3 }, { gas: WALLET_GAS });
            await keypom.call(keypom, 'claim', { account_id: bob, expected_uses: 3 }, { gas: WALLET_GAS });
        }
        nonce += 1;
    }
    
    curBal = await keypom.view('get_user_balance', {account_id: owner});
    console.log('curBal after: ', curBal)

    let keypomInfo = await keypom.balance();
    console.log('keypom available: ', keypomInfo.available.toString())
    console.log('keypom staked: ', keypomInfo.staked.toString())
    console.log('keypom stateStaked: ', keypomInfo.stateStaked.toString())
    console.log('keypom total: ', keypomInfo.total.toString())

    let nftSeriesInfo = await nftSeries.balance();
    console.log('nft Series available: ', nftSeriesInfo.available.toString())
    console.log('nft Series staked: ', nftSeriesInfo.staked.toString())
    console.log('nft Series stateStaked: ', nftSeriesInfo.stateStaked.toString())
    console.log('nft Series total: ', nftSeriesInfo.total.toString())

    let getSeries = await nftSeries.view('get_series', {});
    console.log('getSeries: ', getSeries)
    
    let supplySeries = await nftSeries.view('get_supply_series', {});
    console.log('supplySeries: ', supplySeries)
    t.is(supplySeries, numSponsors);

    let nftTotalSupply = await nftSeries.view('nft_total_supply', {});
    console.log('nftTotalSupply: ', nftTotalSupply)
    t.is(nftTotalSupply, '0');

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions: ', viewFunctions)
    t.is(viewFunctions.dropSupplyForOwner, numSponsors)
    t.is(viewFunctions.keyTotalSupply, numTix)

    nonce = 0;
    for (let [sponsor, keys] of Object.entries(keyPairsForSponsors)) {
        let nftTotalSupply = await nftSeries.view('nft_supply_for_series', {mint_id: nonce});
        console.log(`nftTotalSupply for ${sponsor}: ${nftTotalSupply}`);
        nonce += 1;
    }
});

test('Force Injecting Fields Attack', async t => {
    const { keypom, nftSeries, owner, ali, bob } = t.context.accounts;

    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("5").toString()});
    await ali.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse("5").toString()});

    let keyPairs = await generateKeyPairs(10);

    await nftSeries.call(nftSeries, 'create_series', {mint_id: 0, metadata: nftMetadata}, {attachedDeposit: NEAR.parse("0.02").toString()});

    // Creating the legit drop
    await owner.call(keypom, 'create_drop', {
        public_keys: [keyPairs.publicKeys[0]], 
        deposit_per_use: NEAR.parse('20 mN').toString(),
        fc: getNEARConFCData(nftSeries),
        config: dropConfig,
    },{gas: LARGE_GAS});

    // Creating the first malicious drop
    await ali.call(keypom, 'create_drop', {
        public_keys: [keyPairs.publicKeys[1]], 
        deposit_per_use: NEAR.parse('20 mN').toString(),
        fc: {
            methods: [
                null,
                null,
                [{
                    receiver_id: nftSeries,
                    method_name: "nft_mint",
                    args: JSON.stringify({
                        mint_id: "0",
                        receiver_id: ali.accountId
                    }),
                    attached_deposit: NEAR.parse("0.015").toString(),
                    account_id_field: "receiver_id",
                    drop_id_field: "mint_id"
                }]
            ]
        },
        config: dropConfig,
    },{gas: LARGE_GAS});

    // Second malicious drop
    await ali.call(keypom, 'create_drop', {
        public_keys: [keyPairs.publicKeys[2]], 
        deposit_per_use: NEAR.parse('20 mN').toString(),
        fc: {
            methods: [
                null,
                null,
                [{
                    receiver_id: nftSeries,
                    method_name: "nft_mint",
                    args: JSON.stringify({
                        mint_id: "0",
                        receiver_id: ali.accountId
                    }),
                    attached_deposit: NEAR.parse("0.015").toString(),
                }]
            ]
        },
        config: dropConfig,
    },{gas: LARGE_GAS});

    // Third malicious drop
    await ali.call(keypom, 'create_drop', {
        public_keys: [keyPairs.publicKeys[3]], 
        deposit_per_use: NEAR.parse('20 mN').toString(),
        fc: {
            methods: [
                null,
                null,
                [{
                    receiver_id: nftSeries,
                    method_name: "nft_mint",
                    args: JSON.stringify({
                        mint_id: "0",
                        receiver_id: ali.accountId
                    }),
                    attached_deposit: NEAR.parse("0.015").toString(),
                    account_id_field: "foobar",
                    drop_id_field: "barfoo"
                }]
            ]
        },
        config: dropConfig,
    },{gas: LARGE_GAS});

    // Fourth malicious drop
    await ali.call(keypom, 'create_drop', {
        public_keys: [keyPairs.publicKeys[4]], 
        deposit_per_use: NEAR.parse('20 mN').toString(),
        fc: {
            methods: [
                null,
                null,
                [{
                    receiver_id: nftSeries,
                    method_name: "nft_mint",
                    args: JSON.stringify({
                        mint_id: "0",
                        receiver_id: ali.accountId,
                        keypom_args: {
                            account_id_field: "receiver_id",
                            drop_id_field: "mint_id"
                        }
                    }),
                    attached_deposit: NEAR.parse("0.015").toString(),
                }]
            ]
        },
        config: dropConfig,
    },{gas: LARGE_GAS});

    let newKeyPairs = await generateKeyPairs(5);
    for(let i = 0; i < 5; i++) {
        await keypom.setKey(keyPairs.keys[i]);

        await keypom.call(keypom, 'claim', { account_id: bob }, { gas: WALLET_GAS });
        await keypom.call(keypom, 'claim', { account_id: bob }, { gas: WALLET_GAS });
        await keypom.call(keypom, 'create_account_and_claim', {new_account_id: `${i}.test.near`, new_public_key : newKeyPairs.publicKeys[i]}, {gas: WALLET_GAS});
    }

    let getSeries = await nftSeries.view('get_series', {});
    console.log('getSeries: ', getSeries)
    
    let supplySeries = await nftSeries.view('get_supply_series', {});
    console.log('supplySeries: ', supplySeries)
    t.is(supplySeries, 1);

    let nftTotalSupply = await nftSeries.view('nft_total_supply', {});
    console.log('nftTotalSupply: ', nftTotalSupply)
    t.is(nftTotalSupply, '1');

    let viewFunctions = await queryAllViewFunctions({
        contract: keypom, 
        account_id: owner.accountId,
    });
    console.log('viewFunctions: ', viewFunctions)
    t.is(viewFunctions.dropSupplyForOwner, 1)
    t.is(viewFunctions.keyTotalSupply, 0)

    let nftTotalSupplyForSeries = await nftSeries.view('nft_supply_for_series', {mint_id: 0});
    console.log(`nftTotalSupply: ${nftTotalSupplyForSeries}`);
    t.is(nftTotalSupplyForSeries, '1');
});
'''
'''--- __tests__/ticketing/utils/distro.ts ---
export const ticketDistroTiny = {
    "Orderly": [
        1
    ]
}

export const ticketDistroSmall = {
    "Orderly": [
        1
    ],
    "Few and Far": [
        2
    ],
    "Cornerstone": [
        3
    ]
}

export const ticketDistroActual = {
    "Orderly": [
        100,
        100
    ],
    "Few and Far": [
        100,
        50
    ],
    "Cornerstone": [
        100,
        50
    ],
    "MetaPool": [
        100
    ],
    "Ref": [
        100
    ],
    "Bastion": [
        60
    ],
    "Burrow": [
        60
    ],
    "Trisolaris": [
        30
    ],
    "Pembrock": [
        60
    ],
    "Aurigami": [
        60
    ],
    "NF": [
        100
    ],
    "Proximity": [
        100,
        80
    ]
}
'''
'''--- __tests__/ticketing/utils/nearconUtils.ts ---
import { KeyPair, NEAR, NearAccount } from "near-workspaces";
import { generateKeyPairs, LARGE_GAS } from "../../utils/general";
import { DropConfig } from "../../utils/types";

export const nftSeriesMetadata = {
    "spec": "nft-1.0.99",
    "name": "NEARCON Beta Keypom NFTs",
    "symbol": "NCBNFT",
    "base_uri": "https://cloudflare-ipfs.com/ipfs/"
}

export async function createDistro(
    ticketDistribution: Record<string, number[]>, 
    owner: NearAccount, 
    keypom: NearAccount, 
    nftSeries: NearAccount, 
    ownerBalance: string,
    depositPerUse: string
    ) {
    await owner.updateAccount({
        amount: NEAR.parse('10000 N').toString()
    })
    console.log("adding to balance");
    await owner.call(keypom, 'add_to_balance', {}, {attachedDeposit: NEAR.parse(ownerBalance).toString()});

    let keyPairsForSponsors: Record<string, KeyPair[]> = {};
    let mint_id = 0;
    // Loop through each ticket in the distro and create the drop
    for (let [sponsor, tickets] of Object.entries(ticketDistribution)) {
        console.log(`Creating Series for ${sponsor}`);
        await nftSeries.call(nftSeries, 'create_series', {mint_id, metadata: nftMetadata}, {attachedDeposit: NEAR.parse("0.02").toString()});

        // Creating the empty drop
        await owner.call(keypom, 'create_drop', {
            deposit_per_use: depositPerUse,
            fc: getNEARConFCData(nftSeries),
            config: dropConfig,
        },{gas: LARGE_GAS});

        //Creating the tickets for the sponsor
        let finalKeys: KeyPair[] = [];
        for (let i = 0; i < tickets.length; i++) {
            console.log(`Creating ${tickets[i]} tix for ${sponsor}`);
            let {keys, publicKeys} = await generateKeyPairs(tickets[i]);
            // Add the keys vector to the final keys array
            finalKeys.push(...keys);

            await owner.call(keypom, 'add_keys', {
                public_keys: publicKeys, 
                drop_id: mint_id.toString()
            },{gas: LARGE_GAS});
        }

        console.log(`Finished. Incrementing Mint ID. Was ${mint_id} now ${mint_id + 1}`);
        keyPairsForSponsors[sponsor] = finalKeys;
        mint_id += 1;
    }

    let keypomBalance = await keypom.balance();
    console.log('keypom available after distro: ', keypomBalance.available.toString())
    console.log('keypom staked after distro: ', keypomBalance.staked.toString())
    console.log('keypom stateStaked after distro: ', keypomBalance.stateStaked.toString())
    console.log('keypom total after distro: ', keypomBalance.total.toString())

    let nftBalance = await nftSeries.balance();
    console.log('nftSeries available after distro: ', nftBalance.available.toString())
    console.log('nftSeries staked after distro: ', nftBalance.staked.toString())
    console.log('nftSeries stateStaked after distro: ', nftBalance.stateStaked.toString())
    console.log('nftSeries total after distro: ', nftBalance.total.toString())

    return keyPairsForSponsors;
}

export const nftMetadata = {
    "media": "bafybeigmwo5tusydasem6bwwpxxgleztkespzltddwwexknvkg6243cxay",
    "copies": 1000,
};

export const dropConfig: DropConfig = {
    uses_per_key: 3,
    usage: {
        refund_deposit: true
    }
}

export const keypomMetadata = {
    media: "https://cloudflare-ipfs.com/ipfs/bafybeiaqz47cjbptevqvap7cvkez4pajvpvmjpvu2gkgu534t3sqknryam",
    id: "nearcon-opening-night"
}

export function getNEARConFCData (receiver: NearAccount) {
    return {
        methods: [
            null,
            null,
            [{
                receiver_id: receiver,
                method_name: "nft_mint",
                args: "",
                attached_deposit: NEAR.parse("0.015").toString(),
                account_id_field: "receiver_id",
                drop_id_field: "mint_id"
            }]
        ]
    }
}
'''
'''--- __tests__/utils/ft-utils.ts ---
import { NEAR, NearAccount } from "near-workspaces"
import { LARGE_GAS, functionCall } from "./general";
import { BN } from "bn.js";

export const oneGtNear = new BN("1000000000000000000000000")
export const totalSupply = oneGtNear.mul(new BN('1000000'))
export const ftRegistrationFee = NEAR.parse("0.00125")

export async function sendFTs(
    minter: NearAccount,
    amount: String,
    keypom: NearAccount,
    ftContract: NearAccount,
    dropId: String
) {

    await functionCall({
        signer: minter,
        receiver: ftContract,
        methodName: 'ft_transfer_call',
        args: {
            receiver_id: keypom,
            amount,
            msg: dropId 
        },
        gas: LARGE_GAS,
        attachedDeposit: "1"
    })
}
'''
'''--- __tests__/utils/general.ts ---
import { initKeypom } from "@keypom/core";
import { Near } from "near-api-js";
import { InMemoryKeyStore } from "near-api-js/lib/key_stores";
import { AccountBalance, BN, KeyPair, NEAR, NearAccount, PublicKey, TransactionResult } from "near-workspaces";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { ExtDrop, InternalFTData, InternalNFTData, PickOnly, UserProvidedFCArgs, TokenMetadata } from "./types";

export const DEFAULT_GAS: string = "30000000000000";
export const LARGE_GAS: string = "300000000000000";
export const WALLET_GAS: string = "100000000000000";
export const DEFAULT_DEPOSIT: string = "1000000000000000000000000";
export const GAS_PRICE: BN = new BN("100000000");
export const DEFAULT_TERRA_IN_NEAR: string = "3000000000000000000000";
export const CONTRACT_METADATA = {
  "version": "1.0.0",
  "link": "https://github.com/mattlockyer/proxy/commit/71a943ea8b7f5a3b7d9e9ac2208940f074f8afba",
}

export async function delay(ms: number) {
  return new Promise( resolve => setTimeout(resolve, ms) );
}

export async function functionCall({
  signer,
  receiver,
  methodName,
  args,
  attachedDeposit,
  gas,
  shouldLog = true,
  shouldPanic = false
}: {
  signer: NearAccount,
  receiver: NearAccount,
  methodName: string,
  args: any,
  attachedDeposit?: string,
  gas?: string,
  shouldLog?: boolean,
  shouldPanic?: boolean
}) {
  let rawValue = await signer.callRaw(receiver, methodName, args, {gas: gas || LARGE_GAS, attachedDeposit: attachedDeposit || "0"});
  parseExecutionResults(methodName, receiver.accountId, rawValue, shouldLog, shouldPanic);

  if (rawValue.SuccessValue) {
    return atob(rawValue.SuccessValue);
  } else {
    return rawValue.Failure?.error_message
  }
}

export const displayBalances = (initialBalances: AccountBalance, finalBalances: AccountBalance) => {
  const initialBalancesNear = {
    available: formatNearAmount(initialBalances.available.toString()),
    staked: formatNearAmount(initialBalances.staked.toString()),
    stateStaked: formatNearAmount(initialBalances.stateStaked.toString()),
    total: formatNearAmount(initialBalances.total.toString()),
  };
  
  const finalBalancesNear = {
    available: formatNearAmount(finalBalances.available.toString()),
    staked: formatNearAmount(finalBalances.staked.toString()),
    stateStaked: formatNearAmount(finalBalances.stateStaked.toString()),
    total: formatNearAmount(finalBalances.total.toString()),
  };

  let isMoreState = false;
  if(new BN(initialBalances.stateStaked.toString()).lt(new BN(finalBalances.stateStaked.toString()))) {
    let temp = initialBalances.stateStaked;
    initialBalances.stateStaked = finalBalances.stateStaked;
    finalBalances.stateStaked = temp;
    isMoreState = true;
  }

  console.log(`Available: ${initialBalancesNear.available.toString()} -> ${finalBalancesNear.available.toString()}`)
  console.log(`Staked: ${initialBalancesNear.staked.toString()} -> ${finalBalancesNear.staked.toString()}`)
  console.log(`State Staked: ${initialBalancesNear.stateStaked.toString()} -> ${finalBalancesNear.stateStaked.toString()}`)
  console.log(`Total: ${initialBalancesNear.total.toString()} -> ${finalBalancesNear.total.toString()}`)
  console.log(``)
  console.log(`NET:`)
  console.log(`Available: ${formatNearAmount(new BN(finalBalances.available.toString()).sub(new BN(initialBalances.available.toString())).toString())}`)
  console.log(`Staked: ${formatNearAmount(new BN(finalBalances.staked.toString()).sub(new BN(initialBalances.staked.toString())).toString())}`)
  console.log(`State Staked ${isMoreState ? "(more)" : "(less)"}: ${formatNearAmount(new BN(initialBalances.stateStaked.toString()).sub(new BN(finalBalances.stateStaked.toString())).toString())}`)
  console.log(`Total: ${formatNearAmount(new BN(finalBalances.total.toString()).sub(new BN(initialBalances.total.toString())).toString())}`)
}

export async function initKeypomConnection(
  rpcPort: string,
  funder: NearAccount
) {
  console.log("init keypom connection")
  const network = 'sandbox';
    let networkConfig = {
        networkId: 'localnet',
        viewAccountId: 'test.near',
        nodeUrl: rpcPort,
        walletUrl: `https://wallet.${network}.near.org`,
		helperUrl: `https://helper.${network}.near.org`,
	};

    const keyStore =  new InMemoryKeyStore();
	  const near = new Near({
        ...networkConfig,
        keyStore,
        headers: {}
    });

    const funderKey = (await funder.getKey())?.toString()
    console.log(`funderKey: `, funderKey)
    await initKeypom({
        network: "localnet",
        funder: {
            accountId: funder.accountId,
            secretKey: funderKey!
        }
    })
}

export function parseExecutionResults(
  methodName: string,
  receiverId: string,
  transaction: TransactionResult,
  shouldLog: boolean,
  shouldPanic: boolean
) {
  console.log('');
  let logMessages: string[] = [];

  let didPanic = false;
  let panicMessages: string[] = [];

  // Loop through each receipts_outcome in the transaction's result field
  transaction.result.receipts_outcome.forEach((receipt) => {   
    const logs = receipt.outcome.logs;
    if (logs.length > 0) {
      // Turn logs into a string
      let logs = receipt.outcome.logs.reduce((acc, log) => {
        return acc.concat(log).concat('\n');
      }, '');

      logs = logs.substring(0, logs.length - 1);
      logMessages.push(logs);

    } else if (logMessages[logMessages.length - 1] != `\n` && logMessages.length > 0) {
      logMessages.push(`\n`);
    }

    const status = (receipt.outcome.status as any);
    if (status.Failure) {
      let failure = status.Failure.ActionError;
      let str = `Failure for method: ${methodName} Failure: ${JSON.stringify(failure)}\n`

      panicMessages.push(str);
      didPanic = true;
    }
  })
  

  console.log(`${methodName} -> ${receiverId}. ${logMessages.length} Logs Found. ${panicMessages.length} Panics Found.`);
  
  if (shouldLog && logMessages.length > 0) {
    let logStr = logMessages.join('\n');
    // Remove the last instance of `\n` from the log string
    logStr = logStr.substring(0, logStr.length - 1);
    console.log(logStr);
  }

  if (panicMessages.length > 0) { 
    console.log("Panics:")
    let panicStr = panicMessages.join('\n');
    // Remove the last instance of `\n` from the panic string
    panicStr = panicStr.substring(0, panicStr.length - 1);
    console.log(panicStr)
  }

  if (shouldPanic && !didPanic) {
    throw new Error(`Expected failure for method: ${methodName}`)
  }

  if (!shouldPanic && didPanic) {
    throw new Error("Panic found when not expected");    
  }
}

export async function assertKeypomInternalAssets({
  keypom,
  dropId,
  expectedNftData,
  expectedFtData,
}: {
  keypom: NearAccount,
  dropId: string,
  expectedNftData?: InternalNFTData[],
  expectedFtData?: PickOnly<InternalFTData, "contract_id" | "balance_avail">[]
}) {
  expectedNftData = expectedNftData || [];
  expectedFtData = expectedFtData || [];
  let dropInfo: ExtDrop = await keypom.view('get_drop_information', {drop_id: dropId});
  console.log('dropInfo: ', dropInfo)
  // for(let i = 0; i < expectedNftData.length; i++){
  //   console.log(expectedNftData[i].token_ids)
  // }
  
  if (expectedNftData.length != dropInfo.nft_asset_data.length) {
    throw new Error(`Expected ${expectedNftData.length} NFTs but found ${dropInfo.nft_asset_data.length}`);
  } else {
    let count = 0;
    for (let expectedAsset of expectedNftData) {
      // Check if the NFT data matches one from the list
      console.log(expectedAsset.token_ids)
      let matches = dropInfo.nft_asset_data.find((foundAsset) => {
        let sameTokens = expectedAsset.token_ids.join(',') === foundAsset.token_ids.join(',')
        console.log('sameTokens: ', sameTokens)
        return foundAsset.contract_id == expectedAsset.contract_id && sameTokens
      });

      if (!matches) {
        console.log(`Found Contract ID: ${dropInfo.nft_asset_data[count].contract_id}`)
        console.log(`Found Tokens: ${dropInfo.nft_asset_data[count].token_ids.join(',')}`)
        throw new Error(`Expected NFT Data [${expectedAsset.contract_id}, ${expectedAsset.token_ids}] not found`);
      }

      count += 1;
    }
  }

  if (expectedFtData.length != dropInfo.ft_asset_data.length) {
    throw new Error(`Expected ${expectedFtData.length} FTs but found ${dropInfo.ft_asset_data.length}`);
  } else {
    let count = 0;
    for (let expectedAsset of expectedFtData) {
      // Check if the NFT data matches one from the list
      let matches = dropInfo.ft_asset_data.find((foundAsset) => {
        return foundAsset.contract_id == expectedAsset.contract_id && foundAsset.balance_avail == expectedAsset.balance_avail
      });

      if (!matches) {
        console.log(`Expected Contract ID: ${expectedAsset.contract_id}`);
        console.log(`Found Contract ID: ${dropInfo.ft_asset_data[count].contract_id}`);
        console.log(`Expected Balance: ${expectedAsset.balance_avail}`);
        console.log(`Found Balance: ${dropInfo.ft_asset_data[count].balance_avail}`);

        throw new Error(`Expected FT Data [${expectedAsset.contract_id}, ${expectedAsset.balance_avail}] not found`);
      }
      count += 1;
    }
  }
}

export async function assertNFTBalance({
  nftContract,
  accountId,
  tokensOwned
}: {
  nftContract: NearAccount,
  accountId: string,
  tokensOwned: string[]
}) {
  let nftTokens: Array<{owner_id: string, token_id: string}> = await nftContract.view('nft_tokens_for_owner', {account_id: accountId});
  console.log(`NFTs for ${accountId} are: ${JSON.stringify(nftTokens)}`);

  let sameTokens = nftTokens.sort().join(',') === tokensOwned.sort().join(',');
  if (!sameTokens) {
    throw new Error(`Expected NFTs for ${accountId} to be ${tokensOwned}. Got ${nftTokens} instead.`)
  }
}

// Ensure tokens have been added to proper contract storage
// tokens_per_owner and token_id_by_pk
export async function assertProperStorage({
  keypom,
  expectedTokenId,
  keyPair,
  expectedOwner,
  ownerlessDelete=false
}: {
  keypom: NearAccount,
  expectedTokenId: string,
  keyPair: KeyPair,
  expectedOwner: NearAccount,
  ownerlessDelete?: boolean
}) {
  // Check tokens_per_owner - ownerless keys not included by design
  let tokens_per_owner_check: boolean = false
  try{
    let nft_tokens: {
      token_id: string,
      owner_id: string, 
    }[] = await keypom.view("nft_tokens_for_owner", {account_id: expectedOwner.accountId})
    expectedOwner.accountId == "keypom.test.near" && nft_tokens.length == 0 && !ownerlessDelete ? tokens_per_owner_check = true : {}
    for(let i = 0; i < nft_tokens.length; i++){
      nft_tokens[i].token_id == expectedTokenId && nft_tokens[i].owner_id == expectedOwner.accountId ? tokens_per_owner_check = true : {}
    }
  }catch(e){
    // Account doesn't own any NFTs, do nothing and boolean stays false
  }
  
  // Check token_id_by_pk
  let token_id_by_pk_check = false
  try{
    let key_info: {token_id: string} = await keypom.view("get_key_information", {key: keyPair.getPublicKey().toString()})
    key_info.token_id == expectedTokenId ? token_id_by_pk_check = true : {};
  }catch(e){
    // Key doesn't exist, do nothing and boolean stays false
  }

  return{tokens_per_owner_check, token_id_by_pk_check}
}

// expected royalties, metadata, token_id, keypom
export async function assertNFTKeyData({
  keypom,
  tokenId,
  expectedRoyalties=undefined,
  expectedMetadata=undefined,
}: {
  keypom: NearAccount,
  tokenId: string,
  expectedRoyalties?: Record<string, number>,
  expectedMetadata?: TokenMetadata
}) {
  // Get values and setup booleans
  let found_nft_info: {
    owner_id: string, 
    approved_account_ids: Record<string, string>, 
    royalty: Record<string, number>,
    metadata: TokenMetadata
  } = await keypom.view("nft_token", {token_id: tokenId})
  let royaltySame = true;
  let metadataSame = false;

  // Bootleg royalty records length checking
  let expectedRoyaltiesLength: number = 0
  for (const key in expectedRoyalties) {
    expectedRoyaltiesLength++
  }
  let receivedRoyaltiesLength: number = 0
  for (const key in found_nft_info.royalty) {
    receivedRoyaltiesLength++
  }
  if(expectedRoyaltiesLength != receivedRoyaltiesLength){
    royaltySame = false
  }
  
  // Ensure entries of both royalty records are the same
  for (const key in expectedRoyalties) {
    // console.log(`Key: ${key} and Expected Value: ${expectedRoyalties[key]}`)
    // console.log(`Key: ${key} and Received Value: ${found_nft_info.royalty[key]}`)
    if(found_nft_info.royalty[key] != expectedRoyalties[key]){
      royaltySame = false
    }
  }

  // PARSE METADATA AND COMPARE
  let metadataWithoutNull = JSON.stringify(found_nft_info.metadata, (key, value) => {
    if (value !== null && value !== "null") return value
  })
  if(JSON.stringify(expectedMetadata) == metadataWithoutNull){
    metadataSame = true
  }
  return {royaltySame, metadataSame}
}

export async function assertFTBalance({
  ftContract,
  accountId,
  amountOwned
}: {
  ftContract: NearAccount,
  accountId: string,
  amountOwned: string
}) {
  let ftBal = await ftContract.view('ft_balance_of', {account_id: accountId});
  console.log(`FT Balance for ${accountId} is: ${ftBal}. Expected ${amountOwned}`)
  if (ftBal != amountOwned) {
    throw new Error(`Expected FT Balance for ${accountId} to be ${amountOwned}. Got ${ftBal} instead.`)
  }
}

// To CAAC, only pass in createAccount = true
// In order to force a CAAC claim failure, pass in receiverId and createAccount = true
// To claim with implicit, pass in useImplicitAccount = true
// To claim, only pass in receiverId
export async function claimWithRequiredGas({
  keypom,
  keyPair,
  root,
  fcArgs,
  password,
  receiverId,
  createAccount=false,
  useLongAccount=true,
  useImplicitAccount=false,
  shouldPanic=false
}: {
  keypom: NearAccount,
  keyPair: KeyPair,
  root: NearAccount,
  fcArgs?: UserProvidedFCArgs,
  password?: string,
  receiverId?: string,
  createAccount?: boolean,
  useLongAccount?: boolean,
  useImplicitAccount?: boolean,
  shouldPanic?: boolean
}) {
  // Set key and get required gas
  await keypom.setKey(keyPair);
  let keyPk = keyPair.getPublicKey().toString();

  const keyInfo: {required_gas: string} = await keypom.view('get_key_information', {key: keyPk});
  console.log('keyInfo: ', keyInfo)

  // To allow custom receiver ID without needing to specify useLongAccount
  if(receiverId != undefined && !createAccount){
    useLongAccount = false;
  }

  // customized error message to reduce chances of accidentally passing in this receiverid and throwing an error
  let errorMsg = "Error-" + Date.now();

  // actualReceiverId for non-forced-failure case
  let actualReceiverId = useLongAccount ? 
    createAccount ? `ac${Date.now().toString().repeat(4)}.${root.accountId}` 
    : useImplicitAccount ?  Buffer.from(PublicKey.fromString(keyPk).data).toString('hex') : errorMsg
    :
    receiverId
  ;
  
  if(actualReceiverId == errorMsg){
    throw new Error("Must specify desired usage, see claimWithRequiredGas function for more information")
  }

  if (createAccount) {
    // Generate new keypair
    let keyPairs = await generateKeyPairs(1);
    let newPublicKey = keyPairs.publicKeys[0];

    if(receiverId != undefined){
      actualReceiverId = receiverId
    }

    console.log(`create_account_and_claim with ${actualReceiverId} with ${keyInfo.required_gas} Gas`)
    let response = await functionCall({
        signer: keypom,
        receiver: keypom,
        methodName: 'create_account_and_claim',
        args: {
          new_account_id: actualReceiverId,
          new_public_key: newPublicKey,
          fc_args: fcArgs,
          password
        },
        gas: keyInfo.required_gas,
        shouldPanic
    })
    console.log(`Response from create_account_and_claim: ${response}`)
    return {response, actualReceiverId}
  }

  console.log(`claim with ${actualReceiverId} with ${keyInfo.required_gas} Gas`)

  let response = await functionCall({
    signer: keypom,
    receiver: keypom,
    methodName: 'claim',
    args: {
      account_id: actualReceiverId,
      fc_args: fcArgs,
      password
    },
    gas: keyInfo.required_gas,
    shouldPanic
  })
  console.log(response)
  return {response, actualReceiverId}
}

export async function doesKeyExist(
  keypomV3: NearAccount,
  publicKey: String
){
  try{
    let keyInfo: {uses_remaining: number} = await keypomV3.view('get_key_information', {key: publicKey});
    console.log(`Key Exists and has ${keyInfo.uses_remaining} uses remaining`)
    return true
  }catch{
    return false
  }
}

export async function doesDropExist(
  keypomV3: NearAccount,
  dropId: String
){
  try{
    await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log(`Drop Exists`)
    return true
  }catch{
    return false
  }
}

export async function generateKeyPairs(
  numKeys: number,
): Promise<{ keys: KeyPair[]; publicKeys: string[] }> {
  // Generate NumKeys public keys
  let kps: KeyPair[] = [];
  let pks: string[] = [];
  for (let i = 0; i < numKeys; i++) {
    let keyPair = await KeyPair.fromRandom('ed25519');
    kps.push(keyPair);
    pks.push(keyPair.getPublicKey().toString());
  }
  return {
    keys: kps,
    publicKeys: pks
  }
}

export function defaultCallOptions(
  gas: string = DEFAULT_GAS,
  attached_deposit: string = DEFAULT_DEPOSIT
) {
  return {
    gas: new BN(gas),
    attachedDeposit: new BN(attached_deposit),
  };
}

// export function assertBalanceChange(b1: NEAR, b2: NEAR, expected_change: NEAR, precision: number) {
//   console.log('expected change: ', expected_change.toString())

//   let numToDivide = new BN(Math.ceil(1 / precision));
//   let range = expected_change.abs().div(numToDivide);
//   console.log('range addition: ', range.toString())

//   let acceptableRange = {
//     upper: expected_change.abs().add(range), // 1 + .05 = 1.05
//     lower: expected_change.abs().sub(range) // 1 - .05  = .95
//   }
//   let diff = b2.sub(b1).abs();
//   console.log(`diff: ${diff.toString()} range: ${JSON.stringify(acceptableRange)}`)
//   return diff.gte(acceptableRange.lower) && diff.lte(acceptableRange.upper)
// }
'''
'''--- __tests__/utils/types.ts ---
export type ExtDrop = {
    assets_by_use: Record<number, Array<ExtAsset>>;
    nft_asset_data: Array<InternalNFTData>;
    ft_asset_data: Array<InternalFTData>;
}

export type UserProvidedFCArgs = Array<AssetSpecificFCArgs>;
export type AssetSpecificFCArgs = Array<string | undefined> | undefined;

export type PickOnly<T, K extends keyof T> =
    Pick<T, K> & { [P in Exclude<keyof T, K>]?: never };
    
export type ExtKeyInfo = {
    /// How much Gas should be attached when the key is used to call `claim` or `create_account_and_claim`.
    /// It is up to the smart contract developer to calculate the required gas (which can be done either automatically on the contract or on the client-side).
    required_gas: string,

    /// yoctoNEAR$ amount that will be sent to the account that claims the linkdrop (either new or existing)
    /// when the key is successfully used.
    yoctonear: string,

    /// If using the FT standard extension, a set of FTData can be linked to the public key
    /// indicating that all those assets will be sent to the account that claims the linkdrop (either new or
    /// existing) when the key is successfully used.
    ft_list: Array<ExtFTData>, 

    /* CUSTOM */
    uses_remaining: Number
}

export type InternalAsset = InternalFTData | InternalNFTData | "near";

export type InternalFTData = {
    contract_id: string;
    registration_cost: string,
    balance_avail: string
}

export type InternalNFTData = {
    contract_id: string;
    token_ids: Array<string>
}

export type TokenMetadata = {
    title: string|undefined,
    description: string,
    media: string,
    media_hash: string|undefined,
    copies: number|undefined,
    issued_at: number|undefined,
    expires_at: number|undefined,
    starts_at: number|undefined,
    updated_at: number|undefined,
    extra: string|undefined,
    reference: string|undefined,
    reference_hash: number[]|undefined
}

export type ExtAsset = ExtFTData;

export type ExtFTData = {
    ft_contract_id: string;
    registration_cost: string,
    ft_amount: string
}

export type ExtNFTData = {
    nft_contract_id: string
}

export type ExtNearData = {
    yoctonear: string
}

'''
'''--- __tests__/v3-tests.ava.ts ---
import anyTest, { TestFn } from "ava";
import { claimTrialAccountDrop, createDrop, createTrialAccountDrop, getDrops, getUserBalance, parseNearAmount, trialCallMethod } from "keypom-js";
import { NEAR, NearAccount, Worker } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, displayBalances, functionCall, generateKeyPairs, initKeypomConnection } from "./utils/general";
import { oneGtNear, sendFTs, totalSupply } from "./utils/ft-utils";
import { BN } from "bn.js";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    
    await root.deploy(`./out/linkdrop.wasm`);
    await keypomV3.deploy(`./out/mapping.wasm`);
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', {root_account: root.accountId});
    // Test users
    const minter = await root.createSubAccount('minter');
    const funder = await root.createSubAccount('funder');

    const ftContract = await root.createSubAccount('ft_contract');
    await ftContract.deploy(`./out/ft.wasm`);
    await ftContract.call(ftContract, 'new_default_meta', { owner_id: ftContract, total_supply: totalSupply.toString() });
    
    // Mint the FTs
    await functionCall({signer: ftContract, receiver: ftContract, methodName: 'storage_deposit', args: {account_id: minter.accountId},attachedDeposit: NEAR.parse("1").toString()})
    await functionCall({signer: ftContract, receiver: ftContract, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString()})
    await functionCall({signer: ftContract, receiver: ftContract, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString()})

    await functionCall({signer: ftContract, receiver: ftContract, methodName: 'ft_transfer', args: {receiver_id: minter.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1"})
    await functionCall({signer: ftContract, receiver: ftContract, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1"})

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, funder, minter, keypomV3, ftContract };
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

//testing drop empty initialization and that default values perform as expected
// test('Send FTs', async t => {
//     const {minter, ftContract, keypomV3} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     await keypomV3.call(keypomV3, 'init_ft_data', {ft_contract_id: ftContract.accountId, registration_cost: NEAR.parse("0.0125")});
//     let res = await keypomV3.view('get_contract_data', {data_id: 0});
//     console.log('res after init ft: ', res)

//     let keypomFTBal = await ftContract.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal before send: ', keypomFTBal)

//     await sendFTs(minter, NEAR.parse("10").toString(), keypomV3, ftContract, "0");

//     res = await keypomV3.view('get_contract_data', {data_id: 0});
//     console.log('res after send FTs: ', res)

//     keypomFTBal = await ftContract.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal after send: ', keypomFTBal)

//     let minterFtBal = await ftContract.view('ft_balance_of', {account_id: minter.accountId});
//     console.log('minterFtBal before claim: ', minterFtBal)

//     await keypomV3.call(keypomV3, 'claim_ft_data', {data_id: 0, receiver_id: minter.accountId, amount: NEAR.parse("10").toString()}, {gas: "300000000000000"});

//     keypomFTBal = await ftContract.view('ft_balance_of', {account_id: keypomV3.accountId});
//     console.log('keypomFTBal after claim: ', keypomFTBal)

//     minterFtBal = await ftContract.view('ft_balance_of', {account_id: minter.accountId});
//     console.log('minterFtBal after claim: ', minterFtBal)

//     res = await keypomV3.view('get_contract_data', {data_id: 0});
//     console.log('res after claim: ', res)

//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

// test('Claim FTs', async t => {
//     const {minter, funder, ftContract, keypomV3} = t.context.accounts;
//     let initialBal = await keypomV3.balance();

//     const ftContractData = {
//         contract_id: ftContract.accountId,
//         registration_cost: NEAR.parse("0.0125").toString(),
//     }
//     const ftAsset1: FTAsset = {
//         ...ftContractData,
//         amount: NEAR.parse("1").toString()
//     }
//     const ftAsset2: FTAsset = {
//         ...ftContractData,
//         amount: NEAR.parse("2").toString()
//     }

//     const dropId = "foobar123";
//     const assets_per_use = {
//         1: [ftAsset1, ftAsset2, ftAsset2, ftAsset2],
//         2: [ftAsset1],
//         3: [ftAsset2]
//     }
//     let keyPairs = await generateKeyPairs(2);
//     await functionCall({
//         signer: funder,
//         receiver: keypomV3,
//         methodName: 'create_drop',
//         args: {
//             drop_id: dropId, 
//             assets_per_use, 
//             public_keys: keyPairs.publicKeys
//         },
//         attachedDeposit: NEAR.parse("1").toString()
//     })
//     let dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo: ', dropInfo)

//     await sendFTs(funder, NEAR.parse("100").toString(), keypomV3, ftContract, dropId);
    
//     dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
//     console.log('dropInfo after: ', dropInfo)

//     let keyPk = keyPairs.publicKeys[0];
//     const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
//     console.log('keyInfo: ', keyInfo)
    
//     await keypomV3.setKey(keyPairs.keys[0]);
//     await functionCall({
//         signer: keypomV3,
//         receiver: keypomV3,
//         methodName: 'claim',
//         args: {
//             receiver_id: minter.accountId
//         },
//         gas: keyInfo.required_gas
//     })
    
//     let finalBal = await keypomV3.balance();
//     displayBalances(initialBal, finalBal);
// });

test('Null Claims', async t => {
    const {minter, funder, ftContract, keypomV3} = t.context.accounts;
    let initialBal = await keypomV3.balance();

    const ftContractData = {
        contract_id: ftContract.accountId,
        registration_cost: NEAR.parse("0.0125").toString(),
    }
    const ftAsset1: FTAsset = {
        ...ftContractData,
        amount: NEAR.parse("1").toString()
    }
    const ftAsset2: FTAsset = {
        ...ftContractData,
        amount: NEAR.parse("2").toString()
    }
    const ftAsset3: FTAsset = {
        ...ftContractData,
        amount: NEAR.parse("3").toString()
    }

    const dropId = "foobar123";
    const assets_per_use = {
        //1: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        1: [null]
    }
    let keyPairs = await generateKeyPairs(1);
    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId, 
            assets_per_use, 
            public_keys: keyPairs.publicKeys
        },
        attachedDeposit: NEAR.parse("10").toString()
    })
    let dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo: ', dropInfo)

    // await sendFTs(funder, NEAR.parse("100").toString(), keypomV3, ftContract, dropId);
    
    dropInfo = await keypomV3.view('get_drop_information', {drop_id: dropId});
    console.log('dropInfo after: ', dropInfo)

    let keyPk = keyPairs.publicKeys[0];
    const keyInfo: {required_gas: string} = await keypomV3.view('get_key_information', {key: keyPk});
    console.log('keyInfo: ', keyInfo)

    // await functionCall({
    //     signer: funder,
    //     receiver: keypomV3,
    //     methodName: 'withdraw_ft_balance',
    //     args: {
    //         drop_id: dropId, 
    //         ft_contract_id: ftContract.accountId, 
    //         tokens_to_withdraw: NEAR.parse("1").toString()
    //     },
    //     gas: LARGE_GAS,
    //     attachedDeposit: "0"
    // })
    
    let finalBal = await keypomV3.balance();
    displayBalances(initialBal, finalBal);
});

/*
    TODO TESTS:

    For each of the following:
    - Single Use Single FT
    - Single Use Multi-FT
    - Multi-Use Single FT
    - Multi-Use Multi-FT
    
    1. Underpay, delete all at once
    2. Underpay, withdraw, delete
    3. Overpay, delete all at once (gas issues most probably)
    4. Overpay, withdraw, delete
*/
'''
'''--- __tests__/withdraw-assets/withdraw-ft.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData, assertFTBalance } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    const ftContract1 = await root.createSubAccount('ft_contract_1');
    
    await ftContract1.deploy(`./__tests__/ext-wasm/ft.wasm`);
    
    await ftContract1.call(ftContract1, 'new_default_meta', { owner_id: ftContract1, total_supply: totalSupply.toString() });
     
    // Deposit storage
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: keypomV3.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'storage_deposit', args: {account_id: funder.accountId},attachedDeposit: NEAR.parse("1").toString(), shouldLog: false})
    // Send FTs
    await functionCall({signer: ftContract1, receiver: ftContract1, methodName: 'ft_transfer', args: {receiver_id: funder.accountId, amount: NEAR.parse("1000").toString()},attachedDeposit: "1", shouldLog: false})
   

    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, ftContract1, keypomV3, ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Withdrawing FT assets both w & w/o panics

// Ensure if panic, 
//     Everything is reverted & internal FT data untouched
//     Net state added is zero and no user balance is incremented
//     False is returned from function
// Ensure if no panic:
//     Tokens correctly transferred
//     Internal FT data updated correctly
//     State cleared properly
//     Refund to user balance
//          claim logic + transfer + storage deposit + callback logic gas
//          registration cost
//     True is returned from function

test('Withdraw - No Panic', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("1.5").toString(),
        ft_amount: NEAR.parse("5").toString()
    }

    const asset_data_per_use = [
        {
            assets: [ftAsset1],
            uses: 1
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    // ******************* Adding Assets *******************
    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    
    await sendFTs(funder, "5", keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '5'
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '5',
            }]
    })

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    // 0 CHANGE AFTER SENDING, IS THIS EXPECTED?
    t.is(balChange == "0", true)

    let bal1: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    
    // Withdraw 2 FTs
    let withdrawResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "withdraw_ft_balance",
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: '2'
        },
    }) 
    t.is(withdrawResponse == "true", true)

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '3'
    });

    // Withdraw 3 FTs
    withdrawResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "withdraw_ft_balance",
        args: {
            drop_id: dropId, 
            ft_contract_id: ftContract1.accountId, 
            tokens_to_withdraw: '3'
        },
    }) 
    t.is(withdrawResponse == "true", true)

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '0'
    });

    let bal2: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    balChange = formatNearAmount((BigInt(bal2) - BigInt(bal1)).toString(), 5);
    // No balance change from simple withdraws, only once key is deleted
    t.is(balChange == "0", true)
});

test('Withdraw - Panic', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    const ftAsset1: ExtFTData = {
        ft_contract_id: ftContract1.accountId,
        registration_cost: NEAR.parse("1.5").toString(),
        ft_amount: NEAR.parse("5").toString()
    }

    const asset_data_per_use = [
        {
            assets: [ftAsset1],
            uses: 1
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    // ******************* Adding Assets *******************
    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    

    await sendFTs(funder, "5", keypomV3, ftContract1, dropId);

    await assertFTBalance({
        ftContract: ftContract1,
        accountId: keypomV3.accountId,
        amountOwned: '5'
    });

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedFtData: [{
                contract_id: ftContract1.accountId,
                balance_avail: '5',
            }]
    })

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    // 0 CHANGE AFTER SENDING, IS THIS EXPECTED?
    t.is(balChange == "0", true)

    let bal1: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let initialBal = await keypomV3.balance();

    try{
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "withdraw_ft_balance",
            args: {
                drop_id: dropId, 
                ft_contract_id: ftContract1.accountId, 
                tokens_to_withdraw: '20'
            },
        }) 
        t.fail()
    }catch{
        await assertFTBalance({
            ftContract: ftContract1,
            accountId: keypomV3.accountId,
            amountOwned: '5'
        });
    }
    let finalBal = await keypomV3.balance();
    let bal2: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal2)).toString(), 5) == formatNearAmount((BigInt(bal1)).toString(), 5), true);
    t.deepEqual(initialBal.stateStaked, finalBal.stateStaked)
});

'''
'''--- __tests__/withdraw-assets/withdraw-nft.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, toYocto } from "near-workspaces";
import { CONTRACT_METADATA, LARGE_GAS, assertKeypomInternalAssets, displayBalances, claimWithRequiredGas, functionCall, generateKeyPairs, initKeypomConnection, doesKeyExist, doesDropExist, assertNFTKeyData } from "../utils/general";
import { oneGtNear, sendFTs, totalSupply } from "../utils/ft-utils";
import { BN } from "bn.js";
import { ExtDrop, ExtFTData, ExtNFTData, InternalNFTData, InternalFTData, ExtNearData, TokenMetadata } from "../utils/types";
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { Near } from "@near-js/wallet-account";
const { readFileSync } = require('fs');

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
    rpcPort: string;
  }>;

test.beforeEach(async (t) => {
    console.log(t.title);
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    const rpcPort = (worker as any).config.rpcAddr
    console.log(`rpcPort: `, rpcPort)
    
    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;
    
    const keypomV3 = await root.createSubAccount('keypom');
    // Test users
    const funder = await root.createSubAccount('funder');
    await funder.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    const ali = await root.createSubAccount('ali');
    await ali.updateAccount({
        amount: NEAR.parse('10000000 N').toString()
    })
    
    await keypomV3.deploy(`./out/keypom.wasm`);
    await root.deploy(`./__tests__/ext-wasm/linkdrop.wasm`);

    const nftContract1 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    await nftContract1.call(nftContract1, 'new_default_meta', { owner_id: nftContract1});

    // const nftContract2 = await root.devDeploy(`./__tests__/ext-wasm/nft-tutorial.wasm`);
    // await nftContract2.call(nftContract2, 'new_default_meta', { owner_id: nftContract2});
    
    await root.call(root, 'new', {});
    await keypomV3.call(keypomV3, 'new', { root_account: root.accountId, owner_id: keypomV3.accountId, contract_metadata: {version: "3.0.0", link: "hello"} });

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    await functionCall({
        signer: ali,
        receiver: keypomV3,
        methodName: 'add_to_balance',
        args: {},
        attachedDeposit: NEAR.parse("10").toString(),
        shouldLog: false
    })
    
    // Save state for test runs
    t.context.worker = worker;
    // t.context.accounts = { root, funder, keypomV3, ali };
    t.context.accounts = { root, funder, nftContract1, keypomV3, ali };

    // ftContract1, ftContract2
    t.context.rpcPort = rpcPort;
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

// Withdraw multiple NFTs from the same asset both by specifying token IDs & using limit flag (both none & some).

// Ensure if panic, 
//      Everything in batch is reverted even correct transfers
//      Net state added is zero and no user balance is incremented
//      Tokens are correctly added back in the order they were removed
//      False is returned from function

// Ensure if no panic:
//      Tokens correctly transferred
//      Internal NFT data updated correctly
//      State cleared properly
//      Refund to user balance (claim logic + transfer + callback logic gas)
//      True is returned from function

test('Withdraw - No Panic', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;
    
    let initialBal = await keypomV3.balance();

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    let numNFTs = 12
    const nftAsset1: ExtNFTData = {
        nft_contract_id: nftContract1.accountId
    }

    const asset_data_per_use = [
        {
            assets: [nftAsset1],
            uses: 1
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    // ******************* Adding Assets *******************
    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let token_ids: string[] = []
    for(let i = 0; i < numNFTs; i++){
        let token_id = `NFT-TOKEN-NUMBER-${i+1}`

        await functionCall({
            signer: funder,
            receiver: nftContract1,
            methodName: 'nft_mint',
            args: {
                token_id,
                metadata: {
                    title: "my token",
                    description: 'Coming off a maiden victory at the Sahlen Six Hours of the Glen, the BMW Team RLL squad looks to repeat at Canadian Tire Motorsports following a disappointing qualifying. - Shot On: Nikon 55-200 f4-5.6',
                    media: 'https://ipfs.near.social/ipfs/bafybeig4hirpwvr2suakpwhikwfs4f2tjd5hky233k3fpzfeq6npz72fuy',
                },
                receiver_id: funder.accountId
            },
            attachedDeposit: NEAR.parse("0.01").toString(),
            shouldLog: true
        })
    
        await functionCall({
            signer: funder,
            receiver: nftContract1,
            methodName: 'nft_transfer_call',
            args: {
                receiver_id: keypomV3.accountId,
                token_id,
                msg: dropId
            },
            attachedDeposit: "1"
        })

        token_ids.push(token_id)
    }

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    t.is(balChange > "0", true)

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids
        }],
    })

    let bal1: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    
    // Withdraw last 3 tokens by Token ID
    let withdrawResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "withdraw_nft_tokens",
        args: {
            drop_id: dropId,
            nft_contract_id: nftContract1.accountId,
            token_ids: token_ids.slice(9, 12)

        }
    }) 
    t.is(withdrawResponse == "true", true)

    // Ensure token transfer succeeded
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids: token_ids.slice(0, 9)
        }],
    })

    let bal2: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal2) - BigInt(bal1)).toString(), 5) > "0", true)

    console.log("Withdrawing by Limit")
    // Withdraw last 3 tokens by Limit
    withdrawResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "withdraw_nft_tokens",
        args: {
            drop_id: dropId,
            nft_contract_id: nftContract1.accountId,
            limit: 3

        }
    }) 
    t.is(withdrawResponse == "true", true)

    // Ensure token transfer succeeded
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids: token_ids.slice(0, 6)
        }],
    })

    let bal3: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal3) - BigInt(bal2)).toString(), 5) > "0", true)

    console.log("Withdrawing with nothing specified")
    // Withdraw last 3 tokens by Limit
    withdrawResponse = await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: "withdraw_nft_tokens",
        args: {
            drop_id: dropId,
            nft_contract_id: nftContract1.accountId,
        }
    }) 
    t.is(withdrawResponse == "true", true)

    // Ensure token transfer succeeded
    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids: []
        }],
    })

    let bal4: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal4) - BigInt(bal3)).toString(), 5) > "0", true)
});

test('Withdraw - Panic', async t => {
    const {funder, keypomV3, root, ftContract1, ftContract2,  nftContract1, ali} = t.context.accounts;

    const dropId = "my-drop-id";
    const numKeys = 2;
    let keyPairs = await generateKeyPairs(numKeys);

    // ******************* Creating Drop *******************
    let numNFTs = 4
    const nftAsset1: ExtNFTData = {
        nft_contract_id: nftContract1.accountId
    }

    const asset_data_per_use = [
        {
            assets: [nftAsset1],
            uses: 1
        },
    ]

    await functionCall({
        signer: funder,
        receiver: keypomV3,
        methodName: 'create_drop',
        args: {
            drop_id: dropId,
            asset_data: asset_data_per_use,
            key_data: [{
                public_key: keyPairs.publicKeys[0],
            }],
        },
    }) 

    // ******************* Adding Assets (DO NOT EXIST, WILL PANIC ON WITHDRAW) *******************
    let preSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let token_ids: string[] = []
    for(let i = 0; i < numNFTs; i++){
        let token_id = `NFT-TOKEN-NUMBER-${i+1}`

        await functionCall({
            signer: nftContract1,
            receiver: keypomV3,
            methodName: 'nft_on_transfer',
            args: {
                token_id,
                sender_id: funder.accountId,
                msg: dropId
            },
        })

        token_ids.push(token_id)
    }

    let postSendBal: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    let balChange = formatNearAmount((BigInt(preSendBal) - BigInt(postSendBal)).toString(), 5);
    console.log(balChange)
    t.is(balChange > "0", true)

    await assertKeypomInternalAssets({
        keypom: keypomV3,
        dropId,
        expectedNftData: [{
            contract_id: nftContract1.accountId,
            token_ids
        }],
    })

    let initialBal = await keypomV3.balance();
    let bal1: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})

    console.log("Withdrawing Last 2 Tokens by Limit")
    // Withdraw last 2 tokens by Limit
    try{
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "withdraw_nft_tokens",
            args: {
                drop_id: dropId,
                nft_contract_id: nftContract1.accountId,
                limit: 2
    
            }
        }) 
    }catch{
        // Ensure token transfer succeeded
        await assertKeypomInternalAssets({
            keypom: keypomV3,
            dropId,
            expectedNftData: [{
                contract_id: nftContract1.accountId,
                token_ids
            }],
        })
    }

    let bal2: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal2) - BigInt(bal1)).toString(), 5) == "0", true) 

    console.log("Withdrawing with nothing specified")
    // Withdraw last 3 tokens by Limit
    try{
        await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "withdraw_nft_tokens",
            args: {
                drop_id: dropId,
                nft_contract_id: nftContract1.accountId,
            }
        }) 
    }catch{
         // Ensure token transfer succeeded
        await assertKeypomInternalAssets({
            keypom: keypomV3,
            dropId,
            expectedNftData: [{
                contract_id: nftContract1.accountId,
                token_ids
            }],
        })
    }   
    
    let bal3: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal3) - BigInt(bal2)).toString(), 5) == "0", true)

    console.log("Withdrawing by TokenId")
    try{
        let withdrawResponse = await functionCall({
            signer: funder,
            receiver: keypomV3,
            methodName: "withdraw_nft_tokens",
            args: {
                drop_id: dropId,
                nft_contract_id: nftContract1.accountId,
                token_ids: token_ids.slice(1, 3)
    
            }
        }) 
        t.fail()
    }catch{
        // Will re-insert token 2 and 3 to back --> EXPECTED
        await assertKeypomInternalAssets({
            keypom: keypomV3,
            dropId,
            expectedNftData: [{
                contract_id: nftContract1.accountId,
                token_ids: [token_ids[0], token_ids[3], token_ids[1], token_ids[2]]
            }],
        })
    }

    let bal4: number = await keypomV3.view('get_user_balance', {account_id: funder.accountId})
    t.is(formatNearAmount((BigInt(bal4) - BigInt(bal3)).toString(), 5) == "0", true)

    let finallBal = await keypomV3.balance();
    t.deepEqual(finallBal.stateStaked, initialBal.stateStaked)
});

'''
'''--- assets/CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project maintainer using any of the private contact addresses. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4, available at <https://www.contributor-covenant.org/version/1/4/code-of-conduct.html>

For answers to common questions about this code of conduct, see <https://www.contributor-covenant.org/faq>

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./out
cp target/wasm32-unknown-unknown/release/*.wasm ./out

'''
'''--- contract/Cargo.toml ---
[package]
name = "keypom"
version = "3.0.0"
authors = ["Ben Kurrek <bkurrek@uwaterloo.ca>, Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.1.1"
serde_json = "1.0.91"
hex = "0.4.3"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contract/src/assets/ft_asset/ft_balances.rs ---
use crate::*;

impl InternalFTData {
    /// Add to the available balance. This should only ever be invoked in:
    /// * `ft_on_transfer` (when the transfer is successful).
    /// * `ft_resolve_refund` (when the refund failed).
    /// * `on_assets_claimed` (when the FT claim failed and we need to refund).
    pub fn add_to_balance_avail(&mut self, amount: &Balance) {
        self.balance_avail += amount;
    }
}

#[near_bindgen]
impl Keypom {
    /// Standard function for accepting FTs to then be claimable as part of linkdrops.
    pub fn ft_on_transfer(
        &mut self,
        amount: U128,
        msg: DropId,
    ) -> PromiseOrValue<U128> {
        self.assert_no_global_freeze();
        
        let drop_id = msg;
        let asset_id = env::predecessor_account_id();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");

        let mut asset = drop.asset_by_id.get(&asset_id.to_string()).expect("Asset not found");
        // Ensure asset is fungible token and then call the internal function
        if let InternalAsset::ft(ft_data) = &mut asset {
            ft_data.add_to_balance_avail(&amount.0);
            near_sdk::log!("Added {} FTs to drop ID {}. New asset amount: {}", amount.0, drop_id, ft_data.balance_avail);
        };

        drop.asset_by_id.insert(&asset_id.to_string(), &asset);

        self.drop_by_id.insert(&drop_id, &drop);

        PromiseOrValue::Value(U128(0))
    }
}
'''
'''--- contract/src/assets/ft_asset/ft_claims.rs ---
use near_sdk::{Gas, GasWeight, serde_json::json};

use crate::*;

/// Gas needed to execute any logic in the ft claim function
/// 2 TGas + 2 * CCC gas (since there are 2 CCCs)
/// 12 TGas
pub const GAS_FOR_FT_CLAIM_LOGIC: Gas = Gas(9_000_000_000_000);
/// Minimum Gas required to perform a simple transfer of fungible tokens.
/// 5 TGas
pub const MIN_GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000);
/// Minimum Gas required to register a user on the FT contract
/// 5 TGas
pub const MIN_GAS_FOR_STORAGE_DEPOSIT: Gas = Gas(5_000_000_000_000);

impl InternalFTData {
    /// Attempt to transfer FTs to a given address (will cover registration automatically).
    /// If the transfer fails, the FTs will be returned to the available balance
    /// Should *only* be invoked if the available balance is greater than or equal to the transfer amount.
    pub fn claim_ft_asset(&mut self, receiver_id: &AccountId, transfer_amount: &Balance) -> Option<Promise> {
        if !self.enough_balance(&transfer_amount) {
            near_sdk::log!("not enough balance to transfer. Found {} but needed {}. Skipping asset claim.", self.balance_avail, transfer_amount);
            return None;
        }
            
        
        // Decrement the available balance and then invoke the transfer
        self.balance_avail -= transfer_amount;

        // Create a new batch promise to pay storage and transfer FTs to the new account ID
        let mut batch_transfer = Promise::new(self.contract_id.clone());

        // Pay the required storage as outlined in the AccountData. This will run first and then we send the fungible tokens
        // Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call
        batch_transfer = batch_transfer.function_call_weight(
            "storage_deposit".to_string(),
            json!({ "account_id": receiver_id }).to_string().into(),
            self.registration_cost,
            MIN_GAS_FOR_STORAGE_DEPOSIT,
            GasWeight(0),
        );

        // Send the fungible tokens (after the storage attached_deposit is finished since these run sequentially)
        // Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call
        batch_transfer = batch_transfer.function_call_weight(
            "ft_transfer".to_string(),
            json!({ "receiver_id": receiver_id, "amount": transfer_amount.to_string(), "memo": "Keypom FT Tokens" }).to_string().into(),
            1,
            MIN_GAS_FOR_FT_TRANSFER,
            GasWeight(0)
        );

        Some(batch_transfer)
    }
}
'''
'''--- contract/src/assets/ft_asset/ft_refunds.rs ---
use near_sdk::{ext_contract, PromiseResult};

use crate::*;

/// Minimum Gas required to resolve the batch of promises for transferring the FTs and registering the user.
/// 5 TGas
const MIN_GAS_FOR_RESOLVE_REFUND: Gas = Gas(5_000_000_000_000);

/// FT contract
#[ext_contract(ext_ft_contract)]
trait ExtFTContract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[near_bindgen]
impl Keypom {
    /// Allows users to attach fungible tokens to the Linkdrops. Must have storage recorded by this point. You can only attach one set of FTs or NFT at a time.
    pub fn withdraw_ft_balance(
        &mut self,
        drop_id: DropId,
        ft_contract_id: AccountId,
        tokens_to_withdraw: U128
    ) {
        self.assert_no_global_freeze();
        
        // get the drop object
        let mut drop = self.drop_by_id.get(&drop_id).expect("No drop found");
        let funder_id = &drop.funder_id;

        require!(
            funder_id == &env::predecessor_account_id(),
            "Only drop funder can delete keys"
        );

        let mut asset: InternalAsset = drop.asset_by_id.get(&ft_contract_id.to_string()).expect("Asset not found");
        // Ensure asset is fungible token and then call the internal function
        if let InternalAsset::ft(ft_data) = &mut asset {
            ft_data.ft_refund(&drop_id, tokens_to_withdraw.into(), &drop.funder_id);
        };

        drop.asset_by_id.insert(&ft_contract_id.to_string(), &asset);

        self.drop_by_id.insert(&drop_id, &drop);
    }

    #[private]
    pub fn ft_resolve_refund(
        &mut self, 
        drop_id: DropId, 
        asset_id: AssetId,
        tokens_to_transfer: Balance
    ) -> bool {
        let transfer_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));

        // Everything went well so we return true since the keys registered have already been decremented
        // At this point, we should also refund their user balance with the $NEAR from registration
        if transfer_succeeded {
            near_sdk::log!(
                "Successfully refunded {} FTs for drop ID {}",
                tokens_to_transfer,
                drop_id,
            );

            return true;
        }

        near_sdk::log!(
            "Failed to refund {} FTs for drop ID {}",
            tokens_to_transfer,
            drop_id,
        );

        // Transfer failed so we need to increment the uses registered and return false
        let mut drop = self.drop_by_id.get(&drop_id).expect("no drop for ID");
        let mut internal_asset = drop.asset_by_id.get(&asset_id).expect("no asset for ID");
        
        // ensure asset is FT and then increment the tokens to transfer again
        if let InternalAsset::ft(ref mut ft_asset) = internal_asset {
            ft_asset.add_to_balance_avail(&tokens_to_transfer);
            drop.asset_by_id.insert(&asset_id, &internal_asset);
        } else {
            panic!("asset is not FT");
        }

        self.drop_by_id.insert(&drop_id, &drop);

        false
    }
}

impl InternalFTData {
    /// Automatically refund a claim for fungible tokens
    /// This should refund the FTs & any storage deposits.
    pub fn ft_refund(
        &mut self, 
        drop_id: &DropId, 
        tokens_to_transfer: Balance, 
        refund_to: &AccountId
    ) {
        require!(self.enough_balance(&tokens_to_transfer), format!("not enough balance to transfer. Found {} but needed {}", self.balance_avail, tokens_to_transfer));
        
        near_sdk::log!("Refunding {} FTs to {}", tokens_to_transfer, refund_to);

        // Temporarily decrease the available balance
        // Once the FTs are transferred, we will check whether it failed and refund there
        // Possible re-entrancy attack if we don't do this
        self.balance_avail -= tokens_to_transfer;

        // All FTs can be refunded at once. Funder responsible for registering themselves
        ext_ft_contract::ext(self.contract_id.clone())
        // Call ft transfer with 1 yoctoNEAR. 1/2 unspent GAS will be added on top
        .with_attached_deposit(1)
        .with_static_gas(MIN_GAS_FOR_FT_TRANSFER)
        .ft_transfer(
            refund_to.clone(),
            U128(tokens_to_transfer),
            Some("Keypom Refund".to_string()),
        )
        // We then resolve the promise and call ft_resolve_refund on our own contract
        .then(
            // Call resolve refund with the min GAS and no attached_deposit. 1/2 unspent GAS will be added on top
            Keypom::ext(env::current_account_id())
                .with_static_gas(MIN_GAS_FOR_RESOLVE_REFUND)
                .ft_resolve_refund(
                    drop_id.to_string(), 
                    self.contract_id.to_string(),
                    tokens_to_transfer
                )
        )
        .as_return();                           
    }
}
'''
'''--- contract/src/assets/ft_asset/internal_ft_core.rs ---
use crate::*;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault, Clone)]
pub struct InternalFTData {
    /// Account ID of the token contract
    pub contract_id: AccountId,
    /// Number of tokens that are available for transfer.
    /// To make tokens available for transfer, you must send them via `ft_transfer_call`.
    pub balance_avail: Balance,
    /// How much it costs to register a new user on the FT contract
    pub registration_cost: Balance
}

// Implement a custom serialization that converts both `balance_avail` and `registration_cost` to a `U128` for the frontend
impl Serialize for InternalFTData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
    {
        let mut state = serializer.serialize_struct("InternalFTData", 3)?;
        state.serialize_field("contract_id", &self.contract_id)?;
        state.serialize_field("balance_avail", &U128(self.balance_avail))?;
        state.serialize_field("registration_cost", &U128(self.registration_cost))?;
        state.end()
    }
}

impl InternalFTData {
    /// Initialize a new set of FT data. The available balance is initialize to 0 at the start
    pub fn new(contract_id: AccountId, registration_cost: Balance) -> Self {
        Self {
            contract_id,
            balance_avail: 0,
            registration_cost
        }
    }

    /// Query whether or not enough fungible tokens have been deposited to cover the claim
    pub fn enough_balance(&self, amount: &Balance) -> bool {
        &self.balance_avail >= amount
    }

    /// Get the asset ID for this asset. In the case of Fungible Tokens, the ID is the contract
    pub fn get_asset_id(&self) -> AssetId {
        self.contract_id.to_string()
    }

    /// Query how much gas is required for a single claim
    pub fn get_required_asset_gas(&self) -> Gas {
        MIN_GAS_FOR_FT_TRANSFER + MIN_GAS_FOR_STORAGE_DEPOSIT
    }

    /// Query how much gas is required for a single claim
    pub fn get_total_required_gas(&self) -> Gas {
        GAS_FOR_FT_CLAIM_LOGIC + MIN_GAS_FOR_FT_TRANSFER + MIN_GAS_FOR_STORAGE_DEPOSIT
    }
}
'''
'''--- contract/src/assets/ft_asset/mod.rs ---
pub mod internal_ft_core;
pub mod ft_claims;
pub mod ft_balances;
pub mod ft_refunds;

pub use internal_ft_core::*;
pub use ft_claims::*;

'''
'''--- contract/src/assets/function_call/fc_claims.rs ---
use crate::*;

/// Which methods are prohibited from being called by an FC drop
pub const DEFAULT_PROHIBITED_FC_METHODS: [&str; 6] = [
    "nft_transfer",
    "nft_transfer_call",
    "nft_approve",
    "nft_transfer_payout",
    "ft_transfer",
    "ft_transfer_call",
];

/// Gas needed to execute any logic in the fc claim function
/// 2 TGas
pub const GAS_FOR_FC_CLAIM_LOGIC: Gas = Gas(2_000_000_000_000);
/// For every length of the args, add this much gas
pub const GAS_PER_ARG_LENGTH: Gas = Gas(200_000_000);

impl FCData {
    /// Loop through each method and create a promise to call the method
    /// Each of these methods will be executed 1 after the next.
    /// If anything goes wrong, there's nothing the contract will do to refund.
    pub fn claim_fc_asset(
        &mut self,
        mut fc_args: AssetSpecificFCArgs,
        account_id: AccountId,
        drop_id: DropId,
        key_id: String,
        funder_id: AccountId
    ) -> Option<Promise> {  
        let mut promises = Vec::new();
        let num_fc_args = fc_args.as_ref().and_then(|a| Some(a.len())).unwrap_or(self.methods.len());
        if num_fc_args != self.methods.len() {
            near_sdk::log!("User provided FC args does not match methods length. Found {} Expected {} Skipping all FC args.", num_fc_args, self.methods.len());
            fc_args = None;
        }

        for (idx, method) in self.methods.iter().enumerate() {
            let mut actual_args = method.args.clone();
            if actual_args.len() == 0 {
                actual_args = "{}".to_string();
            }
            
            match handle_fc_args(
                &mut actual_args, 
                method.keypom_args.clone(), 
                &method.user_args_rule, 
                &fc_args, 
                &account_id, 
                &drop_id, 
                &key_id, 
                &funder_id, 
                idx
            ) {
                Ok(_) => {},
                Err(e) => {
                    near_sdk::log!("Error handling FC args: {:?}", e);
                    continue;
                }
            }

            let receiver_id = match determine_receiver_id(
                &method.receiver_to_claimer,
                &method.receiver_id,
                &account_id
            ) {
                Ok(receiver_id) => receiver_id,
                Err(e) => {
                    near_sdk::log!("Error determining receiver ID: {:?}", e);
                    continue;
                }
            };
            
            let promise = Promise::new(receiver_id)
                .function_call_weight(
                    method.method_name.clone(), 
                    actual_args.into(), 
                    method.attached_deposit.0,
                    method.attached_gas,
                    GasWeight(1)
                );
            promises.push(promise);
        }

        promises.into_iter().reduce(|a, b| a.then(b))
    }
}
'''
'''--- contract/src/assets/function_call/helpers.rs ---
use serde_json::{Value, from_str, to_string};
use crate::*;
/// b will overwrite a and `a` will be mutated
pub(crate) fn merge_json(a: &mut Value, b: &Value) {
    match (a, b) {
        (&mut Value::Object(ref mut a), &Value::Object(ref b)) => {
            for (k, v) in b {
                merge_json(a.entry(k.clone()).or_insert(Value::Null), v);
            }
        }
        (a, b) => {
            *a = b.clone();
        }
    }
}

/// Removes the first and last character from a string
pub(crate) fn rem_first_and_last_char(value: &mut String) {
    value.pop();
    value.remove(0);
}

pub(crate) fn determine_receiver_id(receiver_to_claimer: &Option<bool>, method_receiver_id: &String, account_id: &AccountId) -> Result<AccountId, String> {
    if receiver_to_claimer.unwrap_or(false) {
        if account_id == &env::current_account_id() {
            return Err("Cannot set receiver to claimer if the account ID is the same as the contract ID".to_string());
        }

        Ok(account_id.clone())
    } else {
        let valid_account: Result<AccountId, _> = method_receiver_id.parse();
        if valid_account.is_err() {
            return Err("Invalid receiver ID".to_string());
        }
        
        Ok(valid_account.unwrap())
    }
}

/// Given the actual args to the function call, and some user defined arguments
/// Set / replace the markers with what the user passed in
pub(crate) fn set_user_markers(
    output_args: &mut String,
    user_arg: &String
) -> Result<(), String> {
    near_sdk::log!("Setting user markers");

    let try_json: Result<Value, _> = from_str(&user_arg);
    if try_json.is_err() {
        return Err("Cannot cast args to JSON. Skipping method.".to_string());
    }
    
    if let Some(obj) = try_json.unwrap().as_object() {
        near_sdk::log!("User marker obj: {:?}", obj);

        for (key, value) in obj {
            if value.is_string() {
                let mut val_to_insert = value.to_string();
                rem_first_and_last_char(&mut val_to_insert);
                let key = format!(":\"{}\"", key.to_uppercase());
                val_to_insert = format!(":\"{}\"", val_to_insert);
                
                near_sdk::log!("(STRING) replacing {:?} with {:?}", key.to_string(), val_to_insert);
                *output_args = output_args.replace(&key.to_string(), &val_to_insert);
            } else if value.is_object() {
                let mut val_to_insert = to_string(&value).unwrap();
                let key = format!(":\"{}\"", key.to_uppercase());
                val_to_insert = format!(":{}", val_to_insert);
                
                near_sdk::log!("(OBJECT) replacing {:?} with {:?}", key.to_string(), val_to_insert);
                *output_args = output_args.replace(&key.to_string(), &val_to_insert);
            }
        }
    }

    Ok(())
}

pub(crate) fn insert_keypom_arg(
    output_args: &mut String,
    optional_field: &Option<String>,
    value: String
) -> Result<(), String> {
    // Add the account ID that claimed the linkdrop as part of the args to the function call in the key specified by the user
    if let Some(field) = optional_field {
        near_sdk::log!(
            "Attempting to add Value {} into {} For Keypom Args.",
            value,
            field
        );
        near_sdk::log!("Args before: {}", output_args);

        if output_args.contains(field) {
            return Err(format!("Keypom field {} present in args already. Skipping method.", field));
        }

        let insert_str = if output_args == "{}" {
            format!("\"{}\":\"{}\"", field, value)
        } else {
            format!(",\"{}\":\"{}\"", field, value)
        };

        output_args.insert_str(
            output_args.len() - 1,
            &insert_str,
        );

        near_sdk::log!("Args after: {}", output_args);
    }

    Ok(())
}

pub(crate) fn handle_user_args_rules (
    output_args: &mut String, 
    user_args_rule: &Option<UserArgsRule>,
    user_args: &Option<Vec<Option<String>>>, 
    idx: usize
) -> Result<(), String> {
    let try_json: Result<Value, _> = from_str(&output_args);
    if try_json.is_err() {
        return Err(format!("Cannot cast args: {:?} to JSON. Returning and decrementing keys", output_args).to_string());
    }

    let mut output_args_json = try_json.unwrap();

    // Check if user provided args is present and fc_args is some
    if let (Some(rule), Some(user_args_str)) = (user_args_rule, user_args.as_ref().and_then(|a| a[idx].clone())) {
        let try_user_json: Result<Value, _> = from_str(&user_args_str);
        if try_user_json.is_ok() {
            let mut user_args_json = try_user_json.unwrap();
            
            match rule {
                UserArgsRule::AllUser => {
                    output_args_json = user_args_json;
                }
                UserArgsRule::FunderPreferred => {
                    // Take the final args string and merge the user args into it and overwrite any duplicate keys
                    merge_json(&mut user_args_json, &output_args_json);
                    output_args_json = user_args_json;
                }
                UserArgsRule::UserPreferred => {
                    // Take the final args string and merge the user args into it and overwrite any duplicate keys
                    merge_json(&mut output_args_json, &user_args_json);
                }
            }
        } else {
            return Err("Cannot cast user provided args to JSON. Returning and decrementing keys".to_string());
        }
    }

    if to_string(&output_args_json).is_err() {
        return Err("Cannot cast final args to JSON. Returning and decrementing keys".to_string());
    }

    *output_args = to_string(&output_args_json).unwrap();
    Ok(())
}

pub fn handle_fc_args(
    output_args: &mut String, 
    keypom_args: Option<KeypomInjectedArgs>,
    user_args_rule: &Option<UserArgsRule>,
    user_args: &Option<Vec<Option<String>>>, 
    account_id: &AccountId,
    drop_id: &DropId,
    key_id: &String,
    funder_id: &AccountId,
    i: usize,
) -> Result<(), String> {
    if output_args.len() <= 4096 {
        handle_user_args_rules(
            output_args, 
            user_args_rule, 
            user_args, 
            i
        )?;
    }

    // Check if user provided args is present and fc_args is some
    if let (Some(rule), Some(user_args_str)) = (user_args_rule, user_args.as_ref().and_then(|a| a[i].clone())) {
        match rule {
            UserArgsRule::UserPreferred => {
                set_user_markers(output_args, &user_args_str)?;
            }
            _ => {
                near_sdk::log!("User args rule is not UserPreferred. Skipping marker logic");
            }
        }
    }

    add_keypom_args(
        output_args,
        keypom_args,
        account_id,
        drop_id,
        key_id,
        funder_id
    )?;

    return Ok(());
}
'''
'''--- contract/src/assets/function_call/internal_fc_core.rs ---
use crate::*;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PanicOnDefault, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FCData {
    pub methods: Vec<MethodData>
}

impl FCData {
    /// Initialize a new instance of function call data.
    /// All checks such as prohibited methods and valid receivers are done here.
    pub fn new(methods: Vec<MethodData>) -> Self {
        require!(methods.len() > 0, "Must have at least 1 method in FC assets");

        for method in methods.iter() {
            // Check if the method is prohibited
            require!(!DEFAULT_PROHIBITED_FC_METHODS.contains(&method.method_name.as_str()), format!("Method {} is prohibited from being called in an FC drop", method.method_name));

            // Check if the receiver is valid
            require!(method.receiver_id != env::current_account_id().to_string(), "Receiver ID cannot be current Keypom contract.");
        }
        
        Self {
            methods
        }
    }

    /// Query how much $NEAR should be refunded for 1 claim
    pub fn get_yocto_refund_amount(&self) -> Balance {
        // Loop through all the methods, tally up their attached deposits and return that
        let mut total_refund = 0;
        for method in self.methods.iter() {
            total_refund += method.attached_deposit.0;
        }

        total_refund
    }

    /// Query how much gas is required for a single claim
    pub fn get_required_asset_gas(&self) -> Gas {
        // Loop through all the methods, tally up their attached gas and then:
        // Total Method Gas + MIN_BASE_GAS_FOR_ONE_CCC * num_methods + GAS_FOR_FC_CLAIM_LOGIC + num_methods + the length of the arguments
        let mut total_gas = Gas(0);
        for method in self.methods.iter() {
            total_gas += method.attached_gas;
            total_gas += MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP + GAS_FOR_FC_CLAIM_LOGIC;
        }

        total_gas
    }

    /// Query how much gas is required for a single claim
    pub fn get_total_required_gas(&self) -> Gas {
        // Loop through all the methods, tally up their attached gas and then:
        // Total Method Gas + MIN_BASE_GAS_FOR_ONE_CCC * num_methods + GAS_FOR_FC_CLAIM_LOGIC + num_methods + the length of the arguments
        let mut total_gas = Gas(0);
        for method in self.methods.iter() {
            let arg_len = method.args.len() as u64;
            total_gas += GAS_PER_ARG_LENGTH * arg_len;
            total_gas += method.attached_gas;
            total_gas += MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP + GAS_FOR_FC_CLAIM_LOGIC;
        }

        total_gas
    }
}
'''
'''--- contract/src/assets/function_call/mod.rs ---
pub mod internal_fc_core;
pub mod fc_claims;
pub mod models;
pub mod helpers;

pub use internal_fc_core::*;
pub use fc_claims::*;
pub use models::*;
pub use helpers::*;
'''
'''--- contract/src/assets/function_call/models.rs ---
use crate::*;

/// Keep track of info for the method_name to be called
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct MethodData {
    /// Contract that will be called
    pub receiver_id: String,
    /// Method to call on receiver_id contract
    pub method_name: String,
    /// Arguments to pass in (stringified JSON)
    pub args: String,
    /// Amount of yoctoNEAR to attach along with the call
    pub attached_deposit: U128,
    /// How much gas to attach to this method call.
    pub attached_gas: Gas,

    /// Keypom Args struct to be sent to external contracts
    pub keypom_args: Option<KeypomInjectedArgs>,
    /// If set to true, the claiming account ID will be the receiver ID of the method call.
    /// Ths receiver must be a valid account and non-malicious (cannot be set to the keypom contract) 
    pub receiver_to_claimer: Option<bool>,
    /// What permissions does the user have when providing custom arguments to the function call?
    /// By default, the user cannot provide any custom arguments
    pub user_args_rule: Option<UserArgsRule>,
}

/// Keypom Args struct to be sent to external contracts
#[derive(Serialize, Deserialize, Debug, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct KeypomInjectedArgs {
    /// Specifies what field the claiming account ID should go in when calling the function
    /// If None, this isn't attached to the args
    pub account_id_field: Option<String>,
    /// Specifies what field the drop ID should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    /// If Some(String), attach drop ID to args. Else, don't attach.
    pub drop_id_field: Option<String>,
    /// Specifies what field the key ID should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    /// If Some(String), attach key ID to args. Else, don't attach.
    pub key_id_field: Option<String>,
    // Specifies what field the funder id should go in when calling the function. To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
    // If Some(string), attach the funder ID to the args. Else, don't attach.
    pub funder_id_field: Option<String>,
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
/// When a user provides arguments for FC drops in `claim` or `create_account_and_claim`, what behaviour is expected?
/// For `AllUser`, any arguments provided by the user will completely overwrite any previous args provided by the drop creator.
/// For `FunderPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator. If there are any duplicate args, the drop funder's arguments will be used.
/// For `UserPreferred`, any arguments provided by the user will be concatenated with the arguments provided by the drop creator, but if there are any duplicate keys, the user's arguments will overwrite the drop funder's.
pub enum UserArgsRule {
    AllUser,
    FunderPreferred,
    UserPreferred
}
'''
'''--- contract/src/assets/mod.rs ---
pub mod ft_asset;
pub mod nft_asset;
pub mod function_call;

pub use ft_asset::*;
pub use function_call::*;
pub use nft_asset::*;
'''
'''--- contract/src/assets/nft_asset/internal_nft_core.rs ---
use crate::*;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault, Debug, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct InternalNFTData {
    /// Account ID of the token contract
    pub contract_id: AccountId,
    /// Token IDs that are available to be claimed and have been sent via `nft_transfer_call`
    pub token_ids: Vec<TokenId>
}

impl InternalNFTData {
    /// Initialize a new set of FT data. The available balance is initialize to 0 at the start
    pub fn new(contract_id: AccountId) -> Self {
        Self {
            contract_id,
            token_ids: vec![]
        }
    }

    /// Query whether or not there is at least 1 NFT to transfer
    pub fn is_empty(&self) -> bool {
        self.token_ids.is_empty()
    }

    /// Get the asset ID for this asset. In the case of Non Fungible Tokens, the ID is the contract
    pub fn get_asset_id(&self) -> AssetId {
        self.contract_id.to_string()
    }

    /// Query whether or not there is at least 1 NFT to transfer
    pub fn get_next_token_id(&self) -> Option<TokenId> {
        self.token_ids.last().cloned()
    }

    /// Query how much gas is required for a single claim
    pub fn get_required_asset_gas(&self) -> Gas {
        GAS_FOR_NFT_CLAIM_LOGIC + MIN_GAS_FOR_NFT_TRANSFER
    }

    /// Query how much gas is required for a single claim
    pub fn get_total_required_gas(&self) -> Gas {
        GAS_FOR_NFT_CLAIM_LOGIC + MIN_GAS_FOR_NFT_TRANSFER + MIN_GAS_FOR_NFT_CALLBACK_LOGIC
    }
}
'''
'''--- contract/src/assets/nft_asset/mod.rs ---
pub mod internal_nft_core;
pub mod nft_claims;
pub mod nft_balances;
pub mod nft_refunds;

pub use internal_nft_core::*;
pub use nft_claims::*;

'''
'''--- contract/src/assets/nft_asset/nft_balances.rs ---
use crate::*;

impl InternalNFTData {
    /// Add to the list of available token IDs that can be claimed. 
    /// This should only ever be invoked in:
    /// * `nft_on_transfer` (when the transfer is successful).
    /// * `nft_resolve_refund` (when the refund failed).
    /// * `on_assets_claimed` (when the NFT claim failed and we need to refund).
    pub fn add_to_token_ids(&mut self, token_id: &TokenId) {
        self.token_ids.push(token_id.clone());
    }
}

#[near_bindgen]
impl Keypom {
    /// Standard function for accepting NFTs to then be claimable as part of linkdrops.
    pub fn nft_on_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        msg: DropId,
    ) -> PromiseOrValue<bool> {
        self.assert_no_global_freeze();
        
        let initial_storage = env::storage_usage();
        let drop_id = msg;
        let asset_id = env::predecessor_account_id();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");

        // For NFTs, we should assert here so there's not a malicious attack where someone sends really long NFTs
        // and then the funder has to pay for the storage.
        require!(drop.funder_id == sender_id, "Only the funder can add NFTs to the drop");

        let mut asset: InternalAsset = drop.asset_by_id.get(&asset_id.to_string()).expect("Asset not found");
        // Ensure asset is an NFT and then call the internal function
        if let InternalAsset::nft(nft_data) = &mut asset {
            nft_data.add_to_token_ids(&token_id);
            near_sdk::log!("Added Token ID: {} to drop ID {}. There are now {} NFTs available for claim", token_id, drop_id, nft_data.token_ids.len() as u32);
        };

        drop.asset_by_id.insert(&asset_id.to_string(), &asset);

        self.drop_by_id.insert(&drop_id, &drop);

        // Charge the user for storing the token IDs
        let final_storage = env::storage_usage();
        let total_cost = (final_storage - initial_storage) as u128 * env::storage_byte_cost();
        self.internal_modify_user_balance(&drop.funder_id, total_cost as u128, true);

        PromiseOrValue::Value(false)
    }
}
'''
'''--- contract/src/assets/nft_asset/nft_claims.rs ---
use crate::*;

/// Gas needed to execute any logic in the nft claim function
/// 2 TGas + 1 * CCC gas (since there is 1 CCCs)
/// 7 TGas
pub const GAS_FOR_NFT_CLAIM_LOGIC: Gas = Gas(2_000_000_000_000 + MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP.0);
/// Minimum Gas required to perform a simple NFT transfer.
/// 4 TGas
pub const MIN_GAS_FOR_NFT_TRANSFER: Gas = Gas(4_000_000_000_000);
/// Minimum Gas required to execute any callback logic after the claim is complete
/// 2 TGas
pub const MIN_GAS_FOR_NFT_CALLBACK_LOGIC: Gas = Gas(2_000_000_000_000);

impl InternalNFTData {
    /// Attempt to transfer FTs to a given address (will cover registration automatically).
    /// If the transfer fails, the FTs will be returned to the available balance
    /// Should *only* be invoked if the available balance is greater than or equal to the transfer amount.
    pub fn claim_nft_asset(&mut self, receiver_id: &AccountId) -> Option<Promise> {
        if self.is_empty() {
            near_sdk::log!("No NFTs available to transfer. Skipping asset claim.");
            return None;
        }
        
        // Pop the last NFT from the available NFTs
        let token_to_transfer = self.token_ids.pop().unwrap();

        // Create a new promise to transfer the NFT to the new account ID
        let transfer_promise = Promise::new(self.contract_id.clone())
            .function_call_weight(
                "nft_transfer".to_string(),
                json!({ "receiver_id": receiver_id, "token_id": token_to_transfer, "memo": "Keypom Linkdrop" }).to_string().into(),
                1,
                MIN_GAS_FOR_NFT_TRANSFER,
                GasWeight(1),
            );

        Some(transfer_promise)
    }
}
'''
'''--- contract/src/assets/nft_asset/nft_refunds.rs ---
use near_sdk::{PromiseResult, serde_json::json, GasWeight};

use crate::*;

/// Minimum Gas required to resolve the refund's batch of transfer promises
/// 5 TGas
const MIN_GAS_FOR_RESOLVE_REFUND: Gas = Gas(5_000_000_000_000);

#[near_bindgen]
impl Keypom {
    /// Allows users to withdraw their token IDs from the drop
    /// Returns a boolean indicating whether or not the transfer succeeded
    pub fn withdraw_nft_tokens(
        &mut self,
        drop_id: DropId,
        nft_contract_id: AccountId,
        token_ids: Option<Vec<TokenId>>,
        limit: Option<u8>
    ) -> Promise {
        self.assert_no_global_freeze();
        
        // get the drop object
        let mut drop = self.drop_by_id.get(&drop_id).expect("No drop found");
        let funder_id = &drop.funder_id;

        require!(
            funder_id == &env::predecessor_account_id(),
            "Only drop funder can delete keys"
        );

        let mut asset: InternalAsset = drop.asset_by_id.get(&nft_contract_id.to_string()).expect("Asset not found");
        
        let initial_storage = env::storage_usage();
        let mut batch_transfer = Promise::new(env::current_account_id());
        let mut tokens_to_transfer = vec![];

        // Ensure asset is an NFT and then call the internal function
        if let InternalAsset::nft(nft_data) = &mut asset {
            // If token IDs were specified, use those. Otherwise, pop the first `limit` entries off the internal vector
            tokens_to_transfer = if let Some(token_ids) = token_ids {
                token_ids
            } else {
                let mut token_ids = vec![];
                let limit = limit.unwrap_or(nft_data.token_ids.len() as u8);
                // The number of tokens to transfer is either what was specified or the length of the vector
                let max_idx = nft_data.token_ids.len() - 1;
                for idx in 0..limit {
                    if let Some(token_id) = nft_data.token_ids.get(max_idx - idx as usize) {
                        token_ids.push(token_id.to_string());
                    } else {
                        break;
                    }
                }

                token_ids.into_iter().rev().collect()
            };

            batch_transfer = nft_data.nft_refund(
                &drop.funder_id, 
                tokens_to_transfer.clone()
            );
        };
        
        drop.asset_by_id.insert(&nft_contract_id.to_string(), &asset);
        self.drop_by_id.insert(&drop_id, &drop);

        near_sdk::log!("Tokens to transfer: {:?}", tokens_to_transfer);
        
        let net_storage_released = initial_storage - env::storage_usage();    
        // We then resolve the batch and call nft_resolve_refund on our own contract
        batch_transfer.then(
            // Call resolve refund with the min GAS and no attached_deposit. 1/2 unspent GAS will be added on top
            Keypom::ext(env::current_account_id())
                .with_static_gas(MIN_GAS_FOR_RESOLVE_REFUND)
                .resolve_nft_refund(
                    drop_id.to_string(), 
                    nft_contract_id.to_string(), 
                    drop.funder_id,
                    tokens_to_transfer.to_vec(),
                    net_storage_released.into()
                )
        )
    }

    #[private]
    pub fn resolve_nft_refund(
        &mut self, 
        drop_id: DropId, 
        asset_id: AssetId, 
        refund_to: AccountId,
        token_ids: Vec<TokenId>,
        storage_released: u128
    ) -> PromiseOrValue<bool> {
        // There will only ever be 1 promise because it was a batch
        let promise_result = env::promise_result(0);

        let initial_storage = env::storage_usage();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let mut asset: InternalAsset = drop.asset_by_id.get(&asset_id).expect("Asset not found");

        let mut was_successful = true;
        match promise_result {
            PromiseResult::NotReady => return PromiseOrValue::Promise(
                Self::ext(env::current_account_id())
                    .resolve_nft_refund(
                        drop_id,
                        asset_id,
                        refund_to,
                        token_ids,
                        storage_released
                    )
            ),
            PromiseResult::Successful(_) => {
                near_sdk::log!("Refund successful.");
            },
            PromiseResult::Failed => {
                was_successful = false;
                // Ensure asset is an NFT and then add the token back to the internal vector 
                if let InternalAsset::nft(nft_data) = &mut asset {
                    near_sdk::log!("Refund failed. Adding all tokens back: {:?}", token_ids);
                    // Loop through each token and add them
                    for token_id in token_ids {
                        nft_data.add_to_token_ids(&token_id);
                    };
                };
            }

        }

        // If a transfer failed, we should re-insert the asset into storage
        // Since tokens have been set
        if !was_successful {
            drop.asset_by_id.insert(&asset_id, &asset);
            self.drop_by_id.insert(&drop_id, &drop);
        }

        // Measure the final storage now that tokens have been added back to the vector
        // We'll then take the storage that was released and subtract this new storage that was added
        let net_storage_added = env::storage_usage() - initial_storage;
        let total_refund = storage_released.checked_sub(net_storage_added as u128).unwrap_or(0);
        near_sdk::log!("Net storage added in refund: {} bytes. Net storage released: {} bytes.", net_storage_added, storage_released);

        // Refund the storage to the user
        self.internal_modify_user_balance(&drop.funder_id, total_refund * env::storage_byte_cost(), false);

        PromiseOrValue::Value(was_successful)
    }
}

impl InternalNFTData {
    /// Automatically refund a claim for fungible tokens
    /// This should refund the FTs & any storage deposits.
    pub fn nft_refund(
        &mut self,
        refund_to: &AccountId,
        token_ids: Vec<TokenId>
    ) -> Promise {
        // Create the batch promise on the NFT contract
        let mut batch_promise = Promise::new(self.contract_id.clone());

        // Loop through all the token IDs, and add to the batch promise while removing them from the vector
        for token_id in token_ids.clone() {
            let index = self.token_ids.iter().position(|x| *x == token_id).expect("token ID not found");
            near_sdk::log!("Refunding token ID {}. Idx: {} vec: {:?}", token_id, index, self.token_ids);
            self.token_ids.remove(index);

            batch_promise = batch_promise
            .function_call_weight(
                "nft_transfer".to_string(),
                json!({ "receiver_id": refund_to, "token_id": token_id, "memo": "Keypom Linkdrop" }).to_string().into(),
                1,
                MIN_GAS_FOR_NFT_TRANSFER,
                GasWeight(1),
            );
        }

        batch_promise                      
    }
}
'''
'''--- contract/src/drop_claiming/claim_callbacks.rs ---
use near_sdk::PromiseResult;

use crate::*;

#[near_bindgen]
impl Keypom {
    #[private]
    pub fn on_new_account_created(&mut self, token_id: TokenId, receiver_id: AccountId, fc_args: UserProvidedFCArgs, new_public_key: PublicKey) -> PromiseOrValue<bool> {
        let successful_creation = was_account_created();

        // If the account was successfully created, we should claim the assets
        // Otherwise, we should loop through all the assets in the current use and refund the tokens
        if successful_creation {
            return self.internal_claim_assets(token_id, receiver_id, fc_args, Some(new_public_key));
        }

        let initial_storage = env::storage_usage();
        let (drop_id, _) = parse_token_id(&token_id).unwrap();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key not found");
        // The uses were decremented before the account creation, so we need to increment them back to get what use should be refunded
        let cur_key_use = get_key_cur_use(&drop, &key_info) - 1;
        let InternalAssetDataForUses { uses: _, config: _, assets_metadata, required_asset_gas: _ } = get_asset_data_for_specific_use(&drop.asset_data_for_uses, &cur_key_use);

        for metadata in assets_metadata {
            let amount_to_increment = drop.asset_by_id.get(&metadata.asset_id).expect("Asset not found").get_yocto_refund_amount(&metadata.tokens_per_use.map(|t| t.into()));
            self.internal_modify_user_balance(&drop.funder_id, amount_to_increment, false);
        }

        // Loop through all the assets in the drop and ensure they're empty
        let mut is_drop_empty = true;
        for asset in drop.asset_by_id.values() {
            if !asset.is_empty() {
                is_drop_empty = false;
                break;
            }
        }

        // If the key no longer has uses, it should be removed from the drop.
        // In addition, if the drop has no keys and no more refundable assets, it should be removed from storage
        self.handle_key_cleanup(
            &mut drop,
            &key_info,
            &token_id,
            &drop_id,
            is_drop_empty,
            initial_storage
        );
        
        PromiseOrValue::Value(false)
    }

    #[private]
    pub fn on_assets_claimed(
        &mut self, 
        token_id: TokenId,
        token_ids_transferred: Vec<Option<TokenId>>
    ) -> PromiseOrValue<bool> {
        let num_promises = env::promise_results_count();

        let initial_storage = env::storage_usage();
        let (drop_id, _) = parse_token_id(&token_id).unwrap();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key not found");
        // The uses were decremented before the claim, so we need to increment them back to get what use should be refunded
        let cur_key_use = get_key_cur_use(&drop, &key_info) - 1;
        let InternalAssetDataForUses { uses: _, config: _, assets_metadata, required_asset_gas: _ } = get_asset_data_for_specific_use(&drop.asset_data_for_uses, &cur_key_use);
        
        // Iterate through all the promises and get the results
        let mut was_successful = true;
        let mut drop_assets_empty = true;
        for i in 0..num_promises {
            let promise_result = env::promise_result(i);
            let metadata = &assets_metadata[i as usize];
            
            match promise_result {
                PromiseResult::NotReady => return PromiseOrValue::Promise(
                    Self::ext(env::current_account_id())
                        .on_assets_claimed(
                            token_id,
                            token_ids_transferred
                        )
                ),
                PromiseResult::Successful(_) => {
                    if is_fc_asset_id(&metadata.asset_id) {
                        near_sdk::log!("FC asset claimed");
                        continue;
                    }

                    let asset: InternalAsset = drop.asset_by_id.get(&metadata.asset_id).expect("Asset not found");  
                    if !asset.is_empty() {
                        drop_assets_empty = false;
                    }
                },
                PromiseResult::Failed => {
                    was_successful = false;
                    near_sdk::log!("Asset claim failed");
                    // If we're dealing with an FC asset, no need to perform any refunds
                    if is_fc_asset_id(&metadata.asset_id) {
                        near_sdk::log!("FC asset claimed");
                        continue;
                    }
                    
                    let mut asset: InternalAsset = drop.asset_by_id.get(&metadata.asset_id).expect("Asset not found");  
                    let mut tokens_per_use = metadata.tokens_per_use.map(|x| x.0.to_string());
                    
                    // If it's a NFT, we need to get the token ID
                    if let InternalAsset::nft(_) = &mut asset {
                        tokens_per_use = token_ids_transferred[i as usize].clone();
                    };

                    let amount_to_increment = asset.on_failed_claim(&tokens_per_use);
                    self.internal_modify_user_balance(&drop.funder_id, amount_to_increment, false);
                    // Re-insert into storage
                    drop.asset_by_id.insert(&metadata.asset_id, &asset); 
                    if !asset.is_empty() {
                        drop_assets_empty = false;
                    }
                }

            }
        }

        // Potential error -> because we only re-insert the drop at the end of the loop, what happens
        // If the promise result is not ready? Do we lose all the modifications that we made to the drop?
        self.drop_by_id.insert(&drop_id, &drop);

        // If the key no longer has uses, it should be removed from the drop.
        // In addition, if the drop has no keys and no more refundable assets, it should be removed from storage
        self.handle_key_cleanup(
            &mut drop,
            &key_info,
            &token_id,
            &drop_id,
            drop_assets_empty,
            initial_storage
        );

        PromiseOrValue::Value(was_successful)
    }
}
'''
'''--- contract/src/drop_claiming/claims.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    #[private]
    pub fn claim(&mut self, account_id: AccountId, fc_args: UserProvidedFCArgs, password: Option<String>) -> PromiseOrValue<bool> {
        self.assert_no_global_freeze();

        let mut event_logs: Vec<EventLog> = Vec::new();
        let BeforeClaimData { 
            token_id, 
            required_asset_gas, 
            root_account_id: _, 
            account_creation_keypom_args: _,
            drop_id: _,
            key_id: _,
            funder_id: _ 
        } = self.before_claim_logic(
            &mut event_logs,
            None,
            password
        );
        let prepaid_gas = env::prepaid_gas();
        let total_required_gas = BASE_GAS_FOR_CLAIM + required_asset_gas;
        // Use to check prepaid == required. Changed to >= for the sake of simplicity for now
        // Future plan to implement required_gas_for_claim and required_gas_for_create_account_and_claim into key info
        require!(
            prepaid_gas >= total_required_gas,
            format!("Not enough gas attached. Required: {}, Prepaid: {}",
            total_required_gas.0,
            prepaid_gas.0)
        );

        log_events(event_logs);
        self.internal_claim_assets(token_id, account_id, fc_args, None)
    }

    #[private]
    pub fn create_account_and_claim(&mut self, new_account_id: AccountId, new_public_key: PublicKey, fc_args: UserProvidedFCArgs, password: Option<String>) -> Promise {
        self.assert_no_global_freeze();

        let mut event_logs = Vec::new();
        let BeforeClaimData { 
            token_id, 
            required_asset_gas, 
            root_account_id, 
            account_creation_keypom_args,
            drop_id,
            key_id,
            funder_id 
        } = self.before_claim_logic(
            &mut event_logs,
            Some(&new_public_key),
            password
        );

        let prepaid_gas = env::prepaid_gas();
        let total_required_gas = BASE_GAS_FOR_CREATE_ACC_AND_CLAIM + required_asset_gas;
        require!(
            prepaid_gas >= total_required_gas,
            format!("Not enough gas attached. Required: {}, Prepaid: {}",
            total_required_gas.0,
            prepaid_gas.0)
        );
        let gas_for_callback = BASE_GAS_FOR_RESOLVE_ACCOUNT_CREATION + required_asset_gas;
        near_sdk::log!("gas_for_callback: {}", gas_for_callback.0);

        log_events(event_logs);
        near_sdk::log!("Keypom Args Before create_account: {:?}", account_creation_keypom_args);
        let mut create_account_args = json!({
            "new_account_id": new_account_id,
            "new_public_key": new_public_key
        }).to_string();

        add_keypom_args(
            &mut create_account_args,
            account_creation_keypom_args,
            &new_account_id,
            &drop_id,
            &key_id.to_string(),
            &funder_id
        ).expect("Unable to add keypom args");
        
        // First, create the zero-balance account and then, claim the assets
        
        Promise::new(root_account_id)
            .function_call_weight(
                "create_account".to_string(), 
                create_account_args.into(), 
                0,
                GAS_FOR_CREATE_ACCOUNT,
                GasWeight(0)
            ).then(
                // Call resolve refund with the min GAS and no attached_deposit. 1/2 unspent GAS will be added on top
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_for_callback)
                    .with_unused_gas_weight(1)
                    .on_new_account_created(
                        token_id,
                        new_account_id,
                        fc_args,
                        new_public_key
                    )
            )
    }
}
'''
'''--- contract/src/drop_claiming/helpers.rs ---
use near_sdk::{PromiseResult, env::sha256};

use crate::*;

#[near_bindgen]
impl Keypom {
    /// Ensure re-entry protection and decrement remaining uses on a key
    /// Returns the drop ID that the key is associated with
    pub(crate) fn before_claim_logic(
        &mut self, 
        event_logs: &mut Vec<EventLog>, 
        new_public_key: Option<&PublicKey>,
        password: Option<String>
    ) -> BeforeClaimData {
        let signer_pk = env::signer_account_pk();
        

        // Get the key info and decrement its remaining uses.
        // If there are zero remaining uses, break the connection between
        // The public key and token ID that way the key can't be used anymore.
        // This state will be written in the current block so prevents re-entrancy attacks.
        // We shouldn't just remove the public key mapping off the bat because there might be
        // Multi use keys that submit multiple txns in the same block. Only delete if empty.
        let token_id = self
            .token_id_by_pk
            .get(&signer_pk)
            .expect("No drop ID found for PK");
        
        let (drop_id, key_id) = parse_token_id(&token_id).unwrap();
        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let mut key_info = drop.key_info_by_token_id.get(&token_id).expect("Key not found");
        let cur_key_use = get_key_cur_use(&drop, &key_info);
        let InternalAssetDataForUses { uses: _, config: use_config, assets_metadata: _, required_asset_gas } = get_asset_data_for_specific_use(&drop.asset_data_for_uses, &cur_key_use);

        assert_pre_claim_conditions(
            &key_info,
            &use_config,
            &password,
            &cur_key_use,
            &drop.max_key_uses,
            new_public_key.is_some()
        );

        key_info.remaining_uses -= 1;
        key_info.last_claimed = env::block_timestamp();
        if key_info.remaining_uses == 0 {
            // Delete everything except the token ID -> key info mapping since we need the key info in callbacks
            if let Some(owner) = key_info.owner_id.as_ref() {
                self.internal_remove_token_from_owner(owner, &token_id);
            }

            self.token_id_by_pk.remove(&signer_pk);
            Promise::new(env::current_account_id()).delete_key(signer_pk.clone());
            
            event_logs.push(EventLog {
                standard: NFT_STANDARD_NAME.to_string(),
                version: NFT_METADATA_SPEC.to_string(),
                event: EventLogVariant::NftBurn(vec![NftBurnLog {
                    owner_id: key_info.owner_id.as_ref().unwrap_or(&env::current_account_id()).to_string(),
                    token_ids: vec![token_id.to_string()],
                    authorized_id: None,
                    memo: None,
                }]),
            });
            event_logs.push(EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::DeleteKey(vec![AddOrDeleteKeyLog {
                    drop_id: drop_id.to_string(),
                    public_key: (&signer_pk).into()
                }]),
            });
        }

        drop.key_info_by_token_id.insert(&token_id, &key_info);
        self.drop_by_id.insert(&drop_id, &drop);

        let root_account_id = use_config.as_ref().and_then(|c| c.root_account_id.clone()).unwrap_or(self.root_account.clone());
        let account_creation_keypom_args = use_config.as_ref().and_then(|c| c.account_creation_keypom_args.clone());
        
        BeforeClaimData {
            token_id,
            required_asset_gas,
            root_account_id,
            account_creation_keypom_args,
            key_id,
            drop_id,
            funder_id: drop.funder_id
        }

    }

    /// Internal function that loops through all assets for the given use and claims them.
    /// Should be executed in both `claim` or `create_account_and_claim`
    /// Once all assets are claimed, a cross-contract call is fired to `on_assets_claimed`
    pub(crate) fn internal_claim_assets(
        &mut self, 
        token_id: TokenId, 
        receiver_id: AccountId, 
        fc_args: UserProvidedFCArgs,
        new_public_key: Option<PublicKey>
    ) -> PromiseOrValue<bool> {
        let (drop_id, key_id) = parse_token_id(&token_id).unwrap();

        let mut drop: InternalDrop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key not found");

        // The uses were decremented before the claim, so we need to increment them back to get what use should be refunded
        let cur_key_use = get_key_cur_use(&drop, &key_info) - 1;
        let InternalAssetDataForUses { uses: _, config: _, assets_metadata, required_asset_gas: _ } = get_asset_data_for_specific_use(&drop.asset_data_for_uses, &cur_key_use);

        //let promises;
        let mut promises = Vec::new();
        let mut token_ids_transferred = Vec::new();
        let mut fc_arg_idx = 0;
        let mut assets_to_log = Vec::new();
        for metadata in assets_metadata {
            let mut asset = drop.asset_by_id.get(&metadata.asset_id).expect("Asset not found");

            // For claim events
            assets_to_log.push(asset.to_external_events_asset(&metadata.tokens_per_use));

            // We need to keep track of all the NFT token IDs in order to potentially perform refunds
            if let InternalAsset::nft(data) = &asset {
                token_ids_transferred.push(data.get_next_token_id());
            } else {
                token_ids_transferred.push(None);
            }

            // Try to get the fc args for the asset. If the length of the fc_args outer vector is not the same as the number of FC assets
            // Meaning that the user didn't specify fc args (even as none) for each asset, just default it to None once it gets out of range
            let fc_args_for_asset = fc_args.as_ref().and_then(|a| a.get(fc_arg_idx).cloned()).unwrap_or(None);
            
            // Some cases may result in no promise index (i.e not enough balance)
            promises.push(asset.claim_asset(
                &receiver_id, 
                &metadata.tokens_per_use.map(|x| x.into()),
                fc_args_for_asset,
                drop_id.clone(),
                key_id.to_string(),
                drop.funder_id.clone()
            ));

            // Increment the number of fc args we've seen
            if let InternalAsset::fc(_) = asset {
                fc_arg_idx += 1;
            }
            
            drop.asset_by_id.insert(&metadata.asset_id, &asset);
        }

        // Put the modified drop back in storage
        self.drop_by_id.insert(&drop_id, &drop);

        // Log either CAAC or claim events depending on whether or not a new public key was provided
        let event_log = if let Some(pk) = &new_public_key {
            EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::CreateAccountAndClaim(CreateAccountAndClaimLog { 
                    new_account_id: receiver_id.to_string(), 
                    new_public_key: pk.into(), 
                    public_key: env::signer_account_id().into(), 
                    drop_id, 
                    assets: assets_to_log
                }),
            }
        } else {
            EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::Claim(ClaimLog { 
                    account_id: receiver_id.to_string(), 
                    public_key: env::signer_account_id().into(), 
                    drop_id, 
                    assets: assets_to_log
                }),
            }
        };
        log_events(vec![event_log]);

        if let Some(resolve) = promises.into_iter().reduce(|a, b| a.and(b)).expect("empty promises") {
            PromiseOrValue::Promise(resolve.then(
                Self::ext(env::current_account_id())
                    //.with_static_gas(MIN_GAS_FOR_RESOLVE_ASSET_CLAIM)
                    .with_unused_gas_weight(1)
                    .on_assets_claimed(
                        token_id,
                        token_ids_transferred
                    )
            ))
        } else {
            self.on_assets_claimed(token_id, token_ids_transferred)
        }
    }

    /// Check if key is empty and perform cleanup if it is
    /// This includes removing the drop if it now has 0 keys and no refundable assets
    pub(crate) fn handle_key_cleanup(
        &mut self,
        drop: &mut InternalDrop,
        key_info: &InternalKeyInfo,
        token_id: &TokenId,
        drop_id: &DropId,
        drop_assets_withdrawn: bool,
        initial_storage: u64
    ) {
        let mut event_logs = vec![];
        // Now that the callback is finished, we can remove the key info from the drop
        // Since no other functions need the key information
        if key_info.remaining_uses == 0 {
            drop.key_info_by_token_id.remove(&token_id).expect("Key not found");
    
            let should_delete_on_empty = drop.config.as_ref().and_then(|c| c.delete_empty_drop).unwrap_or(true);

            // Now that we've removed the key info, check if the drop is empty
            // Otherwise, re-insert the drop into state
            if drop.key_info_by_token_id.is_empty() && drop_assets_withdrawn && should_delete_on_empty {
                near_sdk::log!("Drop with ID: {} is now empty. Deleting.", drop_id);
                // Remove the drop from storage and clear the maps inside of it
                self.drop_by_id.remove(&drop_id);
                self.internal_remove_drop_for_funder(&drop.funder_id, &drop_id);
                internal_clear_drop_storage(drop, &mut event_logs, &drop_id);
            } else {
                near_sdk::log!("Drop with ID: {} is not empty. Re-inserting. Does have assets? {} Config specified to delete: {}", drop_id, !drop_assets_withdrawn, should_delete_on_empty);
                // Put the modified drop back in storage
                self.drop_by_id.insert(&drop_id, &drop);
            }
        }
    
        let final_storage = env::storage_usage();
        // Some storage was freed so we should refund the user's balance
        if final_storage < initial_storage {
            let storage_cost = (initial_storage - final_storage) as u128 * env::storage_byte_cost();
            self.internal_modify_user_balance(&drop.funder_id, storage_cost, false);
        }

        log_events(event_logs);
    }
}

/// Returns whether or not the account was successfully created when firing the cross contract call to `create_account`
pub fn was_account_created() -> bool {
    if let PromiseResult::Successful(value) = env::promise_result(0) {
        if let Ok(account_created) = near_sdk::serde_json::from_slice::<bool>(&value) {
            //if we need don't need to return the token, we simply return true meaning everything went fine
            near_sdk::log!("create_account call returned {}", account_created);
            return account_created;
        }
    }

    false
}

/// Internal function to perform all the pre-claim checks such as passwords, configs etc.
pub(crate) fn assert_pre_claim_conditions(
    key_info: &InternalKeyInfo,
    use_config: &Option<UseConfig>,
    user_password: &Option<String>,
    cur_key_use: &UseNumber,
    max_uses_per_key: &UseNumber,
    creating_account: bool
) {
    // Ensure that claim and create_account_and_claim are only called based on the key / drop's config
    if let Some(perm) = use_config.as_ref().and_then(|c| c.permissions.as_ref()) {
        match perm {
            ClaimPermissions::claim => {
                require!(creating_account == false, "Cannot call `create_account_and_claim` when key permission is set to only claim")
            },
            ClaimPermissions::create_account_and_claim => {
                require!(creating_account == true, "Cannot call `claim` when key permission is set to only create_account_and_claim")
            },
        }
    }

    // Ensure any timestamps in the configs have been fulfilled
    assert_claim_timestamps(use_config, key_info, &String::from(&env::signer_account_pk()), max_uses_per_key);

    // If there is some password for the current key use, assert that it matches the one provided
    if let Some(pw_by_use) = &key_info.pw_by_use {
        if let Some(pw) = pw_by_use.get(cur_key_use) {
            assert_key_password(user_password, pw.clone());
        }
    }
}

/// Internal function to assert that the password for claim matches the one in the key info
pub(crate) fn assert_key_password(
    user_password: &Option<String>,
    expected_password: Vec<u8>
) {
    let hashed_user_pw = sha256(&user_password.as_ref().and_then(|f| hex::decode(f).ok()).expect("Password expected."));

    require!(hashed_user_pw == expected_password, format!("User provided password: {:?} does not match expected password: {:?}", hashed_user_pw, expected_password));
}

/// Internal function to assert that the predecessor is the contract owner
pub(crate) fn assert_claim_timestamps(
    use_config: &Option<UseConfig>,
    key_info: &InternalKeyInfo,
    signer_pk: &String,
    max_uses_per_key: &UseNumber,
) {
    let time_config = use_config.as_ref().and_then(|c| c.time.as_ref());
    
    if let Some(time_data) = time_config {
        // Ensure enough time has passed if a start timestamp was specified in the config.
        let current_timestamp = env::block_timestamp();

        let desired_start_timestamp = time_data.start.unwrap_or(0);
        require!(current_timestamp >= desired_start_timestamp, format!("Key {} isn't claimable until {}. Current timestamp {}", signer_pk, desired_start_timestamp, current_timestamp));

        // Ensure the end timestamp hasn't passed and the key is still usable
        let desired_end_timestamp = time_data.end.unwrap_or(u64::MAX);
        require!(current_timestamp <= desired_end_timestamp, format!("Key {} is no longer claimable. It was claimable up until {}. Current timestamp {}", signer_pk, desired_end_timestamp, current_timestamp));

        let throttle = time_data.throttle.unwrap_or(0);
        require!((current_timestamp - key_info.last_claimed) >= throttle, format!("Key {} was used too recently. It must be used every {}. Time since last use {}", signer_pk, throttle, current_timestamp - key_info.last_claimed));

        // Ensure the key is within the claim interval if specified
        if let Some(interval) = time_data.interval {
            let start_timestamp = time_data.start.unwrap();

            // At this moment, what is the maximum number of uses that COULD have been possibly claimed
            let total_possible_claims = (env::block_timestamp() - start_timestamp) / interval;
            
            // How many claims given the interval and remaining uses does this key have left?
            // Take the current total claims possible, and subtract the number of uses the key has left
            // Example: If the interval is 1 day, and 4 days have passed, the key has 4 total claimable uses.
            // If the key has already been claimed 3/4 times, then the key has 1 remaining claimable uses.
            let claims_so_far = max_uses_per_key - key_info.remaining_uses;
            let num_claimable_uses = total_possible_claims - claims_so_far as u64;

            require!(num_claimable_uses > 0, format!("Key {} has been claimed {} times. Given the interval {} and starting timestamp of {}, there are {} claims available.", signer_pk, claims_so_far, interval, start_timestamp, num_claimable_uses));
        }
    }
}
'''
'''--- contract/src/drop_claiming/mod.rs ---
pub mod claims;
pub mod claim_callbacks;
pub mod helpers;

pub use helpers::*;
'''
'''--- contract/src/drop_creation/add_keys.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    #[payable]
    pub fn add_keys(
        &mut self, 
        drop_id: DropId, 
        key_data: Vec<ExtKeyData>,
        // Should any excess attached deposit be deposited to the user's balance?
        keep_excess_deposit: Option<bool>
    ) -> bool {
        self.assert_no_global_freeze();

        // Before anything, measure storage usage so we can net the cost and charge the funder
        let initial_storage = env::storage_usage();
        near_sdk::log!("initial bytes {}", initial_storage);

        // get the drop object (remove it and only re-insert at the end if it shouldn't be deleted)
        let mut drop = self.drop_by_id.get(&drop_id).expect("No drop found");
        
        let funder_id = drop.funder_id.clone();
        let caller_id = env::predecessor_account_id();

        let num_keys_to_add = key_data.len();
        require!(num_keys_to_add > 0 && num_keys_to_add <= 100, "Must provide between 1 and 100 keys at a time");

        // If there is a public sale and the predecessor isn't the funder, perform checks and return revenue
        if let Some(allowlist) = drop.config.as_ref().and_then(|c| c.add_key_allowlist.as_ref()) {
            if funder_id != caller_id {
                require!(
                    allowlist.contains(&caller_id),
                    "caller not on allowlist"
                );
            }
        } else {
            require!(
                funder_id == caller_id,
                "Only funder can add keys to the drop"
            );
        }

        // Parse the external assets and store them in the contract
        let max_key_uses = drop.max_key_uses;

        let mut total_cost_per_key = 0;
        let mut total_allowance_per_key = drop.config.as_ref().and_then(|config| config.extra_allowance_per_key).unwrap_or(U128(0)).0;

        // Get the total cost and allowance required for a key that has all its uses remaining
        // We'll then multiply this by the number of keys we want to add and charge the user
        get_total_costs_for_key(
            &mut total_cost_per_key,
            &mut total_allowance_per_key,
            max_key_uses,
            &drop.asset_by_id,
            &drop.asset_data_for_uses
        );

        // Keep track of all the events
        let mut event_logs = Vec::new();
        // Add the keys to the contract
        self.internal_add_keys_to_account(
            &mut drop.next_key_id,
            &mut drop.key_info_by_token_id,
            &mut event_logs,
            &drop_id,
            max_key_uses,
            &key_data,
            total_allowance_per_key
        );

        // Write the updated drop data to storage
        self.drop_by_id.insert(&drop_id, &drop);

        // Measure final costs
        let net_storage = env::storage_usage() - initial_storage;
        self.determine_costs(
            key_data.len(),
            false, // No drop was created
            total_cost_per_key,
            total_allowance_per_key,
            net_storage,
            keep_excess_deposit
        );

        // Now that everything is done (no more potential for panics), we can log the events
        log_events(event_logs);

        true
    }
}
'''
'''--- contract/src/drop_creation/create_drop.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    #[payable]
    pub fn create_drop(
        &mut self, 
        drop_id: DropId,
        key_data: Vec<ExtKeyData>, 
        asset_data: Vec<ExtAssetDataForUses>,

        drop_config: Option<DropConfig>,
        // Should any excess attached deposit be deposited to the user's balance?
        keep_excess_deposit: Option<bool>
    ) -> bool {
        self.assert_no_global_freeze();
        require!(!drop_id.contains(":"), "Drop ID cannot contain a colon (:)");
        require!(self.drop_by_id.get(&drop_id).is_none(), format!("Drop with ID {} already exists", drop_id));

        // Before anything, measure storage usage so we can net the cost and charge the funder
        let initial_storage = env::storage_usage();
        near_sdk::log!("initial bytes {}", initial_storage);

        // Instantiate the drop data structures
        let mut key_info_by_token_id: UnorderedMap<TokenId, InternalKeyInfo> = UnorderedMap::new(StorageKeys::KeyInfoByPk {
            drop_id_hash: hash_string(&drop_id.to_string()),
        });
        // Since these won't have a ton of data, using standard data structures is fine
        let mut asset_by_id: UnorderedMap<AssetId, InternalAsset> = UnorderedMap::new(StorageKeys::AssetById {
            drop_id_hash: hash_string(&drop_id.to_string()),
        });
        let mut asset_data_for_uses = vec![];

        require!(key_data.len() <= 100, "Cannot add more than 100 keys at a time");

        let mut max_key_uses = 0;
        // Parse the external asset data and convert it into the internal representation
        for ext_asset_data in asset_data {
            // Convert the external asset data into the internal asset data
            asset_data_for_uses.push(InternalAssetDataForUses::from(&ext_asset_data));

            // Take the assets and populate the asset_by_id mapping
            store_assets_by_id(
                &ext_asset_data.assets,
                &mut asset_by_id,
            );

            max_key_uses += ext_asset_data.uses;
        }

        let mut total_cost_per_key = 0;
        let mut total_allowance_per_key = drop_config.as_ref().and_then(|config| config.extra_allowance_per_key).unwrap_or(U128(0)).0;
        // Get the total cost and allowance required for a key that has all its uses remaining
        // We'll then multiply this by the number of keys we want to add and charge the user
        get_total_costs_for_key(
            &mut total_cost_per_key,
            &mut total_allowance_per_key,
            max_key_uses,
            &asset_by_id,
            &asset_data_for_uses
        );

        // Keep track of all the key IDs 
        let mut next_key_id = 0;
        // Keep track of all the events
        let mut event_logs = Vec::new();
        // Add the keys to the contract
        self.internal_add_keys_to_account(
            &mut next_key_id,
            &mut key_info_by_token_id,
            &mut event_logs,
            &drop_id,
            max_key_uses,
            &key_data, 
            total_allowance_per_key
        );

        // Write the drop data to storage
        let funder_id = env::predecessor_account_id();
        let drop = InternalDrop {
            max_key_uses,
            asset_data_for_uses,
            asset_by_id,
            key_info_by_token_id,
            next_key_id,
            config: drop_config,
            funder_id: funder_id.clone(),
        };
        require!(self.drop_by_id.insert(&drop_id, &drop).is_none(), format!("Drop with ID {} already exists", drop_id));
        // Add the drop ID to the list of drops owned by the funder
        self.internal_add_drop_to_funder(&funder_id, &drop_id);

        // Measure final costs
        let net_storage = env::storage_usage() - initial_storage;
        self.determine_costs(
            key_data.len(),
            true, // We did create a drop here
            total_cost_per_key,
            total_allowance_per_key,
            net_storage,
            keep_excess_deposit
        );

        // Construct the drop creation log and push it to the event logs
        let drop_creation_event: EventLog = EventLog {
            standard: KEYPOM_STANDARD_NAME.to_string(),
            version: KEYPOM_STANDARD_VERSION.to_string(),
            event: EventLogVariant::DropCreation(CreateOrDeleteDropLog {
                funder_id: funder_id.to_string(),
                drop_id
            }),
        };
        event_logs.push(drop_creation_event);

        // Now that everything is done (no more potential for panics), we can log the events
        log_events(event_logs);
        true
    }
}
'''
'''--- contract/src/drop_creation/helpers.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Loops through public keys and adds them to the current contract account
    /// Also adds the keys to the drop_id_for_pk map and ensures that no keys are already on the contract
    pub(crate) fn internal_add_keys_to_account(
        &mut self,
        next_key_id: &mut u64,
        key_info_by_token_id: &mut UnorderedMap<TokenId, InternalKeyInfo>,
        event_logs: &mut Vec<EventLog>,
        drop_id: &DropId,
        max_uses_per_key: UseNumber,
        key_data: &Vec<ExtKeyData>,
        allowance: Balance
    ) {
        let current_account_id = &env::current_account_id();

        // Logs for add key and NFT mint events
        let mut add_key_logs = Vec::new();
        let mut nft_mint_logs = Vec::new();

        // Create a new promise batch to create all the access keys
        let promise = env::promise_batch_create(current_account_id);

        // Loop through the public keys and add them to the contract.
        // None of these promises will fire if there's a panic so it's
        // Fine to add them in the loop
        for data in key_data.iter() {
            let ExtKeyData { public_key, password_by_use, metadata, key_owner } = data;

            let token_id = format!("{}:{}", drop_id, next_key_id);
            require!(
                self.token_id_by_pk.insert(public_key, &token_id).is_none(),
                "Key already added to contract"
            );

            // Iterate through the key_data.password_by_use hash map (if there is one) and decode all the strings to hex
            let pw_by_use: Option<HashMap<UseNumber, Vec<u8>>> = password_by_use.as_ref().map(|p| {
                p.into_iter().map(|(k, v)| {
                    let decoded = hex::decode(v).expect("Invalid hex string");
                    (*k, decoded)
                }).collect()
            });

            if let Some(owner) = key_owner {
                // Add the NFT key to the owner's list of tokens
                self.internal_add_token_to_owner(
                    &owner,
                    &token_id
                );
            }
            key_info_by_token_id.insert(&token_id, &InternalKeyInfo { 
                pub_key: public_key.clone(), 
                remaining_uses: max_uses_per_key,
                owner_id: key_owner.clone(), 
                next_approval_id: 0,
                last_claimed: 0, // Set to 0 since this will make the key always claimable.
                approved_account_ids: Default::default(),
                metadata: metadata.clone(),
                pw_by_use,
            });

            // TODO: add to tokens_per_owner
            
            // Add this key to the batch
            env::promise_batch_action_add_key_with_function_call(
                promise,
                public_key,
                0, // Nonce
                allowance,
                current_account_id,
                ACCESS_KEY_METHOD_NAMES,
            );

            // Construct the nft mint and add key logs to be added as events later
            add_new_key_logs(
                &mut nft_mint_logs,
                &mut add_key_logs,
                &key_owner,
                &drop_id,
                &public_key,
                &token_id
            );

            *next_key_id += 1;
        }

        // Construct the events themselves
        if nft_mint_logs.len() > 0 {
            event_logs.push(EventLog {
                standard: NFT_STANDARD_NAME.to_string(),
                version: NFT_METADATA_SPEC.to_string(),
                event: EventLogVariant::NftMint(nft_mint_logs),
            });
        }
        if add_key_logs.len() > 0 {
            event_logs.push(EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::AddKey(add_key_logs),
            });
        }

        env::promise_return(promise);
    }

     /// Tally up all the costs for adding keys / creating a drop and refund any excess deposit
     pub(crate) fn determine_costs(
        &mut self,
        num_keys: usize, 
        did_create_drop: bool,
        asset_cost_per_key: Balance, 
        allowance_per_key: Balance,
        net_storage: u64,
        keep_excess_deposit: Option<bool>
    ) {
        let num_keys = num_keys as u128;
        
        let storage_cost = net_storage as Balance * env::storage_byte_cost();
        let total_asset_cost = asset_cost_per_key * num_keys;
        let total_allowance_cost = allowance_per_key * num_keys;

        let fees_for_user = self.fees_per_user.get(&env::predecessor_account_id()).unwrap_or(self.fee_structure.clone());
        let total_fees = num_keys * fees_for_user.per_key + did_create_drop as u128 * fees_for_user.per_drop;
        self.fees_collected += total_fees;
        let total_cost = total_asset_cost + storage_cost + total_allowance_cost + total_fees;
        
        near_sdk::log!("total {} storage {} asset {} allowance {} keypom fees {}", total_cost, storage_cost, total_asset_cost, total_allowance_cost, total_fees);
        self.charge_with_deposit_or_balance(total_cost, keep_excess_deposit);
    }

    /// Internal method to add a drop ID the list of drops a funder has. If they don't have any, instantiate
    /// A new unordered set and add the drop ID to it. Otherwise, just add the drop ID to the existing set
    pub(crate) fn internal_add_drop_to_funder(&mut self, funder_id: &AccountId, drop_id: &DropId) {
        let mut drop_set = self.drop_ids_by_funder.get(funder_id).unwrap_or_else(|| {
            // If the account doesn't have any drops, we create a new unordered set
            UnorderedSet::new(StorageKeys::DropIdsByFunderInner {
                // We get a new unique prefix for the collection equal to the funder (since it's unique)
                account_id_hash: hash_string(&funder_id.to_string()),
            })
        });

        // We insert the drop ID into the set
        drop_set.insert(drop_id);

        // We insert that set for the given account ID.
        self.drop_ids_by_funder.insert(funder_id, &drop_set);
    }

    /// Internal method to remove a drop ID from the list of drops a funder has.
    /// If the funder has no more drops, we remove the funder from the drop_ids_by_funder collection
    pub(crate) fn internal_remove_drop_for_funder(
        &mut self,
        funder_id: &AccountId,
        drop_id: &DropId,
    ) {
        // Get the set of drop IDs that the funder currently has
        let mut drop_set = self
            .drop_ids_by_funder
            .get(funder_id)
            .expect("No Drops found for the funder");

        // Remove the drop ID from the set
        drop_set.remove(drop_id);

        // If the set is now empty, we remove the funder from the collection
        if drop_set.is_empty() {
            self.drop_ids_by_funder.remove(funder_id);
        } else {
            self.drop_ids_by_funder.insert(funder_id, &drop_set);
        }
    }
}

/// Helper function to ingest external assets and store them in the internal asset by ID map
pub fn store_assets_by_id (
    ext_assets: &Vec<Option<ExtAsset>>,
    asset_by_id: &mut UnorderedMap<AssetId, InternalAsset>
) {
    let mut fc_idx = 0;
    for ext_asset in ext_assets {
        // If the external asset is of type FCData, the asset ID will be the incrementing number
        // Otherwise, it will be the asset ID specified
        let asset_id = if let Some(ExtAsset::FCAsset(_)) = ext_asset {
            fc_idx += 1;
            format!("{}{}", FC_ASSET_PREFIX, fc_idx)
        } else {
            ext_asset.as_ref().and_then(|a| Some(a.get_asset_id())).unwrap_or(NONE_ASSET_ID.to_string())
        };

        // Only insert into the asset ID map if it doesn't already exist
        // If we insert, we should also add the cost to the total asset cost
        if asset_by_id.get(&asset_id).is_none() {
            let internal_asset = ext_asset_to_internal(ext_asset.as_ref());

            asset_by_id.insert(&asset_id, &internal_asset);
        }
    }
}

/// Ensure that the time configurations passed in is valid
pub(crate) fn assert_valid_time_config(config: &TimeConfig) {
    // Assert that if the claim_interval is some, the start_timestamp is also some
    assert!(
        (config.interval.is_some() && config.start.is_none()) == false,
        "If you want to set a claim interval, you must also set a start timestamp"
    );

    // Assert that both the start_timestamp and end timestamps are greater than the current block
    assert!(
        config.start.unwrap_or(env::block_timestamp()) >= env::block_timestamp(),
        "The start timestamp must be greater than the current block timestamp"
    );
    assert!(
        config.end.unwrap_or(env::block_timestamp()) >= env::block_timestamp(),
        "The end timestamp must be greater than the current block timestamp"
    );

    // If both the start timestamp and end timestamp are set, ensure that the start timestamp is less than the end timestamp
    if config.start.is_some() && config.end.is_some() {
        assert!(
            config.start.unwrap() < config.end.unwrap(),
            "The start timestamp must be less than the end timestamp"
        );
    }
}
'''
'''--- contract/src/drop_creation/mod.rs ---
pub mod create_drop;
pub mod add_keys;
pub mod helpers;

pub use helpers::*;
'''
'''--- contract/src/drop_deletion.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /*
        User can pass in a vector of public keys or a drop ID.
        If a drop ID is passed in, it will auto delete up to limit.
        If limit is not specified, auto assume 100 keys from the drop.
        All keys must be from the same drop ID.
    */
    pub fn delete_keys(
        &mut self,
        drop_id: DropId,
        public_keys: Option<Vec<PublicKey>>,
        limit: Option<u8>,
        keep_empty_drop: Option<bool>
    ) -> PromiseOrValue<bool>{
        self.assert_no_global_freeze();

        // Measure initial storage before doing any operations
        let initial_storage = env::storage_usage();

        // get the drop object (remove it and only re-insert at the end if it shouldn't be deleted)
        let mut drop = self.drop_by_id.remove(&drop_id).expect("No drop found");
        
        let funder_id = drop.funder_id.clone();
        require!(
            funder_id == env::predecessor_account_id(),
            "Only drop funder can delete keys"
        );

        // Loop through all the assets in the drop and ensure they're empty
        for asset in drop.asset_by_id.values() {
            require!(
                asset.is_empty(),
                "Withdraw all assets in the drop before deleting keys"
            );
        }

        // Get a list of all the public keys that should be deleted.
        // This is either what was passed in, or the first limit (or 100) keys in the drop
        let public_keys = public_keys.unwrap_or_else(|| drop.key_info_by_token_id.iter().take(limit.unwrap_or(100).into()).map(|k| k.1.pub_key).collect());
        
        
        // Create the batch promise for deleting the keys
        let key_deletion_promise = env::promise_batch_create(&env::current_account_id());
        
        // Keep track of the total cost for the key & the required allowance to be refunded
        let mut total_cost_for_keys: Balance = 0;
        let mut total_allowance_for_keys: Balance = drop.config.as_ref().and_then(|config| config.extra_allowance_per_key).unwrap_or(U128(0)).0 * public_keys.len() as u128;

        let mut delete_key_logs = Vec::new();
        let mut nft_burn_logs = Vec::new();

        // Loop through each public key and delete it
        for pk in &public_keys {
            // Get the key info for this public key (by removing - re-entrancy attack prevention)
            let token_id = self.token_id_by_pk.remove(pk).expect("Token ID not found for Public Key");
            let key_info = drop.key_info_by_token_id.remove(&token_id).expect("Key Info not found for Token ID");
            if let Some(owner) = key_info.owner_id.as_ref() {
                self.internal_remove_token_from_owner(owner, &token_id);
            }

            // For every remaining use, we need to loop through all assets and refund
            get_total_costs_for_key(
                &mut total_cost_for_keys,
                &mut total_allowance_for_keys,
                key_info.remaining_uses,
                &drop.asset_by_id,
                &drop.asset_data_for_uses
            );

            add_delete_key_logs(
                &mut nft_burn_logs,
                &mut delete_key_logs,
                &key_info.owner_id,
                &drop_id,
                &pk,
                &token_id
            );

            // Add the delete key action to the batch promise
            env::promise_batch_action_delete_key(key_deletion_promise, &pk);
        }

        // Keep track of all the events starting with the NFT burn and key deletion logs
        let mut event_logs = vec![
            EventLog {
                standard: NFT_STANDARD_NAME.to_string(),
                version: NFT_METADATA_SPEC.to_string(),
                event: EventLogVariant::NftBurn(nft_burn_logs),
            },
            EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::DeleteKey(delete_key_logs),
            }
        ];
        
        // Drop is empty, keep_empty_drop is false and delete_empty_drop is true
        if drop.key_info_by_token_id.is_empty() && !keep_empty_drop.unwrap_or(false) {
            // Now that the drop is empty, we can delete the assets by use and asset by ID
            // The drop has already been removed from storage, so we can just clear the maps
            internal_clear_drop_storage(&mut drop, &mut event_logs, &drop_id);
            self.internal_remove_drop_for_funder(&funder_id, &drop_id);
        } else {
            // Put the modified drop back in storage
            self.drop_by_id.insert(&drop_id, &drop);
        }

        // Measure the final storage released after all operations
        let storage_released = initial_storage - env::storage_usage();
        let storage_refund = storage_released as u128 * env::storage_byte_cost();
        
        let total_refund_for_use = total_cost_for_keys + total_allowance_for_keys + storage_refund;
        near_sdk::log!("Allowance Refund: {} Cost Refund: {} Storage Refund: {}", total_allowance_for_keys, total_cost_for_keys, storage_refund);
        self.internal_modify_user_balance(&funder_id, total_refund_for_use, false);

        // Now that everything is done (no more potential for panics), we can log the events
        log_events(event_logs);

        env::promise_return(key_deletion_promise);

        PromiseOrValue::Value(true)
    }
}

/// Internal helper function to clear the storage in the drop
pub(crate) fn internal_clear_drop_storage(
    drop: &mut InternalDrop,
    event_logs: &mut Vec<EventLog>,
    drop_id: &DropId
) {
    drop.asset_by_id.clear();
    drop.key_info_by_token_id.clear();

    // Add the drop deletion log to the event logs
    event_logs.push(EventLog {
        standard: KEYPOM_STANDARD_NAME.to_string(),
        version: KEYPOM_STANDARD_VERSION.to_string(),
        event: EventLogVariant::DropDeletion(CreateOrDeleteDropLog {
            funder_id: drop.funder_id.to_string(),
            drop_id: drop_id.to_string()
        })
    });
}
'''
'''--- contract/src/helpers.rs ---
use crate::*;

/// Used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_string(string: &String) -> CryptoHash {
    env::sha256_array(string.as_bytes())
}

/// Helper function to convert yoctoNEAR to $NEAR with 7 decimals of precision.
pub(crate) fn yocto_to_near(yocto: u128) -> f64 {
    //10^17 yoctoNEAR (1 NEAR would be 10_000_000). This is to give a precision of 7 decimal places.
    let formatted_near = yocto / 100_000_000_000_000_000;
    let near = formatted_near as f64 / 10_000_000f64;

    near
}

/// Check whether an asset ID is function call or not
pub(crate) fn is_fc_asset_id(asset_id: &AssetId) -> bool {
    asset_id.contains(FC_ASSET_PREFIX)
}

/// Query for the key's current use number given the drop and key info
pub(crate) fn get_key_cur_use(drop: &InternalDrop, key_info: &InternalKeyInfo) -> UseNumber {
    drop.max_key_uses - key_info.remaining_uses + 1
}

/// Used to calculate the base allowance needed given attached GAS
pub(crate) fn calculate_base_allowance(yocto_per_gas: Balance, attached_gas: Gas, should_log: bool) -> Balance {
    let prepaid: u64 = attached_gas.0 + GAS_PER_CCC.0;

    // Get the number of CCCs you can make with the attached GAS
    // 5 TGas GAS_PER_CCC
    let calls_with_gas = (prepaid / GAS_PER_CCC.0) as f32;
    // Get the constant used to pessimistically calculate the required allowance
    let pow_outcome = 1.032_f32.powf(calls_with_gas);

    // Get the required GAS based on the calculated constant
    // 2.5 TGas receipt cost
    let required_allowance = ((prepaid + RECEIPT_GAS_COST.0) as f32 * pow_outcome
        + RECEIPT_GAS_COST.0 as f32) as Balance
        * yocto_per_gas;

    if should_log {
        near_sdk::log!(
            "{} calls with {} attached GAS. Pow outcome: {}. Required Allowance: {}",
            calls_with_gas,
            prepaid,
            pow_outcome,
            required_allowance
        );
    }

    required_allowance
}

/// Helper function that returns the total cost for a given key as well as its allowance
/// This key can be partially used or not
pub(crate) fn get_total_costs_for_key(
    total_cost_for_keys: &mut Balance,
    total_allowance_for_keys: &mut Balance,
    remaining_uses: UseNumber, 
    asset_by_id: &UnorderedMap<AssetId, InternalAsset>,
    asset_data_for_uses: &Vec<InternalAssetDataForUses>,
) {
    // Get the remaining asset data
    let remaining_asset_data = get_remaining_asset_data(asset_data_for_uses, remaining_uses);

    // For every remaining asset data, we should query the costs and multiply it by the number of uses left
    for asset_data in remaining_asset_data {
        let InternalAssetDataForUses { uses, config: use_config, assets_metadata, required_asset_gas } = asset_data;

        // If the config's permission field is set to Claim, the base should be set accordingly. In all other cases, it should be the base for CAAC
        let base_gas_for_use = if let Some(perms) = use_config.as_ref().and_then(|c| c.permissions.as_ref()) {
            match perms {
                ClaimPermissions::claim => {
                    BASE_GAS_FOR_CLAIM
                }
                _ => BASE_GAS_FOR_CREATE_ACC_AND_CLAIM
            }
        } else {
            BASE_GAS_FOR_CREATE_ACC_AND_CLAIM
        };

        // Check and make sure that the time config is valid
        if let Some(time_config) = use_config.as_ref().and_then(|c| c.time.as_ref()) {
            assert_valid_time_config(time_config)
        }

        // Loop through each asset metadata and tally the costs
        for metadata in assets_metadata {
            // Get the asset object (we only clear the assets by ID when the drop is empty and deleted)
            let internal_asset = asset_by_id
                .get(&metadata.asset_id)
                .expect("Asset not found");

            // Get the refund amount for the asset
            let cost_for_use = internal_asset.get_yocto_refund_amount(&metadata.tokens_per_use.map(|x| x.into()));
            *total_cost_for_keys += cost_for_use * uses as u128;
        }

        let total_claim_gas = required_asset_gas + base_gas_for_use;
        require!(total_claim_gas <= MAX_GAS_ATTACHABLE, format!("Total gas {} exceeds the maximum 300 TGas limit", total_claim_gas.0));
        
        // Get the total allowance for this use
        let allowance_for_use = calculate_base_allowance(YOCTO_PER_GAS, total_claim_gas, false);
        *total_allowance_for_keys += allowance_for_use * uses as u128;
    }
}

/// Returns a vector of remaining asset datas given the remaining uses for a key.
/// Tests: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f11c6325055ed73fccd6b5c870dbccc2
pub(crate) fn get_remaining_asset_data(asset_data: &Vec<InternalAssetDataForUses>, remaining_uses: UseNumber) -> Vec<InternalAssetDataForUses> {
    let mut uses_traversed = 0;
    let mut remaining_data = vec![];
    
    for asset in asset_data.iter().rev() {
        uses_traversed += asset.uses;
        
        if uses_traversed >= remaining_uses {
            let asset_to_push = InternalAssetDataForUses { 
                uses: asset.uses - (uses_traversed - remaining_uses),
                config: asset.config.clone(), 
                assets_metadata: asset.assets_metadata.clone(),
                required_asset_gas: asset.required_asset_gas
            };
            
            remaining_data.push(asset_to_push);
            break;
        } else {
            remaining_data.push(asset.clone());
        }
    }
    
    remaining_data
}

/// Helper function to get the internal key behavior for a given use number
/// Tests: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e60e0bd12e87b90d375040d3c2fad715
pub(crate) fn get_asset_data_for_specific_use (
    asset_data_for_uses: &Vec<InternalAssetDataForUses>,
    use_number: &UseNumber
) -> InternalAssetDataForUses {
    let mut cur_use = 0;

    for asset_data in asset_data_for_uses.iter() {
        cur_use += asset_data.uses;

        if cur_use >= *use_number {
            return asset_data.clone();
        }
    }

    InternalAssetDataForUses {
        uses: 0,
        assets_metadata: vec![],
        config: None,
        required_asset_gas: Gas(0)
    }
}

/// Take a token ID and return the drop ID and key nonce based on the `:` delimiter.
pub(crate) fn parse_token_id(token_id: &TokenId) -> Result<(DropId, u64), String> {
    let delimiter = ":";
    let split: Vec<&str> = token_id.split(delimiter).collect();
    let drop_id = split[0];
    let key_nonce = split[1].parse::<u64>();
    if key_nonce.is_err() {
        return Err("Invalid key nonce".to_string());
    }

    return Ok((drop_id.to_string(), key_nonce.unwrap()));
}

/// Helper function to convert an external asset to an internal asset
pub(crate) fn ext_asset_to_internal(ext_asset: Option<&ExtAsset>) -> InternalAsset {
    if let Some(asset) = ext_asset {
        return asset.to_internal_asset();
    }

    return InternalAsset::none;
}

/// Add keypom args to output args for a function call
pub(crate) fn add_keypom_args(
    output_args: &mut String, 
    keypom_args: Option<KeypomInjectedArgs>, 
    account_id: &AccountId,
    drop_id: &DropId,
    key_id: &String,
    funder_id: &AccountId
) -> Result<(), String> {
    // Add keypom args and set any user markers
    let keypom_args = keypom_args.unwrap_or(KeypomInjectedArgs { 
        account_id_field: None,
        drop_id_field: None,
        key_id_field: None,
        funder_id_field: None
    });
    
    insert_keypom_arg(
        output_args,
        &keypom_args.account_id_field,
        account_id.to_string()
    )?;
    insert_keypom_arg(
        output_args,
        &keypom_args.drop_id_field,
        drop_id.to_string()
    )?;
    insert_keypom_arg(
        output_args,
        &keypom_args.key_id_field,
        key_id.to_string()
    )?;
    insert_keypom_arg(
        output_args,
        &keypom_args.funder_id_field,
        funder_id.to_string()
    )?;

    if output_args.contains("\"keypom_args\"") {
        return Err("Keypom Args detected in client args. Returning and decrementing keys".to_string());
    }

    output_args.insert_str(
        output_args.len() - 1,
        &format!(
            ",\"keypom_args\":{}",
            near_sdk::serde_json::to_string(&keypom_args).unwrap()
        ),
    );

    return Ok(());
}
'''
'''--- contract/src/internals/constants/gas_amounts.rs ---
use crate::*;

// ------------------------ General ------------------------ //
/// How much yoctoNEAR is in 1 unit of Gas
pub const YOCTO_PER_GAS: Balance = 100_000_000;
/// For every cross contract call, there is a base 5 TGas cost on top of what is sent to the contract
pub const MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP: Gas = Gas(5_000_000_000_000); // 5 TGas
/// Maximum amount of Gas that can be attached to the transaction
pub const MAX_GAS_ATTACHABLE: Gas = Gas(300_000_000_000_000); // 300 TGas
/// Minimum amount of gas required to perform any necessary computations for the receipt
pub const MIN_GAS_FOR_RECEIPT_COMPUTATION: Gas = Gas(5_000_000_000_000); // 7.5 TGas

// ------------------------ Create Account & Claim ------------------------ //
/// The base amount of gas required for create_account_and_claim calls.
/// This does not include the actual asset promises
pub const BASE_GAS_FOR_CREATE_ACC_AND_CLAIM: Gas = Gas(BASE_GAS_FOR_CLAIM.0 + GAS_FOR_CREATE_ACCOUNT.0 + MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP.0);
/// Actual amount of GAS to attach for creating a new account.
/// This value is equal to 28 TGas
pub const GAS_FOR_CREATE_ACCOUNT: Gas = Gas(28_000_000_000_000); 
/// The base amount of gas required for the callback after a new account is created.
/// This does not include the actual asset promises
pub const BASE_GAS_FOR_RESOLVE_ACCOUNT_CREATION: Gas = Gas(MIN_GAS_FOR_RECEIPT_COMPUTATION.0 + MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP.0 + MIN_GAS_FOR_RESOLVE_ASSET_CLAIM.0);

// ------------------------ Claim ------------------------ //
/// The base amount of gas required for claim calls.
/// This does not include the actual asset promises
pub const BASE_GAS_FOR_CLAIM: Gas = Gas(BASE_GAS_FOR_RESOLVE_ACCOUNT_CREATION.0 + 2*MIN_GAS_FOR_RECEIPT_COMPUTATION.0);

// ------------------------ Shared Constants ------------------------ //
/// The minimum amount of gas required for the callback after a all the assets have been claimed.
pub const MIN_GAS_FOR_RESOLVE_ASSET_CLAIM: Gas = Gas(MIN_GAS_FOR_RECEIPT_COMPUTATION.0 + MIN_BASE_GAS_FOR_RECEIPT_SPIN_UP.0);

// ------------------------ Pessimistic Allowance ------------------------ //
/// For pessimistic allowance calculations:
/// Lowest amount of Gas a CCC can use 
pub const GAS_PER_CCC: Gas = Gas(5_000_000_000_000); // 5 TGas
/// How much Gas it costs to spin up the receipt
pub const RECEIPT_GAS_COST: Gas = Gas(2_500_000_000_000); // 2.5 TGas

// ------------------------ Assets ------------------------ //
pub const GAS_FOR_NONE_ASSET: Gas = Gas(400_000_000_000); // 0.4 TGas
pub const GAS_FOR_NEAR_TRANSFER: Gas = Gas(9_000_000_000_000); // 9 TGas
'''
'''--- contract/src/internals/constants/mod.rs ---
pub mod gas_amounts;
pub mod strings;

pub use gas_amounts::*;
pub use strings::*;
'''
'''--- contract/src/internals/constants/strings.rs ---
// ------------------------ Access Key Method Names ------------------------ //
pub const ACCESS_KEY_METHOD_NAMES: &str = "claim,create_account_and_claim,nft_transfer,nft_approve,nft_revoke";

// ------------------------ NFT Standard Stuff ------------------------ //
/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

// ------------------------ Keypom Standard ------------------------ //
/// What version is the keypom standard on? This is for keypom event logging
pub const KEYPOM_STANDARD_VERSION: &str = "1.0.0";
/// What is the Keypom standard name? This is for keypom event logging
pub const KEYPOM_STANDARD_NAME: &str = "keypom";

// ------------------------ Asset IDs ------------------------ //
/// Asset ID for the fc assets (this should never be used though and is just a fallback)
pub const FALLBACK_FC_ASSET_ID: &str = "fc";
/// Asset ID for the near asset
pub const NEAR_ASSET_ID: &str = "near";
/// Asset ID for the none / null asset
pub const NONE_ASSET_ID: &str = "none-asset";
/// Prefix for all FC asset IDs
pub const FC_ASSET_PREFIX: &str = "fc&";
'''
'''--- contract/src/internals/events/events_core.rs ---
use std::fmt;

use crate::*;

/// External data representing assets that should be logged as part of events
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ExtAssetForEvents {
    FTAsset(ExtFTData),
    NearAsset(ExtNEARData),
    NFTAsset(ExtNFTData),
    FCAsset(Vec<ExtFCDataForEvents>)
}

/// Data going into or out of the Keypom contract representing the presence of fungible tokens as an asset for a drop
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtFCDataForEvents {
    /// Contract that will be called
    pub receiver_id: String,
    /// Method to call on receiver_id contract
    pub method_name: String,
    /// Amount of yoctoNEAR to attach along with the call
    pub attached_deposit: U128,
    /// How much gas to attach to this method call.
    pub attached_gas: Gas,
}

/// Enum that represents the data type of the EventLog.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    /// Drop creation / deletion
    DropCreation(CreateOrDeleteDropLog),
    DropDeletion(CreateOrDeleteDropLog),

    /// Whenever keys are claimed
    Claim(ClaimLog),
    CreateAccountAndClaim(CreateAccountAndClaimLog),

    /// Whenever keys are added
    AddKey(Vec<AddOrDeleteKeyLog>),
    NftMint(Vec<NftMintLog>),

    /// Whenever keys are deleted
    DeleteKey(Vec<AddOrDeleteKeyLog>),
    NftBurn(Vec<NftBurnLog>),

    /// Whenever keys are transferred
    KeyTransfer(TransferKeyLog),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. kpom1
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}
'''
'''--- contract/src/internals/events/helpers.rs ---
use crate::*;

/// Helper function to loop through events and log them.
pub(crate) fn log_events(events: Vec<EventLog>) {
    for event in events {
        // Log the serialized json.
        env::log_str(&event.to_string());
    }
}

/// Whenever a new key is added on the contract, we should add the logs to both
/// An NFT mint and add key vector so that those events can be fired once the
/// Key additions are finalized.
pub fn add_new_key_logs(
    nft_mint_logs: &mut Vec<NftMintLog>,
    add_key_logs: &mut Vec<AddOrDeleteKeyLog>,
    token_owner: &Option<AccountId>,
    drop_id: &String,
    pk: &PublicKey,
    token_id: &TokenId
) {
    nft_mint_logs.push(NftMintLog {
        owner_id: token_owner.as_ref().unwrap_or(&env::current_account_id()).to_string(),
        token_ids: vec![token_id.to_string()],
        memo: None,
    });

    add_key_logs.push(AddOrDeleteKeyLog {
        drop_id: drop_id.to_string(),
        public_key: pk.into()
    });
}

/// Whenever a key is deleted on the contract, we should add the logs to both
/// An NFT burn and delete key vector so that those events can be fired once the
/// Key deltions are finalized.
pub fn add_delete_key_logs(
    nft_burn_logs: &mut Vec<NftBurnLog>,
    delete_key_logs: &mut Vec<AddOrDeleteKeyLog>,
    token_owner: &Option<AccountId>,
    drop_id: &String,
    pk: &PublicKey,
    token_id: &TokenId
) {
    nft_burn_logs.push(NftBurnLog {
        owner_id: token_owner.as_ref().unwrap_or(&env::current_account_id()).to_string(),
        token_ids: vec![token_id.to_string()],
        authorized_id: None,
        memo: None,
    });
    delete_key_logs.push(AddOrDeleteKeyLog {
        drop_id: drop_id.to_string(),
        public_key: pk.into()
    });
}

'''
'''--- contract/src/internals/events/keypom.rs ---
use crate::*;

/// An event log to capture whenever a drop is created or deleted
///
/// Arguments
/// * `funder_id`: "account.near"
/// * `drop_id`: "my-drop123"
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CreateOrDeleteDropLog {
    pub funder_id: String,
    pub drop_id: String,
}

/// An event log to capture whenever a key is added to or deleted from a drop
///
/// Arguments
/// * `drop_id`: "my-drop123"
/// * `public_key`: "ed25519:8WWpRpZswPHoJn5THFdBaFdbVeSjtSrQmEcoUeaNdkKy"
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AddOrDeleteKeyLog {
    pub drop_id: String,
    pub public_key: String,
}

/// An event log to capture whenever a key has been transferred (either meaning the public key was rotated or there's a new owner)
///
/// Arguments
/// * `old_owner_id`: Old owner of the key
/// * `new_owner_id`: New owner of the key
/// * `old_public_key`: Original public key
/// * `new_public_key`: New public key
/// * `drop_id`: "my-drop123"
/// * `token_id`: The ID of the key that was transferred
/// 
/// * `authorized_id`: approved account to transfer
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TransferKeyLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    
    pub old_public_key: String,
    pub new_public_key: String,
    
    pub drop_id: String,
    pub token_id: String
}

/// An event log to capture whenever a key is used to call `claim`
///
/// Arguments
/// * `account_id`: "account.near"
/// * `drop_id`: "my-drop123"
/// * `public_key`: "ed25519:8WWpRpZswPHoJn5THFdBaFdbVeSjtSrQmEcoUeaNdkKy"
/// * `assets`: list of assets that were claimed
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ClaimLog {
    pub account_id: String,
    pub drop_id: String,
    pub public_key: String,

    pub assets: Vec<Option<ExtAssetForEvents>>,
}

/// An event log to capture whenever a key is used to call `claim`
///
/// Arguments
/// * `account_id`: "account.near"
/// * `drop_id`: "my-drop123"
/// * `public_key`: "ed25519:8WWpRpZswPHoJn5THFdBaFdbVeSjtSrQmEcoUeaNdkKy"
/// * `assets`: list of assets that were claimed
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CreateAccountAndClaimLog {
    pub new_account_id: String,
    pub new_public_key: String,
    pub public_key: String,
    pub drop_id: String,

    pub assets: Vec<Option<ExtAssetForEvents>>,
}
'''
'''--- contract/src/internals/events/mod.rs ---
pub mod events_core;
pub mod keypom;
pub mod nfts;
pub mod helpers;

pub use events_core::*;
pub use helpers::*;
pub use keypom::*;
pub use nfts::*;
'''
'''--- contract/src/internals/events/nfts.rs ---
use crate::*;

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token burning
/// 
/// Arguments
/// * `owner_id`: owner of tokens to burn
/// * `authorized_id`: approved account_id to burn, if applicable
/// * `token_ids`: ["1","2"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftBurnLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}
'''
'''--- contract/src/internals/mod.rs ---
pub mod constants;
pub mod types;
pub mod events;

pub use constants::*;
pub use types::*;
pub use events::*;

'''
'''--- contract/src/internals/types.rs ---
/// Which specific use is something being acted on. This is not zero indexed (i.e the first use is 1)
pub type UseNumber = u32;
/// The ID of a given asset such as FTs, NFTs, or Function Calls.
pub type AssetId = String;
/// The ID for a given drop (this is the unique identifier for the drop and is how it will be referenced)
pub type DropId = String;
/// Drop Metadata should be a string which can be JSON or anything the users want.
pub type DropMetadata = String;
/// ID for NFTs that have been sent to the Keypom contract as part of NFT assets
pub type TokenId = String;

/// Optionally, the user can pass in a set of asset specific FC args
pub type UserProvidedFCArgs = Option<Vec<AssetSpecificFCArgs>>;
/// For each FC asset, there can be a set of user arguments for each method. Each method doesn't necessarily need to have user arguments.
pub type AssetSpecificFCArgs = Option<Vec<Option<String>>>;
'''
'''--- contract/src/lib.rs ---
use std::collections::HashMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet, LazyOption};
use near_sdk::json_types::U128;
use near_sdk::serde::{Serialize, Deserialize, Serializer};
use near_sdk::serde::ser::SerializeStruct;
use near_sdk::serde_json::json;
use near_sdk::{env, GasWeight, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, PublicKey, Promise, PromiseOrValue, require, CryptoHash, Gas, Balance};

mod assets;
mod drop_creation;
mod internals;
mod helpers;
mod models;
mod drop_claiming;
mod user_balances;
mod drop_deletion;
mod views;
mod owner;
mod nft_keys;

use assets::*;
use nft_keys::*;
use drop_deletion::*;
use drop_creation::*;
use drop_claiming::*;
use internals::*;
use helpers::*;
use models::*;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Keypom {
    // ------------------------ Owner Only Things ------------------------ //
    /// Owner of the contract that can set configurations such as global freezes etc.
    pub contract_owner_id: AccountId,
    /// Whether or not the contract is frozen and no new drops can be created / keys added.
    pub global_freeze: bool,
    /// Outlines the fees that are charged for every drop and key
    pub fee_structure: KeypomFees,
    /// Total amount of fees available for withdrawal collected overtime.
    pub fees_collected: u128,
    /// Overload the fees for specific users by providing custom fees
    pub fees_per_user: LookupMap<AccountId, KeypomFees>,

    // ------------------------ Drops ------------------------ //
    /// Map a drop ID to its internal drop data
    pub drop_by_id: LookupMap<DropId, InternalDrop>,
    /// Keep track of the drop ids that each funder has created. This is used for view methods.
    pub drop_ids_by_funder: LookupMap<AccountId, UnorderedSet<DropId>>,
    /// Get the token ID for any given public key
    pub token_id_by_pk: UnorderedMap<PublicKey, TokenId>,
    /// Which account should all newly created accounts be sub-accounts of? (i.e `testnet` or `near`)
    pub root_account: AccountId,

    // ------------------------ NFT Keys ------------------------ //
    /// Keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    
    // ------------------------ Utility ------------------------ //
    /// Source metadata extension:
    pub contract_metadata: LazyOption<ContractSourceMetadata>,
    /// Keep track of the balances for each user. This is to prepay for drop creations
    pub user_balances: LookupMap<AccountId, Balance>,
}

#[near_bindgen]
impl Keypom {
    #[init]
    pub fn new(
        root_account: AccountId,
        owner_id: AccountId,
        contract_metadata: ContractSourceMetadata,
    ) -> Self {
        Self {
            contract_owner_id: owner_id,
            global_freeze: false,
            drop_by_id: LookupMap::new(StorageKeys::DropById),
            token_id_by_pk: UnorderedMap::new(StorageKeys::TokenIdByPk),
            tokens_per_owner: LookupMap::new(StorageKeys::TokensPerOwner),
            user_balances: LookupMap::new(StorageKeys::UserBalances),
            root_account,
            fees_per_user: LookupMap::new(StorageKeys::FeesPerUser),
            drop_ids_by_funder: LookupMap::new(StorageKeys::DropIdsByFunder),
            fees_collected: 0,
            fee_structure: KeypomFees {
                per_drop: 0,
                per_key: 0,
            },
            contract_metadata: LazyOption::new(
                StorageKeys::ContractMetadata,
                Some(&contract_metadata),
            ),
        }
    }

    /// Helper function to make sure there isn't a global freeze on the contract
    pub(crate) fn assert_no_global_freeze(&self) {
        if env::predecessor_account_id() != self.contract_owner_id {
            require!(self.global_freeze == false, "Contract is frozen and no new drops or keys can be created");
        }
    }
}
'''
'''--- contract/src/models/config.rs ---
use crate::*;
use std::collections::HashSet;

#[allow(non_camel_case_types)]
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
/// Can a key be used to call `claim` or just `create_account_and_claim`? 
pub enum ClaimPermissions {
    claim,
    create_account_and_claim,
}

/// Keep track of different configuration options for all the uses of a key in a given drop
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct UseConfig {
    /// Configurations related to how often keys can be used
    pub time: Option<TimeConfig>,
    
    /// Can the access key for this use call the claim method_name? Default to both method_name callable
    pub permissions: Option<ClaimPermissions>,
    
    /// When calling `create_account` on the root account, which keypom args should be attached to the payload.
    pub account_creation_keypom_args: Option<KeypomInjectedArgs>,

    /// Override the global root account that sub-accounts will have (near or testnet). This allows
    /// users to create specific drops that can create sub-accounts of a predefined root.
    /// For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then
    /// be `ACCOUNT.fayyr.near`
    pub root_account_id: Option<AccountId>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TimeConfig {
    /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub start: Option<u64>,

    /// Block timestamp that keys must be before. If None, keys can be used indefinitely
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub end: Option<u64>,

    /// Time interval between each key use. If None, there is no delay between key uses.
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub throttle: Option<u64>,

    /// Interval of time after the `start_timestamp` that must pass before a key can be used.
    /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
    /// With the throttle timestamp. It only pertains to the start timestamp and the current
    /// timestamp. The last_used timestamp is not taken into account.
    /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
    pub interval: Option<u64>,
}

/// Optional configurations for the drop such as metadata, deleting empty drops etc.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct DropConfig {
    /// Metadata for the given drop represented as a string. Most often, this will be JSON stringified.
    pub metadata: Option<DropMetadata>,
    /// Configurations for all the NFT keys in this drop. This contains info about royalties and metadata
    /// That each key will inherit
    pub nft_keys_config: Option<NFTKeyConfigurations>,

    /// Which users can add keys to the drop. The public sale config was moved out of the Keypom contract
    /// And now should be deployed on its own proxy contract that in turn performs any necessary sale logic
    /// And then fires a cross contract call to the Keypom contract to add keys
    pub add_key_allowlist: Option<HashSet<AccountId>>,

    /// Should the drop be automatically deleted when all the keys are used? This is defaulted to true and
    /// Must be overwritten
    pub delete_empty_drop: Option<bool>,

    /// How much extra allowance should be given to each key in the drop?
    /// This allows keys to be used for extra functionalities such as `nft_transfer`, `nft_approve`, etc.
    pub extra_allowance_per_key: Option<U128>
}
'''
'''--- contract/src/models/external/implementations.rs ---
use crate::*;

impl ExtAsset {
    /// Convert an `ExtAsset` into an `InternalAsset`
    pub fn to_internal_asset(&self) -> InternalAsset {
        match self {
            ExtAsset::FTAsset(ft_data) => InternalAsset::ft(InternalFTData::new(
                ft_data.ft_contract_id.clone(),
                ft_data.registration_cost.into(),
            )),
            ExtAsset::NFTAsset(nft_data) => InternalAsset::nft(InternalNFTData::new(
                nft_data.nft_contract_id.clone(),
            )),
            ExtAsset::FCAsset(method_data) => InternalAsset::fc(FCData::new(
                method_data.clone()
            )),
            ExtAsset::NearAsset(_) => InternalAsset::near
        }
    }

    /// Standard function to check how many tokens a given asset transfers per use
    pub fn get_tokens_per_use(&self) -> U128 {
        match self {
            ExtAsset::FTAsset(ft_data) => ft_data.ft_amount.into(),
            ExtAsset::NFTAsset(_) => U128(0),
            ExtAsset::NearAsset(near_data) => near_data.yoctonear.into(),
            ExtAsset::FCAsset(_) => U128(0)
        }
    }

    /// Standard function to query for the asset ID of the current external asset
    pub fn get_asset_id(&self) -> AssetId {
        match self {
            ExtAsset::FTAsset(ft_data) => ft_data.ft_contract_id.to_string(),
            ExtAsset::NFTAsset(nft_data) => nft_data.nft_contract_id.to_string(),
            ExtAsset::NearAsset(_) => NEAR_ASSET_ID.to_string(),
            ExtAsset::FCAsset(_) => {
                near_sdk::log!("FC Asset does not have an asset ID. THIS SHOULD NEVER HAPPEN");
                FALLBACK_FC_ASSET_ID.to_string()
            }
        }
    }
}

'''
'''--- contract/src/models/external/mod.rs ---
pub mod implementations;
pub mod models;

pub use implementations::*;
pub use models::*;
'''
'''--- contract/src/models/external/models.rs ---
use crate::*;

/// Represents the asset data including configs for a set amount of uses.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtAssetDataForUses {
    /// How many uses does this asset data apply to?
    pub uses: UseNumber,
    /// Which assets should be present for these uses
    pub assets: Vec<Option<ExtAsset>>,
    /// Any configurations for this set of uses
    pub config: Option<UseConfig>
}

/// Outlines the different asset types that can be used in drops. This is the external version of `InternalAsset`
/// And represents the data that is passed into and out of the Keypom contract
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ExtAsset {
    FTAsset(ExtFTData),
    NearAsset(ExtNEARData),
    NFTAsset(ExtNFTData),
    FCAsset(Vec<MethodData>)
}

/// Data going into or out of the Keypom contract representing the presence of fungible tokens as an asset for a drop
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtNEARData {
    /// How much $NEAR should be transferred as part of the asset claim
    pub yoctonear: U128
}

/// Data going into or out of the Keypom contract representing the presence of fungible tokens as an asset for a drop
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtFTData {
    /// The contract that the fungible tokens originate from
    pub ft_contract_id: AccountId,
    /// How much $NEAR (in yocto) it costs to register a new user on the fungible token contract
    pub registration_cost: U128,
    /// How many fungible tokens (in their smallest indivisible unit) should be transferred as part of the asset claim
    pub ft_amount: U128
}

/// Data going into or out of the Keypom contract representing the presence of non-fungible tokens as an asset for a drop
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtNFTData {
    /// The contract that the non fungible tokens originate from
    pub nft_contract_id: AccountId
}

/// Drop data being returned from view calls from Keypom
#[derive(BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtDrop {
    /// ID for this specific drop
    pub drop_id: DropId,
    /// Account ID who funded / owns the rights to this specific drop
    pub funder_id: AccountId,
    /// What is the maximum number of uses a given key can have in the drop?
    pub max_key_uses: UseNumber,

    pub asset_data: Vec<ExtAssetDataForUses>,

    pub nft_asset_data: Vec<InternalNFTData>,
    pub ft_asset_data: Vec<InternalFTData>,

    /// Keep track of different configuration options for all the uses of a key in a given drop
    pub drop_config: Option<DropConfig>,

    /// Keep track of the next nonce to give out to a key
    pub next_key_id: u64
}

/// Data for each key coming in (public key, password, metadata, owner etc.)
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtKeyData {
    /// What is the public key?
    pub public_key: PublicKey,
    /// A map outlining what the password should be for any given use.
    /// The password here should be a double hash and when claim is called,
    /// The user arguments are hashed and compared to the password here (i.e user passes in single hash)
    pub password_by_use: Option<HashMap<UseNumber, String>>,
    /// Metadata for the given key represented as a string. Most often, this will be JSON stringified.
    pub metadata: Option<String>,
    /// What account ID owns the given key (if any)
    pub key_owner: Option<AccountId>
}
'''
'''--- contract/src/models/internal/implementations.rs ---
use crate::*;

impl InternalDrop {
    /// Convert an `InternalDrop` into an `ExtDrop`
    pub fn to_external_drop(&self, drop_id: DropId) -> ExtDrop {
        let mut nft_list = vec![];
        let mut ft_list = vec![];

        // Loop through all the values in the asset_by_id hashmap and add them to the corresponding vectors
        self.asset_by_id.values().for_each(|asset| {
            match asset {
                InternalAsset::nft(nft_asset) => nft_list.push(nft_asset.clone()),
                InternalAsset::ft(ft_asset) => ft_list.push(ft_asset.clone()),
                _ => {}
            }
        });

        let mut asset_data = vec![];

        for internal_asset in self.asset_data_for_uses.iter() {
            
            let mut ext_assets = vec![];
            for asset_metadata in internal_asset.assets_metadata.iter() {
                let internal_asset = self.asset_by_id.get(&asset_metadata.asset_id).expect("no asset found");
                ext_assets.push(internal_asset.to_external_asset(&asset_metadata.tokens_per_use));
            }

            asset_data.push(ExtAssetDataForUses { 
                uses: internal_asset.uses,
                assets: ext_assets, 
                config: internal_asset.config.clone()
            })
        }

        ExtDrop {
            drop_id,
            asset_data,
            nft_asset_data: nft_list,
            ft_asset_data: ft_list,
            drop_config: self.config.clone(),
            funder_id: self.funder_id.clone(),
            max_key_uses: self.max_key_uses,
            next_key_id: self.next_key_id
        }
    }
}

impl InternalAsset {
    /// Convert an `InternalAsset` into an `ExtAsset`
    pub fn to_external_events_asset(&self, tokens_per_use: &Option<U128>) -> Option<ExtAssetForEvents> {
        match self {
            InternalAsset::ft(ft_data) => Some(ExtAssetForEvents::FTAsset(ExtFTData {
                ft_contract_id: ft_data.contract_id.clone(),
                registration_cost: ft_data.registration_cost.into(),
                // FTs should ALWAYS have a tokens_per_use value
                ft_amount: tokens_per_use.unwrap()
            })),
            InternalAsset::nft(nft_data) => Some(ExtAssetForEvents::NFTAsset(ExtNFTData {
                nft_contract_id: nft_data.contract_id.clone()
            })),
            InternalAsset::fc(fc_data) => Some(ExtAssetForEvents::FCAsset(
                fc_data.methods.iter().map(|method| ExtFCDataForEvents { 
                    receiver_id: method.receiver_id.clone(), 
                    method_name: method.method_name.clone(), 
                    attached_deposit: method.attached_deposit, 
                    attached_gas: method.attached_gas 
                }).collect()
            )),
            InternalAsset::near => Some(ExtAssetForEvents::NearAsset(ExtNEARData { yoctonear: tokens_per_use.unwrap() })),
            InternalAsset::none => None
        }
    }

    /// Convert an `InternalAsset` into an `ExtAsset`
    pub fn to_external_asset(&self, tokens_per_use: &Option<U128>) -> Option<ExtAsset> {
        match self {
            InternalAsset::ft(ft_data) => Some(ExtAsset::FTAsset(ExtFTData {
                ft_contract_id: ft_data.contract_id.clone(),
                registration_cost: ft_data.registration_cost.into(),
                // FTs should ALWAYS have a tokens_per_use value
                ft_amount: tokens_per_use.unwrap()
            })),
            InternalAsset::nft(nft_data) => Some(ExtAsset::NFTAsset(ExtNFTData {
                nft_contract_id: nft_data.contract_id.clone()
            })),
            InternalAsset::fc(fc_data) => Some(ExtAsset::FCAsset(fc_data.methods.clone())),
            InternalAsset::near => Some(ExtAsset::NearAsset(ExtNEARData { yoctonear: tokens_per_use.unwrap() })),
            InternalAsset::none => None
        }
    }

    /// Standard function for claiming an asset regardless of its type
    /// This will return a promise for every asset that will be resolved in a standard callback
    pub fn claim_asset(
        &mut self, 
        receiver_id: &AccountId, 
        tokens_per_use: &Option<Balance>,
        fc_args: AssetSpecificFCArgs,
        drop_id: DropId,
        key_id: String,
        funder_id: AccountId
    ) -> Option<Promise> {
        match self {
            InternalAsset::ft(ref mut ft_data) => {
                return ft_data.claim_ft_asset(receiver_id, &tokens_per_use.unwrap())
            },
            InternalAsset::nft(ref mut nft_data) => {
                return nft_data.claim_nft_asset(receiver_id)
            },
            InternalAsset::fc(ref mut fc_data) => {
                return fc_data.claim_fc_asset(fc_args, receiver_id.clone(), drop_id, key_id, funder_id)
            },
            InternalAsset::near => {
                return Some(Promise::new(receiver_id.clone()).transfer(tokens_per_use.unwrap()));
            },
            InternalAsset::none => {
                return None;
            }
        }
    }

    /// Standard function outlining what should happen if a specific claim failed
    /// This should return the amount of $NEAR that should be refunded to the user's balance
    /// In addition, any internal state changes should be made (i.e balance_available incremented for FTs)
    pub fn on_failed_claim(&mut self, tokens_per_use: &Option<String>) -> Balance {
        match self {
            InternalAsset::ft(ref mut ft_data) => {
                let ft_to_refund = &tokens_per_use.as_ref().unwrap().parse::<u128>().unwrap();
                near_sdk::log!("Failed claim for FT asset. Refunding {} to the user's balance and incrementing balance available by {}", 0, ft_to_refund);
                ft_data.add_to_balance_avail(ft_to_refund);
                ft_data.registration_cost
            },
            InternalAsset::nft(ref mut nft_data) => {
                let token_id = &tokens_per_use.as_ref().unwrap();
                near_sdk::log!("Failed claim NFT asset with Token ID {}", token_id);
                nft_data.add_to_token_ids(token_id);
                0
            },
            InternalAsset::near => {
                let near_tokens = tokens_per_use.as_ref().unwrap().parse::<u128>().unwrap();
                near_sdk::log!("Failed claim for NEAR asset. Refunding {} to the user's balance", near_tokens);
                near_tokens
            },
            InternalAsset::fc(_) => {
                near_sdk::log!("Failed claim for FC asset. Cannot refund.");
                0
            },
            InternalAsset::none => {
                near_sdk::log!("Failed claim for null asset. SHOULD NEVER HAPPEN");
                0
            }
        }
    }

    /// Standard function to check whether an asset is empty or not
    pub fn is_empty(&self) -> bool {
        match self {
            InternalAsset::ft(ft) => !ft.enough_balance(&1),
            InternalAsset::nft(nft) => nft.is_empty(),
            InternalAsset::fc(_) => true,
            InternalAsset::near => true,
            InternalAsset::none => true
        }
    }

    /// Standard function for refunding assets
    /// This does not include any ext assets such as FTs or NFTs.
    /// This simply refunds the funder for the $NEAR cost associated with 1 key use for the given asset
    pub fn get_yocto_refund_amount(&self, tokens_per_use: &Option<Balance>) -> Balance {
        match self {
            InternalAsset::ft(ft_data) => {
                return ft_data.registration_cost;
            },
            InternalAsset::nft(_) => 0,
            InternalAsset::near => {
                return tokens_per_use.unwrap();
            },
            InternalAsset::fc(fc_data) => fc_data.get_yocto_refund_amount(),
            InternalAsset::none => 0
        }
    }

    /// Standard function to query how much gas should be attached to a given claim
    pub fn get_total_required_gas(&self) -> Gas {
        match self {
            InternalAsset::ft(ft_data) => ft_data.get_total_required_gas(),
            InternalAsset::nft(nft_data) => nft_data.get_total_required_gas(),
            InternalAsset::fc(fc_data) => fc_data.get_total_required_gas(),
            InternalAsset::near => GAS_FOR_NEAR_TRANSFER,
            InternalAsset::none => GAS_FOR_NONE_ASSET
        }
    }

    /// Standard function to query how much gas it takes for 1 claim of a given asset
    pub fn get_required_asset_gas(&self) -> Gas {
        match self {
            InternalAsset::ft(ft_data) => ft_data.get_required_asset_gas(),
            InternalAsset::nft(nft_data) => nft_data.get_required_asset_gas(),
            InternalAsset::fc(fc_data) => fc_data.get_required_asset_gas(),
            InternalAsset::near => GAS_FOR_NEAR_TRANSFER,
            InternalAsset::none => GAS_FOR_NONE_ASSET
        }
    }
}
'''
'''--- contract/src/models/internal/mod.rs ---
pub mod implementations;
pub mod models;

pub use implementations::*;
pub use models::*;
'''
'''--- contract/src/models/internal/models.rs ---
use crate::*;

/// Internal drop data that is stored in the contract
#[derive(BorshDeserialize, BorshSerialize)]
pub struct InternalDrop {
    /// Account ID who funded / owns the rights to this specific drop
    pub funder_id: AccountId,

    /// What is the maximum number of uses a given key can have in the drop?
    pub max_key_uses: UseNumber,
    /// Map an asset ID to a specific asset. This is a hyper optimization so the asset data isn't repeated in the contract
    pub asset_by_id: UnorderedMap<AssetId, InternalAsset>,
    /// For every use, keep track of what assets there are (in order)
    pub asset_data_for_uses: Vec<InternalAssetDataForUses>,

    /// Set of public keys associated with this drop mapped to their specific key information.
    pub key_info_by_token_id: UnorderedMap<TokenId, InternalKeyInfo>,
    /// Keep track of the next nonce to give out to a key
    pub next_key_id: u64,

    /// Keep track of different configuration options for all the uses of a key in a given drop
    pub config: Option<DropConfig>
}

/// Keep track of different configuration options for each key in a drop
#[derive(BorshDeserialize, BorshSerialize)]
pub struct InternalKeyInfo {
    /// Current public key that is mapped to this key info
    pub pub_key: PublicKey,

    /// How many uses this key has left. Once 0 is reached, the key is deleted
    pub remaining_uses: UseNumber,

    /// Owner of the key
    pub owner_id: Option<AccountId>,

    /// When was the last time the key was used
    pub last_claimed: u64,

    /// Metadata for the current key
    pub metadata: Option<String>,
    pub pw_by_use: Option<HashMap<UseNumber, Vec<u8>>>,

    /// List of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,

    /// The next approval ID to give out. 
    pub next_approval_id: u64,
}

/// Outlines the asset data for a set of uses
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug)]
pub struct InternalAssetDataForUses {
    /// How many uses does this asset data apply to?
    pub uses: UseNumber,
    /// Any configurations for this set of uses
    pub config: Option<UseConfig>,
    /// The actual assets themselves (ID + tokens)
    pub assets_metadata: Vec<AssetMetadata>,
    /// The amount of gas required to claim this set of assets
    pub required_asset_gas: Gas
}

impl From<&ExtAssetDataForUses> for InternalAssetDataForUses {
    fn from(ext_asset_data: &ExtAssetDataForUses) -> Self {
        let mut assets_metadata = vec![];

        // Keep track of the total gas across all assets in the current use
        let mut total_required_asset_gas: Gas = Gas(0);

        let mut fc_idx = 0;
        for ext_asset in &ext_asset_data.assets {
            // Every asset has a gas cost associated. We should add that to the total gas.
            let internal_asset = ext_asset_to_internal(ext_asset.as_ref());
            let gas_for_asset = internal_asset.get_total_required_gas();
            total_required_asset_gas += gas_for_asset;

            // If the external asset is of type FCData, the asset ID will be the incrementing number
            // Otherwise, it will be the asset ID specified
            let asset_id = if let Some(ExtAsset::FCAsset(_)) = ext_asset {
                fc_idx += 1;
                format!("{}{}", FC_ASSET_PREFIX, fc_idx)
            } else {
                ext_asset.as_ref().and_then(|a| Some(a.get_asset_id())).unwrap_or(NONE_ASSET_ID.to_string())
            };

            assets_metadata.push(AssetMetadata {
                asset_id: asset_id.clone(),
                tokens_per_use: ext_asset.as_ref().and_then(|a| Some(a.get_tokens_per_use()))
            });
        }

        Self {
            uses: ext_asset_data.uses,
            config: ext_asset_data.config.clone(),
            assets_metadata,
            required_asset_gas: total_required_asset_gas
        }
    }
}

/// Outlines the different asset types that can be used in drops. This is the internal version of `ExtAsset`
/// And represents the data that is stored inside the Keypom contract to keep track of assets
#[allow(non_camel_case_types)]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum InternalAsset {
    ft(InternalFTData),
    nft(InternalNFTData),
    fc(FCData),
    near,
    none
}

/// Metadata corresponding to a specific asset. This keeps track of the ID and optionally tokens being transferred per use
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug)]
pub struct AssetMetadata {
    /// What asset is mapped to this specific use
    pub asset_id: AssetId,
    /// How many tokens should be transferred in this use?
    /// This is only relevant for FT and $NEAR assets
    pub tokens_per_use: Option<U128>,
}

/// Contract metadata structure
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractSourceMetadata {
    /// Commit hash being used for the currently deployed wasm. If the contract is not open-sourced, this could also be a numbering system for internal organization / tracking such as "1.0.0" and "2.1.0".
    pub version: String,
    /// Link to open source code such as a Github repository or a CID to somewhere on IPFS.
    pub link: String,
}

/// Fee Structures for drops and keys
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct KeypomFees {
    /// How much $NEAR users are charged for creating a drop
    pub per_drop: u128,
    /// How much $NEAR users are charged for adding a key
    pub per_key: u128,
}

/// Data returned from the `before_claim_logic` function
pub struct BeforeClaimData {
    pub drop_id: DropId,
    pub key_id: u64,
    pub funder_id: AccountId,
    /// What is the token ID for the key being claimed
    pub token_id: TokenId,
    /// How much gas the assets in the given use require
    pub required_asset_gas: Gas,
    /// For CAAC, there needs to be a root for all accounts. By default, this is the contract's global root account (i.e `near` or `testnet`) but if otherwise specified in the use or drop config, it will be that.
    pub root_account_id: AccountId,
    /// When calling `create_account` on the root account, which keypom args should be attached to the payload.
    pub account_creation_keypom_args: Option<KeypomInjectedArgs>,
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKeys {
    KeyInfoByPk { drop_id_hash: CryptoHash },
    AssetById { drop_id_hash: CryptoHash },
    TokensPerOwnerInner { account_id_hash: CryptoHash },
    DropIdsByFunderInner { account_id_hash: CryptoHash },
    DropIdsByFunder,
    FeesPerUser,
    ContractMetadata,
    TokensPerOwner,
    DropById,
    TokenIdByPk,
    UserBalances
}
'''
'''--- contract/src/models/mod.rs ---
pub mod external;
pub mod internal;
pub mod standard;
pub mod config;

pub use config::*;
pub use external::*;
pub use internal::*;
pub use standard::*;
'''
'''--- contract/src/models/standard.rs ---
use crate::*;

/// Information about a specific public key.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtKeyInfo {
    /// How much Gas should be attached when the key is used to call `claim` or `create_account_and_claim`.
   /// It is up to the smart contract developer to calculate the required gas (which can be done either automatically on the contract or on the client-side).
   pub required_gas: String,

   /// yoctoNEAR$ amount that will be sent to the account that claims the linkdrop (either new or existing)
   /// when the key is successfully used.
   pub yoctonear: U128,

   /// If using the FT standard extension, a set of FTData can be linked to the public key
   /// indicating that all those assets will be sent to the account that claims the linkdrop (either new or
   /// existing) when the key is successfully used.
   pub ft_list: Vec<FTListData>, 
   
   /// If using the NFT standard extension, a set of NFTData can be linked to the public key
   /// indicating that all those assets will be sent to the account that claims the linkdrop (either new or
   /// existing) when the key is successfully used.
   pub nft_list: Vec<NFTListData>, 

   /* CUSTOM */
   pub drop_id: DropId,
   pub pub_key: PublicKey,
   pub token_id: TokenId,
   pub owner_id: AccountId,
   pub fc_list: Vec<FCData>,
   
   pub uses_remaining: UseNumber
}

/// Data outlining Fungible Tokens that should be sent to the claiming account
/// (either new or existing) when a key is successfully used.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FTListData {
    /// The number of tokens to transfer, wrapped in quotes and treated
    /// like a string, although the number will be stored as an unsigned integer
    /// with 128 bits.
    pub amount: String,

    /// The valid NEAR account indicating the Fungible Token contract.
    pub contract_id: String
}

/// Data outlining a specific Non-Fungible Token that should be sent to the claiming account
/// (either new or existing) when a key is successfully used.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTListData {
    /// the id of the token to transfer
    pub token_id: String,

    /// The valid NEAR account indicating the Non-Fungible Token contract.
    pub contract_id: String
}

'''
'''--- contract/src/nft_keys/approval.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Allow a specific account ID to transfer a token on your behalf
    #[payable]
    pub fn nft_approve(&mut self, token_id: Option<TokenId>, account_id: AccountId, msg: Option<String>) {
        self.assert_no_global_freeze();

        let sender_id = env::predecessor_account_id();
        let sender_pk = env::signer_account_pk();

        // Token ID is either from sender PK or passed in
        let token_id = self.token_id_by_pk.get(&sender_pk).unwrap_or_else(|| token_id.expect("Token ID not provided"));
        let drop_id = parse_token_id(&token_id).unwrap().0;
        
        // Get drop in order to get key info
        let mut drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let mut key_info = drop.key_info_by_token_id.get(&token_id).expect("Key info not found");

        // Check that the sender is the owner of the token.
        // If the token is owned by keypom, decrement the key's allowance
        check_key_owner(sender_id, &key_info);

        //get the next approval ID if we need a new approval
        let approval_id: u64 = key_info.next_approval_id;
        key_info.approved_account_ids.insert(account_id.clone(), approval_id);
        key_info.next_approval_id += 1;

        // Reinsert key info mapping to NFT and then add token ID mapping to public key
        drop.key_info_by_token_id.insert(&token_id, &key_info);
        self.drop_by_id.insert(&drop_id, &drop);
        
        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to. 
        if let Some(msg) = msg {
            // Defaulting GAS weight to 1, no attached deposit, and no static GAS to attach.
            Promise::new(account_id)
                .function_call_weight(
                    "nft_on_approve".to_string(),
                    json!({ "token_id": token_id, "owner_id": key_info.owner_id.unwrap_or(env::current_account_id()), "approval_id": approval_id, "msg": msg }).to_string().into(),
                    0,
                    Gas(0),
                    GasWeight(1),
                ).as_return();
        }
    }

    //check if the passed in account has access to approve the token ID
	pub fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the key info object from the token_id
        let drop_id = parse_token_id(&token_id).unwrap().0;
    
        // Get drop in order to get key info
        let drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key info not found");
        
        //get the approval number for the passed in account ID
		let approval = key_info.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
			if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
				return approval_id == *approval;
            //if there was no approval_id passed into the function, we simply return true
			} else {
				return true;
			}
        //if there was no approval ID found for the account ID, we simply return false
		} else {
			return false;
		}
    }

    //revoke a specific account from transferring the token on your behalf 
    #[payable]
    pub fn nft_revoke(&mut self, token_id: Option<TokenId>, account_id: AccountId) {
        self.assert_no_global_freeze();
        
        let sender_id = env::predecessor_account_id();
        let sender_pk = env::signer_account_pk();

        // Token ID is either from sender PK or passed in
        let token_id = self.token_id_by_pk.get(&sender_pk).unwrap_or_else(|| token_id.expect("Token ID not provided"));
        let drop_id = parse_token_id(&token_id).unwrap().0;
        
        // Get drop in order to get key info
        let mut drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let mut key_info = drop.key_info_by_token_id.get(&token_id).expect("Key info not found");

        // Check that the sender is the owner of the token.
        // If the token is owned by keypom, decrement the key's allowance
        check_key_owner(sender_id, &key_info);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if key_info
            .approved_account_ids
            .remove(&account_id)
            .is_some()
        {
            // Reinsert key info mapping to NFT and then add token ID mapping to public key
            drop.key_info_by_token_id.insert(&token_id, &key_info);
            self.drop_by_id.insert(&drop_id, &drop);
        }
    }

}

/// Check that the sender is either the owner of the token or the current account (meaning they signed with the key).
pub(crate) fn check_key_owner(sender_id: AccountId, key_info: &InternalKeyInfo) {
    if sender_id != env::current_account_id() {
        require!(
            key_info.owner_id.as_ref().unwrap_or(&env::current_account_id()) == &sender_id,
            "Sender does not own this token"
        );
    }
}
'''
'''--- contract/src/nft_keys/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        // Return the length of the token metadata by ID
        U128(self.token_id_by_pk.len() as u128)
    }

    /// Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<ExtNFTKey> {
        // Where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        // Iterate through each token using an iterator
        self.token_id_by_pk.iter()
            // Skip to the index we specified in the start variable
            .skip(start as usize) 
            // Take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            // We'll map the token IDs which are strings into Json Tokens
            .map(|(_, token_id)| self.nft_token(token_id).unwrap())
            // Since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    /// Get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        // Get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        // If there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            // If there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    /// Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<ExtNFTKey> {
        // Get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        // If there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            // If there is no set of tokens, we'll simply return an empty vector. 
            return vec![];
        };

        // Where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        // Iterate through the keys vector
        tokens.iter()
            // Skip to the index we specified in the start variable
            .skip(start as usize) 
            // Take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            // We'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            // Since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}
'''
'''--- contract/src/nft_keys/internal.rs ---
use std::convert::TryFrom;

use crate::*;

#[near_bindgen]
impl Keypom {
    // Add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKeys::TokensPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_string(&account_id.to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID. 
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        near_sdk::log!("Attemping to Transfer using Account ID: {}", account_id);
        near_sdk::log!("TOKENS_FOR_OWNER contains funder?: {:?}", self.tokens_per_owner.contains_key(&AccountId::try_from("keypom.test.near".to_string()).unwrap()));
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
        //if the token set is not empty, we simply insert it back for the account ID. 
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: Option<AccountId>,
        token_id: String,
        approval_id: Option<u64>,
        new_public_key: PublicKey
    ) -> AccountId {
        let drop_id = parse_token_id(&token_id).unwrap().0;
        
        // Get drop in order to get key info (and royalties if applicable)
        let mut drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        
        // Get key info (will overwrite mapping to new key info after)
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key info not found");
        let cur_account = env::current_account_id();
        let old_owner = key_info.owner_id.as_ref().unwrap_or(&cur_account);
        if &sender_id != old_owner {
            //if the sender doesn't equal the owner, we check if the sender is in the approval list
            //if the token's approved account IDs doesn't contain the sender, we panic
            if !key_info.approved_account_ids.contains_key(&sender_id) {
                env::panic_str("Unauthorized");
            }

            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included
            if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
                let actual_approval_id = key_info
                    .approved_account_ids
                    .get(&sender_id)
                    //if the sender isn't in the map, we panic
                    .expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }

        // Remove token from old owner if there is one
        if let Some(owner) = key_info.owner_id.as_ref() {
            self.internal_remove_token_from_owner(owner, &token_id);
        }

        // Add token to new receiver if there is one
        if let Some(new_owner) = receiver_id.as_ref() {
            self.internal_add_token_to_owner(new_owner, &token_id);
        }

        // Remove old public key from mapping
        let old_pub_key = key_info.pub_key.clone();
        self.token_id_by_pk.remove(&old_pub_key);

        // Generate new key info struct
        let new_key_info = InternalKeyInfo {
            owner_id: receiver_id.clone(),
            pub_key: new_public_key.clone(),
            approved_account_ids: Default::default(),
            remaining_uses: key_info.remaining_uses,
            next_approval_id: key_info.next_approval_id,
            metadata: key_info.metadata,
            last_claimed: key_info.last_claimed,
            pw_by_use: key_info.pw_by_use
        };

        // Reinsert key info mapping to NFT and then add token ID mapping to public key
        drop.key_info_by_token_id.insert(&token_id, &new_key_info);
        self.drop_by_id.insert(&drop_id, &drop);
        
        let key_exists = self.token_id_by_pk.insert(&new_public_key, &token_id);
        assert!(key_exists.is_none(), "Key already exists");

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let event_logs = vec![
            EventLog {
                standard: NFT_STANDARD_NAME.to_string(),
                version: NFT_METADATA_SPEC.to_string(),
                event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                    authorized_id: authorized_id.clone(),
                    old_owner_id: old_owner.to_string(),
                    new_owner_id: receiver_id.as_ref().unwrap_or(&env::current_account_id()).to_string(),
                    token_ids: vec![token_id.to_string()],
                    memo: None,
                }]),
            },
            EventLog {
                standard: KEYPOM_STANDARD_NAME.to_string(),
                version: KEYPOM_STANDARD_VERSION.to_string(),
                event: EventLogVariant::KeyTransfer(TransferKeyLog {
                    authorized_id,
                    old_owner_id: old_owner.to_string(),
                    new_owner_id: receiver_id.as_ref().unwrap_or(&env::current_account_id()).to_string(),
                    old_public_key: (&old_pub_key).into(),
                    new_public_key: (&new_public_key).into(),
                    drop_id,
                    token_id
                })
            }
        ];

        // Delete the original key
        Promise::new(env::current_account_id()).delete_key(old_pub_key);

        // Get the allowance that should be transferred to the new key
        let mut total_cost_for_key: Balance = 0;
        let mut total_allowance_for_key: Balance = drop.config.as_ref().and_then(|config| config.extra_allowance_per_key).unwrap_or(U128(0)).0;
        get_total_costs_for_key(
            &mut total_cost_for_key,
            &mut total_allowance_for_key,
            key_info.remaining_uses,
            &drop.asset_by_id,
            &drop.asset_data_for_uses,
        );

        // Add the new key with the corresponding allowance
        Promise::new(env::current_account_id()).add_access_key(
            new_public_key.clone(),
            total_allowance_for_key,
            env::current_account_id(),
            ACCESS_KEY_METHOD_NAMES.to_string(),
        );

        // Log the transfer events
        log_events(event_logs);
        
        old_owner.clone()
    }
} 
'''
'''--- contract/src/nft_keys/metadata.rs ---
use std::collections::HashMap;

use near_sdk::json_types::Base64VecU8;

use crate::*;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

/// Keep track of different configuration options for each key in a drop
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTKeyConfigurations {
    /// Metadata that all the NFTs in this drop will have
    pub token_metadata: Option<TokenMetadata>,

    /// Royalties that all NFTs in this drop will have
    pub royalties: Option<HashMap<AccountId, u32>>,
}

//The Json token is what will be returned from view calls. 
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ExtNFTKey {
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

#[near_bindgen]
impl Keypom {
    pub fn nft_metadata(&self) -> NFTContractMetadata {
        NFTContractMetadata {
            spec: String::from("nft-1.0.0"),
            name: String::from("Keypom"),
            symbol: String::from("KPOM"),
            icon: Some(String::from("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAQBCAMAAACDnwgUAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAABYkAAAWJAW1onfoAAAL0UExURUdwTP///////////////////////+j4/f///////////////////////////////////////xYfMuP2++P2/BUdMXPW8+j4/OX3/OX2/Or5/er4/P+p3eL2++f4/Ov5/OT3/PH7/fn9//z//+b3++b3/PT7/u35/ej3/P7//+/6/fX+//v+/+35/f3//+H2/Pf+//L7/u76/ef3++36/XPX9PT8/+z5/fn+//T8/uH1++bt+O79++P3/O72+/H9/+r1++n3/OX2/O/8/+Du/+f2/OH5/+Du+fT9/+vz+9by++T1++j1+/P7/djx+un3++fz+uz1++33/B8qPejs+N3x+uz7/9vw+enz+ur7/+j6/9nz++/5/ers+Ob6/yEtQNv4//f9/uDw+ub4/uP5/7+/5+Tt+Nj3/8O+59/4/yQwQ8q75iY0SM665ca85t7v+XrV85TN743P8Ov3/KDI7ZfL7uTw+X3U8rjB6bvA6Cw4S4DT8tvx+rXC6d+04qPH7C47T+Lv+ZHN79y14+38//et34nQ8NG55NS45KnG64PS8abG67LD6ZrK7fL5/eWy4fqs3ur5/f2r3uKz4hEZLJ32+vGu353J7dX2/+P0+9m24+2w4KvF6jA/U++v4IbR8XbW9LDD6q7E6v+14fSt39e35P+85PX8/uiy4RgiNRwmOeqx4N30+//D5vHy9//L6f+v367l973q+UNEWktUZd3j9J/g9pDd9WJtf8zn90V1jerg8xUeMYPb9eDj5r7f9TBPZTAxR8ju+ldfcu3R7dDd8/rZ8NHx+/no9t7E6arU8d3V72i/26Gpsvn2/NHa4LzW7uzA5nd+jF6tyG1xhTtjeszG6s/S7sTIzb7K7Oj5/bPByv70++KZyG7L54Jhg4KHmomOma20vGdRb1GSq42XpPW546t4oEyFn/n8/rmlze+i0piep5ev0nOFm5VxlFedt9CUwMOHs4Sat3+52GuMqsDQ2M6r1Ji94Xiox6eYvqqNsE9ImGkAAAARdFJOUwCAoL9bEO/+3yBAcJAwz7DQ26mZXAADokxJREFUeNrsvW2MXOWVLnoS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"),),
            base_uri: Some(String::from("https://cloudflare-ipfs.com/ipfs/")),
            reference: None,
            reference_hash: None,
        }
    }
}
'''
'''--- contract/src/nft_keys/mod.rs ---
mod internal;
mod enumeration;
mod metadata;
mod nft_core;
mod royalty;
mod approval;

pub use metadata::*;
'''
'''--- contract/src/nft_keys/nft_core.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Transfers an NFT key from one user to another.
    /// If *token_id* is passed in, we use that token ID. Otherwise, we use the token ID associated with the sender's public key
    /// If *receiver_id* is passed in, we transfer the token to that account. Otherwise, we transfer the token to the current account.
    /// This functionality is added in case you want to transfer to someone who doesn't have a NEAR wallet.
    /// The *memo* field is the new public key that the token will be associated with.
    #[payable]
    pub fn nft_transfer(
        &mut self,
        token_id: Option<TokenId>,
        receiver_id: Option<AccountId>,
        approval_id: Option<u64>,
        memo: PublicKey,
    ) {
        self.assert_no_global_freeze();
        
        let sender_id = env::predecessor_account_id();
        let sender_pk = env::signer_account_pk();

        // Token ID is either from sender PK or passed in
        let token_id = self.token_id_by_pk.get(&sender_pk).unwrap_or_else(|| token_id.expect("Token ID not provided"));
        self.internal_transfer(sender_id, receiver_id, token_id, approval_id, memo);
    }

    /// Get the token object info for a specific token ID
    pub fn nft_token(&self, token_id: TokenId) -> Option<ExtNFTKey> {
        let drop_id = parse_token_id(&token_id).unwrap().0;

        if let Some(drop) = self.drop_by_id.get(&drop_id) {
            let NFTKeyConfigurations { token_metadata, royalties } = drop.config.and_then(|c| c.nft_keys_config).unwrap_or(NFTKeyConfigurations {
                token_metadata: None,
                royalties: None,
            });

            if let Some(key_info) = drop.key_info_by_token_id.get(&token_id) {
                return Some(ExtNFTKey {
                    token_id,
                    owner_id: key_info.owner_id.unwrap_or(env::current_account_id()),
                    metadata: token_metadata.unwrap_or(TokenMetadata {
                        title: Some(String::from("Keypom Access Key")),
                        description: Some(String::from("Keypom is pretty lit")),
                        media: Some(String::from("bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq")),
                        media_hash: None,
                        copies: None,
                        issued_at: None,
                        expires_at: None,
                        starts_at: None,
                        updated_at: None,
                        extra: None,
                        reference: None,
                        reference_hash: None,
                    }),
                    approved_account_ids: key_info.approved_account_ids.clone(),
                    royalty: royalties.unwrap_or_default(),
                })
            }
        }
        
        return None;
    }
}
'''
'''--- contract/src/nft_keys/royalty.rs ---
use std::collections::HashMap;

use crate::*;

/// The maximum number of people that can be paid out to in a single transaction
const MAX_LEN_PAYOUT: u32 = 10;

#[near_bindgen]
impl Keypom {
    /// Transfers an NFT key from one user to another and returns the payout object that should be payed given the passed in balance.
    /// If *token_id* is passed in, we use that token ID. Otherwise, we use the token ID associated with the sender's public key
    /// If *receiver_id* is passed in, we transfer the token to that account. Otherwise, we transfer the token to the current account.
    /// This functionality is added in case you want to transfer to someone who doesn't have a NEAR wallet.
    /// The *memo* field is the new public key that the token will be associated with.
    #[payable]
    pub fn nft_transfer_payout(
        &mut self,
        receiver_id: Option<AccountId>,
        token_id: Option<TokenId>,
        approval_id: Option<u64>,
        memo: PublicKey,
        balance: U128,
        max_len_payout: Option<u32>,
    ) -> Payout {
        self.assert_no_global_freeze();
        
        let sender_id = env::predecessor_account_id();
        let sender_pk = env::signer_account_pk();
        // Token ID is either from sender PK or passed in
        let token_id = self.token_id_by_pk.get(&sender_pk).unwrap_or_else(|| token_id.expect("Token ID not provided"));
        
        // Get drop in order to get key info and royalties
        let drop_id = parse_token_id(&token_id).unwrap().0;
        let drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        
        // Get royalties from key info
        let default_royalty = &HashMap::new();
        let nft_royalty = drop.config.as_ref().and_then(|c| c.nft_keys_config.as_ref()).and_then(|c| c.royalties.as_ref()).unwrap_or(default_royalty);

        // Perform the transfer and then calculate payouts
        let old_owner_id = self.internal_transfer(sender_id, receiver_id, token_id, approval_id, memo);
        
        calculate_payouts(old_owner_id, nft_royalty.clone(), u128::from(balance), max_len_payout.unwrap_or(MAX_LEN_PAYOUT))
    }

    /// Calculates the payout for a token given the passed in balance.
    pub fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: Option<u32>) -> Payout {
        //get the key info object from the token_id
        let drop_id = parse_token_id(&token_id).unwrap().0;
    
        let drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        let default_royalty = &HashMap::new();
        let nft_royalty = drop.config.as_ref().and_then(|c| c.nft_keys_config.as_ref()).and_then(|c| c.royalties.as_ref()).unwrap_or(default_royalty);
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key info not found");

        calculate_payouts(key_info.owner_id.unwrap_or(env::current_account_id()), nft_royalty.clone(), u128::from(balance), max_len_payout.unwrap_or(MAX_LEN_PAYOUT))
	}
}

/// Helper function to convert a royalty percentage and amount to a payout
pub(crate) fn calculate_payouts(owner_id: AccountId, royalties: HashMap<AccountId, u32>, balance: u128, max_len_payout: u32) -> Payout {        
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalties.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalties.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance),
        );

        //return the payout object
        payout_object
}

// Convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}
'''
'''--- contract/src/owner.rs ---
use crate::*;
use near_sdk::promise_result_as_success;

#[near_bindgen]
impl Keypom {
    /// Set the contract metadata with a spec and link
    pub fn set_contract_metadata(&mut self, contract_metadata: ContractSourceMetadata) {
        self.assert_owner();
        self.contract_metadata.replace(&contract_metadata);
    }

    /// Set the desired linkdrop contract to interact with
    pub fn set_root_account(&mut self, root_account: AccountId) {
        self.assert_owner();
        self.root_account = root_account;
    }

    /// Set the desired contract fees
    pub fn set_fees(&mut self, drop_fee: Option<U128>, key_fee: Option<U128>) {
        self.assert_owner();
        self.fee_structure = KeypomFees {
            per_drop: drop_fee.map(|x| x.0).unwrap_or(self.fee_structure.per_drop),
            per_key: key_fee.map(|x| x.0).unwrap_or(self.fee_structure.per_key),
        };
    }

    /// Set the desired linkdrop contract to interact with
    pub fn set_fees_per_user(&mut self, account_id: AccountId, drop_fee: U128, key_fee: U128) {
        self.assert_owner();
        self.fees_per_user
            .insert(&account_id, &KeypomFees {
                per_drop: drop_fee.0,
                per_key: key_fee.0,
            });
    }

    /// Set the contract to be frozen thus not allowing any drops to be created or keys added
    pub fn freeze_contract(&mut self) {
        self.assert_owner();
        self.global_freeze = true
    }
    
    /// Set the contract to be unfrozen thus resuming the ability for drops and keys to be created
    pub fn unfreeze_contract(&mut self) {
        self.assert_owner();
        self.global_freeze = false;
    }

    /// Withdraw the fees collected to the passed in Account Id
    pub fn withdraw_fees(&mut self, withdraw_to: AccountId) -> Promise {
        self.assert_owner();
        let amount = self.fees_collected;
        self.fees_collected = 0;

        Promise::new(withdraw_to)
            .transfer(amount)
            .then(Self::ext(env::current_account_id()).on_withdraw_fees(amount))
    }

    /// Callback for withdrawing fees on the contract
    #[private]
    pub fn on_withdraw_fees(&mut self, fees_collected: u128) -> bool {
        let result = promise_result_as_success();

        // If something went wrong, set the fees collected again
        if result.is_none() {
            self.fees_collected += fees_collected;
            return false;
        }

        true
    }

    /// Helper method to check if the predecessor is the current contract owner
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.contract_owner_id,
            "Only the contract owner can call this function"
        );
    }
}
'''
'''--- contract/src/user_balances.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Allows users to add to their balance. This is to prepay and cover drop costs
    #[payable]
    pub fn add_to_balance(&mut self) -> bool  {
        self.assert_no_global_freeze();

        // Get the attached_deposit value which is how much the user wants to add to their storage
        let attached_deposit = env::attached_deposit();

        self.internal_modify_user_balance(&env::predecessor_account_id(), attached_deposit, false);

        true
    }

    /// Allows users to withdraw their balance
    pub fn withdraw_from_balance(&mut self, amount_to_withdraw: Option<U128>) -> bool  {
        self.assert_no_global_freeze();
        
        // The account to withdraw storage to is always the predecessor
        let owner_id = env::predecessor_account_id();
        // Get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        // Possible re-entrency attack if we don't remove the user from the map before transferring
        let mut cur_balance = self.user_balances.remove(&owner_id).unwrap_or(0);

        // If the amount to withdraw is specified, we withdraw the min of the amount to withdraw and the amount the user has
        let amount = amount_to_withdraw.map(|x| x.0).unwrap_or(cur_balance);
        if amount <= cur_balance && amount > 0 {
            // decrement the balance by the amount withdrawn
            cur_balance -= amount;

            Promise::new(owner_id.clone()).transfer(amount).as_return();
        }

        // re-insert the balance into the map if it's greater than 0
        if cur_balance > 0 {
            self.user_balances.insert(&owner_id, &cur_balance);
        }

        true
    }

    /// Return the current balance for a given account
    pub fn get_user_balance(&self, account_id: AccountId) -> U128 {
        U128(self.user_balances.get(&account_id).unwrap_or(0))
    }

    /// Internal function to modify the user's balance. Defaults to adding the amount but decrement can also be specified
    pub(crate) fn internal_modify_user_balance(&mut self, account_id: &AccountId, amount: u128, decrement: bool) {
        if amount > 0 {
            // Get the balance of the account (if the account isn't in the map we default to a balance of 0)
            let mut balance: u128 = self
                .user_balances
                .get(account_id)
                .unwrap_or(0);
    
            // Either add or subtract the amount from the balance depending on whether or not decrement was passed in
            if decrement == true {
                require!(
                    balance >= amount,
                    format!("User balance {} is less than required {}", balance, amount)
                );
                near_sdk::log!(
                    "User balance decremented by {}. Old: {} new: {}",
                    yocto_to_near(amount),
                    yocto_to_near(balance),
                    yocto_to_near(balance - amount)
                );    
                balance -= amount;
            } else {
                near_sdk::log!(
                    "User balance incremented by {}. Old: {} new: {}",
                    yocto_to_near(amount),
                    yocto_to_near(balance),
                    yocto_to_near(balance + amount)
                );  
                balance += amount;
            }
    
            // Insert the balance back into the map for that account ID
            self.user_balances
                .insert(account_id, &balance);
        }
    }

    /// Checks that the attached deposit is greater than the required deposit and refunds any excess
    /// If the attached deposit is less than the required deposit, decrement the user balance
    /// If the user doesn't have enough deposit or balance, panic
    pub(crate) fn charge_with_deposit_or_balance(&mut self, required_deposit: Balance, keep_excess_deposit: Option<bool>) {
        let predecessor = env::predecessor_account_id();
        let can_deposit_cover = env::attached_deposit() >= required_deposit;
        
        // In the case that the attached deposit covers what is required, refund the excess
        if can_deposit_cover {
            let amount_to_refund = env::attached_deposit() - required_deposit;

            // If the user wants to keep the excess deposit, just modify the user balance
            if keep_excess_deposit.unwrap_or(false) {
                self.internal_modify_user_balance(&predecessor, amount_to_refund, false);
                return;
            }

            near_sdk::log!("Refunding {} excess deposit", amount_to_refund);
            Promise::new(predecessor).transfer(amount_to_refund);
            return;
        }

        // In the case that the attached deposit is less than the required, check user balance
        let required_deposit_left = required_deposit - env::attached_deposit();
        self.internal_modify_user_balance(&predecessor, required_deposit_left, true);
    }
}
'''
'''--- contract/src/views/drops.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Allows you to query for the information about a specific drop
    ///
    /// Requirements:
    /// * Panics if the drop does not exist.
    ///
    /// Arguments:
    /// * `id` either the ID for the drop as a string or a public key currently part of the drop.
    ///
    /// Returns the `ExtDrop` information
    pub fn get_drop_information(&self, drop_id: DropId) -> ExtDrop {
        let drop = self.drop_by_id.get(&drop_id).expect("Drop not found");
        return drop.to_external_drop(drop_id);
    }

    /// Allows you to query for the number of live keys in a drop
    ///
    /// Requirements:
    /// * Panics if the drop does not exist.
    ///
    /// Arguments:
    /// * `id` either the ID for the drop as a string or a public key currently part of the drop.
    ///
    /// Returns the total number of keys as `u64` that are currently active for a given drop
    pub fn get_key_supply_for_drop(&self, drop_id: DropId) -> u64 {
        // Get the drop object and return the length
        self.drop_by_id
            .get(&drop_id)
            .expect("no drop found")
            .key_info_by_token_id
            .len()
    }

    /// Allows you to paginate through active keys in a drop
    ///
    /// Requirements:
    /// * Panics if the drop does not exist.
    ///
    /// Arguments:
    /// * `id` either the ID for the drop as a string or a public key currently part of the drop.
    /// * `from_index` where to start paginating from. If not specified, will start from 0 index.
    /// * `limit` how many keys to return. If not specified, will return 50 keys.
    ///
    /// Returns a vector of `ExtKeyInfo` objects representing the information about the keys
    #[handle_result]
    pub fn get_keys_for_drop(
        &self,
        drop_id: DropId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Result<Vec<ExtKeyInfo>, String> {
        //iterate through each key using an iterator
        let drop = self.drop_by_id
            .get(&drop_id)
            .expect("No drop for given ID");

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        return drop
            .key_info_by_token_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the public key which are strings into Drops
            .map(|token_id| self.get_key_information(token_id))
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}
'''
'''--- contract/src/views/funder.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Allows you to query for the total number of drops currently owned by a given funder
    ///
    ///
    /// Arguments:
    /// * `account_id` The account ID of the funder to query for
    ///
    /// Returns a `u64` representing the number of drops owned by the funder. If the funder does not have any drops, returns `0`
    pub fn get_drop_supply_for_funder(&self, account_id: AccountId) -> u64 {
        self.drop_ids_by_funder.get(&account_id).and_then(|d| Some(d.len())).unwrap_or(0)
    }

    /// Allows you to paginate through all the active drops for a given funder
    ///
    /// Requirements:
    /// * Panics if the drop does not exist.
    ///
    /// Arguments:
    /// * `account_id` The account ID of the funder to query for
    /// * `from_index` where to start paginating from. If not specified, will start from 0 index.
    /// * `limit` how many keys to return. If not specified, will return 50 keys.
    ///
    /// Returns a vector of `ExtDrop` objects representing the information about the drops
    pub fn get_drops_for_funder(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<ExtDrop> {
        // Iterate through each drop ID and push JsonDrop to a vector
        let drop_ids = self.drop_ids_by_funder.get(&account_id);

        // If there are IDs, iterate and create the vector of JsonDrops otherwise return empty array.s
        if let Some(ids) = drop_ids {
            // Where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
            let start = u128::from(from_index.unwrap_or(U128(0)));

            ids.iter()
                // Skip to the index we specified in the start variable
                .skip(start as usize)
                // Take the first "limit" elements in the vector. If we didn't specify a limit, use 50
                .take(limit.unwrap_or(50) as usize)
                // Convert each ID into a JsonDrop
                .map(|drop_id| self.get_drop_information(drop_id))
                // Collect all JsonDrops into a vector and return it
                .collect()
        } else {
            return vec![];
        }
    }
}
'''
'''--- contract/src/views/helpers.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Returns how many fees the contract has collected
    pub fn get_fees_collected(&self) -> U128 {
        U128(self.fees_collected)
    }

    /// Returns the current linkdrop contract
    pub fn get_root_account(&self) -> String {
        self.root_account.to_string()
    }

    /// Returns the current fees associated with an account
    pub fn get_fees_per_user(&self, account_id: AccountId) -> Option<KeypomFees> {
        self.fees_per_user
            .get(&account_id)
    }

    /// Returns the current contract source metadata
    pub fn contract_source_metadata(&self) -> ContractSourceMetadata {
        self.contract_metadata.get().unwrap()
    }

    pub(crate) fn parse_key_or_token_id(&self, key_or_token_id: String) -> String {
        let is_token_id = parse_token_id(&key_or_token_id).is_ok();

        if is_token_id {
            return key_or_token_id;
        }

        self
            .token_id_by_pk
            .get(&key_or_token_id.parse().unwrap())
            .expect("Token ID not found for Public Key")
    }
}
'''
'''--- contract/src/views/keys.rs ---
use crate::*;

#[near_bindgen]
impl Keypom {
    /// Allows you to query for the amount of $NEAR tokens contained in a linkdrop corresponding to a given public key.
    ///
    /// Requirements:
    /// * Panics if the key does not exist.
    ///
    /// Arguments:
    /// * `key` Either the public counterpart of the key used to sign, expressed as a string with format "<key-type>:<base58-key-bytes>" (e.g. "ed25519:6TupyNrcHGTt5XRLmHTc2KGaiSbjhQi1KHtCXTgbcr4Y")
    /// or the token ID corresponding to the key.
    ///
    /// Returns a string representing the $yoctoNEAR amount associated with a given public key
    #[handle_result]
    pub fn get_key_balance(&self, key: String) -> Result<U128, String> {
        Ok(self.get_key_information(key)?.yoctonear)
    }

    /// Allows you to query for the `KeyInfo` corresponding to a given public key. This method is preferred over `get_key_balance` as it provides more information about the key.
    ///
    /// Requirements:
    /// * Panics if the key does not exist.
    ///
    /// Arguments:
    /// * `key` Either the public counterpart of the key used to sign, expressed as a string with format "<key-type>:<base58-key-bytes>" (e.g. "ed25519:6TupyNrcHGTt5XRLmHTc2KGaiSbjhQi1KHtCXTgbcr4Y")
    /// or the token ID corresponding to the key.
    ///
    /// Returns `KeyInfo` associated with a given public key
    #[handle_result]
    pub fn get_key_information(&self, key: String) -> Result<ExtKeyInfo, String> {
        let token_id = self.parse_key_or_token_id(key);
        let (drop_id, _) = parse_token_id(&token_id)?;

        let drop = self
            .drop_by_id
            .get(&drop_id)
            .expect("no drop found for drop ID");
        let key_info = drop.key_info_by_token_id.get(&token_id).expect("Key not found");
        let cur_key_use = get_key_cur_use(&drop, &key_info);
        let InternalAssetDataForUses { uses: _, config: use_config, assets_metadata, required_asset_gas } = get_asset_data_for_specific_use(&drop.asset_data_for_uses, &cur_key_use);

        // If the config's permission field is set to Claim, the base should be set accordingly. In all other cases, it should be the base for CAAC
        let base_gas_for_use = if let Some(perms) = use_config.as_ref().and_then(|c| c.permissions.as_ref()) {
            match perms {
                ClaimPermissions::claim => {
                    BASE_GAS_FOR_CLAIM
                }
                _ => BASE_GAS_FOR_CREATE_ACC_AND_CLAIM
            }
        } else {
            BASE_GAS_FOR_CREATE_ACC_AND_CLAIM
        };

        // Keep track of the total gas across all assets in the current use
        let required_gas: Gas = base_gas_for_use + required_asset_gas;

        let mut ft_list: Vec<FTListData> = Vec::new();
        let mut nft_list: Vec<NFTListData> = Vec::new();
        let mut fc_list: Vec<FCData> = Vec::new();

        let mut yoctonear = 0;
        let mut num_nfts = 0;
        for metadata in assets_metadata {
            let internal_asset = drop.asset_by_id.get(&metadata.asset_id).expect("Asset not found");
            
            match internal_asset {
                InternalAsset::ft(ft) => {
                    ft_list.push(FTListData { 
                        amount: metadata.tokens_per_use.unwrap().0.to_string(),
                        contract_id: ft.contract_id.to_string()
                    });
                },
                InternalAsset::nft(nft) => {
                    let last_idx = nft.token_ids.len().checked_sub(1).unwrap_or(0);
                    let idx = last_idx.checked_sub(num_nfts).unwrap_or(nft.token_ids.len());

                    if let Some(token_id) = nft.token_ids.get(idx) {
                        nft_list.push(NFTListData { 
                            token_id: token_id.to_string(), 
                            contract_id: nft.contract_id.to_string(), 
                        });
                    }
                    
                    num_nfts += 1;
                },
                InternalAsset::fc(fc) => {
                    fc_list.push(fc.clone());
                },
                InternalAsset::near => {
                    yoctonear += metadata.tokens_per_use.unwrap().0;
                },
                InternalAsset::none => {}
            }
        }

        Ok(ExtKeyInfo {
            yoctonear: U128(yoctonear),
            ft_list,
            nft_list,
            fc_list,
            required_gas: u64::from(required_gas).to_string(),
            uses_remaining: key_info.remaining_uses,
            drop_id,
            token_id,
            pub_key: key_info.pub_key,
            owner_id: key_info.owner_id.unwrap_or(env::current_account_id()),
        })
    }

    /// Allows you to query for the total number of keys currently active on the Keypom contract
    ///
    ///
    /// Returns a `u64` representing the total number of keys currently active on the Keypom contract
    pub fn get_key_total_supply(&self) -> u64 {
        self.token_id_by_pk.len()
    }

    /// Allows you to paginate through all the active keys on the Keypom contract regardless of which drop they are part of.
    ///
    ///
    /// Arguments:
    /// * `from_index` where to start paginating from. If not specified, will start from 0 index.
    /// * `limit` how many keys to return. If not specified, will return 50 keys.
    ///
    /// Returns a vector of `ExtKeyInfo` objects representing the information about the keys
    #[handle_result]
    pub fn get_keys(&self, from_index: Option<U128>, limit: Option<u64>) -> Result<Vec<ExtKeyInfo>, String> {
        let start = u128::from(from_index.unwrap_or(U128(0)));

        self.token_id_by_pk
            .values()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.get_key_information(token_id))
            .collect()
    }

    /// Allows you to query for the information about a batch of keys all at once with 1 function.
    ///
    ///
    /// Arguments:
    /// * `key` Either the public counterpart of the key used to sign, expressed as a string with format "<key-type>:<base58-key-bytes>" (e.g. "ed25519:6TupyNrcHGTt5XRLmHTc2KGaiSbjhQi1KHtCXTgbcr4Y")
    /// or the token ID corresponding to the key.
    ///
    /// Returns a vector of optional `ExtKeyInfo` objects representing the information about the keys. If
    /// Any of the keys do not exist, the corresponding index in the vector will be `None`
    pub fn get_key_information_batch(&self, keys: Vec<String>) -> Vec<Option<ExtKeyInfo>> {
        keys.iter()
            .map(|key| self.get_key_information(key.clone()).ok())
            .collect()
    }
}
'''
'''--- contract/src/views/mod.rs ---
pub mod drops;
pub mod keys;
pub mod helpers;
pub mod funder;

pub use drops::*;
pub use keys::*;
pub use helpers::*;
pub use funder::*;
'''
'''--- deploy/ft/configurations.js ---
const { parseNearAmount } = require("near-api-js/lib/utils/format");

const KEYPOM_CONTRACT = "v1-3.keypom.testnet"
// const FUNDING_ACCOUNT_ID = "minqi.testnet"
// const FUNDER_INFO = {
//     accountId: FUNDING_ACCOUNT_ID,
//     secretKey: "ed25519:5rnGds9BqnrtLaavHVN8qbZbHxEuhDrnBuai6Wp3Duntu5JmAUSTxRKF93qzPuate8AS5k9MDJNbCvQPHh8o2dqZ"
// }

const FUNDING_ACCOUNT_ID = "minqi.testnet"
const FUNDER_INFO = {
    accountId: FUNDING_ACCOUNT_ID,
    secretKey: "ed25519:3hsCWpjczaPoNejnC2A1McGvnJQipAJUDmo6tEZ6XH6qwxfxTLkpQ8hMNG3jxg1zXEe5Ke2qoqUq76jJpeNKxaMa"
}
const NETWORK_ID = "testnet";
const DEPOSIT_PER_USE_NEAR = 1;
const NUM_KEYS = 1;
const FT_CONTRACT_ID = "ft.keypom.testnet";

const FT_DATA = {
    // Contract ID of the fungible token
    contractId: FT_CONTRACT_ID,
    // Who will be sending the FTs to the Keypom contract
    senderId: FUNDING_ACCOUNT_ID,
    // How many FTs should be sent to the claimed account everytime a key is used
    amount: 1,
}

const DROP_CONFIG = {
    // How many claims can each key have.
    usesPerKey: 2,

    usage: {
        /// Can the access key only call the claim method_name? Default to both method_name callable
        permissions: null,
        /// If claim is called, refund the deposit to the owner's balance. If None, default to false.
        refundDeposit: null,
        /// Should the drop be automatically deleted when all the keys are used? This is defaulted to false and
        /// Must be overwritten
        autoDeleteDrop: true,
        /// When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.
        autoWithdraw: true
    },

    time: {
        /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        start: null,
    
        /// Block timestamp that keys must be before. If None, keys can be used indefinitely
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        end: null,
    
        /// Time interval between each key use. If None, there is no delay between key uses.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        throttle: null,
    
        /// Interval of time after the `start_timestamp` that must pass before a key can be used.
        /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
        /// With the throttle timestamp. It only pertains to the start timestamp and the current
        /// timestamp. The last_used timestamp is not taken into account.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        interval: null
    },

    // Root account that all sub-accounts will default to. If None, default to the global drop root.
    dropRoot: null,
}

const DROP_METADATA = "";

module.exports = {
    FUNDING_ACCOUNT_ID,
    FUNDER_INFO,
    NETWORK_ID,
    DEPOSIT_PER_USE_NEAR,
    NUM_KEYS,
    DROP_CONFIG,
    DROP_METADATA,
    KEYPOM_CONTRACT,
    FT_DATA,
    FT_CONTRACT_ID
}
'''
'''--- deploy/ft/ft-create-sdk.js ---
// In this script, we check if the funder owns the NFTs they are adding to the contract. If they don't, throw an error
const { FUNDING_ACCOUNT_ID, FUNDER_INFO, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, NFT_DATA, NFT_CONTRACT_ID, NFT_METADATA, FT_DATA, FT_CONTRACT_ID} = require("./configurations");

const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initKeypom, createDrop, getDrops } = require("keypom-js");
const { BN } = require("bn.js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");

const { initiateNearConnection } = require("../utils/general");
const { format } = require("path");

// Funder is account to sign txns, can be changed in ./configurations.js
async function createFTDrop(){
    // USER'S RESPONSIBILITY TO CHANGE DEFAULT CONSTS IN CONFIGURATIONS.JS

    // Initialize keypom, this takes care of the new NEAR connection
    console.log("Initiating NEAR connection");
    let near = await initiateNearConnection(NETWORK_ID);
    const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);
    
    await initKeypom({near: near, funder: FUNDER_INFO});

	// Get amount to transfer and see if owner has enough balance to fund drop
	let amountToTransfer = new BN(FT_DATA.amount).mul(new BN(NUM_KEYS * DROP_CONFIG.usesPerKey)).toString()
	console.log('amountToTransfer: ', amountToTransfer);
    
    let funderFungibleTokenBal = await fundingAccount.viewFunction(
		FT_CONTRACT_ID, 
		'ft_balance_of', 
		{
			account_id: FUNDING_ACCOUNT_ID
		}
	);

	if (new BN(funderFungibleTokenBal).lte(new BN(amountToTransfer))){
		throw new Error('funder does not have enough Fungible Tokens for this drop. Top up and try again.');
	}

    // Creates the FT drop based on data from config file. Keys are automatically generated within the function based on `NUM_KEYS`. Since there is no entropy, all keys are completely random.
    const {keys} = await createDrop({
        numKeys: NUM_KEYS,
        depositPerUseNEAR: DEPOSIT_PER_USE_NEAR,
        metadata: DROP_METADATA,
        config: DROP_CONFIG,
        ftData: FT_DATA,
    });
    pubKeys = keys.publicKeys

    console.log(pubKeys)
    var dropInfo = {};
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
    for(var i = 0; i < keys.keyPairs.length; i++) {
        let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
		console.log(linkdropUrl);
	}
	// Write file of all pk's and their respective linkdrops
	console.log('curPks: ', pubKeys)
	await writeFile(path.resolve(__dirname, `linkdrops.json`), JSON.stringify(dropInfo));
}

createFTDrop();
'''
'''--- deploy/ft/ft-create.js ---
// There is no standard way of sending the funder FTs unless we expose a private key in script. For this reason, the script will only work if the funder has enough FTs.
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initiateNearConnection, getFtCosts, estimateRequiredDeposit, ATTACHED_GAS_FROM_WALLET, getRecentDropId } = require("../utils/general");
const { FUNDING_ACCOUNT_ID, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, FT_DATA, FT_CONTRACT_ID } = require("./configurations");
const { KeyPair } = require("near-api-js");
const { BN } = require("bn.js");

async function start() {
	// Initiate connection to the NEAR blockchain.
	console.log("Initiating NEAR connection");
	let near = await initiateNearConnection(NETWORK_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	//get amount to transfer and see if owner has enough balance to fund drop
	let amountToTransfer = new BN(FT_DATA.amount).mul(new BN(NUM_KEYS * DROP_CONFIG.usesPerKey)).toString()
	console.log('amountToTransfer: ', amountToTransfer);

	let funderFungibleTokenBal = await fundingAccount.viewFunction(
		FT_CONTRACT_ID, 
		'ft_balance_of',
		{
			account_id: FUNDING_ACCOUNT_ID
		}
	);

	if (new BN(funderFungibleTokenBal).lte(new BN(amountToTransfer))){
		throw new Error('funder does not have enough Fungible Tokens for this drop. Top up and try again.');
	}
	
	// Keep track of an array of the keyPairs we create
	let keyPairs = [];
	// Keep track of the public keys to pass into the contract
	let pubKeys = [];
	console.log("Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}
	console.log(pubKeys)

	try {
		await fundingAccount.functionCall(
			KEYPOM_CONTRACT, 
			'create_drop', 
			{
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount(DEPOSIT_PER_USE_NEAR.toString()),
				config: {
					uses_per_key: DROP_CONFIG.usesPerKey,
					time: {
						start: DROP_CONFIG.time.start,
						end: DROP_CONFIG.time.end,
						throttle: DROP_CONFIG.time.throttle,
						interval: DROP_CONFIG.time.interval
					},
					usage: {
						permissions: DROP_CONFIG.usage.permissions,
						refund_deposit: DROP_CONFIG.usage.refundDeposit,
						auto_delete_drop:DROP_CONFIG.usage.autoDeleteDrop,
						auto_withdraw: DROP_CONFIG.usage.autoWithdraw
					
					},
					root_account_id: DROP_CONFIG.dropRoot
					
				},
				metadata: JSON.stringify(DROP_METADATA),
				ft: {
					contract_id: FT_DATA.contractId,
					sender_id: FT_DATA.senderId,
					balance_per_use: parseNearAmount(FT_DATA.amount.toString())
				}
			}, 
			"300000000000000",
			parseNearAmount("10")
		);
	} catch(e) {
		console.log('error creating drop: ', e);
	}

	console.log("checking to see if drop creation was successful, Keypom smart contract will panic if drop does not exist");
	await fundingAccount.functionCall(
		KEYPOM_CONTRACT, 
		'get_drop_information', 
		{
			key: pubKeys[0],
		}
	);

	try {
		await fundingAccount.functionCall(
			FT_CONTRACT_ID, 
			'storage_deposit',
			{
				account_id: FUNDING_ACCOUNT_ID,
			},
			"300000000000000",
			parseNearAmount("0.1")
		);

		let dropId = await getRecentDropId(fundingAccount, FUNDING_ACCOUNT_ID, KEYPOM_CONTRACT);
		console.log('dropId: ', dropId)

		await fundingAccount.functionCall(
			FT_CONTRACT_ID, 
			'ft_transfer_call', 
			{
				receiver_id: KEYPOM_CONTRACT,
				// amount: (FT_DATA.amount*NUM_KEYS * DROP_CONFIG.usesPerKey).toString(),
				amount: parseNearAmount((FT_DATA.amount*NUM_KEYS * DROP_CONFIG.usesPerKey).toString()),				
				msg: dropId.toString()
			},
			"300000000000000",
			"1"
		);
	} catch(e) {
		console.log('error sending FTs', e);
	}
	
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}`;
		curPks[keyPairs[i].publicKey.toString()] = linkdropUrl;
		console.log(linkdropUrl);
	}

	console.log('curPks: ', curPks)
	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/ft/linkdrops.json ---
{"ed25519:8q7FBKB4tMxpxWMt3eWfX8va31cJzGBE7TUtiueuJVdJ":"https://testnet.mynearwallet.com/linkdrop/v1-3.keypom.testnet/4VWXTeCp14fg2DcqnmTTkat9vmX7JUT8geLKzg5iEQdTAc1N2Tdr6F6CLGrJxq5hnvYTd43Ty7n14SSbXnoFU78k"}
'''
'''--- deploy/function-call/configurations.js ---
const { parseNearAmount } = require("near-api-js/lib/utils/format");

const KEYPOM_CONTRACT = "v1-3.keypom.testnet"
const FUNDING_ACCOUNT_ID = "minqi.testnet"
const FUNDER_INFO = {
    accountId: FUNDING_ACCOUNT_ID,
    secretKey: "ed25519:3hsCWpjczaPoNejnC2A1McGvnJQipAJUDmo6tEZ6XH6qwxfxTLkpQ8hMNG3jxg1zXEe5Ke2qoqUq76jJpeNKxaMa"
}

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const NETWORK_ID = "testnet";
const DEPOSIT_PER_USE_NEAR = 1;
const NUM_KEYS = 1;
const NFT_CONTRACT_ID = 'nft.examples.testnet';

const NFT_METADATA = {
    title: "My Keypom NFT",
    description: "Keypom is lit fam",
    media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
}

const NFT_DATA = {
    // NFT Contract Id that the tokens will come from
    contractId: NFT_CONTRACT_ID,
    // Who will be sending the NFTs to the Keypom contract
    senderId: FUNDING_ACCOUNT_ID,
    // List of tokenIDs
    tokenIds: ["1a"]
}

const FC_DATA = {
    methods: [
		[{
			receiverId: NFT_CONTRACT_ID,
			methodName: "nft_mint",
			args: JSON.stringify({
                token_id: "one-eh",
                receiver_id: FUNDING_ACCOUNT_ID,
                metadata: NFT_METADATA
			}),
			attachedDeposit: parseNearAmount("1"),
		}]
	]
}

const DROP_CONFIG = {
    // How many claims can each key have.
    usesPerKey: 1,

    usage: {
        /// Can the access key only call the claim method_name? Default to both method_name callable
        permissions: null,
        /// If claim is called, refund the deposit to the owner's balance. If None, default to false.
        refundDeposit: null,
        /// Should the drop be automatically deleted when all the keys are used? This is defaulted to false and
        /// Must be overwritten
        autoDeleteDrop: true,
        /// When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.
        autoWithdraw: true
    },

    time: {
        /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        start: null,
    
        /// Block timestamp that keys must be before. If None, keys can be used indefinitely
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        end: null,
    
        /// Time interval between each key use. If None, there is no delay between key uses.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        throttle: null,
    
        /// Interval of time after the `start_timestamp` that must pass before a key can be used.
        /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
        /// With the throttle timestamp. It only pertains to the start timestamp and the current
        /// timestamp. The last_used timestamp is not taken into account.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        interval: null
    },

    // Root account that all sub-accounts will default to. If None, default to the global drop root.
    dropRoot: null,
}

const DROP_METADATA = "";

module.exports = {
    FUNDING_ACCOUNT_ID,
    FUNDER_INFO,
    NETWORK_ID,
    DEPOSIT_PER_USE_NEAR,
    NUM_KEYS,
    DROP_CONFIG,
    DROP_METADATA,
    FC_DATA,
    NFT_DATA,
    KEYPOM_CONTRACT,
    NFT_CONTRACT_ID,
    NFT_METADATA
}
'''
'''--- deploy/function-call/fc-create-sdk.js ---
const { FUNDING_ACCOUNT_ID, FUNDER_INFO, NETWORK_ID, NUM_KEYS, DROP_METADATA, DROP_CONFIG, KEYPOM_CONTRACT, FC_DATA, DEPOSIT_PER_USE_NEAR} = require("./configurations");

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initKeypom, createDrop, getDrops } = require("keypom-js");

// Funder is account to sign txns, can be changed in ./configurations.js
async function createFCDrop(){
    // USER'S RESPONSIBILITY TO CHANGE DEFAULT CONSTS IN CONFIGURATIONS.JS

    // Init keypom, this takes care of the new NEAR connection
    console.log("Initiating NEAR connection");
    await initKeypom({network: NETWORK_ID, funder: FUNDER_INFO});

    // Create drop, this generates the keys based on the number of keys passed in and uses funder's keypom balance if funderBalance is true (otherwise will sign a txn with an attached deposit)
    const {keys} = await createDrop({
        numKeys: NUM_KEYS,
        depositPerUseNEAR: DEPOSIT_PER_USE_NEAR,
        metadata: DROP_METADATA,
        config: DROP_CONFIG,
        fcData: FC_DATA,
    });
    pubKeys = keys.publicKeys

    var dropInfo = {};
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
    for(var i = 0; i < keys.keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
		console.log(linkdropUrl);
	}
	//Write file of all pk's and their respective linkdrops
	console.log('curPks: ', pubKeys)
	await writeFile(path.resolve(__dirname, `linkdrops.json`), JSON.stringify(dropInfo));
}

createFCDrop();
'''
'''--- deploy/function-call/fc-create.js ---
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const { initiateNearConnection, getFtCosts, estimateRequiredDeposit, ATTACHED_GAS_FROM_WALLET, getRecentDropId } = require("../utils/general");
const { FUNDER_INFO, NUM_KEYS, DROP_CONFIG, NETWORK_ID, KEYPOM_CONTRACT, FUNDING_ACCOUNT_ID,NFT_METADATA, FC_DATA, DROP_METADATA, DEPOSIT_PER_USE_NEAR} = require("./configurations");
const { KeyPair } = require("near-api-js");
const { BN } = require("bn.js");

async function start() {
	// Initiate connection to the NEAR blockchain.
	console.log("Initiating NEAR connection");
	let near = await initiateNearConnection(NETWORK_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	// Keep track of an array of the keyPairs we create
	let keyPairs = [];
	// Keep track of the public keys to pass into the contract
	let pubKeys = [];
	console.log("Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}

	// Create FC drop with pubkkeys from above and fc data
	try {
		await fundingAccount.functionCall(
			KEYPOM_CONTRACT, 
			'create_drop', 
			{
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount(DEPOSIT_PER_USE_NEAR.toString()),
				fc: {
					methods: [[{
						receiver_id: FC_DATA.methods[0][0].receiverId,
						method_name: FC_DATA.methods[0][0].methodName,
						args: FC_DATA.methods[0][0].args,
						attached_deposit: FC_DATA.methods[0][0].attachedDeposit
					}]]
				},
				config: {
					uses_per_key: DROP_CONFIG.usesPerKey,
					time: {
						start: DROP_CONFIG.time.start,
						end: DROP_CONFIG.time.end,
						throttle: DROP_CONFIG.time.throttle,
						interval: DROP_CONFIG.time.interval
					},
					usage: {
						permissions: DROP_CONFIG.usage.permissions,
						refund_deposit: DROP_CONFIG.usage.refundDeposit,
						auto_delete_drop:DROP_CONFIG.usage.autoDeleteDrop,
						auto_withdraw: DROP_CONFIG.usage.autoWithdraw
					
					},
					root_account_id: DROP_CONFIG.dropRoot
				},
				metadata: JSON.stringify(DROP_METADATA)
			}, 
			"300000000000000",
			parseNearAmount("2")
		);
	} catch(e) {
		console.log('error creating drop: ', e);
	}

	console.log("checking to see if drop creation was successful, Keypom smart contract will panic if drop does not exist");
	await fundingAccount.functionCall(
		KEYPOM_CONTRACT, 
		'get_drop_information', 
		{
			key: pubKeys[0],
		}
	);
	

	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}`;
		curPks[keyPairs[i].publicKey.toString()] = linkdropUrl;
		console.log(linkdropUrl);
	}

	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/nft/configurations.js ---
const { parseNearAmount } = require("near-api-js/lib/utils/format");

const KEYPOM_CONTRACT = "v1-3.keypom.testnet"
const FUNDING_ACCOUNT_ID = "minqi.testnet"
const FUNDER_INFO = {
    accountId: FUNDING_ACCOUNT_ID,
    secretKey: "ed25519:3hsCWpjczaPoNejnC2A1McGvnJQipAJUDmo6tEZ6XH6qwxfxTLkpQ8hMNG3jxg1zXEe5Ke2qoqUq76jJpeNKxaMa"
}
// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.
const NETWORK_ID = "testnet";
const DEPOSIT_PER_USE_NEAR = 1;
const NUM_KEYS = 1;
const NFT_CONTRACT_ID = 'nft.examples.testnet';

const NFT_METADATA = {
    title: "My Keypom NFT",
    description: "Keypom is lit fam :D",
    media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
}

const NFT_DATA = {
    // NFT Contract Id that the tokens will come from
    contractId: NFT_CONTRACT_ID,
    // Who will be sending the NFTs to the Keypom contract
    senderId: FUNDING_ACCOUNT_ID,
    // List of tokenIDs
    // tokenIds: ["1.0.6", "1.0.7"]
    tokenIds: ["a white cat", "a brown cat"]
}
//USED TO HAVE 2 OBJS
// const NFT_DATA_OWNED = {
//     // NFT Contract Id that the tokens will come from
//     contract_id: NFT_CONTRACT_ID,
//     // Who will be sending the NFTs to the Keypom contract
//     sender_id: FUNDING_ACCOUNT_ID,
//     //list of tokenIDs
//     tokenIds: []
// }
    

const DROP_CONFIG = {
    // How many claims can each key have.
    usesPerKey: 2,

    usage: {
        /// Can the access key only call the claim method_name? Default to both method_name callable
        permissions: null,
        /// If claim is called, refund the deposit to the owner's balance. If None, default to false.
        refundDeposit: null,
        /// Should the drop be automatically deleted when all the keys are used? This is defaulted to false and
        /// Must be overwritten
        autoDeleteDrop: true,
        /// When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.
        autoWithdraw: true
    },

    time: {
        /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        start: null,
    
        /// Block timestamp that keys must be before. If None, keys can be used indefinitely
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        end: null,
    
        /// Time interval between each key use. If None, there is no delay between key uses.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        throttle: null,
    
        /// Interval of time after the `start_timestamp` that must pass before a key can be used.
        /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
        /// With the throttle timestamp. It only pertains to the start timestamp and the current
        /// timestamp. The last_used timestamp is not taken into account.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        interval: null
    },

    // Root account that all sub-accounts will default to. If None, default to the global drop root.
    dropRoot: null,
}

const DROP_METADATA = "";

module.exports = {
    FUNDING_ACCOUNT_ID,
    FUNDER_INFO,
    NETWORK_ID,
    DEPOSIT_PER_USE_NEAR,
    NUM_KEYS,
    DROP_CONFIG,
    DROP_METADATA,
    KEYPOM_CONTRACT,
    NFT_DATA,
    NFT_CONTRACT_ID,
    NFT_METADATA
}
'''
'''--- deploy/nft/nft-create-sdk-minted.js ---
// In this script, we check if the funder owns the NFTs they are adding to the contract. If they don't, throw an error
const { FUNDING_ACCOUNT_ID, FUNDER_INFO, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, NFT_DATA, NFT_CONTRACT_ID, NFT_METADATA} = require("./configurations");

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initKeypom, createDrop, getDrops } = require("keypom-js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const { initiateNearConnection } = require("../utils/general");

// Funder is account to sign txns, can be changed in ./configurations.js
async function createNFTDropMinted(){
    // USER'S RESPONSIBILITY TO CHANGE DEFAULT CONSTS IN CONFIGURATIONS.JS

    // Init keypom, this takes care of the new NEAR connection
    console.log("Initiating NEAR connection");
    let near = await initiateNearConnection(NETWORK_ID);
    const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);
    
    await initKeypom({near: near, funder: FUNDER_INFO});

    // Mint 1 NFT for the funder from the NFT contract outlined in the NFT_DATA
    // NFT_DATA.tokenIds[0] = `keypom-${dropId}-1-${FUNDING_ACCOUNT_ID}-${Date.now()}`;
	await fundingAccount.functionCall(
		NFT_CONTRACT_ID, 
		'nft_mint', 
		{
			receiver_id: FUNDING_ACCOUNT_ID,
			metadata: NFT_METADATA,
			token_id: NFT_DATA.tokenIds[0],
		},
		"300000000000000",
		parseNearAmount("0.1")
	);

    // Create drop, this generates the keys based on the number of keys passed in and uses funder's keypom balance if funderBalance is true (otherwise will sign a txn with an attached deposit)
    const {keys} = await createDrop({
        numKeys: NUM_KEYS,
        depositPerUseNEAR: DEPOSIT_PER_USE_NEAR,
        metadata: DROP_METADATA,
        config: DROP_CONFIG,
        nftData: NFT_DATA
    });
    pubKeys = keys.publicKeys
    
    console.log(keys)

    var dropInfo = {};
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
    for(var i = 0; i < keys.keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
		console.log(linkdropUrl);
	}
	// Write file of all pk's and their respective linkdrops
	console.log('curPks: ', pubKeys)
	await writeFile(path.resolve(__dirname, `linkdrops.json`), JSON.stringify(dropInfo));
}

createNFTDropMinted();
'''
'''--- deploy/nft/nft-create-sdk-owned.js ---
// In this script, we check if the funder owns the NFTs they are adding to the contract. If they don't, throw an error
const { FUNDING_ACCOUNT_ID, FUNDER_INFO, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, NFT_DATA, NFT_CONTRACT_ID, NFT_METADATA} = require("./configurations");

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initKeypom, createDrop, getDrops } = require("keypom-js");
const { initiateNearConnection } = require("../utils/general");

// Funder is account to sign txns, can be changed in ./configurations.js
async function createNFTDropOwned(){
    // USER'S RESPONSIBILITY TO CHANGE DEFAULT CONSTS IN CONFIGURATIONS.JS

    // Init keypom, this takes care of the new NEAR connection
    console.log("Initiating NEAR connection");
    let near = await initiateNearConnection(NETWORK_ID);
    await initKeypom({near: near, funder: FUNDER_INFO});

    const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

    // Get array of token_ids owned by funder
    let funderOwnedNFTs = await fundingAccount.viewFunction(
        NFT_CONTRACT_ID, 
        'nft_tokens_for_owner', 
        {
            account_id: FUNDING_ACCOUNT_ID,
        },
    );
    let funderOwnedTokenIds = [];
    for(i = 0; i<funderOwnedNFTs.length; i++){
        funderOwnedTokenIds.push(funderOwnedNFTs[i].token_id)
    }
    

    // See if funder actually owns the NFTs in NFT_DATA_OWNED
    for(var i = 0; i < NFT_DATA.tokenIds.length; i++){
        if (!funderOwnedTokenIds.includes(NFT_DATA.tokenIds[i])){
            throw new Error(`funder does not own Non Fungible Token with ID: ${NFT_DATA.tokenIds[i]}`);
        }
    }

    // Creates the FT drop based on data from config file. Keys are automatically generated within the function based on `NUM_KEYS`. Since there is no entropy, all keys are completely random.
    const {keys} = await createDrop({
        numKeys: NUM_KEYS,
        depositPerUseNEAR: DEPOSIT_PER_USE_NEAR,
        metadata: DROP_METADATA,
        config: DROP_CONFIG,
        nftData: NFT_DATA,
    });
    pubKeys = keys.publicKeys

    var dropInfo = {};
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
    for(var i = 0; i < keys.keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
		console.log(linkdropUrl);
	}
	// Write file of all pk's and their respective linkdrops
	console.log('curPks: ', pubKeys)
	await writeFile(path.resolve(__dirname, `linkdrops.json`), JSON.stringify(dropInfo));
}

createNFTDropOwned();
'''
'''--- deploy/nft/nft-create.js ---
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');

// NOTE: This script MUST be run on testnet and WILL NOT WORK ON MAINNET
// This is beause the chosen NFT contract for this tutorial lives on testnet.

const { initiateNearConnection, getFtCosts, estimateRequiredDeposit, ATTACHED_GAS_FROM_WALLET, getRecentDropId } = require("../utils/general");
const { FUNDING_ACCOUNT_ID, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, NFT_DATA, NFT_CONTRACT_ID, NFT_METADATA } = require("./configurations");
const { KeyPair } = require("near-api-js");
const { BN } = require("bn.js");

async function start() {
	// Initiate connection to the NEAR blockchain.
	console.log("Initiating NEAR connection");
	let near = await initiateNearConnection(NETWORK_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);

	
	// Keep track of an array of the keyPairs we create
	let keyPairs = [];
	// Keep track of the public keys to pass into the contract
	let pubKeys = [];
	console.log("Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}

	try {
		await fundingAccount.functionCall(
			KEYPOM_CONTRACT, 
			'create_drop', 
			{
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount(DEPOSIT_PER_USE_NEAR.toString()),
				config: {
					uses_per_key: DROP_CONFIG.usesPerKey,
					time: {
						start: DROP_CONFIG.time.start,
						end: DROP_CONFIG.time.end,
						throttle: DROP_CONFIG.time.throttle,
						interval: DROP_CONFIG.time.interval
					},
					usage: {
						permissions: DROP_CONFIG.usage.permissions,
						refund_deposit: DROP_CONFIG.usage.refundDeposit,
						auto_delete_drop:DROP_CONFIG.usage.autoDeleteDrop,
						auto_withdraw: DROP_CONFIG.usage.autoWithdraw
					
					},
					root_account_id: DROP_CONFIG.dropRoot
					
				},
				metadata: JSON.stringify(DROP_METADATA),
				nft: {
					sender_id: NFT_DATA.senderId,
					contract_id: NFT_DATA.contractId
				}
			}, 
			"300000000000000",
			parseNearAmount("10")
		);
	} catch(e) {
		console.log('error creating drop: ', e);
	}

	console.log("checking to see if drop creation was successful, Keypom smart contract will panic if drop does not exist");
	await fundingAccount.functionCall(
		KEYPOM_CONTRACT, 
		'get_drop_information', 
		{
			key: pubKeys[0],
		}
	);

	try {
		let dropId = await getRecentDropId(fundingAccount, FUNDING_ACCOUNT_ID, KEYPOM_CONTRACT);
		console.log('dropId: ', dropId)

		let amountToTransfer = NUM_KEYS * DROP_CONFIG.usesPerKey;
		for(var i = 0; i < amountToTransfer; i++) {
			let tokenId = `keypom-${dropId}-${i}-${FUNDING_ACCOUNT_ID}-${Date.now()}`;
			await fundingAccount.functionCall(
				NFT_CONTRACT_ID, 
				'nft_mint', 
				{
					receiver_id: FUNDING_ACCOUNT_ID,
					metadata: NFT_METADATA,
					token_id: NFT_DATA.tokenIds[i],
				},
				"300000000000000",
				parseNearAmount("0.1")
			);

			await fundingAccount.functionCall(
				NFT_CONTRACT_ID, 
				'nft_transfer_call', 
				{
					receiver_id: KEYPOM_CONTRACT,
					token_id: NFT_DATA.tokenIds[i],
					msg: dropId.toString()
				},
				"300000000000000",
				"1"
			);
		}
		let curPks = {};
		for(var i = 0; i < keyPairs.length; i++) {
			let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}`;
			curPks[keyPairs[i].publicKey.toString()] = linkdropUrl;
			console.log(linkdropUrl);
		}

		console.log('curPks: ', curPks)
		await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));

		console.log("DROP CREATED SUCCESSFULLY")
	} catch(e) {
		console.log('error sending NFTs', e);
	}
	
}

start();
'''
'''--- deploy/simple/configurations.js ---
const { parseNearAmount } = require("near-api-js/lib/utils/format");

const KEYPOM_CONTRACT = "v1-3.keypom.testnet"
const FUNDING_ACCOUNT_ID = "minqi.testnet"
const FUNDER_INFO = {
    accountId: FUNDING_ACCOUNT_ID,
    secretKey: "ed25519:3hsCWpjczaPoNejnC2A1McGvnJQipAJUDmo6tEZ6XH6qwxfxTLkpQ8hMNG3jxg1zXEe5Ke2qoqUq76jJpeNKxaMa"
}
const NETWORK_ID = "testnet";
const DEPOSIT_PER_USE_NEAR = '1';
const NUM_KEYS = 1;

//change this to match the keypom-sdk types
const DROP_CONFIG = {
    // How many claims can each key have.
    usesPerKey: 2,

    time:{
            /// Minimum block timestamp before keys can be used. If None, keys can be used immediately
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        start: null,

        /// Block timestamp that keys must be before. If None, keys can be used indefinitely
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        end: null,

        /// Time interval between each key use. If None, there is no delay between key uses.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        throttle: null,

        /// Interval of time after the `start_timestamp` that must pass before a key can be used.
        /// If multiple intervals pass, the key can be used multiple times. This has nothing to do
        /// With the throttle timestamp. It only pertains to the start timestamp and the current
        /// timestamp. The last_used timestamp is not taken into account.
        /// Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
        interval: null
    },

    usage:{
        /// Can the access key only call the claim method_name? Default to both method_name callable
        permissions: null,
        /// If claim is called, refund the deposit to the owner's balance. If None, default to false.
        refundDeposit: false,
        /// Should the drop be automatically deleted when all the keys are used? This is defaulted to false and
        /// Must be overwritten
        autoDeleteDrop: true,
        /// When this drop is deleted and it is the owner's *last* drop, automatically withdraw their balance.
        autoWithdraw: true,
    },

    // Root account that all sub-accounts will default to. If None, default to the global drop root.
    dropRoot: null,
}

const DROP_METADATA = "";

module.exports = {
    FUNDING_ACCOUNT_ID,
    FUNDER_INFO,
    NETWORK_ID,
    DEPOSIT_PER_USE_NEAR,
    NUM_KEYS,
    DROP_CONFIG,
    DROP_METADATA,
    KEYPOM_CONTRACT
}
'''
'''--- deploy/simple/linkdrops.json ---
{"ed25519:7fTHEyZ4ZjAM6DGHUzuyYRf8656g6FzCjYBVJRBV9PGa":"https://testnet.mynearwallet.com/linkdrop/v1-3.keypom.testnet/2aEGxjEn5KbSunqrZRsojVg797yxC2hsaDzuejN2TV6MjSVEiJ4sWJEAkcdAbGHNCEQ8XdEVF6nWqAsz1N722cYv"}
'''
'''--- deploy/simple/simple-create-sdk.js ---
const { FUNDING_ACCOUNT_ID, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT, FUNDER_INFO } = require("./configurations");

const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initKeypom, createDrop, getDrops } = require("keypom-js");

// Funder is account to sign txns, can be changed in ./configurations.js
async function createSimpleDrop(){
    // USER'S RESPONSIBILITY TO CHANGE DEFAULT CONSTS IN CONFIGURATIONS.JS

    // Init keypom, this takes care of the new NEAR connection
    console.log("Initiating NEAR connection");
    await initKeypom({network: NETWORK_ID, funder: FUNDER_INFO});

    // Create drop, this generates the keys based on the number of keys passed in and uses funder's keypom balance if funderBalance is true (otherwise will sign a txn with an attached deposit)
    const {keys} = await createDrop({
        numKeys: NUM_KEYS,
        depositPerUseNEAR: DEPOSIT_PER_USE_NEAR,
        metadata: DROP_METADATA,
        config: DROP_CONFIG,
    });
    pubKeys = keys.publicKeys

    var dropInfo = {};
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
    for(var i = 0; i < keys.keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keys.secretKeys[i]}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
		console.log(linkdropUrl);
	}
	// Write file of all pk's and their respective linkdrops
	console.log('curPks: ', pubKeys)
	await writeFile(path.resolve(__dirname, `linkdrops.json`), JSON.stringify(dropInfo));
}

createSimpleDrop();
'''
'''--- deploy/simple/simple-create.js ---
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const path = require("path");
const homedir = require("os").homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const { initiateNearConnection, getFtCosts, estimateRequiredDeposit, ATTACHED_GAS_FROM_WALLET } = require("../utils/general");
const { FUNDING_ACCOUNT_ID, NETWORK_ID, NUM_KEYS, DROP_METADATA, DEPOSIT_PER_USE_NEAR, DROP_CONFIG, KEYPOM_CONTRACT } = require("./configurations");
const { KeyPair } = require("near-api-js");
const { parse } = require("url");

async function start() {
	// Initiate connection to the NEAR blockchain.
	console.log("Initiating NEAR connection");
	let near = await initiateNearConnection(NETWORK_ID);
	const fundingAccount = await near.account(FUNDING_ACCOUNT_ID);
	
	// Keep track of an array of the keyPairs we create
	let keyPairs = [];
	// Keep track of the public keys to pass into the contract
	let pubKeys = [];
	console.log("Creating keypairs");
	for(var i = 0; i < NUM_KEYS; i++) {
		let keyPair = await KeyPair.fromRandom('ed25519'); 
		keyPairs.push(keyPair);   
		pubKeys.push(keyPair.publicKey.toString());   
	}

	// Create drop with pub keys, deposit_per_use, a default drop_config and metadata
	try {
		await fundingAccount.functionCall(
			KEYPOM_CONTRACT, 
			'create_drop', 
			{
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount(DEPOSIT_PER_USE_NEAR.toString()),
				config: {
					uses_per_key: DROP_CONFIG.usesPerKey,
					time: {
						start: DROP_CONFIG.time.start,
						end: DROP_CONFIG.time.end,
						throttle: DROP_CONFIG.time.throttle,
						interval: DROP_CONFIG.time.interval
					},
					usage: {
						permissions: DROP_CONFIG.usage.permissions,
						refund_deposit: DROP_CONFIG.usage.refundDeposit,
						auto_delete_drop:DROP_CONFIG.usage.autoDeleteDrop,
						auto_withdraw: DROP_CONFIG.usage.autoWithdraw
					
					},
					root_account_id: DROP_CONFIG.dropRoot
					
				},
				metadata: JSON.stringify(DROP_METADATA)
			}, 
			"300000000000000",
			// Change this deposit value to whatever is needed to fund your drop; this will be added to your balance...?
			parseNearAmount("2"),
		);

	} catch(e) {
		console.log('error creating drop: ', e);
	}

	console.log("checking to see if drop creation was successful, Keypom smart contract will panic if drop does not exist");
	await fundingAccount.functionCall(
		KEYPOM_CONTRACT, 
		'get_drop_information', 
		{
			key: pubKeys[0],
		}
	);
	
	//manually create linkdrops links with each key in the drop and index with pk
	let curPks = {};
	for(var i = 0; i < keyPairs.length; i++) {
		let linkdropUrl = NETWORK_ID == "testnet" ? `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}` : `https://mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPairs[i].secretKey}`;
		curPks[keyPairs[i].publicKey.toString()] = linkdropUrl;
		console.log(linkdropUrl);
	}

	//write file of all pk's and their respective linkdrops
	console.log('curPks: ', curPks)
	await writeFile(path.resolve(__dirname, `pks.json`), JSON.stringify(curPks));
}

start();
'''
'''--- deploy/utils/general.js ---
const { BN } = require("bn.js");
const { parseNearAmount, formatNearAmount } = require("near-api-js/lib/utils/format");
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

/// How much Gas each each cross contract call with cost to be converted to a receipt
const GAS_PER_CCC = 5000000000000; // 5 TGas
const RECEIPT_GAS_COST = 2500000000000; // 2.5 TGas
const YOCTO_PER_GAS = 100000000; // 100 million
const ATTACHED_GAS_FROM_WALLET = 100000000000000; // 100 TGas

/// How much yoctoNEAR it costs to store 1 access key
const ACCESS_KEY_STORAGE = new BN("1000000000000000000000");

// Initiate the connection to the NEAR blockchain.
const initiateNearConnection = async (network) => {
	const CREDENTIALS_DIR = ".near-credentials";

	const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
	(await path).join;
	let keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
		networkId: network,
		keyStore,
		nodeUrl: `https://rpc.${network}.near.org`,
		walletUrl: `https://wallet.${network}.near.org`,
		helperUrl: `https://helper.${network}.near.org`,
		explorerUrl: `https://explorer.${network}.near.org`,
	};

	near = await connect(nearConfig);
	return near;
};

// Initiate the connection to the NEAR blockchain.
const estimateRequiredDeposit = async (
    near,
    depositPerUse,
    numKeys,
    usesPerKey,
    attachedGas,
    storage = parseNearAmount("0.01"),
    fcData = null,
    ftData = null,
) => {
    let totalRequiredStorage = new BN(parseNearAmount("0.2"));
    console.log('totalRequiredStorage: ', totalRequiredStorage.toString())

    let actualAllowance = estimatePessimisticAllowance(attachedGas);
    console.log('actualAllowance: ', actualAllowance.toString())

    let totalAllowance = actualAllowance.mul(new BN(numKeys));
    console.log('totalAllowance: ', totalAllowance.toString())

    let totalAccessKeyStorage = ACCESS_KEY_STORAGE.mul(new BN(numKeys));
    console.log('totalAccessKeyStorage: ', totalAccessKeyStorage.toString())

    let {numNoneFcs, depositRequiredForFcDrops} = getNoneFcsAndDepositRequired(fcData, usesPerKey);
    let totalDeposits = new BN(depositPerUse).mul(new BN(usesPerKey - numNoneFcs)).mul(new BN(numKeys));
    console.log('totalDeposits: ', totalDeposits.toString())

    let totalDepositsForFc = depositRequiredForFcDrops.mul(new BN(numKeys));
    console.log('totalDepositsForFc: ', totalDepositsForFc.toString())

    let requiredDeposit = totalRequiredStorage
        .add(totalAllowance)
        .add(totalAccessKeyStorage)
        .add(totalDeposits)
        .add(totalDepositsForFc);
    
    console.log('requiredDeposit B4 FT costs: ', requiredDeposit.toString())
    
    if (ftData != null) {
        let extraFtCosts = await getFtCosts(near, numKeys, usesPerKey, ftData.contract_id);
        requiredDeposit = requiredDeposit.add(new BN(extraFtCosts));

        console.log('requiredDeposit AFTER FT costs: ', requiredDeposit.toString())
    }

    return requiredDeposit.toString();
};

// Estimate the amount of allowance required for a given attached gas.
const estimatePessimisticAllowance = (attachedGas) => {
    // Get the number of CCCs you can make with the attached GAS
    let numCCCs = Math.floor(attachedGas / GAS_PER_CCC);
    console.log('numCCCs: ', numCCCs)
    // Get the constant used to pessimistically calculate the required allowance
    let powOutcome = Math.pow(1.03, numCCCs);
    console.log('powOutcome: ', powOutcome)

    let requiredGas = (attachedGas + RECEIPT_GAS_COST) * powOutcome + RECEIPT_GAS_COST;
    console.log('requiredGas: ', requiredGas)
    let requiredAllowance = new BN(requiredGas).mul(new BN(YOCTO_PER_GAS));
    console.log('requiredAllowance: ', requiredAllowance.toString())
    return requiredAllowance;
};

// Estimate the amount of allowance required for a given attached gas.
const getNoneFcsAndDepositRequired = (fcData, usesPerKey) => {
    let depositRequiredForFcDrops = new BN(0);
    let numNoneFcs = 0;
    if (fcData == null) {
        return {numNoneFcs, depositRequiredForFcDrops};
    }

    let numMethodData = fcData.methods.length;

    // If there's one method data specified and more than 1 claim per key, that data is to be used
    // For all the claims. In this case, we need to tally all the deposits for each method in all method data.
    if (usesPerKey > 1 && numMethodData == 1) {
        let methodData = fcData.methods[0];

        // Keep track of the total attached deposit across all methods in the method data
        let attachedDeposit = new BN(0);
        for (let i = 0; i < methodData.length; i++) {
            attachedDeposit = attachedDeposit.add(new BN(methodData[i].attachedDeposit));
        }

        depositRequiredForFcDrops = depositRequiredForFcDrops.add(attachedDeposit).mul(usesPerKey);

        return {
            numNoneFcs,
            depositRequiredForFcDrops,
        }
    }
    // In the case where either there's 1 claim per key or the number of FCs is not 1,
    // We can simply loop through and manually get this data
    for (let i = 0; i < numMethodData; i++) {
        let methodData = fcData.methods[i];
        let isNoneFc = methodData == null;
        numNoneFcs += isNoneFc;

        if (!isNoneFc) {
            // Keep track of the total attached deposit across all methods in the method data
            let attachedDeposit = new BN(0);
            for (let j = 0; j < methodData.length; j++) {
                attachedDeposit = attachedDeposit.add(new BN(methodData[j].attachedDeposit));
            }

            depositRequiredForFcDrops = depositRequiredForFcDrops.add(attachedDeposit);
        }
    }

    return {
        numNoneFcs,
        depositRequiredForFcDrops,
    } 
};

// Estimate the amount of allowance required for a given attached gas.
const getFtCosts = async (near, numKeys, usesPerKey, ftContract) => {
    const viewAccount = await near.account("foo");
    const storageBalanceBounds = await viewAccount.viewFunction(ftContract, "storage_balance_bounds", {}); 
    console.log('storageBalanceBounds: ', storageBalanceBounds)
    let costs = new BN(storageBalanceBounds.min).mul(new BN(numKeys)).mul(new BN(usesPerKey)).add(new BN(storageBalanceBounds.min));
    console.log('costs: ', costs.toString());
    return costs.toString();
};

// Estimate the amount of allowance required for a given attached gas.
const getRecentDropId = async (fundingAccountObject, accountId, keypomContract) => {
    let dropSupplyForOwner = await fundingAccountObject.viewFunction(keypomContract, 'get_drop_supply_for_owner', {account_id: accountId});
	console.log('dropSupplyForOwner: ', dropSupplyForOwner)
	let dropsForOwner = await fundingAccountObject.viewFunction(keypomContract, 'get_drops_for_owner', { account_id: accountId, from_index: (dropSupplyForOwner - 1).toString() });
	console.log('dropsForOwner: ', dropsForOwner)

    return dropsForOwner[dropsForOwner.length - 1].drop_id;
};

module.exports = {
    initiateNearConnection,
    estimateRequiredDeposit,
    estimatePessimisticAllowance,
    getNoneFcsAndDepositRequired,
    getFtCosts,
    getRecentDropId,
    ATTACHED_GAS_FROM_WALLET
};
'''
'''--- package.json ---
{
	"name": "near-proxy-linkdrop-contract",
	"version": "1.0.0",
	"license": "MIT",
	"author": "Ben Kurrek, Matt Lockyer",
	"scripts": {
		"pub-docs": "rm -rf doc && mkdir doc && cargo doc --no-deps && cp -r target/doc/* doc && gh-pages -d doc",
		"dev-deploy": "echo building contract && yarn build-contract && echo removing neardev && rm -rf neardev && echo deploying && (near dev-deploy --wasmFile out/keypom.wasm || exit 0)",
		"build-contract": "./build.sh",
		"simple": "node deploy/simple/simple-create",
		"simple-sdk": "node deploy/simple/simple-create-sdk",
		"ft": "node deploy/ft/ft-create",
		"ft-sdk": "node deploy/ft/ft-create-sdk",
		"nft": "node deploy/nft/nft-create",
		"nft-sdk-minted": "node deploy/nft/nft-create-sdk-minted",
		"nft-sdk-owned": "node deploy/nft/nft-create-sdk-owned",
		"fc": "node deploy/function-call/fc-create",
		"fc-sdk": "node deploy/function-call/fc-create-sdk",
		"test": "yarn test:internals && yarn test:stage1 && yarn test:sales && yarn test:fc-drops && yarn test:nested-fc-fields && yarn test:ticketing && yarn test:poaps && yarn test:configs && yarn test:nft-drops && yarn test:ft-drops && yarn test:passwords",
		"test:internals": "ava __tests__/internals/test-internals.ava.ts",
		"test:stage1": "yarn test:stage1:simple",
		"test:stage1:simple": "ava __tests__/stage1/test-simple.ava.ts",
		"test:fc-drops": "ava __tests__/fc-drops/fc-drops.ava.ts",
		"test:nested-fc-fields": "ava __tests__/nested-fc-fields/nested-fc-fields.ava.ts",
		"test:ticketing": "ava __tests__/ticketing/ticketing-tests.ava.ts",
		"test:poaps": "ava __tests__/poaps/poap-tests.ava.ts",
		"test:configs": "ava __tests__/config-tests/config-tests.ava.ts",
		"test:nft-drops": "ava __tests__/nft-drops/nft-drops.ava.ts",
		"test:ft-drops": "ava __tests__/ft-drops/ft-drops.ava.ts",
		"test:profiling": "ava __tests__/profiling/profiling.ava.ts",
		"test:passwords": "ava __tests__/passwords/password-tests.ava.ts",
		"test:sales": "ava __tests__/pub-sales/pub-sales.ava.ts",
		"test:v3": "ava __tests__/v3-tests.ava.ts",
		"test:deletion:ft-single": "ava __tests__/deletion/ft-single-use.ava.ts",
		"test:deletion:ft-multi": "ava __tests__/deletion/ft-multi-use.ava.ts",
		"test:deletion:nft": "ava __tests__/deletion/nft-deletion.ava.ts",
		"test:creation": "ava __tests__/creation/create-and-add.ava.ts",
		"test:creation:near": "ava __tests__/creation/create-and-add.ava.ts",
		"test:creation:nft": "ava __tests__/creation/nft-creation.ts",
		"test:claim:null": "ava __tests__/claims/null-claim.ava.ts",
		"test:claim:ft": "ava __tests__/claims/ft-claim.ava.ts",
		"test:claim:near": "ava __tests__/claims/near-claim.ava.ts",
		"test:claim:nft": "ava __tests__/claims/nft-claim.ava.ts",
		"test:general": "ava __tests__/v3-tests.ava.ts",
		"test:failed": "ava __tests__/creation/failed-creation.ts",
		"test:edge": "ava __tests__/creation/edge-creation.ava.ts",
		"test:caac": "ava __tests__/claims/create-account-and-claim.ava.ts",
		"test:utils-test": "ava __tests__/claims/testing-utils.ava.ts",
		"test:constants": "ava __tests__/claims/constants-tweaking.ava.ts",
		"test:payment": "ava __tests__/creation/drop-payment.ava.ts",
		"test:nft-funding": "ava __tests__/creation/nft-funding.ava.ts",
		"test:nft-keys": "ava __tests__/nft-keys/nft-keys-basics.ava.ts",
		"test:delete-keys": "ava __tests__/deletion/key-deletion.ava.ts",
		"test:withdraw-nft": "ava __tests__/withdraw-assets/withdraw-nft.ava.ts",
		"test:withdraw-ft": "ava __tests__/withdraw-assets/withdraw-ft.ava.ts",
		"test:configs-usage": "ava __tests__/config-tests/usage-configs.ava.ts",
		"test:configs-time": "ava __tests__/config-tests/time-configs.ava.ts"
	},
	"dependencies": {
		"crypto": "^1.0.1",
		"gh-pages": "^4.0.0",
		"@keypom/core": "^1.0.1",
    	"@keypom/selector": "^1.1.0"
	},
	"devDependencies": {
		"@types/bn.js": "^5.1.0",
		"ava": "^5.0.1",
		"near-workspaces": "3.2.2",
		"ts-node": "^10.8.0",
		"typescript": "^4.6.4",
		"@near-js/accounts": "^0.1.3",
    	"@near-js/crypto": "^0.0.4",
    	"@near-js/keystores": "^0.0.4",
    	"@near-js/keystores-browser": "^0.0.4",
    	"@near-js/transactions": "^0.2.0",
    	"@near-js/types": "^0.0.4",
    	"@near-js/utils": "^0.0.4",
    	"@near-js/wallet-account": "^0.0.6"
	}
}

'''