*GitHub Repository "ico0018/near-smart-contract-rust-template"*

'''--- Cargo.toml ---
[package]
authors = ["Jacob Lindahl <jacob.lindahl@near.org>"]
edition = "2021"
name = "near-smart-contract-rust-template"
version = "0.1.0"

[dependencies]
near-contract-standards = "4.1.1"
near-sdk = "4.1.1"
near-sdk-contract-tools = "1.0.1"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
debug = false
lto = true
opt-level = "z"
overflow-checks = true
panic = "abort"

'''
'''--- Makefile.toml ---
[tasks.clean]
clear = true
script = """
cargo clean
rm -rf ./neardev/
rm -rf ./deploy/
"""

[tasks.test]
clear = true
script = """
#!/usr/bin/env bash

set -e
DEFAULT_ARCH="$(rustc -vV | awk '/host:/ {print $2}')"
cargo test --target $DEFAULT_ARCH
"""

[tasks.build]
args = ["build", "--target", "wasm32-unknown-unknown", "--release"]
command = "cargo"

# Prepare for prod deployment by optimizing the WASM file for size
[tasks.optimize]
dependencies = ["build"]
script = """
#!/usr/bin/env bash

set -e
WASM_PATH="$(find ./target/wasm32-unknown-unknown/release -maxdepth 1 -name "*.wasm")"

mkdir -p ./deploy/
wasm-tools strip "$WASM_PATH" > "./deploy/$(basename $WASM_PATH)"
# TODO: Figure out which wasm-opt flags don't break contracts
"""

[tasks.deploy]
dependencies = ["optimize"]
script = """
#!/usr/bin/env bash

set -e
RAW_WASM_PATH="$(find ./target/wasm32-unknown-unknown/release -maxdepth 1 -name "*.wasm")"
WASM_PATH="./deploy/$(basename $RAW_WASM_PATH)"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(./args.sh)"
"""

[tasks.dev-deploy]
dependencies = ["build"]
script = """
#!/usr/bin/env bash

set -e
WASM_PATH="$(find ./target/wasm32-unknown-unknown/release -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(./args.sh)" \
  --accountId "$(<./neardev/dev-account)"
"""

[tasks.call]
script = """
#!/usr/bin/env bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near call "$(<./neardev/dev-account)" "$@"
"""

[tasks.call-self]
script = """
#!/usr/bin/env bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near call "$(<./neardev/dev-account)" "$@" --accountId "$(<./neardev/dev-account)"
"""

[tasks.view]
script = """
#!/usr/bin/env bash

set -e
[ -f ./neardev/dev-account ] || (echo "Contract must be deployed"; false)
near view "$(<./neardev/dev-account)" "$@"
"""

'''
'''--- README.md ---
# NEAR Smart Contract Rust Template

Project structure for writing smart contracts for NEAR in Rust.

# Required Software

- [Rust & Cargo](https://www.rust-lang.org/tools/install)
  - With the WASM target installed: `rustup target add wasm32-unknown-unknown`
  - [cargo-make](https://crates.io/crates/cargo-make): `cargo install cargo-make`
- [Node.js](https://nodejs.org/)
  - The default initialization arguments script `args.sh` uses the Node.js interpreter, but that can easily be modified if you like. You probably will have Node.js installed anyways since it's required to use the NEAR CLI.
- [NEAR CLI](https://docs.near.org/tools/near-cli) ^3.4.1: `npm install -g near-cli`

# Usage

## Scripts

### `cargo make clean`

Removes the `target` and `neardev` directories.

### `cargo make test`

Runs unit tests using the default target. (Note: behavior may differ from simply running `cargo test` depending on the target specified in `.cargo/config.toml`.)

### `cargo make build`

Compiles the smart contract to a WebAssembly binary. The binary path is `./target/wasm32-unknown-unknown/release/<package>.wasm`.

### `cargo make call <method> <method-args> <...arguments>`

Calls the NEAR CLI:

```txt
near call <dev-account> <method> <method-args> <...arguments>
```

Where `<dev-account>` is the account ID of the most recent dev deployment on testnet.

### `cargo make call-self <method> <method-args> <...arguments>`

Calls the NEAR CLI:

```txt
near call <dev-account> <method> <method-args> <...arguments> --accountId <dev-account>
```

Where `<dev-account>` is the account ID of the most recent dev deployment on testnet.

### `cargo make view <method> <method-args> <...arguments>`

Calls the NEAR CLI:

```txt
near view <dev-account> <method> <method-args> <...arguments>
```

Where `<dev-account>` is the account ID of the most recent dev deployment on testnet.

### `cargo make optimize`

Cleans up and optimizes the most recently-built WASM binary. The optimized binary path is `./deploy/<name>.wasm`.

**Note**: In order to optimize the WASM binary, you must have [`wasm-tools`](https://github.com/bytecodealliance/wasm-tools) installed:

```txt
cargo install wasm-tools
```

`wasm-tools` is also available on Homebrew:

```txt
brew install wasm-tools
```

### `cargo make deploy <account-id>`

Deploys the most recently optimized WASM binary to `<account-id>` on the network specified by `NEAR_ENV`, and calls the `new` function with arguments generated by `args.sh`. (Implicitly calls `cargo make optimize` beforehand.)

### `cargo make dev-deploy [--force]`

Deploys the most recently built WASM binary to the dev account in `neardev/`, or to a new dev account if `neardev/` is not found or `--force` is set. Calls the `new` function with arguments generated by `args.sh`.

# Authors

- Jacob Lindahl <jacob.lindahl@near.org> [@sudo_build](https://twitter.com/sudo_build)

'''
'''--- args.sh ---
#!/usr/bin/env node

const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- rustfmt.toml ---
tab_spaces = 4

'''
'''--- src/contract.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, near_bindgen,
    store::Vector,
    BorshStorageKey, PanicOnDefault,
};
use near_sdk_contract_tools::{event, owner::*, standard::nep297::Event, Owner};

#[allow(unused)]
#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    History,
}

#[event(
    standard = "x-value-history",
    version = "1.0.0",
    serde = "near_sdk::serde"
)]
enum ContractEvent {
    ValueSet { old_value: u32, new_value: u32 },
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize, Owner)]
pub struct Contract {
    value: u32,
    history: Vector<u32>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {
            value: 0,
            history: Vector::new(StorageKey::History),
        };

        let predecessor = env::predecessor_account_id();
        Owner::init(&mut contract, &predecessor);

        contract.history.push(0);

        contract
    }

    pub fn set_value(&mut self, value: u32) {
        Self::require_owner();

        self.history.push(value);
        let old_value = self.value;
        self.value = value;

        ContractEvent::ValueSet {
            old_value,
            new_value: value,
        }
        .emit();
    }

    pub fn get_value(&self) -> u32 {
        self.value
    }

    pub fn get_historical_value(&self, index: u32) -> Option<&u32> {
        self.history
            .len()
            .checked_sub(index + 1)
            .map(|i| self.history.get(i).unwrap())
    }

    pub fn get_history_length(&self) -> u32 {
        self.history.len()
    }
}

'''
'''--- src/lib.rs ---
mod contract;
pub use contract::*;

#[allow(dead_code, unused)]
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::{test_utils::*, testing_env, AccountId, ONE_NEAR};

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test() {}
}

'''