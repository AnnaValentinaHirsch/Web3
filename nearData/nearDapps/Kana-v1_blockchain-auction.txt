*GitHub Repository "Kana-v1/blockchain-auction"*

'''--- Cargo.toml ---
[package]
name = "auction"
version = "0.1.0"
authors = ["Max"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
sha2 = "0.10.2"
serde_json = "1.0.81"
serde = "1.0.137"

[dev-dependencies]
workspaces = "0.3.0"
near-units = "0.2.0"
futures = "0.3.21"
tokio = { version = "1.18.2", features = ["full"] }
serde_json = "1.0.81"
anyhow = "1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Description
The core idea is just a traditinal auction where sellers can sell items and buyers can make bids and win items

# File structure
src -> contract code by itself

frontend -> frontend

# Tests
```
cargo test
```
# Run locally
```
cd frontend
npm i
npm start
```

'''
'''--- build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- deploy.sh ---
bash build.sh
near deploy contract.msolomodenko.testnet ./res/auction.wasm 
'''
'''--- frontend/README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.9.0",
    "@emotion/styled": "^11.8.1",
    "@mui/icons-material": "^5.8.3",
    "@mui/material": "^5.8.3",
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^13.5.0",
    "assert": "^2.0.0",
    "borsh": "^0.7.0",
    "buffer": "^6.0.3",
    "mathjs": "^10.6.1",
    "near-api-js": "^0.45.1",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4",
    "webpack": "^5.73.0",
    "webpack-cli": "^4.9.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/components/Accounts/Accounts.css ---
.accounts {
    min-width: 300px;
    min-height: 12%;
    border-radius: 20px;
    text-align: center;
    margin-left: 20px;
    margin-top: 10px;
    position: absolute;
    z-index: 1;
    background-color: #2F4050;
    color: white;
    font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
}

.accounts .accList {
    width: 100%;
    height: 100%;
    list-style: none;
    padding: 0;
    
}

.accounts .accList .accRow {
    width: 100%;
    height: 40px;
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.accounts .accList .accRow:hover {
    cursor: pointer;
    background-color: #293846;
}

.activeAccSign {
    width: 80%;
    height: 2px;
    background-color: rgb(25, 211, 149);
}

.accList .newAcc {
    box-sizing: border-box;
    text-align: center;
    width: 100%;
    height: 35px;
    background: #41596e;
    border-radius: 999px;
    box-shadow: #58738b 0 10px 20px -10px;
    box-sizing: border-box;
    color: #FFFFFF;
    cursor: pointer;
    font-family: Inter, Helvetica, "Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols, -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", sans-serif;
    font-size: 14px;
    font-weight: 700;
    line-height: 18px;
    opacity: 1;
    outline: 0 solid transparent;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    width: fit-content;
    word-break: break-word;
    border: 0;
    margin-top: 20px;
    padding: 8px 12px;
}

.accList .newAcc:active {
    box-shadow: 0px 0px 0px 0px;
    top: 5px;
    left: 5px;
}

'''
'''--- frontend/src/components/Accounts/Accounts.js ---
import React from 'react'
import './Accounts.css'
import { login, getAccountId, logout } from '../../contract/utils'

function signIn(accounts) {
    let IDs = Array.from(accounts.keys())
    accounts = new Map()

    IDs.map((value) => {
        return accounts.set(value, false)
    })

    console.log(JSON.stringify(Array.from(accounts.entries())))

    localStorage.setItem('usersAccounts', JSON.stringify(Array.from(accounts.entries())))

    logout()
    login()
}

function Accounts() {
    let existingAccs = JSON.parse(localStorage.getItem('usersAccounts'))
    let accs = new Map()

    for (let i = 0; i < existingAccs?.length; i++) {
        accs.set(existingAccs[i][0], existingAccs[i][1])
    }

    const accId = getAccountId()
    if (accId !== "") {
        accs.delete(accId)
        accs.set(accId, true)
    }

    const accounts = Array.from(accs.keys())

    return (
        <div className='accounts' style={{ borderColor: "green" }}>
            <ul className='accList'>
                {accounts.map((value, key) => {
                    return (
                        <li key={key} className='accRow' onClick={() => {
                            signIn(accs)
                        }}>
                            {value}
                            {accs.get(value) === true ? <div className="activeAccSign"></div> : ''}
                        </li>
                    )
                })}

                <button className="newAcc" onClick={() => {
                    signIn(accs)
                }}>Add new account</button>
            </ul>
        </div>)
}

export default Accounts

'''
'''--- frontend/src/components/AdminPanel/AdminPanel.css ---
.adminPanel {
    min-width: 300px;
    min-height: 20%;
    border-radius: 20px;
    text-align: center;
    position: absolute;
    margin-top: 30vh;
    margin-left:20px;
    z-index: 1;
    background-color: #2F4050;
    color: white;
    font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
    display: block;
}

.adminPanel .addNewItem {
    display: flex;
    flex-direction: column;
    height: 50%;
    margin: 20px;
    align-items: center;
}

.adminPanel .addNewItem div {
    margin: 5px;
}

.addNewItem .newItemBtn {
    width: 200px;
    height: 50px;
}

.adminPanel button {
    box-sizing: border-box;
    text-align: center;
    min-width: 40%;
    height: 35px;
    background: #41596e;
    border-radius: 999px;
    box-shadow: #58738b 0 10px 20px -10px;
    box-sizing: border-box;
    color: #FFFFFF;
    cursor: pointer;
    font-family: Inter, Helvetica, "Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols, -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", sans-serif;
    font-size: 14px;
    font-weight: 700;
    line-height: 18px;
    opacity: 1;
    outline: 0 solid transparent;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    width: fit-content;
    word-break: break-word;
    border: 0;
    margin-top: 20px;
    padding: 8px 12px;
}

.auctionActions .btnDisabled,
.adminPanel .btnDisabled {
    background-color: grey;
    cursor: default;
}

.adminPanel .auctionActions {
    margin-bottom: 20px;
    display: flex;
    justify-content: space-around;
}

.adminPanel button:active {
    box-shadow: 0px 0px 0px 0px;
    top: 5px;
    left: 5px;
}

h2 {
    text-align: center;
    margin-bottom: 50px;
}

h2 small {
    font-weight: normal;
    color: #888;
    display: block;
}

.group {
    position: relative;
}

.addNewItem .groupWrapper {
    display: flex;
}

input {
    font-size: 18px;
    padding: 10px 10px 10px 5px;
    display: block;
    width: 150px;
    border: none;
    border-bottom: 1px solid #757575;
}

input:focus {
    outline: none;
}

label {
    color: #999;
    font-size: 18px;
    font-weight: normal;
    position: absolute;
    pointer-events: none;
    left: 5px;
    top: 10px;
}

input:focus~label,
input:valid~label {
    top: -20px;
    font-size: 14px;
    color: rgb(25, 211, 149);
}

.bar {
    position: relative;
    display: block;
    width: 150px;
}

.bar:before,
.bar:after {
    content: '';
    height: 2px;
    width: 0;
    bottom: 1px;
    position: absolute;
    background: rgb(25, 211, 149);
    transition: 0.2s ease all;
    -moz-transition: 0.2s ease all;
    -webkit-transition: 0.2s ease all;
}

.bar:before {
    left: 50%;
}

.bar:after {
    right: 50%;
}

input:focus~.bar:before,
input:focus~.bar:after {
    width: 50%;
}

.highlight {
    position: absolute;
    height: 60%;
    width: 100px;
    top: 25%;
    left: 0;
    pointer-events: none;
    opacity: 0.5;
}

input:focus~.highlight {
    -webkit-animation: inputHighlighter 0.3s ease;
    -moz-animation: inputHighlighter 0.3s ease;
    animation: inputHighlighter 0.3s ease;
}

@-webkit-keyframes inputHighlighter {
    from {
        background: #5264AE;
    }

    to {
        width: 0;
        background: transparent;
    }
}

@-moz-keyframes inputHighlighter {
    from {
        background: #5264AE;
    }

    to {
        width: 0;
        background: transparent;
    }
}

@keyframes inputHighlighter {
    from {
        background: #5264AE;
    }

    to {
        width: 0;
        background: transparent;
    }
}

'''
'''--- frontend/src/components/AdminPanel/AdminPanel.js ---
import './AdminPanel.css'
import React from 'react'
import { addItemToAuction, isAuctionOpen, produceAuction, startNewAuction } from '../../contract/utils'
import * as nearAPI from "near-api-js";
const { utils } = nearAPI;

function updateAuctionState(changeAuctionState) {
    isAuctionOpen().then(isAuctionOpen => {
        changeAuctionState(isAuctionOpen)
    })
}

export default function AdminPanel() {
    const [auctionCreated, changeAuctionState] = React.useState(false)
    const [item, setItem] = React.useState('')
    const [itemMinBid, setItemMinBid] = React.useState('')

    const [addItemBtnDisabled, setAddItemBtnState] = React.useState(true)
    const [createNewAucBrnDisabled, setNewAucBtnState] = React.useState(true)
    const [produceAucBtnDisabled, setProduceAucBtnState] = React.useState(true)

    React.useEffect(() => {
        isAuctionOpen().then(isAuctionOpen => {
            changeAuctionState(isAuctionOpen)
            setAddItemBtnState(false)
            setNewAucBtnState(false)
            setProduceAucBtnState(false)
        })

        const interval = setInterval(() => {
            updateAuctionState(changeAuctionState)
        }, 5000)
        return () => clearInterval(interval)
    }, [])

    return (
        <div className="adminPanel">
            <div className='addNewItem'>
                <div className='groupWrapper'>
                    <div className="group">
                        <input type="text" required
                            value={item}
                            onChange={(e) => setItem(e.target.value)} />
                        <span className="highlight"></span>
                        <span className="bar"></span>
                        <label>Item</label>
                    </div>
                    <div className="group">
                        <input type="text" required
                            value={itemMinBid}
                            onChange={(e) => {
                                e.target.value = e.target.value.replace(/\D/g, '') // remove non-numeric values

                                if (e.target.value !== '') {
                                    setItemMinBid(Number(e.target.value))
                                } else {
                                    setItemMinBid('')
                                }
                            }}
                        />
                        <span className="highlight"></span>
                        <span className="bar"></span>
                        <label>Minimal bid (N) &gt;=1</label>
                    </div>
                </div>
                <button disabled={!auctionCreated || addItemBtnDisabled} className={auctionCreated && !addItemBtnDisabled ? 'newItemBtn' : 'newItemBtn btnDisabled'} onClick={() => {
                    if (item === '' || itemMinBid === '' || itemMinBid < 1) {
                        return
                    }

                    setAddItemBtnState(true)

                    addItemToAuction(item, utils.format.parseNearAmount(itemMinBid.toString()))
                        .then(() => {
                            setItemMinBid('');
                            setItem('')
                            setAddItemBtnState(false)
                        })
                }}>{addItemBtnDisabled ? '...' : 'Add new item'}</button>
            </div>
            <div className='auctionActions'>
                <button disabled={auctionCreated} className={auctionCreated || createNewAucBrnDisabled ? 'btnDisabled' : ''} onClick={() => {
                    setNewAucBtnState(true)

                    startNewAuction().then(() => {
                        updateAuctionState(changeAuctionState)
                        setNewAucBtnState(false)
                    })
                }}>{createNewAucBrnDisabled ? '...' : 'Create new auction'}</button>
                <button disabled={!auctionCreated} className={auctionCreated && !produceAucBtnDisabled ? '' : 'btnDisabled'} onClick={() => {
                    setProduceAucBtnState(true)

                    produceAuction().then(() => {
                        updateAuctionState(changeAuctionState)
                        setProduceAucBtnState(false)
                    })
                }}>{produceAucBtnDisabled ? '...' : 'Produce an auction'}</button>
            </div>
        </div>
    )
}
'''
'''--- frontend/src/components/App.css ---
html {
  height: 100%;
  min-height: 100vh;
  width: 100vw;
  margin: 0;
  padding: 0;
}

#app {
  height: 100%;
  min-height: 100vh;
  width: 100vw;
  margin: 0;
  padding: 0;
}

.App {
  width: 100vw;
  height: 100vh;
}

body {
  min-height: 100vh;
  margin: 0;
  padding: 0;
}

.sidebar,
.smallSidebar {
  height: 100%;
  width: 15%;
  background-color: #2F4050;
}

.smallSidebar {
  width: 5%;
}

.sidebarList {
  height: auto;
  padding: 0;
  width: 100%;
}

.sidebarList .row,
.menuRow {
  width: 100%;
  height: 60px;
  list-style-type: none;
  margin: 0;
  display: flex;
  flex-direction: row;
  color: white;
  justify-content: center;
  align-items: center;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
}

.sidebarList .cutMenu {
  width: 100%;
  height: 60px;
  list-style-type: none;
  margin: 0;
  display: flex;
  flex-direction: row;
  color: white;
  padding-left: 10%;
  align-items: center;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
}

.sidebarList .menuRow:hover, .cutMenu:hover {
  cursor: pointer;
}

.sidebarList .row:hover {
  cursor: pointer;
  background-color: #293846;
}

.sidebarList #active {
  background-color: #293846;
}

.line {
  width: 3px;
  height: 100%;
  background-color: rgb(25, 211, 149);
  visibility: hidden;
}

.sidebarList #active .line {
  visibility: visible;
}

.row #icon {
  flex: 30%;
  display: grid;
  place-items: center;
}

.row #title {
  flex: 70%;
}

#account-arrow,
#account-arrow-active {
  margin-left: -25px;
  margin-right: 15px;
  width: 20px;
  height: 20px;
}

#account-arrow-active {
  transform: rotate(90deg);
}
'''
'''--- frontend/src/components/App.js ---
import './App.css';
import MainPage from './MainPage/MainPage'

function App() {
  return (
    <div className="App">
      <MainPage/>
    </div>
  );
}

export default App;

'''
'''--- frontend/src/components/Items/Items.css ---
div {
    font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
    font-size: large;
}

.tilesWrap {
    padding: 0;
    margin: auto;
    list-style: none;
    text-align: center;
    display: flex;
    flex-basis: 100%;
    flex-flow: wrap;
}

.tilesWrap li {
    width: 20%;
    padding: 80px 20px 40px;
    position: relative;
    margin: 10px;
    font-family: 'helvetica', san-serif;
    background: #262a2b;
    border: 1px solid #252727;
    text-align: left;
    display: flex;
    flex-direction: row;
}

.tilesWrap li h2 {
    font-size: 40px;
    margin: 0;
    position: absolute;
    opacity: 0.2;
    top: 50px;
    right: 10px;
    transition: all 0.3s ease-in-out;
}

.tilesWrap li h3 {
    font-size: 20px;
    color: #b7b7b7;
    margin-bottom: 5px;
}

.tilesWrap li p {
    font-size: 16px;
    line-height: 18px;
    color: #b7b7b7;
    margin-top: 5px;
}

.tilesWrap li:hover h2 {
    top: 0px;
    opacity: 0.6;
}

.tilesWrap li:before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    z-index: -1;
    background: #fff;
    transform: skew(2deg, 2deg);
}

.tilesWrap li:after {
    content: '';
    position: absolute;
    width: 40%;
    height: 100%;
    left: 0;
    top: 0;
    background: rgba(255, 255, 255, 0.02);
}

.tilesWrap li:before {
    background: #f2709c;
    background: -webkit-linear-gradient(to right, #ff9472, #f2709c);
    background: linear-gradient(to right, #ff9472, #f2709c);
}
'''
'''--- frontend/src/components/Items/Items.js ---
import React from 'react'
import './Items.css'
import UpdateIcon from '@mui/icons-material/Update';
import { getItems } from '../../contract/utils'

function Items() {
    let [items, setItems] = React.useState([])

    let [updateColor, setUpdateColor] = React.useState('red')

    React.useEffect(() => {
        getItems().then(result => {
            if (result !== undefined && result !== null) {
                setItems(result)
            }
            
            setUpdateColor('green')
        })
    }, [])

    return (
        <div style={{ width: '100%', height: '100%' }}>
            <div style={{ color: updateColor, position: 'absolute', right: '10px', zIndex: '1', cursor: 'pointer' }} onClick={() => {
                if (updateColor === 'red') {
                    return
                }

                setUpdateColor('red')
                getItems().then(items => {
                    setItems(items)
                    setUpdateColor('green')
                })

            }}>
                <UpdateIcon />
            </div>
            {items.length === 0 ? 'You have not won any items yet' : ''}
            <ul className="tilesWrap">
                {items.map((value, key) => {
                    return (
                        <li key={key}>
                            <h2>{key + 1}</h2>
                            <p>{value}</p>
                        </li>)
                })}
            </ul>
        </div>
    )
}

export default Items
'''
'''--- frontend/src/components/Lots/Lots.css ---
@import url('https://fonts.googleapis.com/css?family=Arapey|Cantarell|Comfortaa|Khand|Russo+One|Ubuntu');

.auctions {
    display: flex;
    list-style: none;
    flex-flow: wrap;
    width: 100%;
    height: 100%;
    padding-left: 15px;
    align-content: flex-start;
}

.auctions>li {
    width: 35%;
    max-height: 40%;
    border: 3px solid #48617a;
    margin-top: 20px;
    margin-bottom: 0;
    margin-right: 20px;
    border-radius: 60px;
    margin-left: 20px;
    padding: 10px;
}

.auctions li .itemEl {
    box-sizing: border-box;
    text-align: center;
    width: 100%;
    margin-top: 10px;
    padding-bottom: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

li button {
    box-sizing: border-box;
    text-align: center;
    width: 50%;
    height: 35px;
    margin-top: 5px;
    margin-bottom: 7px;
    border-radius: 999px;
    box-shadow: #2f2f72 0 10px 20px -10px;
    box-sizing: border-box;
    color: #FFFFFF;
    font-family: Inter, Helvetica, "Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols, -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", sans-serif;
    font-size: 16px;
    font-weight: 700;
    line-height: 24px;
    opacity: 1;
    outline: 0 solid transparent;
    padding: 8px 18px;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    width: fit-content;
    word-break: break-word;
    border: 0;
}

li button:active {
    box-shadow: 0px 0px 0px 0px;
    top: 5px;
    left: 5px;
}

.winnerHelper {
    width: 20%;
    height: 20px;
    border-bottom: 1px solid;
}

.auctions li .titleLine {
    min-width: 80%;
    color: white;
    margin-right: 5px;
    margin-left: 5px;
}

.con-tooltip {
    position: relative;
    border-radius: 9px;
    padding: 0 20px;
    margin: 10px;

    display: inline-block;

    cursor: default;
}

.tooltip {
    visibility: hidden;
    z-index: 1;
    opacity: .40;

    width: 86%;
    padding: 0px 20px;

    background: #333;
    color: #ff9472;

    position: absolute;

    border-radius: 9px;
    font: 16px;

    transform: translateY(9px);
    transition: all 0.3s ease-in-out;

    box-shadow: 0 0 3px rgba(56, 54, 54, 0.86);
}

.tooltip::after {
    content: " ";
    width: 0;
    height: 0;

    border-style: solid;
    border-width: 12px 12.5px 0 12.5px;
    border-color: #333 transparent transparent transparent;

    position: absolute;
    left: 40%;

}

.con-tooltip:hover .tooltip {
    visibility: visible;
    transform: translateY(-10px);
    opacity: 1;
    transition: .3s linear;
    animation: odsoky 1s ease-in-out infinite alternate;
}

.right:hover {
    transform: translateX(6px);
}

.right .tooltip {
    top: -20%;
    left: 115%;
}

.right .tooltip::after {
    top: 20%;
    left: -12%;
    transform: rotate(90deg);
}

.auctions .text {
    margin-left: 20px;
    font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
    font-size: large;
}
'''
'''--- frontend/src/components/Lots/Lots.js ---
import React from 'react'
import './Lots.css'
import UpdateIcon from '@mui/icons-material/Update';
import { getLots, makeBid } from '../../contract/utils'
import * as nearAPI from "near-api-js";
const { utils } = nearAPI;

export default function Auctions() {
    let [lots, setLots] = React.useState([])
    let [updateColor, setUpdateColor] = React.useState('green')
    let [buttonIsAble, setButtonAble] = React.useState(true)

    React.useEffect(() => {
        getLots().then(result => setLots(result))
    }, [])

    return (
        <div style={{ width: '100%', height: '100%' }}>

            <ul className='auctions'>
                <div style={{ color: updateColor, position: 'relative', left: '1%', cursor: 'pointer' }} onClick={() => {
                    if (updateColor === 'red') {
                        return
                    }

                    setUpdateColor('red')
                    getLots().then(lots => setLots(lots))
                    setUpdateColor('green')
                }}>
                    <UpdateIcon />
                </div>
                <div className  = "text">
                    {lots.length === 0 ? 'There are no active lots now' : ''}
                </div>

                {lots.map((value, key) => {
                    if (value.are_u_supplier) {
                        return null
                    }

                    return (
                        <li key={key}>
                            <div className="itemEl">{value.item}</div>
                            <hr className="titleLine" />
                            <div className="itemEl">
                                <div className="con-tooltip right winnerHelper" style={{ borderColor: value.are_u_winner ? "green" : "red" }}
                                >
                                    {utils.format.formatNearAmount(value.current_bid)}
                                    <div className="tooltip"><p>{value.are_u_winner ? "your bid is winning" : "your bid is loosing"}</p></div>
                                </div>
                                <button onClick={() => {
                                    setButtonAble(false)

                                    let attachedDeposit = prompt("Please enter amount of the tokens you want to bid", "1")
                                    if (attachedDeposit === null || attachedDeposit === "" || attachedDeposit === undefined) {
                                        attachedDeposit = "1"
                                    }

                                    makeBid(value.item_hash, utils.format.parseNearAmount(attachedDeposit))
                                    getLots().then(lots => setLots(lots))

                                    setButtonAble(true)
                                }} disabled={!buttonIsAble} style={{ backgroundColor: buttonIsAble ? '#24245c' : 'grey', cursor: buttonIsAble ? 'pointer' : '' }}>Make a bid</button>
                            </div>
                        </li>
                    )
                })}
            </ul>
        </div >
    )
}
'''
'''--- frontend/src/components/MainPage/MainPage.css ---
.items {
    width: 50%;
    height: auto;
    overflow-y:scroll;
}

.border {
	font-size: 1.6rem;
	display: grid;
	place-items: center;
	height: 100%;
	border: 5px solid;
	padding: 1rem;
}

.sides {
    border-image: linear-gradient(to right, rgb(25, 211, 149), rgb(240, 237, 103)) 0 0 0 1;
}

.technicalWrapper {
    position: relative;
}
'''
'''--- frontend/src/components/MainPage/MainPage.js ---
import React from 'react'
import Sidebar from '../Sidebar/Sidebar'
import Items from '../Items/Items'
import Lots from '../Lots/Lots'
import Accounts from '../Accounts/Accounts'
import AdminPanel from '../AdminPanel/AdminPanel'
import './MainPage.css'

function MainPage() {
    const [clicked, setClicked] = React.useState(new Set())

    return (
        <div style={{ height: '100%', display: 'flex' }}>
            <Sidebar style={{ innerHeight: '100%' }}
                clicked={clicked}
                setClicked={setClicked} />
            <div className="technicalWrapper">
                <div style={clicked.has('Account') ? { visibility: 'visible' } : { visibility: 'hidden' }}>
                    <Accounts />
                </div>

                <div style={clicked.has('Admin panel') ? { visibility: 'visible' } : { visibility: 'hidden' }}>
                    <AdminPanel />
                </div>
            </div>

            <div style={{ height: '100%', width: '100%' }}>
                <div style={{ height: '100%', width: '100%', display: 'flex' }}>
                    <div style={clicked.has('Lots') ? { visibility: 'visible', width: '50%' } : { visibility: 'hidden', width: '50%' }}><Lots /></div>
                    <div className="items sides border" style={clicked.has('Items') ? { visibility: 'visible' } : { visibility: 'hidden' }}><Items /></div>
                </div>
            </div>

        </div>
    )
}

export default MainPage

'''
'''--- frontend/src/components/Sidebar/Sidebar.js ---
import React from 'react'
import { SidebarData } from './SidebarData'
import MenuIcon from '@mui/icons-material/Menu';

function Sidebar(props) {
    const [fullList, setFullList] = React.useState(false)

    return (
        <div className={fullList ? 'sidebar' : 'smallSidebar'} >
            <ul className='sidebarList'>
                <div className={!fullList ? 'menuRow' : 'cutMenu'} onClick={() => setFullList(!fullList)}>
                    <MenuIcon />
                </div>
                {SidebarData.map((value, key) => {
                    return (
                        <li key={key} className='row' onClick={() => {
                            props.clicked.has(value.title) ? props.clicked.delete(value.title) : props.clicked.add(value.title)
                            props.setClicked(new Set(props.clicked))
                        }}
                            id={props.clicked.has(value.title) ? 'active' : ''}>
                            <div className="line"></div>
                            <div id='icon'>{value.icon}</div>

                            {fullList ? <div id="title">{value.title}</div> : ''}
                        </li>
                    )
                })}
            </ul>
        </div>
    )
}

export default Sidebar
'''
'''--- frontend/src/components/Sidebar/SidebarData.js ---
import React from 'react'
import SellIcon from '@mui/icons-material/Sell';
import DataArrayIcon from '@mui/icons-material/DataArray';
import AccountCircleIcon from '@mui/icons-material/AccountCircle';
import AdminPanelSettingsIcon from '@mui/icons-material/AdminPanelSettings';

export const SidebarData = [
    {
        title: 'Account',
        icon: <AccountCircleIcon />,
    },
    {
        title: 'Lots',
        icon: <SellIcon />,
    },
    {
        title: 'Items',
        icon: <DataArrayIcon />,
    },
    {
        title: 'Admin panel',
        icon: <AdminPanelSettingsIcon />,
    }
]

'''
'''--- frontend/src/contract/config.js ---
const CONTRACT_NAME = 'contract.msolomodenko.testnet'

function getConfig() {
    return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
    }
}

export default getConfig;
'''
'''--- frontend/src/contract/utils.js ---
import { connect, Contract, WalletConnection, keyStores, DEFAULT_FUNCTION_CALL_GAS } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig()

export async function initContract() {
    const near = await connect(Object.assign({
        deps: {
            keyStore: new keyStores.BrowserLocalStorageKeyStore()
        }
    }, nearConfig))

    window.walletConnection = new WalletConnection(near)

    window.accountId = window.walletConnection.getAccountId()

    window.contract = new Contract(window.walletConnection.account(), nearConfig.contractName, {
        viewMethods: ['get_lots', 'get_items', 'get_auction_state'],
        changeMethods: ['add_item_to_auction', 'produce_auction', 'make_bid', 'start_new_auction']
    })
}

export function logout() {
    window.walletConnection.signOut()
}

export function login() {
    window.walletConnection.requestSignIn({ contractId: nearConfig.contractName })
}

export async function getItems() {
    return await window.contract.get_items({ account_id: getAccountId().toString() }).catch(errorHandler)
}

export async function isAuctionOpen() {
    return await window.contract.get_auction_state({}).catch(errorHandler)
}

export async function getLots() {
    let lots = await window.contract.get_lots({ args: {} }).catch(errorHandler)
    if (lots === null || lots === undefined || lots === '') {
        return
    }

    try {
        lots = JSON.parse(lots)
        let suitableLots = []
        lots.forEach(lot => {
            suitableLots.push({
                is_owner: true,
                item: lot.item,
                current_bid: lot.current_bid.toLocaleString('fullwide', { useGrouping: false }),
                are_u_winner: getAccountId() === lot.winner,
                are_u_supplier: getAccountId() === lot.supplier,
                item_hash: lot.item_hash
            })
        })

        return suitableLots

    }
    catch (err) {
        errorHandler(err)
    }
}

export async function addItemToAuction(item, minBid) {
    await window.contract.add_item_to_auction({ args: { item: item, min_bid: minBid } }).catch(errorHandler)
}

export async function produceAuction() {
    await window.contract.produce_auction({ args: {} }).catch(errorHandler)
}

export async function makeBid(itemHash, attachedDeposit) {
    await window.contract.make_bid({ item_hash: itemHash }, DEFAULT_FUNCTION_CALL_GAS, attachedDeposit).catch(errorHandler)
}

export async function startNewAuction() {
    await window.contract.start_new_auction({ args: {} }).catch(errorHandler)
}

export function getAccountId() {
    return window.walletConnection.getAccountId()
}

function errorHandler(err) {
    console.log(err)
}

'''
'''--- frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './components/App';
import reportWebVitals from './reportWebVitals';
import {initContract} from './contract/utils';

window.Buffer = window.Buffer || require("buffer").Buffer;

initContract()

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();

'''
'''--- frontend/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- src/helper.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
};

/// Helper that separates non-main contract actions
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Helper {
    next_id_length: u64,
}

impl Helper {
    pub fn new() -> Self {
        Self { next_id_length: 0 }
    }

    /// generates unique ids for near collections 
    pub fn generate_collection_id(&mut self) -> Vec<u8> {
        let symbols = vec![
            "a", "b", "c", "d", "e", "f", "g", "h", "q", "w", "}", "r", "t", "y", "u", "i", "p",
            "o", "r", "!", "1", "2", "3", "3", "4",
        ];

        let mut collection_id = Vec::<u8>::new();

        let mut j = 0usize;

        for i in 0..self.next_id_length {
            if i as usize / symbols.len() >= 1 {
                j = 0
            }

            collection_id.extend(symbols[j].as_bytes());
            j += 1;
        }

        self.next_id_length += 1;

        collection_id
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn test_id_generating() {
        let id = "abcdefghqw}";
        let mut generated_id = Vec::<u8>::new();
        let mut helper = super::Helper::new();

        for _ in 0..12 {
            generated_id = helper.generate_collection_id();
        }

        assert_eq!(id.as_bytes().to_vec(), generated_id);

        assert_eq!(
            "abcdefghqw}r".as_bytes().to_vec(),
            helper.generate_collection_id()
        );
    }
}
'''
'''--- src/lib.rs ---
mod helper;
pub mod supplier;

use std::collections::HashMap;

use helper::Helper;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, Vector};
use near_sdk::serde::Serialize;
use near_sdk::{env, PanicOnDefault};
use near_sdk::{near_bindgen, AccountId, Promise};

use crate::supplier::Supplier;

type Item = String;
type Money = u128;
type ItemHash = String;

/// Representation of a user's bid that contains information about account id and amount of bid
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone)]
pub struct Bid {
    pub account_id: AccountId,
    pub bid: Money,
}

/// Representation of a lot for frontend
#[derive(Serialize)]
struct Lot {
    item_hash: ItemHash,
    item: Item,
    supplier: AccountId,
    winner: AccountId,
    current_bid: u128,
}

impl Bid {
    pub fn new(account_id: &AccountId, bid: &Money) -> Self {
        Self {
            account_id: account_id.clone(),
            bid: *bid,
        }
    }
}

/// contract for performing auction between suppliers and buyers
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Auction {
    pub suppliers: UnorderedMap<AccountId, Supplier>, // who want to sell item
    pub items_and_bids: UnorderedMap<ItemHash, Bid>,  // current bid for each item
    pub users_bids: UnorderedMap<AccountId, Money>, // whole sum of all bids for each user (e.g. user wants to buy item_1 and item_2. He bids item_1 = 1 token, item_2 = 1 token. Sum will be 2 tokens)
    pub winners_items: LookupMap<AccountId, Vector<Item>>, // each item winner

    auction_is_open: bool, // does suppliers can add new items or buyers can add new bids for the current auction
    helper: Helper,
}

#[near_bindgen]
impl Auction {
    #[init]
    pub fn new() -> Self {
        Self {
            suppliers: UnorderedMap::new(b"suppliers".to_vec()),
            items_and_bids: UnorderedMap::new(b"items_and_bids".to_vec()),
            users_bids: UnorderedMap::new(b"users_bids".to_vec()),
            winners_items: LookupMap::new(b"winners_items".to_vec()),
            auction_is_open: false,
            helper: Helper::new(),
        }
    }

    /// make a signal that buyers can make bids and suppliers can add items
    ///
    /// # Panics
    ///
    ///  * if an auction has not been opened yet
    pub fn start_new_auction(&mut self) {
        assert!(!self.auction_is_open, "Auction is already opened");
        self.auction_is_open = true;
    }

    /// return all items that caller won
    pub fn get_items(&self, account_id: String) -> Vec<String> {
        let items = self
            .winners_items
            .get(&AccountId::new_unchecked(account_id));

        match items {
            Some(itms) => itms.to_vec(),
            None => Vec::<String>::new(),
        }
    }

    /// return all available lots
    pub fn get_lots(&self) -> String {
        let mut lots = Vec::<Lot>::new();

        for (_, supplier) in self.suppliers.iter() {
            for (item_hash, item) in supplier.items.iter() {
                let winner_bid = self.items_and_bids.get(&item_hash).unwrap_or_else(|| {
                    Bid::new(&AccountId::new_unchecked("0".to_string()), &item.min_bid)
                });

                lots.push(Lot {
                    item: item.itself,
                    supplier: supplier.id.clone(),
                    current_bid: winner_bid.bid,
                    item_hash,
                    winner: winner_bid.account_id,
                })
            }
        }

        serde_json::to_string(&lots).unwrap()
    }

    /// clear all data except won items after an auction has been finished
    pub fn clear_data(&mut self) {
        self.suppliers.clear();
        self.items_and_bids.clear();
        self.users_bids.clear();
    }

    /// make bid for item
    ///
    /// # Arguments
    ///
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    ///
    /// # Panics
    ///
    ///  * auction must be started
    ///  * supplier can not make bid for his own item
    ///  * attached deposit must be more than item's minimal bid
    ///  * item must exists
    ///  * bid has to be bigger than previous
    #[payable]
    pub fn make_bid(&mut self, item_hash: &ItemHash) {
        assert!(self.auction_is_open, "Auction is closed. Try again later");

        assert!(
            !self.does_supplier_make_bid_for_his_item(&item_hash),
            "Supplier can not make bid for his items"
        );

        let mut item_exists = false;

        for mut supplier in self.suppliers.values() {
            let (can_bid, min_bid) = supplier.bid_can_be_done(&item_hash, &env::attached_deposit());
            if !can_bid {
                panic!(
                    "This item has {} minimum bid. Actual: {}",
                    min_bid,
                    env::attached_deposit()
                )
            }

            if min_bid >= supplier::DEFAULT_MIN_BID {
                item_exists = true;
                break;
            }
        }

        assert!(!item_exists, "Item with hash {} does not exist", item_hash);

        if let Some(exists_bid) = self.items_and_bids.get(&item_hash) {
            assert!(
                env::attached_deposit() > exists_bid.bid,
                "A bigger bid for this item already exists"
            );
        }

        self.items_and_bids.insert(
            &item_hash,
            &Bid::new(&env::predecessor_account_id(), &env::attached_deposit()),
        );

        let bid = self
            .users_bids
            .get(&env::predecessor_account_id())
            .unwrap_or_default()
            + env::attached_deposit();

        self.users_bids.insert(&env::predecessor_account_id(), &bid);
    }

    /// return money to the user
    ///
    /// # Arguments
    ///
    /// * `account_id` - user's account id
    /// * `amount` - amount of money that has to be returned
    ///
    /// # Panics
    ///
    /// * user must have bids with equal or more amount of money that wants to return
    fn return_money(&mut self, account_id: &AccountId, amount: &u128) {
        assert!(
            self.users_bids.get(&account_id).is_some(),
            "there is no bid for user {}",
            account_id
        );

        assert!(
            self.users_bids.get(&account_id).unwrap() >= *amount,
            "Can not return {} tokens for user {} because his bid is less",
            account_id,
            amount,
        );

        Promise::new(account_id.clone()).transfer(*amount);
    }

    /// execute an auction process
    ///
    /// # Panics
    ///
    /// * auction must not be finished
    pub fn produce_auction(&mut self) {
        assert!(self.auction_is_open, "Auction has already been finished");

        self.auction_is_open = false;

        let mut winners = HashMap::<ItemHash, Bid>::new();

        /* #region pick winners and recalculate their sum of bids */

        for item_and_bid in self.items_and_bids.iter() {
            winners.insert(item_and_bid.0.clone(), item_and_bid.1.clone());

            let rest_money = self
                .users_bids
                .get(&item_and_bid.1.account_id)
                .unwrap_or(item_and_bid.1.bid)
                - item_and_bid.1.bid; // if user won in an auction and loosed in another auction then we have to return money that he spent in the second auction

            self.users_bids
                .insert(&item_and_bid.1.account_id, &rest_money);
        }

        /* #endregion pick winners and recalculate their sum of bids */

        for winner in winners.iter() {
            self.produce_exchange(&winner.1.account_id, &winner.0);
        }

        for user_bid in self.users_bids.iter() {
            Promise::new(user_bid.0.clone()).transfer(user_bid.1.clone());
        }

        self.clear_data();
    }

    /// add item to an auction as a supplier
    ///
    /// # Arguments
    ///
    /// * `item` - representation of an item
    /// * `min_bid` - minimal bid for this item. Will be replaced to 1 if 0
    ///
    /// # Panics
    ///  * auction must be opened
    pub fn add_item_to_auction(&mut self, item: &Item, min_bid: &String) {
        let converted_min_bid = min_bid.parse::<u128>().unwrap();

        assert!(self.auction_is_open, "Auction is closed. Try again later");

        match self.suppliers.get(&env::predecessor_account_id()) {
            Some(mut supplier) => supplier.add_item_to_auction(&item, &converted_min_bid),
            None => {
                let mut supplier = Supplier::new(&mut self.helper);
                supplier.add_item_to_auction(&item, &converted_min_bid);
                self.suppliers
                    .insert(&env::predecessor_account_id(), &supplier);
            }
        }
    }

    pub fn get_auction_state(&self) -> bool {
        self.auction_is_open
    }

    /// produce exchange. send money to a supplier and item to a buyer
    ///
    /// # Arguments
    /// * `winner` - account id that won this item
    /// * `item` - hash calculated from an item through the SHA256 algorithm
    fn produce_exchange(&mut self, winner: &AccountId, item: &ItemHash) {
        for mut supplier in self.suppliers.iter() {
            match supplier.1.sell_item(&item) {
                Some(sold_item) => {
                    /* #region add won item to a winner */
                    match self.winners_items.get(&winner) {
                        Some(mut items) => {
                            items.push(&sold_item.itself);
                            self.winners_items.insert(&winner, &items);
                        }

                        None => {
                            let mut v: Vector<Item> =
                                Vector::new(self.helper.generate_collection_id());
                            v.push(&sold_item.itself);

                            self.winners_items.insert(&winner, &v);
                        }
                    }
                    /* #endregion add won item to a winner */

                    // send money to a supplier for the sold item
                    Promise::new(supplier.0.clone()).transfer(
                        self.items_and_bids
                            .get(&item)
                            .unwrap_or(Bid::new(&env::predecessor_account_id(), &0))
                            .bid,
                    );

                    return;
                }

                _ => {}
            };
        }

        // suppliers don't contain item if we got here
        self.return_money(
            &winner,
            &self
                .items_and_bids
                .get(&item)
                .unwrap_or(Bid::new(&env::predecessor_account_id(), &0))
                .bid,
        );
    }

    /// chech if supplier make item for his own bid
    ///
    /// # Arguments
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    fn does_supplier_make_bid_for_his_item(&self, item_hash: &ItemHash) -> bool {
        match self.suppliers.get(&env::predecessor_account_id()) {
            None => false,
            Some(supplier) => supplier.contains_item(&item_hash),
        }
    }

    // FOR TEST PURPOSES
    #[private]
    pub fn add_test_item(&mut self) {
        self.add_item_to_auction(&String::from("test_item"), &"0".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_acc_id() -> AccountId {
        AccountId::try_from("bob.near".to_string()).unwrap()
    }

    #[test]
    #[should_panic]
    fn test_start_started_auction() {
        let mut exchange = Auction::new();
        exchange.start_new_auction();
        exchange.start_new_auction();
    }

    #[test]
    fn test_get_items() {
        let mut exchange = Auction::new();

        let item = "test_item".to_string();
        let mut items = Vector::<String>::new(b"i");
        items.push(&item);

        exchange.winners_items.insert(&get_acc_id(), &items);

        assert_eq!(
            exchange.get_items(get_acc_id().to_string()).len(),
            1,
            "invalid amount of items"
        )
    }

    #[test]
    fn test_clear_data() {
        let mut exchange = Auction::new();

        let mut items = Vector::<String>::new(b"i");
        items.push(&"item".to_string());

        exchange
            .suppliers
            .insert(&&get_acc_id(), &Supplier::new(&mut Helper::new()));
        exchange
            .items_and_bids
            .insert(&"test_key".to_string(), &Bid::new(&get_acc_id(), &10u128));
        exchange.users_bids.insert(&get_acc_id(), &10u128);
        exchange.winners_items.insert(&get_acc_id(), &items);

        exchange.clear_data();

        assert_eq!(exchange.suppliers.len(), 0);
        assert_eq!(exchange.items_and_bids.len(), 0);
        assert_eq!(exchange.users_bids.len(), 0);

        assert!(exchange.winners_items.contains_key(&get_acc_id()));
    }

    #[test]
    #[should_panic]
    fn test_make_same_bids() {
        let mut exchange = Auction::new();
        exchange.start_new_auction();

        let hash = "hash".to_string();

        exchange.make_bid(&hash);
        exchange.make_bid(&hash);
    }

    #[test]
    #[should_panic]
    fn test_add_tem_to_closed_auction() {
        let mut exchange = Auction::new();
        exchange.add_item_to_auction(&"test_item".to_string(), &"10".to_string());
    }

    #[test]
    fn test_add_item_to_auction() {
        let mut exchange = Auction::new();
        exchange.start_new_auction();

        exchange.add_item_to_auction(&"test_item".to_string(), &"10".to_string());

        assert_eq!(
            exchange.suppliers.len(),
            1,
            "invalid number of suppliers. Expected 1, actual: {}",
            exchange.suppliers.len()
        );
    }

    #[test]
    fn test_supplier_can_not_bid_for_his_items() {
        let mut exchange = Auction::new();
        exchange.start_new_auction();

        let (_, item_hash) = supplier::Item::new(&"test_item".to_string(), &12u128);

        exchange.add_item_to_auction(&"test_item".to_string(), &"10".to_string());

        assert_eq!(
            exchange.does_supplier_make_bid_for_his_item(&item_hash),
            true,
            "supplier is able to bid for his item"
        );
    }
}

'''
'''--- src/supplier.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::Balance;
use near_sdk::{collections::UnorderedMap, env, AccountId};
use sha2::{Digest, Sha256};

use crate::helper::Helper;

pub type ItemHash = String;

pub const DEFAULT_MIN_BID: u128 = 1;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Item {
    pub min_bid: u128,
    pub itself: String,
}

impl Item {
    pub fn new(item: &String, min_price: &u128) -> (Self, ItemHash) {
        (
            Self {
                min_bid: *min_price,
                itself: item.to_string(),
            },
            get_hash(item),
        )
    }
}

/// Seller that supplies items to an auction
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Supplier {
    pub id: AccountId,
    pub items: UnorderedMap<ItemHash, Item>,
}

impl Supplier {
    pub fn new(helper: &mut Helper) -> Self {
        Self {
            id: env::predecessor_account_id(),
            items: UnorderedMap::new(helper.generate_collection_id()),
        }
    }

    /// add item to an supplier's internal list
    ///
    /// # Arguments
    ///
    /// * `item` - represent of an item in a string format
    /// * `min_price` - minimal price that buyers can. Will be changed to 1 yocto token if 0
    pub fn add_item_to_auction(&mut self, item: &String, min_price: &u128) {
        let correct_min_price = if DEFAULT_MIN_BID < *min_price {
            *min_price
        } else {
            DEFAULT_MIN_BID
        };

        let (item, item_hash) = Item::new(item, &correct_min_price);
        self.items.insert(&item_hash, &item);
    }

    /// remove item from the supplier's internal list
    ///
    /// # Arguments
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    pub fn sell_item(&mut self, item_hash: &ItemHash) -> Option<Item> {
        self.items.remove(&item_hash)
    }

    /// check if selled has added item with such hash to an auction
    ///
    /// # Arguments
    ///
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    pub fn contains_item(&self, item_hash: &String) -> bool {
        self.items.get(&item_hash).is_some()
    }

    /// return item that has been added to an auction
    ///
    /// # Arguments
    ///
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    ///
    ///  # Panics
    ///
    ///  * Supplier has not added item with such hash
    pub fn get_item(&self, item_hash: &ItemHash) -> String {
        match self.items.get(&item_hash) {
            Some(item) => item.itself,
            None => panic!("supplier does not contain item with hash {}", item_hash),
        }
    }

    /// check if deposit is bigger than item's min bid
    ///
    ///  # Arguments
    /// * `item_hash` - hash calculated from an item through the SHA256 algorithm
    /// * `deposit` - attached deposit in yocto tokens
    pub fn bid_can_be_done(&mut self, item_hash: &String, deposit: &Balance) -> (bool, Balance) {
        match self.items.get(item_hash) {
            Some(item) => {
                if item.min_bid > *deposit {
                    return (false, item.min_bid);
                }

                (true, item.min_bid)
            }
            None => (true, 0),
        }
    }
}

fn get_hash(item: &String) -> String {
    format!("{:X}", Sha256::digest(item.as_bytes()))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_hash() {
        let test_phrase = "test phrase".to_string();
        let test_phrase_hash =
            "03725d0a96e114361230a7978eeefa0d646d7656dce5e44ae4e70a4dea5e674c".to_string();

        assert_eq!(
            get_hash(&test_phrase).to_lowercase(),
            test_phrase_hash.to_lowercase()
        );
    }

    #[test]
    fn test_add_item_to_auction() {
        let mut supplier = Supplier::new(&mut Helper::new());
        let (item, item_hash) = Item::new(&"test_item".to_string(), &12u128);
        supplier.add_item_to_auction(&item.itself, &item.min_bid);

        assert_eq!(
            true,
            supplier.contains_item(&item_hash),
            "item has not been added to a seller"
        )
    }

    #[test]
    fn test_sell_item() {
        let min_bet = 12u128;

        let (item, item_hash) = Item::new(&"test_item".to_string(), &12u128);

        let mut supplier = Supplier::new(&mut Helper::new());
        supplier.add_item_to_auction(&item.itself, &item.min_bid);

        match supplier.sell_item(&item_hash) {
            Some(item) => {
                assert_eq!(item.min_bid, min_bet, "wrong item has been selled");
                assert_eq!(item.itself, item.itself, "wrong item has been selled");
            }

            None => panic!("suppliyer still contains item after a sell"),
        }
    }
}

'''
'''--- test.sh ---
#!/bin/bash
# near call contract.msolomodenko.testnet --accountId=contract.msolomodenko.testnet new
near call contract.msolomodenko.testnet --accountId=contract.msolomodenko.testnet start_new_auction
near call contract.msolomodenko.testnet --accountId=contract.msolomodenko.testnet add_test_item
near call contract.msolomodenko.testnet --deposit 1 --accountId=looser.msolomodenko.testnet make_bid '{"item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"}'
near call contract.msolomodenko.testnet --deposit 2 --accountId=msolomodenko.testnet make_bid '{"item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"}'
near call contract.msolomodenko.testnet --accountId=contract.msolomodenko.testnet produce_auction

'''
'''--- tests/sim/main.rs ---
use near_units::parse_near;
use serde_json::json;
use serde_json::Value;
use workspaces::prelude::*;

const SELLER_ACC_ID: &str = "seller";
const WINNER_ACC_ID: &str = "winner";
const LOSER_ACC_ID: &str = "loser";
const WASM_FILEPATH: &str = "./res/auction.wasm";

fn yocto_to_token(n: u128) -> f64 {
    n as f64 / 10u128.pow(24) as f64
}

#[tokio::test]
async fn test_single_participant() -> anyhow::Result<()> {
    /* #region  init*/
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let owner = worker.root_account();

    owner.call(&worker, contract.id(), "new").transact().await?;

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await?;

    let winner = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let seller = owner
        .create_subaccount(&worker, SELLER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;
    /* #endregion*/

    let args_for_sell = json!(
        {
            "item":"test_item",
            "min_bid": "0"
        }
    );

    seller
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell)?
        .transact()
        .await?;

    let args_for_bid: Value = json!(
        {
            "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
        }
    );

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(args_for_bid)?
        .deposit(parse_near!("10 N"))
        .transact()
        .await?;

    owner
        .call(&worker, contract.id(), "produce_auction")
        .transact()
        .await?;

    let get_items_args = json!({ "account_id": format!("{}.test.near", WINNER_ACC_ID) });

    let winner_items: Vec<String> = winner
        .call(&worker, contract.id(), "get_items")
        .args_json(get_items_args)?
        .transact()
        .await?
        .json()?;

    assert_eq!(
        winner_items.len(),
        1,
        "Incorrect items amount. Should be 1, actual {}",
        winner_items.len()
    );

    let acc = seller.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(acc.balance).ceil(), // much less than 1 token has been burned as gas
        30f64,
        "Seller has invalid amount of money. Should be 20 N, actual: {}",
        acc.balance
    );

    Ok(())
}

#[tokio::test]
async fn test_multiple_participants() -> anyhow::Result<()> {
    /* #region  init*/
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let owner = worker.root_account();

    owner.call(&worker, contract.id(), "new").transact().await?;

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await?;

    let winner = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let seller = owner
        .create_subaccount(&worker, SELLER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let loser = owner
        .create_subaccount(&worker, LOSER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let args_for_bid = json!(
        {
            "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
        }
    );

    let args_for_sell = json!(
        {
            "item":"test_item",
            "min_bid": "0"
        }
    );
    /* #endregion*/

    seller
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell)?
        .transact()
        .await?;

    loser
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("10 N"))
        .transact()
        .await?;

    owner
        .call(&worker, contract.id(), "produce_auction")
        .transact()
        .await?;

    let get_items_args = json!({ "account_id": format!("{}.test.near", WINNER_ACC_ID) });

    let winner_items: Vec<String> = winner
        .call(&worker, contract.id(), "get_items")
        .args_json(get_items_args)?
        .transact()
        .await?
        .json()?;

    assert_eq!(
        winner_items.len(),
        1,
        "Incorrect items amount. Should be 1, actual {}",
        winner_items.len()
    );

    let seller_acc = seller.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(seller_acc.balance).ceil(),
        30f64,
        "Seller has invalid amount of money. Should be 20 N, actual: {}",
        seller_acc.balance
    );

    let loser_acc = loser.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(loser_acc.balance).ceil(),
        20f64,
        "Seller has invalid amount of money. Should be 30 N, actual: {}",
        loser_acc.balance
    );

    Ok(())
}

#[tokio::test]
async fn two_two_auctions_in_sequence() -> anyhow::Result<()> {
    /* #region  init*/
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let owner = worker.root_account();

    owner.call(&worker, contract.id(), "new").transact().await?;

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await?;

    let winner = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let seller = owner
        .create_subaccount(&worker, SELLER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let loser = owner
        .create_subaccount(&worker, LOSER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await?
        .into_result()?;

    let args_for_bid = json!(
        {
            "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
        }
    );

    let args_for_sell = json!(
        {
            "item":"test_item",
            "min_bid": "0"
        }
    );
    /* #endregion*/
    seller
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell.clone())?
        .transact()
        .await?;

    loser
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("10 N"))
        .transact()
        .await?;

    owner
        .call(&worker, contract.id(), "produce_auction")
        .transact()
        .await?;

    let get_items_args = json!({ "account_id": format!("{}.test.near", WINNER_ACC_ID) });

    let winner_items: Vec<String> = winner
        .call(&worker, contract.id(), "get_items")
        .args_json(get_items_args)?
        .transact()
        .await?
        .json()?;

    assert_eq!(
        winner_items.len(),
        1,
        "Incorrect items amount. Should be 1, actual {}",
        winner_items.len()
    );

    let seller_acc = seller.view_account(&worker).await?;
    let loser_acc = loser.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(seller_acc.balance).ceil(),
        30f64,
        "Seller has invalid amount of money. Should be 30 N, actual: {}",
        seller_acc.balance
    );

    assert_eq!(
        yocto_to_token(loser_acc.balance).ceil(),
        20f64,
        "Seller has invalid amount of money. Should be 20 N, actual: {}",
        loser_acc.balance
    );

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await?;

    seller
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell)?
        .transact()
        .await?;

    loser
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid)?
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;

    owner
        .call(&worker, contract.id(), "produce_auction")
        .transact()
        .await?;

    let get_items_args = json!({ "account_id": format!("{}.test.near", WINNER_ACC_ID) });

    let winner_items: Vec<String> = winner
        .call(&worker, contract.id(), "get_items")
        .args_json(get_items_args)?
        .transact()
        .await?
        .json()?;

    assert_eq!(
        winner_items.len(),
        2,
        "Incorrect items amount. Should be 2, actual {}",
        winner_items.len()
    );

    let seller_acc = seller.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(seller_acc.balance).ceil(),
        35f64,
        "Seller has invalid amount of money. Should be 35 N, actual: {}",
        yocto_to_token(seller_acc.balance).ceil()
    );

    assert_eq!(
        yocto_to_token(loser_acc.balance).ceil(),
        20f64,
        "Loser has invalid amount of money. Should be 20 N, actual: {}",
        yocto_to_token(loser_acc.balance).ceil()
    );

    Ok(())
}

#[tokio::test]
async fn test_auction_with_two_items() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let owner = worker.root_account();

    owner.call(&worker, contract.id(), "new").transact().await?;

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await?;

    let winner = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let seller_1 = owner
        .create_subaccount(&worker, SELLER_ACC_ID)
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let seller_2 = owner
        .create_subaccount(&worker, format!("{}_1", SELLER_ACC_ID).as_str())
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let loser = owner
        .create_subaccount(&worker, LOSER_ACC_ID)
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let args_for_sell_1 = json!(
        {
            "item":"test_item",
            "min_bid": "0"
        }
    );

    let args_for_bid_1 = json!(
        {
                "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
            }
    );

    let args_for_sell_2 = json!(
        {
            "item":"another_test_item",
            "min_bid": "0"
        }
    );

    let args_for_bid_2 = json!(
        {
            "item_hash":"AD2AFDA91E9D009272A01459110D14D0AAD7F4648412CE04B2B5E5F322DC527E"
        }
    );

    seller_1
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell_1.clone())?
        .transact()
        .await?;

    seller_2
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell_2.clone())?
        .transact()
        .await?;

    loser
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid_1)?
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid_1)?
        .deposit(parse_near!("10 N"))
        .transact()
        .await?;

    loser
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid_2)?
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;

    winner
        .call(&worker, contract.id(), "make_bid")
        .args_json(&args_for_bid_2)?
        .deposit(parse_near!("10 N"))
        .transact()
        .await?;

    owner
        .call(&worker, contract.id(), "produce_auction")
        .transact()
        .await?;

    let get_items_args = json!({ "account_id": format!("{}.test.near", WINNER_ACC_ID) });

    let winner_items: Vec<String> = winner
        .call(&worker, contract.id(), "get_items")
        .args_json(get_items_args)?
        .transact()
        .await?
        .json()?;

    assert_eq!(
        winner_items.len(),
        2,
        "Incorrect items amount. Should be 2, actual {}",
        winner_items.len()
    );

    let seller_acc_1 = seller_1.view_account(&worker).await?;
    let seller_acc_2 = seller_2.view_account(&worker).await?;
    let loser_acc = loser.view_account(&worker).await?;

    assert_eq!(
        yocto_to_token(seller_acc_1.balance).ceil(),
        40f64,
        "Seller has invalid amount of money. Should be 40 N, actual: {}",
        yocto_to_token(seller_acc_1.balance).ceil(),
    );

    assert_eq!(
        yocto_to_token(seller_acc_2.balance).ceil(),
        40f64,
        "Seller has invalid amount of money. Should be 40 N, actual: {}",
        yocto_to_token(seller_acc_2.balance).ceil(),
    );

    assert_eq!(
        yocto_to_token(loser_acc.balance).ceil(),
        30f64,
        "Seller has invalid amount of money. Should be 30 N, actual: {}",
        yocto_to_token(loser_acc.balance).ceil(),
    );

    Ok(())
}

#[tokio::test]
#[should_panic(expected="This item has 2 minimum bid. Actual: 1")]
async fn bid_less_than_min_bid() {
    let worker = workspaces::sandbox().await.unwrap();
    let wasm = std::fs::read(WASM_FILEPATH).unwrap();
    let contract = worker.dev_deploy(&wasm).await.unwrap();

    let owner = worker.root_account();

    owner
        .call(&worker, contract.id(), "new")
        .transact()
        .await
        .unwrap();

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await
        .unwrap();

    let bidder = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let seller = owner
        .create_subaccount(&worker, SELLER_ACC_ID)
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let args_for_sell = json!(
        {
            "item":"test_item",
            "min_bid": "2"
        }
    );

    let args_for_bid = json!(
        {
            "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
        }
    );

    seller
        .call(&worker, contract.id(), "add_item_to_auction")
        .args_json(args_for_sell.clone())
        .unwrap()
        .transact()
        .await
        .unwrap();

    bidder
        .call(&worker, contract.id(), "make_bid")
        .args_json(args_for_bid)
        .unwrap()
        .deposit(1u128)
        .transact()
        .await
        .unwrap();
}

#[tokio::test]
#[should_panic(expected="Item with hash 68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225 does not exist")]
async fn bid_to_non_exists_item() {
    let worker = workspaces::sandbox().await.unwrap();
    let wasm = std::fs::read(WASM_FILEPATH).unwrap();
    let contract = worker.dev_deploy(&wasm).await.unwrap();

    let owner = worker.root_account();

    owner
        .call(&worker, contract.id(), "new")
        .transact()
        .await
        .unwrap();

    owner
        .call(&worker, contract.id(), "start_new_auction")
        .transact()
        .await
        .unwrap();

    let bidder = owner
        .create_subaccount(&worker, WINNER_ACC_ID)
        .initial_balance(parse_near!("20 N"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let args_for_bid = json!(
        {
            "item_hash":"68E5EE009D13B901BBB36D3BB47FC59ACA581D6DB141DA0574287495244A9225"
        }
    );

    bidder
        .call(&worker, contract.id(), "make_bid")
        .args_json(args_for_bid)
        .unwrap()
        .deposit(1u128)
        .transact()
        .await
        .unwrap();
}

'''