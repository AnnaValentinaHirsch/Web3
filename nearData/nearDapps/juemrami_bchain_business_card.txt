*GitHub Repository "juemrami/bchain_business_card"*

'''--- Contract/Cargo.toml ---
[package]
name = "bchain-business-card"
version = "0.1.0"
authors = ["@juemrami <juemrami@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
# near-sdk = "4.0.0-pre.4"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- Contract/README.md ---
# Created with Rust Smart Contract Template

## Getting started

If you would just like to play with the contract using Rust this is your place to start.
If you would like do deploy the contract to testnet and have it ready for the frontend  see [`/frontend/contract/`](../frontend/contract/README.md)

_MAKE SURE YOUR TERMINAL IS IN THE RIGHT DIRECTORY_.

0. __Exploring the contract:__

    This contract's code can be found inside of the [`lib.rs`](/src/lib.rs) file. In NEAR we usually compile our contracts as a library because it will be used by accounts as a library when managing the public methods and data stores for the contract as opposed to a binary file which is just like a one time exectuable.
    
    Once compiled with the correct flags (see __Building the contract__ below), you can browse the actual inside of the target folder `target/wasm32-unknown-unknown/release/<name>.wasm` if you are interested. _Note. This wasm is auto generated so it might not be very readable but its interesting regardless imo._

1. __Building the contract:__

    `RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release`

Test the contract 

    `cargo test -- --nocapture`

2. __Testing the contract:__

   This will run all the test while display macros like `pintln!()` in the contract code with the `--nocapture` option.

**Get more info at:**

* [Rust Smart Contract Quick Start](https://docs.near.org/docs/develop/contracts/rust/intro)
* [Rust SDK Book](https://www.near-sdk.io/)

'''
'''--- Contract/build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- Contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../frontend/contract/wasm32_out
cp target/wasm32-unknown-unknown/release/*.wasm ../frontend/contract/wasm32_out/contract.wasm
'''
'''--- Contract/src/lib.rs ---
/* Learn more about writing NEAR smart contracts with Rust:
 * https://github.com/near/near-sdk-rs
 *
 */

// To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)

use std::collections::HashMap;

/* TODO:
 * ------------------------------
 * 0. Implement a better system for keeping track of supported blockchains.
 *    so that i can parse input validity for add_blockchain() better instead of that long match.
 *
 * 1. Setup create_card() so that you can pass optional agruments like website and 1 blockchain
 *    so that we dont have make as many calls in the futur
 *
 * 2. Keep track of vouches and refutes seperately instead of having an overall rating score.
 *
 * 3. Make it so that only people who you have authorized (maybe someone youve done work for)
 *    can vouch/refute you blockchain experience.
 *
 * 4. Keep tracks of jobs youve gotten for each specific blockchain.
 */
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, setup_alloc, AccountId, PanicOnDefault};

setup_alloc!();
// fn as_yocto(near_amount: u128) -> U128 {
//     U128(near_amount * 10u128.pow(24))
// }

//Json Struct for displaying to Future Frontend
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonBusinessCard {
    owner_id: AccountId,
    website_url: Option<String>,
    experience: Vec<String>,
}

//A Business card contains Owner ID, Website URL, and Expereince
//Expereience is a set of blockchains youve developed on with rating (given by others)
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[serde(crate = "near_sdk::serde")]
pub struct BusinessCard {
    pub owner_id: AccountId,
    pub website_url: Option<String>,
    pub blockchain_exp: HashMap<String, i32>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub records: LookupMap<AccountId, BusinessCard>,
}
fn ntoy(near_amount: u128) -> U128 {
    U128(near_amount * 10u128.pow(24))
}
#[near_bindgen]
impl Contract {
    #[init]

    pub fn new() -> Self {
        Self {
            owner_id: "juemrami.testnet".to_string(),
            records: LookupMap::new(b"r".to_vec()),
        }
    }
    pub fn set_website(&mut self, url: String) {
        let account_id = env::signer_account_id();
        assert!(url != "", "Url must be non empty.");
        let mut business_card = {
            match self.records.get(&account_id) {
                Some(card) => card,
                None => panic!("No business card exists for this account."),
            }
        };
        business_card.website_url = Some(url.clone());
        self.records.insert(&account_id, &business_card);
        env::log(format!("Url: {url} added for account: {account_id}").as_bytes());
        println!("Url: {url} added for account: {account_id}")
    }
    pub fn add_blockchain(&mut self, blockchain_name: String) {
        match blockchain_name.as_ref(){
            "NEAR" => (),
            "Ethereum" => (),
            "Cardano" => (),
            "Solana" => (),
            "Polkadot" => (),
            "Terra" => (),
            "Avalanche" => (),
            _=> panic!("Not a valid blockchain: only NEAR, Ethereum, Cardano, Solana, Polkadot, Terra, Avalanche."),
        }
        let account_id = env::signer_account_id();
        let mut business_card = {
            match self.records.get(&account_id) {
                Some(card) => card,
                None => panic!("No business card exists for this account."),
            }
        };
        let mut blockchain_exp = business_card.blockchain_exp;
        if blockchain_exp.contains_key(&blockchain_name) {
            panic!("This blockchain is already associated with this account.");
        } else {
            blockchain_exp.insert(blockchain_name.clone(), 0);
            env::log(
                format!("Experience: {blockchain_name} added for account: {account_id}").as_bytes(),
            );
        }
        business_card.blockchain_exp = blockchain_exp;
        self.records.insert(&account_id, &business_card);
        println!("Successfully added {} to {}", &blockchain_name, &account_id);
    }
    pub fn vouch(&mut self, card_owner_id: AccountId, blockchain_name: String) {
        let account_id = env::signer_account_id();
        match blockchain_name.as_ref(){
            "NEAR" => (),
            "Ethereum" => (),
            "Cardano" => (),
            "Solana" => (),
            "Polkadot" => (),
            "Terra" => (),
            "Avalanche" => (),
            _=> panic!("Not a valid blockchain: only NEAR, Ethereum, Cardano, Solana, Polkadot, Terra, Avalanche."),
        }
        let mut business_card = {
            match self.records.get(&card_owner_id) {
                Some(card) => card,
                None => panic!("No business card exists for this account."),
            }
        };
        let mut blockchain_exp = business_card.blockchain_exp;
        match &blockchain_exp.contains_key(&blockchain_name) {
            true => {
                let mut rating = blockchain_exp.get(&blockchain_name).unwrap().clone();
                rating += 1;
                blockchain_exp.insert(blockchain_name.clone(), rating.clone());
                env::log(format!("{card_owner_id} has recivied a vocuh for {blockchain_name} from {account_id}. New count: {rating}").as_bytes());
                println!("{card_owner_id} has recivied a vocuh for {blockchain_name} from {account_id}. New count: {rating}");
            }
            false => panic!("This account has not add this blockchain to their experience."),
        }
        business_card.blockchain_exp = blockchain_exp;
        self.records.insert(&card_owner_id, &business_card);
    }

    pub fn refute(&mut self, card_owner_id: AccountId, blockchain_name: String) {
        let account_id = env::signer_account_id();
        match blockchain_name.as_ref(){
            "NEAR" => (),
            "Ethereum" => (),
            "Cardano" => (),
            "Solana" => (),
            "Polkadot" => (),
            "Terra" => (),
            "Avalanche" => (),
            _=> panic!("Not a valid blockchain: only NEAR, Ethereum, Cardano, Solana, Polkadot, Terra, Avalanche."),
        }
        let mut business_card = {
            match self.records.get(&card_owner_id) {
                Some(card) => card,
                None => panic!("No business card exists for this account."),
            }
        };
        let mut blockchain_exp = business_card.blockchain_exp;
        match &blockchain_exp.contains_key(&blockchain_name) {
            true => {
                let mut rating = blockchain_exp.get(&blockchain_name).unwrap().clone();
                rating -= 1;
                blockchain_exp.insert(blockchain_name.clone(), rating.clone());
                env::log(format!("{card_owner_id} has recivied a refute for {blockchain_name} from {account_id}. New count: {rating}").as_bytes());
                println!("{card_owner_id} has recivied a refute for {blockchain_name} from {account_id}. New count: {rating}");
            }
            false => panic!("This account has not add this blockchain to their experience."),
        }
        business_card.blockchain_exp = blockchain_exp;
        self.records.insert(&card_owner_id, &business_card);
    }

    #[payable]
    pub fn create_new_card(&mut self) {
        let account_id = env::signer_account_id();
        assert_eq!(
            env::attached_deposit(),
            ntoy(5).into(),
            "Incorrect deposit amount. Cost to create a card is 5 NEAR"
        );
        assert!(
            self.records.contains_key(&account_id.to_string()) == false,
            "Business card for this account already exists."
        );
        let _balance = env::attached_deposit();
        let business_card = BusinessCard {
            owner_id: account_id.clone(),
            website_url: None,
            blockchain_exp: HashMap::new(),
        };
        // Use env::log to record logs permanently to the blockchain!
        env::log(format!("New Business Card created for account:{}", &account_id).as_bytes());
        println!("New Business Card created for account: {account_id}");
        self.records.insert(&account_id, &business_card);
    }

    // `match` is similar to `switch` in other languages.
    // self.records.get(&account_id) is not yet defined.
    // Learn more: https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont
    pub fn get_card(&self, account_id: String) -> BusinessCard {
        match self.records.get(&account_id) {
            Some(card) => card,
            None => panic!("No business card exists for this account."),
        }
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 *
 * To run from contract directory:
 * cargo test -- --nocapture
 *
 * From project root, to run in combination with frontend tests:
 * yarn test
 *
 */
#[cfg(test)]
mod tests {

    use std::convert::{TryFrom, TryInto};

    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // mock the context for testing, If None is given for signer_account_id default of bob_near is used.
    fn get_context(signer_account_id: Option<String>, is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id(match signer_account_id {
                Some(arg) => arg.try_into().unwrap(),
                None => ValidAccountId::try_from("bob_near".to_string()).unwrap(),
            })
            .is_view(is_view)
            .attached_deposit(ntoy(5).into())
            .build()
    }

    #[test]
    #[should_panic(expected = r#"The contract is not initialized"#)]
    fn default_deploy() {
        let context = get_context(None, false);
        testing_env!(context);
        let _contract = Contract::default();
    }
    #[test]
    fn get_card_and_display() {
        let mut context = get_context(None, false);
        // let account_id = &context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();

        //1st Signer

        contract.create_new_card();
        let input_url = "www.example.com".to_string();
        contract.set_website(input_url.clone());
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());
        let input = "Ethereum".to_string();
        contract.add_blockchain(input.clone());

        //2nd Signer
        context = get_context(Some("wendydoescode_near".to_string()), false);
        testing_env!(context);
        contract.create_new_card();
        let input_url = "www.wendywu.com".to_string();
        contract.set_website(input_url.clone());
        let input = "Polkadot".to_string();
        contract.add_blockchain(input.clone());
        let input = "Avalanche".to_string();
        contract.add_blockchain(input.clone());
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());

        //3 create vouches/refutes
        context = get_context(Some("jack_near".to_string()), false);
        testing_env!(context);
        contract.vouch("bob_near".to_string(), "NEAR".to_string());
        contract.refute("bob_near".to_string(), "Ethereum".to_string());
        contract.vouch("wendydoescode_near".to_string(), "NEAR".to_string());
        contract.vouch("wendydoescode_near".to_string(), "Polkadot".to_string());
        contract.vouch("wendydoescode_near".to_string(), "Avalanche".to_string());

        //Displays
        let business_card = contract.get_card("bob_near".into());
        println!(
            "----------------------------------------\nBlockchainBusinessCard\n----------------------------------------\nAccount Name: \t {}\nWebsite: \t {}",
            &business_card.owner_id,
            &business_card.website_url.unwrap()
        );
        println!("---------Blockchain Experience----------");
        for (key, value) in &business_card.blockchain_exp {
            println!("{},\t Net vouches: {}", key, value);
        }
        let business_card = contract.get_card("wendydoescode_near".into());
        println!(
            "----------------------------------------\nBlockchainBusinessCard\n----------------------------------------\nAccount Name: \t {}\nWebsite: \t {}",
            &business_card.owner_id,
            &business_card.website_url.unwrap()
        );
        println!("---------Blockchain Experience----------");
        for (key, value) in &business_card.blockchain_exp {
            println!("{},\t Net vouches: {}", key, value);
        }
    }
    #[test]
    fn populate_card() {
        let mut context = get_context(None, false);
        let _account_id = &context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        let input_url = "www.example.com".to_string();
        contract.set_website(input_url.clone());
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());
        let input = "Ethereum".to_string();
        contract.add_blockchain(input.clone());

        context = get_context(Some("jack_near".to_string()), false);
        testing_env!(context);
        contract.vouch("bob_near".to_string(), "NEAR".to_string());
    }
    #[test]
    fn create_card() {
        let context = get_context(None, false);
        let account_id = context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        let business_card = {
            match contract.records.get(&account_id) {
                Some(res) => res,
                None => panic!("No Record Found"),
            }
        };
        assert_eq!(account_id.to_string(), business_card.owner_id.to_string());
    }

    #[test]
    fn set_and_get_url() {
        let context = get_context(None, false);
        let account_id = context.signer_account_id.clone();
        testing_env!(context);

        let mut contract = Contract::new();
        contract.create_new_card();
        let input_url = "www.example.com".to_string();
        contract.set_website(input_url.clone());

        let business_card = {
            match contract.records.get(&account_id) {
                Some(res) => res,
                None => panic!("No Record Found"),
            }
        };
        let output_url = {
            match business_card.website_url {
                Some(res) => res,
                None => panic!("No URL Found"),
            }
        };
        assert_eq!(
            output_url, input_url,
            "URL mismatch {output_url} != {input_url}"
        );
    }
    #[test]
    fn get_and_set_experience() {
        let context = get_context(None, false);
        let account_id = context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());

        let business_card = {
            match contract.records.get(&account_id) {
                Some(res) => res,
                None => panic!("No Record Found"),
            }
        };
        let rating = business_card.blockchain_exp.get(&input).unwrap();
        assert_eq!(rating.to_owned(), 0, "Test Fail, Ratings not equal");
    }
    #[test]
    #[should_panic(
        expected = r#"Not a valid blockchain: only NEAR, Ethereum, Cardano, Solana, Polkadot, Terra, Avalanche."#
    )]
    fn set_nonexistent_experience() {
        let context = get_context(None, false);
        let _account_id = context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        let input = "TEST123".to_string();
        contract.add_blockchain(input.clone());
    }
    #[test]
    #[should_panic(expected = r#"No business card exists for this account."#)]
    fn experience_entry_no_card() {
        let context = get_context(None, false);
        let _account_id = context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());
    }
    #[test]
    #[should_panic(expected = r#"This blockchain is already associated with this account."#)]
    fn double_entry_experience() {
        let context = get_context(None, false);
        let _account_id = context.signer_account_id.clone();
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        let input = "NEAR".to_string();
        contract.add_blockchain(input.clone());
        contract.add_blockchain(input.clone());
    }
    #[test]
    #[should_panic(expected = r#"Business card for this account already exists."#)]
    fn create_duplicate_card() {
        let context = get_context(None, false);
        testing_env!(context);
        let mut contract = Contract::new();
        contract.create_new_card();
        contract.create_new_card();
    }
    #[test]
    #[should_panic(expected = r#"No business card exists for this account."#)]
    fn access_non_existent_card() {
        let context = get_context(None, true);
        let account_id = context.signer_account_id.clone();
        testing_env!(context);
        let contract = Contract::new();
        contract.get_card(account_id);
    }
}

'''
'''--- Contract/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- README.md ---
# Blockchain Business Card v2

try it out here

https://block-cards.vercel.app/

This is NEAR chain dApp consisting a relatively simple smart contract written in rust and implemented with a Nextjs front end.

The contract allows you to _"mint"_ a business card for 5 NEAR.
Things you can do with you business card:

- Add a website.
- Display your NEAR account id.
- Claim blockchain development experience.
- Vouch and/or refute other business card holders personal claims.

All Business Cards will display their respective Net Vouches as a public rating.

__To get started with deploying the contract and starting up fronted check the README here in [/frontend/](frontend/README.md)__

Alternatively,

__To learn about the internals and the Rust smart contracts follow the README in [/Contract/](Contract/README.md)__

-----
## Screenshots

![site gif](https://i.imgur.com/kxvtUN5.gif)

----

__WARNING.__ - If you're on Windows please make sure you're using WSL2 (Windows Subsystem for Linux) and that your End of Line settings for files is set to `LF` and not `CRLF` on the, in particular for the  `.sh` script files, otherwise you might have trouble running the shell scripts.

_Note. I have yet to figure out the economics. But it would be interesting to budget the amount of times you can claim experience via time gating and ask the users to pay a small fee if they want to add additional experience within that time period. Or if a cards Net Vouches reaches 0, we could remove that experience from that card and the owner would have to pay to reclaim that experience._ 

---

I have yet to figure out the economics. This was built for the NEARxEncode Bootcamp Jan 2022.

'''
'''--- frontend/.eslintrc.js ---
module.exports = {
  env: {
    browser: false,
    es2021: true,
    mocha: true,
    node: true,
  },
  plugins: ["@typescript-eslint/plugin"],
  extends: [
    "next/core-web-vitals",
    "plugin:typescript-eslint/recommended",
    "plugin:prettier/recommended",
    "plugin:node/recommended",
    "plugin:react/reccomened",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaFeature: {
      jsx: true,
    },
    ecmaVersion: 12,
  },
  rules: {
    "node/no-unsupported-features/es-syntax": [
      "error",
      { ignores: ["modules"] },
    ],
  },
};

'''
'''--- frontend/README.md ---

## Todo:
    x add error catching inside of provider. 
    x add view functions to provider.
    - implement propper typings for callFunction's
    - better handling of error/loading states (maybe use a stack or queue to track)
    - add loading spinners per component vs page.
    - implement contract log indexing w/ graphql.
    
---

# This Frontend Was Created Using Nextjs

Before you run any scripts i encourage you to follow the [`README.md`](/frontend/contract/README.md) inside of the `/frontend/contract` directory.

or... TLDR. do the following:

_from within the `frontend/contract/` directory..._

1. run `./dev-deploy.sh`

2. run `near call $CONTRACT new --accountId $CONTRACT` with the proper `$CONTRACT` set.

3. Set the proper contract account name in the `frontend/.env` file.

4. run 'yarn install'

5. run 'yarn start'

------

_The following is auto-generated by create-react-app_

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

'''
'''--- frontend/contract/README.md ---
# Scripts Created With The [near-sdk-as Starter Kit](https://github.com/Learn-NEAR/starter--near-sdk-as)

These following scripts will guide you through building the rust smart contract and deploying it to testnet using the NEAR CLI.

__You must complete these steps for the frontend to work propperly__

If you would like to continue with the in-depth tour and are comming from the [/Contract/README.md](../../Contract/README.md) please continue to step 0.

## Step 0

(__OPTIONAL__)
Step 1 runs the follow commands via a script anyways.

This is just for insight as to whats going on for those interested. (aka future me)

Run the build-contract.sh command from the within this directory.

    ./build-contract.sh

This builds the webasembly file, `.wasm`, from within the `/Contract/` directory and copies it into the `frontend/contract/wasm32_out/` folder as `contract.wasm`

Check out the [script](../../Contract/build.sh) to see exactly what is does.

*Note. This webassembly in reality has nothing to do with the function of the front end directly. Meaning when your frontend is communicating with the smart contract it's never using these `.wasm` files directly. The files are instead used by the Near CLI to be able to deploy a Smart Contract onto an account on the blockchain. This account is what is executing your 'backend' logic*

## Step 1

Run the dev-deploy.sh script to build the contract and then execute the Near CLI commands that will deploy the contract onto a development account generated by the Near CLI itself. __Follow the script instructions careufully.__

    ./dev-deploy.sh

Once you have followed all the instructions and set your `$CONTRACT` enviroment variable from within your terminal correctly (check with `echo $CONTRACT`) run the following.

    near call $CONTRACT new --accountId $CONTRACT

This will call the `new()` method on the smart contract deployed onto the account created by the `dev-deploy.sh` script. 

_By passing in the same contract account name (ie `$CONTRACT`) as the `--acountId` argument, the contract invokes itself and is its own owner, saved onto the `owner_id` feild of the `Contract` main `struct`, seen here in [lib.rs](../../Contract/src/lib.rs). Check it out explore the contract internals._

# Step 2

Before You can build the frontend we have to set the correct `.env` variable for the account id the contract is deployed onto. You can see workspace varaible you set for the contract account id with `echo $CONTRACT`. There should also be new folder generated in this directory called `/neardev/` with the account id as well.

Make sure the correct contract account id is set on the `REACT_APP_CONTRACT_NAME` environment variable within [`frontend/.env`](../.env)

Also make sure that your terminal is in the `/frontend/` directory before running these next commands. Run.
  
    yarn install

and

    yarn start

Now you can play with App on the Browser!

# Clean up

To clean up the project run this command from within this directory.

_Note. Make sure you set an account as a beneficiary with `export $BENEFICIARY=myaccountexample.testnet`_

    ./cleaup.sh
    
This script will delete the development account created by `near dev-deploy` which was ran from within the script in __Step 1__ and transfer any NEAR currency in the account to the `$BENEFICIARY` account. (free testnet money!).

It will also delete `/contract/neardev` directory and its contents.

**Get more info at:**

* [NEAR CLI Docs](https://docs.near.org/docs/tools/near-cli)

'''
'''--- frontend/contract/build-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build

cd ../../Contract
./build.sh

'''
'''--- frontend/contract/cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Deleting $CONTRACT"
echo "Any contract balance will transfered to $BENEFICIARY"
echo ---------------------------------------------------------
echo

near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
rm -r ./neardev
rm ./wasm32_out/*.wasm

exit 0
'''
'''--- frontend/contract/dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

./build-contract.sh

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo ---------------------------------------------------------
echo

near dev-deploy wasm32_out/contract.wasm

echo
echo -----------------------------------------------------------------------------
echo "Step 3: Prepare your environment"
echo
echo "(1) Find YOUR contract (account) name in the message above"
echo "    it will look like: 'Done deploying to dev-1231231231231-12312312312312'"
echo
echo "(2) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo -----------------------------------------------------------------------------
echo "example:"
echo
echo 'export CONTRACT=dev-1231231231231-12312312312312'
echo -----------------------------------------------------------------------------
echo

exit 0

'''
'''--- frontend/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- frontend/next.config.js ---
const WindiCSSWebpackPlugin = require("windicss-webpack-plugin");
module.exports = {
  eslint: {
    // Warning: This allows production builds to successfully complete even if
    // your project has ESLint errors.
    ignoreDuringBuilds: true,
  },

  reactStrictMode: true,
  webpack(config) {
    config.plugins.push(new WindiCSSWebpackPlugin());
    config.module.rules.push({
      test: /\.svg$/i,
      issuer: /\.[jt]sx?$/,
      use: ["@svgr/webpack"],
    });
    return config;
  },
};

'''
'''--- frontend/package.json ---
{
  "name": "next_frontend",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "fix-lints": "standardx src/**/*.ts src/**/*.tsx --fix"
  },
  "dependencies": {
    "big.js": "^6.1.1",
    "near-api-js": "^0.44.2",
    "next": "12.0.9",
    "next-google-fonts": "^2.2.0",
    "react": "17.0.2",
    "react-dom": "^17.0.2",
    "react-loading-icons": "^1.0.8"
  },
  "devDependencies": {
    "@next/eslint-plugin-next": "^12.0.10",
    "@svgr/webpack": "^6.2.1",
    "@types/node": "^17.0.13",
    "@types/react": "^17.0.38",
    "@typescript-eslint/eslint-plugin": "^5.11.0",
    "@typescript-eslint/parser": "^5.11.0",
    "@typescript-eslint/typescript-estree": "^5.11.0",
    "eslint": "8.8.0",
    "eslint-config-next": "^12.0.9",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "prettier": "^2.5.1",
    "typescript": "^4.5.5",
    "windicss-webpack-plugin": "^1.6.2"
  }
}

'''
'''--- frontend/src/pages/api/hello.js ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction

export default function handler(req, res) {
  res.status(200).json({ name: 'John Doe' })
}

'''
'''--- frontend/src/public/error-notification.svg ---
<svg
xmlns="http://www.w3.org/2000/svg"
class="h-10 w-10 text-danger"
viewBox="0 0 24 24"  
fill="none"  
stroke="currentColor"  
stroke-width="2"  
stroke-linecap="round"  
stroke-linejoin="round">  
<circle cx="12" cy="12" r="10" />  
<line x1="12" y1="8" x2="12" y2="12" />
<line x1="12" y1="16" x2="12.01" y2="16" />
</svg>
'''
'''--- frontend/src/public/near-logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 288 288"><defs><style>.cls-1{fill:gray;}</style></defs><g id="Layer_1" data-name="Layer 1"><path class="cls-1" d="M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z"/></g></svg>
'''
'''--- frontend/src/public/search-icon.svg ---
<svg class="text-black" xmlns="http://www.w3.org/2000/svg"  
fill="none" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
</svg>

'''
'''--- frontend/src/public/vercel.svg ---
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
'''
'''--- frontend/src/styles/globals.css ---

@import url("https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;700&display=swap");

html,
body {
  padding: 0;
  margin: 0;
  font-family: "Manrope", sans-serif;
  height: 100%;
}

a {
  color: inherit;
  text-decoration: none;
}

'''
'''--- frontend/tsconfig.json ---
{
  "compilerOptions": {
    "typeRoots": ["node_modules/@types"],
    "types": ["node"],
    "target": "es2021",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": [
    "next-env.d.ts",
    "*/*.ts",
    "**/*.tsx",
    "src/pages/Homepage.jsx",
    "src/pages/index.tsx"
  ],
  "exclude": ["node_modules"]
}

'''
'''--- frontend/windi.config.ts ---
import { defineConfig } from "windicss/helpers";

export default defineConfig({
  attributify: true,
  extract: {
    include: [
      "./src/**/*.{html,jsx,tsx}",
      "./src/components/**/*.{js,ts,jsx,tsx}",
      "./src/containers/**/*.{js,ts,jsx,tsx}",
    ],
    exclude: ["node_modules", ".git", ".next"],
  },
  safelist: ["prose", "prose-sm", "m-auto"],
  theme: {
    extend: {
      colors: {
        "near-blue": "#0072CE",
        success: "#218838",
        danger: "#a80c19",
        "modal-bg": "rgba(0,0,0,0.4)",
      },
    },
  },
  shortcuts: {
    btn: 'rounded-lg border border-gray-300 text-gray-100 bg-blue-500 px-4 py-2 m-2 inline-block hover:shadow',
  },
  plugins: [],
});

'''