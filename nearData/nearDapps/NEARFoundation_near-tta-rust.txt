*GitHub Repository "NEARFoundation/near-tta-rust"*

'''--- .github/workflows/static.yml ---
# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup Pages
        uses: actions/configure-pages@v3
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: "./ui"
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2

'''
'''--- .vscode/launch.json ---
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug executable 'tta-rust'",
      "cargo": {
        "args": ["build", "--bin=tta-rust", "--package=tta-rust"],
        "filter": {
          "name": "tta-rust",
          "kind": "bin"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    },
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug unit tests in executable 'tta-rust'",
      "cargo": {
        "args": ["test", "--no-run", "--bin=tta-rust", "--package=tta-rust"],
        "filter": {
          "name": "tta-rust",
          "kind": "bin"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}

'''
'''--- Cargo.toml ---
[package]
name = "tta-rust"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tokio-util = { version = "0.7.8", features = ["io", "io-util"] }
axum = "0.6.2"
tokio = { version = "1.24.1", features = ["full"] }
hyper = { version = "0.14.23", features = ["full"] }
tower = { version = "0.4", features = ["full"] }
serde = { version = "1", features = ["derive", "serde_derive"] }
serde_json = "1.0.91"
tracing = "0.1.37"
tracing-subscriber = "0.3.16"
chrono = "0.4.26"
sqlx = { version = "0.6.3", features = [
  "postgres",
  "runtime-tokio-rustls",
  "json",
  "chrono",
  "offline",
  "macros",
  "decimal",
] }
dotenvy = "0.15.6"
sha2 = "0.10.6"
anyhow = "1.0.71"
futures-util = "0.3.28"
tokio-stream = "0.1.14"
csv = "1.2.2"
num-traits = "0.2.15"
base64 = "0.21.2"
rust_decimal = "1.30.0"
near-sdk = "4.1.1"
near-jsonrpc-client = "0.6.0"
near-jsonrpc-primitives = "0.17.0"
near-primitives = "0.17.0"
tower-http = { version = "0.4.3", features = ["full"] }
lru = "0.11.0"
governor = "0.6.0"
tracing-loki = "0.2.4"
reqwest = "0.11.22"
uint = { version = "0.8.3", default-features = false }
quick_cache = "0.4.0"

[dev-dependencies]
axum-test-helper = "0.3.0"

'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.70"

'''
'''--- src/kitwallet/mod.rs ---
mod models;

use std::{collections::HashMap, num::NonZeroU32, sync::Arc};

use anyhow::bail;
use governor::{Quota, RateLimiter};
use tokio::sync::RwLock;
use tracing::{error, info};
use tta_rust::RateLim;

use crate::kitwallet::models::FastNearFT;

#[derive(Clone)]
pub struct KitWallet {
    rate_limiter: Arc<RwLock<RateLim>>,
    client: reqwest::Client,
    cache: Arc<RwLock<HashMap<String, (i64, Vec<String>)>>>,
}

impl Default for KitWallet {
    fn default() -> Self {
        Self::new()
    }
}

impl KitWallet {
    pub fn new() -> Self {
        Self {
            rate_limiter: Arc::new(RwLock::new(RateLimiter::direct(Quota::per_second(
                NonZeroU32::new(4u32).unwrap(),
            )))),
            client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(60))
                .build()
                .unwrap(),
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    // TODO(plg): expire the cache.
    pub async fn get_likely_tokens(&self, account: String) -> anyhow::Result<Vec<String>> {
        let cache_read = self.cache.read().await;

        if let Some(likely_tokens) = cache_read.get(&account) {
            // Check if the cache is expired
            if chrono::Utc::now().timestamp() - likely_tokens.0 < 60 {
                return Ok(likely_tokens.1.clone());
            }
        }

        drop(cache_read); // Release the read lock

        // Now, only here do we apply the rate limiter
        self.rate_limiter.read().await.until_ready().await;

        info!(
            "Account {} likely tokens not cached, fetching from API",
            account
        );
        // https://api.fastnear.com/v1/account/here.near/ft
        let likely_tokens = self
            .client
            .get(format!(
                "https://api.fastnear.com/v1/account/{}/ft",
                account
            ))
            .send()
            .await?
            .json::<FastNearFT>()
            .await?;

        // Insert the result into the cache
        let mut cache_write = self.cache.write().await;
        cache_write.insert(
            account.clone(),
            (
                chrono::Utc::now().timestamp(),
                likely_tokens
                    .tokens
                    .iter()
                    .map(|t| t.contract_id.clone())
                    .collect(),
            ),
        );

        Ok(cache_write.get(&account).unwrap().1.clone())
    }

    // get all in parallel
    pub async fn get_likely_tokens_for_accounts(
        &self,
        accounts: Vec<String>,
    ) -> anyhow::Result<HashMap<String, Vec<String>>> {
        let mut tasks = Vec::new();
        for account in accounts {
            let account = account.clone();
            let self_clone = self.clone();
            tasks.push(tokio::spawn(async move {
                let likely_tokens = match self_clone.get_likely_tokens(account.clone()).await {
                    Ok(likely_tokens) => likely_tokens,
                    Err(e) => {
                        error!(
                            "Error fetching likely tokens for account {}: {}",
                            account, e
                        );
                        bail!(
                            "Error fetching likely tokens for account {}: {}",
                            account,
                            e
                        )
                    }
                };
                anyhow::Ok((account, likely_tokens))
            }));
        }

        let mut likely_tokens_for_accounts = HashMap::new();
        for task in tasks {
            let (account, likely_tokens) = match task.await? {
                Ok(a) => a,
                Err(err) => {
                    error!("Error fetching likely tokens: {}", err);
                    continue;
                }
            };
            likely_tokens_for_accounts.insert(account, likely_tokens);
        }

        Ok(likely_tokens_for_accounts)
    }
}

'''
'''--- src/kitwallet/models.rs ---
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FastNearFT {
    #[serde(rename = "account_id")]
    pub account_id: String,
    pub tokens: Vec<Token>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Token {
    #[serde(rename = "contract_id")]
    pub contract_id: String,
    #[serde(rename = "last_update_block_height")]
    pub last_update_block_height: Value,
}

'''
'''--- src/lib.rs ---
use std::collections::HashSet;

use anyhow::Result;
use governor::{clock, state, RateLimiter};
use hyper::{Body, Response};
use serde::Serialize;
use sha2::{Digest, Sha256};

pub type RateLim = RateLimiter<
    state::NotKeyed,
    state::InMemoryState,
    clock::QuantaClock,
    governor::middleware::NoOpMiddleware<clock::QuantaInstant>,
>;

// Extract accounts,
// returns: account, is lockup, master account
pub fn get_accounts_and_lockups(accounts: &str) -> HashSet<(String, Option<String>)> {
    let mut accounts: HashSet<(String, Option<String>)> = accounts
        .split(',')
        .map(String::from)
        .filter(|account| account != "near" && account != "system")
        .map(|account| (account, None))
        .collect();

    for a in accounts.clone() {
        if a.0.ends_with(".lockup.near") {
            continue;
        }
        let lockup_account = get_associated_lockup(&a.0, "near");
        accounts.insert((lockup_account, Some(a.0.clone())));
    }

    accounts
}

// Consolidate results and return a Response
pub fn results_to_response<T: Serialize>(results: Vec<T>) -> Result<Response<Body>, csv::Error> {
    let mut wtr = csv::Writer::from_writer(Vec::new());
    for row in results {
        wtr.serialize(row)?;
    }
    wtr.flush()?;
    Ok(Response::builder()
        .header("Content-Type", "text/csv")
        .body(Body::from(wtr.into_inner().unwrap()))
        .unwrap())
}

pub fn get_associated_lockup(account_id: &str, master_account_id: &str) -> String {
    format!(
        "{}.lockup.{}",
        &sha256(account_id)[0..40],
        master_account_id
    )
}

fn sha256(value: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.as_bytes());
    format!("{:x}", hasher.finalize())
}

'''
'''--- src/lockup/l.rs ---
use std::time::Duration;

use anyhow::Context;

use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::hash::CryptoHash;
use near_primitives::types::{AccountId, BlockHeight, BlockId, BlockReference};
use near_primitives::views::QueryRequest;
use near_sdk::borsh::BorshDeserialize;
use near_sdk::json_types::{U128, U64};
use tracing::info;

use super::lockup_types::{
    LockupContract, TransfersInformation, VestingInformation, VestingSchedule, WrappedBalance, U256,
};

// The timestamp (nanos) when transfers were enabled in the Mainnet after community voting
// Tuesday, 13 October 2020 18:38:58.293
pub(super) const TRANSFERS_ENABLED: Duration = Duration::from_nanos(1602614338293769340);
const CIRCULATING_SUPPLY: &str = "circulating_supply";

pub(crate) async fn get_lockup_contract_state(
    rpc_client: &JsonRpcClient,
    account_id: &AccountId,
    block_height: &BlockHeight,
) -> anyhow::Result<LockupContract> {
    let block_reference = BlockReference::BlockId(BlockId::Height(*block_height));
    let request = QueryRequest::ViewState {
        account_id: account_id.clone(),
        prefix: vec![].into(),
        include_proof: false,
    };
    let query = methods::query::RpcQueryRequest {
        block_reference,
        request,
    };

    let state_response = rpc_client.call(query).await.with_context(|| {
        format!(
            "Failed to deliver ViewState for lockup contract {}, block_height {}",
            account_id, block_height
        )
    })?;

    let view_state_result = match state_response.kind {
        QueryResponseKind::ViewState(state) => state,
        _ => {
            anyhow::bail!(
                "Failed to extract ViewState response for lockup contract {}, block_height {}",
                account_id,
                block_height
            )
        }
    };

    let view_state = view_state_result.values.get(0).with_context(|| {
        format!(
            "Failed to find encoded lockup contract for {}, block_height {}",
            account_id, block_height
        )
    })?;

    let mut state = LockupContract::try_from_slice(&view_state.value)
        .with_context(|| format!("Failed to construct LockupContract for {}", account_id))?;

    // If owner of the lockup account didn't call the
    // `check_transfers_vote` contract method we won't be able to
    // get proper information based on timestamp, that's why we inject
    // the `transfer_timestamp` which is phase2 timestamp
    state.lockup_information.transfers_information = TransfersInformation::TransfersEnabled {
        transfers_timestamp: U64(TRANSFERS_ENABLED.as_nanos() as u64),
    };
    Ok(state)
}

// The lockup contract implementation had a bug that affected lockup start date.
// https://github.com/near/core-contracts/pull/136
// For each contract, we should choose the logic based on the binary version of the contract
pub(crate) fn is_bug_inside_contract(code_hash: &CryptoHash, account_id: &AccountId) -> bool {
    match &*code_hash.to_string() {
        // The first implementation, with the bug
        "3kVY9qcVRoW3B5498SMX6R3rtSLiCdmBzKs7zcnzDJ7Q" => true,
        // We have 6 lockups created at 6th of April 2021, assume it's buggy
        "DiC9bKCqUHqoYqUXovAnqugiuntHWnM3cAc7KrgaHTu" => true,
        // Another 5 lockups created in May/June 2021, assume they are OK
        "Cw7bnyp4B6ypwvgZuMmJtY6rHsxP2D4PC8deqeJ3HP7D" => false,
        // Most recent contracts
        "4Pfw2RU6e35dUsHQQoFYfwX8KFFvSRNwMSNLXuSFHXrC" => false,
        "3skHaUtj85RPdUZwx6M4Jp4PfC9qJHqnsyuWLtuq2xBT" => false,
        _ => {
            info!(
                target: CIRCULATING_SUPPLY,
                "Assuming contract {} for account {} is not buggy", code_hash, account_id
            );
            false
        }
    }
}

// This is almost a copy of https://github.com/near/core-contracts/blob/master/lockup/src/getters.rs#L64
impl LockupContract {
    /// Returns the amount of tokens that are locked in the account due to lockup or vesting.
    pub fn get_locked_amount(&self, timestamp: u64, has_bug: bool) -> WrappedBalance {
        let lockup_amount = self.lockup_information.lockup_amount;
        if let TransfersInformation::TransfersEnabled {
            transfers_timestamp,
        } = &self.lockup_information.transfers_information
        {
            let lockup_timestamp = std::cmp::max(
                transfers_timestamp
                    .0
                    .saturating_add(self.lockup_information.lockup_duration),
                self.lockup_information.lockup_timestamp.unwrap_or(0),
            );
            let block_timestamp = timestamp;
            if lockup_timestamp <= block_timestamp {
                let unreleased_amount =
                    if let Some(release_duration) = self.lockup_information.release_duration {
                        let start_lockup = if has_bug {
                            transfers_timestamp.0
                        } else {
                            lockup_timestamp
                        };
                        let end_timestamp = start_lockup.saturating_add(release_duration);
                        if block_timestamp >= end_timestamp {
                            // Everything is released
                            0
                        } else {
                            let time_left = U256::from(end_timestamp - block_timestamp);
                            let unreleased_amount = U256::from(lockup_amount) * time_left
                                / U256::from(release_duration);
                            // The unreleased amount can't be larger than lockup_amount because the
                            // time_left is smaller than total_time.
                            unreleased_amount.as_u128()
                        }
                    } else {
                        0
                    };

                let unvested_amount = match &self.vesting_information {
                    VestingInformation::VestingSchedule(vs) => {
                        self.get_unvested_amount(vs.clone(), block_timestamp)
                    }
                    VestingInformation::Terminating(terminating) => terminating.unvested_amount,
                    // Vesting is private, so we can assume the vesting started before lockup date.
                    _ => U128(0),
                };
                return std::cmp::max(
                    unreleased_amount
                        .saturating_sub(self.lockup_information.termination_withdrawn_tokens),
                    unvested_amount.0,
                )
                .into();
            }
        }
        // The entire balance is still locked before the lockup timestamp.
        (lockup_amount - self.lockup_information.termination_withdrawn_tokens).into()
    }

    /// Returns the amount of tokens that are locked in this account due to vesting schedule.
    /// Takes raw vesting schedule, in case the internal vesting schedule is private.
    pub fn get_unvested_amount(
        &self,
        vesting_schedule: VestingSchedule,
        block_timestamp: u64,
    ) -> WrappedBalance {
        let lockup_amount = self.lockup_information.lockup_amount;
        match &self.vesting_information {
            VestingInformation::Terminating(termination_information) => {
                termination_information.unvested_amount
            }
            VestingInformation::None => U128::from(0),
            _ => {
                if block_timestamp < vesting_schedule.cliff_timestamp.0 {
                    // Before the cliff, nothing is vested
                    lockup_amount.into()
                } else if block_timestamp >= vesting_schedule.end_timestamp.0 {
                    // After the end, everything is vested
                    0.into()
                } else {
                    // cannot overflow since block_timestamp < vesting_schedule.end_timestamp
                    let time_left = U256::from(vesting_schedule.end_timestamp.0 - block_timestamp);
                    // The total time is positive. Checked at the contract initialization.
                    let total_time = U256::from(
                        vesting_schedule.end_timestamp.0 - vesting_schedule.start_timestamp.0,
                    );
                    let unvested_amount = U256::from(lockup_amount) * time_left / total_time;
                    // The unvested amount can't be larger than lockup_amount because the
                    // time_left is smaller than total_time.
                    unvested_amount.as_u128().into()
                }
            }
        }
    }
}

'''
'''--- src/lockup/lockup_types.rs ---
#![allow(
    clippy::assign_op_pattern,
    clippy::manual_range_contains,
    clippy::ptr_offset_with_cast
)]
// Copied from lockup contract code
// https://github.com/near/core-contracts/blob/master/lockup/src/types.rs
// https://github.com/near/core-contracts/blob/master/lockup/src/lib.rs

use uint::construct_uint;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance};

construct_uint! {
  /// 256-bit unsigned integer.
  pub struct U256(4);
}

/// Raw type for duration in nanoseconds
pub type Duration = u64;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;

/// Timestamp in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedTimestamp = U64;
/// Balance wrapped into a struct for JSON serialization as a string.
pub type WrappedBalance = U128;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupContract {
    /// The account ID of the owner.
    pub owner_account_id: AccountId,

    /// Information about lockup schedule and the amount.
    pub lockup_information: LockupInformation,

    /// Information about vesting including schedule or termination status.
    pub vesting_information: VestingInformation,

    /// Account ID of the staking pool whitelist contract.
    pub staking_pool_whitelist_account_id: AccountId,

    /// Information about staking and delegation.
    /// `Some` means the staking information is available and the staking pool contract is selected.
    /// `None` means there is no staking pool selected.
    pub staking_information: Option<StakingInformation>,

    /// The account ID that the NEAR Foundation, that has the ability to terminate vesting.
    pub foundation_account_id: Option<AccountId>,
}

/// Contains information about token lockups.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupInformation {
    /// The amount in yocto-NEAR tokens locked for this account.
    pub lockup_amount: Balance,
    /// The amount of tokens that were withdrawn by NEAR foundation due to early termination
    /// of vesting.
    /// This amount has to be accounted separately from the lockup_amount to make sure
    /// linear release is not being affected.
    pub termination_withdrawn_tokens: Balance,
    /// [deprecated] - the duration in nanoseconds of the lockup period from
    /// the moment the transfers are enabled. During this period tokens are locked and
    /// the release doesn't start. Instead of this, use `lockup_timestamp` and `release_duration`
    pub lockup_duration: Duration,
    /// If present, it is the duration when the full lockup amount will be available. The tokens
    /// are linearly released from the moment tokens are unlocked, defined by:
    /// `max(transfers_timestamp + lockup_duration, lockup_timestamp)`.
    /// If not present, the tokens are not locked (though, vesting logic could be used).
    pub release_duration: Option<Duration>,
    /// The optional absolute lockup timestamp in nanoseconds which locks the tokens until this
    /// timestamp passes. Until this moment the tokens are locked and the release doesn't start.
    /// If not present, `transfers_timestamp` will be used.
    pub lockup_timestamp: Option<Timestamp>,
    /// The information about the transfers. Either transfers are already enabled, then it contains
    /// the timestamp when they were enabled. Or the transfers are currently disabled and
    /// it contains the account ID of the transfer poll contract.
    pub transfers_information: TransfersInformation,
}

/// Contains information about the transfers. Whether transfers are enabled or disabled.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum TransfersInformation {
    /// The timestamp when the transfers were enabled.
    TransfersEnabled {
        transfers_timestamp: WrappedTimestamp,
    },
    /// The account ID of the transfers poll contract, to check if the transfers are enabled.
    /// The lockup period can start only after the transfer voted to be enabled.
    /// At the launch of the network transfers are disabled for all lockup contracts, once transfers
    /// are enabled, they can't be disabled and don't need to be checked again.
    TransfersDisabled { transfer_poll_account_id: AccountId },
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    /// There are no transactions in progress.
    Idle,
    /// There is a transaction in progress.
    Busy,
}

/// Contains information about current stake and delegation.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingInformation {
    /// The Account ID of the staking pool contract.
    pub staking_pool_account_id: AccountId,

    /// Contains status whether there is a transaction in progress.
    pub status: TransactionStatus,

    /// The amount of tokens that were deposited from this account to the staking pool.
    /// NOTE: The unstaked amount on the staking pool might be higher due to staking rewards.
    pub deposit_amount: WrappedBalance,
}

/// Contains information about vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingSchedule {
    /// The timestamp in nanosecond when the vesting starts. E.g. the start date of employment.
    pub start_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the first part of lockup tokens becomes vested.
    /// The remaining tokens will vest continuously until they are fully vested.
    /// Example: a 1 year of employment at which moment the 1/4 of tokens become vested.
    pub cliff_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the vesting ends.
    pub end_timestamp: WrappedTimestamp,
}

/// Initialization argument type to define the vesting schedule
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingScheduleOrHash {
    /// [deprecated] After transfers are enabled, only public schedule is used.
    /// The vesting schedule is private and this is a hash of (vesting_schedule, salt).
    /// In JSON, the hash has to be encoded with base64 to a string.
    VestingHash(Base64VecU8),
    /// The vesting schedule (public)
    VestingSchedule(VestingSchedule),
}

/// Contains information about vesting that contains vesting schedule and termination information.
#[derive(Serialize, BorshDeserialize, BorshSerialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingInformation {
    None,
    /// [deprecated] After transfers are enabled, only public schedule is used.
    /// Vesting schedule is hashed for privacy and only will be revealed if the NEAR foundation
    /// has to terminate vesting.
    /// The contract assume the vesting schedule doesn't affect lockup release and duration, because
    /// the vesting started before transfers were enabled and the duration is shorter or the same.
    VestingHash(Base64VecU8),
    /// Explicit vesting schedule.
    VestingSchedule(VestingSchedule),
    /// The information about the early termination of the vesting schedule.
    /// It means the termination of the vesting is currently in progress.
    /// Once the unvested amount is transferred out, `VestingInformation` is removed.
    Terminating(TerminationInformation),
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(
    BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Eq, Copy, Clone, Debug,
)]
#[serde(crate = "near_sdk::serde")]
pub enum TerminationStatus {
    /// Initial stage of the termination in case there are deficit on the account.
    VestingTerminatedWithDeficit,
    /// A transaction to unstake everything is in progress.
    UnstakingInProgress,
    /// The transaction to unstake everything from the staking pool has completed.
    EverythingUnstaked,
    /// A transaction to withdraw everything from the staking pool is in progress.
    WithdrawingFromStakingPoolInProgress,
    /// Everything is withdrawn from the staking pool. Ready to withdraw out of the account.
    ReadyToWithdraw,
    /// A transaction to withdraw tokens from the account is in progress.
    WithdrawingFromAccountInProgress,
}

/// Contains information about early termination of the vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TerminationInformation {
    /// The amount of tokens that are unvested and has to be transferred back to NEAR Foundation.
    /// These tokens are effectively locked and can't be transferred out and can't be restaked.
    pub unvested_amount: WrappedBalance,

    /// The status of the withdrawal. When the unvested amount is in progress of withdrawal the
    /// status will be marked as busy, to avoid withdrawing the funds twice.
    pub status: TerminationStatus,
}

/// Contains a vesting schedule with a salt.
#[derive(BorshSerialize, Deserialize, Serialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingScheduleWithSalt {
    /// The vesting schedule
    pub vesting_schedule: VestingSchedule,
    /// Salt to make the hash unique
    pub salt: Base64VecU8,
}

'''
'''--- src/lockup/mod.rs ---
pub mod l;
pub mod lockup_types;

'''
'''--- src/main.rs ---
use csv::Writer;
use hyper::Body;
use kitwallet::KitWallet;
use near_primitives::types::AccountId;
use tower::ServiceBuilder;
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
};
use tracing_loki::url::Url;
use tta::models::ReportRow;

use axum::{
    body,
    extract::{Query, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::get,
    routing::post,
    Json, Router,
};

use chrono::DateTime;
use dotenvy::dotenv;

use futures_util::future::join_all;
use near_jsonrpc_client::JsonRpcClient;
use serde::{Deserialize, Serialize};
use sqlx::postgres::PgPoolOptions;
use std::{
    collections::{HashMap, HashSet},
    env,
    sync::{Arc, RwLock},
};
use tokio::{spawn, sync::Semaphore};
use tracing::*;
use tracing_subscriber::{prelude::__tracing_subscriber_SubscriberExt, EnvFilter, FmtSubscriber};
use tta::tta_impl::TTA;
use tta_rust::{get_accounts_and_lockups, results_to_response};

use crate::tta::{ft_metadata::FtService, sql::sql_queries::SqlClient, tta_impl::safe_divide_u128};

pub mod kitwallet;
pub mod lockup;
pub mod tta;

const POOL_SIZE: u32 = 500;
const SEMAPHORE_SIZE: usize = 50;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    info!("Starting up");

    match dotenv() {
        Ok(_) => info!("Loaded .env file"),
        Err(e) => warn!("Failed to load .env file: {}", e),
    }

    init_tracing()?;

    let app = router().await?;

    let ip = env!("IP");
    let port = env!("PORT");
    let address = format!("{ip}:{port}");
    info!("Binding server to {address}");

    axum::Server::bind(&address.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();

    info!("Closing server on {address}");
    Ok(())
}

fn init_tracing() -> anyhow::Result<()> {
    // Check the environment variable
    let env = env::var("ENV").unwrap_or_else(|_| "production".to_string());

    let filter = match option_env!("LOG_LEVEL") {
        Some(level) => EnvFilter::new(level),
        None => EnvFilter::new("info"),
    };

    if env == "local" {
        // If we're in a local environment, just set a simple subscriber
        tracing::subscriber::set_global_default(
            FmtSubscriber::builder().with_env_filter(filter).finish(),
        )?;
    } else {
        // If we're not in a local environment, set up Loki logging
        let (layer, task) = tracing_loki::builder()
            .label("job", "tta")?
            .build_url(Url::parse("http://loki-33z9:3100")?)?;

        tracing::subscriber::set_global_default(
            FmtSubscriber::builder()
                .with_env_filter(filter)
                .finish()
                .with(layer),
        )?;

        spawn(task);
    }

    debug!("Tracing initialized.");

    Ok(())
}

async fn router() -> anyhow::Result<Router> {
    let pool = PgPoolOptions::new()
        .max_connections(POOL_SIZE)
        .connect(env!("DATABASE_URL"))
        .await?;

    let sql_client = SqlClient::new(pool);
    // let archival_near_client = JsonRpcClient::connect("http://beta.rpc.mainnet.near.org");
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(60 * 5))
        .build()?;
    let archival_near_client =
        JsonRpcClient::with(client).connect("http://beta.rpc.mainnet.near.org");
    // let near_client = JsonRpcClient::connect(NEAR_MAINNET_RPC_URL);
    let ft_service = FtService::new(archival_near_client);
    let kitwallet = KitWallet::new();
    let semaphore = Arc::new(Semaphore::new(SEMAPHORE_SIZE));

    let tta_service = TTA::new(sql_client.clone(), ft_service.clone(), semaphore);

    let trace = TraceLayer::new_for_http();
    let cors = CorsLayer::new().allow_methods(Any).allow_origin(Any);
    let middleware = ServiceBuilder::new().layer(trace).layer(cors);

    Ok(Router::new()
        .route("/tta", post(get_txns_report))
        .route("/tta", get(get_txns_report))
        .with_state(tta_service)
        .route("/likelyBlockId", get(get_closest_block_id))
        .with_state(sql_client.clone())
        .route("/balances", get(get_balances))
        .route("/balances", post(get_balances))
        .with_state((sql_client.clone(), ft_service.clone(), kitwallet.clone()))
        .route("/balancesfull", post(get_balances_full))
        .with_state((sql_client.clone(), ft_service.clone(), kitwallet))
        .route("/staking", get(get_staking_report))
        .route("/staking", post(get_staking_report))
        .with_state((sql_client.clone(), ft_service.clone()))
        .route("/lockup", get(get_lockup_balances))
        .route("/lockup", post(get_lockup_balances))
        .with_state((sql_client, ft_service))
        .layer(middleware))
}

// HTTP layer
type AccountID = String;
type TransactionID = String;
type Metadata = HashMap<AccountID, HashMap<TransactionID, String>>;

#[derive(Debug, Deserialize)]
struct TxnsReportParams {
    pub start_date: String,
    pub end_date: String,
    pub accounts: String,
    pub include_balances: Option<bool>,
}

#[derive(Debug, Deserialize, Default, Clone)]
struct TxnsReportWithMetadata {
    pub metadata: Metadata,
}

async fn get_txns_report(
    Query(params): Query<TxnsReportParams>,
    State(tta_service): State<TTA>,
    metadata_body: Option<Json<TxnsReportWithMetadata>>,
) -> Result<Response<Body>, AppError> {
    let start_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.start_date)
        .unwrap()
        .into();
    let end_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.end_date)
        .unwrap()
        .into();

    let accounts: HashSet<String> = params
        .accounts
        .split(',')
        .map(|s| String::from(s.trim()))
        .filter(|account| account != "near" && account != "system" && !account.is_empty())
        .collect();

    let include_balances = params.include_balances.unwrap_or(false);

    let metadata = Arc::new(RwLock::new(metadata_body.unwrap_or_default().0));

    let csv_data = tta_service
        .get_txns_report(
            start_date.timestamp_nanos() as u128,
            end_date.timestamp_nanos() as u128,
            accounts,
            include_balances,
            metadata,
        )
        .await?;

    // Create a Writer with a Vec<u8> as the underlying writer
    let mut wtr = Writer::from_writer(Vec::new());

    // Write the headers
    wtr.write_record(&ReportRow::get_vec_headers())?;

    // Write each row
    for row in csv_data {
        let record: Vec<String> = row.to_vec();
        wtr.write_record(&record)?;
    }

    // Get the CSV data
    let csv_data = wtr.into_inner()?;

    // Create a response with the CSV data
    let response = Response::builder()
        .header("Content-Type", "text/csv")
        .header("Content-Disposition", "attachment; filename=data.csv")
        .body(Body::from(csv_data))?;

    Ok(response)
}

#[derive(Debug, Deserialize)]
struct ClosestBlockIdParams {
    pub date: String,
}

async fn get_closest_block_id(
    Query(params): Query<ClosestBlockIdParams>,
    State(sql_client): State<SqlClient>,
) -> Result<Response<Body>, AppError> {
    let date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.date).unwrap().into();
    let nanos = date.timestamp_nanos() as u128;
    let d = sql_client.get_closest_block_id(nanos).await?;
    Ok(Response::new(Body::from(d.to_string())))
}

#[derive(Debug, Deserialize)]
struct GetBalances {
    pub start_date: String,
    pub end_date: String,
    pub accounts: Option<String>,
}

#[derive(Debug, Deserialize)]
struct GetBalancesBody {
    pub accounts: Vec<String>,
}

#[derive(Debug, Serialize, Clone)]
struct GetBalancesResultRow {
    pub account: String,
    pub start_date: String,
    pub end_date: String,
    pub start_block_id: u128,
    pub end_block_id: u128,
    pub token_id: String,
    pub symbol: String,
    pub lockup_of: Option<String>,
    pub start_balance: Option<f64>,
    pub end_balance: Option<f64>,
}

async fn get_balances(
    Query(params): Query<GetBalances>,
    State((sql_client, ft_service, kitwallet)): State<(SqlClient, FtService, KitWallet)>,
    body: Option<Json<GetBalancesBody>>,
) -> Result<Response<Body>, AppError> {
    let start_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.start_date)
        .unwrap()
        .into();
    let end_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.end_date)
        .unwrap()
        .into();
    let start_nanos = start_date.timestamp_nanos() as u128;
    let end_nanos = end_date.timestamp_nanos() as u128;

    let start_block_id = sql_client.get_closest_block_id(start_nanos).await?;
    let end_block_id = sql_client.get_closest_block_id(end_nanos).await?;
    let a = match body {
        Some(body) => body.accounts.join(","),
        None => params.accounts.unwrap_or("".to_string()),
    };

    let accounts = get_accounts_and_lockups(&a);
    let mut f = vec![];

    for (a, b) in accounts.clone() {
        f.push(a.clone());
        if let Some(b) = b {
            f.push(b.clone())
        };
    }

    kitwallet.get_likely_tokens_for_accounts(f).await?;

    let mut handles = vec![];

    for (account, lockup_of) in accounts {
        let ft_service = ft_service.clone();
        let start_block_id = start_block_id;
        let end_block_id = end_block_id;
        let start_date = start_date;
        let end_date = end_date;
        let kitwallet = kitwallet.clone();

        let handle = spawn(async move {
            info!(
                "Getting balances for {}, dates: start {} end {}",
                account, start_date, end_date
            );
            let mut rows: Vec<GetBalancesResultRow> = vec![];

            let likely_tokens = kitwallet.get_likely_tokens(account.clone()).await?;
            let token_handles: Vec<_> = likely_tokens
                .iter()
                .map(|token| {
                    let token = token.clone();
                    let account = account.clone();
                    let ft_service = ft_service.clone();
                    let lockup_of = lockup_of.clone();
                    async move {
                        let metadata = match ft_service.assert_ft_metadata(&token).await {
                            Ok(v) => v,
                            Err(e) => {
                                debug!("{}: {}", account, e);
                                return Err(e);
                            }
                        };
                        let start_balance = match ft_service
                            .assert_ft_balance(&token, &account, start_block_id as u64)
                            .await
                        {
                            Ok(v) => v,
                            Err(e) => {
                                debug!("{}: {}", account, e);
                                0.0
                            }
                        };
                        let end_balance = match ft_service
                            .assert_ft_balance(&token, &account, end_block_id as u64)
                            .await
                        {
                            Ok(v) => v,
                            Err(e) => {
                                debug!("{}: {}", account, e);
                                0.0
                            }
                        };
                        let record = GetBalancesResultRow {
                            account: account.clone(),
                            start_date: start_date.to_rfc3339(),
                            end_date: end_date.to_rfc3339(),
                            start_block_id,
                            end_block_id,
                            start_balance: Some(start_balance),
                            end_balance: Some(end_balance),
                            token_id: token.clone(),
                            symbol: metadata.symbol,
                            lockup_of,
                        };
                        Ok(record)
                    }
                })
                .collect();

            let token_results: Vec<_> = join_all(token_handles).await;
            for result in token_results {
                match result {
                    Ok(record) => rows.push(record),
                    Err(e) => {
                        debug!("Token fetch error: {:?}", e);
                    }
                }
            }

            let start_near_balance = match ft_service
                .get_near_balance(&account, start_block_id as u64)
                .await
            {
                Ok(v) => v,
                Err(e) => {
                    debug!("{}: {}", account, e);
                    None
                }
            };
            let end_near_balance = match ft_service
                .get_near_balance(&account, end_block_id as u64)
                .await
            {
                Ok(v) => v,
                Err(e) => {
                    debug!("{}: {}", account, e);
                    None
                }
            };

            let record = GetBalancesResultRow {
                account: account.clone(),
                start_date: start_date.to_rfc3339(),
                end_date: end_date.to_rfc3339(),
                start_block_id,
                end_block_id,
                start_balance: start_near_balance.map(|start| start.0),
                end_balance: end_near_balance.map(|end: (f64, f64)| end.0),
                token_id: "NEAR".to_string(),
                symbol: "NEAR".to_string(),
                lockup_of,
            };
            rows.push(record);

            anyhow::Ok(rows)
        });
        handles.push(handle);
    }

    let mut rows = vec![];
    join_all(handles).await.iter().for_each(|row| match row {
        Ok(result) => match result {
            Ok(res) => rows.extend(res.iter().cloned()),
            Err(e) => {
                println!("{:?}", e)
            }
        },
        Err(e) => {
            warn!("{:?}", e)
        }
    });

    let r = results_to_response(rows)?;
    Ok(r)
}

#[derive(Debug, Deserialize)]
struct GetBalancesFull {
    pub start_date: String,
    pub end_date: String,
    pub accounts: Vec<String>,
}

#[derive(Debug, Serialize, Clone)]
struct GetBalancesFullResultRow {
    pub account: String,
    pub date: String,
    pub block_id: u128,
    pub token_id: String,
    pub symbol: String,
    pub lockup_of: Option<String>,
    pub balance: Option<f64>,
}

#[tracing::instrument(skip(sql_client, ft_service, kitwallet))]
async fn get_balances_full(
    State((sql_client, ft_service, kitwallet)): State<(SqlClient, FtService, KitWallet)>,
    Json(params): Json<GetBalancesFull>,
) -> Result<Response<Body>, AppError> {
    let start_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.start_date)
        .unwrap()
        .into();
    let end_date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.end_date)
        .unwrap()
        .into();
    let accounts = params.accounts.join(",");
    let accounts = get_accounts_and_lockups(accounts.as_str());
    let mut f = vec![];

    for (a, b) in &accounts {
        f.push(a.clone());
        if let Some(b) = b {
            f.push(b.clone())
        };
    }
    error!("test");

    let likely_tokens = kitwallet.get_likely_tokens_for_accounts(f).await?;

    // put all days between start and end in all_dates.
    let all_dates = {
        let mut dates = vec![];
        let mut date = start_date;
        while date <= end_date {
            dates.push(date);
            date += chrono::Duration::days(1);
        }
        dates
    };

    let block_ids = sql_client
        .get_closest_block_ids(
            all_dates
                .iter()
                .map(|d| d.timestamp_nanos() as u128)
                .collect(),
        )
        .await?;
    let mut handles = vec![];

    for (idx, date) in all_dates.iter().enumerate() {
        let date = *date;
        let idx = idx;
        let block_id = block_ids[idx];

        for (account, lockup_of) in &accounts {
            let ft_service = ft_service.clone();
            let likely_tokens = likely_tokens.get(account).unwrap().clone();
            let account = account.clone();
            let lockup_of = lockup_of.clone();

            // sleep 1 ms
            tokio::time::sleep(std::time::Duration::from_millis(1)).await;

            let handle = spawn(async move {
                let mut rows: Vec<GetBalancesFullResultRow> = vec![];

                let token_handles: Vec<_> = likely_tokens
                    .iter()
                    .map(|token| {
                        let token = token.clone();
                        let account = account.clone();
                        let ft_service = ft_service.clone();
                        let lockup_of = lockup_of.clone();
                        async move {
                            let metadata = match ft_service.assert_ft_metadata(&token).await {
                                Ok(v) => v,
                                Err(e) => {
                                    debug!("{}: {}", account, e);
                                    return Err(e);
                                }
                            };
                            let balance = match ft_service
                                .assert_ft_balance(&token, &account, block_id as u64)
                                .await
                            {
                                Ok(v) => Some(v),
                                Err(e) => {
                                    debug!("{}: {}", account, e);
                                    None
                                }
                            };

                            let record = GetBalancesFullResultRow {
                                account: account.clone(),
                                date: date.to_rfc3339(),
                                token_id: token.clone(),
                                symbol: metadata.symbol,
                                lockup_of: lockup_of.clone(),
                                block_id,
                                balance,
                            };
                            Ok(record)
                        }
                    })
                    .collect();

                let token_results: Vec<_> = join_all(token_handles).await;
                for result in token_results {
                    match result {
                        Ok(record) => rows.push(record),
                        Err(e) => {
                            debug!("Token fetch error: {:?}", e);
                        }
                    }
                }

                let near_balance =
                    match ft_service.get_near_balance(&account, block_id as u64).await {
                        Ok(v) => v.map(|v| v.0),
                        Err(e) => {
                            error!("{}: {}", account, e);
                            None
                        }
                    };

                let record = GetBalancesFullResultRow {
                    account: account.clone(),
                    date: date.to_rfc3339(),
                    block_id,
                    balance: near_balance,
                    token_id: "NEAR".to_string(),
                    symbol: "NEAR".to_string(),
                    lockup_of: lockup_of.clone(),
                };
                rows.push(record);

                anyhow::Ok(rows)
            });
            handles.push(handle);
        }
    }

    let mut rows = vec![];
    join_all(handles).await.iter().for_each(|row| match row {
        Ok(result) => match result {
            Ok(res) => rows.extend(res.iter().cloned()),
            Err(e) => {
                error!("{:?}", e)
            }
        },
        Err(e) => {
            warn!("{:?}", e)
        }
    });

    let r = results_to_response(rows)?;
    Ok(r)
}

#[derive(Debug, Deserialize)]
struct DateAndAccounts {
    pub date: String,
    pub accounts: String,
}

#[derive(Debug, Serialize, Clone)]
struct StakingReportRow {
    pub account: String,
    pub staking_pool: String,
    pub amount_staked: f64,
    pub amount_unstaked: f64,
    pub ready_for_withdraw: bool,
    pub lockup_of: Option<String>,
    pub date: String,
    pub block_id: u128,
}

#[derive(Debug, Serialize, Deserialize)]
struct StakingData {
    account_id: String,
    pools: Vec<Pool>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Pool {
    last_update_block_height: Option<u64>,
    pool_id: String,
}

async fn get_staking_report(
    params: Option<Query<DateAndAccounts>>,
    State((sql_client, ft_service)): State<(SqlClient, FtService)>,
    body: Option<Json<DateAndAccounts>>,
) -> Result<Response<Body>, AppError> {
    let params = match params {
        Some(params) => params.0,
        None => body.unwrap().0,
    };

    let date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.date).unwrap().into();
    let start_nanos = date.timestamp_nanos() as u128;

    let block_id = sql_client.get_closest_block_id(start_nanos).await?;

    let accounts = get_accounts_and_lockups(&params.accounts);

    let client = reqwest::Client::new();
    let mut handles = vec![];

    for (account, master_account) in accounts {
        let client = client.clone();
        let ft_service = ft_service.clone();
        let block_id = block_id;

        let handle = spawn(async move {
            info!("Getting staking for {}", account);
            let mut rows: Vec<StakingReportRow> = vec![];

            let staking_deposits = client
                .get(format!(
                    "https://api.fastnear.com/v1/account/{account}/staking"
                ))
                .send()
                .await?
                .json::<StakingData>()
                .await?;
            info!(
                "Account {} staking deposits: {:?}",
                account, staking_deposits
            );

            let handles: Vec<_> = staking_deposits
                .pools
                .iter()
                .map(|pool| {
                    let pool_id = pool.pool_id.clone();
                    let account = account.clone();
                    let ft_service = ft_service.clone();
                    let master_account = master_account.clone();
                    async move {
                        let staking_details = match ft_service
                            .get_staking_details(&pool_id, &account, block_id as u64)
                            .await
                        {
                            Ok(v) => v,
                            Err(e) => {
                                debug!("{}: {}", account, e);
                                return Err(e);
                            }
                        };

                        if staking_details.0 == 0.0 && staking_details.1 == 0.0 {
                            return Ok(None);
                        }

                        let record = StakingReportRow {
                            account,
                            staking_pool: pool_id.clone(),
                            amount_staked: staking_details.0,
                            amount_unstaked: staking_details.1,
                            ready_for_withdraw: staking_details.2,
                            lockup_of: master_account,
                            date: date.to_rfc3339(),
                            block_id,
                        };
                        Ok(Some(record))
                    }
                })
                .collect();

            let results: Vec<_> = join_all(handles).await;
            for result in results {
                match result {
                    Ok(record) => {
                        if let Some(record) = record {
                            rows.push(record)
                        }
                    }
                    Err(e) => {
                        error!("staking error: {:?}", e);
                    }
                }
            }

            anyhow::Ok(rows)
        });
        handles.push(handle);
    }

    let mut rows = vec![];
    join_all(handles).await.iter().for_each(|row| match row {
        Ok(result) => match result {
            Ok(res) => rows.extend(res.iter().cloned()),
            Err(e) => {
                println!("{:?}", e)
            }
        },
        Err(e) => {
            warn!("{:?}", e)
        }
    });

    let r = results_to_response(rows)?;
    Ok(r)
}

#[derive(Debug, Serialize, Clone)]
struct LockupBalanceRow {
    pub account: String,
    pub lockup_balance: Option<f64>,
    pub locked_amount: Option<f64>,
    pub liquid_amount: Option<f64>,
    pub lockup_of: Option<String>,
    pub date: String,
    pub block_id: u128,
}

async fn get_lockup_balances(
    params: Option<Query<DateAndAccounts>>,
    State((sql_client, ft_service)): State<(SqlClient, FtService)>,
    body: Option<Json<DateAndAccounts>>,
) -> Result<Response<Body>, AppError> {
    let params = match params {
        Some(params) => params.0,
        None => body.unwrap().0,
    };

    let date: DateTime<chrono::Utc> = DateTime::parse_from_rfc3339(&params.date).unwrap().into();
    let date_nanos = date.timestamp_nanos() as u128;
    let block_id = sql_client.get_closest_block_id(date_nanos).await?;
    let accounts = get_accounts_and_lockups(&params.accounts);
    let mut handles = vec![];

    for (account, master_account) in accounts {
        if master_account.is_none() {
            continue;
        }

        let ft_service = ft_service.clone();
        let account: AccountId = account.parse().unwrap();
        let block_id = block_id as u64;

        let handle = spawn(async move {
            info!("Getting lockup_balance for {}", account);

            let account = account.clone();
            let ft_service = ft_service.clone();
            let master_account = master_account.clone();

            let lockup =
                lockup::l::get_lockup_contract_state(&ft_service.near_client, &account, &block_id)
                    .await?;
            let timestamp = date.timestamp_nanos();

            // todo: address has_bug, get hash of contract
            let locked_amount = lockup.get_locked_amount(timestamp as u64, false);
            // let unlocked = lockup.get_unvested_amount(timestamp as u64, false);
            let locked_amount = safe_divide_u128(locked_amount.0, 24);
            let near_balance = ft_service.get_near_balance(&account, block_id).await?;

            info!("Account {} lockup balance: {:?}", account, near_balance);

            let record = LockupBalanceRow {
                account: account.to_string(),
                lockup_of: master_account,
                lockup_balance: near_balance.map(|v| v.0),
                locked_amount: Some(locked_amount),
                liquid_amount: near_balance.map(|v| v.0 - locked_amount),
                date: date.to_rfc3339(),
                block_id: block_id as u128,
            };

            anyhow::Ok(record)
        });
        handles.push(handle);
    }

    let mut rows = vec![];
    join_all(handles).await.iter().for_each(|row| match row {
        Ok(result) => match result {
            Ok(res) => rows.push(res.clone()),
            Err(e) => {
                println!("{:?}", e)
            }
        },
        Err(e) => {
            warn!("{:?}", e)
        }
    });

    let r = results_to_response(rows)?;
    Ok(r)
}

struct AppError(anyhow::Error);

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Something went wrong: {}", self.0),
        )
            .into_response()
    }
}

impl<E> From<E> for AppError
where
    E: Into<anyhow::Error>,
{
    fn from(err: E) -> Self {
        Self(err.into())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::http::StatusCode;
    use axum_test_helper::TestClient;
    use futures_util::future::join_all;

    #[tokio::test]
    async fn test_tta_router() {
        let router = router().await.unwrap();
        let client = TestClient::new(router);
        let res = client.get("/tta?start_date=2023-01-01T00:00:00Z&end_date=2023-02-01T00:00:00Z&accounts=nf-payments.near&include_balances=false").send().await;
        assert_eq!(res.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn loadtest_tta() {
        let router = router().await.unwrap();
        let request_url = "/tta?start_date=2023-01-01T00:00:00Z&end_date=2023-02-01T00:00:00Z&accounts=nf-payments.near&include_balances=false";

        let futures = (0..20)
            .map(|_| {
                let router = router.clone(); // Clone the router for each request
                tokio::spawn(async move {
                    let client = TestClient::new(router); // Create a new client for each request
                    let res = client.get(request_url).send().await;
                    assert_eq!(res.status(), StatusCode::OK);
                    res
                })
            })
            .collect::<Vec<_>>();

        // wait for all requests to complete
        let results: Vec<_> = join_all(futures).await.into_iter().collect();

        for result in results {
            match result {
                Ok(res) => {
                    assert_eq!(res.status(), StatusCode::OK);
                }
                Err(e) => {
                    eprintln!("Request error: {:?}", e);
                    panic!("Request failed");
                }
            }
        }
    }
}

'''
'''--- src/tta/ft_metadata.rs ---
use anyhow::{bail, Result};
use governor::{Quota, RateLimiter};
use lru::LruCache;
use near_jsonrpc_client::JsonRpcClient;
use near_jsonrpc_primitives::types::query::{
    QueryResponseKind, RpcQueryError, RpcQueryRequest, RpcQueryResponse,
};
use near_primitives::{
    types::{
        BlockId::Height,
        BlockReference,
        Finality::{self},
        FunctionArgs,
    },
    views::{CallResult, QueryRequest},
};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{
    collections::HashMap,
    num::{NonZeroU32, NonZeroUsize},
    sync::Arc,
};
use tokio::{join, sync::RwLock};
use tracing::{debug, error};
use tta_rust::RateLim;

use std::hash::{Hash, Hasher};

use crate::tta::tta_impl::safe_divide_u128;

#[derive(Debug, Clone)]
pub struct CompositeKey {
    block_id: u64,
    account_id: String,
    token_id: String,
}

impl PartialEq for CompositeKey {
    fn eq(&self, other: &Self) -> bool {
        self.block_id == other.block_id
            && self.account_id == other.account_id
            && self.token_id == other.token_id
    }
}

impl Eq for CompositeKey {}

impl Hash for CompositeKey {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.block_id.hash(state);
        self.account_id.hash(state);
        self.token_id.hash(state);
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct FtMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
    pub decimals: u8,
}

#[derive(Debug, Clone)]
pub struct FtService {
    pub ft_metadata_cache: Arc<RwLock<HashMap<String, FtMetadata>>>,
    pub ft_balances_cache: Arc<RwLock<LruCache<CompositeKey, f64>>>,
    pub near_client: JsonRpcClient,
    pub archival_rate_limiter: Arc<RwLock<RateLim>>,
    pub likely_tokens: Arc<RwLock<HashMap<String, Vec<String>>>>,
}

impl FtService {
    pub fn new(near_client: JsonRpcClient) -> Self {
        FtService {
            ft_metadata_cache: Arc::new(RwLock::new(HashMap::new())),
            ft_balances_cache: Arc::new(RwLock::new(LruCache::new(
                NonZeroUsize::new(1_000_000).unwrap(),
            ))),
            near_client,
            archival_rate_limiter: Arc::new(RwLock::new(RateLimiter::direct(Quota::per_second(
                NonZeroU32::new(5_000_000u32).unwrap(),
            )))),
            likely_tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn assert_ft_metadata(&self, ft_token_id: &str) -> Result<FtMetadata> {
        if !self
            .ft_metadata_cache
            .clone()
            .read()
            .await
            .contains_key(ft_token_id)
        {
            // self.archival_rate_limiter.write().await.until_ready().await;
            let args = json!({}).to_string().into_bytes();
            let result = match view_function_call(
                &self.near_client,
                QueryRequest::CallFunction {
                    account_id: ft_token_id.parse().unwrap(),
                    method_name: "ft_metadata".to_string(),
                    args: FunctionArgs::from(args),
                },
                BlockReference::Finality(Finality::Final),
            )
            .await
            {
                Ok(v) => v,
                Err(e) => {
                    bail!(
                        "Error getting ft_metadata for ft_token_id: {}, error: {:?}",
                        ft_token_id,
                        e
                    );
                }
            };

            let v = serde_json::from_slice(&result)?;
            let e = self.ft_metadata_cache.clone();
            let mut w = e.write().await;
            w.insert(ft_token_id.to_string(), v);
        }

        match self.ft_metadata_cache.read().await.get(ft_token_id) {
            Some(v) => Ok(v.clone()),
            None => bail!("ft_metadata not found"),
        }
    }

    #[tracing::instrument(skip(self))]
    pub async fn assert_ft_balance(
        &self,
        token_id: &String,
        account_id: &String,
        block_id: u64,
    ) -> Result<f64> {
        if token_id == "kusama-airdrop.near" {
            return Ok(0.0);
        }
        if self
            .ft_balances_cache
            .clone()
            .read()
            .await
            .contains(&CompositeKey {
                block_id,
                account_id: account_id.clone(),
                token_id: token_id.clone(),
            })
        {
            debug!("Found ft_balance in cache");
            let mut w = self.ft_balances_cache.write().await;
            return Ok(*w
                .get(&CompositeKey {
                    block_id,
                    account_id: account_id.clone(),
                    token_id: token_id.clone(),
                })
                .unwrap());
        }
        let metadata = self.assert_ft_metadata(token_id).await.unwrap();

        // self.archival_rate_limiter.write().await.until_ready().await;
        let args = json!({ "account_id": account_id }).to_string().into_bytes();
        let result = match view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: token_id.parse().unwrap(),
                method_name: "ft_balance_of".to_string(),
                args: FunctionArgs::from(args),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await
        {
            Ok(v) => v,
            Err(e) => {
                error!(
                    "Error assert_ft_balance for token_id: {}, error: {:?}",
                    token_id, e
                );
                bail!(
                    "Error assert_ft_balance for token_id: {}, error: {:?}",
                    token_id,
                    e
                );
            }
        };

        let amount: String = serde_json::from_slice(&result)?;
        let amount = amount.parse::<u128>()?;
        let amount = safe_divide_u128(amount, metadata.decimals as u32);

        debug!("Got ft_balance amount: {}", amount);
        let mut w = self.ft_balances_cache.write().await;
        w.put(
            CompositeKey {
                block_id,
                account_id: account_id.clone(),
                token_id: token_id.clone(),
            },
            amount,
        );

        Ok(amount)
    }

    #[tracing::instrument(skip(self))]
    pub async fn get_near_balance(
        &self,
        account_id: &str,
        block_id: u64,
    ) -> Result<Option<(f64, f64)>> {
        // self.archival_rate_limiter.write().await.until_ready().await;
        let RpcQueryResponse { kind, .. } = match self
            .near_client
            .call(RpcQueryRequest {
                request: QueryRequest::ViewAccount {
                    account_id: account_id.parse().unwrap(),
                },
                block_reference: BlockReference::BlockId(Height(block_id)),
            })
            .await
        {
            Ok(v) => v,
            Err(e) => {
                if let Some(w) = e.handler_error() {
                    match w {
                        RpcQueryError::UnknownAccount { .. } => {
                            if !account_id.ends_with("lockup.near") {
                                error!("Unknown Account: {:?}", e); // Here's the debug print for UnknownAccount
                            }
                        }
                        _ => {
                            error!("Error calling ViewAccount: {:?}, block_id: {}", e, block_id);
                        }
                    }
                } else {
                    error!("Error calling ViewAccount: {:?}", e);
                }
                return Ok(None);
            }
        };
        let view = match kind {
            QueryResponseKind::ViewAccount(view) => view,
            _ => {
                error!("Received unexpected kind: {:?}", kind);
                bail!("Received unexpected kind: {:?}", kind);
            }
        };

        let amount = safe_divide_u128(view.amount, 24);
        let locked = safe_divide_u128(view.locked, 24);

        Ok(Some((amount, locked)))
    }

    pub async fn get_staking_details(
        &self,
        staking_pool: &str,
        account_id: &str,
        block_id: u64,
    ) -> Result<(f64, f64, bool)> {
        let args = json!({ "account_id": account_id }).to_string().into_bytes();

        let unstaked_balance_future = self.get_unstaked_balance(staking_pool, &args, block_id);
        let staked_balance_future = self.get_staked_balance(staking_pool, &args, block_id);
        let unstaked_balance_available_future =
            self.is_unstaked_balance_available(staking_pool, &args, block_id);

        let (unstaked_balance, staked_balance, unstaked_balance_available) = join!(
            unstaked_balance_future,
            staked_balance_future,
            unstaked_balance_available_future
        );

        Ok((
            safe_divide_u128(staked_balance?, 24),
            safe_divide_u128(unstaked_balance?, 24),
            unstaked_balance_available?,
        ))
    }

    async fn get_unstaked_balance(
        &self,
        staking_pool: &str,
        args: &[u8],
        block_id: u64,
    ) -> Result<u128> {
        self.archival_rate_limiter.write().await.until_ready().await;
        let result = view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: staking_pool.parse()?,
                method_name: "get_account_unstaked_balance".to_string(),
                args: FunctionArgs::from(args.to_vec()),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await;

        match result {
            Ok(v) => Ok(serde_json::from_slice::<String>(&v)?.parse::<u128>()?),
            Err(e) => {
                bail!(
                    "Error getting staking details for staking pool: {}, error: {:?}",
                    staking_pool,
                    e
                );
            }
        }
    }

    async fn get_staked_balance(
        &self,
        staking_pool: &str,
        args: &[u8],
        block_id: u64,
    ) -> Result<u128> {
        self.archival_rate_limiter.write().await.until_ready().await;
        let result = view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: staking_pool.parse()?,
                method_name: "get_account_staked_balance".to_string(),
                args: FunctionArgs::from(args.to_vec()),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await;

        match result {
            Ok(v) => Ok(serde_json::from_slice::<String>(&v)?.parse::<u128>()?),
            Err(e) => {
                bail!(
                    "Error getting staking details for staking pool: {}, error: {:?}",
                    staking_pool,
                    e
                );
            }
        }
    }

    async fn is_unstaked_balance_available(
        &self,
        staking_pool: &str,
        args: &[u8],
        block_id: u64,
    ) -> Result<bool> {
        self.archival_rate_limiter.write().await.until_ready().await;
        let result = view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: staking_pool.parse()?,
                method_name: "is_account_unstaked_balance_available".to_string(),
                args: FunctionArgs::from(args.to_vec()),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await;

        match result {
            Ok(v) => Ok(serde_json::from_slice::<bool>(&v)?),
            Err(e) => {
                bail!(
                    "Error getting staking details for staking pool: {}, error: {:?}",
                    staking_pool,
                    e
                );
            }
        }
    }

    pub async fn get_locked_amount(&self, lockup: &str, block_id: u64) -> Result<u128> {
        self.archival_rate_limiter.write().await.until_ready().await;
        let args = json!({}).to_string().into_bytes();
        let result = view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: lockup.parse()?,
                method_name: "get_locked_amount".to_string(),
                args: FunctionArgs::from(args.to_vec()),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await;

        match result {
            Ok(v) => Ok(serde_json::from_slice::<String>(&v)?.parse::<u128>()?),
            Err(e) => {
                bail!(
                    "Error getting locked amount for lockup: {}, error: {:?}",
                    lockup,
                    e
                );
            }
        }
    }

    pub async fn get_liquid_owners_balance(&self, lockup: &str, block_id: u64) -> Result<u128> {
        self.archival_rate_limiter.write().await.until_ready().await;
        let args = json!({}).to_string().into_bytes();
        let result = view_function_call(
            &self.near_client,
            QueryRequest::CallFunction {
                account_id: lockup.parse()?,
                method_name: "get_liquid_owners_balance".to_string(),
                args: FunctionArgs::from(args.to_vec()),
            },
            BlockReference::BlockId(Height(block_id)),
        )
        .await;

        match result {
            Ok(v) => Ok(serde_json::from_slice::<String>(&v)?.parse::<u128>()?),
            Err(e) => {
                bail!(
                    "Error get_liquid_owners_balance for lockup: {}, error: {:?}",
                    lockup,
                    e
                );
            }
        }
    }
}

#[tracing::instrument(skip(client))]
pub async fn view_function_call(
    client: &JsonRpcClient,
    request: QueryRequest,
    block_reference: BlockReference,
) -> anyhow::Result<Vec<u8>> {
    let RpcQueryResponse { kind, .. } = match client
        .call(RpcQueryRequest {
            block_reference: block_reference.clone(),
            request,
        })
        .await
    {
        Ok(v) => v,
        Err(e) => {
            if let Some(w) = e.handler_error() {
                match w {
                    RpcQueryError::UnknownAccount { .. } => {
                        error!("Unknown Account: {:?}", e);
                    }
                    RpcQueryError::NoContractCode { .. } => {
                        error!("No Contract Code: {:?}", e);
                    }
                    RpcQueryError::ContractExecutionError { .. } => {
                        error!("Contract Execution Error: {:?}", e);
                    }
                    _ => {
                        error!(
                            "Error calling ViewAccount: {:?}, block_id: {:#?}",
                            e, block_reference
                        );
                    }
                }
            } else {
                error!("Error calling ViewAccount: {:?}", e);
            }
            bail!("Error calling ViewAccount: {:?}", e)
        }
    };

    match kind {
        QueryResponseKind::CallResult(CallResult { result, .. }) => Ok(result),
        _ => {
            eprintln!("Received unexpected kind: {:?}", kind); // <-- Add this line
            bail!("Unexpected response kind");
        }
    }
}

'''
'''--- src/tta/mod.rs ---
pub mod models;
pub mod sql;
pub mod tta_impl;

pub mod ft_metadata;
mod utils;

'''
'''--- src/tta/models.rs ---
use near_primitives::types::AccountId;
use near_sdk::json_types::U128;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone)]
pub struct ReportRow {
    pub date: String,
    pub account_id: String,
    pub method_name: String,
    pub block_timestamp: u128,
    pub from_account: String,
    pub block_height: u128,
    pub args: String,
    pub transaction_hash: String,
    pub amount_transferred: f64,
    pub currency_transferred: String,
    pub ft_amount_out: Option<f64>,
    pub ft_currency_out: Option<String>,
    pub ft_amount_in: Option<f64>,
    pub ft_currency_in: Option<String>,
    pub to_account: String,
    pub amount_staked: f64,
    pub onchain_balance: Option<f64>,
    pub onchain_balance_token: Option<String>,
    pub metadata: Option<String>,
}

// Define the extension trait
pub trait FloatExt {
    fn to_5dp_string(&self) -> String;
}

// Implement the extension trait for f64
impl FloatExt for f64 {
    fn to_5dp_string(&self) -> String {
        format!("{:.5}", self)
    }
}

impl ReportRow {
    pub fn get_vec_headers() -> Vec<String> {
        vec![
            "date".to_string(),
            "account_id".to_string(),
            "method_name".to_string(),
            "block_timestamp".to_string(),
            "from_account".to_string(),
            "block_height".to_string(),
            "args".to_string(),
            "transaction_hash".to_string(),
            "amount_transferred".to_string(),
            "currency_transferred".to_string(),
            "ft_amount_out".to_string(),
            "ft_currency_out".to_string(),
            "ft_amount_in".to_string(),
            "ft_currency_in".to_string(),
            "to_account".to_string(),
            "amount_staked".to_string(),
            "onchain_balance".to_string(),
            "onchain_balance_token".to_string(),
            "metadata".to_string(),
        ]
    }

    pub fn to_vec(&self) -> Vec<String> {
        vec![
            self.date.clone(),
            self.account_id.clone(),
            self.method_name.clone(),
            self.block_timestamp.to_string(),
            self.from_account.clone(),
            self.block_height.to_string(),
            self.args.clone(),
            self.transaction_hash.clone(),
            self.amount_transferred.to_5dp_string(),
            self.currency_transferred.clone(),
            self.ft_amount_out
                .map_or(String::new(), |v| v.to_5dp_string()),
            self.ft_currency_out.clone().unwrap_or_default(),
            self.ft_amount_in
                .map_or(String::new(), |v| v.to_5dp_string()),
            self.ft_currency_in.clone().unwrap_or_default(),
            self.to_account.clone(),
            self.amount_staked.to_5dp_string(),
            self.onchain_balance
                .map_or(String::new(), |v| v.to_5dp_string()),
            self.onchain_balance_token.clone().unwrap_or_default(),
            self.metadata.clone().unwrap_or_default(),
        ]
    }
}

#[derive(Debug, Clone)]
pub struct FtAmounts {
    pub ft_amount_out: Option<f64>,
    pub ft_currency_out: Option<String>,
    pub ft_amount_in: Option<f64>,
    pub ft_currency_in: Option<String>,
    pub from_account: String,
    pub to_account: String,
}

#[derive(Debug, PartialEq)]
pub enum MethodName {
    FtTransfer,
    FtTransferCall,
    Withdraw,
    NearDeposit,
    NearWithdraw,
    Mint,
    Unsupported,
}

impl From<&str> for MethodName {
    fn from(s: &str) -> Self {
        match s {
            "ft_transfer" => MethodName::FtTransfer,
            "ft_transfer_call" => MethodName::FtTransferCall,
            "withdraw" => MethodName::Withdraw,
            "near_deposit" => MethodName::NearDeposit,
            "near_withdraw" => MethodName::NearWithdraw,
            "mint" => MethodName::Mint,
            _ => MethodName::Unsupported,
        }
    }
}

#[derive(Clone, Serialize, Deserialize)]
pub struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: U128,
    pub memo: Option<String>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct FtTransferCall {
    pub receiver_id: AccountId,
    pub amount: U128,
    pub memo: Option<String>,
    pub msg: String,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Swap {
    pub token_in: String,
    pub amount_in: U128,
    pub token_out: String,
    pub min_amount_out: U128,
}
#[derive(Clone, Serialize, Deserialize)]
pub struct WithdrawFromBridge {
    pub amount: U128,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct RainbowBridgeMint {
    pub account_id: AccountId,
    pub amount: U128,
}

'''
'''--- src/tta/sql/mod.rs ---
pub mod models;
pub mod sql_queries;

'''
'''--- src/tta/sql/models.rs ---
use serde::{Deserialize, Serialize};
use serde_json::Value;
use sqlx::{types::Decimal, Type};

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Transaction {
    #[serde(rename = "t_transaction_hash", default)]
    pub t_transaction_hash: String,
    #[serde(rename = "t_included_in_block_hash", default)]
    pub t_included_in_block_hash: String,
    #[serde(rename = "t_included_in_chunk_hash", default)]
    pub t_included_in_chunk_hash: String,
    #[serde(rename = "t_index_in_chunk", default)]
    pub t_index_in_chunk: i32,
    #[serde(rename = "t_block_timestamp", default)]
    pub t_block_timestamp: Decimal,
    #[serde(rename = "t_signer_account_id", default)]
    pub t_signer_account_id: String,
    #[serde(rename = "t_signer_public_key", default)]
    pub t_signer_public_key: String,
    #[serde(rename = "t_nonce", default)]
    pub t_nonce: Decimal,
    #[serde(rename = "t_receiver_account_id", default)]
    pub t_receiver_account_id: String,
    #[serde(rename = "t_signature", default)]
    pub t_signature: String,
    #[serde(rename = "t_status", default)]
    pub t_status: String,
    #[serde(rename = "t_converted_into_receipt_id", default)]
    pub t_converted_into_receipt_id: String,
    #[serde(rename = "t_receipt_conversion_gas_burnt", default)]
    pub t_receipt_conversion_gas_burnt: std::option::Option<Decimal>,
    #[serde(rename = "t_receipt_conversion_tokens_burnt", default)]
    pub t_receipt_conversion_tokens_burnt: std::option::Option<Decimal>,
    #[serde(rename = "r_receipt_id", default)]
    pub r_receipt_id: String,
    #[serde(rename = "r_included_in_block_hash", default)]
    pub r_included_in_block_hash: String,
    #[serde(rename = "r_included_in_chunk_hash", default)]
    pub r_included_in_chunk_hash: String,
    #[serde(rename = "r_index_in_chunk", default)]
    pub r_index_in_chunk: i32,
    #[serde(rename = "r_included_in_block_timestamp", default)]
    pub r_included_in_block_timestamp: Decimal,
    #[serde(rename = "r_predecessor_account_id", default)]
    pub r_predecessor_account_id: String,
    #[serde(rename = "r_receiver_account_id", default)]
    pub r_receiver_account_id: String,
    #[serde(rename = "r_receipt_kind", default)]
    pub r_receipt_kind: String,
    #[serde(rename = "r_originated_from_transaction_hash", default)]
    pub r_originated_from_transaction_hash: String,
    // #[serde(rename = "ta_transaction_hash", default)]
    // pub ta_transaction_hash: String,
    // #[serde(rename = "ta_index_in_transaction", default)]
    // pub ta_index_in_transaction: i32,
    // #[serde(rename = "ta_action_kind", default)]
    // pub ta_action_kind: String,
    // #[serde(rename = "ta_args", default)]
    // pub ta_args: serde_json::Value,
    // pub ta_args: sqlx::types::Json<TaArgs>,
    #[serde(rename = "ara_receipt_id", default)]
    pub ara_receipt_id: String,
    #[serde(rename = "ara_index_in_action_receipt", default)]
    pub ara_index_in_action_receipt: i32,
    #[serde(rename = "ara_action_kind", default)]
    pub ara_action_kind: String,
    #[serde(rename = "ara_args", default)]
    pub ara_args: serde_json::Value,
    // pub ara_args: AraArgs,
    #[serde(rename = "ara_receipt_predecessor_account_id", default)]
    pub ara_receipt_predecessor_account_id: String,
    #[serde(rename = "ara_receipt_receiver_account_id", default)]
    pub ara_receipt_receiver_account_id: String,
    #[serde(rename = "ara_receipt_included_in_block_timestamp", default)]
    pub ara_receipt_included_in_block_timestamp: Decimal,
    #[serde(rename = "b_block_height", default)]
    pub b_block_height: Decimal,
    #[serde(rename = "b_block_hash", default)]
    pub b_block_hash: String,
    #[serde(rename = "b_prev_block_hash", default)]
    pub b_prev_block_hash: String,
    #[serde(rename = "b_block_timestamp", default)]
    pub b_block_timestamp: Decimal,
    // #[serde(rename = "b_total_supply", default)]
    // pub b_total_supply: Decimal,
    #[serde(rename = "b_gas_price", default)]
    pub b_gas_price: Decimal,
    #[serde(rename = "b_author_account_id", default)]
    pub b_author_account_id: String,
    #[serde(rename = "eo_receipt_id", default)]
    pub eo_receipt_id: String,
    #[serde(rename = "eo_executed_in_block_hash", default)]
    pub eo_executed_in_block_hash: String,
    #[serde(rename = "eo_executed_in_block_timestamp", default)]
    pub eo_executed_in_block_timestamp: Decimal,
    #[serde(rename = "eo_index_in_chunk", default)]
    pub eo_index_in_chunk: i32,
    #[serde(rename = "eo_gas_burnt", default)]
    pub eo_gas_burnt: Decimal,
    #[serde(rename = "eo_tokens_burnt", default)]
    pub eo_tokens_burnt: Decimal,
    #[serde(rename = "eo_executor_account_id", default)]
    pub eo_executor_account_id: String,
    #[serde(rename = "eo_status", default)]
    pub eo_status: String,
    #[serde(rename = "eo_shard_id", default)]
    pub eo_shard_id: Decimal,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TaArgs {
    pub gas: Option<i64>,
    pub deposit: Option<String>,
    #[serde(rename = "args_json", default)]
    pub args_json: Option<ArgsJson>,
    #[serde(rename = "args_base64", default)]
    pub args_base64: Option<String>,
    #[serde(rename = "method_name", default)]
    pub method_name: Option<String>,
    #[serde(rename = "access_key", default)]
    pub access_key: Option<AccessKey>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ArgsJson {
    #[serde(rename = "estimated_fee", default)]
    pub estimated_fee: Value,
    pub msg: Option<String>,
    pub amount: Value,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: Option<String>,
    #[serde(rename = "account_id", default)]
    pub account_id: Option<String>,
    #[serde(rename = "registration_only", default)]
    pub registration_only: Option<bool>,
    pub id: Option<i64>,
    pub action: Option<String>,
    pub proposal: Option<Proposal>,
    pub args: Option<String>,
    pub name: Option<String>,
    #[serde(rename = "token_id", default)]
    pub token_id: Option<String>,
    pub unregister: Option<bool>,
    pub shares: Option<String>,
    #[serde(rename = "pool_id", default)]
    pub pool_id: Option<i64>,
    #[serde(rename = "min_amounts", default)]
    pub min_amounts: Option<Vec<String>>,
    pub amounts: Option<Vec<String>>,
    #[serde(rename = "min_shares", default)]
    pub min_shares: Option<String>,
    pub accounts: Option<Vec<Account>>,
    #[serde(default)]
    pub receivers: Vec<String>,
    #[serde(rename = "min_fee", default)]
    pub min_fee: Option<String>,
    #[serde(rename = "account_ids", default)]
    pub account_ids: Vec<String>,
    pub expected: Option<Expected>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
    #[serde(rename = "request_id", default)]
    pub request_id: Option<i64>,
    pub request: Option<Request>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Proposal {
    pub kind: Kind,
    pub description: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Kind {
    #[serde(rename = "RemoveMemberFromRole", default)]
    pub remove_member_from_role: Option<RemoveMemberFromRole>,
    #[serde(rename = "AddMemberToRole", default)]
    pub add_member_to_role: Option<AddMemberToRole>,
    #[serde(rename = "FunctionCall", default)]
    pub function_call: Option<FunctionCall>,
    #[serde(rename = "Transfer", default)]
    pub transfer: Option<Transfer>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RemoveMemberFromRole {
    pub role: String,
    #[serde(rename = "member_id", default)]
    pub member_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AddMemberToRole {
    pub role: String,
    #[serde(rename = "member_id", default)]
    pub member_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FunctionCall {
    pub actions: Vec<Action>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Action {
    pub gas: String,
    pub args: String,
    pub deposit: String,
    #[serde(rename = "method_name", default)]
    pub method_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Transfer {
    pub amount: String,
    #[serde(rename = "token_id", default)]
    pub token_id: String,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Account {
    pub amount: String,
    #[serde(rename = "account_id", default)]
    pub account_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Expected {
    pub decimals: i64,
    pub slippage: String,
    pub multiplier: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Request {
    pub actions: Vec<Action2>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Action2 {
    #[serde(rename = "type", default)]
    pub type_field: String,
    pub amount: Option<String>,
    pub gas: Value,
    pub args: Option<String>,
    pub deposit: Value,
    #[serde(rename = "method_name", default)]
    pub method_name: Option<String>,
    pub permission: Option<Permission>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Permission {
    pub allowance: Value,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
    #[serde(rename = "method_names", default)]
    pub method_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AccessKey {
    pub nonce: i64,
    pub permission: Permission2,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Permission2 {
    #[serde(rename = "permission_kind", default)]
    pub permission_kind: String,
    #[serde(rename = "permission_details", default)]
    pub permission_details: Option<PermissionDetails>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PermissionDetails {
    pub allowance: String,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
    #[serde(rename = "method_names", default)]
    pub method_names: Vec<Value>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AraArgs {
    pub gas: Option<i64>,
    pub deposit: Option<String>,
    #[serde(rename = "args_json", default)]
    pub args_json: Option<FunctionCallParameters>,
    #[serde(rename = "args_base64", default)]
    pub args_base64: Option<String>,
    #[serde(rename = "method_name", default)]
    pub method_name: Option<String>,
    #[serde(rename = "access_key", default)]
    pub access_key: Option<AccessKey2>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FunctionCallParameters {
    #[serde(rename = "estimated_fee", default)]
    pub estimated_fee: Option<Value>,
    pub msg: Option<String>,
    pub amount: Option<Value>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: Option<String>,
    #[serde(rename = "account_id", default)]
    pub account_id: Option<String>,
    #[serde(rename = "registration_only", default)]
    pub registration_only: Option<bool>,
    pub id: Option<i64>,
    pub action: Option<String>,
    pub proposal: Option<Proposal2>,
    pub args: Option<String>,
    pub name: Option<String>,
    #[serde(rename = "token_id", default)]
    pub token_id: Option<String>,
    pub unregister: Option<bool>,
    pub shares: Option<String>,
    #[serde(rename = "pool_id", default)]
    pub pool_id: Option<i64>,
    #[serde(rename = "min_amounts", default)]
    pub min_amounts: Option<Vec<String>>,
    pub amounts: Option<Vec<String>>,
    #[serde(rename = "min_shares", default)]
    pub min_shares: Option<String>,
    pub accounts: Option<Vec<Account2>>,
    #[serde(default)]
    pub receivers: Vec<String>,
    #[serde(rename = "min_fee", default)]
    pub min_fee: Option<String>,
    #[serde(rename = "account_ids", default)]
    pub account_ids: Vec<String>,
    pub expected: Option<Expected2>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
    #[serde(rename = "request_id", default)]
    pub request_id: Option<i64>,
    #[serde(rename = "request", default)]
    pub request: Option<MultiSigRequest>,
    #[serde(rename = "lockup_duration", default)]
    pub lockup_duration: Option<String>,
    #[serde(rename = "lockup_timestamp", default)]
    pub lockup_timestamp: Option<String>,
    #[serde(rename = "owner_account_id", default)]
    pub owner_account_id: Option<String>,
    #[serde(rename = "release_duration", default)]
    pub release_duration: Option<String>,
    #[serde(rename = "whitelist_account_id", default)]
    pub whitelist_account_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Proposal2 {
    pub kind: Kind2,
    pub description: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Kind2 {
    #[serde(rename = "RemoveMemberFromRole", default)]
    pub remove_member_from_role: Option<RemoveMemberFromRole2>,
    #[serde(rename = "AddMemberToRole", default)]
    pub add_member_to_role: Option<AddMemberToRole2>,
    #[serde(rename = "FunctionCall", default)]
    pub function_call: Option<FunctionCall2>,
    #[serde(rename = "Transfer", default)]
    pub transfer: Option<Transfer2>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RemoveMemberFromRole2 {
    pub role: String,
    #[serde(rename = "member_id", default)]
    pub member_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AddMemberToRole2 {
    pub role: String,
    #[serde(rename = "member_id", default)]
    pub member_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FunctionCall2 {
    pub actions: Vec<Action3>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Action3 {
    pub gas: String,
    pub args: String,
    pub deposit: String,
    #[serde(rename = "method_name", default)]
    pub method_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Transfer2 {
    pub amount: String,
    #[serde(rename = "token_id", default)]
    pub token_id: String,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Account2 {
    pub amount: String,
    #[serde(rename = "account_id", default)]
    pub account_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Expected2 {
    pub decimals: i64,
    pub slippage: String,
    pub multiplier: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct MultiSigRequest {
    pub actions: Vec<Action4>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Action4 {
    #[serde(rename = "type", default)]
    pub type_field: Option<String>,
    pub amount: Option<String>,
    pub gas: Option<Value>,
    pub args: Option<String>,
    pub deposit: Option<Value>,
    #[serde(rename = "method_name", default)]
    pub method_name: Option<String>,
    pub permission: Option<Permission3>,
    #[serde(rename = "public_key", default)]
    pub public_key: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Permission3 {
    pub allowance: Value,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
    #[serde(rename = "method_names", default)]
    pub method_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AccessKey2 {
    pub nonce: i64,
    pub permission: Permission4,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Permission4 {
    #[serde(rename = "permission_kind", default)]
    pub permission_kind: String,
    #[serde(rename = "permission_details", default)]
    pub permission_details: Option<PermissionDetails2>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PermissionDetails2 {
    pub allowance: Option<String>,
    #[serde(rename = "receiver_id", default)]
    pub receiver_id: String,
    #[serde(rename = "method_names", default)]
    pub method_names: Vec<String>,
}

#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, Eq, Type)]
#[sqlx(rename_all = "snake_case", type_name = "execution_outcome_status")]
// #[serde(rename_all = "snake_case", default)]
pub enum ExecutionOutcomeStatus {
    #[default]
    Unknown,
    Failure,
    SuccessValue,
    SuccessReceiptId,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct BlockId {
    #[serde(rename = "block_ud", default)]
    pub block_height: Decimal,
}

'''
'''--- src/tta/sql/sql_queries.rs ---
use std::collections::{self};

use anyhow::Result;
use num_traits::cast::ToPrimitive;
use sqlx::{types::Decimal, Pool, Postgres};
use tokio::sync::mpsc::Sender;
use tokio_stream::StreamExt;
use tracing::{debug, error, info, instrument};

use crate::tta::sql::models::BlockId;

use super::models::Transaction;

#[derive(Debug, Clone)]
pub struct SqlClient {
    pool: Pool<Postgres>,
}

impl SqlClient {
    pub fn new(pool: Pool<Postgres>) -> Self {
        Self { pool }
    }

    #[instrument(skip(self, sender_txn))]
    pub async fn get_outgoing_txns(
        &self,
        accounts: collections::HashSet<String>,
        start_date: u128,
        end_date: u128,
        sender_txn: Sender<Transaction>,
    ) -> Result<()> {
        let accs: Vec<String> = accounts.into_iter().collect();
        let start_date_decimal = Decimal::from(start_date);
        let end_date_decimal = Decimal::from(end_date);

        let mut stream_txs = sqlx::query_as!(
            Transaction,
            r##"SELECT
                T.TRANSACTION_HASH as T_TRANSACTION_HASH,
                T.INCLUDED_IN_BLOCK_HASH as T_INCLUDED_IN_BLOCK_HASH,
                T.INCLUDED_IN_CHUNK_HASH as T_INCLUDED_IN_CHUNK_HASH,
                T.INDEX_IN_CHUNK as T_INDEX_IN_CHUNK,
                T.BLOCK_TIMESTAMP as T_BLOCK_TIMESTAMP,
                T.SIGNER_ACCOUNT_ID as T_SIGNER_ACCOUNT_ID,
                T.SIGNER_PUBLIC_KEY as T_SIGNER_PUBLIC_KEY,
                T.NONCE as T_NONCE,
                T.RECEIVER_ACCOUNT_ID as T_RECEIVER_ACCOUNT_ID,
                T.SIGNATURE as T_SIGNATURE,
                T.STATUS as "t_status: String",
                T.CONVERTED_INTO_RECEIPT_ID as T_CONVERTED_INTO_RECEIPT_ID,
                T.RECEIPT_CONVERSION_GAS_BURNT as T_RECEIPT_CONVERSION_GAS_BURNT,
                T.RECEIPT_CONVERSION_TOKENS_BURNT as T_RECEIPT_CONVERSION_TOKENS_BURNT,
                R.RECEIPT_ID as R_RECEIPT_ID,
                R.INCLUDED_IN_BLOCK_HASH as R_INCLUDED_IN_BLOCK_HASH,
                R.INCLUDED_IN_CHUNK_HASH as R_INCLUDED_IN_CHUNK_HASH,
                R.INDEX_IN_CHUNK as R_INDEX_IN_CHUNK,
                R.INCLUDED_IN_BLOCK_TIMESTAMP as R_INCLUDED_IN_BLOCK_TIMESTAMP,
                R.PREDECESSOR_ACCOUNT_ID as R_PREDECESSOR_ACCOUNT_ID,
                R.RECEIVER_ACCOUNT_ID as R_RECEIVER_ACCOUNT_ID,
                R.RECEIPT_KIND as "r_receipt_kind: String",
                R.ORIGINATED_FROM_TRANSACTION_HASH as R_ORIGINATED_FROM_TRANSACTION_HASH,
                ARA.RECEIPT_ID as ARA_RECEIPT_ID,
                ARA.INDEX_IN_ACTION_RECEIPT as ARA_INDEX_IN_ACTION_RECEIPT,
                ARA.ARGS as ARA_ARGS,
                ARA.RECEIPT_PREDECESSOR_ACCOUNT_ID as ARA_RECEIPT_PREDECESSOR_ACCOUNT_ID,
                ARA.RECEIPT_RECEIVER_ACCOUNT_ID as ARA_RECEIPT_RECEIVER_ACCOUNT_ID,
                ARA.RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP as ARA_RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP,
                ARA.ACTION_KIND as "ara_action_kind: String",
                B.BLOCK_HEIGHT as B_BLOCK_HEIGHT,
                B.BLOCK_HASH as B_BLOCK_HASH,
                B.PREV_BLOCK_HASH as B_PREV_BLOCK_HASH,
                B.BLOCK_TIMESTAMP as B_BLOCK_TIMESTAMP,
                B.GAS_PRICE as B_GAS_PRICE,
                B.AUTHOR_ACCOUNT_ID as B_AUTHOR_ACCOUNT_ID,
                EO.RECEIPT_ID as EO_RECEIPT_ID,
                EO.EXECUTED_IN_BLOCK_HASH  as EO_EXECUTED_IN_BLOCK_HASH ,
                EO.EXECUTED_IN_BLOCK_TIMESTAMP as EO_EXECUTED_IN_BLOCK_TIMESTAMP,
                EO.INDEX_IN_CHUNK as EO_INDEX_IN_CHUNK,
                EO.GAS_BURNT as EO_GAS_BURNT,
                EO.TOKENS_BURNT as EO_TOKENS_BURNT,
                EO.EXECUTOR_ACCOUNT_ID as EO_EXECUTOR_ACCOUNT_ID,
                EO.SHARD_ID as EO_SHARD_ID,
                EO.STATUS as "eo_status: String"
            FROM
                TRANSACTIONS T
                LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID
                        OR t.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
                LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
                LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
                LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
            WHERE
                receipt_predecessor_account_id = ANY($1)
                AND EO.STATUS IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
                and B.BLOCK_TIMESTAMP >= $2
                and B.BLOCK_TIMESTAMP < $3  
                AND NOT EXISTS (
                    SELECT 1
                    FROM RECEIPTS R2
                    JOIN EXECUTION_OUTCOMES EO2 ON EO2.RECEIPT_ID = R2.RECEIPT_ID
                    WHERE (T.CONVERTED_INTO_RECEIPT_ID = R2.RECEIPT_ID OR T.TRANSACTION_HASH = R2.ORIGINATED_FROM_TRANSACTION_HASH)
                    AND EO2.STATUS = 'FAILURE'
                );
            "##,
            &accs,
            &start_date_decimal,
            &end_date_decimal,
        )
        .fetch(&self.pool);

        let start = chrono::Utc::now();

        while let Some(txn) = stream_txs.next().await {
            match txn {
                Ok(txn) => {
                    if let Err(e) = sender_txn.send(txn).await {
                        error!("Error sending transaction: {}", e);
                    };
                }
                Err(e) => error!("Error getting transaction: {}", e),
            }
        }

        let end = chrono::Utc::now();
        info!(
            "Time taken to get outgoing transactions: {:?} for {:?}",
            end - start,
            accs
        );

        Ok(())
    }

    #[instrument(skip(self, sender_txn))]
    pub async fn get_incoming_txns(
        &self,
        accounts: collections::HashSet<String>,
        start_date: u128,
        end_date: u128,
        sender_txn: Sender<Transaction>,
    ) -> Result<()> {
        let accs: Vec<String> = accounts.into_iter().collect();
        let start_date_decimal = Decimal::from(start_date);
        let end_date_decimal = Decimal::from(end_date);

        let mut stream_txs = sqlx::query_as!(
            Transaction,
            r##"
            SELECT
                T.TRANSACTION_HASH as T_TRANSACTION_HASH,
                T.INCLUDED_IN_BLOCK_HASH as T_INCLUDED_IN_BLOCK_HASH,
                T.INCLUDED_IN_CHUNK_HASH as T_INCLUDED_IN_CHUNK_HASH,
                T.INDEX_IN_CHUNK as T_INDEX_IN_CHUNK,
                T.BLOCK_TIMESTAMP as T_BLOCK_TIMESTAMP,
                T.SIGNER_ACCOUNT_ID as T_SIGNER_ACCOUNT_ID,
                T.SIGNER_PUBLIC_KEY as T_SIGNER_PUBLIC_KEY,
                T.NONCE as T_NONCE,
                T.RECEIVER_ACCOUNT_ID as T_RECEIVER_ACCOUNT_ID,
                T.SIGNATURE as T_SIGNATURE,
                T.STATUS as "t_status: String",
                T.CONVERTED_INTO_RECEIPT_ID as T_CONVERTED_INTO_RECEIPT_ID,
                T.RECEIPT_CONVERSION_GAS_BURNT as T_RECEIPT_CONVERSION_GAS_BURNT,
                T.RECEIPT_CONVERSION_TOKENS_BURNT as T_RECEIPT_CONVERSION_TOKENS_BURNT,
                R.RECEIPT_ID as R_RECEIPT_ID,
                R.INCLUDED_IN_BLOCK_HASH as R_INCLUDED_IN_BLOCK_HASH,
                R.INCLUDED_IN_CHUNK_HASH as R_INCLUDED_IN_CHUNK_HASH,
                R.INDEX_IN_CHUNK as R_INDEX_IN_CHUNK,
                R.INCLUDED_IN_BLOCK_TIMESTAMP as R_INCLUDED_IN_BLOCK_TIMESTAMP,
                R.PREDECESSOR_ACCOUNT_ID as R_PREDECESSOR_ACCOUNT_ID,
                R.RECEIVER_ACCOUNT_ID as R_RECEIVER_ACCOUNT_ID,
                R.RECEIPT_KIND as "r_receipt_kind: String",
                R.ORIGINATED_FROM_TRANSACTION_HASH as R_ORIGINATED_FROM_TRANSACTION_HASH,
                ARA.RECEIPT_ID as ARA_RECEIPT_ID,
                ARA.INDEX_IN_ACTION_RECEIPT as ARA_INDEX_IN_ACTION_RECEIPT,
                ARA.ARGS as ARA_ARGS,
                ARA.RECEIPT_PREDECESSOR_ACCOUNT_ID as ARA_RECEIPT_PREDECESSOR_ACCOUNT_ID,
                ARA.RECEIPT_RECEIVER_ACCOUNT_ID as ARA_RECEIPT_RECEIVER_ACCOUNT_ID,
                ARA.RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP as ARA_RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP,
                ARA.ACTION_KIND as "ara_action_kind: String",
                B.BLOCK_HEIGHT as B_BLOCK_HEIGHT,
                B.BLOCK_HASH as B_BLOCK_HASH,
                B.PREV_BLOCK_HASH as B_PREV_BLOCK_HASH,
                B.BLOCK_TIMESTAMP as B_BLOCK_TIMESTAMP,
                B.GAS_PRICE as B_GAS_PRICE,
                B.AUTHOR_ACCOUNT_ID as B_AUTHOR_ACCOUNT_ID,
                EO.RECEIPT_ID as EO_RECEIPT_ID,
                EO.EXECUTED_IN_BLOCK_HASH  as EO_EXECUTED_IN_BLOCK_HASH ,
                EO.EXECUTED_IN_BLOCK_TIMESTAMP as EO_EXECUTED_IN_BLOCK_TIMESTAMP,
                EO.INDEX_IN_CHUNK as EO_INDEX_IN_CHUNK,
                EO.GAS_BURNT as EO_GAS_BURNT,
                EO.TOKENS_BURNT as EO_TOKENS_BURNT,
                EO.EXECUTOR_ACCOUNT_ID as EO_EXECUTOR_ACCOUNT_ID,
                EO.SHARD_ID as EO_SHARD_ID,
                EO.STATUS as "eo_status: String"
            FROM
                TRANSACTIONS T
                LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID
                        OR T.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
                LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
                LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
                LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
            WHERE
                RECEIPT_RECEIVER_ACCOUNT_ID = ANY ($1)
                AND EO.STATUS IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
                AND B.BLOCK_TIMESTAMP >= $2
                AND B.BLOCK_TIMESTAMP < $3;
            "##,
            &accs,
            &start_date_decimal,
            &end_date_decimal,
        )
        .fetch(&self.pool);

        let start = chrono::Utc::now();

        while let Some(txn) = stream_txs.next().await {
            match txn {
                Ok(txn) => {
                    if let Err(e) = sender_txn.send(txn).await {
                        error!("Error sending transaction: {}", e);
                    };
                }
                Err(e) => error!("Error getting transaction: {}", e),
            }
        }

        let end = chrono::Utc::now();
        info!(
            "Time taken to get incoming transactions: {:?} for {:?}",
            end - start,
            accs
        );

        Ok(())
    }

    #[instrument(skip(self, sender_txn))]
    pub async fn get_ft_incoming_txns(
        &self,
        accounts: collections::HashSet<String>,
        start_date: u128,
        end_date: u128,
        sender_txn: Sender<Transaction>,
    ) -> Result<()> {
        let accs: Vec<String> = accounts.into_iter().collect();
        let start_date_decimal = Decimal::from(start_date);
        let end_date_decimal = Decimal::from(end_date);

        let mut stream_txs = sqlx::query_as!(
            Transaction,
            r##"
            SELECT
                T.TRANSACTION_HASH as T_TRANSACTION_HASH,
                T.INCLUDED_IN_BLOCK_HASH as T_INCLUDED_IN_BLOCK_HASH,
                T.INCLUDED_IN_CHUNK_HASH as T_INCLUDED_IN_CHUNK_HASH,
                T.INDEX_IN_CHUNK as T_INDEX_IN_CHUNK,
                T.BLOCK_TIMESTAMP as T_BLOCK_TIMESTAMP,
                T.SIGNER_ACCOUNT_ID as T_SIGNER_ACCOUNT_ID,
                T.SIGNER_PUBLIC_KEY as T_SIGNER_PUBLIC_KEY,
                T.NONCE as T_NONCE,
                T.RECEIVER_ACCOUNT_ID as T_RECEIVER_ACCOUNT_ID,
                T.SIGNATURE as T_SIGNATURE,
                T.STATUS as "t_status: String",
                T.CONVERTED_INTO_RECEIPT_ID as T_CONVERTED_INTO_RECEIPT_ID,
                T.RECEIPT_CONVERSION_GAS_BURNT as T_RECEIPT_CONVERSION_GAS_BURNT,
                T.RECEIPT_CONVERSION_TOKENS_BURNT as T_RECEIPT_CONVERSION_TOKENS_BURNT,
                R.RECEIPT_ID as R_RECEIPT_ID,
                R.INCLUDED_IN_BLOCK_HASH as R_INCLUDED_IN_BLOCK_HASH,
                R.INCLUDED_IN_CHUNK_HASH as R_INCLUDED_IN_CHUNK_HASH,
                R.INDEX_IN_CHUNK as R_INDEX_IN_CHUNK,
                R.INCLUDED_IN_BLOCK_TIMESTAMP as R_INCLUDED_IN_BLOCK_TIMESTAMP,
                R.PREDECESSOR_ACCOUNT_ID as R_PREDECESSOR_ACCOUNT_ID,
                R.RECEIVER_ACCOUNT_ID as R_RECEIVER_ACCOUNT_ID,
                R.RECEIPT_KIND as "r_receipt_kind: String",
                R.ORIGINATED_FROM_TRANSACTION_HASH as R_ORIGINATED_FROM_TRANSACTION_HASH,
                ARA.RECEIPT_ID as ARA_RECEIPT_ID,
                ARA.INDEX_IN_ACTION_RECEIPT as ARA_INDEX_IN_ACTION_RECEIPT,
                ARA.ARGS as ARA_ARGS,
                ARA.RECEIPT_PREDECESSOR_ACCOUNT_ID as ARA_RECEIPT_PREDECESSOR_ACCOUNT_ID,
                ARA.RECEIPT_RECEIVER_ACCOUNT_ID as ARA_RECEIPT_RECEIVER_ACCOUNT_ID,
                ARA.RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP as ARA_RECEIPT_INCLUDED_IN_BLOCK_TIMESTAMP,
                ARA.ACTION_KIND as "ara_action_kind: String",
                B.BLOCK_HEIGHT as B_BLOCK_HEIGHT,
                B.BLOCK_HASH as B_BLOCK_HASH,
                B.PREV_BLOCK_HASH as B_PREV_BLOCK_HASH,
                B.BLOCK_TIMESTAMP as B_BLOCK_TIMESTAMP,
                B.GAS_PRICE as B_GAS_PRICE,
                B.AUTHOR_ACCOUNT_ID as B_AUTHOR_ACCOUNT_ID,
                EO.RECEIPT_ID as EO_RECEIPT_ID,
                EO.EXECUTED_IN_BLOCK_HASH  as EO_EXECUTED_IN_BLOCK_HASH ,
                EO.EXECUTED_IN_BLOCK_TIMESTAMP as EO_EXECUTED_IN_BLOCK_TIMESTAMP,
                EO.INDEX_IN_CHUNK as EO_INDEX_IN_CHUNK,
                EO.GAS_BURNT as EO_GAS_BURNT,
                EO.TOKENS_BURNT as EO_TOKENS_BURNT,
                EO.EXECUTOR_ACCOUNT_ID as EO_EXECUTOR_ACCOUNT_ID,
                EO.SHARD_ID as EO_SHARD_ID,
                EO.STATUS as "eo_status: String"
            FROM TRANSACTIONS t
                    LEFT JOIN RECEIPTS R ON (T.CONVERTED_INTO_RECEIPT_ID = R.RECEIPT_ID OR
                                                t.TRANSACTION_HASH = R.ORIGINATED_FROM_TRANSACTION_HASH)
                    LEFT JOIN ACTION_RECEIPT_ACTIONS ARA ON ARA.RECEIPT_ID = R.RECEIPT_ID
                    LEFT JOIN BLOCKS B ON B.BLOCK_HASH = R.INCLUDED_IN_BLOCK_HASH
                    LEFT JOIN EXECUTION_OUTCOMES EO ON EO.RECEIPT_ID = R.RECEIPT_ID
            WHERE eo.status IN ('SUCCESS_RECEIPT_ID', 'SUCCESS_VALUE')
                AND ARA.action_kind = 'FUNCTION_CALL'
                AND (ARA.args -> 'args_json' ->> 'receiver_id' = ANY($1) OR ARA.args -> 'args_json' ->> 'account_id' = ANY($1))
                AND B.BLOCK_TIMESTAMP >= $2
                AND B.BLOCK_TIMESTAMP < $3
                AND NOT EXISTS (
                    SELECT 1
                    FROM RECEIPTS R2
                    JOIN EXECUTION_OUTCOMES EO2 ON EO2.RECEIPT_ID = R2.RECEIPT_ID
                    WHERE (T.CONVERTED_INTO_RECEIPT_ID = R2.RECEIPT_ID OR T.TRANSACTION_HASH = R2.ORIGINATED_FROM_TRANSACTION_HASH)
                    AND EO2.STATUS = 'FAILURE'
            );
            "##,
            &accs,
            &start_date_decimal,
            &end_date_decimal,
        )
        .fetch(&self.pool);

        let start = chrono::Utc::now();

        while let Some(txn) = stream_txs.next().await {
            match txn {
                Ok(txn) => {
                    if let Err(e) = sender_txn.send(txn).await {
                        error!("Error sending transaction: {}", e);
                    };
                }
                Err(e) => error!("Error getting transaction: {}", e),
            }
        }

        let end = chrono::Utc::now();
        info!(
            "Time taken to get incoming FT transactions: {:?} for {:?}",
            end - start,
            accs
        );

        Ok(())
    }

    #[instrument(skip(self))]
    pub async fn get_closest_block_id(&self, date: u128) -> Result<u128> {
        debug!("calling DB");
        let date_decimal = Decimal::from(date);

        let block = sqlx::query_as!(
            BlockId,
            r##"
            SELECT block_height
            FROM blocks
            WHERE block_timestamp >= $1
            ORDER BY block_timestamp ASC
            LIMIT 1;
            "##,
            &date_decimal,
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(block.block_height.to_u128().unwrap())
    }

    #[instrument(skip(self, dates))]
    pub async fn get_closest_block_ids(&self, dates: Vec<u128>) -> Result<Vec<u128>> {
        debug!("calling DB");
        // Convert dates to decimals
        let dates_decimal: Vec<Decimal> = dates.iter().map(|&d| Decimal::from(d)).collect();

        let result = sqlx::query_as!(
            BlockIdWithDate,
            r##"
            WITH RECURSIVE timestamps_cte(date) AS (
                SELECT unnest($1::numeric[]) AS date
            )
            SELECT
                ts.date AS "input_date!",
                (
                    SELECT block_height
                    FROM blocks
                    WHERE block_timestamp >= ts.date
                    ORDER BY block_timestamp ASC
                    LIMIT 1
                ) AS "block_height!"
            FROM timestamps_cte ts
            WHERE ts.date = ANY($1::numeric[])
            "##,
            &dates_decimal
        )
        .fetch_all(&self.pool)
        .await?;

        // Extract block_height from result and return
        let block_ids: Vec<u128> = result
            .into_iter()
            .map(|r| r.block_height.to_u128().unwrap())
            .collect();

        Ok(block_ids)
    }
}

#[derive(Debug, sqlx::FromRow)]
struct BlockIdWithDate {
    input_date: Decimal,
    block_height: Decimal,
}

'''
'''--- src/tta/tta_impl.rs ---
use std::{
    collections::HashSet,
    sync::{Arc, RwLock},
    vec,
};

use anyhow::{bail, Context, Result};

use futures_util::future::join_all;
use near_sdk::ONE_NEAR;

use crate::{tta::utils::get_associated_lockup, TxnsReportWithMetadata};
use base64::{engine::general_purpose, Engine as _};
use chrono::{NaiveDateTime, Utc};

use num_traits::cast::ToPrimitive;
use tokio::sync::{
    mpsc::{channel, Sender},
    Semaphore,
};

use tracing::{debug, error, info, instrument};

use super::{
    ft_metadata::{FtMetadata, FtService},
    models::{
        FtAmounts, FtTransfer, FtTransferCall, MethodName, RainbowBridgeMint, ReportRow,
        WithdrawFromBridge,
    },
    sql::{
        models::{TaArgs, Transaction},
        sql_queries::SqlClient,
    },
};

#[derive(Clone, Copy, PartialEq, Debug)]
pub enum TransactionType {
    Incoming,
    FtIncoming,
    Outgoing,
}

impl TransactionType {
    async fn get_transaction(
        self,
        client: &SqlClient,
        accounts: HashSet<String>,
        start_date: u128,
        end_date: u128,
        tx: Sender<Transaction>,
    ) -> Result<()> {
        match self {
            TransactionType::Incoming => {
                client
                    .get_incoming_txns(accounts, start_date, end_date, tx)
                    .await
            }
            TransactionType::FtIncoming => {
                client
                    .get_ft_incoming_txns(accounts, start_date, end_date, tx)
                    .await
            }
            TransactionType::Outgoing => {
                client
                    .get_outgoing_txns(accounts, start_date, end_date, tx)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct TTA {
    sql_client: SqlClient,
    ft_service: FtService,
    semaphore: Arc<Semaphore>,
}

impl TTA {
    pub fn new(sql_client: SqlClient, ft_service: FtService, semaphore: Arc<Semaphore>) -> Self {
        Self {
            sql_client,
            ft_service,
            semaphore,
        }
    }

    #[instrument(skip(self, start_date, end_date, accounts))]
    pub(crate) async fn get_txns_report(
        &self,
        start_date: u128,
        end_date: u128,
        accounts: HashSet<String>,
        include_balances: bool,
        metadata: Arc<RwLock<TxnsReportWithMetadata>>,
    ) -> Result<Vec<ReportRow>> {
        info!(?start_date, ?end_date, ?accounts, "Got request");

        let mut join_handles = vec![];
        let mut report = vec![];
        let started_at = Utc::now();

        for acc in &accounts {
            let t = self;
            let mut wallets_for_account = HashSet::new();
            let lockup = get_associated_lockup(acc, "near");
            info!(?acc, ?lockup, "Got lockup");
            wallets_for_account.insert(acc.clone());
            wallets_for_account.insert(lockup);

            let task_incoming = tokio::spawn({
                info!(
                    "Acquiring semaphore, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let s = self.semaphore.clone().acquire_owned().await?;
                info!(
                    "Acquired, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let wallets_for_account = wallets_for_account.clone();
                let t = t.clone();
                let for_account = acc.clone();
                let metadata = metadata.clone();

                async move {
                    let _s = s;
                    t.handle_txns(
                        TransactionType::Incoming,
                        for_account,
                        wallets_for_account,
                        start_date,
                        end_date,
                        include_balances,
                        metadata,
                    )
                    .await
                }
            });

            let task_ft_incoming = tokio::spawn({
                info!(
                    "Acquiring semaphore, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let s = self.semaphore.clone().acquire_owned().await?;
                info!(
                    "Acquired, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let wallets_for_account = wallets_for_account.clone();
                let t = t.clone();
                let for_account = acc.clone();
                let metadata = metadata.clone();

                async move {
                    let _s = s;
                    t.handle_txns(
                        TransactionType::FtIncoming,
                        for_account,
                        wallets_for_account,
                        start_date,
                        end_date,
                        include_balances,
                        metadata,
                    )
                    .await
                }
            });

            let task_outgoing = tokio::spawn({
                info!(
                    "Acquiring semaphore, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let s = self.semaphore.clone().acquire_owned().await?;
                info!(
                    "Acquired, remaining: {:?}",
                    self.semaphore.available_permits()
                );
                let wallets_for_account = wallets_for_account.clone();
                let t = t.clone();
                let a = acc.clone();
                let metadata = metadata.clone();

                async move {
                    let _s = s;

                    t.handle_txns(
                        TransactionType::Outgoing,
                        a,
                        wallets_for_account,
                        start_date,
                        end_date,
                        include_balances,
                        metadata,
                    )
                    .await
                }
            });

            join_handles.push(task_incoming);
            join_handles.push(task_ft_incoming);
            join_handles.push(task_outgoing);
        }

        // Wait for threads to be over.
        for ele in join_handles {
            match ele.await {
                Ok(res) => match res {
                    Ok(partial_report) => {
                        let mut p = vec![];
                        // Apply filtering
                        for ele in partial_report {
                            if let Some(ele) = assert_moves_token(ele) {
                                p.push(ele)
                            }
                        }
                        report.extend(p);
                    }
                    Err(e) => {
                        error!(?e, "Error in returned value from thread");
                    }
                },
                Err(e) => {
                    error!(?e, "Error joining threads");
                }
            }
        }

        // sort the report by account_id and block_timestamp
        report.sort_by(|a, b| {
            a.account_id
                .cmp(&b.account_id)
                .then(a.block_timestamp.cmp(&b.block_timestamp))
        });

        let ended_at = Utc::now();

        info!(
            "It took: {:?}, got {} txns",
            ended_at - started_at,
            report.len()
        );

        Ok(report)
    }

    async fn handle_txns(
        self,
        txn_type: TransactionType,
        for_account: String,
        accounts: HashSet<String>,
        start_date: u128,
        end_date: u128,
        include_balances: bool,
        metadata: Arc<RwLock<TxnsReportWithMetadata>>,
    ) -> Result<Vec<ReportRow>> {
        let mut report: Vec<ReportRow> = vec![];
        let (tx, mut rx) = channel(100);

        let t = self.clone();
        tokio::spawn({
            let a = accounts.clone();
            async move {
                txn_type
                    .get_transaction(&t.sql_client, a, start_date, end_date, tx)
                    .await
                    .unwrap();
            }
        });

        let mut rows_handle = vec![];
        while let Some(txn) = rx.recv().await {
            let t2: TTA = self.clone();
            let for_account = for_account.clone();
            let metadata = metadata.clone();
            let row = tokio::spawn(async move {
                if txn.ara_action_kind != "FUNCTION_CALL" && txn.ara_action_kind != "TRANSFER" {
                    return Ok(None);
                }

                let txn_args = decode_args(&txn)?;

                // Skipping gas refunds
                if get_near_transferred(&txn_args) < 0.5
                    && txn.ara_receipt_predecessor_account_id == "system"
                {
                    return Ok(None);
                }

                let ft_amounts = match t2
                    .get_ft_amounts(
                        txn_type != TransactionType::Outgoing,
                        txn.clone(),
                        txn_args.clone(),
                    )
                    .await
                {
                    Ok(ft_amounts) => ft_amounts,
                    Err(e) => bail!("Error getting ft amounts: {:?}", e),
                };

                let (ft_amount_out, ft_currency_out, ft_amount_in, ft_currency_in, to_account) =
                    ft_amounts
                        .as_ref()
                        .map(|ft_amounts| {
                            (
                                ft_amounts.ft_amount_out,
                                ft_amounts.ft_currency_out.clone(),
                                ft_amounts.ft_amount_in,
                                ft_amounts.ft_currency_in.clone(),
                                ft_amounts.to_account.clone(),
                            )
                        })
                        .unwrap_or((None, None, None, None, txn.r_receiver_account_id.clone()));

                let multiplier = if txn_type == TransactionType::Outgoing {
                    -1.0
                } else {
                    1.0
                };

                let mut onchain_balance = None;
                let mut onchain_balance_token = None;
                if include_balances {
                    if ft_amount_in.is_some() || ft_amount_out.is_some() {
                        debug!("Getting onchain balance for {}", for_account);
                        let ft_service = t2.ft_service.clone();
                        onchain_balance = Some(
                            ft_service
                                .assert_ft_balance(
                                    &txn.r_receiver_account_id,
                                    &for_account,
                                    txn.b_block_height
                                        .to_u64()
                                        .expect("Block height too large to fit in u128"),
                                )
                                .await?,
                        );
                        onchain_balance_token = Some(
                            ft_service
                                .assert_ft_metadata(&txn.r_receiver_account_id)
                                .await?
                                .symbol,
                        );
                    } else {
                        // It's a NEAR transfer
                        let near = t2
                            .ft_service
                            .get_near_balance(
                                &for_account,
                                txn.b_block_height
                                    .to_u64()
                                    .expect("Block height too large to fit in u64"),
                            )
                            .await?;
                        if let Some(near) = near {
                            onchain_balance = Some(near.0);
                            onchain_balance_token = Some("NEAR".to_string());
                        }
                    }
                }

                let data = metadata
                    .read()
                    .unwrap()
                    .metadata
                    .get(&for_account)
                    .and_then(|m| m.get(&txn.t_transaction_hash).cloned());

                Ok(Some(ReportRow {
                    account_id: for_account.clone(),
                    date: get_transaction_date(&txn),
                    method_name: get_method_name(&txn, &txn_args),
                    block_timestamp: txn.b_block_timestamp.to_u128().unwrap(),
                    from_account: txn.ara_receipt_predecessor_account_id.clone(),
                    block_height: txn.b_block_height.to_u128().unwrap(),
                    args: decode_transaction_args(&txn_args),
                    transaction_hash: txn.t_transaction_hash.clone(),
                    amount_transferred: get_near_transferred(&txn_args) * multiplier,
                    currency_transferred: "NEAR".to_string(),
                    ft_amount_out,
                    ft_currency_out,
                    ft_amount_in,
                    ft_currency_in,
                    to_account,
                    amount_staked: 0.0,
                    onchain_balance,
                    onchain_balance_token,
                    metadata: data,
                }))
            });
            rows_handle.push(row);
        }

        join_all(rows_handle)
            .await
            .iter()
            .for_each(|row| match row {
                Ok(r) => match r {
                    Ok(row) => {
                        if let Some(row) = row {
                            report.push(row.clone())
                        }
                    }
                    Err(err) => error!(?err, "Error getting row"),
                },
                Err(err) => error!(?err, "Error joining rows"),
            });

        Ok(report)
    }

    async fn get_ft_amounts(
        &self,
        is_incoming: bool,
        txn: Transaction,
        txn_args: TaArgs,
    ) -> Result<Option<FtAmounts>> {
        let method_name = txn_args
            .method_name
            .as_deref()
            .map(MethodName::from)
            .unwrap_or(MethodName::Unsupported);

        let function_call_args = decode_transaction_args(&txn_args);

        let res = match method_name {
            MethodName::FtTransfer => {
                let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;

                let ft_transfer_args = serde_json::from_str::<FtTransfer>(&function_call_args)
                    .context(format!("Invalid ft_transfer args {:?}", function_call_args))?;
                let amount = safe_divide_u128(ft_transfer_args.amount.0, metadata.decimals as u32);
                if is_incoming {
                    Some(FtAmounts {
                        ft_amount_out: None,
                        ft_currency_out: None,
                        ft_amount_in: Some(amount),
                        ft_currency_in: Some(metadata.symbol),
                        from_account: txn.ara_receipt_predecessor_account_id.clone(),
                        to_account: ft_transfer_args.receiver_id.to_string(),
                    })
                } else {
                    Some(FtAmounts {
                        ft_amount_out: Some(amount),
                        ft_currency_out: Some(metadata.symbol),
                        ft_amount_in: None,
                        ft_currency_in: None,
                        from_account: txn.ara_receipt_predecessor_account_id.clone(),
                        to_account: ft_transfer_args.receiver_id.to_string(),
                    })
                }
            }
            MethodName::FtTransferCall => {
                let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;
                let ft_transfer_args = serde_json::from_str::<FtTransferCall>(&function_call_args)
                    .context(format!("Invalid ft_transfer args {:?}", function_call_args))?;
                let amount = safe_divide_u128(ft_transfer_args.amount.0, metadata.decimals as u32);

                // No need to handle incoming. it comes as ft_transfer in case of swap.
                Some(FtAmounts {
                    ft_amount_out: Some(amount),
                    ft_currency_out: Some(metadata.symbol),
                    ft_amount_in: None,
                    ft_currency_in: None,
                    from_account: txn.ara_receipt_predecessor_account_id,
                    to_account: ft_transfer_args.receiver_id.to_string(),
                })
            }
            MethodName::Withdraw => {
                if txn.r_receiver_account_id.ends_with(".factory.bridge.near") {
                    let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;
                    let withdraw_args =
                        serde_json::from_str::<WithdrawFromBridge>(&function_call_args)
                            .context(format!("Invalid withdraw args {:?}", function_call_args))?;
                    let amount = safe_divide_u128(withdraw_args.amount.0, metadata.decimals as u32);

                    Some(FtAmounts {
                        ft_amount_out: Some(amount),
                        ft_currency_out: Some(metadata.symbol),
                        ft_amount_in: None,
                        ft_currency_in: None,
                        from_account: txn.ara_receipt_predecessor_account_id.clone(),
                        to_account: txn.ara_receipt_predecessor_account_id.clone(),
                    })
                } else {
                    None
                }
            }
            MethodName::NearDeposit => {
                let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;
                let deposit = get_near_transferred(&txn_args);
                Some(FtAmounts {
                    ft_amount_out: None,
                    ft_currency_out: None,
                    ft_amount_in: Some(deposit),
                    ft_currency_in: Some(metadata.symbol),
                    from_account: txn.ara_receipt_predecessor_account_id.clone(),
                    to_account: txn.ara_receipt_predecessor_account_id.clone(),
                })
            }
            MethodName::NearWithdraw => {
                let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;
                let withdraw_args = serde_json::from_str::<WithdrawFromBridge>(&function_call_args)
                    .context(format!("Invalid withdraw args {:?}", function_call_args))?;
                let amount = safe_divide_u128(withdraw_args.amount.0, metadata.decimals as u32);

                Some(FtAmounts {
                    ft_amount_out: Some(amount),
                    ft_currency_out: Some(metadata.symbol),
                    ft_amount_in: None,
                    ft_currency_in: None,
                    from_account: txn.ara_receipt_predecessor_account_id.clone(),
                    to_account: txn.ara_receipt_predecessor_account_id.to_string(),
                })
            }
            MethodName::Mint => {
                let metadata = self.get_metadata(&txn.r_receiver_account_id).await?;

                let bridge_mint_args =
                    serde_json::from_str::<RainbowBridgeMint>(&function_call_args).context(
                        format!("Invalid bridge_mint_args args {:?}", function_call_args),
                    )?;
                let amount = safe_divide_u128(bridge_mint_args.amount.0, metadata.decimals as u32);
                if is_incoming {
                    Some(FtAmounts {
                        ft_amount_out: None,
                        ft_currency_out: None,
                        ft_amount_in: Some(amount),
                        ft_currency_in: Some(metadata.symbol),
                        from_account: txn.ara_receipt_predecessor_account_id.clone(),
                        to_account: bridge_mint_args.account_id.to_string(),
                    })
                } else {
                    error!("Minting should always comes from the bridge");
                    None
                }
            }
            MethodName::Unsupported => None,
        };

        Ok(res)
    }

    async fn get_metadata(&self, token_id: &String) -> Result<FtMetadata> {
        let ft_service = self.ft_service.clone();
        let metadata = match ft_service.assert_ft_metadata(token_id.as_str()).await {
            Ok(metadata) => metadata,
            Err(e) => bail!(
                "Failed to get ft_metadata for token_id: {:?}, err: {:?}",
                token_id,
                e
            ),
        };

        Ok(metadata)
    }
}

fn get_near_transferred(txn_args: &TaArgs) -> f64 {
    txn_args
        .deposit
        .as_ref()
        .map_or(Some(0.0), |deposit_str| {
            let deposit: u128 = match deposit_str.parse() {
                Ok(deposit) => deposit,
                Err(e) => panic!("Invalid deposit amount: {:?}, err: {:?}", deposit_str, e),
            };

            let nears = deposit / ONE_NEAR; // integer division
            let remainder = deposit % ONE_NEAR; // remainder

            // Convert the nears and remainder to f64
            let amount = nears as f64 + (remainder as f64 / ONE_NEAR as f64);

            // filter out small amounts
            (amount >= 0.0001).then_some(amount)
        })
        .unwrap_or(0.0)
}

pub fn safe_divide_u128(a: u128, decimals: u32) -> f64 {
    let divisor = 10u128.pow(decimals);
    (a / divisor) as f64 + (a % divisor) as f64 / divisor as f64
}

fn decode_args(txn: &Transaction) -> Result<TaArgs> {
    match serde_json::from_value::<TaArgs>(txn.clone().ara_args) {
        Ok(args) => Ok(args),
        Err(e) => bail!("Invalid args {:?}, err: {:?}", txn.ara_args, e),
    }
}

fn decode_transaction_args(txn_args: &TaArgs) -> String {
    match txn_args.args_base64.as_ref() {
        Some(base64_string) => general_purpose::STANDARD
            .decode(base64_string)
            .map(|decoded: Vec<u8>| {
                let mut args = String::new();
                for byte in decoded {
                    args.push(byte as char);
                }
                args
            })
            .unwrap_or_else(|_| String::new()),
        None => "{}".to_string(),
    }
}

fn get_method_name(txn: &Transaction, txn_args: &TaArgs) -> String {
    if txn.ara_action_kind != "FUNCTION_CALL" {
        txn.ara_action_kind.clone()
    } else {
        match &txn_args.method_name {
            Some(method_name) => method_name.clone(),
            None => {
                error!("No method name {:?}", txn_args);
                "".to_string()
            }
        }
    }
}

fn get_transaction_date(txn: &Transaction) -> String {
    let nanoseconds = txn
        .b_block_timestamp
        .to_u128()
        .expect("Timestamp too large to fit in u128");
    let seconds = (nanoseconds / 1_000_000_000) as i64;
    let date = NaiveDateTime::from_timestamp_opt(seconds, 0)
        .expect("Invalid timestamp")
        .date();
    date.format("%B %d, %Y").to_string()
}

fn assert_moves_token(row: ReportRow) -> Option<ReportRow> {
    if row.amount_transferred == 0.000000
        && row.ft_amount_out.is_none()
        && row.ft_amount_in.is_none()
        && row.amount_staked == 0.0
    {
        None
    } else {
        Some(row)
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use chrono::DateTime;
    use near_jsonrpc_client::{JsonRpcClient, NEAR_MAINNET_ARCHIVAL_RPC_URL};
    use sqlx::postgres::PgPoolOptions;

    use super::*;

    async fn setup() -> Result<(SqlClient, FtService, TTA)> {
        let pool = PgPoolOptions::new()
            .max_connections(30)
            .connect(env!("DATABASE_URL"))
            .await?;

        let sql_client = SqlClient::new(pool);
        let near_client = JsonRpcClient::connect(NEAR_MAINNET_ARCHIVAL_RPC_URL);
        let ft_service = FtService::new(near_client);
        let semaphore = Arc::new(Semaphore::new(30));
        let tta_service = TTA::new(sql_client.clone(), ft_service.clone(), semaphore);

        Ok((sql_client, ft_service, tta_service))
    }

    #[tokio::test]
    async fn tta() -> Result<()> {
        let (_, _, tta_service) = setup().await?;

        let start_date = DateTime::parse_from_rfc3339("2022-01-01T00:00:00Z")
            .unwrap()
            .timestamp_nanos() as u128;
        let end_date = DateTime::parse_from_rfc3339("2022-02-01T00:00:00Z")
            .unwrap()
            .timestamp_nanos() as u128;
        let accounts: HashSet<String> = "nf-payments.near,nf-payments2.near"
            .split(',')
            .map(String::from)
            .collect();
        let include_balances = false;

        let mut accounts_metadata = HashMap::new();
        let mut account_txns = HashMap::new();

        account_txns.insert(
            "51VVGwLAFX6K62jB84E6qVHdF4GbhEMB2CoZJ9ZziiEt".to_string(),
            "unit test".to_string(),
        );

        accounts_metadata.insert("nf-payments.near".to_string(), account_txns);

        let metadata_struct = Arc::new(RwLock::new(TxnsReportWithMetadata {
            metadata: accounts_metadata,
        }));

        let res = tta_service
            .get_txns_report(
                start_date,
                end_date,
                accounts,
                include_balances,
                metadata_struct,
            )
            .await
            .unwrap();

        assert!(!res.is_empty());

        for row in res {
            if row.transaction_hash == "51VVGwLAFX6K62jB84E6qVHdF4GbhEMB2CoZJ9ZziiEt" {
                assert_eq!(row.metadata, Some("unit test".to_string()));
            } else {
                assert_eq!(row.metadata, None);
            }
        }
        Ok(())
    }
}

'''
'''--- src/tta/utils.rs ---
use sha2::{Digest, Sha256};

pub fn get_associated_lockup(account_id: &str, master_account_id: &str) -> String {
    format!(
        "{}.lockup.{}",
        &sha256(account_id)[0..40],
        master_account_id
    )
}

fn sha256(value: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(value.as_bytes());
    format!("{:x}", hasher.finalize())
}

'''
'''--- ui/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEAR transaction report</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp"></script>
  <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
</head>

<body>
  <div class="prose flex flex-col p-3 gap-3">
    <h1>NEAR transaction report</h1>
    <div class="flex flex-col items-center justify-center gap-3">
      <div class="inline-flex items-center gap-1">
        <input type="date" id="startDate" placeholder="YYYY-MM-DD" required>
        to
        <input type="date" id="endDate" placeholder="YYYY-MM-DD" required>
        (up until, and excluding)
      </div>
      <textarea id="accountIds" placeholder="account IDs separated by linebreaks or commas"
        style="width: 100%; height: 20rem" required></textarea>
    </div>

    <div class="flex flex-col items-center">
      <div class="flex items-center gap-2">
        <label for="includeBalances">Include balances in full accounting exports:</label>
        <input type="checkbox" id="includeBalances">
      </div>
      <p class="text-sm text-red-500">
        Note: Reports with balances per block may take significantly longer to generate.
      </p>
      <button onclick="handleDownloadClick()" id="downloadButton"
        class="w-1/2 rounded bg-blue-100 px-2 py-1 hover:bg-blue-300">
        Download report as CSV
      </button>

    </div>
    <!-- seperator -->
    <div class="border-t-2 border-gray-200"></div>
    <div class="flex flex-col items-center">
      <button onclick="handleGetBalancesCsv()" id="getBalancesButton"
        class="w-1/2 rounded bg-blue-100 px-2 py-1 hover:bg-blue-300">
        Get start and end balances
      </button>
    </div>
  </div>
  </div>

  <script>
    const TTA_URL = "https://tta-api.onrender.com";

    const handleDownloadClick = async () => {
      const downloadButton = document.getElementById("downloadButton");
      const startDateInput = document.getElementById("startDate");
      const endDateInput = document.getElementById("endDate");
      const accountIdsTextArea = document.getElementById("accountIds");
      const includeBalancesInput = document.getElementById("includeBalances");

      downloadButton.disabled = true;
      downloadButton.innerText = "Loading, time to grab a coffee...";

      if (!startDateInput.value || !endDateInput.value) {
        alert("Please select valid start and end dates");
        return;
      }

      const start = new Date(startDateInput.value + "T00:00:00Z").toISOString();
      const end = new Date(endDateInput.value + "T00:00:00Z").toISOString();

      const accountIdsArray = accountIdsTextArea.value.replaceAll(" ", "").split(/,|\n/);
      const commaSeparatedAccountIds = accountIdsArray.join(",");

      const url = `${TTA_URL}/tta?start_date=${start}&end_date=${end}&accounts=${commaSeparatedAccountIds}` +
        `&include_balances=${includeBalancesInput.checked.toString()}`;

      fetch(url, { method: "GET" }).then(response => {
        const contentDisposition = response.headers.get("Content-Disposition");
        if (response.ok) {
          return response.blob().then(blob => [blob, contentDisposition]);
        }
        throw new Error("Network response was not ok");
      }).then(([blob, contentDisposition]) => {
        const url = window.URL.createObjectURL(blob);
        let filename = "report.csv";
        if (contentDisposition) {
          const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
          const matches = filenameRegex.exec(contentDisposition);
          if (matches != null && matches[1]) {
            filename = matches[1].replace(/['"]/g, "");
          }
        }
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }).catch(error => {
        console.error("Error:", error);
      }).finally(() => {
        downloadButton.disabled = false;
        downloadButton.innerText = "Download report as CSV";
      });
    }

    const handleGetBalancesCsv = async () => {
      const downloadButton = document.getElementById("getBalancesButton");
      const startDateInput = document.getElementById("startDate");
      const endDateInput = document.getElementById("endDate");
      const accountIdsTextArea = document.getElementById("accountIds");

      downloadButton.disabled = true;
      downloadButton.innerText = "Loading, usually 20 seconds per account...";

      if (!startDateInput.value || !endDateInput.value) {
        alert("Please select valid start and end dates");
        return;
      }

      const start = new Date(startDateInput.value + "T00:00:00Z").toISOString();
      const end = new Date(endDateInput.value + "T00:00:00Z").toISOString();

      const accountIdsArray = accountIdsTextArea.value.replaceAll(" ", "").split(/,|\n/);
      const commaSeparatedAccountIds = accountIdsArray.join(",");

      const url = `${TTA_URL}/balances?start_date=${start}&end_date=${end}&accounts=${commaSeparatedAccountIds}`;

      fetch(url, { method: "GET" }).then(response => {
        const contentDisposition = response.headers.get("Content-Disposition");
        if (response.ok) {
          return response.blob().then(blob => [blob, contentDisposition]);
        }
        throw new Error("Network response was not ok");
      }).then(([blob, contentDisposition]) => {
        const url = window.URL.createObjectURL(blob);
        let filename = "balances.csv";

        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }).catch(error => {
        console.error("Error:", error);
      }).finally(() => {
        downloadButton.disabled = false;
        downloadButton.innerText = "Get start and end balances";
      });
    }
  </script>
</body>

</html>
'''