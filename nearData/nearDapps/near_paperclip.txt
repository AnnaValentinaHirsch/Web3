*GitHub Repository "near/paperclip"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .travis.yml ---
language: rust
rust: stable
node_js: "12"
install: "npm install -g gitbook-cli"

# jobs are sorted by duration to optimize time to completion
matrix:
  include:
  - name: test
    script:
    - cargo test --all --features "actix cli chrono uuid"
    - cd tests/test_k8s && cargo check
    - cd ../test_pet && cargo check
    - cd cli && CARGO_TARGET_DIR=../target cargo check
    - cd ../../test_k8s/cli && CARGO_TARGET_DIR=../target cargo check
  - name: test-nightly
    before_script:
    - rustup toolchain install nightly
    - rustup default nightly
    script:
    - cargo test --all --features "actix-nightly cli chrono uuid"
  - name: build
    script:
    - cargo build
    - cargo build --features actix
    - cargo build --features cli
  - name: docs
    script:
    - rm -rf target/doc
    - cargo doc --all --features "actix cli chrono uuid" --no-deps
    - gitbook build book/
    - cp -r book/_book/* target/doc/
  - name: check
    before_script:
    - rustup toolchain install nightly --allow-downgrade -c rustfmt
    - rustup component add clippy
    script:
    - cargo +nightly fmt --all -- --check
    - cargo clippy --all --features "actix" -- -D clippy::all

deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN
  on:
    branch: master
    condition: "$TRAVIS_JOB_NAME = docs"
  local_dir: target/doc
  fqdn: paperclip.waffles.space

'''
'''--- CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Add support for actix-web-macros methods routing [PR#289](https://github.com/wafflespeanut/paperclip/pull/289)
- Actix plugin: add an empty impl for actix-web `ReqData<T>`

### Changed

### Fixed
- Optional type aliases like `type Email = Option<String>` will not be added to the `required` fields.
- Actix plugin: Path tuples now inherit field names and descriptions from doc comments

## [0.5.0] - 2020-11-28
### Added
- Actix plugin: Support for actix-web 3.0 (is now default).
- Arrays up to length 32 are supported (in codegen and actix-web plugin).
- Actix plugin: `#[api_v2_operation]` macro now supports specifying `consumes`, `produces`, `summary`, `description`, `tags`
and `operation_id` in macro.
- Actix plugin: Support for `actix-session`, `serde_qs` and `chrono` types in handlers.
- Actix plugin: `App::wrap_api_with_spec` allows to provide default specification with `info` and other custom settings
- Actix plugin: Support tags in api_v2_operation macros.
- Actix plugin: `#[serde(flatten)]` support in `Apiv2Schema` derive.
- Actix plugin: Added wrapper types for some 2xx status codes.

### Changed
- Actix plugin: Refactored internals of `#[api_v2_operation]` proc macro (long-outstanding technical debt). This now generates operation metadata (on the fly) for each handler, which enables us to tie custom changes to operations easily.
- Actix plugin: Grouping of parameters across handlers have been disabled as a result of major bugs (it's now under `normalize` feature).
- Actix plugin: actix-web `2.x` is supported through `actix2` and `actix2-nightly` features.

### Fixed
- `Apiv2Schema` supports `HashMap<Uuid, Foo>`.
- Actix plugin: `#[api_v2_operation]` supports referencing inside handlers.
- Actix plugin: Fixed a bug on using `where` clause in handlers marked with `#[api_v2_operation]`.
- Actix plugin: API objects have `object` type specified in their schemas.

## [0.4.1] - 2020-07-01
### Fixed
- Re-exported import from `proc-macro-error` which broke builds.

## [0.4.0] - 2020-06-13
### Added
- Client timeout in CLI.
- Codegen for header parameters in operations.
- Validation for non-body parameters.
- `x-rust-dependencies` field in root for specifying additional crate dependencies.
- Default en/decoders (JSON/YAML) and support for custom en/decoders through `x-rust-coders` field in root.
- Methods to `Schema` trait for aiding resolution and codegen.
- Codegen for nested arrays in operation parameters.
- Codegen for form data parameters in operations.
- Codegen for `Any` type in schema.
- CLI payload encoding/decoding supports custom types and not limited to JSON.
- Codegen for `#[deprecated]` attribute when `deprecated` field is set to `true` in schema.
- Codegen adds `Request` and `Response` traits for HTTP request and response objects.
- CLI uses name and version from `info` field in spec.
- Codegen for file responses with streaming to `AsyncWrite` implementors.
- Codegen for `multipart/form-data` parameters with file streaming.
- Referencing globally defined parameters and responses.
- Codegen for enums in object definitions.
- Response wrapper containing headers and status code for operation.
- Parsing for custom response headers.
- Actix plugin: `#[openapi(empty)]` attribute can be used to any type to implement empty schema and ignore the warning.
- Actix plugin: Empty impls for some actix-web types (like `Payload`, `Data<T>`, etc.).
- Actix plugin: Raw JSON spec generation from handlers.
- Actix plugin: Support for `#[serde(rename = "...")]` and `#[serde(rename_all = "...")]`.
- Actix plugin: Support for error (non-2xx) response codes.
- Actix plugin: Type-level and field-level documentation is now used for `description` fields in schema and properties.
- Actix plugin: Security definitions (globally) and security requirements (for operations).
- Actix plugin: Support for `serde_json::Value` and `serde_yaml::Value` (by default), and for objects from `uuid`, `rust_decimal`, `chrono`, etc. (through features of the same name) in structs.

### Changed
- Switched to templating for (almost) static modules.
- Operation IDs are preferred for method names if they exist.
- `ApiClient` uses the newly added `Request` and `Response` and is now async/await.
- `Sendable` accepts the new `ApiClient` and is now async/await.
- `SchemaRepr` renamed to `Resolvable`.
- `OperationMap` renamed to `PathItem`.
- `Api` struct is now generic over parameters and responses in addition to definitions.
- Actix plugin: Switched to `actix-web = "^2.0"`.
- Actix plugin: **Supports stable compiler**.
- Actix plugin: `#[api_v2_schema]` macro attribute is now `#[derive(Apiv2Schema)]`.

### Fixed
- Switched `enum` field to array of `any` rather than strings.
- Resolution of anonymous schema definitions in objects, operation parameters and responses.
- Unmappable operations (i.e., without body parameters and simple response types) are now namespaced in a separate module.
- Array definitions are now allowed in schemas.
- `additionalProperties` takes boolean or a schema.
- Deadlock when resolving some recursive types.
- Actix plugin: `.route()` method call on `App`, `Scope` and `ServiceConfig` don't override existing route operations.
- Actix plugin: `web::Path<T>` also supports simple types (strings, integers, etc.).
- Actix plugin: `#[api_v2_schema]` derivatives can now use references.
- Actix plugin: Breakage of `#[api_v2_operation]` when returning `impl Handler`.
- Actix plugin: `web::scope` supports having path parameters.
- Actix plugin: Misuse of `actix_web::Scope` in `App::configure` which resulted in missing overwritten routes.

## [0.3.0] - 2019-07-30
### Added
- Paperclip's `#[api_v2_schema]` derives raw schema structs (i.e., no smart pointers) along with actual schema structs for other users and plugins. An effect of this would be that now there's a `DefaultSchemaRaw` in addition to `DefaultSchema`.
- `TypedData`, `Apiv2Schema` and `Apiv2Operation` traits for deriving v2 spec for server plugins.
- `paperclip-core` crate for segregating core types and traits.
- `paperclip-actix` crate as an actix-web plugin for hosting v2 spec as a JSON by marking models and operations using proc macro attributes.
- `paperclip::actix` module for exporting `paperclip_actix::*` when `actix` feature is enabled.

### Changed
- Segregated dependencies using feature gates.
- `Api::<S>::resolve` now returns `ValidationError` instead of `failure::Error`.
- During serialization, optional schema fields are skipped when empty/null.

### Fixed
- Allowing ports in `host` field in v2 spec.

## [0.2.0] - 2019-07-03
### Added
- Gitbook for detailed documentation and walkthroughs.
- Changelog
- Root module (`mod.rs`, `lib.rs` or `main.rs`) generation for codegen (previously we were only generating children modules).
- Cargo manifest generation (gated by `"cli"` feature).
- `[bin]` target (CLI) for generating crates.
- CLI generation (fancy curl for your APIs) - generated app uses async/await and `runtime_tokio`.
- `ApiClient::make_request` for sending a request and fetching a response future.
- Support for operations returning array of objects.
- Codegen uses `basePath` and `host` fields (if they exist) to override default base URL (`https://example.com`).
- API relative paths are checked for uniqueness.

### Changed
- Codegen now writes the dependency traits, types and impls in the root module.

### Removed
- `ApiClient::base_url` in favor of `ApiClient::make_request`
- Redundant `Optional` trait for generated markers.

### Fixed
- Templated paths are now validated against parameters.
- Import prefixes support in emitter (for codegen).

## [0.1.0] - 2019-06-13
### Added
- Build script example in README.
- `impl Sendable` for fulfilled builders to send API requests and return response futures.
- Documentation for builders and methods from `description` fields.
- Generation of `#[repr(transparent)]` builders with phantom fields for enforcing required parameters.
- Generation of builders for API objects and operations.
- Generation of Rust structs with appropriate serde rules from definitions.
- `#[api_schema]` proc-macro attribute for implementing `Schema` trait for custom schemas.
- Resolution of `$ref` references in definitions and paths to objects in the same file.
- Loading OpenAPI v2 schema from JSON/YAML
- Workspace, README, LICENSE, Makefile, CI config, etc.

[Unreleased]: https://github.com/wafflespeanut/paperclip/compare/v0.5.0...HEAD
[0.5.0]: https://github.com/wafflespeanut/paperclip/compare/v0.4.1...v0.5.0
[0.4.1]: https://github.com/wafflespeanut/paperclip/compare/v0.4.0...v0.4.1
[0.4.0]: https://github.com/wafflespeanut/paperclip/compare/v0.3.0...v0.4.0
[0.3.0]: https://github.com/wafflespeanut/paperclip/compare/v0.2.0...v0.3.0
[0.2.0]: https://github.com/wafflespeanut/paperclip/compare/v0.1.0...v0.2.0
[0.1.0]: https://github.com/wafflespeanut/paperclip/releases/tag/v0.1.0

'''
'''--- Cargo.toml ---
[package]
name = "paperclip"
version = "0.5.0"
authors = ["Ravi Shankar <wafflespeanut@gmail.com>"]
edition = "2018"
description = "OpenAPI tooling library for type-safe compile-time checked HTTP APIs"
documentation = "https://paperclip.waffles.space/paperclip"
keywords = ["openapi", "api", "swagger", "http", "web"]
license = "MIT OR Apache-2.0"
homepage = "https://github.com/wafflespeanut/paperclip"
repository = "https://github.com/wafflespeanut/paperclip"
readme = "README.md"
build = "src/build/build.rs"

[[bin]]
name = "paperclip"
path = "src/bin/main.rs"
required-features = ["cli"]

[dependencies]
env_logger = { version = "0.8", optional = true }
git2 = { version = "0.13", optional = true }
heck = { version = "0.3", optional = true }
http = { version = "0.2", optional = true }
itertools = "0.10"
log = { version = "0.4", optional = true }
paperclip-actix = { path = "plugins/actix-web", version = "0.3.0", optional = true }
paperclip-core = { path = "core", version = "0.3.0" }
paperclip-macros = { path = "macros", version = "0.4.0", optional = true }
parking_lot = { version = ">=0.10,<0.12" }
regex = { version = "1.3", optional = true }
reqwest = { version = "0.10", features = ["blocking"], optional = true }
semver = ">=0.9, <0.12"
serde = "1.0"
serde_derive = "1.0"
serde_json = "1.0"
serde_yaml = "0.8"
structopt = { version = "0.3", optional = true }
tinytemplate = { version = "1.1", optional = true }
url = ">=1.7,<3"
thiserror = "1.0"
anyhow = "1.0"
once_cell = "1.4"

[dev-dependencies]
actix-rt = "2"
actix-service = "2.0.0-beta.4"
actix-web = { version = "4.0.0-beta.6", default-features = false }
chrono_dev = { version = "0.4", features = ["serde"], package = "chrono" }
futures = "0.3"
uuid_dev = { version = "0.8", features = ["serde"], package = "uuid" }
reqwest = { version = "0.10", features = ["blocking", "json"] }
log = { version = "0.4", features = ["kv_unstable"] }
insta = "1.0"
env_logger = "0.8"

[features]
# actix-web support
actix = ["actix4"]
actix-nightly = ["actix3-nightly"]
actix2-nightly = ["actix2", "paperclip-actix/nightly"]
actix3-nightly = ["actix3", "paperclip-actix/nightly"]
actix4-nightly = ["actix4", "paperclip-actix/nightly"]
actix2 = ["actix-base", "paperclip-actix/actix2"]
actix3 = ["actix-base", "paperclip-actix/actix3"]
actix4 = ["actix-base", "paperclip-actix/actix4"]
actix-base = ["v2", "paperclip-macros/actix"]

# OpenAPI support (v2 and codegen)
cli = ["env_logger", "structopt", "git2", "v2", "codegen"]
codegen = ["heck", "http", "log", "regex", "tinytemplate", "paperclip-core/codegen"]
v2 = ["paperclip-macros/v2", "paperclip-core/v2"]

# Features for implementing traits for dependencies.
actix-multipart = ["paperclip-core/actix-multipart"]
actix-session = ["paperclip-core/actix-session"]
actix-files = ["paperclip-core/actix-files"]
chrono = ["paperclip-core/chrono"]
rust_decimal = ["paperclip-core/rust_decimal"]
uuid = ["paperclip-core/uuid"]
serde_qs = ["paperclip-core/serde_qs"]

[workspace]
members = [
    ".",
    "core",
    "macros",
    "plugins/actix-web",
]

[[test]]
name = "test_codegen"
required-features = ["v2", "codegen"]

[[test]]
name = "test_errors"
required-features = ["v2", "codegen"]

[[test]]
name = "test_app"
required-features = ["cli", "actix", "uuid", "chrono"]

'''
'''--- README.md ---
# Paperclip

[![Build Status](https://api.travis-ci.org/wafflespeanut/paperclip.svg?branch=master)](https://travis-ci.org/wafflespeanut/paperclip)
[![API docs](https://img.shields.io/badge/docs-latest-blue.svg)](https://paperclip.waffles.space/paperclip)
[![Crates.io](https://img.shields.io/crates/v/paperclip.svg)](https://crates.io/crates/paperclip)

Paperclip offers tooling for the [OpenAPI specification](https://github.com/OAI/OpenAPI-Specification/). Once complete, it will provide:

- Code generation for efficient, type-safe, compile-time checked HTTP APIs (server, client and CLI) in Rust.
- Support for processing, validating and hosting OpenAPI spec.
- Customization for spec and code generation.

It's currently under active development and may not be ready for production use just yet.

You may be interested in:

 - [Examples and Usage](https://paperclip.waffles.space/).
 - [Features being worked on](https://github.com/wafflespeanut/paperclip/projects).
 - [API documentation](https://paperclip.waffles.space/paperclip).

## Developing locally

 - Make sure you have [`rustup`](https://rustup.rs/) installed. `cd` into this repository and run `make prepare` to setup your environment.
 - Now run `make` to build and run the tests.

## Contributing

This project welcomes all kinds of contributions. No contribution is too small!

If you want to contribute to this project but don't know how to begin or if you need help with something related to this project, feel free to send me an email (in Github profile) or join the [Discord server](https://discord.gg/PPu4Dhj).

## Code of Conduct

This project follows the [Rust Code of Conduct](https://www.rust-lang.org/policies/code-of-conduct).

## License

Licensed under either of

- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.

## Sponsors

Folks who have sponsored for the development of this project:

<table>
  <tr>
    <td><a href="https://offscale.io"><img src="https://avatars1.githubusercontent.com/u/11748352" width="100"></a>
  </tr>
</table>

## FAQ

> Why is this generating raw Rust code instead of leveraging [procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html) for compile-time codegen?

I don't think proc macros are the right way to go for REST APIs. We need to be able to **see** the generated code somehow to identify names, fields, supported methods, etc. With proc macros, you sorta have to guess.

This doesn't mean you can't generate APIs in compile-time. The only difference is that you'll be using [build scripts](https://paperclip.waffles.space/build-script.html) instead and `include!` the relevant code. That said, [we're using proc-macros](./macros) for other things.

> The error thrown at compile-time doesn't look like it's very useful. Isn't there a better way to do this?

None that I can think of, sadly.

**New ideas are here needed.**

'''
'''--- book/README.md ---
[![API docs](https://img.shields.io/badge/docs-latest-blue.svg)](https://paperclip.waffles.space/paperclip)
[![Crates.io](https://img.shields.io/crates/v/paperclip.svg)](https://crates.io/crates/paperclip)

# Paperclip

Paperclip is a OpenAPI code generator for efficient type-safe compile-time checked HTTP APIs in Rust.

It's currently under active development and may not be ready for production use just yet.

### Features

- Paperclip CLI can generate API client library (which checks some usage at [compile-time](compile-checks.md)) or a console for your API (which checks usage at [runtime](cli.md#runtime-checks)).
- API client code can also be generated using [build scripts](build-script.md) which will then check parameters usage in your library at compile time.
- [Acix-web plugin](actix-plugin.md) can be used to host the API spec for your `actix-web` application.

### Design

TODO

'''
'''--- book/SUMMARY.md ---
# Summary

* [Overview](README.md)
* [CLI](cli.md)
* [Build script](build-script.md)
  * [Compile-time checks](compile-checks.md)
* [Actix-web plugin](actix-plugin.md)
  * [Adding operation metadata](actix-operation-meta.md)
  * [Defining additional HTTP status codes](actix-status-codes.md)
  * [Defining security](actix-security.md)
  * [Setting schema defaults](actix-schema-defaults.md)

'''
'''--- book/actix-operation-meta.md ---
## Adding additional metadata to operations

By default, the first doc comment (if any) is taken for the `summary` field and the rest of the following doc comments
(if any) will be taken as `description` for that operation.

```rust
/// Default
/// multiline
/// summary
///
/// Default
/// multiline
/// description
async fn my_handler() -> Json<Foo> { /* */ }
```

This can be overridden by explicitly specifying `summary` and `description` in the proc-macro attribute like so:

```rust
#[api_v2_operation(
  summary = "My awesome handler",
  description = "It creates a pretty JSON object",
  /// A few other parameters are also supported
  operation_id = "my_handler",
  consumes = "application/yaml, application/json",
  produces = "application/yaml, application/json",
  tags(Cats, Dogs, "Api reference"),
)]
async fn my_handler() -> Json<Foo> { /* */ }
```

'''
'''--- book/actix-plugin.md ---
# Host OpenAPI v2 spec through actix-web

With `actix` feature enabled, paperclip exports an **experimental** plugin for [actix-web](https://github.com/actix/actix-web) framework to host OpenAPI v2 spec for your APIs *automatically*. While it's not feature complete, you can rely on it to not break your actix-web flow.

Let's start with a simple actix-web application. It has `actix-web` and `serde` for JSON'ifying your APIs. Let's also add `paperclip` with `actix` feature.

```toml
# [package] ignored for brevity

[dependencies]
# actix-web 2.0 is supported through "actix2" and "actix2-nightly" features
actix-web = "3.0"
# The "actix-nightly" feature can be specified if you're using nightly compiler. Even though
# this plugin works smoothly with the nightly compiler, it also works in stable
# channel (replace "actix-nightly" feature with "actix" in that case). There maybe compilation errors,
# but those can be fixed.
paperclip = { version = "0.4", features = ["actix-nightly"] }
serde = "1.0"
```

Our `main.rs` looks like this:

```rust
use actix_web::{App, HttpServer, web::{self, Json}};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Pet {
    name: String,
    id: Option<i64>,
}

async fn echo_pet(body: Json<Pet>) -> Result<Json<Pet>, ()> {
    Ok(body)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new()
        .service(
            web::resource("/pets")
                .route(web::post().to(echo_pet))
        )
    ).bind("127.0.0.1:8080")?
    .run().await
}
```

Now, let's modify it to use the plugin!

```rust
use actix_web::{App, HttpServer};
use paperclip::actix::{
    // extension trait for actix_web::App and proc-macro attributes
    OpenApiExt, Apiv2Schema, api_v2_operation,
    // use this instead of actix_web::web
    web::{self, Json},
};
use serde::{Serialize, Deserialize};

// Mark containers (body, query, parameter, etc.) like so...
#[derive(Serialize, Deserialize, Apiv2Schema)]
struct Pet {
    name: String,
    id: Option<i64>,
}

// Mark operations like so...
#[api_v2_operation]
async fn echo_pet(body: Json<Pet>) -> Result<Json<Pet>, ()> {
    Ok(body)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new()
        // Record services and routes from this line.
        .wrap_api()
        // Add routes like you normally do...
        .service(
            web::resource("/pets")
                .route(web::post().to(echo_pet))
        )
        // Mount the JSON spec at this path.
        .with_json_spec_at("/api/spec")

        // ... or if you wish to build the spec by yourself...

        // .with_raw_json_spec(|app, spec| {
        //     app.route("/api/spec", web::get().to(move || {
        //         actix_web::HttpResponse::Ok().json(&spec)
        //     }))
        // })

        // IMPORTANT: Build the app!
        .build()
    ).bind("127.0.0.1:8080")?
    .run().await
}
```

We have:

 - Imported `OpenApiExt` extension trait for `actix_web::App` along with `Apiv2Schema` derive macro and `api_v2_operation` proc macro attributes.
 - Switched from `actix_web::web` to `paperclip::actix::web`.
 - Marked our `Pet` struct and `add_pet` function as OpenAPI-compatible schema and operation using proc macro attributes.
 - Transformed our `actix_web::App` to a wrapper using `.wrap_api()`.
 - Mounted the JSON spec at a relative path using `.with_json_spec_at("/api/spec")`.
 - Built (using `.build()`) and passed the original `App` back to actix-web.

Note that we never touched the service, resources, routes or anything else! This means that our original actix-web flow is unchanged.

Now you can check the API with the following **cURL** command:

```
curl -X POST http://localhost:8080/pets -H "Content-Type: application/json" -d '{"id":1,"name":"Felix"}'
```

And see the specs with this:

```
curl http://localhost:8080/api/spec
```

... we get the swagger spec as a JSON!

```js
// NOTE: Formatted for clarity
{
  "swagger": "2.0",
  "definitions": {
    "Pet": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      },
      "required": ["name"]
    }
  },
  "paths": {
    "/pets": {
      "post": {
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Pet"
            }
          }
        }
      },
      "parameters": [{
        "in": "body",
        "name": "body",
        "required": true,
        "schema": {
          "$ref": "#/definitions/Pet"
        }
      }]
    }
  },
  "info": {
    "version": "",
    "title": ""
  }
}
```

Similarly, if we were to use other extractors like `web::Query<T>`, `web::Form<T>` or `web::Path`, the plugin will emit the corresponding specification as expected.

#### Known limitations

- **Enums:** OpenAPI (v2) itself supports using simple enums (i.e., with unit variants), but Rust and serde has support for variants with fields and tuples. I still haven't looked deep enough either to say whether this can/cannot be done in OpenAPI or find an elegant way to represent this in OpenAPI.
- **Functions returning abstractions:** The plugin has no way to obtain any useful information from functions returning abstractions such as `HttpResponse`, `impl Responder` or containers such as `Result<T, E>` containing those abstractions. So currently, the plugin silently ignores these types, which results in an empty value in your hosted specification.

#### Missing features

At the time of this writing, this plugin didn't support a few OpenAPI v2 features:

Affected entity | Missing feature(s)
--------------- | ---------------
[Parameter](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object) | Non-body parameters allowing validations like `allowEmptyValue`, `collectionFormat`, `items`, etc.
[Parameter](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object) | Headers as parameters.

#### Performance implications?

Even though we use some wrappers and generate schema structs for building the spec, we do this only once i.e., until the `.build()` function call. At runtime, it's basically a pointer read, which is quite fast!

We also add wrappers to blocks in functions tagged with `#[api_v2_operation]`, but those wrappers follow the [Newtype pattern](https://doc.rust-lang.org/stable/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types) and the code eventually gets optimized away anyway.

'''
'''--- book/actix-schema-defaults.md ---
## Setting defaults in API schema

It is possible to define default initial values for the schema, which might be useful to define "info",
"schemes", "tags" and other top level schema fields which are not inherited from handlers.

```rust
use paperclip::v2::models::{DefaultApiRaw, Tag};

let mut spec = DefaultApiRaw::default();
spec.tags = vec![
    Tag {
        name: "Dogs".to_string(),
        description: Some("Images of dogs".to_string()),
        external_docs: None,
    },
    Tag {
        name: "Cats".to_string(),
        description: Some("Images of cats".to_string()),
        external_docs: None,
    },
    Tag {
        name: "Api reference".to_string(),
        description: Some("List of all api endpoints".to_string()),
        external_docs: None,
    },
];
spec.info = Info {
    version: "0.1".into(),
    title: "Image server".into(),
    ..Default::default()
};
App::new()
    .wrap_api_with_spec(spec)
    .with_json_spec_at("/api/spec")
    .service(web::resource("/images/pets").route(web::get().to(some_pets_images)))
    .build()
```

'''
'''--- book/actix-security.md ---
## Defining security schemes for your API

You can use `Apiv2Security` derive macro for structs which can then be used as handler parameters to have those handlers marked as requiring authorization.

```rust
use paperclip::actix::Apiv2Security;

#[derive(Apiv2Security)]
#[openapi(
  apiKey,
  in = "header",
  name = "Authorization",
  description = "Use format 'Bearer TOKEN'"
)]
pub struct AccessToken;

impl FromRequest for Accesstoken { /*...*/ }

#[api_v2_operation]
async fn my_handler(access_token: AccessToken) -> Result<String, MyError> {
    /*...*/
}
```

First parameter is the type of security, currently supported types are "apiKey" and "oauth2". Possible parameters are `alias`, `description`, `name`, `in`, `flow`, `auth_url`, `token_url` or `parent`.

Use `alias` parameter if you need to have two different security definitions of the same type.

If you need to define scopes for `oauth2`, use `parent` attribute:

```rust
#[derive(Apiv2Security, Deserialize)]
#[openapi(
  oauth2,
  auth_url = "http://example.com/",
  token_url = "http://example.com/token",
  flow = "password"
)]
struct OAuth2Access;

#[derive(Apiv2Security, Deserialize)]
#[openapi(parent = "OAuth2Access", scopes("pets.read", "pets.write"))]
struct PetScopeAccess;
```

'''
'''--- book/actix-status-codes.md ---
## Adding additional response status codes to operations

Paperclip deduces your API schema using macros (which read the types of handlers and parameter structs at compile time), so in order for paperclip to know what response code sent by the API, it needs type information about it at compile time. It cannot be inferred from response at runtime.

The plugin exports some newtypes which encode this information for the some of the common 2xx codes (`200 OK`, `201 Created` and `202 Accepted`) for JSON responses and `204 No Content`.

```rust
use paperclip::actix::web::Json;
use paperclip::actix::{CreatedJson, AcceptedJson, NoContent};

// 201 Created
#[api_v2_operation]
async fn adopt_pet(body: Json<Pet>) -> Result<CreatedJson<Pet>, ()> {
    let pet: Pet = body.into_inner();
    // bring the pet home
    Ok(CreatedJson(pet))
}
// 204 No Content
#[api_v2_operation]
async fn acknowledge_pet(body: Json<Pet>) -> NoContent {
    NoContent
}
```

### Manually defining error response codes

Another macro `api_v2_errors` helps to manually add error response codes.

```rust
use paperclip::actix::api_v2_errors;

#[api_v2_errors(
    code=400,
    code=401, description="Unauthorized: Can't read session from header",
    code=500,
)]
pub enum MyError {
    /* ... */
}
```

You can now use this error in handlers and they'll emit operations containing those response codes.

```rust
#[api_v2_operation]
async fn my_handler() -> Result<(), MyError> {
    /* ... */
}
```

'''
'''--- book/build-script.md ---
# Generate client code using build script

This example generates API client code code using a [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html).

- Create a new project using cargo: `cargo new my_awesome_app`

- Modify your `Cargo.toml` to look like this:

```toml
[package]
name = "my_awesome_app"
version = "0.1.0"
authors = ["Me <me@example.com>"]
edition = "2018"
build = "build.rs"

[dependencies]
# Crates required by the generated code
async-trait = "0.1"
bytes = "0.5"
thiserror = "1.0"
futures = "0.3"
http = "0.2"
lazy_static = "1.4"
log = "0.4"
mime = { git = "https://github.com/hyperium/mime" }
mime_guess = "2.0"
parking_lot = "0.11"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.8"
tokio-util = { version = "0.4", features = ["codec"] }
url = "2.1"
tokio = { version = "0.3", features = ["fs", "io-util", "macros", "rt-multi-thread"] }
reqwest = { version = "0.10", features = ["stream", "json"] }

[build-dependencies]
paperclip = { version = "0.5", features = ["v2", "codegen"] }
```

- Add `my-spec.yaml` to the project root with contents from [this file](https://raw.githubusercontent.com/wafflespeanut/paperclip/master/tests/pet-v2.yaml).

- Now, add `build.rs` to the project root with the following:

```rust
use paperclip::v2::{
    self,
    codegen::{DefaultEmitter, Emitter, EmitterState},
    models::{ResolvableApi, DefaultSchema},
};

use std::env;
use std::fs::File;

fn main() {
    let fd = File::open("my-spec.yaml").expect("schema?");
    let raw: ResolvableApi<DefaultSchema> = v2::from_reader(fd).expect("deserializing spec");
    let schema = raw.resolve().expect("resolution");

    let out_dir = env::var("OUT_DIR").unwrap();
    let mut state = EmitterState::default();
    // set prefix for using generated code inside `codegen` module (see main.rs).
    state.mod_prefix = "crate::codegen::";
    state.working_dir = out_dir.into();

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&schema).expect("codegen");
}
```

- Now, you can modify `src/main.rs` to make use of the generated code:

```rust
#[macro_use] extern crate serde;

use reqwest::Client;

mod codegen {
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/mod.rs"));
}

use self::codegen::client::Sendable;
use self::codegen::pet::Pet;

#[tokio::main]
async fn main() {
    let client = Client::new();
    let _pets = Pet::<()>::list_pets().send(&client).await.unwrap();
}
```

Some things to note:

- The names of associated functions for each [operation](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject) (such as `list_pets`) is obtained from `operationId` fields. But since it's optional and if the user has ignored it in their spec, then we use HTTP methods and number them if there are more than one.
- The emitter tries to bind each operation to some model (based on `body` parameters and `2xx` responses). If it cannot bind it, then they're ignored (at this point).

'''
'''--- book/cli.md ---
# Paperclip CLI

Install `paperclip` CLI with:

```
cargo install paperclip --features cli
```

## Generate client library from CLI

You can generate the client library for some spec using the following command:

```
wget https://raw.githubusercontent.com/wafflespeanut/paperclip/master/tests/pet-v2.yaml
paperclip --api v2 -o pet pet-v2.yaml
```

This generates the client library for that spec in `./pet` directory.

## Generate console from CLI

You can also generate a console for your API using the CLI by passing the `--cli` flag.

```
wget https://raw.githubusercontent.com/wafflespeanut/paperclip/master/tests/pet-v2.yaml
paperclip --api v2 -o pet --cli pet-v2.yaml
```

### Build and run the console

> **NOTE:** I'm using the debug build throughout this example.

```
cd pet && cargo build && ./target/debug/pet
```

    pet 0.1.0

    USAGE:
        pet [FLAGS] [OPTIONS] --url <url> <SUBCOMMAND>

    FLAGS:
        -h, --help       Prints help information
        -V, --version    Prints version information
        -v, --verbose    Enable verbose mode.

    OPTIONS:
            --ca-cert <ca-cert>            Path to CA certificate to be added to trust store.
            --client-cert <client-cert>    Path to certificate for TLS client verification.
            --client-key <client-key>      Path to private key for TLS client verification.
            --url <url>                    Base URL for your API.

    SUBCOMMANDS:
        add-pet          Add a new pet to the store
        get-pet-by-id    Find pet by ID
        help             Prints this message or the help of the given subcommand(s)
        list-pets        Fetch list of pets

Note that passing **`--url` is mandatory**. It's the base URL for your API.

> The console also supports client verification and setting root CA.

## Runtime checks

The generated console associates subcommands to operations and arguments to parameters. Similar to compile-time checks in the generated client code, the console checks subcommand arguments at runtime.

#### Parameters as arguments

Let's try to fetch a pet by its ID without passing the ID.

```
./target/debug/pet --url https://example.com/pets get-pet-by-id
```

    error: The following required arguments were not provided:
        --pet-id <pet-id>

    USAGE:
        pet get-pet-by-id --pet-id <pet-id>

    For more information try --help

... and we get an error.

Now, let's add that argument with a valid value (i.e., value that can be parsed to the expected type, which in this case, is an integer).

```
./target/debug/pet -v --url http://echo.jsontest.com get-pet-by-id get-pet-by-id --pet-id 25

GET http://echo.jsontest.com/pets/25
200 OK
{"pets": "25"}
```

Passing `-v` flag enables verbose mode which prints additional information about the request we've made. Also note that the body of the response is piped to stdout directly.

#### Request body

Finally, let's `POST` something with a body. Here, `add-pet` requires a payload, so `--payload` argument is required. This argument is special in that it could be either a path to a file or `-` (when input is obtained from stdin). Either way, the input is parsed to the actual schema before making the API call.

```
./target/debug/pet -v --url http://localhost:8000 add-pet --payload - << EOF
{"id": 25, "name": "Milo"}
EOF

POST http://localhost:8000/pets
200 OK
{"status": "ok"}
```

'''
'''--- book/compile-checks.md ---
## Compile-time checks

API calls often *require* some parameters. Should we miss those parameters when performing a request, either the client will produce a runtime error or the server will reject our request. On the other hand, paperclip's generated client code uses markers to avoid this problem at compile-time.

For example, in the [previous example](build-script.md), in order to fetch a pet, [`petId` parameter](https://github.com/wafflespeanut/paperclip/blob/fa95b023aaf8b6e396c899a93a9eda6fd791505c/openapi/tests/pet-v2.yaml#L42-L47) is required. Let's change the main function in the above example to fetch a pet without its ID.

```rust
let pet = Pet::get_pet_by_id().send(&client).await?;
```

If we try and compile the program, then we'll get the following error:

```
error[E0599]: no method named `send` found for type
`codegen::pet::PetGetBuilder1<codegen::generics::MissingPetId>`
in the current scope
```

Note that the struct `PetGetBuilder1` has been marked with `MissingPetId`. And, `send` is implemented only when the builder has `PetIdExists` marker.

Hence the fix would be to set the required parameter using the relevant method call (which transforms the builder struct).

```rust
let pet = Pet::get_pet_by_id()
    .id(25)
    .send(&client)
    .await?;
```

... and the code will compile.

The same applies to using API objects (with required fields). For example, the [`addPet` operation](https://github.com/wafflespeanut/paperclip/blob/98a2c053c283ebbbef9b17f7e0ac6ddb0e64f77f/tests/pet-v2.yaml#L125-L148) requires `Pet` object to be present in the HTTP body, but then `Pet` object itself requires [`id` and `name` fields](https://github.com/wafflespeanut/paperclip/blob/98a2c053c283ebbbef9b17f7e0ac6ddb0e64f77f/tests/pet-v2.yaml#L44-L46).

So, if we did this:

```rust
let pet = Pet::add_pet().send(&client).await?;
```

... we'd get an error during compilation:

```
no method named `send` found for type `codegen::pet::PetPostBuilder<
    codegen::generics::MissingId,
    codegen::generics::MissingName
>` in the current scope
```

As we can see, the builder struct has been marked with `MissingId` and `MissingName`, but again `send` is implemented only if the struct had `IdExists` and `NameExists` markers.

Now, we change the code to:

```rust
let pet = Pet::add_pet()
    .id(25)
    .name("Milo")
    .send(&client)
    .await?;
```

... and the code will compile.

Similarly, the types of arguments are also enforced.

'''
'''--- core/Cargo.toml ---
[package]
name = "paperclip-core"
version = "0.3.0"
authors = ["Ravi Shankar <wafflespeanut@gmail.com>"]
edition = "2018"
description = "Core types and traits for paperclip OpenAPI tooling library"
documentation = "https://paperclip.waffles.space/paperclip_core"
license = "MIT OR Apache-2.0"
homepage = "https://github.com/wafflespeanut/paperclip"
repository = "https://github.com/wafflespeanut/paperclip"

[dependencies]
actix-web2 = { version = "2", optional = true, default-features = false, package = "actix-web" }
actix-web3 = { version = "3", optional = true, default-features = false, package = "actix-web" }
actix-web4 = { version = "4.0.0-beta.6", optional = true, default-features = false, package = "actix-web" }
actix-multipart = { version = "0", optional = true }
actix-session = { version = "0", optional = true }
actix-files = {version = "0", optional = true}
chrono = { version = "0", optional = true }
heck = { version = "0.3", optional = true }
once_cell = "1.4"
log = { version = "0.4", optional = true }
mime = "0.3"
paperclip-macros = { path = "../macros", version = "0.4.0" }
parking_lot = { version = ">=0.10,<0.12", features = ["serde"] }
pin-project = { version = "1.0", optional = true }
rust_decimal = { version = "1", optional = true }
regex = "1.3"
serde = { version = "1.0", features = ["derive", "rc"] }
serde_json = "1.0"
serde_yaml = "0.8"
uuid = { version = "0", optional = true }
thiserror = "1.0"
serde_qs = { version = "0", optional = true }

[features]
# actix-web support
actix = ["actix4"]
actix2 = ["actix-base", "actix-web2"]
actix3 = ["actix-base", "actix-web3"]
actix4 = ["actix-base", "actix-web4"]
actix-base = ["v2", "pin-project"]

# Enable nightly if nightly compiler can be allowed
nightly = ["paperclip-macros/nightly"]

# OpenAPI support (v2 and codegen)
v2 = ["paperclip-macros/v2"]
codegen = ["v2", "heck", "log"]

'''
'''--- core/src/error.rs ---
#[cfg(feature = "v2")]
use crate::v2::models::{DataType, ParameterIn};
use thiserror::Error;

/// Errors related to spec validation.
#[derive(Debug, Error)]
pub enum ValidationError {
    /// Failed to resolve the schema because an invalid URI was provided for
    /// `$ref` field.
    ///
    /// Currently, we only support `#/{definitions,parameters}/Name` in `$ref` field.
    #[error("Invalid $ref URI {:?}. Only relative URIs are supported.", _0)]
    #[allow(clippy::upper_case_acronyms)]
    InvalidRefURI(String),
    /// The specified reference is missing in the spec.
    #[error("Reference missing in spec: {}", _0)]
    MissingReference(String),
    /// If a parameter specifies body, then schema must be specified.
    #[error(
        "Parameter {:?} in path {:?} is a body but the schema is missing",
        _0,
        _1
    )]
    MissingSchemaForBodyParameter(String, String),
    /// Some headers have special meaning in OpenAPI. The user cannot have these headers
    /// in their API spec.
    #[error("Path {:?} has header parameter {:?} which is not allowed", _1, _0)]
    InvalidHeader(String, String),
    #[cfg(feature = "v2")]
    /// Only arrays and primitive types are allowed in parameters.
    #[error(
        "Parameter {:?} in path {:?} has specified {:?} type, but it's invalid for {:?} parameters",
        _0,
        _1,
        _2,
        _3
    )]
    InvalidParameterType(String, String, Option<DataType>, ParameterIn),
}

'''
'''--- core/src/im.rs ---
//! Interior mutability stuff.

#[cfg(feature = "v2")]
use crate::v2::models::Resolvable;
#[cfg(feature = "v2")]
use serde::{Serialize, Serializer};

#[cfg(feature = "v2")]
impl<T> Serialize for Resolvable<T>
where
    T: Serialize,
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Resolvable::Raw(s) => s.serialize(serializer),
            Resolvable::Resolved { new, .. } => new.serialize(serializer),
        }
    }
}

'''
'''--- core/src/lib.rs ---
#![cfg_attr(feature = "nightly", feature(specialization))]
//! Core structs and traits for paperclip.

#[cfg(feature = "actix2")]
extern crate actix_web2 as actix_web;
#[cfg(feature = "actix3")]
extern crate actix_web3 as actix_web;
#[cfg(feature = "actix4")]
extern crate actix_web4 as actix_web;
#[cfg_attr(feature = "v2", macro_use)]
extern crate serde;

mod error;
pub mod im;
pub mod util;
#[cfg(feature = "v2")]
pub mod v2;

pub use self::error::ValidationError;

'''
'''--- core/src/util.rs ---
use std::{
    future::Future,
    marker::Unpin,
    pin::Pin,
    task::{Context, Poll},
};

/// Unstabilized [`Ready`](https://doc.rust-lang.org/nightly/std/future/struct.Ready.html) future.
pub struct Ready<T>(Option<T>);

impl<T> Unpin for Ready<T> {}

impl<T> Future for Ready<T> {
    type Output = T;

    #[inline]
    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<T> {
        Poll::Ready(self.0.take().expect("Ready polled after completion"))
    }
}

/// Unstabilized [`ready`](https://doc.rust-lang.org/nightly/std/future/fn.ready.html) function.
pub fn ready<T>(t: T) -> Ready<T> {
    Ready(Some(t))
}

'''
'''--- core/src/v2/actix.rs ---
#[cfg(feature = "actix-multipart")]
use super::schema::TypedData;
use super::{
    models::{
        DefaultOperationRaw, DefaultResponseRaw, DefaultSchemaRaw, Either, Items, Parameter,
        ParameterIn, Response, SecurityScheme,
    },
    schema::{Apiv2Errors, Apiv2Operation, Apiv2Schema},
};
use actix_web::{
    http::StatusCode,
    web::{Bytes, Data, Form, Json, Path, Payload, Query, ReqData},
    HttpRequest, HttpResponse, Responder,
};
use pin_project::pin_project;

use serde::Serialize;
#[cfg(feature = "serde_qs")]
use serde_qs::actix::QsQuery;

use std::{
    collections::BTreeMap,
    fmt,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

/// Actix-specific trait for indicating that this entity can modify an operation
/// and/or update the global map of definitions.
pub trait OperationModifier: Apiv2Schema + Sized {
    /// Update the parameters list in the given operation (if needed).
    fn update_parameter(_op: &mut DefaultOperationRaw) {}

    /// Update the responses map in the given operation (if needed).
    fn update_response(_op: &mut DefaultOperationRaw) {}

    /// Update the definitions map (if needed).
    fn update_definitions(map: &mut BTreeMap<String, DefaultSchemaRaw>) {
        update_definitions_from_schema_type::<Self>(map);
    }

    /// Update the security map in the given operation (if needed).
    fn update_security(op: &mut DefaultOperationRaw) {
        update_security::<Self>(op);
    }

    /// Update the security definition map (if needed).
    fn update_security_definitions(map: &mut BTreeMap<String, SecurityScheme>) {
        update_security_definitions::<Self>(map);
    }
}

/// All schema types default to updating the definitions map.
#[cfg(feature = "nightly")]
impl<T> OperationModifier for T
where
    T: Apiv2Schema,
{
    default fn update_parameter(_op: &mut DefaultOperationRaw) {}

    default fn update_response(_op: &mut DefaultOperationRaw) {}

    default fn update_definitions(map: &mut BTreeMap<String, DefaultSchemaRaw>) {
        update_definitions_from_schema_type::<Self>(map);
    }

    default fn update_security(op: &mut DefaultOperationRaw) {
        update_security::<Self>(op);
    }

    default fn update_security_definitions(map: &mut BTreeMap<String, SecurityScheme>) {
        update_security_definitions::<Self>(map);
    }
}

impl<T> OperationModifier for Option<T>
where
    T: OperationModifier,
{
    fn update_parameter(op: &mut DefaultOperationRaw) {
        T::update_parameter(op);
    }

    fn update_response(op: &mut DefaultOperationRaw) {
        T::update_response(op);
    }

    fn update_definitions(map: &mut BTreeMap<String, DefaultSchemaRaw>) {
        T::update_definitions(map);
    }

    fn update_security(op: &mut DefaultOperationRaw) {
        T::update_security(op);
    }

    fn update_security_definitions(map: &mut BTreeMap<String, SecurityScheme>) {
        T::update_security_definitions(map);
    }
}

#[cfg(feature = "nightly")]
impl<T, E> OperationModifier for Result<T, E>
where
    T: OperationModifier,
{
    default fn update_parameter(op: &mut DefaultOperationRaw) {
        T::update_parameter(op);
    }

    default fn update_response(op: &mut DefaultOperationRaw) {
        T::update_response(op);
    }

    default fn update_definitions(map: &mut BTreeMap<String, DefaultSchemaRaw>) {
        T::update_definitions(map);
    }

    default fn update_security_definitions(map: &mut BTreeMap<String, SecurityScheme>) {
        T::update_security_definitions(map);
    }
}

impl<T, E> OperationModifier for Result<T, E>
where
    T: OperationModifier,
    E: Apiv2Errors,
{
    fn update_parameter(op: &mut DefaultOperationRaw) {
        T::update_parameter(op);
    }

    fn update_response(op: &mut DefaultOperationRaw) {
        T::update_response(op);
        update_error_definitions_from_schema_type::<E>(op);
    }

    fn update_definitions(map: &mut BTreeMap<String, DefaultSchemaRaw>) {
        T::update_definitions(map);
    }

    fn update_security_definitions(map: &mut BTreeMap<String, SecurityScheme>) {
        T::update_security_definitions(map);
    }
}

// We don't know what we should do with these abstractions
// as they could be anything.
impl<T> Apiv2Schema for Data<T> {}
#[cfg(not(feature = "nightly"))]
impl<T> OperationModifier for Data<T> {}
impl<T: std::clone::Clone> Apiv2Schema for ReqData<T> {}
#[cfg(not(feature = "nightly"))]
impl<T: std::clone::Clone> OperationModifier for ReqData<T> {}

macro_rules! impl_empty({ $($ty:ty),+ } => {
    $(
        impl Apiv2Schema for $ty {}
        #[cfg(not(feature = "nightly"))]
        impl OperationModifier for $ty {}
    )+
});

impl Apiv2Operation for HttpResponse {
    fn operation() -> DefaultOperationRaw {
        Default::default()
    }

    fn security_definitions() -> BTreeMap<String, SecurityScheme> {
        Default::default()
    }

    fn definitions() -> BTreeMap<String, DefaultSchemaRaw> {
        Default::default()
    }
}

impl_empty!(HttpRequest, HttpResponse, Bytes, Payload);

#[cfg(not(feature = "nightly"))]
mod manual_impl {
    use super::OperationModifier;

    impl<'a> OperationModifier for &'a str {}
    impl<'a, T: OperationModifier> OperationModifier for &'a [T] {}

    macro_rules! impl_simple({ $ty:ty } => {
        impl OperationModifier for $ty {}
    });

    impl_simple!(char);
    impl_simple!(String);
    impl_simple!(bool);
    impl_simple!(f32);
    impl_simple!(f64);
    impl_simple!(i8);
    impl_simple!(i16);
    impl_simple!(i32);
    impl_simple!(u8);
    impl_simple!(u16);
    impl_simple!(u32);
    impl_simple!(i64);
    impl_simple!(i128);
    impl_simple!(isize);
    impl_simple!(u64);
    impl_simple!(u128);
    impl_simple!(usize);
    #[cfg(feature = "chrono")]
    impl_simple!(chrono::NaiveDateTime);
    #[cfg(feature = "rust_decimal")]
    impl_simple!(rust_decimal::Decimal);
    #[cfg(feature = "uuid")]
    impl_simple!(uuid::Uuid);
}

#[cfg(feature = "chrono")]
impl<T: chrono::TimeZone> OperationModifier for chrono::DateTime<T> {}

// Other extractors

#[cfg(feature = "nightly")]
impl<T> Apiv2Schema for Json<T> {
    default const NAME: Option<&'static str> = None;

    default fn raw_schema() -> DefaultSchemaRaw {
        Default::default()
    }
}

/// JSON needs specialization because it updates the global definitions.
impl<T: Apiv2Schema> Apiv2Schema for Json<T> {
    const NAME: Option<&'static str> = T::NAME;

    fn raw_schema() -> DefaultSchemaRaw {
        T::raw_schema()
    }
}

impl<T> OperationModifier for Json<T>
where
    T: Apiv2Schema,
{
    fn update_parameter(op: &mut DefaultOperationRaw) {
        op.parameters.push(Either::Right(Parameter {
            description: None,
            in_: ParameterIn::Body,
            name: "body".into(),
            required: true,
            schema: Some({
                let mut def = T::schema_with_ref();
                def.retain_ref();
                def
            }),
            ..Default::default()
        }));
    }

    fn update_response(op: &mut DefaultOperationRaw) {
        op.responses.insert(
            "200".into(),
            Either::Right(Response {
                // TODO: Support configuring other 2xx codes using macro attribute.
                description: Some("OK".into()),
                schema: Some({
                    let mut def = T::schema_with_ref();
                    def.retain_ref();
                    def
                }),
                ..Default::default()
            }),
        );
    }
}

#[cfg(feature = "actix-multipart")]
impl OperationModifier for actix_multipart::Multipart {
    fn update_parameter(op: &mut DefaultOperationRaw) {
        op.parameters.push(Either::Right(Parameter {
            description: None,
            in_: ParameterIn::FormData,
            name: "file_data".into(),
            required: true,
            data_type: Some(<actix_multipart::Multipart as TypedData>::data_type()),
            format: <actix_multipart::Multipart as TypedData>::format(),
            ..Default::default()
        }));
    }
}

#[cfg(feature = "actix-session")]
impl OperationModifier for actix_session::Session {
    fn update_definitions(_map: &mut BTreeMap<String, DefaultSchemaRaw>) {}
}

#[cfg(feature = "actix-files")]
impl OperationModifier for actix_files::NamedFile {
    fn update_definitions(_map: &mut BTreeMap<String, DefaultSchemaRaw>) {}
}

macro_rules! impl_param_extractor ({ $ty:ty => $container:ident } => {
    #[cfg(feature = "nightly")]
    impl<T> Apiv2Schema for $ty {
        default const NAME: Option<&'static str> = None;

        default fn raw_schema() -> DefaultSchemaRaw {
            Default::default()
        }
    }

    #[cfg(not(feature = "nightly"))]
    impl<T: Apiv2Schema> Apiv2Schema for $ty {}

    impl<T: Apiv2Schema> OperationModifier for $ty {
        fn update_parameter(op: &mut DefaultOperationRaw) {
            let def = T::raw_schema();
            // If there aren't any properties and if it's a path parameter,
            // then add a parameter whose name will be overridden later.
            if def.properties.is_empty() && ParameterIn::$container == ParameterIn::Path {
                op.parameters.push(Either::Right(Parameter {
                    name: String::new(),
                    in_: ParameterIn::Path,
                    required: true,
                    data_type: def.data_type,
                    format: def.format,
                    enum_: def.enum_,
                    description: def.description,
                    ..Default::default()
                }));
            }
            for (k, v) in def.properties {
                op.parameters.push(Either::Right(Parameter {
                    in_: ParameterIn::$container,
                    required: def.required.contains(&k),
                    data_type: v.data_type,
                    format: v.format,
                    enum_: v.enum_,
                    description: v.description,
                    collection_format: None, // this defaults to csv
                    items: v.items.as_deref().map(map_schema_to_items),
                    name: k,
                    ..Default::default()
                }));
            }
        }

        // These don't require updating definitions, as we use them only
        // to get their properties.
        fn update_definitions(_map: &mut BTreeMap<String, DefaultSchemaRaw>) {}
    }
});

fn map_schema_to_items(schema: &DefaultSchemaRaw) -> Items {
    Items {
        data_type: schema.data_type,
        format: schema.format.clone(),
        collection_format: None, // this defaults to csv
        enum_: schema.enum_.clone(),
        items: schema
            .items
            .as_deref()
            .map(|schema| Box::new(map_schema_to_items(schema))),
        ..Default::default() // range fields are not emitted
    }
}

/// `formData` can refer to the global definitions.
#[cfg(feature = "nightly")]
impl<T: Apiv2Schema> Apiv2Schema for Form<T> {
    const NAME: Option<&'static str> = T::NAME;

    fn raw_schema() -> DefaultSchemaRaw {
        T::raw_schema()
    }
}

impl_param_extractor!(Path<T> => Path);
impl_param_extractor!(Query<T> => Query);
impl_param_extractor!(Form<T> => FormData);
#[cfg(feature = "serde_qs")]
impl_param_extractor!(QsQuery<T> => Query);

macro_rules! impl_path_tuple ({ $($ty:ident),+ } => {
    #[cfg(feature = "nightly")]
    impl<$($ty,)+> Apiv2Schema for Path<($($ty,)+)> {}

    #[cfg(not(feature = "nightly"))]
    impl<$($ty: Apiv2Schema,)+> Apiv2Schema for Path<($($ty,)+)> {}

    impl<$($ty,)+> OperationModifier for Path<($($ty,)+)>
        where $($ty: Apiv2Schema,)+
    {
        fn update_parameter(op: &mut DefaultOperationRaw) {
            $(
                let def = $ty::raw_schema();
                if def.properties.is_empty() {
                    op.parameters.push(Either::Right(Parameter {
                        // NOTE: We're setting empty name, because we don't know
                        // the name in this context. We'll get it when we add services.
                        name: String::new(),
                        in_: ParameterIn::Path,
                        required: true,
                        data_type: def.data_type,
                        format: def.format,
                        enum_: def.enum_,
                        description: def.description,
                        ..Default::default()
                    }));
                }
                for (k, v) in def.properties {
                    op.parameters.push(Either::Right(Parameter {
                        in_: ParameterIn::Path,
                        required: def.required.contains(&k),
                        data_type: v.data_type,
                        format: v.format,
                        enum_: v.enum_,
                        description: v.description,
                        collection_format: None, // this defaults to csv
                        items: v.items.as_deref().map(map_schema_to_items),
                        name: k,
                        ..Default::default()
                    }));
                }
            )+
        }
    }
});

impl_path_tuple!(A);
impl_path_tuple!(A, B);
impl_path_tuple!(A, B, C);
impl_path_tuple!(A, B, C, D);
impl_path_tuple!(A, B, C, D, E);

/// Wrapper for wrapping over `impl Responder` thingies (to avoid breakage).
pub struct ResponderWrapper<T>(pub T);

#[cfg(feature = "nightly")]
impl<T: Responder> Apiv2Schema for ResponderWrapper<T> {
    default const NAME: Option<&'static str> = None;

    default fn raw_schema() -> DefaultSchemaRaw {
        DefaultSchemaRaw::default()
    }
}

#[cfg(not(feature = "nightly"))]
impl<T: Responder> Apiv2Schema for ResponderWrapper<T> {}

#[cfg(not(feature = "nightly"))]
impl<T: Responder> OperationModifier for ResponderWrapper<T> {}

impl<T: Responder> Responder for ResponderWrapper<T> {
    #[inline]
    fn respond_to(self, req: &HttpRequest) -> HttpResponse {
        self.0.respond_to(req)
    }
}

/// Wrapper for all response types from handlers. This holds the actual value
/// returned by the handler and a unit struct (autogenerated by the plugin) which
/// is used for generating operation information.
#[pin_project]
pub struct ResponseWrapper<T, H>(#[pin] pub T, pub H);

impl<T: Responder, H> Responder for ResponseWrapper<T, H> {
    #[inline]
    fn respond_to(self, req: &HttpRequest) -> HttpResponse {
        self.0.respond_to(req)
    }
}

impl<F, T, H> Future for ResponseWrapper<F, H>
where
    F: Future<Output = T>,
    T: OperationModifier + Responder,
    H: Apiv2Operation,
{
    type Output = T;

    #[inline]
    fn poll(mut self: Pin<&mut Self>, ctx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.as_mut().project();
        this.0.poll(ctx)
    }
}

impl<F, T, H> Apiv2Operation for ResponseWrapper<F, H>
where
    F: Future<Output = T>,
    T: OperationModifier + Responder,
    H: Apiv2Operation,
{
    fn operation() -> DefaultOperationRaw {
        H::operation()
    }

    fn security_definitions() -> BTreeMap<String, SecurityScheme> {
        H::security_definitions()
    }

    fn definitions() -> BTreeMap<String, DefaultSchemaRaw> {
        H::definitions()
    }
}

/// Given the schema type, recursively update the map of definitions.
fn update_definitions_from_schema_type<T>(map: &mut BTreeMap<String, DefaultSchemaRaw>)
where
    T: Apiv2Schema,
{
    let mut schema = T::schema_with_ref();
    loop {
        if let Some(s) = schema.items {
            schema = *s;
            continue;
        } else if let Some(Either::Right(s)) = schema.extra_props {
            schema = *s;
            continue;
        } else if let Some(n) = schema.name.take() {
            schema.remove_refs();
            map.insert(n, schema);
        }

        break;
    }
}

/// Given a schema type that represents an error, add the responses
/// representing those errors.
fn update_error_definitions_from_schema_type<T>(op: &mut DefaultOperationRaw)
where
    T: Apiv2Errors,
{
    for (status, def_name) in T::ERROR_MAP {
        let response = DefaultResponseRaw {
            description: Some((*def_name).to_string()),
            ..Default::default()
        };
        op.responses
            .insert(status.to_string(), Either::Right(response));
    }
}

/// Add security requirements to operation.
fn update_security<T>(op: &mut DefaultOperationRaw)
where
    T: Apiv2Schema,
{
    if let (Some(name), Some(scheme)) = (T::NAME, T::security_scheme()) {
        let mut security_map = BTreeMap::new();
        let scopes = scheme.scopes.keys().map(String::clone).collect();
        security_map.insert(name.into(), scopes);
        op.security.push(security_map);
    }
}

/// Merge security scheme into existing security definitions or add new.
fn update_security_definitions<T>(map: &mut BTreeMap<String, SecurityScheme>)
where
    T: Apiv2Schema,
{
    if let (Some(name), Some(new)) = (T::NAME, T::security_scheme()) {
        new.update_definitions(name, map);
    }
}

macro_rules! json_with_status {
    ($name:ident => $status:expr) => {
        pub struct $name<T: Serialize + Apiv2Schema>(pub T);

        impl<T> fmt::Debug for $name<T>
        where
            T: fmt::Debug + Serialize + Apiv2Schema,
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let status: StatusCode = $status;
                let status_str = status.canonical_reason().unwrap_or(status.as_str());
                write!(f, "{} Json: {:?}", status_str, self.0)
            }
        }

        impl<T> fmt::Display for $name<T>
        where
            T: fmt::Display + Serialize + Apiv2Schema,
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                fmt::Display::fmt(&self.0, f)
            }
        }

        impl<T> Responder for $name<T>
        where
            T: Serialize + Apiv2Schema,
        {
            fn respond_to(self, _: &HttpRequest) -> HttpResponse {
                let status: StatusCode = $status;

                HttpResponse::build(status)
                    .content_type("application/json")
                    .json(self.0)
            }
        }

        impl<T> Apiv2Schema for $name<T>
        where
            T: Serialize + Apiv2Schema,
        {
            const NAME: Option<&'static str> = T::NAME;

            fn raw_schema() -> DefaultSchemaRaw {
                T::raw_schema()
            }
        }

        impl<T> OperationModifier for $name<T>
        where
            T: Serialize + Apiv2Schema,
        {
            fn update_response(op: &mut DefaultOperationRaw) {
                let status: StatusCode = $status;
                op.responses.insert(
                    status.as_str().into(),
                    Either::Right(Response {
                        description: status.canonical_reason().map(ToString::to_string),
                        schema: Some({
                            let mut def = T::schema_with_ref();
                            def.retain_ref();
                            def
                        }),
                        ..Default::default()
                    }),
                );
            }
        }
    };
}

json_with_status!(CreatedJson => StatusCode::CREATED);
json_with_status!(AcceptedJson => StatusCode::ACCEPTED);

#[derive(Debug)]
pub struct NoContent;

impl fmt::Display for NoContent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("No Content")
    }
}

impl Responder for NoContent {
    fn respond_to(self, _: &HttpRequest) -> HttpResponse {
        HttpResponse::build(StatusCode::NO_CONTENT)
            .content_type("application/json")
            .finish()
    }
}

impl Apiv2Schema for NoContent {}

impl OperationModifier for NoContent {
    fn update_response(op: &mut DefaultOperationRaw) {
        let status = StatusCode::NO_CONTENT;
        op.responses.insert(
            status.as_str().into(),
            Either::Right(Response {
                description: status.canonical_reason().map(ToString::to_string),
                schema: None,
                ..Default::default()
            }),
        );
    }
}

'''
'''--- core/src/v2/extensions.rs ---
use serde::{Deserialize, Deserializer, Serialize, Serializer};

use once_cell::sync::Lazy;
use std::{
    cmp::Ordering,
    collections::BTreeMap,
    fmt,
    ops::{Deref, DerefMut},
    sync::Arc,
};

/// Media range for JSON.
pub static JSON_MIME: Lazy<MediaRange> =
    Lazy::new(|| MediaRange("application/json".parse().expect("parsing mime")));
/// Default coder for JSON.
pub static JSON_CODER: Lazy<Arc<Coder>> = Lazy::new(|| {
    Arc::new(Coder {
        encoder_path: "serde_json::to_writer".into(),
        decoder_path: "serde_json::from_reader".into(),
        any_value: "serde_json::Value".into(),
        error_path: "serde_json::Error".into(),
        prefer: false,
        builtin: true,
    })
});
/// Media range for YAML.
pub static YAML_MIME: Lazy<MediaRange> =
    Lazy::new(|| MediaRange("application/yaml".parse().expect("parsing mime")));
/// Default coder for YAML.
pub static YAML_CODER: Lazy<Arc<Coder>> = Lazy::new(|| {
    Arc::new(Coder {
        encoder_path: "serde_yaml::to_writer".into(),
        decoder_path: "serde_yaml::from_reader".into(),
        any_value: "serde_yaml::Value".into(),
        error_path: "serde_yaml::Error".into(),
        prefer: false,
        builtin: true,
    })
});

/// Wrapper for `mime::MediaRange` to support `BTree{Set, Map}`.
#[derive(Debug, Clone)]
pub struct MediaRange(pub mime::Mime);

#[cfg(feature = "codegen")]
impl MediaRange {
    /// Implementation from https://github.com/hyperium/mime/blob/65ea9c3d0cad4cb548b41124050c545120134035/src/range.rs#L155
    fn matches_params(&self, r: &Self) -> bool {
        for (name, value) in self.0.params() {
            if name != "q" && r.0.get_param(name) != Some(value) {
                return false;
            }
        }

        true
    }
}

/// `x-rust-coders` global extension for custom encoders and decoders.
#[derive(Debug, Default, Clone)]
pub struct Coders(BTreeMap<MediaRange, Arc<Coder>>);

#[cfg(feature = "codegen")]
impl Coders {
    /// Returns the matching coder for the given media range (if any).
    ///
    /// Matching algorithm from https://github.com/hyperium/mime/blob/65ea9c3d0cad4cb548b41124050c545120134035/src/range.rs#L126
    pub fn matching_coder(&self, ty: &MediaRange) -> Option<Arc<Coder>> {
        self.0
            .get(ty)
            .or_else(|| {
                let (target_t1, target_t2) = (ty.0.type_(), ty.0.subtype());
                for (r, c) in &self.0 {
                    let (source_t1, source_t2) = (r.0.type_(), r.0.subtype());
                    if target_t1 == mime::STAR && r.matches_params(ty) {
                        return Some(c);
                    }

                    if source_t1 != target_t1 {
                        continue;
                    }

                    if target_t2 == mime::STAR && r.matches_params(ty) {
                        return Some(c);
                    }

                    if source_t2 != target_t2 {
                        continue;
                    }

                    return Some(c);
                }

                None
            })
            .map(Clone::clone)
    }
}

/// Represents the en/decoder for some MIME media range.
#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct Coder {
    /// Path to the encoding function.
    pub encoder_path: String,
    /// Path to the decoding function.
    pub decoder_path: String,
    /// Path to the error type.
    pub error_path: String,
    /// Path to the struct/enum that represents `Any` (such as `serde_json::Value`).
    pub any_value: String,
    /// Whether this media type should be preferred when multiple
    /// types are available. When multiple types are preferred,
    /// it's unspecified as to which is chosen.
    #[serde(default)]
    pub prefer: bool,
    /// Whether this en/decoder is built-in.
    #[serde(skip)]
    pub builtin: bool,
}

/* Common trait impls */

impl PartialEq for MediaRange {
    fn eq(&self, other: &MediaRange) -> bool {
        self.0.eq(&other.0)
    }
}

impl Eq for MediaRange {}

impl PartialOrd for MediaRange {
    fn partial_cmp(&self, other: &MediaRange) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for MediaRange {
    fn cmp(&self, other: &MediaRange) -> Ordering {
        self.0.as_ref().cmp(other.0.as_ref())
    }
}

impl Serialize for MediaRange {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.0.as_ref())
    }
}

impl<'de> Deserialize<'de> for MediaRange {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct Visitor;

        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MediaRange;

            fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("a valid media range")
            }

            fn visit_str<E>(self, value: &str) -> Result<MediaRange, E>
            where
                E: serde::de::Error,
            {
                value.parse().map_err(E::custom).map(MediaRange)
            }
        }

        deserializer.deserialize_str(Visitor)
    }
}

impl Deref for Coders {
    type Target = BTreeMap<MediaRange, Arc<Coder>>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Coders {
    fn deref_mut(&mut self) -> &mut <Self as Deref>::Target {
        &mut self.0
    }
}

impl Serialize for Coders {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for Coders {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(Coders(BTreeMap::deserialize(deserializer)?))
    }
}

'''
'''--- core/src/v2/mod.rs ---
//! Core types and traits associated with the
//! [OpenAPI v2 specification](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md).

#[cfg(feature = "actix-base")]
mod actix;
mod extensions;
pub mod models;
#[cfg(feature = "codegen")]
mod resolver;
pub mod schema;

#[cfg(feature = "actix-base")]
pub use self::actix::{
    AcceptedJson, CreatedJson, NoContent, OperationModifier, ResponderWrapper, ResponseWrapper,
};

pub use self::{
    models::{DefaultSchema, ResolvableApi},
    schema::Schema,
};
pub use paperclip_macros::*;

#[cfg(feature = "codegen")]
use self::resolver::Resolver;
#[cfg(feature = "codegen")]
use crate::error::ValidationError;

#[cfg(feature = "codegen")]
impl<S: Schema + Default> ResolvableApi<S> {
    /// Consumes this API schema, resolves the references and returns
    /// the resolved schema.
    ///
    /// This walks recursively, collects the referenced schema objects,
    /// substitutes the referenced IDs with the pointer to schema objects
    /// and returns the resolved object or an error if it encountered one.
    pub fn resolve(self) -> Result<ResolvableApi<S>, ValidationError> {
        let mut resolver = Resolver::from((
            self.definitions,
            self.paths,
            self.parameters,
            self.responses,
        ));
        resolver.resolve()?;
        Ok(ResolvableApi {
            swagger: self.swagger,
            info: self.info,
            definitions: resolver.defs,
            paths: resolver.paths,
            base_path: self.base_path,
            host: self.host,
            schemes: self.schemes,
            consumes: self.consumes,
            produces: self.produces,
            coders: self.coders,
            support_crates: self.support_crates,
            parameters: resolver.params,
            responses: resolver.resp,
            spec_format: self.spec_format,
            external_docs: self.external_docs,
            security: self.security,
            security_definitions: self.security_definitions,
            tags: self.tags,
        })
    }
}

'''
'''--- core/src/v2/models.rs ---
//! Models used by OpenAPI v2.

pub use super::extensions::{
    Coder, Coders, MediaRange, JSON_CODER, JSON_MIME, YAML_CODER, YAML_MIME,
};

use super::schema::Schema;
use crate::error::ValidationError;
use once_cell::sync::Lazy;
use paperclip_macros::api_v2_schema_struct;
use regex::{Captures, Regex};

#[cfg(feature = "actix-base")]
use actix_web::http::Method;

use parking_lot::RwLock;
use std::{
    borrow::Cow,
    collections::{BTreeMap, BTreeSet},
    fmt::{self, Display},
    ops::{Deref, DerefMut},
    sync::Arc,
};

/// Regex that can be used for fetching templated path parameters.
static PATH_TEMPLATE_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"\{(.*?)\}").expect("path template regex"));

// Headers that have special meaning in OpenAPI. These cannot be used in header parameter.
// Ensure that they're all lowercase for case insensitive check.
const SPECIAL_HEADERS: &[&str] = &["content-type", "accept", "authorization"];

/// OpenAPI version.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub enum Version {
    #[serde(rename = "2.0")]
    V2,
}

/// Supported data types.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DataType {
    Integer,
    Number,
    String,
    Boolean,
    Array,
    Object,
    File,
}

impl DataType {
    /// Checks if this is a primitive type.
    #[inline]
    pub fn is_primitive(self) -> bool {
        std::matches!(
            self,
            DataType::Integer | DataType::Number | DataType::String | DataType::Boolean
        )
    }
}

/// Supported data type formats.
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DataTypeFormat {
    Int32,
    Int64,
    Float,
    Double,
    Byte,
    Binary,
    Date,
    #[serde(rename = "date-time")]
    DateTime,
    Password,
    Uuid,
    #[serde(other)]
    Other,
}

/// OpenAPI v2 spec which can be traversed and resolved for codegen.
pub type ResolvableApi<S> = Api<ResolvableParameter<S>, ResolvableResponse<S>, Resolvable<S>>;

/// OpenAPI v2 spec with defaults.
pub type DefaultApiRaw = Api<DefaultParameterRaw, DefaultResponseRaw, DefaultSchemaRaw>;

/// OpenAPI v2 (swagger) spec generic over parameter and schema.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Api<P, R, S> {
    pub swagger: Version,
    #[serde(default = "BTreeMap::new")]
    pub definitions: BTreeMap<String, S>,
    pub paths: BTreeMap<String, PathItem<P, R>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(rename = "basePath", skip_serializing_if = "Option::is_none")]
    pub base_path: Option<String>,
    #[serde(default, skip_serializing_if = "BTreeSet::is_empty")]
    pub consumes: BTreeSet<MediaRange>,
    #[serde(default, skip_serializing_if = "BTreeSet::is_empty")]
    pub produces: BTreeSet<MediaRange>,
    #[serde(default, skip_serializing_if = "BTreeSet::is_empty")]
    pub schemes: BTreeSet<OperationProtocol>,
    #[serde(default = "BTreeMap::new", skip_serializing_if = "BTreeMap::is_empty")]
    pub parameters: BTreeMap<String, P>,
    #[serde(default = "BTreeMap::new", skip_serializing_if = "BTreeMap::is_empty")]
    pub responses: BTreeMap<String, R>,
    #[serde(
        default,
        rename = "securityDefinitions",
        skip_serializing_if = "BTreeMap::is_empty"
    )]
    pub security_definitions: BTreeMap<String, SecurityScheme>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub security: Vec<BTreeMap<String, BTreeSet<String>>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<Tag>,
    #[serde(rename = "externalDocs", skip_serializing_if = "Option::is_none")]
    pub external_docs: Option<ExternalDocs>,
    /// Extension for custom coders to be used for decoding API objects.
    ///
    /// An example for JSON would be:
    /// ```yaml
    /// x-rust-coders:
    ///   application/json:
    ///     encoder_path: serde_json::to_writer
    ///     decoder_path: serde_json::from_reader
    ///     any_value: serde_json::Value
    ///     error_path: serde_json::Error
    /// ```
    /// **NOTE:** JSON and YAML encodings are already supported.
    #[serde(
        default,
        rename = "x-rust-coders",
        skip_serializing_if = "<Coders as Deref>::Target::is_empty"
    )]
    pub coders: Coders,
    /// Additional crates that need to be added to the manifest.
    ///
    /// The key is the LHS of a dependency, which is the crate name.
    /// The value is the RHS of a crate's requirements as it would appear
    /// in the manifest. Note that the caller must add proper escaping
    /// wherever required.
    ///
    /// For example, the following are all valid:
    /// - `my_crate: "0.7"`
    /// - `my_crate: "{ git = \"git://foo.bar/repo\" }"`
    /// - `my_crate: "{ version = \"0.9\", features = [\"booya\"] }"`
    #[serde(
        default,
        rename = "x-rust-dependencies",
        skip_serializing_if = "BTreeMap::is_empty"
    )]
    pub support_crates: BTreeMap<String, String>,
    /// This field is set manually, because we don't know the format in which
    /// the spec was provided and we need to use this as the fallback encoding.
    #[serde(skip)]
    pub spec_format: SpecFormat,
    pub info: Info,
}

/// The format used by spec (JSON/YAML).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SpecFormat {
    Json,
    Yaml,
}

impl SpecFormat {
    /// The en/decoder used for this format.
    pub fn coder(self) -> Arc<Coder> {
        match self {
            SpecFormat::Json => JSON_CODER.clone(),
            SpecFormat::Yaml => YAML_CODER.clone(),
        }
    }

    /// The mime for this format.
    pub fn mime(self) -> &'static MediaRange {
        match self {
            SpecFormat::Json => &*JSON_MIME,
            SpecFormat::Yaml => &*YAML_MIME,
        }
    }
}

impl<P, R, S> Api<P, R, S> {
    /// Gets the parameters from the given path template and calls
    /// the given function with the parameter names.
    pub fn path_parameters_map(
        path: &str,
        mut f: impl FnMut(&str) -> Cow<'static, str>,
    ) -> Cow<'_, str> {
        PATH_TEMPLATE_REGEX.replace_all(path, |c: &Captures| f(&c[1]))
    }
}

use crate as paperclip; // hack for proc macro

/// Default schema if your schema doesn't have any custom fields.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject
#[api_v2_schema_struct]
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DefaultSchema;

/// Info object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#infoObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Info {
    pub version: String,
    pub title: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact: Option<Contact>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license: Option<License>,
}

/// Contact object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#contactObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Contact {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
}

/// License object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#licenseObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct License {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// Security Scheme object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#security-scheme-object
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct SecurityScheme {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type")]
    pub type_: String,
    #[serde(rename = "in", skip_serializing_if = "Option::is_none")]
    pub in_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flow: Option<String>,
    #[serde(rename = "authorizationUrl", skip_serializing_if = "Option::is_none")]
    pub auth_url: Option<String>,
    #[serde(rename = "tokenUrl", skip_serializing_if = "Option::is_none")]
    pub token_url: Option<String>,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub scopes: BTreeMap<String, String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl SecurityScheme {
    /// Adds or updates this definition to the map of security definitions.
    pub fn update_definitions(mut self, name: &str, map: &mut BTreeMap<String, SecurityScheme>) {
        if let Some(existing) = map.get_mut(name) {
            existing.name = existing.name.take().or(self.name);
            if !self.type_.is_empty() {
                existing.type_ = self.type_;
            }
            existing.in_ = existing.in_.take().or(self.in_);
            existing.flow = existing.flow.take().or(self.flow);
            existing.auth_url = existing.auth_url.take().or(self.auth_url);
            existing.token_url = existing.token_url.take().or(self.token_url);
            existing.scopes.append(&mut self.scopes);
            existing.description = existing.description.take().or(self.description);
            return;
        }

        map.insert(name.into(), self);
    }

    /// Appends one map to the other whilst merging individual scheme properties.
    pub fn append_map(
        old: BTreeMap<String, SecurityScheme>,
        new: &mut BTreeMap<String, SecurityScheme>,
    ) {
        for (name, def) in old {
            def.update_definitions(&name, new);
        }
    }
}

/// Tag object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#tag-object
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Tag {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "externalDocs")]
    pub external_docs: Option<ExternalDocs>,
}

/// External Documentation object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#external-documentation-object
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ExternalDocs {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub url: String,
}

/// Path item that can be traversed and resolved for codegen.
pub type ResolvablePathItem<S> = PathItem<ResolvableParameter<S>, ResolvableResponse<S>>;

/// Path item with default parameter and response.
pub type DefaultPathItemRaw = PathItem<DefaultParameterRaw, DefaultResponseRaw>;

/// Path item object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#pathItemObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct PathItem<P, R> {
    #[serde(flatten, default = "BTreeMap::default")]
    pub methods: BTreeMap<HttpMethod, Operation<P, R>>,
    #[serde(default = "Vec::default", skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<Either<Reference, P>>,
}

impl<S> PathItem<Parameter<S>, Response<S>> {
    /// Normalizes this operation map.
    /// - Collects and removes parameters shared across operations
    /// and adds them to the list global to this map.
    pub fn normalize(&mut self) {
        // We're using `Option<BTreeSet>` over `BTreeSet` because we need to
        // differentiate between the first operation that we use for initial
        // value of the set and  an operation that doesn't have any parameters.
        let mut shared_params = None;
        for op in self.methods.values() {
            let params = op
                .parameters
                .iter()
                .map(|p| p.name.clone())
                .collect::<BTreeSet<_>>();
            if let Some(p) = shared_params.take() {
                shared_params = Some(&p & &params); // set intersection
            } else {
                shared_params = Some(params);
            }
        }

        let shared_params = match shared_params {
            Some(p) => p,
            None => return,
        };

        // FIXME: A parameter defined at path level could be overridden at
        // the operation level with a different type. We shouldn't remove such
        // path-level parameters.
        for name in &shared_params {
            for op in self.methods.values_mut() {
                let idx = op
                    .parameters
                    .iter()
                    .position(|p| p.name == name.as_str())
                    .expect("collected parameter missing?");
                let p = op.parameters.swap_remove(idx);
                if self
                    .parameters
                    .iter()
                    .find(|p| p.name == name.as_str())
                    .is_none()
                {
                    self.parameters.push(p);
                }
            }
        }
    }
}

/// Parameter that can be traversed and resolved for codegen.
pub type ResolvableParameter<S> = Arc<RwLock<Parameter<Resolvable<S>>>>;

/// Parameter with the default raw schema.
pub type DefaultParameterRaw = Parameter<DefaultSchemaRaw>;

/// Request parameter object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameterObject
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Parameter<S> {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "in")]
    pub in_: ParameterIn,
    pub name: String,
    #[serde(default, skip_serializing_if = "is_false")]
    pub required: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<S>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<DataType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DataTypeFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Items>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_format: Option<CollectionFormat>,
    #[serde(default, skip_serializing_if = "is_false")]
    pub allow_empty_value: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f32>,
    #[serde(rename = "exclusiveMaximum", skip_serializing_if = "Option::is_none")]
    pub exclusive_maximum: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f32>,
    #[serde(rename = "exclusiveMinimum", skip_serializing_if = "Option::is_none")]
    pub exclusive_minimum: Option<bool>,
    #[serde(rename = "maxLength", skip_serializing_if = "Option::is_none")]
    pub max_length: Option<u32>,
    #[serde(rename = "minLength", skip_serializing_if = "Option::is_none")]
    pub min_length: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(rename = "maxItems", skip_serializing_if = "Option::is_none")]
    pub max_items: Option<u32>,
    #[serde(rename = "minItems", skip_serializing_if = "Option::is_none")]
    pub min_items: Option<u32>,
    #[serde(default, rename = "uniqueItems", skip_serializing_if = "is_false")]
    pub unique_items: bool,
    #[serde(rename = "multipleOf", skip_serializing_if = "Option::is_none")]
    pub multiple_of: Option<f32>,
    #[serde(default, rename = "enum", skip_serializing_if = "Vec::is_empty")]
    pub enum_: Vec<serde_json::Value>,
}

/// Items object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#itemsObject
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Items {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<DataType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DataTypeFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Box<Items>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_format: Option<CollectionFormat>,
    #[serde(default, rename = "enum", skip_serializing_if = "Vec::is_empty")]
    pub enum_: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f32>,
    #[serde(rename = "exclusiveMaximum", skip_serializing_if = "Option::is_none")]
    pub exclusive_maximum: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f32>,
    #[serde(rename = "exclusiveMinimum", skip_serializing_if = "Option::is_none")]
    pub exclusive_minimum: Option<bool>,
    #[serde(rename = "maxLength", skip_serializing_if = "Option::is_none")]
    pub max_length: Option<u32>,
    #[serde(rename = "minLength", skip_serializing_if = "Option::is_none")]
    pub min_length: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(rename = "maxItems", skip_serializing_if = "Option::is_none")]
    pub max_items: Option<u32>,
    #[serde(rename = "minItems", skip_serializing_if = "Option::is_none")]
    pub min_items: Option<u32>,
    #[serde(rename = "uniqueItems", skip_serializing_if = "Option::is_none")]
    pub unique_items: Option<bool>,
    #[serde(rename = "multipleOf", skip_serializing_if = "Option::is_none")]
    pub multiple_of: Option<f32>,
}

impl<S> Parameter<Resolvable<S>>
where
    S: Schema,
{
    /// Checks the validity of this parameter using the relative URL
    /// path it's associated with.
    pub fn check(&self, path: &str) -> Result<(), ValidationError> {
        if self.in_ == ParameterIn::Body {
            // Body parameter must specify a schema.
            if self.schema.is_none() {
                return Err(ValidationError::MissingSchemaForBodyParameter(
                    self.name.clone(),
                    path.into(),
                ));
            }

            return Ok(());
        } else if self.in_ == ParameterIn::Header {
            // Some headers aren't allowed.
            let lower = self.name.to_lowercase();
            if SPECIAL_HEADERS.iter().any(|&h| lower == h) {
                return Err(ValidationError::InvalidHeader(
                    self.name.clone(),
                    path.into(),
                ));
            }
        }

        // Non-body parameters must be primitives or an array - they can't have objects.
        let mut is_invalid = false;
        match self.data_type {
            Some(dt) if dt.is_primitive() => (),
            Some(DataType::Array) => {
                let mut inner = self.items.as_ref();
                loop {
                    let dt = inner.as_ref().and_then(|s| s.data_type);
                    match dt {
                        Some(ty) if ty.is_primitive() => break,
                        Some(DataType::Array) => {
                            inner = inner.as_ref().and_then(|s| s.items.as_deref());
                        }
                        None => {
                            return Err(ValidationError::InvalidParameterType(
                                self.name.clone(),
                                path.into(),
                                dt,
                                self.in_,
                            ));
                        }
                        _ => {
                            is_invalid = true;
                            break;
                        }
                    }
                }
            }
            // If "file" is specified, then it must be `formData` parameter.
            Some(DataType::File) => {
                // FIXME: Check against `consumes` and `produces` fields.
                if self.in_ != ParameterIn::FormData {
                    is_invalid = true;
                }
            }
            _ => is_invalid = true,
        }

        if is_invalid {
            return Err(ValidationError::InvalidParameterType(
                self.name.clone(),
                path.into(),
                self.data_type,
                self.in_,
            ));
        }

        Ok(())
    }
}

/// The location of the parameter.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd)]
#[serde(rename_all = "camelCase")]
pub enum ParameterIn {
    Query,
    Header,
    Path,
    FormData,
    Body,
}

/// Possible formats for array values in parameter.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd)]
#[serde(rename_all = "lowercase")]
pub enum CollectionFormat {
    Csv,
    Ssv,
    Tsv,
    Pipes,
    Multi,
}

/// Operation that can be traversed and resolved for codegen.
pub type ResolvableOperation<S> = Operation<ResolvableParameter<S>, ResolvableResponse<S>>;

/// Operation with default raw parameter and response.
pub type DefaultOperationRaw = Operation<DefaultParameterRaw, DefaultResponseRaw>;

/// Operation object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Operation<P, R> {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    // *NOTE:* `consumes` and `produces` are optional, because
    // local media ranges can be used to override global media ranges
    // (including setting it to empty), so we cannot go for an empty set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consumes: Option<BTreeSet<MediaRange>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub produces: Option<BTreeSet<MediaRange>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub security: Vec<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "BTreeSet::is_empty")]
    pub schemes: BTreeSet<OperationProtocol>,
    // FIXME: Validate using `http::status::StatusCode::from_u16`
    pub responses: BTreeMap<String, Either<Reference, R>>,
    #[serde(default = "Vec::default", skip_serializing_if = "Vec::is_empty")]
    pub parameters: Vec<Either<Reference, P>>,
    #[serde(default, skip_serializing_if = "is_false")]
    pub deprecated: bool,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,
}

impl<S> Operation<Parameter<S>, Response<S>> {
    /// Overwrites the names of parameters in this operation using the
    /// given path template.
    pub fn set_parameter_names_from_path_template(&mut self, path: &str) {
        let mut names = vec![];
        Api::<(), (), ()>::path_parameters_map(path, |p| {
            names.push(p.to_owned());
            ":".into()
        });

        for p in self
            .parameters
            .iter_mut()
            .filter(|p| p.in_ == ParameterIn::Path)
            .rev()
        {
            if let Some(n) = names.pop() {
                p.name = n;
            } else {
                break;
            }
        }
    }
}

/// Reference object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#referenceObject
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
pub struct Reference {
    #[serde(rename = "$ref")]
    pub reference: String,
}

/// The protocol used for an operation.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd)]
#[serde(rename_all = "lowercase")]
pub enum OperationProtocol {
    Http,
    Https,
    Ws,
    Wss,
}

/// Response that can be traversed and resolved for codegen.
pub type ResolvableResponse<S> = Arc<RwLock<Response<Resolvable<S>>>>;

/// Response with the default raw schema.
pub type DefaultResponseRaw = Response<DefaultSchemaRaw>;

/// Response object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#responseObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Response<S> {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<S>,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub headers: BTreeMap<String, Header>,
}

/// Header object.
///
/// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#headerObject
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Header {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub data_type: Option<DataType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<DataTypeFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Items>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_format: Option<CollectionFormat>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    #[serde(default, rename = "enum", skip_serializing_if = "Vec::is_empty")]
    pub enum_: Vec<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f32>,
    #[serde(rename = "exclusiveMaximum", skip_serializing_if = "Option::is_none")]
    pub exclusive_maximum: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f32>,
    #[serde(rename = "exclusiveMinimum", skip_serializing_if = "Option::is_none")]
    pub exclusive_minimum: Option<bool>,
    #[serde(rename = "maxLength", skip_serializing_if = "Option::is_none")]
    pub max_length: Option<u32>,
    #[serde(rename = "minLength", skip_serializing_if = "Option::is_none")]
    pub min_length: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(rename = "maxItems", skip_serializing_if = "Option::is_none")]
    pub max_items: Option<u32>,
    #[serde(rename = "minItems", skip_serializing_if = "Option::is_none")]
    pub min_items: Option<u32>,
    #[serde(rename = "uniqueItems", skip_serializing_if = "Option::is_none")]
    pub unique_items: Option<bool>,
    #[serde(rename = "multipleOf", skip_serializing_if = "Option::is_none")]
    pub multiple_of: Option<f32>,
}

/// The HTTP method used for an operation.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, Eq, PartialEq, Ord, PartialOrd)]
#[serde(rename_all = "lowercase")]
pub enum HttpMethod {
    Get,
    Put,
    Post,
    Delete,
    Options,
    Head,
    Patch,
}

impl HttpMethod {
    /// Whether this method allows body in requests.
    pub fn allows_body(self) -> bool {
        std::matches!(self, HttpMethod::Post | HttpMethod::Put | HttpMethod::Patch)
    }
}

/* Helpers */

/// `Either` from "either" crate. We can't use that crate because
/// we don't want the enum to be tagged during de/serialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Either<L, R> {
    Left(L),
    Right(R),
}

impl<L, R> Either<L, R> {
    /// Get a readable reference to the right variant (if it exists).
    pub fn right(&self) -> Option<&R> {
        match self {
            Either::Left(_) => None,
            Either::Right(r) => Some(r),
        }
    }

    /// Get a mutable reference to the right variant (if it exists).
    pub fn right_mut(&mut self) -> Option<&mut R> {
        match self {
            Either::Left(_) => None,
            Either::Right(r) => Some(r),
        }
    }

    /// Get a readable reference to the left variant (if it exists).
    pub fn left(&self) -> Option<&L> {
        match self {
            Either::Left(l) => Some(l),
            Either::Right(_) => None,
        }
    }

    /// Get a mutable reference to the left variant (if it exists).
    pub fn left_mut(&mut self) -> Option<&mut L> {
        match self {
            Either::Left(l) => Some(l),
            Either::Right(_) => None,
        }
    }
}

/// Wrapper for schema. This uses `Arc<RwLock<S>>` for interior
/// mutability and differentiates raw schema from resolved schema
/// (i.e., the one where `$ref` references point to the actual schema).
#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum Resolvable<S> {
    Raw(Arc<RwLock<S>>),
    #[serde(skip)]
    Resolved {
        new: Arc<RwLock<S>>,
        old: Arc<RwLock<S>>,
    },
}

impl<S> Resolvable<S>
where
    S: Schema,
{
    /// Fetch the description for this schema.
    pub fn get_description(&self) -> Option<String> {
        match *self {
            Resolvable::Raw(ref s) => s.read().description().map(String::from),
            // We don't want parameters/fields to describe the actual refrenced object.
            Resolvable::Resolved { ref old, .. } => old.read().description().map(String::from),
        }
    }
}

/* Common trait impls */

impl Default for SpecFormat {
    fn default() -> Self {
        SpecFormat::Json
    }
}

#[cfg(feature = "actix-base")]
impl From<&Method> for HttpMethod {
    fn from(method: &Method) -> HttpMethod {
        match method.as_str() {
            "PUT" => HttpMethod::Put,
            "POST" => HttpMethod::Post,
            "DELETE" => HttpMethod::Delete,
            "OPTIONS" => HttpMethod::Options,
            "HEAD" => HttpMethod::Head,
            "PATCH" => HttpMethod::Patch,
            _ => HttpMethod::Get,
        }
    }
}

impl<T> Deref for Either<Reference, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        match *self {
            Either::Left(_) => panic!("unable to deref because reference is not resolved."),
            Either::Right(ref r) => r,
        }
    }
}

impl<T> DerefMut for Either<Reference, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        match *self {
            Either::Left(_) => panic!("unable to deref because reference is not resolved."),
            Either::Right(ref mut r) => r,
        }
    }
}

impl<S> Deref for Resolvable<S> {
    type Target = Arc<RwLock<S>>;

    fn deref(&self) -> &Self::Target {
        match *self {
            Resolvable::Raw(ref s) => s,
            Resolvable::Resolved { ref new, .. } => new,
        }
    }
}

impl<S> DerefMut for Resolvable<S> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        match *self {
            Resolvable::Raw(ref mut s) => s,
            Resolvable::Resolved { ref mut new, .. } => new,
        }
    }
}

impl<S: Default> Default for Resolvable<S> {
    fn default() -> Self {
        Resolvable::from(S::default())
    }
}

impl<S> From<S> for Resolvable<S> {
    fn from(t: S) -> Self {
        Resolvable::Raw(Arc::new(RwLock::new(t)))
    }
}

impl<S> Clone for Resolvable<S> {
    fn clone(&self) -> Self {
        match *self {
            Resolvable::Raw(ref s) => Resolvable::Raw(s.clone()),
            Resolvable::Resolved { ref new, ref old } => Resolvable::Resolved {
                new: new.clone(),
                old: old.clone(),
            },
        }
    }
}

impl Display for HttpMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl Default for Version {
    fn default() -> Self {
        Version::V2
    }
}

impl Default for CollectionFormat {
    fn default() -> Self {
        CollectionFormat::Csv
    }
}

/// **NOTE:** This is just a stub. This is usually set explicitly.
impl Default for ParameterIn {
    fn default() -> Self {
        ParameterIn::Body
    }
}

/* Serde helpers */

#[allow(clippy::trivially_copy_pass_by_ref)]
fn is_false(val: &bool) -> bool {
    !*val
}

'''
'''--- core/src/v2/resolver.rs ---
use super::{
    models::{
        Either, HttpMethod, Reference, Resolvable, ResolvableParameter, ResolvablePathItem,
        ResolvableResponse,
    },
    Schema,
};
use crate::error::ValidationError;
use heck::CamelCase;

use std::{cell::RefCell, collections::BTreeMap, mem};

// FIXME: The resolver is not in its best. It "just" works atm.

const DEF_REF_PREFIX: &str = "#/definitions/";
const PARAM_REF_PREFIX: &str = "#/parameters/";
const RESP_REF_PREFIX: &str = "#/responses/";

type DefinitionsMap<S> = BTreeMap<String, Resolvable<S>>;
type OperationsMap<S> = BTreeMap<String, ResolvablePathItem<S>>;
type ParametersMap<S> = BTreeMap<String, ResolvableParameter<S>>;
type ResponsesMap<S> = BTreeMap<String, ResolvableResponse<S>>;

/// API schema resolver. This visits each definition and resolves
/// `$ref` field (if any) by finding the associated definition and
/// replacing the field with a reference to the actual definition.
// FIXME: Move all validation to resolver.
pub(crate) struct Resolver<S> {
    /// List of definitions that must be marked as cyclic while resolving a definition.
    cyclic_defs: RefCell<Vec<Resolvable<S>>>,
    /// Globally defined object definitions.
    pub defs: DefinitionsMap<S>,
    /// Paths and the corresponding operations.
    pub paths: OperationsMap<S>,
    /// Globally defined parameters.
    pub params: ParametersMap<S>,
    /// Globally defined responses;
    pub resp: ResponsesMap<S>,
}

impl<S>
    From<(
        DefinitionsMap<S>,
        OperationsMap<S>,
        ParametersMap<S>,
        ResponsesMap<S>,
    )> for Resolver<S>
{
    fn from(
        (defs, paths, params, resp): (
            DefinitionsMap<S>,
            OperationsMap<S>,
            ParametersMap<S>,
            ResponsesMap<S>,
        ),
    ) -> Self {
        Resolver {
            cyclic_defs: vec![].into(),
            defs,
            paths,
            params,
            resp,
        }
    }
}

impl<S> Resolver<S>
where
    S: Schema + Default,
{
    /// Visit definitions and resolve them!
    pub fn resolve(&mut self) -> Result<(), ValidationError> {
        // Resolve path operations first. We may encounter anonymous
        // definitions along the way, which we'll insert into `self.defs`
        // and we'll have to resolve them anyway.
        let mut paths = mem::replace(&mut self.paths, BTreeMap::new());
        paths.iter_mut().try_for_each(|(path, map)| {
            log::trace!("Checking path: {}", path);
            self.resolve_operations(path, map)
        })?;
        self.paths = paths;

        // Set the names of all schemas.
        for (name, schema) in &self.defs {
            schema.write().set_name(name);
        }

        for (name, schema) in &self.defs {
            log::trace!("Entering: {}", name);
            self.resolve_definitions_no_root_ref(schema)?;

            for def in self.cyclic_defs.borrow_mut().drain(..) {
                log::debug!(
                    "Cyclic definition detected: {:?}",
                    def.read().name().unwrap()
                );
                def.write().set_cyclic(true);
            }
        }

        Ok(())
    }

    /// We've passed some definition. Resolve it assuming that it doesn't
    /// contain any reference.
    fn resolve_definitions_no_root_ref(
        &self,
        schema: &Resolvable<S>,
    ) -> Result<(), ValidationError> {
        let mut schema = match schema.try_write() {
            Some(s) => s,
            None => {
                self.cyclic_defs.borrow_mut().push(schema.clone());
                return Ok(());
            }
        };

        if let Some(inner) = schema.items_mut().take() {
            return self.resolve_definitions(inner);
        }

        if let Some(props) = schema.properties_mut().take() {
            props.iter_mut().try_for_each(|(k, s)| {
                log::trace!("Resolving property {:?}", k);
                self.resolve_definitions(s)
            })?;
        }

        if let Some(props) = schema
            .additional_properties_mut()
            .take()
            .and_then(|s| s.right_mut())
        {
            self.resolve_definitions(props)?;
        }

        Ok(())
    }

    /// Resolve the given definition. If it contains a reference, find and assign it,
    /// otherwise traverse further.
    fn resolve_definitions(&self, schema: &mut Resolvable<S>) -> Result<(), ValidationError> {
        let ref_def = {
            let s = match schema.try_read() {
                Some(s) => s,
                None => {
                    self.cyclic_defs.borrow_mut().push(schema.clone());
                    return Ok(());
                }
            };

            if let Some(ref_name) = s.reference() {
                log::trace!("Resolving definition {}", ref_name);
                Some(self.resolve_definition_reference(ref_name)?)
            } else {
                None
            }
        };

        if let Some(new) = ref_def {
            *schema = match schema {
                Resolvable::Raw(old) => Resolvable::Resolved {
                    old: old.clone(),
                    new: (&*new).clone(),
                },
                _ => unimplemented!("schema already resolved?"),
            };
        }

        self.resolve_definitions_no_root_ref(&*schema)
    }

    /// Resolve a given operation.
    fn resolve_operations(
        &mut self,
        path: &str,
        map: &mut ResolvablePathItem<S>,
    ) -> Result<(), ValidationError> {
        for (&method, op) in &mut map.methods {
            self.resolve_parameters(Some(method), path, &mut op.parameters)?;
            for resp in op.responses.values_mut() {
                let ref_resp = if let Some(r) = resp.left() {
                    log::trace!("Resolving response {}", r.reference);
                    Some(self.resolve_response_reference(&r.reference)?)
                } else {
                    None
                };

                if let Some(new) = ref_resp {
                    *resp = Either::Right(new);
                }

                let mut response = resp.write();
                self.resolve_operation_schema(
                    &mut response.schema,
                    Some(method),
                    path,
                    "Response",
                )?;
            }
        }

        self.resolve_parameters(None, path, &mut map.parameters)
    }

    /// Resolve the given bunch of parameters.
    fn resolve_parameters(
        &mut self,
        method: Option<HttpMethod>,
        path: &str,
        params: &mut Vec<Either<Reference, ResolvableParameter<S>>>,
    ) -> Result<(), ValidationError> {
        for p in params.iter_mut() {
            let ref_param = if let Some(r) = p.left() {
                log::trace!("Resolving parameter {}", r.reference);
                Some(self.resolve_parameter_reference(&r.reference)?)
            } else {
                None
            };

            if let Some(new) = ref_param {
                *p = Either::Right(new);
            }

            let mut param = p.write();
            self.resolve_operation_schema(&mut param.schema, method, path, "Body")?;
        }

        Ok(())
    }

    /// Resolves request/response schema in operation.
    fn resolve_operation_schema(
        &mut self,
        s: &mut Option<Resolvable<S>>,
        method: Option<HttpMethod>,
        path: &str,
        suffix: &str,
    ) -> Result<(), ValidationError> {
        let schema = match s.as_mut() {
            Some(s) => s,
            _ => return Ok(()),
        };

        match schema {
            Resolvable::Raw(ref s) if s.read().reference().is_none() => {
                // We've encountered an anonymous schema definition in some
                // parameter/response. Give it a name and add it to global definitions.
                let prefix = method.map(|s| s.to_string()).unwrap_or_default();
                let def_name = (prefix + path + suffix).to_camel_case();
                let mut ref_schema = S::default();
                ref_schema.set_reference(format!("{}{}", DEF_REF_PREFIX, def_name));
                let old_schema = mem::replace(schema, ref_schema.into());
                self.defs.insert(def_name, old_schema);
            }
            _ => (),
        }

        self.resolve_definitions(schema)?;
        Ok(())
    }

    /// Given a name (from `$ref` field), get a reference to the definition.
    fn resolve_definition_reference(&self, name: &str) -> Result<Resolvable<S>, ValidationError> {
        if !name.starts_with(DEF_REF_PREFIX) {
            return Err(ValidationError::InvalidRefURI(name.into()));
        }

        let name = &name[DEF_REF_PREFIX.len()..];
        let schema = self
            .defs
            .get(name)
            .ok_or_else(|| ValidationError::MissingReference(name.into()))?;
        Ok(schema.clone())
    }

    /// Given a name (from `$ref` field), get a reference to the parameter.
    fn resolve_parameter_reference(
        &self,
        name: &str,
    ) -> Result<ResolvableParameter<S>, ValidationError> {
        if !name.starts_with(PARAM_REF_PREFIX) {
            return Err(ValidationError::InvalidRefURI(name.into()));
        }

        let name = &name[PARAM_REF_PREFIX.len()..];
        let param = self
            .params
            .get(name)
            .ok_or_else(|| ValidationError::MissingReference(name.into()))?;
        Ok(param.clone())
    }

    /// Given a name (from `$ref` field), get a reference to the response.
    fn resolve_response_reference(
        &self,
        name: &str,
    ) -> Result<ResolvableResponse<S>, ValidationError> {
        if !name.starts_with(RESP_REF_PREFIX) {
            return Err(ValidationError::InvalidRefURI(name.into()));
        }

        let name = &name[RESP_REF_PREFIX.len()..];
        let resp = self
            .resp
            .get(name)
            .ok_or_else(|| ValidationError::MissingReference(name.into()))?;
        Ok(resp.clone())
    }
}

'''
'''--- core/src/v2/schema.rs ---
//! Traits used for code and spec generation.

use super::models::{
    DataType, DataTypeFormat, DefaultOperationRaw, DefaultSchemaRaw, Either, Resolvable,
    SecurityScheme,
};

use std::collections::{BTreeMap, BTreeSet};

/// Interface for the [`Schema`](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject) object.
///
/// This is only used for resolving the definitions.
///
/// **NOTE:** Don't implement this by yourself! Please use the `#[api_v2_schema]`
/// proc macro attribute instead.
pub trait Schema: Sized {
    /// Description for this schema, if any (`description` field).
    fn description(&self) -> Option<&str>;

    /// Reference to some other schema, if any (`$ref` field).
    fn reference(&self) -> Option<&str>;

    /// Data type of this schema, if any (`type` field).
    fn data_type(&self) -> Option<DataType>;

    /// Data type format used by this schema, if any (`format` field).
    fn format(&self) -> Option<&DataTypeFormat>;

    /// Schema for array definitions, if any (`items` field).
    fn items(&self) -> Option<&Resolvable<Self>>;

    /// Mutable access to the `items` field, if it exists.
    fn items_mut(&mut self) -> Option<&mut Resolvable<Self>>;

    /// Value schema for maps (`additional_properties` field).
    fn additional_properties(&self) -> Option<&Either<bool, Resolvable<Self>>>;

    /// Mutable access to `additional_properties` field, if it's a map.
    fn additional_properties_mut(&mut self) -> Option<&mut Either<bool, Resolvable<Self>>>;

    /// Map of names and schema for properties, if it's an object (`properties` field)
    fn properties(&self) -> Option<&BTreeMap<String, Resolvable<Self>>>;

    /// Mutable access to `properties` field.
    fn properties_mut(&mut self) -> Option<&mut BTreeMap<String, Resolvable<Self>>>;

    /// Returns the required properties (if any) for this object.
    fn required_properties(&self) -> Option<&BTreeSet<String>>;

    /// Enum variants in this schema (if any). It's `serde_json::Value`
    /// because:
    ///
    /// - Enum variants are allowed to have any type of value.
    /// - `serde_json::Value` works for both JSON and YAML.
    fn enum_variants(&self) -> Option<&[serde_json::Value]>;

    /// Returns whether this definition "is" or "has" `Any` type.
    fn contains_any(&self) -> bool {
        _schema_contains_any(self, vec![])
    }

    /* MARK: Resolver-specific methods. */

    /// Set the reference to this schema.
    fn set_reference(&mut self, ref_: String);

    /// Set whether this definition is cyclic. This is done by the resolver.
    fn set_cyclic(&mut self, cyclic: bool);

    /// Returns whether this definition is cyclic.
    ///
    /// **NOTE:** This is not part of the schema object, but it's
    /// set by the resolver using `set_cyclic` for codegen.
    fn is_cyclic(&self) -> bool;

    /// Name of this schema, if any.
    ///
    /// **NOTE:** This is not part of the schema object, but it's
    /// set by the resolver using `set_name` for codegen.
    fn name(&self) -> Option<&str>;

    /// Sets the name for this schema. This is done by the resolver.
    fn set_name(&mut self, name: &str);
}

fn _schema_contains_any<'a, S: Schema>(schema: &'a S, mut nodes: Vec<&'a str>) -> bool {
    if schema.data_type().is_none() {
        return true;
    }

    if let Some(name) = schema.name() {
        if nodes.iter().any(|&n| n == name) {
            return false; // We've encountered a cycle.
        } else {
            nodes.push(name);
        }
    }

    schema
        .properties()
        .map(|t| {
            t.values()
                .any(|s| _schema_contains_any(&*s.read(), nodes.clone()))
        })
        .unwrap_or(false)
        || schema
            .items()
            .map(|s| _schema_contains_any(&*s.read(), nodes.clone()))
            .unwrap_or(false)
        || schema
            .additional_properties()
            .map(|e| match e {
                Either::Left(extra_props_allowed) => *extra_props_allowed,
                Either::Right(s) => _schema_contains_any(&*s.read(), nodes),
            })
            .unwrap_or(false)
}

/// Trait for returning OpenAPI data type and format for the implementor.
pub trait TypedData {
    /// The OpenAPI type for this implementor.
    fn data_type() -> DataType {
        DataType::Object
    }

    /// The optional OpenAPI data format for this implementor.
    fn format() -> Option<DataTypeFormat> {
        None
    }
}

macro_rules! impl_type_simple {
    ($ty:ty) => {
        impl TypedData for $ty {}
    };
    ($ty:ty, $dt:expr) => {
        impl TypedData for $ty {
            fn data_type() -> DataType {
                $dt
            }
        }
    };
    ($ty:ty, $dt:expr, $df:expr) => {
        impl TypedData for $ty {
            fn data_type() -> DataType {
                $dt
            }
            fn format() -> Option<DataTypeFormat> {
                Some($df)
            }
        }
    };
}

impl<'a> TypedData for &'a str {
    fn data_type() -> DataType {
        DataType::String
    }
}

impl<'a, T: TypedData> TypedData for &'a T {
    fn data_type() -> DataType {
        T::data_type()
    }

    fn format() -> Option<DataTypeFormat> {
        T::format()
    }
}

impl_type_simple!(char, DataType::String);
impl_type_simple!(String, DataType::String);
impl_type_simple!(bool, DataType::Boolean);
impl_type_simple!(f32, DataType::Number, DataTypeFormat::Float);
impl_type_simple!(f64, DataType::Number, DataTypeFormat::Double);
impl_type_simple!(i8, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(i16, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(i32, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(u8, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(u16, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(u32, DataType::Integer, DataTypeFormat::Int32);
impl_type_simple!(i64, DataType::Integer, DataTypeFormat::Int64);
impl_type_simple!(i128, DataType::Integer, DataTypeFormat::Int64);
impl_type_simple!(isize, DataType::Integer, DataTypeFormat::Int64);
impl_type_simple!(u64, DataType::Integer, DataTypeFormat::Int64);
impl_type_simple!(u128, DataType::Integer, DataTypeFormat::Int64);
impl_type_simple!(usize, DataType::Integer, DataTypeFormat::Int64);

#[cfg(feature = "actix-multipart")]
impl_type_simple!(
    actix_multipart::Multipart,
    DataType::File,
    DataTypeFormat::Binary
);
#[cfg(feature = "actix-session")]
impl_type_simple!(actix_session::Session);
#[cfg(feature = "actix-files")]
impl_type_simple!(
    actix_files::NamedFile,
    DataType::File,
    DataTypeFormat::Binary
);
#[cfg(feature = "chrono")]
impl_type_simple!(
    chrono::NaiveDateTime,
    DataType::String,
    DataTypeFormat::DateTime
);
#[cfg(feature = "chrono")]
impl_type_simple!(chrono::NaiveDate, DataType::String, DataTypeFormat::Date);
#[cfg(feature = "chrono")]
impl_type_simple!(chrono::NaiveTime, DataType::String);
#[cfg(feature = "rust_decimal")]
impl_type_simple!(
    rust_decimal::Decimal,
    DataType::Number,
    DataTypeFormat::Float
);

#[cfg(feature = "uuid")]
impl_type_simple!(uuid::Uuid, DataType::String, DataTypeFormat::Uuid);

#[cfg(feature = "chrono")]
impl<T: chrono::offset::TimeZone> TypedData for chrono::DateTime<T> {
    fn data_type() -> DataType {
        DataType::String
    }
    fn format() -> Option<DataTypeFormat> {
        Some(DataTypeFormat::DateTime)
    }
}

#[cfg(feature = "chrono")]
impl<T: chrono::offset::TimeZone> TypedData for chrono::Date<T> {
    fn data_type() -> DataType {
        DataType::String
    }
    fn format() -> Option<DataTypeFormat> {
        Some(DataTypeFormat::Date)
    }
}

/// Represents a OpenAPI v2 schema object convertible. This is auto-implemented by
/// framework-specific macros:
///
/// - [`Apiv2Schema`](https://paperclip.waffles.space/paperclip_actix/derive.Apiv2Schema.html)
/// for schema objects.
/// - [`Apiv2Security`](https://paperclip.waffles.space/paperclip_actix/derive.Apiv2Security.html)
/// for security scheme objects.
///
/// This is implemented for primitive types by default.
pub trait Apiv2Schema {
    /// Name of this schema. This is the name to which the definition of the object is mapped.
    const NAME: Option<&'static str> = None;

    /// Description of this schema. In case the trait is derived, uses the documentation on the type.
    const DESCRIPTION: &'static str = "";

    /// Indicates the requirement of this schema.
    const REQUIRED: bool = true;

    /// Returns the raw schema for this object.
    fn raw_schema() -> DefaultSchemaRaw {
        Default::default()
    }

    /// Returns the schema with a reference (if this is an object).
    ///
    /// Here, we set the global reference to this object using its name,
    /// and we either remove the reference (`remove_refs`) or remove all
    /// properties other than the reference (`retain_ref`) based on where
    /// we're storing this object in the spec i.e., in an operation/response
    /// or in the map of definitions.
    ///
    /// And we do that because at the time of this writing, statically
    /// collecting all models for all operations involved a lot of work,
    /// and so I went for runtime collection. Even though this happens at
    /// runtime, we're only doing this once at the start of the application,
    /// so it won't affect the incoming requests at all.
    fn schema_with_ref() -> DefaultSchemaRaw {
        let mut def = Self::raw_schema();
        if let Some(n) = Self::NAME {
            def.reference = Some(String::from("#/definitions/") + n);
        } else if let Some(n) = def.name.as_ref() {
            def.reference = Some(String::from("#/definitions/") + n);
        }
        if !Self::DESCRIPTION.is_empty() {
            def.description = Some(Self::DESCRIPTION.to_owned());
        }

        def
    }

    /// Returns the security scheme for this object.
    fn security_scheme() -> Option<SecurityScheme> {
        None
    }
}

impl Apiv2Schema for () {}
impl Apiv2Schema for serde_json::Value {}
impl Apiv2Schema for serde_yaml::Value {}

impl<T: TypedData> Apiv2Schema for T {
    fn raw_schema() -> DefaultSchemaRaw {
        DefaultSchemaRaw {
            data_type: Some(T::data_type()),
            format: T::format(),
            ..Default::default()
        }
    }
}

#[cfg(feature = "nightly")]
impl<T> Apiv2Schema for Option<T> {
    default const NAME: Option<&'static str> = None;
    default const REQUIRED: bool = false;

    default fn raw_schema() -> DefaultSchemaRaw {
        Default::default()
    }

    default fn security_scheme() -> Option<SecurityScheme> {
        None
    }
}

impl<T: Apiv2Schema> Apiv2Schema for Option<T> {
    const NAME: Option<&'static str> = T::NAME;
    const REQUIRED: bool = false;

    fn raw_schema() -> DefaultSchemaRaw {
        T::raw_schema()
    }

    fn security_scheme() -> Option<SecurityScheme> {
        T::security_scheme()
    }
}

#[cfg(feature = "nightly")]
impl<T, E> Apiv2Schema for Result<T, E> {
    default const NAME: Option<&'static str> = None;

    default fn raw_schema() -> DefaultSchemaRaw {
        Default::default()
    }

    default fn security_scheme() -> Option<SecurityScheme> {
        Default::default()
    }
}

impl<T: Apiv2Schema, E> Apiv2Schema for Result<T, E> {
    const NAME: Option<&'static str> = T::NAME;

    fn raw_schema() -> DefaultSchemaRaw {
        T::raw_schema()
    }

    fn security_scheme() -> Option<SecurityScheme> {
        T::security_scheme()
    }
}

impl<T: Apiv2Schema + Clone> Apiv2Schema for std::borrow::Cow<'_, T> {
    const NAME: Option<&'static str> = T::NAME;

    fn raw_schema() -> DefaultSchemaRaw {
        T::raw_schema()
    }

    fn security_scheme() -> Option<SecurityScheme> {
        T::security_scheme()
    }
}

impl<'a, T: Apiv2Schema> Apiv2Schema for &'a [T] {
    fn raw_schema() -> DefaultSchemaRaw {
        Vec::<T>::raw_schema()
    }
}

macro_rules! impl_schema_array {
    ($ty:ty) => {
        impl<T: Apiv2Schema> Apiv2Schema for $ty {
            fn raw_schema() -> DefaultSchemaRaw {
                DefaultSchemaRaw {
                    data_type: Some(DataType::Array),
                    items: Some(T::schema_with_ref().into()),
                    ..Default::default()
                }
            }
        }
    };
}

macro_rules! impl_schema_map {
    ($ty:ty) => {
        impl<K: ToString, V: Apiv2Schema> Apiv2Schema for $ty {
            fn raw_schema() -> DefaultSchemaRaw {
                DefaultSchemaRaw {
                    data_type: Some(DataType::Object),
                    extra_props: Some(Either::Right(V::schema_with_ref().into())),
                    ..Default::default()
                }
            }
        }
    };
}

use std::collections::*;

impl_schema_array!(Vec<T>);
impl_schema_array!(HashSet<T>);
impl_schema_array!(LinkedList<T>);
impl_schema_array!(VecDeque<T>);
impl_schema_array!(BTreeSet<T>);
impl_schema_array!(BinaryHeap<T>);
impl_schema_array!([T; 0]);
impl_schema_array!([T; 1]);
impl_schema_array!([T; 2]);
impl_schema_array!([T; 3]);
impl_schema_array!([T; 4]);
impl_schema_array!([T; 5]);
impl_schema_array!([T; 6]);
impl_schema_array!([T; 7]);
impl_schema_array!([T; 8]);
impl_schema_array!([T; 9]);
impl_schema_array!([T; 10]);
impl_schema_array!([T; 11]);
impl_schema_array!([T; 12]);
impl_schema_array!([T; 13]);
impl_schema_array!([T; 14]);
impl_schema_array!([T; 15]);
impl_schema_array!([T; 16]);
impl_schema_array!([T; 17]);
impl_schema_array!([T; 18]);
impl_schema_array!([T; 19]);
impl_schema_array!([T; 20]);
impl_schema_array!([T; 21]);
impl_schema_array!([T; 22]);
impl_schema_array!([T; 23]);
impl_schema_array!([T; 24]);
impl_schema_array!([T; 25]);
impl_schema_array!([T; 26]);
impl_schema_array!([T; 27]);
impl_schema_array!([T; 28]);
impl_schema_array!([T; 29]);
impl_schema_array!([T; 30]);
impl_schema_array!([T; 31]);
impl_schema_array!([T; 32]);

impl_schema_map!(HashMap<K, V>);
impl_schema_map!(BTreeMap<K, V>);

/// Represents a OpenAPI v2 operation convertible. This is auto-implemented by
/// framework-specific macros:
///
/// - [`paperclip_actix::api_v2_operation`](https://paperclip.waffles.space/paperclip_actix/attr.api_v2_operation.html).
///
/// **NOTE:** The type parameters specified here aren't used by the trait itself,
/// but *can* be used for constraining stuff in framework-related impls.
pub trait Apiv2Operation {
    /// Returns the definition for this operation.
    fn operation() -> DefaultOperationRaw;

    /// Returns a map of security definitions that will be merged globally.
    fn security_definitions() -> BTreeMap<String, SecurityScheme>;

    /// Returns the definitions used by this operation.
    fn definitions() -> BTreeMap<String, DefaultSchemaRaw>;
}

/// Represents a OpenAPI v2 error convertible. This is auto-implemented by
/// framework-specific macros:
///
/// - [`paperclip_actix::api_v2_errors`](https://paperclip.waffles.space/paperclip_actix/attr.api_v2_errors.html).
pub trait Apiv2Errors {
    const ERROR_MAP: &'static [(u16, &'static str)] = &[];
}

impl Apiv2Errors for () {}
#[cfg(feature = "actix-base")]
impl Apiv2Errors for actix_web::Error {}

'''
'''--- macros/Cargo.toml ---
[package]
name = "paperclip-macros"
version = "0.4.0"
authors = ["Ravi Shankar <wafflespeanut@gmail.com>"]
edition = "2018"
description = "Macros for paperclip OpenAPI tooling library"
documentation = "https://paperclip.waffles.space/paperclip_macros"
license = "MIT OR Apache-2.0"
homepage = "https://github.com/wafflespeanut/paperclip"
repository = "https://github.com/wafflespeanut/paperclip"

[lib]
proc-macro = true

[dependencies]
mime = "0.3"
proc-macro2 = "1.0"
proc-macro-error = "1.0"
quote = "1.0"
syn = { version = "1.0", features = ["full"] }
heck = { version = "0.3", optional = true }
http = { version = "0.2", optional = true }
lazy_static = { version = "1.4", optional = true }
strum = { version = ">=0.19,<0.21", optional = true }
strum_macros = { version = ">=0.19,<0.21", optional = true }

[features]
actix = ["heck", "http", "lazy_static", "strum", "strum_macros"]
v2 = []
nightly = []

'''
'''--- macros/src/actix.rs ---
//! Convenience macros for the [actix-web](https://github.com/wafflespeanut/paperclip/tree/master/plugins/actix-web)
//! OpenAPI plugin (exposed by paperclip with `actix` feature).

use heck::*;
use http::StatusCode;
use lazy_static::lazy_static;
use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use strum_macros::EnumString;
use syn::{
    parse_macro_input,
    punctuated::{Pair, Punctuated},
    spanned::Spanned,
    Attribute, Data, DataEnum, DeriveInput, Field, Fields, FieldsNamed, FieldsUnnamed, FnArg,
    Generics, Ident, ItemFn, Lit, Meta, MetaList, MetaNameValue, NestedMeta, Path, PathArguments,
    ReturnType, Token, TraitBound, Type, TypeTraitObject,
};

use std::collections::HashMap;

const SCHEMA_MACRO_ATTR: &str = "openapi";

lazy_static! {
    static ref EMPTY_SCHEMA_HELP: String = format!(
        "you can mark the struct with #[{}(empty)] to ignore this warning.",
        SCHEMA_MACRO_ATTR
    );
}

/// Actual parser and emitter for `api_v2_operation` macro.
pub fn emit_v2_operation(attrs: TokenStream, input: TokenStream) -> TokenStream {
    let default_span = proc_macro2::Span::call_site();
    let mut item_ast: ItemFn = match syn::parse(input) {
        Ok(s) => s,
        Err(e) => {
            emit_error!(e.span().unwrap(), "operation must be a function.");
            return quote!().into();
        }
    };

    // Unit struct
    let s_name = format!("paperclip_{}", item_ast.sig.ident);
    let unit_struct = Ident::new(&s_name, default_span);
    let generics = &item_ast.sig.generics;
    let mut generics_call = quote!();
    let mut struct_definition = quote!(struct #unit_struct;);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    if !generics.params.is_empty() {
        let turbofish = ty_generics.as_turbofish();
        let generics_params = extract_generics_params(&item_ast);
        generics_call = quote!(#turbofish { p: std::marker::PhantomData });
        struct_definition = quote!(struct #unit_struct #ty_generics { p: std::marker::PhantomData<(#generics_params)> } )
    }

    // Get rid of async prefix. In the end, we'll have them all as `impl Future` thingies.
    if item_ast.sig.asyncness.is_some() {
        item_ast.sig.asyncness = None;
    }

    let mut wrapper = quote!(paperclip::actix::ResponseWrapper<actix_web::HttpResponse, #unit_struct #ty_generics>);
    let mut is_impl_trait = false;
    let mut is_responder = false;
    match &mut item_ast.sig.output {
        rt @ ReturnType::Default => {
            // Not particularly useful, but let's deal with it anyway
            *rt = ReturnType::Type(
                Token![->](default_span),
                Box::new(syn::parse2(wrapper.clone()).expect("parsing empty type")),
            );
        }
        ReturnType::Type(_, ty) => {
            let t = quote!(#ty).to_string();
            if let Type::ImplTrait(_) = &**ty {
                is_impl_trait = true;
            }

            if t == "impl Responder" {
                // `impl Responder` is a special case because we have to add another wrapper.
                // FIXME: Better way to deal with this?
                is_responder = true;
                *ty = Box::new(
                    syn::parse2(quote!(
                        impl std::future::Future<Output=paperclip::actix::ResponderWrapper<#ty>>
                    ))
                    .expect("parsing impl trait"),
                );
            } else if !is_impl_trait {
                // Any handler that's not returning an impl trait should return an `impl Future`
                *ty = Box::new(
                    syn::parse2(quote!(impl std::future::Future<Output=#ty>))
                        .expect("parsing impl trait"),
                );
            }

            if let Type::ImplTrait(imp) = &**ty {
                let obj = TypeTraitObject {
                    dyn_token: Some(Token![dyn](default_span)),
                    bounds: imp.bounds.clone(),
                };
                *ty = Box::new(
                    syn::parse2(quote!(#ty + paperclip::v2::schema::Apiv2Operation))
                        .expect("parsing impl trait"),
                );

                if !is_responder {
                    // NOTE: We're only using the box "type" to generate the operation data, we're not boxing
                    // the handlers at runtime.
                    wrapper = quote!(paperclip::actix::ResponseWrapper<Box<#obj + std::marker::Unpin>, #unit_struct #ty_generics>);
                }
            }
        }
    }

    let block = item_ast.block;
    // We need a function because devs should be able to use "return" keyword along the way.
    let wrapped_fn_call = if is_responder {
        quote!(paperclip::util::ready(paperclip::actix::ResponderWrapper((move || #block)())))
    } else if is_impl_trait {
        quote!((move || #block)())
    } else {
        quote!((move || async move #block)())
    };

    item_ast.block = Box::new(
        syn::parse2(quote!(
            {
                let f = #wrapped_fn_call;
                paperclip::actix::ResponseWrapper {
                    0: f,
                    1: #unit_struct #generics_call,
                }
            }
        ))
        .expect("parsing wrapped block"),
    );

    // Initialize operation parameters from macro attributes
    let (mut op_params, mut op_values) = parse_operation_attrs(attrs);

    // Optionally extract summary and description from doc comments
    if op_params.iter().find(|i| *i == "summary").is_none() {
        let (summary, description) = extract_fn_documentation(&item_ast);
        if let Some(summary) = summary {
            op_params.push(Ident::new("summary", item_ast.span()));
            op_values.push(summary)
        }
        if let Some(description) = description {
            op_params.push(Ident::new("description", item_ast.span()));
            op_values.push(description)
        }
    }

    let modifiers = extract_fn_arguments_types(&item_ast);

    quote!(
        #struct_definition

        #item_ast

        impl #impl_generics paperclip::v2::schema::Apiv2Operation for #unit_struct #ty_generics #where_clause {
            fn operation() -> paperclip::v2::models::DefaultOperationRaw {
                use paperclip::actix::OperationModifier;
                let mut op = paperclip::v2::models::DefaultOperationRaw {
                    #(
                        #op_params: #op_values,
                    )*
                    .. Default::default()
                };
                #(
                    <#modifiers>::update_parameter(&mut op);
                    <#modifiers>::update_security(&mut op);
                )*
                <<#wrapper as std::future::Future>::Output>::update_response(&mut op);
                op
            }

            #[allow(unused_mut)]
            fn security_definitions() -> std::collections::BTreeMap<String, paperclip::v2::models::SecurityScheme> {
                use paperclip::actix::OperationModifier;
                let mut map = Default::default();
                #(
                    <#modifiers>::update_security_definitions(&mut map);
                )*
                map
            }

            fn definitions() -> std::collections::BTreeMap<String, paperclip::v2::models::DefaultSchemaRaw> {
                use paperclip::actix::OperationModifier;
                let mut map = std::collections::BTreeMap::new();
                #(
                    <#modifiers>::update_definitions(&mut map);
                )*
                <<#wrapper as std::future::Future>::Output>::update_definitions(&mut map);
                map
            }
        }
    )
    .into()
}

/// Extract punctuated generic parameters from fn definition
fn extract_generics_params(item_ast: &ItemFn) -> Punctuated<Ident, syn::token::Comma> {
    item_ast
        .sig
        .generics
        .params
        .pairs()
        .filter_map(|pair| match pair {
            Pair::Punctuated(syn::GenericParam::Type(gen), punct) => {
                Some(Pair::new(gen.ident.clone(), Some(*punct)))
            }
            Pair::End(syn::GenericParam::Type(gen)) => Some(Pair::new(gen.ident.clone(), None)),
            _ => None,
        })
        .collect()
}

/// Extract function arguments
fn extract_fn_arguments_types(item_ast: &ItemFn) -> Vec<Type> {
    item_ast
        .sig
        .inputs
        .iter()
        .filter_map(|inp| match inp {
            FnArg::Receiver(_) => None,
            FnArg::Typed(ref t) => Some(*t.ty.clone()),
        })
        .collect()
}

/// Parse macro attrs, matching to Operation fields
/// Returning operation attribute identifier and value initialization arrays
/// Note: Array likes initialized from string "val1, val2, val3", where "val1"
/// would parse into destination item
fn parse_operation_attrs(attrs: TokenStream) -> (Vec<Ident>, Vec<proc_macro2::TokenStream>) {
    let attrs = crate::parse_input_attrs(attrs);
    let mut params = Vec::new();
    let mut values = Vec::new();
    for attr in attrs.0 {
        if let NestedMeta::Meta(Meta::NameValue(MetaNameValue { path, lit, .. })) = &attr {
            if let Some(ident) = path.get_ident() {
                match ident.to_string().as_str() {
                    "summary" | "description" | "operation_id" => {
                        if let Lit::Str(val) = lit {
                            params.push(ident.clone());
                            values.push(quote!(Some(#val.to_string())));
                        } else {
                            emit_error!(lit.span(), "Expected string literal: {:?}", lit)
                        }
                    }
                    "consumes" | "produces" => {
                        if let Lit::Str(mimes) = lit {
                            let mut mime_types = Vec::new();
                            for val in mimes.value().split(',') {
                                let val = val.trim();
                                if let Err(err) = val.parse::<mime::Mime>() {
                                    emit_error!(
                                        lit.span(),
                                        "Value {} does not parse as mime type: {}",
                                        val,
                                        err
                                    );
                                } else {
                                    mime_types.push(quote!(paperclip::v2::models::MediaRange(#val.parse().unwrap())));
                                }
                            }
                            if !mime_types.is_empty() {
                                params.push(ident.clone());
                                values.push(quote!({
                                    let mut tmp = std::collections::BTreeSet::new();
                                    #(
                                        tmp.insert(#mime_types);
                                    )*
                                    Some(tmp)
                                }));
                            }
                        } else {
                            emit_error!(
                                lit.span(),
                                "Expected comma separated values in string literal: {:?}",
                                lit
                            )
                        }
                    }
                    x => emit_error!(ident.span(), "Unknown attribute {}", x),
                }
            } else {
                emit_error!(
                    path.span(),
                    "Expected single identifier, got path {:?}",
                    path
                )
            }
        } else if let NestedMeta::Meta(Meta::List(MetaList { path, nested, .. })) = &attr {
            if let Some(ident) = path.get_ident() {
                match ident.to_string().as_str() {
                    "tags" => {
                        let mut tags = Vec::new();
                        for meta in nested.pairs().map(|pair| pair.into_value()) {
                            if let NestedMeta::Meta(Meta::Path(Path { segments, .. })) = meta {
                                tags.push(segments[0].ident.to_string());
                            } else if let NestedMeta::Lit(Lit::Str(lit)) = meta {
                                tags.push(lit.value());
                            } else {
                                emit_error!(
                                    meta.span(),
                                    "Expected comma separated list of tags idents: {:?}",
                                    meta
                                )
                            }
                        }
                        if !tags.is_empty() {
                            params.push(ident.clone());
                            values.push(quote!(vec![ #( #tags.to_string() ),* ]));
                        }
                    }
                    x => emit_error!(ident.span(), "Unknown list ident {}", x),
                }
            }
        } else {
            emit_error!(attr.span(), "Not supported attribute type {:?}", attr)
        }
    }
    (params, values)
}

/// Extracts summary from top line doc comment and description from the rest
fn extract_fn_documentation(
    item_ast: &ItemFn,
) -> (
    Option<proc_macro2::TokenStream>,
    Option<proc_macro2::TokenStream>,
) {
    let docs = extract_documentation(&item_ast.attrs);
    let lines = docs.lines();
    let mut before_empty = true;
    let (summary, description): (Vec<_>, Vec<_>) = lines.partition(|line| {
        if line.trim().is_empty() {
            before_empty = false
        };
        before_empty
    });
    let none_if_empty = |text: &str| {
        if text.is_empty() {
            None
        } else {
            Some(quote!(Some(#text.to_string())))
        }
    };
    let summary = none_if_empty(summary.into_iter().collect::<String>().trim());
    let description = none_if_empty(description.join("\n").trim());
    (summary, description)
}

/// Actual parser and emitter for `api_v2_errors` macro.
pub fn emit_v2_errors(attrs: TokenStream, input: TokenStream) -> TokenStream {
    let item_ast = match crate::expect_struct_or_enum(input) {
        Ok(i) => i,
        Err(ts) => return ts,
    };

    let name = &item_ast.ident;
    let attrs = crate::parse_input_attrs(attrs);
    let generics = item_ast.generics.clone();
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Convert macro attributes to tuples in form of (u16, &str)
    let error_codes = attrs
        .0
        .iter()
        // Pair code attrs with description attrs; save attr itself to properly span error messages at later stage
        .fold(Vec::new(), |mut list: Vec<(Option<u16>, Option<String>, _)>, attr| {
            let span = attr.span().unwrap();
            match attr {
                // Read named attribute.
                NestedMeta::Meta(Meta::NameValue(name_value)) => {
                    let attr_name = name_value.path.get_ident().map(|ident| ident.to_string());
                    let attr_value = &name_value.lit;

                    match (attr_name.as_deref(), attr_value) {
                        // "code" attribute adds new element to list
                        (Some("code"), Lit::Int(attr_value)) => {
                            let status_code = attr_value.base10_parse::<u16>()
                                .map_err(|_| emit_error!(span, "Invalid u16 in code argument")).ok();
                            list.push((status_code, None, attr));
                        },
                        // "description" attribute updates last element in list
                        (Some("description"), Lit::Str(attr_value)) =>
                            if let Some(last_value) = list.last_mut() {
                                if last_value.1.is_some() {
                                    emit_warning!(span, "This attribute overwrites previous description");
                                }
                                last_value.1 = Some(attr_value.value());
                            } else {
                                emit_error!(span, "Attribute 'description' can be only placed after prior 'code' argument");
                            },
                        _ => emit_error!(span, "Invalid macro attribute. Should be plain u16, 'code = u16' or 'description = str'")
                    }
                },
                // Read plain status code as attribute.
                NestedMeta::Lit(Lit::Int(attr_value)) => {
                    let status_code = attr_value.base10_parse::<u16>()
                    .map_err(|_| emit_error!(span, "Invalid u16 in code argument")).ok();
                    list.push((status_code, None, attr));
                },
                _ => emit_error!(span, "This macro supports only named attributes - 'code' (u16) or 'description' (str)")
            }

            list
        })
        .iter()
        // Map code-message pairs into bits of code, filter empty codes out
        .filter_map(|triple| {
            let (code, description) = match triple {
                (Some(code), Some(description), _) => (code, description.to_owned()),
                (Some(code), None, attr) => {
                    let span = attr.span().unwrap();
                    let description = StatusCode::from_u16(*code)
                        .map_err(|_| {
                            emit_warning!(span, format!("Invalid status code {}", code));
                            String::new()
                        })
                        .map(|s| s.canonical_reason()
                            .map(str::to_string)
                            .unwrap_or_else(|| {
                                emit_warning!(span, format!("Status code {} doesn't have a canonical name", code));
                                String::new()
                            })
                        )
                        .unwrap_or_else(|_| String::new());
                    (code, description)
                },
                (None, _, _) => return None,
            };

            Some(quote! {
                (#code, #description),
            })
        })
        .fold(proc_macro2::TokenStream::new(), |mut stream, tokens| {
            stream.extend(tokens);
            stream
        });

    let gen = quote! {
        #item_ast

        impl #impl_generics paperclip::v2::schema::Apiv2Errors for #name #ty_generics #where_clause {
            const ERROR_MAP: &'static [(u16, &'static str)] = &[
                #error_codes
            ];
        }
    };

    gen.into()
}

/// Actual parser and emitter for `api_v2_schema` macro.
pub fn emit_v2_definition(input: TokenStream) -> TokenStream {
    let item_ast = match crate::expect_struct_or_enum(input) {
        Ok(i) => i,
        Err(ts) => return ts,
    };

    if let Some(empty) = check_empty_schema(&item_ast) {
        return empty;
    }

    let docs = extract_documentation(&item_ast.attrs);
    let docs = docs.trim();

    let props = SerdeProps::from_item_attrs(&item_ast.attrs);
    let name = &item_ast.ident;

    // Add `Apiv2Schema` bound for impl if the type is generic.
    let mut generics = item_ast.generics.clone();
    let bound = syn::parse2::<TraitBound>(quote!(paperclip::v2::schema::Apiv2Schema))
        .expect("expected to parse trait bound");
    generics.type_params_mut().for_each(|param| {
        param.bounds.push(bound.clone().into());
    });

    let opt_impl = add_optional_impl(&name, &generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // FIXME: Use attr path segments to find flattening, skipping, etc.
    let mut props_gen = quote! {};

    match &item_ast.data {
        Data::Struct(ref s) => {
            props_gen.extend(quote!(
                schema.data_type = Some(DataType::Object);
            ));
            match &s.fields {
                Fields::Named(ref f) => {
                    handle_field_struct(f, &item_ast.attrs, &props, &mut props_gen)
                }
                Fields::Unnamed(ref f) => {
                    handle_unnamed_field_struct(f, &item_ast.attrs, &mut props_gen)
                }
                Fields::Unit => {
                    emit_warning!(
                        s.struct_token.span().unwrap(),
                        "unit structs do not have any fields and hence will have empty schema.";
                        help = "{}", &*EMPTY_SCHEMA_HELP;
                    );
                }
            }
        }
        Data::Enum(ref e) => handle_enum(e, &props, &mut props_gen),
        Data::Union(ref u) => emit_error!(
            u.union_token.span().unwrap(),
            "unions are unsupported for deriving schema"
        ),
    };

    let schema_name = name.to_string();
    let props_gen_empty = props_gen.is_empty();
    let gen = quote! {
        impl #impl_generics paperclip::v2::schema::Apiv2Schema for #name #ty_generics #where_clause {
            const NAME: Option<&'static str> = Some(#schema_name);

            const DESCRIPTION: &'static str = #docs;

            fn raw_schema() -> paperclip::v2::models::DefaultSchemaRaw {
                use paperclip::v2::models::{DataType, DataTypeFormat, DefaultSchemaRaw};
                use paperclip::v2::schema::TypedData;

                let mut schema = DefaultSchemaRaw {
                    name: Some(#schema_name.into()), // Add name for later use.
                    .. Default::default()
                };
                #props_gen
                // props_gen may override the schema for unnamed structs with 1 element
                // as it replaces the struct type with inner type.
                // make sure we set the name properly if props_gen is not empty
                if !#props_gen_empty {
                    schema.name = Some(#schema_name.into());
                }
                schema
            }
        }

        #opt_impl
    };

    gen.into()
}

/// Actual parser and emitter for `Apiv2Security` derive macro.
pub fn emit_v2_security(input: TokenStream) -> TokenStream {
    let item_ast = match crate::expect_struct_or_enum(input) {
        Ok(i) => i,
        Err(ts) => return ts,
    };

    if let Some(empty) = check_empty_schema(&item_ast) {
        return empty;
    }

    let name = &item_ast.ident;
    // Add `Apiv2Schema` bound for impl if the type is generic.
    let mut generics = item_ast.generics.clone();
    let bound = syn::parse2::<TraitBound>(quote!(paperclip::v2::schema::Apiv2Schema))
        .expect("expected to parse trait bound");
    generics.type_params_mut().for_each(|param| {
        param.bounds.push(bound.clone().into());
    });

    let opt_impl = add_optional_impl(&name, &generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let mut security_attrs = HashMap::new();
    let mut scopes = Vec::new();

    let valid_attrs = vec![
        "alias",
        "description",
        "name",
        "in",
        "flow",
        "auth_url",
        "token_url",
        "parent",
    ];
    let invalid_attr_msg = format!("Invalid macro attribute. Should be bare security type [\"apiKey\", \"oauth2\"] or named attribute {:?}", valid_attrs);

    // Read security params from openapi attr.
    for nested in extract_openapi_attrs(&item_ast.attrs) {
        for nested_attr in nested {
            let span = nested_attr.span().unwrap();
            match &nested_attr {
                // Read bare attribute.
                NestedMeta::Meta(Meta::Path(attr_path)) => {
                    if let Some(type_) = attr_path.get_ident() {
                        if security_attrs
                            .insert("type".to_string(), type_.to_string())
                            .is_some()
                        {
                            emit_warning!(span, "Auth type defined multiple times.");
                        }
                    }
                }
                // Read named attribute.
                NestedMeta::Meta(Meta::NameValue(name_value)) => {
                    let attr_name = name_value.path.get_ident().map(|id| id.to_string());
                    let attr_value = &name_value.lit;

                    if let Some(attr_name) = attr_name {
                        if valid_attrs.contains(&attr_name.as_str()) {
                            if let Lit::Str(attr_value) = attr_value {
                                if security_attrs
                                    .insert(attr_name.clone(), attr_value.value())
                                    .is_some()
                                {
                                    emit_warning!(
                                        span,
                                        "Attribute {} defined multiple times.",
                                        attr_name
                                    );
                                }
                            } else {
                                emit_warning!(
                                    span,
                                    "Invalid value for named attribute: {}",
                                    attr_name
                                );
                            }
                        } else {
                            emit_warning!(span, invalid_attr_msg);
                        }
                    } else {
                        emit_error!(span, invalid_attr_msg);
                    }
                }
                // Read scopes attribute
                NestedMeta::Meta(Meta::List(list_attr)) => {
                    match list_attr
                        .path
                        .get_ident()
                        .map(|id| id.to_string())
                        .as_deref()
                    {
                        Some("scopes") => {
                            for nested in &list_attr.nested {
                                match nested {
                                    NestedMeta::Lit(Lit::Str(value)) => {
                                        scopes.push(value.value().to_string())
                                    }
                                    _ => emit_error!(
                                        nested.span().unwrap(),
                                        "Invalid list attribute value"
                                    ),
                                }
                            }
                        }
                        Some(path) => emit_error!(span, "Invalid list attribute: {}", path),
                        _ => emit_error!(span, "Invalid list attribute"),
                    }
                }
                _ => {
                    emit_error!(span, invalid_attr_msg);
                }
            }
        }
    }

    fn quote_option(value: Option<&String>) -> proc_macro2::TokenStream {
        if let Some(value) = value {
            quote! { Some(#value.to_string()) }
        } else {
            quote! { None }
        }
    }

    let scopes_stream = scopes
        .iter()
        .fold(proc_macro2::TokenStream::new(), |mut stream, scope| {
            stream.extend(quote! {
                oauth2_scopes.insert(#scope.to_string(), #scope.to_string());
            });
            stream
        });

    let (security_def, security_def_name) = match (
        security_attrs.get("type"),
        security_attrs.get("parent"),
    ) {
        (Some(type_), None) => {
            let alias = security_attrs.get("alias").unwrap_or(type_);
            let quoted_description = quote_option(security_attrs.get("description"));
            let quoted_name = quote_option(security_attrs.get("name"));
            let quoted_in = quote_option(security_attrs.get("in"));
            let quoted_flow = quote_option(security_attrs.get("flow"));
            let quoted_auth_url = quote_option(security_attrs.get("auth_url"));
            let quoted_token_url = quote_option(security_attrs.get("token_url"));

            (
                Some(quote! {
                    Some(paperclip::v2::models::SecurityScheme {
                        type_: #type_.to_string(),
                        name: #quoted_name,
                        in_: #quoted_in,
                        flow: #quoted_flow,
                        auth_url: #quoted_auth_url,
                        token_url: #quoted_token_url,
                        scopes: std::collections::BTreeMap::new(),
                        description: #quoted_description,
                    })
                }),
                Some(quote!(Some(#alias))),
            )
        }
        (None, Some(parent)) => {
            let parent_ident = Ident::new(parent, proc_macro2::Span::call_site());
            // Child of security definition (Scopes will be glued to parent definition).
            (
                Some(quote! {
                    let mut oauth2_scopes = std::collections::BTreeMap::new();
                    #scopes_stream
                    let mut scheme = #parent_ident::security_scheme()
                        .expect("empty schema. did you derive `Apiv2Security` for parent struct?");
                    scheme.scopes = oauth2_scopes;
                    Some(scheme)
                }),
                Some(quote!(<#parent_ident as paperclip::v2::schema::Apiv2Schema>::NAME)),
            )
        }
        (Some(_), Some(_)) => {
            emit_error!(
                item_ast.span().unwrap(),
                "Can't define new security type and use parent attribute together."
            );
            (None, None)
        }
        (None, None) => {
            emit_error!(
                item_ast.span().unwrap(),
                "Invalid attributes. Expected security type or parent defined."
            );
            (None, None)
        }
    };

    let gen = if let (Some(def_block), Some(def_name)) = (security_def, security_def_name) {
        quote! {
            impl #impl_generics paperclip::v2::schema::Apiv2Schema for #name #ty_generics #where_clause {
                const NAME: Option<&'static str> = #def_name;

                fn security_scheme() -> Option<paperclip::v2::models::SecurityScheme> {
                    #def_block
                }
            }

            #opt_impl
        }
    } else {
        quote! {}
    };

    gen.into()
}

#[cfg(feature = "nightly")]
fn add_optional_impl(_: &Ident, _: &Generics) -> proc_macro2::TokenStream {
    // Empty impl for "nightly" feature because specialization helps us there.
    quote!()
}

#[cfg(not(feature = "nightly"))]
fn add_optional_impl(name: &Ident, generics: &Generics) -> proc_macro2::TokenStream {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    quote! {
        impl #impl_generics paperclip::actix::OperationModifier for #name #ty_generics #where_clause {}
    }
}

fn get_field_type(field: &Field) -> Option<proc_macro2::TokenStream> {
    match field.ty {
        Type::Path(_) | Type::Reference(_) => Some(address_type_for_fn_call(&field.ty)),
        _ => {
            emit_warning!(
                field.ty.span().unwrap(),
                "unsupported field type will be ignored."
            );
            None
        }
    }
}

/// Generates code for a tuple struct with fields.
fn handle_unnamed_field_struct(
    fields: &FieldsUnnamed,
    struct_attr: &[Attribute],
    props_gen: &mut proc_macro2::TokenStream,
) {
    if fields.unnamed.len() == 1 {
        let field = fields.unnamed.iter().next().unwrap();

        if let Some(ty_ref) = get_field_type(&field) {
            let docs = extract_documentation(struct_attr);
            let docs = docs.trim();

            props_gen.extend(quote!({
                let mut s = #ty_ref::raw_schema();
                if !#docs.is_empty() {
                    s.description = Some(#docs.to_string());
                }
                schema = s;
            }));
        }
    } else {
        for (inner_field_id, field) in (&fields.unnamed).into_iter().enumerate() {
            let ty_ref = get_field_type(&field);

            let docs = extract_documentation(&field.attrs);
            let docs = docs.trim();

            let mut gen = if !SerdeFlatten::exists(&field.attrs) {
                // this is really not what we'd want to do because that's not how the
                // deserialized struct will be like, ideally we want an actual tuple
                // this type should therefore not be used for anything else than `Path`
                quote!({
                    let mut s = #ty_ref::raw_schema();
                    if !#docs.is_empty() {
                        s.description = Some(#docs.to_string());
                    }
                    schema.properties.insert(#inner_field_id.to_string(), s.into());
                })
            } else {
                quote!({
                    let s = #ty_ref::raw_schema();
                    schema.properties.extend(s.properties);
                })
            };

            gen.extend(quote! {
                if #ty_ref::REQUIRED {
                    schema.required.insert(#inner_field_id.to_string());
                }
            });

            props_gen.extend(gen);
        }
    }
}

/// Checks for `api_v2_empty` attributes and removes them.
fn extract_openapi_attrs(
    field_attrs: &'_ [Attribute],
) -> impl Iterator<Item = Punctuated<syn::NestedMeta, syn::token::Comma>> + '_ {
    field_attrs.iter().filter_map(|a| match a.parse_meta() {
        Ok(Meta::List(list)) if list.path.is_ident("openapi") => Some(list.nested),
        _ => None,
    })
}

/// Checks for `api_v2_empty` attributes and removes them.
fn extract_documentation(attrs: &[Attribute]) -> String {
    attrs
        .iter()
        .filter_map(|a| match a.parse_meta() {
            Ok(Meta::NameValue(mnv)) if mnv.path.is_ident("doc") => match &mnv.lit {
                Lit::Str(s) => Some(s.value()),
                _ => None,
            },
            _ => None,
        })
        .collect::<Vec<String>>()
        .join("\n")
}

/// Checks if an empty schema has been requested and generate if needed.
fn check_empty_schema(item_ast: &DeriveInput) -> Option<TokenStream> {
    let needs_empty_schema = extract_openapi_attrs(&item_ast.attrs).any(|nested| {
        nested.len() == 1
            && match &nested[0] {
                NestedMeta::Meta(Meta::Path(path)) => path.is_ident("empty"),
                _ => false,
            }
    });

    if needs_empty_schema {
        let name = &item_ast.ident;
        let generics = item_ast.generics.clone();
        let opt_impl = add_optional_impl(&name, &generics);
        let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
        return Some(quote!(
            impl #impl_generics paperclip::v2::schema::Apiv2Schema for #name #ty_generics #where_clause {}

            #opt_impl
        ).into());
    }

    None
}

/// Generates code for a struct with fields.
fn handle_field_struct(
    fields: &FieldsNamed,
    struct_attr: &[Attribute],
    serde: &SerdeProps,
    props_gen: &mut proc_macro2::TokenStream,
) {
    let docs = extract_documentation(struct_attr);
    let docs = docs.trim();

    props_gen.extend(quote!({
        if !#docs.is_empty() {
            schema.description = Some(#docs.to_string());
        }
    }));
    for field in &fields.named {
        let mut field_name = field
            .ident
            .as_ref()
            .expect("missing field name?")
            .to_string();

        if let Some(renamed) = SerdeRename::from_field_attrs(&field.attrs) {
            field_name = renamed;
        } else if let Some(prop) = serde.rename {
            field_name = prop.rename(&field_name);
        }

        let ty_ref = get_field_type(&field);

        let docs = extract_documentation(&field.attrs);
        let docs = docs.trim();

        let mut gen = if !SerdeFlatten::exists(&field.attrs) {
            quote!({
                let mut s = #ty_ref::raw_schema();
                if !#docs.is_empty() {
                    s.description = Some(#docs.to_string());
                }
                schema.properties.insert(#field_name.into(), s.into());
            })
        } else {
            quote!({
                let s = #ty_ref::raw_schema();
                schema.properties.extend(s.properties);
            })
        };

        gen.extend(quote! {
            if #ty_ref::REQUIRED {
                schema.required.insert(#field_name.into());
            }
        });

        props_gen.extend(gen);
    }
}

/// Generates code for an enum (if supported).
fn handle_enum(e: &DataEnum, serde: &SerdeProps, props_gen: &mut proc_macro2::TokenStream) {
    props_gen.extend(quote!(
        schema.data_type = Some(DataType::String);
    ));

    for var in &e.variants {
        let mut name = var.ident.to_string();
        match &var.fields {
            Fields::Unit => (),
            Fields::Named(ref f) => {
                emit_warning!(
                    f.span().unwrap(),
                    "skipping enum variant with named fields in schema."
                );
                continue;
            }
            Fields::Unnamed(ref f) => {
                emit_warning!(f.span().unwrap(), "skipping tuple enum variant in schema.");
                continue;
            }
        }

        if let Some(renamed) = SerdeRename::from_field_attrs(&var.attrs) {
            name = renamed;
        } else if let Some(prop) = serde.rename {
            name = prop.rename(&name);
        }

        props_gen.extend(quote!(
            schema.enum_.push(serde_json::json!(#name));
        ));
    }
}

/// An associated function of a generic type, say, a vector cannot be called
/// like `Vec::foo` as it doesn't have a default type. We should instead call
/// `Vec::<T>::foo`. Something similar applies to `str`. This function takes
/// care of that special treatment.
fn address_type_for_fn_call(old_ty: &Type) -> proc_macro2::TokenStream {
    if let Type::Reference(_) = old_ty {
        return quote!(<(#old_ty)>);
    }

    let mut ty = old_ty.clone();
    if let Type::Path(ref mut p) = &mut ty {
        p.path.segments.pairs_mut().for_each(|mut pair| {
            let is_empty = pair.value().arguments.is_empty();
            let args = &mut pair.value_mut().arguments;
            match args {
                PathArguments::AngleBracketed(ref mut brack_args) if !is_empty => {
                    brack_args.colon2_token = Some(Token![::](proc_macro2::Span::call_site()));
                }
                _ => (),
            }
        });
    }

    quote!(#ty)
}

/* Serde attributes */

/// Supported renaming options in serde (https://serde.rs/variant-attrs.html).
#[derive(Clone, Copy, Debug, Eq, PartialEq, EnumString)]
enum SerdeRename {
    #[strum(serialize = "lowercase")]
    Lower,
    #[strum(serialize = "UPPERCASE")]
    Upper,
    #[strum(serialize = "PascalCase")]
    Pascal,
    #[strum(serialize = "camelCase")]
    Camel,
    #[strum(serialize = "snake_case")]
    Snake,
    #[strum(serialize = "SCREAMING_SNAKE_CASE")]
    ScreamingSnake,
    #[strum(serialize = "kebab-case")]
    Kebab,
    #[strum(serialize = "SCREAMING-KEBAB-CASE")]
    ScreamingKebab,
}

impl SerdeRename {
    /// Traverses the field attributes and returns the renamed value from the first matching
    /// `#[serde(rename = "...")]` pattern.
    fn from_field_attrs(field_attrs: &[Attribute]) -> Option<String> {
        for meta in field_attrs.iter().filter_map(|a| a.parse_meta().ok()) {
            let inner_meta = match meta {
                Meta::List(ref l)
                    if l.path
                        .segments
                        .last()
                        .map(|p| p.ident == "serde")
                        .unwrap_or(false) =>
                {
                    &l.nested
                }
                _ => continue,
            };

            for meta in inner_meta {
                let rename = match meta {
                    NestedMeta::Meta(Meta::NameValue(ref v))
                        if v.path
                            .segments
                            .last()
                            .map(|p| p.ident == "rename")
                            .unwrap_or(false) =>
                    {
                        &v.lit
                    }
                    _ => continue,
                };

                if let Lit::Str(ref s) = rename {
                    return Some(s.value());
                }
            }
        }

        None
    }

    /// Renames the given value using the current option.
    fn rename(self, name: &str) -> String {
        match self {
            SerdeRename::Lower => name.to_lowercase(),
            SerdeRename::Upper => name.to_uppercase(),
            SerdeRename::Pascal => name.to_camel_case(),
            SerdeRename::Camel => name.to_mixed_case(),
            SerdeRename::Snake => name.to_snek_case(),
            SerdeRename::ScreamingSnake => name.to_snek_case().to_uppercase(),
            SerdeRename::Kebab => name.to_kebab_case(),
            SerdeRename::ScreamingKebab => name.to_kebab_case().to_uppercase(),
        }
    }
}

#[derive(Clone, Debug, Default)]
struct SerdeProps {
    rename: Option<SerdeRename>,
}

impl SerdeProps {
    /// Traverses the serde attributes in the given item attributes and returns
    /// the applicable properties.
    fn from_item_attrs(item_attrs: &[Attribute]) -> Self {
        let mut props = Self::default();
        for meta in item_attrs.iter().filter_map(|a| a.parse_meta().ok()) {
            let inner_meta = match meta {
                Meta::List(ref l)
                    if l.path
                        .segments
                        .last()
                        .map(|p| p.ident == "serde")
                        .unwrap_or(false) =>
                {
                    &l.nested
                }
                _ => continue,
            };

            for meta in inner_meta {
                let global_rename = match meta {
                    NestedMeta::Meta(Meta::NameValue(ref v))
                        if v.path
                            .segments
                            .last()
                            .map(|p| p.ident == "rename_all")
                            .unwrap_or(false) =>
                    {
                        &v.lit
                    }
                    _ => continue,
                };

                if let Lit::Str(ref s) = global_rename {
                    props.rename = s.value().parse().ok();
                }
            }
        }

        props
    }
}

/// Supported flattening of embedded struct (https://serde.rs/variant-attrs.html).
struct SerdeFlatten;

impl SerdeFlatten {
    /// Traverses the field attributes and returns true if there is `#[serde(flatten)]`.
    fn exists(field_attrs: &[Attribute]) -> bool {
        for meta in field_attrs.iter().filter_map(|a| a.parse_meta().ok()) {
            let inner_meta = match meta {
                Meta::List(ref l)
                    if l.path
                        .segments
                        .last()
                        .map(|p| p.ident == "serde")
                        .unwrap_or(false) =>
                {
                    &l.nested
                }
                _ => continue,
            };

            for meta in inner_meta {
                if let NestedMeta::Meta(Meta::Path(syn::Path { segments, .. })) = meta {
                    if segments.iter().any(|p| p.ident == "flatten") {
                        return true;
                    }
                }
            }
        }

        false
    }
}

macro_rules! doc_comment {
    ($x:expr; $($tt:tt)*) => {
        #[doc = $x]
        $($tt)*
    };
}

#[cfg(feature = "actix")]
impl super::Method {
    fn handler_uri(attr: TokenStream) -> TokenStream {
        let attr = parse_macro_input!(attr as syn::AttributeArgs);
        attr.first().into_token_stream().into()
    }
    fn handler_name(item: TokenStream) -> syn::Result<syn::Ident> {
        let handler: ItemFn = syn::parse(item)?;
        Ok(handler.sig.ident)
    }
    pub(crate) fn generate(
        &self,
        attr: TokenStream,
        item: TokenStream,
    ) -> syn::Result<proc_macro2::TokenStream> {
        let uri: proc_macro2::TokenStream = Self::handler_uri(attr).into();
        let handler_name = Self::handler_name(item.clone())?;
        let handler_fn: proc_macro2::TokenStream = item.into();
        let method: proc_macro2::TokenStream = self.method().parse()?;
        let variant: proc_macro2::TokenStream = self.variant().parse()?;
        let handler_name_str = handler_name.to_string();

        Ok(quote! {
            #[allow(non_camel_case_types, missing_docs)]
            pub struct #handler_name;

            impl #handler_name {
                fn resource() -> paperclip::actix::web::Resource {
                    #handler_fn
                    paperclip::actix::web::Resource::new(#uri)
                        .name(#handler_name_str)
                        .guard(actix_web::guard::#variant())
                        .route(paperclip::actix::web::#method().to(#handler_name))
                }
            }

            impl actix_web::dev::HttpServiceFactory for #handler_name {
                fn register(self, config: &mut actix_web::dev::AppService) {
                    Self::resource().register(config);
                }
            }

            impl paperclip::actix::Mountable for #handler_name {
                fn path(&self) -> &str {
                    #uri
                }

                fn operations(
                    &mut self,
                ) -> std::collections::BTreeMap<
                    paperclip::v2::models::HttpMethod,
                    paperclip::v2::models::DefaultOperationRaw,
                > {
                    Self::resource().operations()
                }

                fn definitions(
                    &mut self,
                ) -> std::collections::BTreeMap<
                    String,
                    paperclip::v2::models::DefaultSchemaRaw,
                > {
                    Self::resource().definitions()
                }

                fn security_definitions(
                    &mut self,
                ) -> std::collections::BTreeMap<String, paperclip::v2::models::SecurityScheme>
                {
                    Self::resource().security_definitions()
                }
            }
        })
    }
}

#[macro_use]
macro_rules! rest_methods {
    (
        $($variant:ident, $method:ident, )+
    ) => {
        /// All available Rest methods
        #[derive(Debug, PartialEq, Eq, Hash)]
        pub(crate) enum Method {
            $(
                $variant,
            )+
        }

        impl Method {
            fn method(&self) -> &'static str {
                match self {
                    $(Self::$variant => stringify!($method),)+
                }
            }
            fn variant(&self) -> &'static str {
                match self {
                    $(Self::$variant => stringify!($variant),)+
                }
            }
        }

        $(doc_comment! {
            concat!("
Creates route handler with `paperclip::actix::web::Resource", "`.
In order to control the output type and status codes the return value/response must implement the
trait actix_web::Responder.

# Syntax
```text
#[", stringify!($method), r#"("path"[, attributes])]
```

# Attributes
- `"path"` - Raw literal string with path for which to register handler.

# Example

/// use paperclip::actix::web::Json;
/// use paperclip_macros::"#, stringify!($method), ";
/// #[", stringify!($method), r#"("/")]
/// async fn example() {
/// }
"#);
            #[cfg(feature = "actix")]
            #[proc_macro_attribute]
            pub fn $method(attr: TokenStream, item: TokenStream) -> TokenStream {
                match Method::$variant.generate(attr, item) {
                    Ok(v) => v.into(),
                    Err(e) => e.to_compile_error().into(),
                }
            }
        })+
    };
}

'''
'''--- macros/src/core.rs ---
//! Convenience macros for paperclip (exposed by default).

use proc_macro::TokenStream;
use quote::quote;
use syn::{spanned::Spanned, Data, DeriveInput, Fields, FieldsNamed, Ident};

/// Actual parser and emitter for `api_v2_schema_struct` macro.
pub fn emit_v2_schema_struct(input: TokenStream) -> TokenStream {
    let mut item_ast = match crate::expect_struct_or_enum(input) {
        Ok(i) => i,
        Err(ts) => return ts,
    };

    let name = item_ast.ident.clone();
    let generics = item_ast.generics.clone();
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Generate raw schema struct.
    let mut raw_item_ast = item_ast.clone();
    let raw_defaults = match raw_schema(&mut raw_item_ast) {
        Ok(s) => s,
        Err(ts) => return ts,
    };

    let raw_struct_name = &raw_item_ast.ident;
    let mut gen = quote!(
        /// Raw version of schema.
        ///
        /// **NOTE:** This doesn't have smart pointers to reuse definitions
        /// throughout the spec. Instead, it contains the actual schema with
        /// unresolvable `$ref` fields.
        ///
        #raw_item_ast
    );

    let defaults = match actual_schema(&mut item_ast) {
        Ok(s) => s,
        Err(ts) => return ts,
    };

    gen.extend(quote! {
        #item_ast

        impl Default for #name {
            fn default() -> Self {
                #name {
                    #defaults
                }
            }
        }

        impl Default for #raw_struct_name {
            fn default() -> Self {
                #raw_struct_name {
                    #raw_defaults
                }
            }
        }

        impl #raw_struct_name {
            /// Recursively removes all `$ref` values in this schema.
            pub fn remove_refs(&mut self) {
                self.properties.values_mut().for_each(|s| s.remove_refs());
                self.items.as_mut().map(|s| s.remove_refs());
                self.extra_props.as_mut().and_then(|s| s.right_mut()).map(|s| s.remove_refs());
                self.reference = None;
            }

            /// Recursively removes all properties other than `$ref` value
            /// if the `$ref` is non-null.
            pub fn retain_ref(&mut self) {
                if self.reference.is_some() {
                    let ref_ = self.reference.take();
                    *self = Self::default();
                    self.reference = ref_;
                } else {
                    self.properties.values_mut().for_each(|s| s.retain_ref());
                    self.items.as_mut().map(|s| s.retain_ref());
                    self.extra_props.as_mut().and_then(|s| s.right_mut()).map(|s| s.retain_ref());
                }
            }
        }

        impl #impl_generics paperclip::v2::Schema for #name #ty_generics #where_clause {
            #[inline]
            fn name(&self) -> Option<&str> {
                self.name.as_ref().map(String::as_str)
            }

            #[inline]
            fn set_name(&mut self, name: &str) {
                self.name = Some(name.into());
            }

            #[inline]
            fn set_cyclic(&mut self, cyclic: bool) {
                self.cyclic = cyclic;
            }

            #[inline]
            fn is_cyclic(&self) -> bool {
                self.cyclic
            }

            #[inline]
            fn description(&self) -> Option<&str> {
                self.description.as_ref().map(String::as_str)
            }

            #[inline]
            fn reference(&self) -> Option<&str> {
                self.reference.as_ref().map(String::as_str)
            }

            #[inline]
            fn set_reference(&mut self, ref_: String) {
                self.reference = Some(ref_);
            }

            #[inline]
            fn data_type(&self) -> Option<paperclip::v2::models::DataType> {
                self.data_type
            }

            #[inline]
            fn format(&self) -> Option<&paperclip::v2::models::DataTypeFormat> {
                self.format.as_ref()
            }

            #[inline]
            fn items(&self) -> Option<&paperclip::v2::models::Resolvable<Self>> {
                self.items.as_ref()
            }

            #[inline]
            fn items_mut(&mut self) -> Option<&mut paperclip::v2::models::Resolvable<Self>> {
                self.items.as_mut()
            }

            #[inline]
            fn additional_properties(&self) -> Option<&paperclip::v2::models::Either<bool, paperclip::v2::models::Resolvable<Self>>> {
                self.extra_props.as_ref()
            }

            #[inline]
            fn additional_properties_mut(&mut self) -> Option<&mut paperclip::v2::models::Either<bool, paperclip::v2::models::Resolvable<Self>>> {
                self.extra_props.as_mut()
            }

            #[inline]
            fn properties(&self) -> Option<&std::collections::BTreeMap<String, paperclip::v2::models::Resolvable<Self>>> {
                if self.properties.is_empty() {
                    None
                } else {
                    Some(&self.properties)
                }
            }

            #[inline]
            fn properties_mut(&mut self) -> Option<&mut std::collections::BTreeMap<String, paperclip::v2::models::Resolvable<Self>>> {
                if self.properties.is_empty() {
                    None
                } else {
                    Some(&mut self.properties)
                }
            }

            #[inline]
            fn required_properties(&self) -> Option<&std::collections::BTreeSet<String>> {
                if self.required.is_empty() {
                    None
                } else {
                    Some(&self.required)
                }
            }

            #[inline]
            fn enum_variants(&self) -> Option<&[serde_json::Value]> {
                if self.enum_.is_empty() {
                    return None
                } else {
                    Some(&self.enum_)
                }
            }
        }
    });

    gen.into()
}

/// Generates a raw schema struct with suffix "{structName}Raw".
fn raw_schema(item_ast: &mut DeriveInput) -> Result<proc_macro2::TokenStream, TokenStream> {
    let ident = Ident::new(
        &format!("{}Raw", item_ast.ident),
        proc_macro2::Span::call_site(),
    );
    item_ast.ident = ident.clone();

    let fields = named_fields(item_ast)?;
    let default_fields: FieldsNamed =
        syn::parse2(schema_fields(&ident, false)).expect("parsing schema fields?");
    fields.named.extend(default_fields.named);

    let mut defaults = quote!();
    for field in &fields.named {
        let f_name = field.ident.as_ref().expect("fields not named?");
        defaults.extend(quote!(#f_name: Default::default(),));
    }

    Ok(defaults)
}

/// Generates the actual schema struct with the actual name.
fn actual_schema(item_ast: &mut DeriveInput) -> Result<proc_macro2::TokenStream, TokenStream> {
    let name = item_ast.ident.clone();
    let fields = named_fields(item_ast)?;

    let default_fields: FieldsNamed =
        syn::parse2(schema_fields(&name, true)).expect("parsing schema fields?");
    fields.named.extend(default_fields.named);

    let mut defaults = quote!();
    for field in &fields.named {
        let f_name = field.ident.as_ref().expect("fields not named?");
        defaults.extend(quote!(#f_name: Default::default(),));
    }

    Ok(defaults)
}

/// Extracts named fields from the given struct.
fn named_fields(item_ast: &mut DeriveInput) -> Result<&mut FieldsNamed, TokenStream> {
    let span = item_ast.span();
    if let Data::Struct(s) = &mut item_ast.data {
        match &mut s.fields {
            Fields::Named(ref mut f) => Ok(f),
            Fields::Unnamed(ref f) => Err(crate::span_error_with_msg(
                f,
                "expected struct with zero or more fields for schema",
            )),
            f @ Fields::Unit => {
                *f = Fields::Named(syn::parse2(quote!({})).expect("parsing empty named fields"));
                match f {
                    Fields::Named(ref mut f) => Ok(f),
                    _ => unreachable!(),
                }
            }
        }
    } else {
        emit_error!(span.unwrap(), "expected struct for schema");
        Err(quote!().into())
    }
}

/// Generates fields for a schema struct using its name. Also takes a
/// boolean to indicate whether this struct's fields hold references.
fn schema_fields(name: &Ident, is_ref: bool) -> proc_macro2::TokenStream {
    let mut gen = quote!();
    let add_self = |gen: &mut proc_macro2::TokenStream| {
        if is_ref {
            gen.extend(quote!(paperclip::v2::models::Resolvable<#name>));
        } else {
            gen.extend(quote!(Box<#name>));
        }
    };

    gen.extend(quote!(
        #[serde(rename = "$ref", skip_serializing_if = "Option::is_none")]
        pub reference: Option<String>,
    ));
    gen.extend(quote!(
        #[serde(skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
    ));
    gen.extend(quote!(
        #[serde(skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
    ));
    gen.extend(quote!(
        #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
        pub data_type: Option<paperclip::v2::models::DataType>,
    ));
    gen.extend(quote!(
        #[serde(skip_serializing_if = "Option::is_none")]
        pub format: Option<paperclip::v2::models::DataTypeFormat>,
    ));
    gen.extend(quote!(
        #[serde(skip_serializing_if = "Option::is_none")]
        pub example: Option<String>,
    ));

    gen.extend(quote!(
        #[serde(default, skip_serializing_if = "std::collections::BTreeMap::is_empty")]
        pub properties: std::collections::BTreeMap<String,
    ));
    add_self(&mut gen);
    gen.extend(quote!(>,));

    gen.extend(quote!(
        #[serde(skip_serializing_if = "Option::is_none")]
        pub items: Option<
    ));
    add_self(&mut gen);
    gen.extend(quote!(>,));

    gen.extend(quote!(
        #[serde(default, rename = "enum", skip_serializing_if = "Vec::is_empty")]
        pub enum_: Vec<serde_json::Value>,
    ));

    gen.extend(quote!(
        #[serde(rename = "additionalProperties", skip_serializing_if = "Option::is_none")]
        pub extra_props: Option<paperclip::v2::models::Either<bool,
    ));
    add_self(&mut gen);
    gen.extend(quote!(>>,));

    gen.extend(quote!(
        #[serde(default, skip_serializing_if = "std::collections::BTreeSet::is_empty")]
        pub required: std::collections::BTreeSet<String>,
    ));

    if is_ref {
        gen.extend(quote!(
            #[serde(skip)]
            cyclic: bool,
        ));
    }

    quote!({
        #[doc(hidden)]
        #[serde(skip)]
        pub name: Option<String>,
        #gen
    })
}

'''
'''--- macros/src/lib.rs ---
//! Convenience macros for [paperclip](https://github.com/wafflespeanut/paperclip).
//!
//! You shouldn't need to depend on this, because the stuff here is
//! already exposed by the corresponding crates.

#![recursion_limit = "512"]

extern crate proc_macro;
#[macro_use]
extern crate proc_macro_error;

#[cfg(feature = "actix")]
#[macro_use]
mod actix;
#[cfg(feature = "v2")]
mod core;

use proc_macro::TokenStream;
use quote::quote;
use syn::{
    parse::{Parse, ParseStream},
    punctuated::Punctuated,
    spanned::Spanned,
    token::Comma,
    DeriveInput, NestedMeta,
};

/// Converts your struct to support deserializing from an OpenAPI v2
/// [Schema](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject)
/// object ([example](https://paperclip.waffles.space/paperclip/v2/)). This adds the necessary fields (in addition to your own fields) and implements the
/// `Schema` trait for parsing and codegen.
#[cfg(feature = "v2")]
#[proc_macro_attribute]
pub fn api_v2_schema_struct(_attr: TokenStream, input: TokenStream) -> TokenStream {
    self::core::emit_v2_schema_struct(input)
}

/// Marker attribute for indicating that a function is an OpenAPI v2 compatible operation.
#[cfg(feature = "actix")]
#[proc_macro_error]
#[proc_macro_attribute]
pub fn api_v2_operation(attr: TokenStream, input: TokenStream) -> TokenStream {
    self::actix::emit_v2_operation(attr, input)
}

/// Derive attribute for indicating that a type is an OpenAPI v2 compatible definition.
#[cfg(feature = "actix")]
#[proc_macro_error]
#[proc_macro_derive(Apiv2Schema, attributes(openapi))]
pub fn api_v2_schema(input: TokenStream) -> TokenStream {
    self::actix::emit_v2_definition(input)
}

/// Marker attribute for indicating that an object forbids public access to operation (for example AccessToken).
#[cfg(feature = "actix")]
#[proc_macro_error]
#[proc_macro_derive(Apiv2Security, attributes(openapi))]
pub fn api_v2_security(input: TokenStream) -> TokenStream {
    self::actix::emit_v2_security(input)
}

/// Marker attribute for indicating that the marked object can represent non-2xx (error)
/// status codes with optional descriptions.
#[cfg(feature = "actix")]
#[proc_macro_error]
#[proc_macro_attribute]
pub fn api_v2_errors(attrs: TokenStream, input: TokenStream) -> TokenStream {
    self::actix::emit_v2_errors(attrs, input)
}

/// Generate an error at the call site and return empty token stream.
#[allow(dead_code)]
fn span_error_with_msg<T: Spanned>(it: &T, msg: &str) -> TokenStream {
    emit_error!(it.span().unwrap(), msg);
    (quote! {}).into()
}

/// Parses this token stream expecting a struct/enum and fails with an error otherwise.
#[allow(dead_code)]
fn expect_struct_or_enum(ts: TokenStream) -> Result<DeriveInput, TokenStream> {
    syn::parse(ts).map_err(|e| {
        emit_error!(
            e.span().unwrap(),
            "expected struct or enum for deriving schema."
        );
        quote!().into()
    })
}

/// Helper struct for parsing proc-macro input attributes.
#[derive(Default)]
struct MacroAttribute(Punctuated<NestedMeta, Comma>);

impl Parse for MacroAttribute {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        Ok(MacroAttribute(input.call(Punctuated::parse_terminated)?))
    }
}

#[cfg(feature = "actix")]
fn parse_input_attrs(ts: TokenStream) -> MacroAttribute {
    syn::parse(ts)
        .map_err(|e| {
            emit_warning!(
                e.span().unwrap(),
                "cannot parse proc-macro input attributes."
            );
        })
        .ok()
        .unwrap_or_default()
}

#[cfg(feature = "actix")]
rest_methods! {
    Get,    get,
    Post,   post,
    Put,    put,
    Delete, delete,
}

'''
'''--- plugins/actix-web/Cargo.toml ---
[package]
name = "paperclip-actix"
version = "0.3.0"
authors = ["Ravi Shankar <wafflespeanut@gmail.com>"]
edition = "2018"
description = "Paperclip OpenAPI plugin for actix-web framework"
documentation = "https://paperclip.waffles.space/paperclip_actix"
license = "MIT OR Apache-2.0"
homepage = "https://github.com/wafflespeanut/paperclip"
repository = "https://github.com/wafflespeanut/paperclip"

[dependencies]
futures = "0.3"
actix-service = "2.0.0-beta.4"
actix-web2 = { version = "2", default-features = false, optional = true, package = "actix-web" }
actix-web3 = { version = "3", default-features = false, optional = true, package = "actix-web" }
actix-web4 = { version = "4.0.0-beta.6", default-features = false, optional = true, package = "actix-web" }
paperclip-core = { path = "../../core", version = "0.3.0", optional = true }
paperclip-macros = { path = "../../macros", version = "0.4.0", features = ["actix"] }
parking_lot = ">=0.10,<0.12"
serde_json = "1.0"
once_cell = "1.4"

[features]
actix = ["actix4"]
actix2 = ["actix-web2", "paperclip-core/actix2"]
actix3 = ["actix-web3", "paperclip-core/actix3"]
actix4 = ["actix-web4", "paperclip-core/actix4"]
nightly = ["paperclip-core/nightly"]
normalize = []

'''
'''--- plugins/actix-web/src/lib.rs ---
#[cfg(feature = "actix2")]
extern crate actix_web2 as actix_web;
#[cfg(feature = "actix3")]
extern crate actix_web3 as actix_web;
#[cfg(feature = "actix4")]
extern crate actix_web4 as actix_web;

pub mod web;

pub use self::web::{Resource, Route, Scope};
pub use paperclip_macros::{
    api_v2_errors, api_v2_operation, delete, get, post, put, Apiv2Schema, Apiv2Security,
};

use self::web::{RouteWrapper, ServiceConfig};
use actix_service::ServiceFactory;
use actix_web::{
    dev::{HttpServiceFactory, MessageBody, ServiceRequest, ServiceResponse, Transform},
    Error, HttpResponse,
};
use futures::future::{ok as fut_ok, Ready};
use paperclip_core::v2::models::{
    DefaultApiRaw, DefaultOperationRaw, DefaultPathItemRaw, DefaultSchemaRaw, HttpMethod,
    SecurityScheme,
};
use parking_lot::RwLock;

use std::{collections::BTreeMap, fmt::Debug, future::Future, sync::Arc};

/// Wrapper for [`actix_web::App`](https://docs.rs/actix-web/*/actix_web/struct.App.html).
pub struct App<T, B> {
    spec: Arc<RwLock<DefaultApiRaw>>,
    inner: Option<actix_web::App<T, B>>,
}

/// Extension trait for actix-web applications.
pub trait OpenApiExt<T, B> {
    type Wrapper;

    /// Consumes this app and produces its wrapper to start tracking
    /// paths and their corresponding operations.
    fn wrap_api(self) -> Self::Wrapper;

    /// Same as `wrap_api` initializing with provided specification
    /// defaults. Useful for defining Api properties outside of definitions and
    /// paths.
    fn wrap_api_with_spec(self, spec: DefaultApiRaw) -> Self::Wrapper;
}

impl<T, B> OpenApiExt<T, B> for actix_web::App<T, B> {
    type Wrapper = App<T, B>;

    fn wrap_api(self) -> Self::Wrapper {
        App {
            spec: Arc::new(RwLock::new(DefaultApiRaw::default())),
            inner: Some(self),
        }
    }

    fn wrap_api_with_spec(self, spec: DefaultApiRaw) -> Self::Wrapper {
        App {
            spec: Arc::new(RwLock::new(spec)),
            inner: Some(self),
        }
    }
}

/// Indicates that this thingmabob has a path and a bunch of definitions and operations.
pub trait Mountable {
    /// Where this thing gets mounted.
    fn path(&self) -> &str;

    /// Map of HTTP methods and the associated API operations.
    fn operations(&mut self) -> BTreeMap<HttpMethod, DefaultOperationRaw>;

    /// The definitions recorded by this object.
    fn definitions(&mut self) -> BTreeMap<String, DefaultSchemaRaw>;

    /// The security definitions recorded by this object.
    fn security_definitions(&mut self) -> BTreeMap<String, SecurityScheme>;

    /// Updates the given map of operations with operations tracked by this object.
    ///
    /// **NOTE:** Overriding implementations must ensure that the `PathItem`
    /// is normalized before updating the input map.
    fn update_operations(&mut self, map: &mut BTreeMap<String, DefaultPathItemRaw>) {
        let op_map = map
            .entry(self.path().into())
            .or_insert_with(Default::default);
        op_map.methods.extend(self.operations().into_iter());
    }
}

impl<T, B> App<T, B>
where
    B: MessageBody,
    T: ServiceFactory<
        ServiceRequest,
        Config = (),
        Response = ServiceResponse<B>,
        Error = Error,
        InitError = (),
    >,
{
    /// Proxy for [`actix_web::App::data`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn data<U: 'static>(mut self, data: U) -> Self {
        self.inner = self.inner.take().map(|a| a.data(data));
        self
    }

    /// Proxy for [`actix_web::App::data_factory`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.data_factory).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn data_factory<F, Out, D, E>(mut self, data: F) -> Self
    where
        F: Fn() -> Out + 'static,
        Out: Future<Output = Result<D, E>> + 'static,
        D: 'static,
        E: Debug,
    {
        self.inner = self.inner.take().map(|a| a.data_factory(data));
        self
    }

    /// Proxy for [`actix_web::App::app_data`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.app_data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn app_data<U: 'static>(mut self, data: U) -> Self {
        self.inner = self.inner.take().map(|a| a.app_data(data));
        self
    }

    /// Wrapper for [`actix_web::App::configure`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.configure).
    pub fn configure<F>(mut self, f: F) -> Self
    where
        F: FnOnce(&mut ServiceConfig),
    {
        self.inner = self.inner.take().map(|s| {
            s.configure(|c| {
                let mut cfg = ServiceConfig::from(c);
                f(&mut cfg);
                self.update_from_mountable(&mut cfg);
            })
        });
        self
    }

    /// Wrapper for [`actix_web::App::route`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.route).
    pub fn route(mut self, path: &str, route: Route) -> Self {
        let mut w = RouteWrapper::from(path, route);
        self.update_from_mountable(&mut w);
        self.inner = self.inner.take().map(|a| a.route(path, w.inner));
        self
    }

    /// Wrapper for [`actix_web::App::service`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.service).
    pub fn service<F>(mut self, mut factory: F) -> Self
    where
        F: Mountable + HttpServiceFactory + 'static,
    {
        self.update_from_mountable(&mut factory);
        self.inner = self.inner.take().map(|a| a.service(factory));
        self
    }

    /// Proxy for [`actix_web::App::default_service`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.default_service).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn default_service<F, U>(mut self, f: F) -> Self
    where
        F: actix_service::IntoServiceFactory<U, ServiceRequest>,
        U: ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            > + 'static,
        U::InitError: Debug,
    {
        self.inner = self.inner.take().map(|a| a.default_service(f));
        self
    }

    /// Proxy for [`actix_web::App::external_resource`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.external_resource).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn external_resource<N, U>(mut self, name: N, url: U) -> Self
    where
        N: AsRef<str>,
        U: AsRef<str>,
    {
        self.inner = self.inner.take().map(|a| a.external_resource(name, url));
        self
    }

    /// Proxy for [`actix_web::web::App::wrap`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.wrap).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap<M, B1>(
        mut self,
        mw: M,
    ) -> App<
        impl ServiceFactory<
            ServiceRequest,
            Config = (),
            Response = ServiceResponse<B1>,
            Error = Error,
            InitError = (),
        >,
        B1,
    >
    where
        M: Transform<
            T::Service,
            ServiceRequest,
            Response = ServiceResponse<B1>,
            Error = Error,
            InitError = (),
        >,
        B1: MessageBody,
    {
        App {
            spec: self.spec,
            inner: self.inner.take().map(|a| a.wrap(mw)),
        }
    }

    /// Proxy for [`actix_web::web::App::wrap_fn`](https://docs.rs/actix-web/*/actix_web/struct.App.html#method.wrap_fn).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap_fn<B1, F, R>(
        mut self,
        mw: F,
    ) -> App<
        impl ServiceFactory<
            ServiceRequest,
            Config = (),
            Response = ServiceResponse<B1>,
            Error = Error,
            InitError = (),
        >,
        B1,
    >
    where
        B1: MessageBody,
        F: Fn(ServiceRequest, &T::Service) -> R + Clone,
        R: Future<Output = Result<ServiceResponse<B1>, Error>>,
    {
        App {
            spec: self.spec,
            inner: self.inner.take().map(|a| a.wrap_fn(mw)),
        }
    }

    /// Mounts the specification for all operations and definitions
    /// recorded by the wrapper and serves them in the given path
    /// as a JSON.
    pub fn with_json_spec_at(mut self, path: &str) -> Self {
        self.inner = self.inner.take().map(|a| {
            a.service(
                actix_web::web::resource(path)
                    .route(actix_web::web::get().to(SpecHandler(self.spec.clone()))),
            )
        });
        self
    }

    /// Calls the given function with `App` and JSON `Value` representing your API
    /// specification **built until now**.
    ///
    /// **NOTE:** Unlike `with_json_spec_at`, this only has the API spec built until
    /// this function call. Any route handler added after this call won't affect the
    /// spec. So, it's important to call this function after adding all route handlers.
    pub fn with_raw_json_spec<F>(self, mut call: F) -> Self
    where
        F: FnMut(Self, serde_json::Value) -> Self,
    {
        let spec = serde_json::to_value(&*self.spec.read()).expect("generating json spec");
        call(self, spec)
    }

    /// Builds and returns the `actix_web::App`.
    pub fn build(self) -> actix_web::App<T, B> {
        self.inner.expect("missing app?")
    }

    /// Updates the underlying spec with definitions and operations from the given factory.
    fn update_from_mountable<F>(&mut self, factory: &mut F)
    where
        F: Mountable,
    {
        let mut api = self.spec.write();
        api.definitions.extend(factory.definitions().into_iter());
        SecurityScheme::append_map(
            factory.security_definitions(),
            &mut api.security_definitions,
        );
        factory.update_operations(&mut api.paths);
        if cfg!(feature = "normalize") {
            for map in api.paths.values_mut() {
                map.normalize();
            }
        }
    }
}

#[derive(Clone)]
struct SpecHandler(Arc<RwLock<DefaultApiRaw>>);

impl actix_web::dev::Handler<(), Ready<Result<HttpResponse, Error>>> for SpecHandler {
    fn call(&self, _: ()) -> Ready<Result<HttpResponse, Error>> {
        fut_ok(HttpResponse::Ok().json(&*self.0.read()))
    }
}

'''
'''--- plugins/actix-web/src/web.rs ---
//! Proxy module for [`actix_web::web`](https://docs.rs/actix-web/*/actix_web/web/index.html).

pub use actix_web::web::{
    block, service, to, Bytes, BytesMut, Data, Form, FormConfig, HttpRequest, HttpResponse, Json,
    JsonConfig, Path, PathConfig, Payload, PayloadConfig, Query, QueryConfig, ReqData,
};

use crate::Mountable;
use actix_service::{IntoServiceFactory, ServiceFactory};
use actix_web::{
    dev::{AppService, Handler, HttpServiceFactory, ServiceRequest, ServiceResponse, Transform},
    guard::Guard,
    http::Method,
    Error, FromRequest, Responder,
};
use paperclip_core::v2::{
    models::{
        DefaultOperationRaw, DefaultPathItemRaw, DefaultSchemaRaw, HttpMethod, SecurityScheme,
    },
    schema::Apiv2Operation,
};

use std::{collections::BTreeMap, fmt::Debug, future::Future, mem};

const METHODS: &[Method] = &[
    Method::GET,
    Method::PUT,
    Method::POST,
    Method::DELETE,
    Method::OPTIONS,
    Method::HEAD,
    Method::PATCH,
];

/* Resource */

/// Wrapper for [`actix_web::Resource`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html)
pub struct Resource<R = actix_web::Resource> {
    path: String,
    operations: BTreeMap<HttpMethod, DefaultOperationRaw>,
    definitions: BTreeMap<String, DefaultSchemaRaw>,
    security: BTreeMap<String, SecurityScheme>,
    inner: R,
}

impl Resource {
    /// Wrapper for [`actix_web::Resource::new`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.new).
    pub fn new(path: &str) -> Resource {
        Resource {
            path: path.into(),
            operations: BTreeMap::new(),
            definitions: BTreeMap::new(),
            security: BTreeMap::new(),
            inner: actix_web::Resource::new(path),
        }
    }
}

impl<T> HttpServiceFactory for Resource<actix_web::Resource<T>>
where
    T: ServiceFactory<
            ServiceRequest,
            Config = (),
            Response = ServiceResponse,
            Error = Error,
            InitError = (),
        > + 'static,
{
    fn register(self, config: &mut AppService) {
        self.inner.register(config)
    }
}

impl<T> IntoServiceFactory<T, ServiceRequest> for Resource<actix_web::Resource<T>>
where
    T: ServiceFactory<
            ServiceRequest,
            Config = (),
            Response = ServiceResponse,
            Error = Error,
            InitError = (),
        > + 'static,
{
    fn into_factory(self) -> T {
        self.inner.into_factory()
    }
}

impl<T> Mountable for Resource<T> {
    fn path(&self) -> &str {
        &self.path
    }

    fn operations(&mut self) -> BTreeMap<HttpMethod, DefaultOperationRaw> {
        mem::replace(&mut self.operations, BTreeMap::new())
    }

    fn definitions(&mut self) -> BTreeMap<String, DefaultSchemaRaw> {
        mem::replace(&mut self.definitions, BTreeMap::new())
    }

    fn security_definitions(&mut self) -> BTreeMap<String, SecurityScheme> {
        mem::replace(&mut self.security, BTreeMap::new())
    }
}

impl<T> Resource<actix_web::Resource<T>>
where
    T: ServiceFactory<
        ServiceRequest,
        Config = (),
        Response = ServiceResponse,
        Error = Error,
        InitError = (),
    >,
{
    /// Proxy for [`actix_web::Resource::name`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.name).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn name(mut self, name: &str) -> Self {
        self.inner = self.inner.name(name);
        self
    }

    /// Proxy for [`actix_web::Resource::guard`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.guard).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn guard<G: Guard + 'static>(mut self, guard: G) -> Self {
        self.inner = self.inner.guard(guard);
        self
    }

    /// Wrapper for [`actix_web::Resource::route`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.route).
    pub fn route(mut self, route: Route) -> Self {
        let w = RouteWrapper::from(&self.path, route);
        self.operations.extend(w.operations.into_iter());
        self.definitions.extend(w.definitions.into_iter());
        SecurityScheme::append_map(w.security, &mut self.security);
        self.inner = self.inner.route(w.inner);
        self
    }

    /// Proxy for [`actix_web::Resource::data`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn data<U: 'static>(mut self, data: U) -> Self {
        self.inner = self.inner.data(data);
        self
    }

    /// Proxy for [`actix_web::Resource::app_data`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.app_data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn app_data<U: 'static>(mut self, data: U) -> Self {
        let w = self.inner.app_data(data);
        self.inner = w;
        self
    }

    /// Wrapper for [`actix_web::Resource::to`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.to).
    pub fn to<F, I, R, U>(mut self, handler: F) -> Self
    where
        F: Handler<I, R> + 'static,
        I: FromRequest + 'static,
        R: Apiv2Operation + Future<Output = U> + 'static,
        U: Responder + 'static,
    {
        self.update_from_handler::<R>();
        self.inner = self.inner.to(handler);
        self
    }

    /// Proxy for [`actix_web::web::Resource::wrap`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.wrap).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap<M>(
        self,
        mw: M,
    ) -> Resource<
        actix_web::Resource<
            impl ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            >,
        >,
    >
    where
        M: Transform<
            T::Service,
            ServiceRequest,
            Response = ServiceResponse,
            Error = Error,
            InitError = (),
        >,
    {
        Resource {
            path: self.path,
            operations: self.operations,
            definitions: self.definitions,
            security: self.security,
            inner: self.inner.wrap(mw),
        }
    }

    /// Proxy for [`actix_web::web::Resource::wrap_fn`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.wrap_fn).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap_fn<F, R>(
        self,
        mw: F,
    ) -> Resource<
        actix_web::Resource<
            impl ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            >,
        >,
    >
    where
        F: Fn(ServiceRequest, &T::Service) -> R + Clone,
        R: Future<Output = Result<ServiceResponse, Error>>,
    {
        Resource {
            path: self.path,
            operations: self.operations,
            definitions: self.definitions,
            security: self.security,
            inner: self.inner.wrap_fn(mw),
        }
    }

    /// Proxy for [`actix_web::web::Resource::default_service`](https://docs.rs/actix-web/*/actix_web/struct.Resource.html#method.default_service).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn default_service<F, U>(mut self, f: F) -> Self
    where
        F: actix_service::IntoServiceFactory<U, ServiceRequest>,
        U: ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            > + 'static,
        U::InitError: Debug,
    {
        self.inner = self.inner.default_service(f);
        self
    }

    /// Updates this resource using the given handler.
    fn update_from_handler<U>(&mut self)
    where
        U: Apiv2Operation,
    {
        let mut op = U::operation();
        op.set_parameter_names_from_path_template(&self.path);
        for method in METHODS {
            self.operations.insert(method.into(), op.clone());
        }

        self.definitions.extend(U::definitions().into_iter());
        SecurityScheme::append_map(U::security_definitions(), &mut self.security);
    }
}

/// Wrapper for [`actix_web::web::resource`](https://docs.rs/actix-web/*/actix_web/web/fn.resource.html).
pub fn resource(path: &str) -> Resource {
    Resource::new(path)
}

/* Scope */

/// Wrapper for [`actix_web::Scope`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html)
pub struct Scope<S = actix_web::Scope> {
    path: String,
    path_map: BTreeMap<String, DefaultPathItemRaw>,
    definitions: BTreeMap<String, DefaultSchemaRaw>,
    security: BTreeMap<String, SecurityScheme>,
    inner: Option<S>,
}

impl Scope {
    /// Wrapper for [`actix_web::Scope::new`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.new)
    pub fn new(path: &str) -> Self {
        Scope {
            path: path.into(),
            path_map: BTreeMap::new(),
            definitions: BTreeMap::new(),
            security: BTreeMap::new(),
            inner: Some(actix_web::Scope::new(path)),
        }
    }
}

impl<T> HttpServiceFactory for Scope<actix_web::Scope<T>>
where
    T: ServiceFactory<
            ServiceRequest,
            Config = (),
            Response = ServiceResponse,
            Error = Error,
            InitError = (),
        > + 'static,
{
    fn register(self, config: &mut AppService) {
        if let Some(s) = self.inner {
            s.register(config);
        }
    }
}

impl<T> Scope<actix_web::Scope<T>>
where
    T: ServiceFactory<
        ServiceRequest,
        Config = (),
        Response = ServiceResponse,
        Error = Error,
        InitError = (),
    >,
{
    /// Proxy for [`actix_web::Scope::guard`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.guard).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn guard<G: Guard + 'static>(mut self, guard: G) -> Self {
        self.inner = self.inner.take().map(|s| s.guard(guard));
        self
    }

    /// Proxy for [`actix_web::Scope::data`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn data<U: 'static>(mut self, data: U) -> Self {
        self.inner = self.inner.take().map(|s| s.data(data));
        self
    }

    /// Proxy for [`actix_web::Scope::app_data`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.data).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn app_data<U: 'static>(mut self, data: U) -> Self {
        self.inner = self.inner.take().map(|s| s.app_data(data));
        self
    }

    /// Wrapper for [`actix_web::Scope::configure`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.configure).
    pub fn configure<F>(mut self, f: F) -> Self
    where
        F: FnOnce(&mut ServiceConfig),
    {
        self.inner = self.inner.take().map(|s| {
            s.configure(|c| {
                let mut cfg = ServiceConfig::from(c);
                f(&mut cfg);
                self.update_from_mountable(&mut cfg);
            })
        });
        self
    }

    /// Wrapper for [`actix_web::Scope::service`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.service).
    pub fn service<F>(mut self, mut factory: F) -> Self
    where
        F: Mountable + HttpServiceFactory + 'static,
    {
        self.update_from_mountable(&mut factory);
        self.inner = self.inner.take().map(|s| s.service(factory));
        self
    }

    /// Wrapper for [`actix_web::Scope::route`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.route).
    pub fn route(mut self, path: &str, route: Route) -> Self {
        let mut w = RouteWrapper::from(path, route);
        self.update_from_mountable(&mut w);
        self.inner = self.inner.take().map(|s| s.route(path, w.inner));
        self
    }

    /// Proxy for [`actix_web::web::Scope::default_service`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.default_service).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn default_service<F, U>(mut self, f: F) -> Self
    where
        F: actix_service::IntoServiceFactory<U, ServiceRequest>,
        U: ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            > + 'static,
        U::InitError: Debug,
    {
        self.inner = self.inner.map(|s| s.default_service(f));
        self
    }

    /// Proxy for [`actix_web::web::Scope::wrap`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.wrap).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap<M>(
        mut self,
        mw: M,
    ) -> Scope<
        actix_web::Scope<
            impl ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            >,
        >,
    >
    where
        M: Transform<
            T::Service,
            ServiceRequest,
            Response = ServiceResponse,
            Error = Error,
            InitError = (),
        >,
    {
        Scope {
            path: self.path,
            path_map: self.path_map,
            definitions: self.definitions,
            security: self.security,
            inner: self.inner.take().map(|s| s.wrap(mw)),
        }
    }

    /// Proxy for [`actix_web::web::Scope::wrap_fn`](https://docs.rs/actix-web/*/actix_web/struct.Scope.html#method.wrap_fn).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn wrap_fn<F, R>(
        mut self,
        mw: F,
    ) -> Scope<
        actix_web::Scope<
            impl ServiceFactory<
                ServiceRequest,
                Config = (),
                Response = ServiceResponse,
                Error = Error,
                InitError = (),
            >,
        >,
    >
    where
        F: Fn(ServiceRequest, &T::Service) -> R + Clone,
        R: Future<Output = Result<ServiceResponse, Error>>,
    {
        Scope {
            path: self.path,
            path_map: self.path_map,
            definitions: self.definitions,
            security: self.security,
            inner: self.inner.take().map(move |s| s.wrap_fn(mw)),
        }
    }

    /// Updates `self` using the given `Mountable` object.
    fn update_from_mountable<M>(&mut self, factory: &mut M)
    where
        M: Mountable,
    {
        self.definitions.extend(factory.definitions().into_iter());
        let mut path_map = BTreeMap::new();
        factory.update_operations(&mut path_map);
        for (path, mut map) in path_map {
            let p = self.path.clone() + &path;
            for op in map.methods.values_mut() {
                op.set_parameter_names_from_path_template(&p);
            }

            self.path_map.insert(p.clone(), map);
        }

        SecurityScheme::append_map(factory.security_definitions(), &mut self.security);
    }
}

impl<T> Mountable for Scope<T> {
    fn path(&self) -> &str {
        unimplemented!("Scope has multiple paths. Use `update_operations` object instead.");
    }

    fn operations(&mut self) -> BTreeMap<HttpMethod, DefaultOperationRaw> {
        unimplemented!("Scope has multiple operation maps. Use `update_operations` object instead.")
    }

    fn security_definitions(&mut self) -> BTreeMap<String, SecurityScheme> {
        mem::replace(&mut self.security, BTreeMap::new())
    }

    fn definitions(&mut self) -> BTreeMap<String, DefaultSchemaRaw> {
        mem::replace(&mut self.definitions, BTreeMap::new())
    }

    fn update_operations(&mut self, map: &mut BTreeMap<String, DefaultPathItemRaw>) {
        for (path, item) in mem::replace(&mut self.path_map, BTreeMap::new()) {
            let op_map = map.entry(path).or_insert_with(Default::default);
            op_map.methods.extend(item.methods.into_iter());
        }
    }
}

/// Wrapper for [`actix_web::web::scope`](https://docs.rs/actix-web/*/actix_web/web/fn.scope.html).
pub fn scope(path: &str) -> Scope {
    Scope::new(path)
}

/* Route */

/// Wrapper for [`actix_web::Route`](https://docs.rs/actix-web/*/actix_web/struct.Route.html)
pub struct Route {
    method: Option<HttpMethod>,
    operation: Option<DefaultOperationRaw>,
    definitions: BTreeMap<String, DefaultSchemaRaw>,
    security: BTreeMap<String, SecurityScheme>,
    inner: actix_web::Route,
}

impl ServiceFactory<ServiceRequest> for Route {
    type Config = ();
    type Response = ServiceResponse;
    type Error = Error;
    type InitError = ();
    type Service = <actix_web::Route as ServiceFactory<ServiceRequest>>::Service;
    type Future = <actix_web::Route as ServiceFactory<ServiceRequest>>::Future;

    fn new_service(&self, cfg: Self::Config) -> Self::Future {
        #[allow(clippy::unit_arg)]
        self.inner.new_service(cfg)
    }
}

impl Route {
    /// Wrapper for [`actix_web::Route::new`](https://docs.rs/actix-web/*/actix_web/struct.Route.html#method.new)
    #[allow(clippy::new_without_default)]
    pub fn new() -> Route {
        Route {
            method: None,
            operation: None,
            definitions: BTreeMap::new(),
            security: BTreeMap::new(),
            inner: actix_web::Route::new(),
        }
    }

    /// Wrapper for [`actix_web::Route::method`](https://docs.rs/actix-web/*/actix_web/struct.Route.html#method.method)
    pub fn method(mut self, method: Method) -> Self {
        self.method = Some(HttpMethod::from(&method));
        self.inner = self.inner.method(method);
        self
    }

    /// Proxy for [`actix_web::Route::guard`](https://docs.rs/actix-web/*/actix_web/struct.Route.html#method.guard).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn guard<G: Guard + 'static>(mut self, guard: G) -> Self {
        self.inner = self.inner.guard(guard);
        self
    }

    /// Wrapper for [`actix_web::Route::to`](https://docs.rs/actix-web/*/actix_web/struct.Route.html#method.to)
    pub fn to<F, I, R, U>(mut self, handler: F) -> Self
    where
        F: Handler<I, R>,
        I: FromRequest + 'static,
        R: Apiv2Operation + Future<Output = U> + 'static,
        U: Responder + 'static,
    {
        self.operation = Some(R::operation());
        self.definitions = R::definitions();
        self.security = R::security_definitions();
        self.inner = self.inner.to(handler);
        self
    }
}

/// Wrapper for [`actix_web::web::method`](https://docs.rs/actix-web/*/actix_web/web/fn.method.html).
pub fn method(method: Method) -> Route {
    Route::new().method(method)
}

/// Wrapper for [`actix_web::web::get`](https://docs.rs/actix-web/*/actix_web/web/fn.get.html).
pub fn get() -> Route {
    method(Method::GET)
}

/// Wrapper for [`actix_web::web::put`](https://docs.rs/actix-web/*/actix_web/web/fn.put.html).
pub fn put() -> Route {
    method(Method::PUT)
}

/// Wrapper for [`actix_web::web::post`](https://docs.rs/actix-web/*/actix_web/web/fn.post.html).
pub fn post() -> Route {
    method(Method::POST)
}

/// Wrapper for [`actix_web::web::patch`](https://docs.rs/actix-web/*/actix_web/web/fn.patch.html).
pub fn patch() -> Route {
    method(Method::PATCH)
}

/// Wrapper for [`actix_web::web::delete`](https://docs.rs/actix-web/*/actix_web/web/fn.delete.html).
pub fn delete() -> Route {
    method(Method::DELETE)
}

/// Wrapper for [`actix_web::web::options`](https://docs.rs/actix-web/*/actix_web/web/fn.options.html).
pub fn options() -> Route {
    method(Method::OPTIONS)
}

/// Wrapper for [`actix_web::web::head`](https://docs.rs/actix-web/*/actix_web/web/fn.head.html).
pub fn head() -> Route {
    method(Method::HEAD)
}

/// Workaround for issue #17. In actix-web, a method in a route is a guard for that route.
/// Whenever we call `App::route`, `Scope::route` or `ServiceConfig::route`, actix-web
/// creates a new resource with a route (by calling `Resource::new(path).route(route)`),
/// but then it also internally moves the guards to the new entity (manually). This forces
/// us to call the `.route` method on that entity rather than creating a resource with a
/// route. This wrapper is `Mountable` and can be used by `App`, `Scope`, etc. when calling
/// the `.route()` method.
pub(crate) struct RouteWrapper<S> {
    path: S,
    pub(crate) operations: BTreeMap<HttpMethod, DefaultOperationRaw>,
    pub(crate) definitions: BTreeMap<String, DefaultSchemaRaw>,
    pub(crate) security: BTreeMap<String, SecurityScheme>,
    pub(crate) inner: actix_web::Route,
}

impl<S> RouteWrapper<S>
where
    S: AsRef<str>,
{
    pub(crate) fn from(path: S, route: Route) -> Self {
        let mut operations = BTreeMap::new();
        if let Some(mut op) = route.operation {
            op.set_parameter_names_from_path_template(path.as_ref());

            if let Some(meth) = route.method {
                operations.insert(meth, op);
            } else {
                for method in METHODS {
                    operations.insert(method.into(), op.clone());
                }
            }
        }

        RouteWrapper {
            path,
            operations,
            definitions: route.definitions,
            security: route.security,
            inner: route.inner,
        }
    }
}

impl<S> Mountable for RouteWrapper<S>
where
    S: AsRef<str>,
{
    fn path(&self) -> &str {
        self.path.as_ref()
    }

    fn operations(&mut self) -> BTreeMap<HttpMethod, DefaultOperationRaw> {
        mem::replace(&mut self.operations, BTreeMap::new())
    }

    fn security_definitions(&mut self) -> BTreeMap<String, SecurityScheme> {
        mem::replace(&mut self.security, BTreeMap::new())
    }

    fn definitions(&mut self) -> BTreeMap<String, DefaultSchemaRaw> {
        mem::replace(&mut self.definitions, BTreeMap::new())
    }
}

/* Service config */

/// Wrapper for [`actix_web::web::ServiceConfig`](https://docs.rs/actix-web/*/actix_web/web/struct.ServiceConfig.html).
pub struct ServiceConfig<'a> {
    path_map: BTreeMap<String, DefaultPathItemRaw>,
    definitions: BTreeMap<String, DefaultSchemaRaw>,
    security: BTreeMap<String, SecurityScheme>,
    inner: &'a mut actix_web::web::ServiceConfig,
}

impl<'a> From<&'a mut actix_web::web::ServiceConfig> for ServiceConfig<'a> {
    fn from(cfg: &'a mut actix_web::web::ServiceConfig) -> Self {
        ServiceConfig {
            path_map: BTreeMap::new(),
            definitions: BTreeMap::new(),
            security: BTreeMap::new(),
            inner: cfg,
        }
    }
}

impl<'a> Mountable for ServiceConfig<'a> {
    fn path(&self) -> &str {
        unimplemented!("ServiceConfig has multiple paths. Use `update_operations` object instead.");
    }

    fn operations(&mut self) -> BTreeMap<HttpMethod, DefaultOperationRaw> {
        unimplemented!(
            "ServiceConfig has multiple operation maps. Use `update_operations` object instead."
        )
    }

    fn security_definitions(&mut self) -> BTreeMap<String, SecurityScheme> {
        mem::replace(&mut self.security, BTreeMap::new())
    }

    fn definitions(&mut self) -> BTreeMap<String, DefaultSchemaRaw> {
        mem::replace(&mut self.definitions, BTreeMap::new())
    }

    fn update_operations(&mut self, map: &mut BTreeMap<String, DefaultPathItemRaw>) {
        for (path, item) in mem::replace(&mut self.path_map, BTreeMap::new()) {
            let op_map = map.entry(path).or_insert_with(Default::default);
            op_map.methods.extend(item.methods.into_iter());
        }
    }
}

impl<'a> ServiceConfig<'a> {
    /// Wrapper for [`actix_web::web::ServiceConfig::route`](https://docs.rs/actix-web/*/actix_web/web/struct.ServiceConfig.html#method.route).
    pub fn route(&mut self, path: &str, route: Route) -> &mut Self {
        let mut w = RouteWrapper::from(path, route);
        self.definitions.extend(w.definitions().into_iter());
        w.update_operations(&mut self.path_map);
        SecurityScheme::append_map(w.security, &mut self.security);
        self.inner.route(path, w.inner);
        self
    }

    /// Wrapper for [`actix_web::web::ServiceConfig::service`](https://docs.rs/actix-web/*/actix_web/web/struct.ServiceConfig.html#method.service).
    pub fn service<F>(&mut self, mut factory: F) -> &mut Self
    where
        F: Mountable + HttpServiceFactory + 'static,
    {
        self.definitions.extend(factory.definitions().into_iter());
        factory.update_operations(&mut self.path_map);
        SecurityScheme::append_map(factory.security_definitions(), &mut self.security);
        self.inner.service(factory);
        self
    }

    /// Proxy for [`actix_web::web::ServiceConfig::external_resource`](https://docs.rs/actix-web/*/actix_web/web/struct.ServiceConfig.html#method.external_resource).
    ///
    /// **NOTE:** This doesn't affect spec generation.
    pub fn external_resource<N, U>(&mut self, name: N, url: U) -> &mut Self
    where
        N: AsRef<str>,
        U: AsRef<str>,
    {
        self.inner.external_resource(name, url);
        self
    }
}

'''
'''--- rustfmt.toml ---
merge_imports = true
space_after_colon = true

'''
'''--- src/bin/main.rs ---
use anyhow::Error;
use paperclip::{
    v2::{
        self,
        codegen::{CrateMeta, DefaultEmitter, EmitMode, Emitter, EmitterState},
        models::{DefaultSchema, ResolvableApi},
    },
    PaperClipError,
};
use structopt::StructOpt;

use std::{
    fs::{self, File},
    path::PathBuf,
};

fn parse_version(s: &str) -> Result<OApiVersion, Error> {
    match s {
        "v2" => Ok(OApiVersion::V2),
        "v3" => Ok(OApiVersion::V3),
        _ => Err(PaperClipError::UnsupportedOpenAPIVersion.into()),
    }
}

fn parse_spec(s: &str) -> Result<ResolvableApi<DefaultSchema>, Error> {
    let fd = File::open(s)?;
    Ok(v2::from_reader(fd)?)
}

#[derive(Debug)]
enum OApiVersion {
    V2,
    V3,
}

#[derive(Debug, StructOpt)]
struct Opt {
    /// Path to OpenAPI spec in JSON/YAML format (also supports publicly accessible URLs).
    #[structopt(parse(try_from_str = parse_spec))]
    spec: ResolvableApi<DefaultSchema>,
    /// OpenAPI version (e.g., v2).
    #[structopt(long = "api", parse(try_from_str = parse_version))]
    api: OApiVersion,
    /// Output directory to write code (default: current working directory).
    #[structopt(short = "o", long = "out", parse(from_os_str))]
    output: Option<PathBuf>,
    /// Emit CLI target instead.
    #[structopt(long = "cli")]
    cli: bool,
    /// Do not make the crate a root crate.
    #[structopt(long = "no-root")]
    no_root: bool,
    /// Name of the crate. If this is not specified, then the name of the
    /// working directory is assumed to be crate name.
    #[structopt(long = "name")]
    pub name: Option<String>,
    /// Version (defaults to 0.1.0)
    #[structopt(long = "version")]
    pub version: Option<String>,
}

fn parse_args_and_run() -> Result<(), Error> {
    let opt = Opt::from_args();
    if let OApiVersion::V3 = opt.api {
        return Err(PaperClipError::UnsupportedOpenAPIVersion.into());
    }

    let spec = opt.spec.resolve()?;
    let mut state = EmitterState::default();

    if let Some(o) = opt.output {
        fs::create_dir_all(&o)?;
        state.working_dir = o;
    }

    let mut meta = CrateMeta::default();
    if opt.cli {
        meta.mode = EmitMode::App;
    } else {
        meta.mode = EmitMode::Crate;
    }
    if opt.name.is_some() {
        meta.name = opt.name;
    }
    if opt.version.is_some() {
        meta.version = opt.version;
    }

    meta.no_root = opt.no_root;

    state.set_meta(meta);
    let emitter = DefaultEmitter::from(state);
    emitter.generate(&spec)
}

fn main() {
    env_logger::init();
    if let Err(e) = parse_args_and_run() {
        eprintln!("{}", e);
    }
}

'''
'''--- src/build/build.rs ---
use std::{
    env,
    fs::File,
    io::{Read, Write},
    path::PathBuf,
};

fn load_file(p: PathBuf) -> String {
    let mut string = String::new();
    let mut fd = File::open(p).unwrap();
    fd.read_to_string(&mut string).unwrap();
    string
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let root = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let files = &[
        ("CARGO_MANIFEST", "src/build/manifest.hbs"),
        ("CLIENT_MOD", "src/build/client_mod.hbs"),
        ("CLAP_YAML", "src/build/clap_yaml.hbs"),
        ("CLI_MAIN", "src/build/cli_main.hbs"),
        ("UTIL_MOD", "src/build/util_mod.hbs"),
        ("CLI_UTIL", "src/build/cli_util.hbs"),
    ];

    let mut contents = String::from(
        "
#[cfg(feature = \"codegen\")]
mod template {
    use tinytemplate::TinyTemplate;

    #[derive(Debug, Copy, Clone)]
    #[allow(dead_code, non_camel_case_types)]
    pub enum TEMPLATE {",
    );

    for (name, _) in files {
        contents.push_str(
            "
        ",
        );
        contents.push_str(&name);
        contents.push(',');
    }

    contents.push_str(
        "
    }",
    );

    let source_path = PathBuf::from(&out_dir).join("template.rs");
    for (name, file) in files {
        println!("cargo:rerun-if-changed={}", file);
        let thing = load_file(root.join(&file));
        contents.push_str(&format!(
            "
    pub const {}: &str = {:?};
",
            name, thing
        ));
    }

    contents.push_str(
        "
    pub fn render<C>(t: TEMPLATE, context: &C) -> tinytemplate::error::Result<String>
        where C: serde::Serialize
    {
        let mut temp = TinyTemplate::new();
        temp.add_template(\"file\", match t {",
    );

    for (name, _) in files {
        contents.push_str(&format!(
            "
            TEMPLATE::{name} => {name},",
            name = name
        ));
    }

    contents.push_str(
        "
        })?;

        temp.render(\"file\", context)
    }
}
",
    );

    let mut fd = File::create(&source_path).unwrap();
    fd.write_all(contents.as_bytes()).unwrap();
}

'''
'''--- src/error.rs ---
use std::{collections::HashSet, path::PathBuf};

macro_rules! impl_err_from {
    ($err:ident :: $type:ty > $variant:ident) => {
        impl From<$type> for $err {
            fn from(s: $type) -> Self {
                $err::$variant(s)
            }
        }
    };
}

/// Generic result used throughout this library.
pub type PaperClipResult<T> = Result<T, PaperClipError>;

/// Global error which encapsulates all related errors.
#[derive(Debug, thiserror::Error)]
pub enum PaperClipError {
    /// Error encountered during spec validation.
    #[error("{}", _0)]
    Validation(paperclip_core::ValidationError),
    /// The given directory cannot be used for generating code.
    #[error("Cannot generate code in the given directory")]
    InvalidCodegenDirectory,
    /// Currently, we only support OpenAPI v2, and eventually v3.
    #[error("This version of OpenAPI is unsupported.")]
    #[allow(clippy::upper_case_acronyms)]
    UnsupportedOpenAPIVersion,
    /// Paths listed in the spec must be unique.
    #[error("Path similar to {:?} already exists.", _0)]
    RelativePathNotUnique(String),
    #[error("Parameter(s) {:?} aren't defined for templated path {:?}", _1, _0)]
    MissingParametersInPath(String, HashSet<String>),
    /// Invalid host for URL.
    #[error("Cannot parse host {:?}: {}", _0, _1)]
    InvalidHost(String, url::ParseError),
    /// Invalid base path URL.
    #[error("Cannot set URL {:?}: {}", _0, _1)]
    #[allow(clippy::upper_case_acronyms)]
    InvalidBasePathURL(String, url::ParseError),
    /// The given schema object is an array, but the `items` field is missing.
    #[error("Mising item schema for array: {:?}", _0)]
    MissingArrayItem(Option<String>),
    /// The name for the given definition is invalid.
    #[error("Invalid name for definition: '{0}'")]
    InvalidDefinitionName(String),
    /// The name for the given definition is missing.
    #[error("Missing name for definition")]
    MissingDefinitionName,
    /// A valid path cannot be obtained for the given definition.
    #[error("Invalid path for definition: {:?}", _0)]
    InvalidDefinitionPath(PathBuf),
    /// I/O errors.
    #[error("I/O error: {}", _0)]
    Io(std::io::Error),
    /// JSON coding errors.
    #[error("JSON error: {}", _0)]
    Json(serde_json::Error),
    /// YAML coding errors.
    #[error("YAML error: {}", _0)]
    Yaml(serde_yaml::Error),
    #[cfg(feature = "codegen-fmt")]
    /// Errors from rustfmt.
    #[error("Rustfmt formatting error: {}", _0)]
    RustFmt(rustfmt_nightly::ErrorKind),
    #[cfg(feature = "codegen")]
    /// Errors in templating.
    #[error("Templating error: {}", _0)]
    Templating(tinytemplate::error::Error),
}

impl_err_from!(PaperClipError::std::io::Error > Io);
impl_err_from!(PaperClipError::serde_json::Error > Json);
impl_err_from!(PaperClipError::serde_yaml::Error > Yaml);
impl_err_from!(PaperClipError::paperclip_core::ValidationError > Validation);
#[cfg(feature = "codegen-fmt")]
impl_err_from!(PaperClipError::rustfmt_nightly::ErrorKind > RustFmt);
#[cfg(feature = "codegen")]
impl_err_from!(PaperClipError::tinytemplate::error::Error > Templating);

'''
'''--- src/lib.rs ---
//! Paperclip is a OpenAPI code generator for efficient type-safe
//! compile-time checked HTTP APIs in Rust.
//!
//! See the [website](https://paperclip.waffles.space) for detailed
//! documentation and examples.

#[cfg_attr(feature = "codegen", macro_use)]
#[cfg(feature = "codegen")]
extern crate log;

mod error;
#[cfg(feature = "v2")]
pub mod v2;

pub use error::{PaperClipError, PaperClipResult};
pub use paperclip_core::util;
#[cfg(feature = "v2")]
pub use paperclip_macros::api_v2_schema_struct as api_v2_schema;

#[cfg(feature = "actix-base")]
pub mod actix {
    //! Plugin types, traits and macros for actix-web framework.

    pub use paperclip_actix::{
        api_v2_errors, api_v2_operation, delete, get, post, put, web, Apiv2Schema, Apiv2Security,
        App, Mountable, OpenApiExt,
    };
    pub use paperclip_core::v2::{
        AcceptedJson, CreatedJson, NoContent, OperationModifier, ResponderWrapper, ResponseWrapper,
    };
}

'''
'''--- src/v2/codegen/author.rs ---
//! Author extraction for cargo manifest (c) 2018 Cargo Developers.
//!
//! Obtained from [Cargo](https://github.com/rust-lang/cargo/blob/fa05862cd0c6b899b801fda0f256ac5b9bae69d9/src/cargo/ops/cargo_new.rs#L690-L750).

use anyhow::Error;
use git2::{Config as GitConfig, Repository as GitRepository};

use std::env;

fn get_environment_variable(variables: &[&str]) -> Option<String> {
    variables.iter().filter_map(|var| env::var(var).ok()).next()
}

/// Attempts to find the name and email of the author from the current environment.
pub(super) fn discover() -> Result<(String, Option<String>), Error> {
    let cwd = env::current_dir()?;
    let git_config = if let Ok(repo) = GitRepository::discover(&cwd) {
        repo.config()
            .ok()
            .or_else(|| GitConfig::open_default().ok())
    } else {
        GitConfig::open_default().ok()
    };
    let git_config = git_config.as_ref();
    let name_variables = [
        "CARGO_NAME",
        "GIT_AUTHOR_NAME",
        "GIT_COMMITTER_NAME",
        "USER",
        "USERNAME",
        "NAME",
    ];
    let name = get_environment_variable(&name_variables[0..3])
        .or_else(|| git_config.and_then(|g| g.get_string("user.name").ok()))
        .or_else(|| get_environment_variable(&name_variables[3..]));

    let name = match name {
        Some(name) => name,
        None => {
            let username_var = if cfg!(windows) { "USERNAME" } else { "USER" };
            anyhow::bail!(
                "could not determine the current user, please set ${}",
                username_var
            )
        }
    };
    let email_variables = [
        "CARGO_EMAIL",
        "GIT_AUTHOR_EMAIL",
        "GIT_COMMITTER_EMAIL",
        "EMAIL",
    ];
    let email = get_environment_variable(&email_variables[0..3])
        .or_else(|| git_config.and_then(|g| g.get_string("user.email").ok()))
        .or_else(|| get_environment_variable(&email_variables[3..]));

    let name = name.trim().to_string();
    let email = email.map(|s| {
        let mut s = s.trim();

        // In some cases emails will already have <> remove them since they
        // are already added when needed.
        if s.starts_with('<') && s.ends_with('>') {
            s = &s[1..s.len() - 1];
        }

        s.to_string()
    });

    Ok((name, email))
}

'''
'''--- src/v2/codegen/emitter.rs ---
use super::{
    object::{
        ApiObject, ObjectContainer, ObjectField, ObjectVariant, OpRequirement, Parameter, Response,
    },
    state::{ChildModule, EmitterState},
    CrateMeta,
};
use crate::{
    error::PaperClipError,
    v2::{
        models::{
            Coder, CollectionFormat, DataType, DataTypeFormat, Either, HttpMethod, Items,
            MediaRange, ParameterIn, Reference, ResolvableApi, ResolvableOperation,
            ResolvableParameter, ResolvablePathItem, ResolvableResponse, JSON_CODER, JSON_MIME,
            YAML_CODER, YAML_MIME,
        },
        Schema,
    },
};
use anyhow::Error;
use heck::{CamelCase, SnekCase};
use http::{header::HeaderName, HeaderMap};
use itertools::Itertools;
use parking_lot::RwLock;
use std::{
    collections::{BTreeMap, BTreeSet, HashSet},
    fmt::Debug,
    fs,
    ops::Deref,
    path::{Path, PathBuf},
    sync::Arc,
};
use url::Host;

/// Identifier used for `Any` generic parameters in struct definitions.
pub(super) const ANY_GENERIC_PARAMETER: &str = "Any";
/// Identifier used for file types in schema. This will be replaced with `ResponseStream`.
pub(super) const FILE_MARKER: &str = "--FILE--";
/// Field that collects all properties when "additionalProperties" is set to "true"
pub(super) const EXTRA_PROPS_FIELD: &str = "other_fields";

/// Some "thing" emitted by the emitter.
#[derive(Debug)]
pub enum EmittedUnit {
    /// Some Rust type.
    Known(String),
    /// Bunch of emitted Rust objects.
    Objects(Vec<ApiObject>),
    /// We've identified the Rust type, but then we also have a
    /// bunch of generated Rust objects. This happens in the
    /// presence of anonymously defined schema.
    KnownButAnonymous(String, Vec<ApiObject>),
    /// Nothing to do.
    None,
}

impl EmittedUnit {
    #[inline]
    fn known_type(&self) -> String {
        match self {
            EmittedUnit::Known(ref s) => s.clone(),
            EmittedUnit::KnownButAnonymous(ref s, _) => s.clone(),
            _ => panic!("Emitted unit {:?} is not a known type", self),
        }
    }

    #[inline]
    fn map_known(self, ty: impl Into<String>) -> Self {
        match self {
            EmittedUnit::Known(_) => EmittedUnit::Known(ty.into()),
            EmittedUnit::KnownButAnonymous(_, o) => EmittedUnit::KnownButAnonymous(ty.into(), o),
            _ => panic!("Cannot map unknown emitted units"),
        }
    }
}

/// Context for building definitions.
#[derive(Debug, Clone, Default)]
pub struct DefinitionContext<'a> {
    /// Whether we're planning to define the Rust type or whether we're
    /// reusing an existing type.
    pub define: bool,
    /// Names of parents. In JSON schema, object types are allowed to
    /// define a new object in their schema without '$ref'erencing them
    /// from elsewhere. This means, we'll have an anonymous object. So,
    /// we make use of parents (object names or property names) to
    /// autogenerate struct names at will.
    pub parents: Vec<&'a str>,
}

impl<'a> DefinitionContext<'a> {
    /// Specify whether the object needs to be defined.
    pub fn define(mut self, define: bool) -> Self {
        self.define = define;
        self
    }

    /// Creates a new context by appending the immediate parent's name.
    pub fn add_parent(mut self, parent: &'a str) -> Self {
        self.parents.push(parent);
        DefinitionContext {
            define: self.define,
            parents: self.parents,
        }
    }
}

/// `Emitter` represents the interface for generating the relevant
/// modules, API object definitions and the associated calls.
pub trait Emitter: Sized {
    /// The associated `Schema` implementor.
    type Definition: Schema + Debug;

    /* MARK: Overridable methods */

    /// Returns a reference to the underlying state.
    fn state(&self) -> &EmitterState;

    /// Returns an iterator of path components for the given definition.
    ///
    /// **NOTE:** All components are [snake_cased](https://docs.rs/heck/*/heck/trait.SnekCase.html)
    /// (including the definition name).
    fn def_ns_name<'a>(
        &self,
        def: &'a Self::Definition,
    ) -> Result<Box<dyn Iterator<Item = String> + 'a>, Error> {
        let state = self.state();
        def.name()
            .map(|n| n.split(state.ns_sep).map(SnekCase::to_snek_case))
            .ok_or_else(|| {
                trace!("Missing name for definition: '{:?}'", def);
                PaperClipError::MissingDefinitionName.into()
            })
            .map(|i| Box::new(i) as Box<_>)
    }

    /// Returns the [CamelCase](https://docs.rs/heck/*/heck/trait.CamelCase.html)
    /// name for the given definition.
    fn def_name(&self, def: &Self::Definition) -> Result<String, Error> {
        Ok(self
            .def_ns_name(def)?
            .last()
            .map(|s| s.to_camel_case())
            .expect("last item always exists for split?"))
    }

    /// Returns the [CamelCase](https://docs.rs/heck/*/heck/trait.CamelCase.html)
    /// name for some definition based on its parent names. This is called whenever
    /// a definition doesn't have a name (i.e., through `$ref`) and we have to generate it.
    fn def_anon_name(&self, def: &Self::Definition, parents: &[&str]) -> Option<String> {
        let mut name = String::new();
        parents.iter().for_each(|s| {
            name.push_str(s);
            name.push_str("_");
        });

        if name.is_empty() {
            trace!("Unable to get name for anonymous schema: {:?}", def);
            None
        } else {
            Some(name.to_camel_case())
        }
    }

    /// Returns the enum variant of a possible value in the given definition.
    fn enum_variant(
        &self,
        def: &Self::Definition,
        value: &serde_json::Value,
    ) -> Option<ObjectVariant> {
        use serde_json::Value;
        let _ = def;

        let name = match value {
            Value::Number(ref n) => format!(
                "Number_{}",
                n.to_string().replace('-', "_").replace('.', "_")
            ),
            Value::Bool(b) => b.to_string().to_camel_case(),
            Value::String(ref s) => s.to_string().to_camel_case(),
            _ => return None,
        };

        Some(ObjectVariant {
            name,
            value: value.clone(),
        })
    }

    /// Returns the module path (from working directory) for the given definition.
    ///
    /// **NOTE:** This should set `.rs` extension to the leaf path component.
    fn def_mod_path(&self, def: &Self::Definition) -> Result<PathBuf, Error> {
        let state = self.state();
        let mut path = state.working_dir.clone();
        path.extend(self.def_ns_name(def)?);
        path.set_extension("rs");
        Ok(path)
    }

    /// Called whenever we encounter an operation that can't be added to
    /// any modules. By default, this returns `miscellaneous.rs` module in root.
    ///
    /// **NOTE:** This should set `.rs` extension to the leaf path component.
    fn unknown_op_mod_path(
        &self,
        path: &str,
        method: HttpMethod,
        op: &ResolvableOperation<Self::Definition>,
    ) -> Result<PathBuf, Error> {
        let _ = (path, method, op);
        let state = self.state();
        let mut path = state.working_dir.clone();
        path.push("miscellaneous");
        path.set_extension("rs");
        Ok(path)
    }

    /// Called whenever we don't have an object for the module path returned by
    /// `Emitter::unknown_op_mod_path` method. By default, this returns an object
    /// (named `Miscellaneous`) representing an unit struct.
    ///
    /// **NOTE:** Only the name and description fields can be relied upon when
    /// creating `ApiObject`. Others may be overridden.
    fn unknown_op_object(
        &self,
        path: &str,
        method: HttpMethod,
        op: &ResolvableOperation<Self::Definition>,
    ) -> Result<ApiObject, Error> {
        let _ = (path, method, op);
        Ok(ApiObject {
            name: "Miscellaneous".into(),
            description: Some(
                "Namespace for operations that cannot be added \
                 to any other modules."
                    .into(),
            ),
            ..Default::default()
        })
    }

    /* MARK: Internal methods. Not meant to be overridden. */

    /// Entrypoint for emitter. Given an API spec, generate code
    /// inside Rust modules in the configured working directory.
    ///
    /// **NOTE:** Not meant to be overridden.
    fn generate(&self, api: &ResolvableApi<Self::Definition>) -> Result<(), Error> {
        let state = self.state();
        state.reset_internal_fields();

        let m = state.get_meta();
        if m.borrow().is_none() {
            let mut meta = CrateMeta::default();
            meta.name = Some(api.info.title.clone());
            if semver::Version::parse(&api.info.version).is_ok() {
                meta.version = Some(api.info.version.clone());
            } else {
                warn!("Unable to parse {:?} as semver version.", api.info.version);
            }

            state.set_meta(meta);
        }

        // Add default coders.
        let mut coders = api.coders.clone();
        if !coders.contains_key(&JSON_MIME) {
            coders.insert(JSON_MIME.clone(), JSON_CODER.clone());
        }

        if !coders.contains_key(&YAML_MIME) {
            coders.insert(YAML_MIME.clone(), YAML_CODER.clone());
        }

        state.set_media_info(api.spec_format, &coders);

        // Set host and base path.
        if let Some(h) = api.host.as_ref() {
            let mut parts = h.split(':');
            let mut u = state.base_url.borrow_mut();
            if let Some(host) = parts.next() {
                Host::parse(host).map_err(|e| PaperClipError::InvalidHost(h.into(), e))?;
                u.set_host(Some(&host))
                    .expect("expected valid host in URL?");
            }

            if let Some(port) = parts.next() {
                let p = port.parse::<u16>().map_err(|_| {
                    PaperClipError::InvalidHost(h.into(), url::ParseError::InvalidPort)
                })?;
                u.set_port(Some(p)).expect("expected valid port in URL?");
            }
        }

        if let Some(p) = api.base_path.as_ref() {
            state.base_url.borrow_mut().set_path(p);
        }

        let gen = CodegenEmitter(self);
        // Generate file contents by accumulating definitions.
        for (name, schema) in &api.definitions {
            debug!("Creating definition {}", name);
            let schema = schema.read();
            gen.generate_from_definition(&schema)?;
        }

        for (path, map) in &api.paths {
            RequirementCollector {
                path,
                emitter: self,
                api,
                map,
                template_params: HashSet::new(),
            }
            .collect()?;
        }

        state.declare_modules()?;
        state.write_definitions()?;
        state.add_builders()?;
        state.add_client_deps()?;
        state.add_deps()?;

        Ok(())
    }

    /// Builds a schema. This resolves type aliases to known types
    /// and defines/reuses types based on the given context.
    ///
    /// **NOTE:** Not meant to be overridden.
    fn build_def<'a>(
        &self,
        def: &Self::Definition,
        ctx: DefinitionContext<'a>,
    ) -> Result<EmittedUnit, Error> {
        if let Some(u) = CodegenEmitter(self).try_emit_enum(def, ctx.clone())? {
            return Ok(u);
        }

        if let Some(ty) = matching_unit_type(def.format(), def.data_type()) {
            trace!("Matches unit type: {}", ty);
            if ctx.define {
                return Ok(EmittedUnit::None);
            }

            return Ok(EmittedUnit::Known(ty.to_owned()));
        }

        match def.data_type() {
            Some(DataType::Array) => CodegenEmitter(self).emit_array(def, ctx),
            Some(DataType::Object) => CodegenEmitter(self).emit_object(def, ctx),
            Some(DataType::File) => Ok(EmittedUnit::Known(FILE_MARKER.into())),
            Some(_) => unreachable!("bleh?"), // we've already handled everything else
            None => {
                if ctx.define {
                    Ok(EmittedUnit::None)
                } else {
                    // We're using `Any` as a known type, because in the context of
                    // the emitted generic struct, it *is* a known type.
                    Ok(EmittedUnit::Known(ANY_GENERIC_PARAMETER.into()))
                }
            }
        }
    }
}

/// Abstraction for segregating `Emitter` trait methods from internal methods.
struct CodegenEmitter<'a, E>(&'a E)
where
    Self: Sized;

impl<'a, E> Deref for CodegenEmitter<'a, E> {
    type Target = E;

    fn deref(&self) -> &E {
        &self.0
    }
}

impl<'a, E> CodegenEmitter<'a, E>
where
    E: Emitter,
    E::Definition: Debug,
{
    /// Given a schema definition, generate the corresponding Rust definitions and
    /// add them to `EmitterState`.
    fn generate_from_definition(&self, def: &E::Definition) -> Result<(), Error> {
        // Generate the object.
        let objects = match self.build_def(def, DefinitionContext::default().define(true))? {
            EmittedUnit::Objects(o) => o,
            // We don't care about type aliases because we resolve them anyway.
            _ => return Ok(()),
        };

        self.add_objects_to_path(objects, self.def_mod_path(def)?)
    }

    /// Given a bunch of API objects and their module path, add them to the internal state.
    ///
    /// **NOTE:** Should we need to add any `ApiObject` to `EmitterState.def_mods`, this
    /// method must be used instead of manipulating the field directly.
    fn add_objects_to_path(
        &self,
        mut objects: Vec<ApiObject>,
        mod_path: PathBuf,
    ) -> Result<(), Error> {
        let state = self.state();
        // Create parent dirs recursively for the leaf module.
        let dir_path = mod_path
            .parent()
            .ok_or_else(|| PaperClipError::InvalidDefinitionPath(mod_path.clone()))?;
        if !dir_path.exists() {
            fs::create_dir_all(&dir_path)?;
        }

        // Get the path without the extension.
        let full_path = dir_path.join(
            mod_path
                .file_stem()
                .ok_or_else(|| PaperClipError::InvalidDefinitionPath(mod_path.clone()))?,
        );
        // Get the relative path to the parent.
        let rel_path = full_path
            .strip_prefix(&state.working_dir)
            .map_err(|_| PaperClipError::InvalidDefinitionPath(full_path.clone()))?;

        // Gather the immediate parent-children pairs for module declarations.
        let mut mods = state.mod_children.borrow_mut();
        for (i, path) in rel_path.ancestors().enumerate() {
            if let (Some(parent), Some(name)) = (path.parent(), path.file_name()) {
                let entry = mods.entry(parent.into()).or_insert_with(HashSet::new);
                entry.insert(ChildModule {
                    name: name.to_string_lossy().into_owned(),
                    is_final: i == 0,
                });
            }
        }

        // Set the relative path to objects for future reference.
        for obj in &mut objects {
            obj.path = rel_path.to_string_lossy().into_owned().replace('/', "::");
        }

        // Add generated object to state.
        let mut def_mods = state.def_mods.borrow_mut();
        def_mods.insert(mod_path, objects);
        Ok(())
    }

    /// Assumes that the given definition is an array and returns the corresponding
    /// vector type for it.
    fn emit_array<'c>(
        &self,
        def: &E::Definition,
        ctx: DefinitionContext<'c>,
    ) -> Result<EmittedUnit, Error> {
        let it = def
            .items()
            .ok_or_else(|| PaperClipError::MissingArrayItem(self.def_name(def).ok()))?;

        let mut ctx = ctx.clone();
        if let Some(n) = def.name() {
            ctx = ctx.add_parent(n);
        }

        let schema = it.read();
        if schema.name().is_none() {
            // If the schema doesn't have a name, then add "item" as a suffix
            // so that it can be used for name generation later.
            ctx = ctx.add_parent("item");
        }

        if ctx.define {
            if schema.name().is_none() {
                // If there are nested types requiring definitions, then return them.
                if let e @ EmittedUnit::Objects(_) = self.build_def(&schema, ctx)? {
                    return Ok(e);
                }
            }

            return Ok(EmittedUnit::None);
        }

        let obj = self.build_def(&schema, ctx.define(false))?;
        let ty = String::from("Vec<") + &obj.known_type() + ">";
        Ok(obj.map_known(ty))
    }

    /// Checks if the given definition is a simple enum and returns an unit if it can be
    /// represented as a Rust enum.
    fn try_emit_enum(
        &self,
        def: &E::Definition,
        ctx: DefinitionContext<'_>,
    ) -> Result<Option<EmittedUnit>, Error> {
        // FIXME: Research on how we can support complex enums.
        if def.data_type().is_some() && matching_unit_type(def.format(), def.data_type()).is_none()
        {
            return Ok(None);
        }

        let values = match def.enum_variants() {
            Some(v) => v,
            None => return Ok(None),
        };

        if !ctx.define {
            return CodegenEmitter(self)
                .emit_known_object_path(def, ctx)
                .map(Some);
        }

        let name = self.def_name(def).or_else(|e| {
            // anonymous object
            self.def_anon_name(def, &ctx.parents).ok_or_else(|| e)
        })?;

        let mut obj = ApiObject::with_name(&name);
        obj.description = def.description().map(String::from);
        obj.inner = ObjectContainer::Enum {
            variants: vec![],
            is_string: def.data_type() == Some(DataType::String),
        };

        for val in values {
            if let Some(var) = self.0.enum_variant(def, val) {
                obj.variants_mut().push(var);
            }
        }

        if obj.variants().is_empty() {
            return Ok(None);
        }

        Ok(Some(EmittedUnit::Objects(vec![obj])))
    }

    /// Assumes that the given definition is an object and returns the corresponding
    /// Rust struct / map.
    fn emit_object<'c>(
        &self,
        def: &E::Definition,
        ctx: DefinitionContext<'c>,
    ) -> Result<EmittedUnit, Error> {
        match self.try_emit_map(def, &ctx)? {
            EmittedUnit::None => (),
            x => return Ok(x),
        }

        if !ctx.define {
            return self.emit_known_object_path(def, ctx);
        }

        self.emit_struct(def, ctx)
    }

    /// Checks if the given definition is a simple map and returns the corresponding `BTreeMap`.
    fn try_emit_map(
        &self,
        def: &E::Definition,
        ctx: &DefinitionContext<'_>,
    ) -> Result<EmittedUnit, Error> {
        if ctx.define {
            return Ok(EmittedUnit::None);
        }

        match def.additional_properties() {
            Some(Either::Right(s)) => {
                let schema = s.read();
                let ty = self
                    .build_def(&schema, ctx.clone().define(false))?
                    .known_type();
                let map = format!("std::collections::BTreeMap<String, {}>", ty);
                Ok(EmittedUnit::Known(map))
            }
            _ => Ok(EmittedUnit::None),
        }
    }

    fn emit_known_object_path<'c>(
        &self,
        def: &E::Definition,
        ctx: DefinitionContext<'c>,
    ) -> Result<EmittedUnit, Error> {
        // Use absolute paths to save some pain.
        let mut ty_path = String::from(self.state().mod_prefix.trim_matches(':'));

        // If this is an anonymous object, then address it directly.
        if def.name().is_none() {
            let objects = match self.build_def(def, ctx.clone().define(true))? {
                EmittedUnit::Objects(o) => o,
                _ => unreachable!(),
            };

            // If the object has an anonymous name, then it would definitely
            // be in its own module, which is identified by the initial parent name.
            if let Some(name) = self.def_anon_name(def, &ctx.parents) {
                ty_path.push_str("::");
                let parent = ctx.parents.get(0).expect("expected first parent name");
                ty_path.push_str(&parent.to_snek_case());
                ty_path.push_str("::");
                ty_path.push_str(&name);
                return Ok(EmittedUnit::KnownButAnonymous(ty_path, objects));
            }
        }

        let mut iter = self.def_ns_name(def)?.peekable();
        while let Some(mut c) = iter.next() {
            ty_path.push_str("::");
            if iter.peek().is_none() {
                ty_path.push_str(&c);
                ty_path.push_str("::");
                c = c.to_camel_case();
            }

            ty_path.push_str(&c);
        }

        Ok(EmittedUnit::Known(ty_path))
    }

    /// Helper for `emit_object` - This returns the Rust struct definition for the
    /// given schema definition.
    fn emit_struct(
        &self,
        def: &E::Definition,
        ctx: DefinitionContext<'_>,
    ) -> Result<EmittedUnit, Error> {
        let name = self.def_name(def).or_else(|e| {
            // anonymous object
            self.def_anon_name(def, &ctx.parents).ok_or_else(|| e)
        })?;
        let mut obj = ApiObject::with_name(&name);
        obj.description = def.description().map(String::from);

        // If we don't have any parents and there's a name for this object,
        // then it's the root object - add the name to parents before checking
        // its properties.
        let mut ctx = ctx.clone();
        if ctx.parents.is_empty() && def.name().is_some() {
            ctx = ctx.add_parent(&name);
        }

        // Anonymous objects that we've collected along the way.
        let mut objects = vec![];

        if let Some(props) = def.properties() {
            props
                .iter()
                .try_for_each(|(name, prop)| -> Result<(), Error> {
                    let schema = prop.read();
                    let ctx = ctx.clone().define(false).add_parent(name);
                    let ty = self.build_def(&schema, ctx)?;
                    let ty_path = ty.known_type();

                    obj.fields_mut().push(ObjectField {
                        name: name.clone(),
                        description: prop.get_description(),
                        ty_path,
                        is_required: def
                            .required_properties()
                            .map(|s| s.contains(name))
                            .unwrap_or(false),
                        needs_any: schema.contains_any(),
                        boxed: schema.is_cyclic(),
                        child_req_fields: self.children_requirements(&schema),
                    });

                    if let EmittedUnit::KnownButAnonymous(_, mut o) = ty {
                        objects.append(&mut o);
                    }

                    Ok(())
                })?;

            // If additional properties are enabled, then collect them into
            // a separate field for flattening.
            if let Some(Either::Left(true)) = def.additional_properties() {
                obj.fields_mut().push(ObjectField {
                    name: EXTRA_PROPS_FIELD.into(),
                    ty_path: "std::collections::BTreeMap<String, Any>".into(),
                    description: None,
                    is_required: false,
                    needs_any: true,
                    boxed: false,
                    child_req_fields: vec![],
                });
            }
        }

        objects.insert(0, obj);
        Ok(EmittedUnit::Objects(objects))
    }

    /// Returns the requirements of the "deepest" child type in the given definition.
    ///
    /// See `ObjectField.children_req` field for what it means.
    fn children_requirements(&self, schema: &E::Definition) -> Vec<String> {
        match schema.data_type() {
            Some(DataType::Object) => {
                if let Some(Either::Right(s)) = schema.additional_properties() {
                    return self.children_requirements(&s.read());
                } else if let Some(s) = schema.required_properties() {
                    return s.iter().cloned().collect();
                }
            }
            Some(DataType::Array) => {
                if let Some(s) = schema.items() {
                    return self.children_requirements(&s.read());
                }
            }
            _ => (),
        }

        vec![]
    }
}

/// Abstraction which takes care of adding requirements for operations.
struct RequirementCollector<'a, E: Emitter> {
    path: &'a str,
    emitter: &'a E,
    api: &'a ResolvableApi<E::Definition>,
    map: &'a ResolvablePathItem<E::Definition>,
    template_params: HashSet<String>,
}

impl<'a, E> RequirementCollector<'a, E>
where
    E: Emitter,
    E::Definition: Debug,
{
    /// Given a path and an operation map, collect the stuff required
    /// for generating builders later.
    fn collect(mut self) -> Result<(), Error> {
        self.validate_path_and_add_params()?;
        debug!("Collecting builder requirement for {:?}", self.path);

        // Collect all the parameters local to some API call.
        let (unused_params, _) = self.collect_parameters(&self.map.parameters)?;
        // FIXME: What if a body is "required" globally (for all operations)?
        // This means, operations can override the body with some other schema
        // and we may need to map it to the appropriate builders.

        for (&meth, op) in &self.map.methods {
            self.collect_from_operation(meth, op, &unused_params)?;
        }

        // FIXME: If none of the parameters (local to operation or global) specify
        // a body then we should use something (say, `operationID`) to generate
        // a builder and forward `unused_params` to it?
        if self.map.methods.is_empty() {
            warn!(
                "Missing operations for path: {:?}{}",
                self.path,
                if unused_params.is_empty() {
                    ""
                } else {
                    ", but 'parameters' field is specified."
                }
            );
        }

        if !self.template_params.is_empty() {
            return Err(PaperClipError::MissingParametersInPath(
                self.path.into(),
                self.template_params,
            )
            .into());
        }

        Ok(())
    }

    /// Checks whether this path is unique (regardless of its templating)
    /// and returns the list of parameters that exist in the template.
    ///
    /// For example, `/api/{foo}` and `/api/{bar}` are the same, and we
    /// should reject it.
    fn validate_path_and_add_params(&mut self) -> Result<(), PaperClipError> {
        let path_fmt = ResolvableApi::<()>::path_parameters_map(self.path, |p| {
            self.template_params.insert(p.into());
            ":".into()
        });

        let state = self.emitter.state();
        let mut paths = state.rel_paths.borrow_mut();
        let value_absent = paths.insert(path_fmt.clone().into());
        if value_absent {
            Ok(())
        } else {
            Err(PaperClipError::RelativePathNotUnique(self.path.into()))
        }
    }

    /// Collect the parameters local to an API call operation (method).
    fn collect_from_operation(
        &mut self,
        meth: HttpMethod,
        op: &ResolvableOperation<E::Definition>,
        unused_params: &[Parameter],
    ) -> Result<(), Error> {
        let (mut params, schema_path) = self.collect_parameters(&op.parameters)?;
        // If we have unused params which don't exist in the method-specific
        // params (which take higher precedence), then we can copy those inside.
        for global_param in unused_params {
            if params
                .iter()
                .find(|p| p.name == global_param.name)
                .is_none()
            {
                params.push(global_param.clone());
            }
        }

        params = params
            .into_iter()
            .filter(|p| {
                let skip = p.presence == ParameterIn::FormData && schema_path.is_some();
                if skip {
                    warn!(
                        "Skipping form data parameter {:?} in path {:?} because \
                         the operation already has a body.",
                        p.name, self.path
                    );
                }

                !skip
            })
            .collect();

        // If there's a matching object, add the params to its operation.
        if let Some(pat) = schema_path.as_ref() {
            self.bind_schema_to_operation(pat, meth, op, params)?;
        } else {
            self.bind_operation_blindly(meth, op, params)?;
        }

        Ok(())
    }

    /// Collects headers as parameters for all responses in some operation.
    fn collect_response_headers(
        &self,
        responses: &BTreeMap<String, Either<Reference, ResolvableResponse<E::Definition>>>,
    ) -> Vec<Parameter> {
        let mut map = HeaderMap::<Parameter>::with_capacity(2);
        for resp in responses.values() {
            let r = resp.read();
            for (name, info) in &r.headers {
                let name = match HeaderName::from_bytes(name.as_bytes()) {
                    Ok(n) => n,
                    Err(_) => {
                        warn!("Skipping response header {:?} because it's invalid.", name);
                        continue;
                    }
                };

                // Enforce that the parameter is an allowed type and collect it.
                let (ty, mut it_fmts) = match resolve_parameter_type(
                    info.data_type,
                    info.format.as_ref(),
                    info.items.as_ref(),
                ) {
                    Some(t) => t,
                    None => {
                        warn!(
                            "Skipping response header {:?} with unknown type {:?} in path {:?}",
                            name, info.data_type, self.path
                        );
                        continue;
                    }
                };

                validate_collection_format(
                    name.as_str(),
                    info.data_type,
                    ParameterIn::Header,
                    info.collection_format,
                    &mut it_fmts,
                );
                let param = Parameter {
                    name: name.as_str().into(),
                    description: info.description.clone(),
                    ty_path: ty,
                    presence: ParameterIn::Header,
                    required: false,
                    delimiting: it_fmts,
                };

                map.insert(name, param);
            }
        }

        map.into_iter().map(|(_, v)| v).collect()
    }

    /// Given a bunch of resolved parameters, validate and collect a simplified version of them.
    fn collect_parameters(
        &mut self,
        obj_params: &[Either<Reference, ResolvableParameter<E::Definition>>],
    ) -> Result<(Vec<Parameter>, Option<PathBuf>), Error> {
        let def_mods = self.emitter.state().def_mods.borrow();
        let mut schema_path = None;
        let mut params = vec![];
        for param in obj_params {
            let p = param.read();
            p.check(self.path)?; // validate the parameter

            if let Some(def) = p.schema.as_ref() {
                // If a schema exists, then get its path for later use.
                let pat = self.emitter.def_mod_path(&*def.read())?;
                if def_mods.get(&pat).is_some() {
                    schema_path = Some(pat);
                    continue;
                }

                warn!(
                    "Unregistered schema for parameter {:?} in path {:?}: {:?}",
                    p.name, self.path, def
                );
                continue;
            }

            // If this is a parameter that must exist in path, then remove it
            // from the expected list of parameters.
            if p.in_ == ParameterIn::Path {
                self.template_params.remove(&p.name);
            }

            // Enforce that the parameter is an allowed type and collect it.
            let (ty, mut it_fmts) =
                match resolve_parameter_type(p.data_type, p.format.as_ref(), p.items.as_ref()) {
                    Some(t) => t,
                    None => {
                        warn!(
                            "Skipping parameter {:?} with unknown type {:?} in path {:?}",
                            p.name, p.data_type, self.path
                        );
                        continue;
                    }
                };

            validate_collection_format(
                &p.name,
                p.data_type,
                p.in_,
                p.collection_format,
                &mut it_fmts,
            );

            params.push(Parameter {
                name: p.name.clone(),
                description: p.description.clone(),
                ty_path: ty,
                presence: p.in_,
                // NOTE: parameter is required if it's in path
                required: p.required || p.in_ == ParameterIn::Path,
                delimiting: it_fmts,
            });
        }

        Ok((params, schema_path))
    }

    /// Given a schema path, fetch the object and bind the given operation to it.
    fn bind_schema_to_operation(
        &self,
        schema_path: &Path,
        meth: HttpMethod,
        op: &ResolvableOperation<E::Definition>,
        params: Vec<Parameter>,
    ) -> Result<(), Error> {
        trace!(
            "Binding {:?} operation in path {:?} to module {:?}",
            meth,
            self.path,
            schema_path
        );

        let state = self.emitter.state();
        let mut def_mods = state.def_mods.borrow_mut();
        let obj = def_mods.get_mut(schema_path).expect("bleh?");
        let ops = obj[0] // first object is always the globally defined object.
            .paths
            .entry(self.path.into())
            .or_insert_with(Default::default);

        let mut response_contains_any = false;
        let response_ty_path = if let Some(s) = Self::get_2xx_response_schema(&op) {
            let schema = &*s.read();
            response_contains_any = schema.contains_any();
            Some(
                self.emitter
                    .build_def(schema, DefinitionContext::default())?
                    .known_type(),
            )
        } else {
            None
        };

        ops.req.insert(
            meth,
            OpRequirement {
                listable: false,
                id: op.operation_id.clone(),
                description: op.description.clone(),
                deprecated: op.deprecated,
                params,
                response: Response {
                    contains_any: response_contains_any,
                    ty_path: response_ty_path,
                    headers: self.collect_response_headers(&op.responses),
                },
                body_required: true,
                encoding: self.get_coder(op.consumes.as_ref(), &self.api.consumes),
                decoding: self.get_coder(op.produces.as_ref(), &self.api.produces),
            },
        );

        Ok(())
    }

    /// We couldn't attach this operation to any object. Now, we're
    /// just attempting out of desperation.
    fn bind_operation_blindly(
        &self,
        meth: HttpMethod,
        op: &ResolvableOperation<E::Definition>,
        params: Vec<Parameter>,
    ) -> Result<(), Error> {
        // Let's try from the response maybe...
        let s = match Self::get_2xx_response_schema(&op) {
            Some(s) => s,
            None => {
                warn!(
                    "Unable to bind {:?} operation in path {:?} to any known schema.",
                    meth, self.path
                );
                return Ok(());
            }
        };

        let schema = &*s.read();
        let state = self.emitter.state();
        let listable = schema.items().and_then(|s| s.read().data_type()) == Some(DataType::Object);

        let mut unknown_schema_context = None;
        let s = match schema.data_type() {
            // We can deal with object responses.
            Some(DataType::Object) => s.clone(),
            // We can also deal with array of objects by mapping
            // the operation to that object.
            _ if listable => Clone::clone(&**schema.items().unwrap()),
            // But... we can't deal with simple types or nested arrays, so we
            // let the emitter guess something based on this operation.
            _ => {
                let path = self.emitter.unknown_op_mod_path(self.path, meth, op)?;
                if !state.def_mods.borrow().contains_key(&path) {
                    // NOTE: Don't add `ApiObject` directly, because we have to
                    // set appropriate paths.
                    CodegenEmitter(self.emitter).add_objects_to_path(
                        vec![self.emitter.unknown_op_object(self.path, meth, op)?],
                        path.clone(),
                    )?;
                }

                unknown_schema_context = Some((
                    path,
                    self.emitter
                        .build_def(schema, DefinitionContext::default())?
                        .known_type(),
                ));
                s.clone()
            }
        };

        let schema = &*s.read();
        let mut def_mods = state.def_mods.borrow_mut();
        let (obj, response_ty_path) = match unknown_schema_context {
            Some((p, ty)) => (
                def_mods.get_mut(&p).expect("expected misc API object"),
                Some(ty),
            ),
            // If this is known, then we should be able to get the object.
            None => match self
                .emitter
                .def_mod_path(schema)
                .ok()
                .and_then(|p| def_mods.get_mut(&p))
            {
                Some(o) => (o, self.emitter.def_name(schema).ok()),
                None => {
                    warn!(
                        "Skipping unknown response schema for path {:?}: {:?}",
                        self.path, schema
                    );
                    return Ok(());
                }
            },
        };

        let ops = obj[0] // first object is always the globally defined object.
            .paths
            .entry(self.path.into())
            .or_insert_with(Default::default);

        ops.req.insert(
            meth,
            OpRequirement {
                id: op.operation_id.clone(),
                description: op.description.clone(),
                deprecated: op.deprecated,
                params,
                body_required: false,
                listable,
                response: Response {
                    ty_path: response_ty_path,
                    contains_any: schema.contains_any(),
                    headers: self.collect_response_headers(&op.responses),
                },
                encoding: self.get_coder(op.consumes.as_ref(), &self.api.consumes),
                decoding: self.get_coder(op.produces.as_ref(), &self.api.produces),
            },
        );

        Ok(())
    }

    /// Returns the first 2xx response schema in this operation.
    ///
    /// **NOTE:** This assumes that 2xx response schemas are the same for an operation.
    fn get_2xx_response_schema(
        op: &ResolvableOperation<E::Definition>,
    ) -> Option<Arc<RwLock<E::Definition>>> {
        op.responses
            .iter()
            .filter(|(c, _)| c.starts_with('2')) // 2xx response
            .filter_map(|(_, r)| {
                let resp = r.read();
                resp.schema.as_ref().map(|r| (&**r).clone())
            })
            .next()
    }

    /// Returns the coder based on the given local and global media range, and `None`
    /// if it's JSON (as we already support it).
    fn get_coder(
        &self,
        local_ref: Option<&BTreeSet<MediaRange>>,
        global_ref: &BTreeSet<MediaRange>,
    ) -> Option<(String, Arc<Coder>)> {
        let ranges = match local_ref {
            // We don't care if this is empty - if it's empty, then we can assume
            // that it's overridden the global set.
            Some(s) => s,
            None => global_ref,
        };

        let mut coders = ranges
            .iter()
            .filter_map(|r| self.api.coders.matching_coder(r).map(|c| (r, c)))
            .sorted_by(|(_, a), (_, b)| b.prefer.cmp(&a.prefer)); // sort based on preference.

        let (range, coder) = coders
            .next()
            .unwrap_or_else(|| (self.api.spec_format.mime(), self.api.spec_format.coder()));
        if range == &*JSON_MIME {
            return None;
        }

        Some((range.0.as_ref().into(), coder))
    }
}

/// Ensures that a parameter type is either a simple type or an array
/// and returns the resolved Rust type.
fn resolve_parameter_type(
    dt: Option<DataType>,
    dt_fmt: Option<&DataTypeFormat>,
    items: Option<&Items>,
) -> Option<(String, Vec<CollectionFormat>)> {
    match matching_unit_type(dt_fmt, dt) {
        Some(t) => return Some((t.into(), vec![])),
        None if dt == Some(DataType::File) => return Some((FILE_MARKER.into(), vec![])),
        None if dt == Some(DataType::Array) => {
            if let Some(i) = items {
                if let Some((ty, mut fmts)) =
                    resolve_parameter_type(i.data_type, i.format.as_ref(), i.items.as_deref())
                {
                    fmts.insert(0, i.collection_format.unwrap_or_default());
                    // We collect it as `Vec` for now - we'll replace it with our
                    // `Delimited` wrapper when we actually write the code.
                    return Some((String::from("Vec<") + ty.as_str() + ">", fmts));
                }
            }
        }
        None => (),
    }

    None
}

/// Checks if the given type/format matches a known Rust type and returns it.
fn matching_unit_type(
    format: Option<&DataTypeFormat>,
    type_: Option<DataType>,
) -> Option<&'static str> {
    match format {
        Some(DataTypeFormat::Int32) => Some("i32"),
        Some(DataTypeFormat::Int64) => Some("i64"),
        Some(DataTypeFormat::Float) => Some("f32"),
        Some(DataTypeFormat::Double) => Some("f64"),
        _ => match type_ {
            Some(DataType::Integer) => Some("i64"),
            Some(DataType::Number) => Some("f64"),
            Some(DataType::Boolean) => Some("bool"),
            Some(DataType::String) => Some("String"),
            _ => None,
        },
    }
}

/// If the parameter is an array, then validate the collection formats and
/// default if needed.
fn validate_collection_format(
    name: &str,
    data_type: Option<DataType>,
    in_: ParameterIn,
    collection_format: Option<CollectionFormat>,
    it_fmts: &mut Vec<CollectionFormat>,
) {
    if data_type != Some(DataType::Array) {
        return;
    }

    let default_fmt = CollectionFormat::default();
    it_fmts.insert(0, collection_format.unwrap_or(default_fmt));
    it_fmts.pop(); // pop the final format, as it's unnecessary.
    let is_url_encoded = in_ == ParameterIn::Query || in_ == ParameterIn::FormData;
    if it_fmts.contains(&CollectionFormat::Multi) {
        let needs_override = if is_url_encoded {
            let mut fmt_idx_iter = it_fmts
                .iter()
                .enumerate()
                .filter(|&(_, &fmt)| fmt == CollectionFormat::Multi);
            fmt_idx_iter.next().expect("expected collection format?");
            // We support URL encoding multiple values only when it's specified in root.
            fmt_idx_iter.next().is_some()
        } else {
            true
        };

        if needs_override {
            if is_url_encoded {
                info!(
                    "Parameter {:?} in {:?} doesn't allow multiple instances in nested arrays. \
                            Replacing with default ({:?}).",
                    name, in_, default_fmt
                );
            } else {
                info!(
                    "Parameter {:?} is in {:?}, which doesn't allow array values as multiple \
                        instances. Replacing with default ({:?}).",
                    name, in_, default_fmt
                );
            }

            for (i, f) in it_fmts.iter_mut().enumerate() {
                if *f == CollectionFormat::Multi {
                    if i == 0 && is_url_encoded {
                        continue;
                    }

                    *f = default_fmt;
                }
            }
        }
    }
}

'''
'''--- src/v2/codegen/impls.rs ---
use super::{
    emitter::ANY_GENERIC_PARAMETER,
    object::{ApiObject, ApiObjectBuilder, Response, StructField, TypeParameters},
    RUST_KEYWORDS,
};
use crate::v2::models::{CollectionFormat, ParameterIn, JSON_CODER, JSON_MIME};
use heck::{CamelCase, KebabCase, SnekCase};

use std::{
    fmt::{self, Display, Write},
    iter,
    rc::Rc,
};

// Using Debug directly to escape/format strings (so they can be put safely in a YAML property) is broken in Rust < 1.53.0
// See https://github.com/wafflespeanut/paperclip/pull/315#issuecomment-823918807
// See https://github.com/rust-lang/rust/issues/83046
// The following code:
//   - tests (once) if this issue exists in the current context (depends on which version of rustc was used)
//   - provides a function to escape/format strings that works in both cases
static CORRECT_ESCAPING: once_cell::sync::Lazy<bool> =
    once_cell::sync::Lazy::new(|| format!("{:?}", "'") != "\"\\'\"");
fn mk_description_text(str: &str) -> String {
    if *CORRECT_ESCAPING {
        format!("{:?}", str)
    } else {
        format!("{:?}", str).replace("\\'", "'")
    }
}

/// Represents the API object impl.
pub struct ApiObjectImpl<'a> {
    inner: &'a ApiObject,
    // NOTE: `Rc<[T]>` because we shouldn't mutate the stuff later.
    pub(super) builders: Rc<[ApiObjectBuilder<'a>]>,
}

impl ApiObject {
    /// Returns a struct representing the impl for this object. This also
    /// holds the builders generated for this object.
    ///
    /// Each builder is bound to an operation in a path. If the object is not
    /// bound to any operation, then the builder only keeps track of the fields
    /// for building the actual object.
    // FIXME: Make operations generic across builders. This will reduce the
    // number of structs generated.
    pub fn impl_repr<'a>(&'a self, helper_module_prefix: &'a str) -> ApiObjectImpl<'a> {
        if self.inner.is_enum() {
            return ApiObjectImpl {
                inner: self,
                builders: vec![].into(),
            };
        }

        let needs_any = self.fields().iter().any(|f| f.needs_any);
        // Always emit a builder for API objects (regardless of operations).
        let main_builder = ApiObjectBuilder {
            helper_module_prefix,
            object: &self.name,
            body_required: true,
            fields: self.fields(),
            encoding: None,
            needs_any,
            ..Default::default()
        };

        let path_iter = self
            .paths
            .iter()
            .enumerate()
            .flat_map(move |(idx, (path, path_ops))| {
                path_ops
                    .req
                    .iter()
                    .map(move |(&method, req)| ApiObjectBuilder {
                        idx,
                        is_list_op: req.listable,
                        multiple_builders_exist: {
                            let mut iter =
                                self.paths.values().flat_map(|path_ops| path_ops.req.iter());
                            iter.next().is_some() && iter.next().is_some()
                        },
                        helper_module_prefix,
                        rel_path: Some(path),
                        description: req.description.as_deref(),
                        object: &self.name,
                        op_id: req.id.as_deref(),
                        deprecated: req.deprecated,
                        method: Some(method),
                        body_required: req.body_required,
                        encoding: req.encoding.as_ref(),
                        decoding: req.decoding.as_ref(),
                        fields: self.fields(),
                        global_params: &path_ops.params,
                        local_params: &req.params,
                        needs_any: needs_any && req.body_required,
                        response: Response {
                            ty_path: req.response.ty_path.as_deref(),
                            contains_any: req.response.contains_any,
                            headers: &req.response.headers,
                        },
                    })
            });

        ApiObjectImpl {
            inner: self,
            builders: iter::once(if main_builder.fields.is_empty() {
                None
            } else {
                Some(main_builder)
            })
            .filter_map(|b| b)
            .chain(path_iter)
            .collect::<Vec<_>>()
            .into(),
        }
    }
}

impl<'a> ApiObjectImpl<'a> {
    /// Writes the required "clap" subcommand for this object in YAML.
    pub(super) fn write_clap_yaml<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        self.with_cli_cmd_and_builder(|name, builder| {
            write!(f, "\n  - {}:", name)?;
            if let Some(desc) = builder.description {
                write!(f, "\n      about: {}", &mk_description_text(desc))?;
            }

            let mut iter = builder
                .struct_fields_iter()
                .filter(|f| f.prop.is_parameter())
                .peekable();

            // Has at least one argument or body.
            if iter.peek().is_some() || builder.body_required {
                f.write_str("\n      args:")?;
                if builder.body_required {
                    write!(
                        f,
                        "
        - payload:
            long: payload
            help: \"Path to payload (schema: {obj}) or pass '-' for stdin\"
            takes_value: true
            required: true",
                        obj = self.inner.name
                    )?;
                }
            }

            iter.try_for_each(|field| {
                let field_name = field.name.to_kebab_case();
                write!(f, "\n        - {}:", &field_name)?;
                f.write_str("\n            long: ")?;
                f.write_str(&field_name)?;
                if field.prop.is_required() {
                    f.write_str("\n            required: true")?;
                }

                if let Some(desc) = field.desc {
                    write!(f, "\n            help: {}", &mk_description_text(desc))?;
                }

                f.write_str("\n            takes_value: true")
            })
        })?;

        f.write_str("\n")
    }

    /// Writes the match arms associated with this object's operations.
    pub(super) fn write_arg_match_arms<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        self.with_cli_cmd_and_builder(|name, builder| {
            f.write_str("\n        \"")?;
            f.write_str(&name)?;
            f.write_str("\" => {\n            let builder = ")?;
            f.write_str(&builder.helper_module_prefix)?;
            f.write_str(&self.inner.path)?;
            f.write_str("::")?;
            builder.write_name(f)?;
            f.write_str(
                "::from_args(sub_matches)?;
            builder.send_raw(client).await
        },",
            )
        })
    }

    /// Helper function for calling the given closure with the kebab-case
    /// name of the builder (operation) and the actual builder.
    fn with_cli_cmd_and_builder<F, E>(&self, mut call: F) -> Result<(), E>
    where
        F: FnMut(String, &ApiObjectBuilder<'_>) -> Result<(), E>,
    {
        // Ignore objects without any operations (all objects have a default builder).
        if self.builders.len() < 2 {
            return Ok(());
        }

        for builder in &self.builders[1..] {
            let name = match builder.op_id {
                Some(n) => n.to_kebab_case(),
                None => {
                    // FIXME: Investigate what we should do in the absence of operation ID.
                    warn!(
                        "Unable to generate name for operation ({:?} {:?}). Skipping.",
                        builder.method, builder.rel_path,
                    );

                    continue;
                }
            };

            call(name, builder)?;
        }

        Ok(())
    }

    /// Writes the associated function for this object for instantiating builders.
    fn write_builder_methods<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        for builder in &*self.builders {
            let mut temp = String::new();
            let has_fields = builder.has_atleast_one_field();
            if builder.description.is_none() {
                temp.write_str("\n")?;
            }

            if builder.deprecated {
                temp.write_str("    #[deprecated]\n")?;
            }

            // All builder constructor functions are inlined.
            temp.write_str("    #[inline]\n    pub fn ")?;
            if let Some(name) = builder.constructor_fn_name() {
                temp.write_str(&name)?;
                ApiObject::write_docs(builder.description.as_ref(), f, 1)?;
            } else {
                // If we can't generate a name of a builder, then we go for a
                // simple object builder.
                f.write_str("\n    /// Create a builder for this object.")?;
                temp.write_str("builder")?;
            }

            // Now that we've written the docs, we can write the actual method signature.
            f.write_str(&temp)?;
            f.write_str("() -> ")?;
            builder.write_name(f)?;
            builder.write_generics_if_necessary(f, None, TypeParameters::ReplaceAll)?;
            f.write_str(" {\n        ")?;
            builder.write_name(f)?;

            if has_fields || builder.body_required {
                f.write_str(" {")?;
            }

            let needs_container = builder.needs_container();
            if needs_container {
                f.write_str("\n            ")?;
                f.write_str("inner: Default::default(),")?;
            } else if builder.body_required {
                f.write_str("\n            ")?;
                f.write_str("body: Default::default(),")?;
            }

            builder
                .struct_fields_iter()
                .try_for_each::<_, fmt::Result>(|field| {
                    if field.prop.is_required() {
                        f.write_str("\n            ")?;
                        if field.prop.is_parameter() {
                            f.write_str("_param")?;
                        }

                        f.write_str("_")?;
                        f.write_str(&field.name.to_snek_case())?;
                        f.write_str(": core::marker::PhantomData,")?;
                    // If we have a container, then we store parameters inside that.
                    } else if field.prop.is_parameter() && !needs_container {
                        f.write_str("\n            param_")?;
                        f.write_str(&field.name.to_snek_case())?;
                        f.write_str(": None,")?;
                    }

                    Ok(())
                })?;

            if has_fields || builder.body_required {
                f.write_str("\n        }")?;
            }

            f.write_str("\n    }\n")?;
        }

        Ok(())
    }

    /// Writes the `Into` impl for fulfilled builders (if they have a body).
    fn write_into_impl<F>(&self, builder: &ApiObjectBuilder<'_>, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        if !builder.body_required {
            return Ok(());
        }

        let needs_container = builder.needs_container();
        f.write_str("\nimpl")?;
        if builder.needs_any {
            ApiObject::write_any_generic(f)?;
        }

        f.write_str(" Into<")?;
        f.write_str(&self.inner.name)?;
        if builder.needs_any {
            ApiObject::write_any_generic(f)?;
        }

        f.write_str("> for ")?;
        builder.write_name(f)?;
        builder.write_generics_if_necessary(f, None, TypeParameters::ChangeAll)?;
        f.write_str(" {\n    fn into(self) -> ")?;
        f.write_str(&self.inner.name)?;
        if builder.needs_any {
            ApiObject::write_any_generic(f)?;
        }

        f.write_str(" {\n        self.")?;

        if needs_container {
            f.write_str("inner.")?;
        }

        f.write_str("body\n    }\n}\n")
    }
}

/// Represents the API object builder impl.
pub struct ApiObjectBuilderImpl<'a, 'b>(&'a ApiObjectBuilder<'b>);

impl<'a> ApiObjectBuilder<'a> {
    /// Returns a struct representing the impl for this builder.
    pub fn impl_repr(&self) -> ApiObjectBuilderImpl<'_, '_> {
        ApiObjectBuilderImpl(self)
    }
}

impl<'a, 'b> ApiObjectBuilderImpl<'a, 'b>
where
    'b: 'a,
{
    /// Writes impl for getting args from `clap::ArgMatches`
    pub(super) fn write_arg_parsing<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        if self.0.rel_path.is_none() && self.0.method.is_none() {
            return Ok(());
        }

        let needs_container = self.0.needs_container();
        f.write_str("\n#[allow(unused_variables)]\nimpl ")?;
        self.0.write_name(f)?;
        self.0.write_generics_if_necessary(
            f,
            Some(
                self.0
                    .encoding
                    .map(|(_, c)| c.any_value.as_str())
                    .unwrap_or_else(|| JSON_CODER.any_value.as_str()),
            ),
            TypeParameters::ChangeAll,
        )?;

        // NOTE: We're assuming that we've correctly given all the arg requirements to clap.
        f.write_str(
            " {
    pub(crate) fn from_args(matches: Option<&clap::ArgMatches<'_>>) -> Result<Self, crate::ClientError> {",
        )?;
        f.write_str("\n        let thing = ")?;
        self.0.write_name(f)?;
        f.write_str(" {")?;

        if needs_container {
            f.write_str("\n            inner: ")?;
            self.0.write_container_name(f)?;
            f.write_str(" {")?;
        }

        if self.0.body_required {
            write!(
                f,
                "
            body: crate::cli::read_from_input(matches)?,"
            )?;
        }

        let mut phantom = String::new();
        self.0.struct_fields_iter().try_for_each(|field| {
            let (sk, kk) = (field.name.to_snek_case(), field.name.to_kebab_case());
            if field.prop.is_required() {
                phantom.push_str("\n            _");
                if field.prop.is_parameter() {
                    phantom.push_str("param_");
                }
                phantom.push_str(&sk);
                phantom.push_str(": core::marker::PhantomData,");
            }

            if field.prop.is_field() {
                return Ok(());
            }

            f.write_str("\n            param_")?;
            f.write_str(&sk)?;
            let mut ty = String::new();
            ApiObjectBuilder::write_wrapped_ty(
                self.0.helper_module_prefix,
                field.ty,
                field.delimiting,
                &mut ty,
            )?;

            if field.needs_file {
                ty = "std::path::PathBuf".into();
            }

            // We're enforcing requirements in the CLI. We can relax here.
            writeln!(
                f,
                ": matches.and_then(|m| {{
                    m.value_of(\"{arg}\").map(|_| {{
                        value_t!(m, \"{arg}\", {ty}).unwrap_or_else(|e| e.exit())
                    }})
                }}),",
                arg = kk,
                ty = ty
            )
        })?;

        if needs_container {
            f.write_str("\n            },")?;
        }

        f.write_str(&phantom)?;
        f.write_str(
            "
        };

        Ok(thing)
    }
}
",
        )
    }

    /// Builds the method parameter type using the actual field type.
    ///
    /// For example, if a field is `Vec<T>`, then we replace it (in builder method)
    /// with `impl Iterator<Item=Into<T>>`, and if we had `BTreeMap<String, T>`,
    /// then we replace it with `impl Iterator<Item = (String, T)>` and
    /// we do this... recursively.
    // FIXME: Investigate if there's a better way.
    fn write_builder_ty<F>(
        &self,
        ty: &str,
        req: &[String],
        needs_any: bool,
        f: &mut F,
    ) -> fmt::Result
    where
        F: Write,
    {
        if let Some(i) = ty.find('<') {
            if ty[..i].ends_with("Vec") {
                f.write_str("impl Iterator<Item = ")?;
                self.write_builder_ty(&ty[i + 1..ty.len() - 1], req, needs_any, f)?;
                f.write_str(">")?;
            } else if ty[..i].ends_with("std::collections::BTreeMap") {
                f.write_str("impl Iterator<Item = (String, ")?;
                self.write_builder_ty(&ty[i + 9..ty.len() - 1], req, needs_any, f)?;
                f.write_str(")>")?;
            }
        } else if ApiObject::is_simple_type(ty) {
            write!(f, "impl Into<{}", ty)?;
            if needs_any && ty != ANY_GENERIC_PARAMETER {
                ApiObject::write_any_generic(f)?;
            }

            return f.write_str(">");
        } else {
            f.write_str(ty)?;
            if !req.is_empty() {
                f.write_str("Builder<")?;
                req.iter().enumerate().try_for_each(|(i, n)| {
                    if i > 0 {
                        f.write_str(", ")?;
                    }

                    f.write_str(self.0.helper_module_prefix)?;
                    f.write_str("generics::")?;
                    f.write_str(&n.to_camel_case())?;
                    f.write_str("Exists")
                })?;

                if needs_any {
                    f.write_str(", ")?;
                    f.write_str(ANY_GENERIC_PARAMETER)?;
                }

                f.write_str(">")?;
            } else if needs_any {
                ApiObject::write_any_generic(f)?;
            }
        }

        Ok(())
    }

    /// Builds the value conversion block using the actual field type.
    ///
    /// Once we get the value from a builder method (whose type is
    /// generated by `Self::write_builder_ty`), we need to convert it
    /// appropriately. So, whenever we encounter collections, we recursively
    /// collect the iterator items and if it's not a collection, we go for
    /// `value.into()`.
    fn write_value_map<F>(ty: &str, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        if let Some(i) = ty.find('<') {
            if ty[..i].ends_with("Vec") {
                f.write_str("value.map(|value| ")?;
                Self::write_value_map(&ty[i + 1..ty.len() - 1], f)?;
                f.write_str(").collect::<Vec<_>>()")?;
            } else if ty[..i].ends_with("std::collections::BTreeMap") {
                f.write_str("value.map(|(key, value)| (key, ")?;
                Self::write_value_map(&ty[i + 9..ty.len() - 1], f)?;
                f.write_str(")).collect::<std::collections::BTreeMap<_, _>>()")?;
            }
        } else {
            f.write_str("value")?;
        }

        // Always write `into` to ease conversions.
        f.write_str(".into()")
    }

    /// Writes the property-related methods to the given formatter.
    fn write_property_method<F>(&self, field: StructField<'b>, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        let field_name = field.name.to_snek_case();
        let (prop_is_parameter, prop_is_required, needs_container) = (
            field.prop.is_parameter(),
            field.prop.is_required(),
            self.0.needs_container(),
        );
        let collides_with_keyword = RUST_KEYWORDS.iter().any(|&k| k == field_name);
        let needs_trailing_dash = collides_with_keyword && field.prop.is_field();

        ApiObject::write_docs(field.desc, f, 1)?;
        if field.desc.is_none() {
            f.write_str("\n")?;
        }

        // Inline property methods.
        f.write_str("    #[inline]\n    pub fn ")?;
        f.write_str(&field_name)?;
        if collides_with_keyword {
            f.write_str("_")?;
        }

        f.write_str("(mut self, value: ")?;
        if field.needs_file {
            f.write_str("impl AsRef<std::path::Path>")?;
        } else {
            self.write_builder_ty(&field.ty, &field.strict_child_fields, field.needs_any, f)?;
        }

        f.write_str(") -> ")?;
        if prop_is_required {
            self.0.write_name(f)?;
            self.0
                .write_generics_if_necessary(f, None, TypeParameters::ChangeOne(field.name))?;
        } else {
            f.write_str("Self")?;
        }

        f.write_str(" {\n        self.")?;
        if needs_container {
            f.write_str("inner.")?;
        }

        if prop_is_parameter {
            f.write_str("param_")?;
        // If it's not a parameter, then it's definitely a body field.
        } else if self.0.body_required {
            f.write_str("body.")?;
        }

        f.write_str(&field_name)?;
        if needs_trailing_dash {
            f.write_str("_")?;
        }

        f.write_str(" = ")?;
        if prop_is_parameter || !prop_is_required {
            f.write_str("Some(")?;
        }

        if field.needs_file {
            f.write_str("value.as_ref().into()")?;
        } else if field.overridden && self.0.body_required {
            // If there's a field in the body with similar name and type,
            // then override it with this value.
            f.write_str("{\n            let val = ")?;
            Self::write_value_map(field.ty, f)?;
            f.write_str(";\n            self.")?;
            if needs_container {
                f.write_str("inner.")?;
            }

            f.write_str("body.")?;
            f.write_str(&field_name)?;
            if needs_trailing_dash {
                f.write_str("_")?;
            }

            f.write_str(" = val.clone().into();")?;
            f.write_str("\n            val\n        }")?;
        } else {
            Self::write_value_map(field.ty, f)?;
        }

        if prop_is_parameter || !prop_is_required {
            f.write_str(")")?;
        }

        f.write_str(";\n        ")?;
        // We need to transmute only if there's a required field/parameter.
        if prop_is_required {
            f.write_str("unsafe { std::mem::transmute(self) }")?;
        } else {
            f.write_str("self")?;
        }

        f.write_str("\n    }\n")
    }
}

/// Codegen for `Sendable` trait for operation builders.
struct SendableCodegen<'a, 'b> {
    builder: &'a ApiObjectBuilder<'b>,
    needs_container: bool,
    is_multipart: bool,
    path_items: String,
    headers: String,
    form: String,
    query: String,
    multi_value_query: Vec<String>,
}

impl<'a, 'b> From<&'a ApiObjectBuilder<'b>> for SendableCodegen<'a, 'b> {
    fn from(builder: &'a ApiObjectBuilder<'b>) -> Self {
        SendableCodegen {
            builder,
            needs_container: builder.needs_container(),
            path_items: String::new(),
            headers: String::new(),
            is_multipart: builder.struct_fields_iter().any(|f| f.needs_file),
            form: String::new(),
            query: String::new(),
            multi_value_query: vec![],
        }
    }
}

impl<'a, 'b> SendableCodegen<'a, 'b> {
    /// Determine and write `Sendable` impl (if it's needed for this builder).
    fn write_impl_if_needed<F>(mut self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        let (path, method) = match (self.builder.rel_path, self.builder.method) {
            (Some(p), Some(m)) => (p, m),
            _ => return Ok(()),
        };

        f.write_str("\n")?;
        if self.builder.response.is_file() {
            f.write_str("#[async_trait::async_trait]\n")?;
        }

        f.write_str("impl<Client: ")?;
        f.write_str(self.builder.helper_module_prefix)?;
        f.write_str("client::ApiClient + Sync + 'static")?;

        if self.builder.needs_any {
            f.write_str(", Any: serde::Serialize")?;
        }

        f.write_str("> ")?;
        f.write_str(self.builder.helper_module_prefix)?;
        f.write_str("client::Sendable<Client> for ")?;
        self.builder.write_name(f)?;
        self.builder
            .write_generics_if_necessary(f, None, TypeParameters::ChangeAll)?;
        f.write_str(" {\n    type Output = ")?;
        let accepted_range = self.write_output_ty(f)?;

        f.write_str(";\n\n    const METHOD: http::Method = http::Method::")?;
        f.write_str(&method.to_string().to_uppercase())?;
        f.write_str(";\n\n    fn rel_path(&self) -> std::borrow::Cow<'static, str> {\n        ")?;

        self.builder
            .struct_fields_iter()
            .for_each(|field| match field.param_loc {
                Some(ParameterIn::Path) => self.handle_path_param(field),
                Some(ParameterIn::Header) => self.handle_header_param(field),
                Some(ParameterIn::FormData) => self.handle_form_param(field),
                Some(ParameterIn::Query) => self.handle_query_param(field),
                _ => (),
            });

        // Determine if we need a `&'static str` or `String`
        if self.path_items.is_empty() {
            write!(f, "\"{}\".into()", path)?;
        } else {
            write!(f, "format!(\"{}\"{}).into()", path, self.path_items)?;
        }

        f.write_str("\n    }")?;

        // Check whether `modify` method needs to be overridden (i.e. body and other params).
        if self.builder.body_required
            || !self.form.is_empty()
            || !self.query.is_empty()
            || !self.multi_value_query.is_empty()
            || !self.headers.is_empty()
        {
            self.write_modify_method(f, accepted_range)?;
        }

        if self.builder.response.is_file() {
            self.write_file_acceptor(f)?;
        }

        f.write_str("\n}\n")?;
        self.write_response_headers_impl(f)
    }

    fn write_response_headers_impl<F: Write>(&mut self, f: &mut F) -> fmt::Result {
        if self.builder.response.headers.is_empty() {
            return Ok(());
        }

        f.write_str("\nimpl")?;
        if self.builder.needs_any {
            ApiObject::write_any_generic(f)?;
        }

        write!(
            f,
            " {}client::ResponseWrapper<",
            self.builder.helper_module_prefix
        )?;
        self.write_output_ty(f)?;
        f.write_str(", ")?;
        self.builder.write_name(f)?;
        self.builder
            .write_generics_if_necessary(f, None, TypeParameters::ChangeAll)?;
        f.write_str("> {")?;

        self.builder
            .response
            .headers
            .iter()
            .try_for_each(|header| {
                let name = header.name.to_snek_case();
                let collides_with_keyword = RUST_KEYWORDS.iter().any(|&k| k == name);
                ApiObject::write_docs(header.description.as_ref(), f, 1)?;
                if header.description.is_none() {
                    f.write_str("\n")?;
                }

                // Inline property methods.
                f.write_str("    #[inline]\n    pub fn ")?;
                f.write_str(&name)?;
                if collides_with_keyword {
                    f.write_str("_")?;
                }

                f.write_str("(&self) -> Option<")?;
                ApiObjectBuilder::write_wrapped_ty(
                    &self.builder.helper_module_prefix,
                    &header.ty_path,
                    &header.delimiting,
                    f,
                )?;
                write!(
                    f,
                    "> {{
        self.headers.get({:?}).and_then(|v| String::from_utf8_lossy(v.as_ref()).parse().ok())
    }}",
                    header.name
                )
            })?;

        f.write_str("\n}\n")
    }

    /// Writes the output type for a `Sendable` implementor and returns
    /// acceptable media range if it's "any" type.
    fn write_output_ty<F>(&mut self, f: &mut F) -> Result<Option<String>, fmt::Error>
    where
        F: Write,
    {
        if self.builder.is_list_op {
            f.write_str("Vec<")?;
        }

        if self.builder.response.is_file() {
            write!(f, "{prefix}util::ResponseStream<<<Client as {prefix}client::ApiClient>::Response as {prefix}client::Response>::Bytes, <<Client as {prefix}client::ApiClient>::Response as {prefix}client::Response>::Error>",
                   prefix=self.builder.helper_module_prefix)?;
        } else if let Some(resp) = self.builder.response.ty_path.as_ref() {
            // If we've acquired a response type, then write that.
            f.write_str(resp)?;
        }

        // If the type has `Any` or if we don't know what we're going to get, then
        // assume we have to write `Any` type.
        let mut accepted_range = None;
        if self.builder.needs_any
            || self.builder.response.ty_path.is_none()
            || self.builder.response.contains_any
        {
            let (range, coder) = match self.builder.decoding {
                Some(&(ref r, ref c)) => (r.as_str(), c),
                None => ((*JSON_MIME).0.as_ref(), &*JSON_CODER),
            };

            accepted_range = Some(range);
            if self.builder.response.ty_path.is_some() {
                write!(f, "<{}>", coder.any_value)?;
            } else {
                f.write_str(&coder.any_value)?;
            }
        }

        if self.builder.is_list_op {
            f.write_str(">")?;
        }

        Ok(accepted_range.map(|s| s.to_owned()))
    }

    /// Handle field for a path parameter.
    fn handle_path_param(&mut self, field: StructField) {
        let _ = write!(self.path_items, ", {}=self.", &field.name);
        let name = field.name.to_snek_case();
        if self.needs_container {
            self.path_items.push_str("inner.");
        }

        let _ = write!(
            self.path_items,
            "param_{name}.as_ref().expect(\"missing parameter {name}?\")",
            name = name
        );
    }

    /// Handle field for a header parameter.
    fn handle_header_param(&mut self, field: StructField) {
        let is_required = field.prop.is_required();
        let name = field.name.to_snek_case();
        let mut param_ref = String::from("&self.");
        if self.needs_container {
            param_ref.push_str("inner.");
        }

        param_ref.push_str("param_");
        param_ref.push_str(&name);
        param_ref.push_str(".as_ref().map(std::string::ToString::to_string)");
        if is_required {
            let _ = write!(param_ref, ".expect(\"missing parameter {}?\")", name);
        }

        if !is_required {
            let _ = write!(self.headers, "\n        if let Some(v) = {} {{", param_ref);
        }

        self.headers.push_str("\n        ");
        if !is_required {
            self.headers.push_str("    ");
        }

        let _ = write!(
            self.headers,
            "req = req.header({:?}, {});",
            &field.name,
            if is_required { &param_ref } else { "&v" }
        );

        if !is_required {
            self.headers.push_str("\n        }");
        }
    }

    /// Handle field for a form data parameter.
    fn handle_form_param(&mut self, field: StructField) {
        let name = field.name.to_snek_case();
        if let Some(CollectionFormat::Multi) = field.delimiting.get(0) {
            let _ = write!(
                self.form,
                "
            if let Some(stuff) = self.{}param_{}.as_ref() {{
                for v in stuff.iter() {{
                    {}({:?}, {}v.to_string());
                }}
            }}",
                if self.needs_container { "inner." } else { "" },
                name,
                if self.is_multipart {
                    "form = form.text"
                } else {
                    "ser.append_pair"
                },
                &field.name,
                if self.is_multipart { "" } else { "&" },
            );

            return;
        }

        if field.needs_file {
            let _ = write!(
                self.form,
                "
            if let Some(v) = self.{}param_{}.as_ref() {{
                form = form.file({:?}, v)?;
            }}",
                if self.needs_container { "inner." } else { "" },
                name,
                &field.name,
            );

            return;
        }

        self.form.push_str("\n            if let Some(v) = self.");
        if self.needs_container {
            self.form.push_str("inner.");
        }

        let _ = write!(
            self.form,
            "param_{}.as_ref() {{
                {}({:?}, {}v.to_string());
            }}",
            name,
            if self.is_multipart {
                "form = form.text"
            } else {
                "ser.append_pair"
            },
            &field.name,
            if self.is_multipart { "" } else { "&" },
        );
    }

    /// Handle field for an URL query parameter.
    fn handle_query_param(&mut self, field: StructField) {
        let name = field.name.to_snek_case();
        if let Some(CollectionFormat::Multi) = field.delimiting.get(0) {
            self.multi_value_query.push(format!(
                "
            &self.{}param_{}.as_ref().map(|v| {{
                v.iter().map(|v| ({:?}, v.to_string())).collect::<Vec<_>>()
            }}).unwrap_or_default()",
                if self.needs_container { "inner." } else { "" },
                name,
                &field.name,
            ));

            return;
        }

        if !self.query.is_empty() {
            self.query.push_str(",");
        }

        let _ = write!(self.query, "\n            ({:?}, self.", &field.name);
        if self.needs_container {
            self.query.push_str("inner.");
        }

        let _ = write!(
            self.query,
            "param_{name}.as_ref().map(std::string::ToString::to_string))",
            name = name
        );
    }

    /// We have determined that we have to override the default `modify` method.
    fn write_modify_method<F>(&mut self, f: &mut F, accepted_range: Option<String>) -> fmt::Result
    where
        F: Write,
    {
        f.write_str("\n\n    fn modify(&self, req: Client::Request) -> Result<Client::Request, ")?;
        f.write_str(&self.builder.helper_module_prefix)?;
        f.write_str("client::ApiError<Client::Response>> {")?;
        f.write_str("\n        use ")?;
        f.write_str(&self.builder.helper_module_prefix)?;
        f.write_str("client::Request;")?;

        if !self.headers.is_empty() {
            f.write_str("\n        let mut req = req;")?;
            f.write_str(&self.headers)?;
            f.write_str("\n")?;
        }

        f.write_str("\n        Ok(req")?;
        if self.builder.body_required {
            f.write_str("\n        ")?;
            if let Some((range, coder)) = self.builder.encoding {
                write!(
                    f,
                    ".header(http::header::CONTENT_TYPE.as_str(), {:?})",
                    range
                )?;

                f.write_str(
                    "\n        .body_bytes({
            let mut vec = vec![];
            ",
                )?;
                f.write_str(&coder.encoder_path)?;
                f.write_str("(&mut vec, ")?;
            } else {
                f.write_str(".json(")?;
            }

            f.write_str("&self.")?;
            if self.needs_container {
                f.write_str("inner.")?;
            }

            f.write_str("body)")?;

            if self.builder.encoding.is_some() {
                f.write_str("?;\n            vec\n        })")?;
            }
        }

        if let Some(r) = accepted_range {
            write!(
                f,
                "\n        .header(http::header::ACCEPT.as_str(), {:?})",
                r
            )?;
        }

        if !self.form.is_empty() && self.is_multipart {
            write!(
                f,
                "
        .multipart_form_data({{
            use {prefix}client::Form;
            let mut form = <Client::Request as Request>::Form::new();",
                prefix = self.builder.helper_module_prefix
            )?;
            f.write_str(&self.form)?;
            f.write_str(
                "
            form
        })",
            )?;
        } else if !self.form.is_empty() {
            f.write_str(
                "
        .body_bytes({
            let mut ser = url::form_urlencoded::Serializer::new(String::new());",
            )?;
            f.write_str(&self.form)?;
            f.write_str(
                "
            ser.finish().into_bytes()\n        })",
            )?;
            f.write_str(
                "
        .header(http::header::CONTENT_TYPE.as_str(), \"application/x-www-form-urlencoded\")",
            )?;
        }

        if !self.query.is_empty() {
            f.write_str("\n        .query(&[")?;
            f.write_str(&self.query)?;
            f.write_str("\n        ])")?;
        }

        for q in self.multi_value_query.drain(..) {
            f.write_str("\n        .query({")?;
            f.write_str(&q)?;
            f.write_str("\n        })")?;
        }

        f.write_str(")\n    }")
    }

    /// Writes async `send` method for this operation assuming that the response is a file.
    fn write_file_acceptor<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        write!(
            f,
            "

    async fn send(&self, client: &Client) -> Result<{prefix}client::ResponseWrapper<Self::Output, Self>, {prefix}client::ApiError<Client::Response>> {{
        use {prefix}client::Response;
        let resp = self.send_raw(client).await?;
        Ok({prefix}client::ResponseWrapper::wrap(resp, |r| async {{
            Ok({prefix}util::ResponseStream(r.stream()))
        }}).await.unwrap())
    }}",
            prefix = self.builder.helper_module_prefix
        )
    }
}

impl<'a> Display for ApiObjectImpl<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.builders.is_empty() {
            return Ok(());
        }

        f.write_str("impl")?;
        let needs_any = self.inner.fields().iter().any(|f| f.needs_any);
        if needs_any {
            f.write_str("<")?;
            f.write_str(ANY_GENERIC_PARAMETER)?;
            f.write_str(": Default")?;
            f.write_str(">")?;
        }

        f.write_str(" ")?;
        f.write_str(&self.inner.name)?;
        if needs_any {
            ApiObject::write_any_generic(f)?;
        }

        f.write_str(" {")?;
        self.write_builder_methods(f)?;
        f.write_str("}\n")?;

        for builder in &*self.builders {
            self.write_into_impl(builder, f)?;
        }

        Ok(())
    }
}

impl<'a, 'b> Display for ApiObjectBuilderImpl<'a, 'b> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut generics = String::new();
        self.0
            .write_generics_if_necessary(&mut generics, None, TypeParameters::Generic)?;

        let mut has_fields = false;
        self.0
            .struct_fields_iter()
            .filter(|f| (self.0.body_required && f.prop.is_field()) || f.prop.is_parameter())
            .enumerate()
            .try_for_each(|(i, field)| {
                if i == 0 {
                    has_fields = true;
                    f.write_str("impl")?;
                    f.write_str(&generics)?;
                    f.write_str(" ")?;
                    self.0.write_name(f)?;
                    f.write_str(&generics)?;
                    f.write_str(" {")?;
                }

                self.write_property_method(field, f)
            })?;

        if has_fields {
            f.write_str("}\n")?;
        }

        SendableCodegen::from(self.0).write_impl_if_needed(f)
    }
}

'''
'''--- src/v2/codegen/mod.rs ---
//! Code generation for OpenAPI v2.

#[cfg(feature = "cli")]
mod author;
mod emitter;
mod impls;
pub mod object;
mod state;
include!(concat!(env!("OUT_DIR"), "/template.rs"));

pub use self::{
    emitter::{EmittedUnit, Emitter},
    state::EmitterState,
};

use super::Schema;

use std::{fmt::Debug, marker::PhantomData};

/// Common conflicting keywords in Rust. An underscore will be added
/// to fields using these keywords.
const RUST_KEYWORDS: &[&str] = &[
    "as", "break", "const", "continue", "crate", "dyn", "else", "enum", "extern", "false", "fn",
    "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref",
    "return", "self", "Self", "static", "struct", "super", "trait", "true", "type", "unsafe",
    "use", "where", "while", "do",
];

/// Default emitter for anything that implements `Schema` trait.
///
/// This doesn't do anything special, as `Emitter` trait methods take
/// care of all the heavy load.
pub struct DefaultEmitter<S> {
    state: EmitterState,
    _schema: PhantomData<S>,
}

impl<S> From<EmitterState> for DefaultEmitter<S> {
    fn from(state: EmitterState) -> Self {
        DefaultEmitter {
            state,
            _schema: PhantomData,
        }
    }
}

impl<S: Schema + Debug> Emitter for DefaultEmitter<S> {
    type Definition = S;

    fn state(&self) -> &EmitterState {
        &self.state
    }
}

/// Metadata for generating a crate.
#[derive(Debug, Default, Clone)]
pub struct CrateMeta {
    /// Name of the crate. If this is not specified, then the name of the
    /// working directory is assumed to be crate name.
    pub name: Option<String>,
    /// Version (defaults to 0.1.0)
    pub version: Option<String>,
    /// List of authors for this crate. Defaults to cargo's defaults.
    pub authors: Option<Vec<String>>,
    /// Whether we're planning to emit a lib, app or module.
    pub mode: EmitMode,
    /// Whether or not to make this a root crate.
    pub no_root: bool,
    // Marker to avoid potential breakage when more public fields come in.
    _marker: (),
}

/// Mode of codegen (module, crate or CLI app).
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum EmitMode {
    Module,
    Crate,
    App,
}

impl Default for EmitMode {
    fn default() -> Self {
        // NOTE: Module by default - CLI will specify other modes if needed.
        EmitMode::Module
    }
}

'''
'''--- src/v2/codegen/object.rs ---
//! Simplified objects for codegen.
//!
//! This contains the necessary objects for generating actual
//! API objects, their builders, impls, etc.

pub use super::impls::{ApiObjectBuilderImpl, ApiObjectImpl};

use super::{
    emitter::{ANY_GENERIC_PARAMETER, EXTRA_PROPS_FIELD, FILE_MARKER},
    RUST_KEYWORDS,
};
use crate::v2::models::{Coder, CollectionFormat, HttpMethod, ParameterIn};
use heck::{CamelCase, SnekCase};
use once_cell::sync::Lazy;
use regex::{Captures, Regex};

use std::{
    collections::{BTreeMap, HashSet},
    fmt::{self, Display, Write},
    iter,
    sync::Arc,
};

/// Regex for appropriate escaping in docs.
static DOC_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"\[|\]").expect("invalid doc regex?"));

/// Represents a (simplified) Rust struct or enum.
#[derive(Default, Debug, Clone)]
pub struct ApiObject {
    /// Name of the struct (camel-cased).
    pub name: String,
    /// Description for this object (if any), to be used for docs.
    pub description: Option<String>,
    /// Path to this object from (generated) root module.
    pub path: String,
    /// Fields/variants based on whether this is a struct/enum.
    pub inner: ObjectContainer,
    /// Paths with operations which address this object.
    pub paths: BTreeMap<String, PathOps>,
}

impl ApiObject {
    /// Get a mutable reference to the struct fields. **Panics** if this
    /// is not a struct.
    pub fn fields_mut(&mut self) -> &mut Vec<ObjectField> {
        match &mut self.inner {
            ObjectContainer::Struct { fields } => fields,
            _ => panic!("cannot obtain fields for enum type"),
        }
    }

    /// Get a reference to the struct fields. **Panics** if this
    /// is not a struct.
    pub fn fields(&self) -> &[ObjectField] {
        match &self.inner {
            ObjectContainer::Struct { fields } => fields,
            _ => panic!("cannot obtain fields for enum type"),
        }
    }

    /// Get a mutable reference to the enum variants. **Panics** if this
    /// is not an enum.
    pub fn variants_mut(&mut self) -> &mut Vec<ObjectVariant> {
        match &mut self.inner {
            ObjectContainer::Enum { variants, .. } => variants,
            _ => panic!("cannot obtain fields for enum type"),
        }
    }

    /// Get a reference to the enum variants. **Panics** if this
    /// is not an enum.
    pub fn variants(&self) -> &[ObjectVariant] {
        match &self.inner {
            ObjectContainer::Enum { variants, .. } => variants,
            _ => panic!("cannot obtain fields for enum type"),
        }
    }
}

/// Container for the struct/enum containing fields/variants.
#[derive(Debug, Clone)]
pub enum ObjectContainer {
    Enum {
        /// Variants if it's an enum.
        ///
        /// **NOTE:** Currently, we only support simple enums.
        variants: Vec<ObjectVariant>,
        /// Flag to represent whether this enum is a string.
        /// When that's the case, we leave de/serialization to
        /// serde completely.
        is_string: bool,
    },
    Struct {
        /// Fields if it's a struct.
        fields: Vec<ObjectField>,
    },
}

impl ObjectContainer {
    /// Returns whether this object is an enum.
    pub fn is_enum(&self) -> bool {
        match self {
            ObjectContainer::Enum { .. } => true,
            _ => false,
        }
    }

    /// Returns whether this enum is to represent a string.
    pub fn is_string_enum(&self) -> bool {
        match self {
            ObjectContainer::Enum { is_string, .. } => *is_string,
            _ => false,
        }
    }
}

/// Operations in a path.
#[derive(Default, Debug, Clone)]
pub struct PathOps {
    /// Operations for this object and their associated requirements.
    pub req: BTreeMap<HttpMethod, OpRequirement>,
    /// Parameters required for all operations in this path.
    pub params: Vec<Parameter>,
}

/// Requirement for an object corresponding to some operation.
#[derive(Debug, Clone)]
pub struct OpRequirement {
    /// Operation ID (if it's provided in the schema).
    ///
    /// If there are multiple operations for the same path, then we
    /// attempt to use this.
    pub id: Option<String>,
    /// Description of this operation (if any), to be used for docs.
    pub description: Option<String>,
    /// Whether the operation is deprecated or not.
    pub deprecated: bool,
    /// Parameters required for this operation.
    pub params: Vec<Parameter>,
    /// Whether the object itself is required (in body) for this operation.
    pub body_required: bool,
    /// Whether this operation returns a list of the associated `ApiObject`.
    pub listable: bool,
    /// Response information for this operation.
    pub response: Response<String, Vec<Parameter>>,
    /// Preferred media range and encoder for the client. This is ignored for
    /// methods that don't accept a body. If there's no coder, then JSON
    /// encoding is assumed.
    pub encoding: Option<(String, Arc<Coder>)>,
    /// Preferred media range and decoder for the client. This is used only
    /// when objects make use of `Any` type. If there's no coder, then JSON
    /// encoding is assumed.
    pub decoding: Option<(String, Arc<Coder>)>,
}

#[derive(Default, Debug, Clone)]
pub struct Response<S, H> {
    /// Type path for this operation's response (if any). If this is empty,
    /// then we go for `Any`.
    pub ty_path: Option<S>,
    /// Whether the response contains an `Any`. This is useful when operations
    /// get bound to some other object.
    pub contains_any: bool,
    /// Custom response headers for this operation (if any).
    pub headers: H,
}

impl<S, H> Response<S, H>
where
    S: AsRef<str>,
{
    /// Returns whether this response is a file.
    pub fn is_file(&self) -> bool {
        self.ty_path
            .as_ref()
            .map(|s| s.as_ref() == FILE_MARKER)
            .unwrap_or_default()
    }
}

/// Represents some parameter somewhere (header, path, query, etc.).
#[derive(Debug, Clone)]
pub struct Parameter {
    /// Name of the parameter.
    pub name: String,
    /// Description of this operation (if any), to be used for docs.
    pub description: Option<String>,
    /// Type of the parameter as a path.
    pub ty_path: String,
    /// Whether this parameter is required.
    pub required: bool,
    /// Where the parameter lives.
    pub presence: ParameterIn,
    /// If the parameter is an array of values, then the format for collecting them.
    pub delimiting: Vec<CollectionFormat>,
}

/// Represents an enum variant.
#[derive(Debug, Clone)]
pub struct ObjectVariant {
    /// Name of the variant (case unspecified).
    pub name: String,
    /// Value of this variant (if any). Note that this is only applicable
    /// for simple enums, and it's ignored entirely for string enums.
    pub value: serde_json::Value,
}

/// Represents a struct field.
#[derive(Debug, Clone)]
pub struct ObjectField {
    /// Name of the field.
    pub name: String,
    /// Type of the field as a path.
    pub ty_path: String,
    /// Description of this operation (if any), to be used for docs.
    pub description: Option<String>,
    /// Whether this field is required (i.e., not optional).
    pub is_required: bool,
    /// Whether this field's type "is" or "has" an `Any` type.
    pub needs_any: bool,
    /// Whether this field should be boxed.
    pub boxed: bool,
    /// Required fields of the "deepest" child type in the given definition.
    ///
    /// Now, what do I mean by "deepest"? For example, if we had `Vec<Vec<Vec<T>>>`
    /// or `Vec<BTreeMap<String, Vec<BTreeMap<String, T>>>>`, then "deepest" child
    /// type is T (as long as it's not a `Vec` or `BTreeMap`).
    ///
    /// To understand why we're doing this, see `ApiObjectBuilderImpl::write_builder_ty`
    /// and `ApiObjectBuilderImpl::write_value_map` functions.
    ///
    /// Yours sincerely.
    pub child_req_fields: Vec<String>,
}

impl ApiObject {
    /// Create an object with the given name.
    pub fn with_name<S>(name: S) -> Self
    where
        S: Into<String>,
    {
        ApiObject {
            name: name.into(),
            // NOTE: Even though `path` is empty, it'll be replaced by the emitter.
            ..Default::default()
        }
    }

    /// Writes `Any` as a generic parameter (including `<>`).
    pub(super) fn write_any_generic<F>(f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        f.write_str("<")?;
        f.write_str(ANY_GENERIC_PARAMETER)?;
        f.write_str(">")
    }

    /// Writes the given string (if any) as Rust documentation into
    /// the given formatter.
    pub(super) fn write_docs<F, S>(stuff: Option<S>, f: &mut F, levels: usize) -> fmt::Result
    where
        F: Write,
        S: AsRef<str>,
    {
        let indent = iter::repeat(' ').take(levels * 4).collect::<String>();
        if let Some(desc) = stuff.as_ref() {
            desc.as_ref().split('\n').try_for_each(|line| {
                f.write_str("\n")?;
                f.write_str(&indent)?;
                f.write_str("///")?;
                if line.is_empty() {
                    return Ok(());
                }

                f.write_str(" ")?;
                f.write_str(
                    &DOC_REGEX
                        .replace_all(line, |c: &Captures| match &c[0] {
                            "[" => "\\[",
                            "]" => "\\]",
                            _ => unreachable!(),
                        })
                        .trim_end(),
                )
            })?;
            f.write_str("\n")?;
        }

        Ok(())
    }

    /// Returns whether this type is simple (i.e., not an object defined by us).
    #[inline]
    pub(super) fn is_simple_type(ty: &str) -> bool {
        !ty.contains("::") || ty.ends_with("Delimited")
    }

    /// Assuming that the given type "is" or "has" `Any`, this adds
    /// the appropriate generic parameter.
    fn write_field_with_any<F>(ty: &str, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        if let Some(i) = ty.find('<') {
            if ty[..i].ends_with("Vec") {
                f.write_str(&ty[..=i])?;
                Self::write_field_with_any(&ty[i + 1..ty.len() - 1], f)?;
            } else if ty[..i].ends_with("std::collections::BTreeMap") {
                f.write_str(&ty[..i + 9])?;
                Self::write_field_with_any(&ty[i + 9..ty.len() - 1], f)?;
            } else {
                unreachable!("no other generics expected.");
            }

            f.write_str(">")?;
            return Ok(());
        }

        f.write_str(ty)?;
        if !Self::is_simple_type(ty) {
            Self::write_any_generic(f)?;
        }

        Ok(())
    }
}

/// Represents a builder struct for some API object.
#[derive(Default, Debug, Clone)]
pub(super) struct ApiObjectBuilder<'a> {
    /// Index of this builder.
    pub idx: usize,
    /// Description if any, for docs.
    pub description: Option<&'a str>,
    /// Whether body is required for this builder.
    pub body_required: bool,
    /// Prefix for addressing stuff from crate root.
    pub helper_module_prefix: &'a str,
    /// Operation ID, if any.
    pub op_id: Option<&'a str>,
    /// Whether the operation is deprecated or not.
    pub deprecated: bool,
    /// HTTP method for the operation - all builders (other than object builders)
    /// have this.
    pub method: Option<HttpMethod>,
    /// Relative URL path - presence is same as HTTP method.
    pub rel_path: Option<&'a str>,
    /// Whether this operation returns a list object.
    pub is_list_op: bool,
    /// Response for this operation, if any.
    pub response: Response<&'a str, &'a [Parameter]>,
    /// Object to which this builder belongs to.
    pub object: &'a str,
    /// Encoding for the operation, if it's not JSON.
    pub encoding: Option<&'a (String, Arc<Coder>)>,
    /// Decoding for the operation, if it's not JSON.
    ///
    /// **NOTE:** We use this to set the `Accept` header for operations
    /// which return objects that are (or have) `Any` type.
    pub decoding: Option<&'a (String, Arc<Coder>)>,
    /// Whether there are multiple builders for this object.
    pub multiple_builders_exist: bool,
    /// Fields in this builder.
    pub fields: &'a [ObjectField],
    /// Parameters global to this URL path.
    pub global_params: &'a [Parameter],
    /// Parameters local to this operation.
    pub local_params: &'a [Parameter],
    /// Whether this builder is generic over `Any` type.
    pub needs_any: bool,
}

/// The property we're dealing with.
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub(super) enum Property {
    RequiredField,
    OptionalField,
    RequiredParam,
    OptionalParam,
}

impl Property {
    /// Whether this property is required.
    pub(super) fn is_required(self) -> bool {
        match self {
            Property::RequiredField | Property::RequiredParam => true,
            _ => false,
        }
    }

    /// Checks whether this property is a parameter.
    pub(super) fn is_parameter(self) -> bool {
        match self {
            Property::RequiredParam | Property::OptionalParam => true,
            _ => false,
        }
    }

    /// Checks whether this property is a field.
    pub(super) fn is_field(self) -> bool {
        match self {
            Property::RequiredField | Property::OptionalField => true,
            _ => false,
        }
    }
}

/// See `ApiObjectBuilder::write_generics_if_necessary`
pub(super) enum TypeParameters<'a> {
    Generic,
    ChangeOne(&'a str),
    ReplaceAll,
    ChangeAll,
}

/// Represents a Rust struct field (could be actual object field or a parameter).
#[derive(Debug, Clone)]
pub(super) struct StructField<'a> {
    /// Name of this field (case unspecified).
    pub name: &'a str,
    /// Type of this field.
    pub ty: &'a str,
    /// What this field represents.
    pub prop: Property,
    /// Description for this field (if any), for docs.
    pub desc: Option<&'a str>,
    /// Whether this field had a collision (i.e., between parameter and object field)
    pub overridden: bool,
    /// Required fields of child needed for this field. If they exist, then we
    /// switch to requiring a builder.
    pub strict_child_fields: &'a [String],
    /// Delimiting for array values (if it is a parameter).
    pub delimiting: &'a [CollectionFormat],
    /// Location of the parameter (if it is a parameter).
    pub param_loc: Option<ParameterIn>,
    /// Whether this field "is" or "has" `Any` type. This is only
    /// applicable for object fields.
    pub needs_any: bool,
    /// Whether this field indicates a file upload.
    pub needs_file: bool,
}

impl<'a> ApiObjectBuilder<'a> {
    /// Name of the constructor function which creates this builder.
    pub fn constructor_fn_name(&self) -> Option<String> {
        match (self.op_id, self.method) {
            // If there's an operation ID, then we go for that ...
            (Some(id), _) => Some(id.to_snek_case()),
            // If there's a method and we *don't* have any collisions
            // (i.e., two or more paths for same object), then we default
            // to using the method ...
            (_, Some(meth)) if !self.multiple_builders_exist => {
                Some(meth.to_string().to_snek_case())
            }
            // If there's a method, then we go for numbered functions ...
            (_, Some(meth)) => {
                let mut name = meth.to_string().to_snek_case();
                if self.idx > 0 {
                    name.push('_');
                    name.push_str(&self.idx.to_string());
                }

                Some(name)
            }
            // We don't know what to do ...
            // FIXME: Use route and method to generate a name.
            _ => None,
        }
    }

    /// Returns an iterator of all fields and parameters required for the Rust builder struct.
    ///
    /// **NOTE:** The names yielded by this iterator are unique for a builder.
    /// If there's a collision between a path-specific parameter and an operation-specific
    /// parameter, then the latter overrides the former. If there's a collision between a field
    /// and a parameter, then the latter overrides the former.
    pub(super) fn struct_fields_iter(&self) -> impl Iterator<Item = StructField<'a>> + 'a {
        let body_required = self.body_required;
        let field_iter = self.fields.iter().map(move |field| StructField {
            name: field.name.as_str(),
            ty: field.ty_path.as_str(),
            // We "require" the object fields only if the object itself is required.
            prop: if body_required && field.is_required {
                Property::RequiredField
            } else {
                Property::OptionalField
            },
            desc: field.description.as_deref(),
            strict_child_fields: &*field.child_req_fields,
            param_loc: None,
            overridden: false,
            needs_any: field.needs_any,
            needs_file: field.ty_path == FILE_MARKER,
            delimiting: &[],
        });

        let param_iter = self
            .global_params
            .iter()
            .chain(self.local_params.iter())
            .scan(HashSet::new(), |set, param| {
                // Local parameters override global parameters.
                if set.contains(&param.name) {
                    // Workaround because `scan` stops when it encounters
                    // `None`, but we want filtering.
                    Some(None)
                } else {
                    set.insert(&param.name);
                    Some(Some(StructField {
                        name: param.name.as_str(),
                        ty: param.ty_path.as_str(),
                        prop: if param.required {
                            Property::RequiredParam
                        } else {
                            Property::OptionalParam
                        },
                        desc: param.description.as_deref(),
                        strict_child_fields: &[] as &[_],
                        param_loc: Some(param.presence),
                        overridden: false,
                        needs_any: false,
                        needs_file: param.ty_path == FILE_MARKER,
                        delimiting: &param.delimiting,
                    }))
                }
            })
            .filter_map(|p| p);

        let mut fields = vec![];
        // Check parameter-field collisions.
        for field in param_iter.chain(field_iter) {
            if let Some(v) = fields
                .iter_mut()
                .find(|f: &&mut StructField<'_>| f.name == field.name)
            {
                if v.ty == field.ty {
                    v.overridden = true;
                }

                // We don't know what we should do when we encounter
                // parameter-field collision and they have different types.
                continue;
            }

            fields.push(field);
        }

        fields.into_iter()
    }

    /// Write this builder's name into the given formatter.
    pub(super) fn write_name<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        f.write_str(&self.object)?;
        if let Some(method) = self.method {
            write!(f, "{}", method)?;
        }

        f.write_str("Builder")?;
        if self.idx > 0 {
            f.write_str(&self.idx.to_string())?;
        }

        Ok(())
    }

    /// Writes generic parameters, if needed.
    ///
    /// Also takes an enum to specify whether the one/all/none of the parameters
    /// should make use of actual types.
    pub(super) fn write_generics_if_necessary<F>(
        &self,
        f: &mut F,
        any_value: Option<&str>,
        params: TypeParameters<'_>,
    ) -> Result<usize, fmt::Error>
    where
        F: Write,
    {
        let mut num_generics = 0;
        // Inspect fields and parameters and write generics.
        self.struct_fields_iter()
            .filter(|f| f.prop.is_required())
            .enumerate()
            .try_for_each(|(i, field)| {
                num_generics += 1;
                if i == 0 {
                    f.write_str("<")?;
                } else {
                    f.write_str(", ")?;
                }

                match params {
                    // If the name matches, then change that unit type to `{Name}Exists`
                    TypeParameters::ChangeOne(n) if field.name == n => {
                        f.write_str(self.helper_module_prefix)?;
                        f.write_str("generics::")?;
                        f.write_str(&field.name.to_camel_case())?;
                        return f.write_str("Exists");
                    }
                    // All names should be changed to `{Name}Exists`
                    TypeParameters::ChangeAll => {
                        f.write_str(self.helper_module_prefix)?;
                        f.write_str("generics::")?;
                        f.write_str(&field.name.to_camel_case())?;
                        return f.write_str("Exists");
                    }
                    // All names should be reset to `Missing{Name}`
                    TypeParameters::ReplaceAll => {
                        f.write_str(self.helper_module_prefix)?;
                        f.write_str("generics::")?;
                        f.write_str("Missing")?;
                    }
                    _ => (),
                }

                f.write_str(&field.name.to_camel_case())
            })?;

        if self.needs_any {
            if num_generics > 0 {
                f.write_str(", ")?;
            } else {
                f.write_str("<")?;
            }

            f.write_str(any_value.unwrap_or(ANY_GENERIC_PARAMETER))?;
            num_generics += 1;
        }

        if num_generics > 0 {
            f.write_str(">")?;
        }

        Ok(num_generics)
    }

    /// Returns whether this builder will have at least one field.
    pub(super) fn has_atleast_one_field(&self) -> bool {
        self.struct_fields_iter()
            .any(|f| f.prop.is_parameter() || f.prop.is_required())
    }

    /// Returns whether a separate container is needed for the builder struct.
    pub(super) fn needs_container(&self) -> bool {
        // This is perhaps one of those important blocks, because this
        // decides whether to mark builder structs as `repr(transparent)`
        // (for unsafely transmuting). It's UB to transmute `repr(Rust)`
        // structs, so we put stuff into a container and transmute
        // whenever a builder:
        //
        // - Has at least one operation parameter that's required (or)
        // - Has a body with at least one field that's required and the
        // operation has at least one parameter.
        //
        // Because, we need `mem::transmute` only when we use phantom fields
        // and we use phantom fields only when there's a "required" constraint.
        // And, we don't need a container if there's just a body (i.e., no params),
        // because we can transmute the builder directly.

        self.local_params
            .iter()
            .chain(self.global_params.iter())
            .any(|p| p.required)
            || (self.body_required
                && self.fields.iter().any(|f| f.is_required)
                && self.local_params.len() + self.global_params.len() > 0)
    }

    /// Write this builder's container name into the given formatter.
    pub(super) fn write_container_name<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        self.write_name(f)?;
        f.write_str("Container")
    }

    /// Given the helper module prefix, type and delimiters for that type,
    /// wraps the type (if needed) and writes the old or new type to the given formatter.
    pub(super) fn write_wrapped_ty<F>(
        module_prefix: &str,
        ty: &str,
        delims: &[CollectionFormat],
        f: &mut F,
    ) -> fmt::Result
    where
        F: fmt::Write,
    {
        if !ty.contains("Vec") {
            return f.write_str(ty);
        }

        // In parameters, we're limited to basic types and arrays,
        // so we can assume that whatever `<>` we encounter, they're
        // all for `Vec`.
        let delim_ty = String::from(module_prefix) + "util::Delimited";
        let mut ty = ty.replace("Vec", &delim_ty);
        let mut new_ty = String::new();
        // From the reverse, because we replace from inside out.
        let mut delim_idx = delims.len();
        while let Some(idx) = ty.find('>') {
            delim_idx -= 1;
            new_ty.push_str(&ty[..idx]);
            new_ty.push_str(", ");
            write!(
                &mut new_ty,
                "{}util::{:?}",
                module_prefix, delims[delim_idx]
            )?;
            new_ty.push('>');
            if idx == ty.len() - 1 {
                break;
            }

            ty = ty[idx + 1..].into();
        }

        f.write_str(&new_ty)
    }

    /// Writes the body field into the formatter if required.
    fn write_body_field_if_required<F>(&self, f: &mut F) -> fmt::Result
    where
        F: Write,
    {
        if self.body_required {
            // We address with 'self::' because it's possible for body type
            // to collide with type parameters (if any).
            f.write_str("\n    body: self::")?;
            f.write_str(&self.object)?;
            if self.needs_any {
                ApiObject::write_any_generic(f)?;
            }

            f.write_str(",")?;
        }

        Ok(())
    }

    /// Writes the parameter into the formatter if required.
    fn write_parameter_if_required<F>(
        &self,
        prop: Property,
        name: &str,
        ty: &str,
        delims: &[CollectionFormat],
        f: &mut F,
    ) -> fmt::Result
    where
        F: Write,
    {
        if !prop.is_parameter() {
            return Ok(());
        }

        f.write_str("\n    param_")?;
        f.write_str(&name)?;
        f.write_str(": Option<")?;
        if ty == FILE_MARKER {
            f.write_str("std::path::PathBuf")?;
        } else {
            Self::write_wrapped_ty(self.helper_module_prefix, ty, delims, f)?;
        }

        f.write_str(">,")
    }
}

impl<'a> Display for ApiObjectBuilder<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("/// Builder ")?;
        if let (Some(name), Some(m)) = (self.constructor_fn_name(), self.method) {
            f.write_str("created by [`")?;
            f.write_str(&self.object)?;
            f.write_str("::")?;
            f.write_str(&name)?;
            f.write_str("`](./struct.")?;
            f.write_str(&self.object)?;
            f.write_str(".html#method.")?;
            f.write_str(&name)?;
            f.write_str(") method for a `")?;
            f.write_str(&m.to_string().to_uppercase())?;
            f.write_str("` operation associated with `")?;
            f.write_str(&self.object)?;
            f.write_str("`.\n")?;
        } else {
            f.write_str("for [`")?;
            f.write_str(&self.object)?;
            f.write_str("`](./struct.")?;
            f.write_str(&self.object)?;
            f.write_str(".html) object.\n")?;
        }

        // If the builder "needs" parameters/fields, then we go for a separate
        // container which holds both the body (if any) and the parameters,
        // so that we can make the actual builder `#[repr(transparent)]`
        // for safe transmuting.
        let needs_container = self.needs_container();
        if needs_container {
            f.write_str("#[repr(transparent)]\n")?;
        }

        f.write_str("#[derive(Debug, Clone)]\npub struct ")?;
        self.write_name(f)?;
        self.write_generics_if_necessary(f, None, TypeParameters::Generic)?;

        // If structs don't have any fields, then we go for unit structs.
        let has_fields = self.has_atleast_one_field();

        if has_fields || self.body_required || needs_container {
            f.write_str(" {")?;
        }

        let mut container = String::new();
        if needs_container {
            container.push_str("#[derive(Debug, Default, Clone)]\nstruct ");
            self.write_container_name(&mut container)?;
            if self.needs_any {
                ApiObject::write_any_generic(&mut container)?;
            }

            container.push_str(" {");
            self.write_body_field_if_required(&mut container)?;

            f.write_str("\n    inner: ")?;
            self.write_container_name(f)?;
            if self.needs_any {
                ApiObject::write_any_generic(f)?;
            }

            f.write_str(",")?;
        } else {
            self.write_body_field_if_required(f)?;
        }

        // Write struct fields and the associated markers if needed.
        self.struct_fields_iter()
            .try_for_each::<_, fmt::Result>(|field| {
                let (cc, sk) = (field.name.to_camel_case(), field.name.to_snek_case());
                if needs_container {
                    self.write_parameter_if_required(
                        field.prop,
                        &sk,
                        field.ty,
                        &field.delimiting,
                        &mut container,
                    )?;
                } else {
                    self.write_parameter_if_required(
                        field.prop,
                        &sk,
                        field.ty,
                        &field.delimiting,
                        f,
                    )?;
                }

                if field.prop.is_required() {
                    f.write_str("\n    ")?;
                    if field.prop.is_parameter() {
                        f.write_str("_param")?;
                    }

                    f.write_str("_")?;
                    f.write_str(&sk)?;
                    f.write_str(": ")?;
                    f.write_str("core::marker::PhantomData<")?;
                    f.write_str(&cc)?;
                    f.write_str(">,")?;
                }

                Ok(())
            })?;

        if has_fields || self.body_required {
            f.write_str("\n}\n")?;
        } else {
            f.write_str(";\n")?;
        }

        if needs_container {
            f.write_str("\n")?;
            f.write_str(&container)?;
            f.write_str("\n}\n")?;
        }

        Ok(())
    }
}

impl Display for ApiObject {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        ApiObject::write_docs(self.description.as_ref(), f, 0)?;
        if self.inner.is_enum() {
            return self.write_enum(f);
        }

        f.write_str("#[derive(Debug, Default, Clone, Serialize, Deserialize)]\npub struct ")?;
        f.write_str(&self.name)?;
        if !self.inner.is_enum() && self.fields().iter().any(|f| f.needs_any) {
            ApiObject::write_any_generic(f)?;
        }

        f.write_str(" {")?;

        self.fields()
            .iter()
            .try_for_each::<_, fmt::Result>(|field| {
                let mut new_name = field.name.to_snek_case();
                // Check if the field matches a Rust keyword and add '_' suffix.
                if RUST_KEYWORDS.iter().any(|&k| k == new_name) {
                    new_name.push('_');
                }

                ApiObject::write_docs(field.description.as_ref(), f, 1)?;
                if field.description.is_none() {
                    f.write_str("\n")?;
                }

                f.write_str("    ")?;
                if field.name == EXTRA_PROPS_FIELD {
                    f.write_str("#[serde(flatten)]\n    ")?;
                } else if new_name != field.name.as_str() {
                    f.write_str("#[serde(rename = \"")?;
                    f.write_str(&field.name)?;
                    f.write_str("\")]\n    ")?;
                }

                f.write_str("pub ")?;
                f.write_str(&new_name)?;
                f.write_str(": ")?;
                if !field.is_required {
                    f.write_str("Option<")?;
                }

                if field.boxed {
                    f.write_str("Box<")?;
                }

                if field.needs_any {
                    Self::write_field_with_any(&field.ty_path, f)?;
                } else {
                    f.write_str(&field.ty_path)?;
                }

                if field.boxed {
                    f.write_str(">")?;
                }

                if !field.is_required {
                    f.write_str(">")?;
                }

                f.write_str(",")?;
                Ok(())
            })?;

        if !self.fields().is_empty() {
            f.write_str("\n")?;
        }

        f.write_str("}\n")
    }
}

impl ApiObject {
    /// Writes an enum declaration along with serde impl if needed.
    fn write_enum<F>(&self, f: &mut F) -> fmt::Result
    where
        F: fmt::Write,
    {
        let is_string = self.inner.is_string_enum();
        f.write_str("#[derive(Debug, Clone")?;
        if is_string {
            f.write_str(", Serialize, Deserialize")?;
        }

        f.write_str(")]\n#[allow(non_camel_case_types)]\npub enum ")?;
        f.write_str(&self.name)?;
        f.write_str(" {")?;

        self.variants().iter().try_for_each(|var| {
            if is_string {
                f.write_str("\n    #[serde(rename = ")?;
                if let serde_json::Value::String(s) = &var.value {
                    write!(f, "{:?}", s)?;
                } else {
                    write!(f, "{:?}", var.value.to_string())?;
                }

                f.write_str(")]")?;
            }

            f.write_str("\n    ")?;
            f.write_str(&var.name)?;
            f.write_str(",")
        })?;

        f.write_str("\n}\n")?;

        // FIXME: Currently, we're implementing the first value as enum default.
        // If "default" field exists, then we should use that instead.
        if let Some(var) = self.variants().get(0) {
            writeln!(
                f,
                "impl Default for {name} {{
    fn default() -> Self {{
        {name}::{first_var}
    }}
}}",
                name = &self.name,
                first_var = &var.name
            )?;
        }

        if !is_string {
            EnumSerdeImpl::from(self).write_to(f)?;
        }

        Ok(())
    }
}

/// Abstraction for implementing Serialize/Deserialize mechanism
/// for non-string enums.
struct EnumSerdeImpl<'a> {
    obj: &'a ApiObject,
    true_: Option<&'a ObjectVariant>,
    false_: Option<&'a ObjectVariant>,
    i64_: Vec<&'a ObjectVariant>,
    u64_: Vec<&'a ObjectVariant>,
    f64_: Vec<&'a ObjectVariant>,
    str_: Vec<&'a ObjectVariant>,
}

impl<'a> EnumSerdeImpl<'a> {
    fn from(o: &'a ApiObject) -> Self {
        use serde_json::Value;
        let mut writer = EnumSerdeImpl {
            obj: o,
            true_: None,
            false_: None,
            i64_: vec![],
            u64_: vec![],
            f64_: vec![],
            str_: vec![],
        };

        o.variants().iter().for_each(|var| match var.value {
            Value::Number(ref n) => {
                if n.is_u64() {
                    writer.u64_.push(var);
                } else if n.is_i64() {
                    writer.i64_.push(var);
                } else if n.is_f64() {
                    writer.f64_.push(var);
                }
            }
            Value::Bool(ref b) if *b => writer.true_ = Some(var),
            Value::Bool(_) => writer.false_ = Some(var),
            Value::String(_) => writer.str_.push(var),
            _ => (),
        });

        writer
    }

    /// Writes the serde impl to the given formatter.
    fn write_to<F>(self, f: &mut F) -> fmt::Result
    where
        F: fmt::Write,
    {
        f.write_str("impl serde::Serialize for ")?;
        f.write_str(&self.obj.name)?;
        f.write_str(
            " {
    fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
        match self {",
        )?;

        // We've already checked that we have non-zero variants when we emitted
        // the enum, so we're okay here.
        self.obj.variants().iter().try_for_each(|var| {
            write!(
                f,
                "
            {}::{} => ({}).serialize(ser),",
                self.obj.name, var.name, var.value
            )
        })?;
        f.write_str("\n        }\n    }\n}")?;

        write!(
            f,
            "
impl<'de> serde::Deserialize<'de> for {name} {{
    fn deserialize<D: serde::Deserializer<'de>>(deser: D) -> Result<Self, D::Error> {{
        use serde::de::{{Error, Unexpected, Visitor}};
        struct VariantVisitor;
        const EXPECT_MSG: &str = \"valid value for enum {name}\";

        impl<'de> Visitor<'de> for VariantVisitor {{
            type Value = {name};

            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {{
                f.write_str(EXPECT_MSG)
            }}",
            name = self.obj.name,
        )?;

        self.write_visit_methods(f)?;
        f.write_str(
            "\n        }

        deser.deserialize_any(VariantVisitor)\n    }\n}\n",
        )
    }

    /// Writes the necessary visitor methods for deserializing the enum.
    fn write_visit_methods<F>(&self, f: &mut F) -> fmt::Result
    where
        F: fmt::Write,
    {
        let mut bool_vis = vec![];
        if let Some(var) = self.true_ {
            bool_vis.push(var);
        }
        if let Some(var) = self.false_ {
            bool_vis.push(var);
        }

        let visitors = &[
            ("bool", None, &bool_vis, "Bool", bool_vis.len() == 1),
            ("i64", None, &self.i64_, "Signed", true),
            ("u64", None, &self.u64_, "Unsigned", true),
            ("f64", None, &self.f64_, "Float", true),
            ("str", Some("&str"), &self.str_, "Str", true),
        ];

        for (vis_name, vis_ty, vars, ident, needs_error) in visitors {
            write!(
                f,
                "

            fn visit_{name}<E: Error>(self, v: {ty}) -> Result<Self::Value, E> {{",
                name = vis_name,
                ty = vis_ty.unwrap_or(vis_name)
            )?;

            for var in *vars {
                write!(
                    f,
                    "
                if v == {} {{
                    return Ok({}::{});
                }}",
                    var.value, self.obj.name, var.name
                )?;
            }

            // For bool, this is needed for "unreachable" code check.
            if *needs_error {
                write!(
                    f,
                    "
                Err(E::invalid_value(Unexpected::{ident}(v), &EXPECT_MSG))
            }}",
                    ident = ident,
                )?;
            }
        }

        Ok(())
    }
}

impl Default for ObjectContainer {
    fn default() -> Self {
        ObjectContainer::Struct { fields: vec![] }
    }
}

'''
'''--- src/v2/codegen/state.rs ---
use super::{
    object::ApiObject,
    template::{self, TEMPLATE},
    CrateMeta, EmitMode,
};
use crate::{
    error::PaperClipError,
    v2::models::{Coders, SpecFormat},
};
use anyhow::Error;
use heck::CamelCase;
#[cfg(feature = "cli")]
use heck::SnekCase;
use itertools::Itertools;
use url::Url;

#[cfg(feature = "cli")]
use std::fs;
use std::{
    cell::RefCell,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    fmt::Write as _,
    fs::OpenOptions,
    hash::{Hash, Hasher},
    io::Write,
    path::{Path, PathBuf},
    rc::Rc,
};

/// Holds the state for your schema emitter.
#[derive(Debug)]
pub struct EmitterState {
    /// Working directory - the path in which the necessary modules are generated.
    pub working_dir: PathBuf,
    /// Namespace separation string.
    pub ns_sep: &'static str,
    /// Module prefix for using in generated code.
    pub mod_prefix: &'static str,

    /* MARK: Private fields. */
    /// Base URL for the API.
    pub(super) base_url: RefCell<Url>,
    /// Fallback encoding when we don't have a choice (obtained from `Api.spec_format`).
    default_encoding: RefCell<SpecFormat>,
    /// If crate metadata is specified, then `lib.rs` and `Cargo.toml` are generated
    /// along with the modules. This is gated behind `"cli"` feature.
    #[cfg(feature = "cli")]
    crate_meta: Rc<RefCell<Option<CrateMeta>>>,

    /* MARK: Internal fields that should be reset for each session. */
    /// Maps parent mod to immediate children. Used for declaring modules.
    pub(super) mod_children: RefCell<HashMap<PathBuf, HashSet<ChildModule>>>,
    /// Holds generated struct definitions for leaf modules.
    pub(super) def_mods: RefCell<BTreeMap<PathBuf, Vec<ApiObject>>>,
    /// Relative paths
    pub(super) rel_paths: RefCell<HashSet<String>>,
    /// Media ranges and the corresponding decoders we've registered.
    media_coders: RefCell<Vec<MediaCoder>>,
    /// Unit types used by builders.
    unit_types: RefCell<BTreeSet<String>>,
    /// Generated CLI YAML for clap.
    cli_yaml: RefCell<String>,
    /// Generated match arms for clap subcommands and matches.
    cli_match_arms: RefCell<String>,
}

/// Indicates a child module in codegen working directory.
#[derive(Debug, Clone, Eq)]
pub(super) struct ChildModule {
    /// Name of this child module.
    pub name: String,
    /// Whether this module is the final child.
    pub is_final: bool,
}

impl EmitterState {
    /// Sets the base URL for this session.
    ///
    /// **NOTE:** Once `Emitter::generate` is called, this gets overridden
    /// by `host` and `basePath` fields in spec (if they exist).
    pub fn set_url(&self, url: &str) -> Result<(), Error> {
        let u = Url::parse(url).map_err(|e| PaperClipError::InvalidBasePathURL(url.into(), e))?;
        *self.base_url.borrow_mut() = u;
        Ok(())
    }

    /// Base URL for this API.
    ///
    /// **NOTE:** Once `Emitter::generate` is called, this gets overridden
    /// by `host` and `basePath` fields in spec (if they exist).
    pub fn base_url(&self) -> String {
        self.base_url.borrow().to_string()
    }

    /// Resets internal state-related information used by the emitter.
    pub(crate) fn reset_internal_fields(&self) {
        *self.mod_children.borrow_mut() = Default::default();
        *self.def_mods.borrow_mut() = Default::default();
        *self.rel_paths.borrow_mut() = Default::default();
        *self.unit_types.borrow_mut() = Default::default();
        *self.cli_yaml.borrow_mut() = Default::default();
        *self.cli_match_arms.borrow_mut() = Default::default();
        *self.media_coders.borrow_mut() = Default::default();
    }

    /// Sets the media type information for encoder/decoders.
    pub(crate) fn set_media_info(&self, spec_format: SpecFormat, coders: &Coders) {
        *self.default_encoding.borrow_mut() = spec_format;

        *self.media_coders.borrow_mut() = coders
            .iter()
            .map(|(r, c)| (r.0.as_ref(), c))
            .map(|(r, c)| MediaCoder {
                range: r.into(),
                error_variant: r.replace('*', "wildcard").to_camel_case(),
                error_ty_path: c.error_path.clone(),
                decoder: c.decoder_path.clone(),
            })
            .collect();
    }

    /// Once the emitter has generated the struct definitions,
    /// we can call this method to generate the module declarations
    /// from root.
    pub(crate) fn declare_modules(&self) -> Result<(), Error> {
        info!("Writing module declarations.");
        let is_app = self.is_cli()?;
        let mods = self.mod_children.borrow();
        for (rel_parent, children) in &*mods {
            let mut mod_path = self.working_dir.join(&rel_parent);
            let mut contents = String::new();

            if rel_parent.parent().is_none() && self.needs_root_module() {
                mod_path = self.root_module_path();
                contents.push_str(
                    "
#[macro_use]
extern crate serde;
",
                );

                if is_app {
                    contents.push_str(
                        "
#[macro_use]
extern crate clap;

pub mod cli {
    include!(\"./cli.rs\");
}
",
                    )
                }
            } else {
                mod_path.push("mod.rs");
            }

            for child in children.iter().sorted_by(|a, b| a.name.cmp(&b.name)) {
                writeln!(
                    contents,
                    "
pub mod {name} {{
    include!(\"./{path}\");
}}",
                    name = child.name,
                    path = if child.is_final {
                        child.name.clone() + ".rs"
                    } else {
                        child.name.clone() + "/mod.rs"
                    }
                )?;
            }

            self.write_contents(&contents, &mod_path)?;
        }

        Ok(())
    }

    /// Once the emitter has generated the struct definitions,
    /// we can call this method to write the definitions to leaf modules.
    pub(crate) fn write_definitions(&self) -> Result<(), Error> {
        let def_mods = self.def_mods.borrow();
        info!("Writing definitions.");
        for (i, (mod_path, object)) in def_mods
            .iter()
            .flat_map(move |(p, l)| l.iter().map(move |o| (p, o)).enumerate())
        {
            let contents = object.to_string();
            if i == 0 {
                self.write_contents(&contents, mod_path)?;
            } else {
                self.append_contents(&contents, mod_path)?;
            }
        }

        Ok(())
    }

    /// Once the emitter has collected requirements for paths,
    /// we can use this method to add builder structs and their impls.
    pub(crate) fn add_builders(&self) -> Result<(), Error> {
        let module_prefix = self.normalized_mod_prefix();
        info!("Adding builders to definitions.");
        let mut unit_types = self.unit_types.borrow_mut();
        let def_mods = self.def_mods.borrow();
        let mut cli_yaml = self.cli_yaml.borrow_mut();
        let mut match_arms = self.cli_match_arms.borrow_mut();
        let is_cli = self.is_cli()?;

        for (mod_path, object) in def_mods
            .iter()
            .flat_map(move |(p, l)| l.iter().map(move |o| (p, o)))
        {
            let mut builder_content = String::new();
            let repr = object.impl_repr(&module_prefix);
            for builder in &*repr.builders {
                builder
                    .struct_fields_iter()
                    .filter(|f| f.prop.is_required())
                    .for_each(|f| {
                        unit_types.insert(f.name.to_camel_case());
                    });

                builder_content.push('\n');
                let _ = write!(builder_content, "{}", builder);
                builder_content.push('\n');
                let inner_repr = builder.impl_repr();
                let _ = write!(builder_content, "{}", inner_repr);
                if is_cli {
                    inner_repr.write_arg_parsing(&mut builder_content)?;
                }
            }

            if is_cli {
                repr.write_clap_yaml(&mut *cli_yaml)?;
                repr.write_arg_match_arms(&mut *match_arms)?;
            }

            let mut impl_content = String::from("\n");
            write!(impl_content, "{}", repr)?;

            self.append_contents(&impl_content, mod_path)?;
            self.append_contents(&builder_content, mod_path)?;
        }

        Ok(())
    }

    /// Once the builders have been added, we can add unit types
    /// and other dependencies.
    pub(crate) fn add_deps(&self) -> Result<(), Error> {
        let mut module = self.root_module_path();
        let types = self.unit_types.borrow();
        let mut content = String::new();
        content.push_str(
            "
pub mod generics {
    include!(\"./generics.rs\");
}

pub mod util {
    include!(\"./util.rs\");
}
",
        );
        self.append_contents(&content, &module)?;

        content.clear();
        module.set_file_name("generics.rs");

        for ty in &*types {
            content.push_str("\npub struct Missing");
            content.push_str(ty);
            content.push_str(";");
            content.push_str("\npub struct ");
            content.push_str(ty);
            content.push_str("Exists;");
        }

        content.push_str("\n");
        self.write_contents(&content, &module)?;

        module.set_file_name("util.rs");
        let contents = template::render(TEMPLATE::UTIL_MOD, &EmptyContext {})?;
        self.write_contents(&contents, &module)?;

        self.add_cli_deps_if_needed()?;
        self.create_manifest()
    }

    /// Once the builders have been added, we can add API client dependencies.
    pub(crate) fn add_client_deps(&self) -> Result<(), Error> {
        let module = self.root_module_path();
        let contents = template::render(
            TEMPLATE::CLIENT_MOD,
            &ClientModContext {
                mod_prefix: &self.normalized_mod_prefix(),
                media_coders: &*self.media_coders.borrow(),
                base_url: self.base_url.borrow().as_str(),
            },
        )?;

        self.append_contents(&contents, &module)
    }

    /// Writes the given contents to a file at the given path (truncating the file if it exists).
    fn write_contents(&self, contents: &str, path: &Path) -> Result<(), Error> {
        let mut fd = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(path)?;
        fd.write_all(contents.as_bytes())?;
        Ok(())
    }

    /// Appends the given contents to an existing file at the given path.
    ///
    /// **NOTE:** This doesn't create a file if it is non-existent.
    fn append_contents(&self, contents: &str, path: &Path) -> Result<(), Error> {
        let mut fd = OpenOptions::new().append(true).open(path)?;
        fd.write_all(contents.as_bytes())?;
        Ok(())
    }

    /// Adds CLI-related deps for the given object (if needed).
    fn add_cli_deps_if_needed(&self) -> Result<(), Error> {
        let root = self.root_module_path();
        if !self.is_cli()? {
            return Ok(());
        }

        let cm = self.infer_crate_meta()?;
        if let Some(meta) = cm.borrow().as_ref() {
            // Clap YAML
            let clap_yaml = root.with_file_name("app.yaml");
            let base_content = template::render(
                TEMPLATE::CLAP_YAML,
                &ClapYamlContext {
                    name: meta.name.as_ref().unwrap(),
                    version: &format!("{:?}", meta.version.as_ref().unwrap()),
                },
            )?;

            let cli_mod = root.with_file_name("cli.rs");
            self.write_contents(&base_content, &clap_yaml)?;
            self.append_contents(&*self.cli_yaml.borrow(), &clap_yaml)?;

            // CLI module
            let cli_content = template::render(
                TEMPLATE::CLI_UTIL,
                &CliUtilContext {
                    match_arms: &*self.cli_match_arms.borrow(),
                    media_coders: &*self.media_coders.borrow(),
                },
            )?;

            self.write_contents(&cli_content, &cli_mod)?;
        }

        // `main.rs`
        let contents = template::render(TEMPLATE::CLI_MAIN, &EmptyContext {})?;
        self.append_contents(&contents, &root)
    }

    /// Returns if this session is for generating CLI.
    fn is_cli(&self) -> Result<bool, Error> {
        Ok(self
            .infer_crate_meta()?
            .borrow()
            .as_ref()
            .map(|m| m.mode == EmitMode::App)
            .unwrap_or(false))
    }

    fn no_root(&self) -> Result<bool, Error> {
        Ok(self
            .infer_crate_meta()?
            .borrow()
            .as_ref()
            .map(|m| m.no_root)
            .unwrap_or(true))
    }

    /// Normalized module prefix used by codegen.
    fn normalized_mod_prefix(&self) -> String {
        format!("{}::", self.mod_prefix.trim_matches(':'))
    }
}

/* Feature-specific impls */

#[cfg(feature = "cli")]
impl EmitterState {
    /// Sets the crate metadata for this session.
    pub fn set_meta(&self, meta: CrateMeta) {
        *self.crate_meta.borrow_mut() = Some(meta)
    }

    pub(super) fn get_meta(&self) -> Rc<RefCell<Option<CrateMeta>>> {
        self.crate_meta.clone()
    }

    /// Checks whether this session is for emitting a crate or CLI.
    fn needs_root_module(&self) -> bool {
        self.crate_meta
            .borrow()
            .as_ref()
            .map(|m| m.mode != EmitMode::Module)
            .unwrap_or(false)
    }

    /// Returns the path to the root module.
    fn root_module_path(&self) -> PathBuf {
        let cm = self.crate_meta.borrow();
        if let Some(meta) = cm.as_ref() {
            match meta.mode {
                EmitMode::Crate => return self.working_dir.join("lib.rs"),
                EmitMode::App => return self.working_dir.join("main.rs"),
                EmitMode::Module => (),
            }
        }

        self.working_dir.join("mod.rs")
    }

    /// Creates a Cargo.toml manifest in the working directory (if it's a crate).
    fn create_manifest(&self) -> Result<(), Error> {
        let mut man_path = self.root_module_path();
        let is_cli = self.is_cli()?;
        let no_root = self.no_root()?;
        man_path.set_file_name("Cargo.toml");

        let cm = self.infer_crate_meta()?;
        let m = cm.borrow();
        let meta = match m.as_ref() {
            Some(c) => c,
            None => return Ok(()),
        };

        if self.needs_root_module() {
            let contents = template::render(
                TEMPLATE::CARGO_MANIFEST,
                &ManifestContext {
                    name: &format!("{:?}", meta.name.as_ref().unwrap()),
                    version: &format!("{:?}", meta.version.as_ref().unwrap()),
                    authors: &format!("{:?}", meta.authors.as_ref().unwrap()),
                    is_cli,
                    no_root,
                },
            )?;

            self.write_contents(&contents, &man_path)?;
        }

        Ok(())
    }

    /// Validates crate metadata, sets the unset fields and returns a reference.
    fn infer_crate_meta(&self) -> Result<Rc<RefCell<Option<CrateMeta>>>, Error> {
        let mut cm = self.crate_meta.borrow_mut();
        if let Some(meta) = &mut *cm {
            if meta.name.is_none() {
                meta.name = Some(
                    fs::canonicalize(&self.working_dir)?
                        .file_name()
                        .ok_or(PaperClipError::InvalidCodegenDirectory)?
                        .to_string_lossy()
                        .into_owned()
                        .to_snek_case(),
                );
            }

            if meta.version.is_none() {
                meta.version = Some("0.1.0".into());
            }

            if meta.authors.is_none() {
                let (mut name, email) = super::author::discover()?;
                if let Some(e) = email {
                    name.push_str(" <");
                    name.push_str(&e);
                    name.push_str(">");
                }

                meta.authors = Some(vec![name]);
            }
        }

        Ok(self.crate_meta.clone())
    }
}

#[cfg(not(feature = "cli"))]
impl EmitterState {
    /// This is a no-op.
    pub fn set_meta(&self, _: CrateMeta) {}

    /// This is a no-op
    pub fn get_meta(&self) -> Rc<RefCell<Option<CrateMeta>>> {
        Rc::new(RefCell::new(None))
    }

    /// Always returns `Ok(None)`
    fn infer_crate_meta(&self) -> Result<Rc<RefCell<Option<CrateMeta>>>, Error> {
        Ok(Rc::new(RefCell::new(None)))
    }

    /// Always returns the path to `mod.rs` in root.
    fn root_module_path(&self) -> PathBuf {
        self.working_dir.join("mod.rs")
    }

    /// This always returns `false`.
    fn needs_root_module(&self) -> bool {
        false
    }

    /// Always returns `Ok(())`
    fn create_manifest(&self) -> Result<(), Error> {
        Ok(())
    }
}

/* Other impls */

impl Clone for EmitterState {
    fn clone(&self) -> EmitterState {
        EmitterState {
            working_dir: self.working_dir.clone(),
            mod_prefix: self.mod_prefix,
            ns_sep: self.ns_sep,
            #[cfg(feature = "cli")]
            crate_meta: self.crate_meta.clone(),
            base_url: self.base_url.clone(),
            default_encoding: self.default_encoding.clone(),
            // Get rid of all state-specific fields.
            ..Default::default()
        }
    }
}

impl Default for EmitterState {
    fn default() -> EmitterState {
        EmitterState {
            working_dir: PathBuf::from("."),
            mod_prefix: "crate::",
            ns_sep: ".",
            #[cfg(feature = "cli")]
            crate_meta: Rc::new(RefCell::new(None)),
            base_url: RefCell::new("https://example.com".parse().expect("invalid URL?")),
            def_mods: RefCell::new(BTreeMap::new()),
            rel_paths: RefCell::new(HashSet::new()),
            mod_children: RefCell::new(HashMap::new()),
            unit_types: RefCell::new(BTreeSet::new()),
            cli_yaml: RefCell::new(String::new()),
            cli_match_arms: RefCell::new(String::new()),
            media_coders: RefCell::new(vec![]),
            default_encoding: RefCell::new(SpecFormat::Json),
        }
    }
}

impl Hash for ChildModule {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
    }
}

impl PartialEq for ChildModule {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

/* Templating contexts */

#[cfg(feature = "cli")]
#[derive(serde::Serialize)]
struct ManifestContext<'a> {
    name: &'a str,
    version: &'a str,
    authors: &'a str,
    is_cli: bool,
    no_root: bool,
}

#[derive(serde::Serialize)]
struct CliUtilContext<'a> {
    match_arms: &'a str,
    media_coders: &'a [MediaCoder],
}

#[derive(serde::Serialize)]
struct ClientModContext<'a> {
    base_url: &'a str,
    mod_prefix: &'a str,
    media_coders: &'a [MediaCoder],
}

#[derive(Debug, serde::Serialize)]
struct MediaCoder {
    range: String,
    decoder: String,
    error_variant: String,
    error_ty_path: String,
}

#[derive(serde::Serialize)]
struct ClapYamlContext<'a> {
    name: &'a str,
    version: &'a str,
}

#[derive(serde::Serialize)]
struct EmptyContext {}

'''
'''--- src/v2/mod.rs ---
//! Utilities related to the [OpenAPI v2 specification](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md).
//!
//! # Detailed example
//!
//! To parse your v2 spec, you begin with transforming the schema into a
//! Rust struct. If your schema doesn't have custom properties, then you
//! can use the `DefaultSchema`.
//!
//! ```rust,no_run
//! use paperclip::v2::{self, ResolvableApi, DefaultSchema, models::Version};
//!
//! use std::fs::File;
//!
//! let mut fd = File::open("my_spec.yaml").unwrap(); // yaml or json
//! let api: ResolvableApi<DefaultSchema> = v2::from_reader(&mut fd).unwrap();
//! assert_eq!(api.swagger, Version::V2);
//! ```
//!
//! On the other hand, if your schema does have custom properties which you'd
//! like to parse, then use the `#[api_v2_schema]` proc macro.
//!
//! For example, let's take the [Kubernetes API spec][kube-spec]
//! which uses some custom thingmabobs. Let's say we're only interested in the
//! `x-kubernetes-patch-strategy` field for now.
//!
//! [kube-spec]: https://github.com/kubernetes/kubernetes/tree/afd928b8bc81cea385eba4c94558373df7aeae75/api/openapi-spec
//!
//! ```rust,no_run
//! #[macro_use] extern crate paperclip;
//! #[macro_use] extern crate serde_derive; // NOTE: We're using serde for decoding stuff.
//!
//! use paperclip::v2::{self, ResolvableApi};
//!
//! use std::fs::File;
//!
//! #[derive(Debug, Deserialize)]
//! #[serde(rename_all = "camelCase")]
//! enum PatchStrategy {
//!     Merge,
//!     RetainKeys,
//!     #[serde(rename = "merge,retainKeys")]
//!     MergeAndRetain,
//!     #[serde(other)]
//!     Other,
//! }
//!
//! #[api_v2_schema]
//! #[derive(Debug, Deserialize)]
//! struct K8sSchema {
//!     #[serde(rename = "x-kubernetes-patch-strategy")]
//!     patch_strategy: Option<PatchStrategy>,
//! }
//!
//! // K8sSchema now implements `Schema` trait.
//! let mut fd = File::open("k8s_spec.yaml").unwrap();
//! let api: ResolvableApi<K8sSchema> = v2::from_reader(&mut fd).unwrap();
//! ```
//!
//! Now, if `codegen` feature is enabled (it is by default), we can use the
//! emitter to emit the API into some path. But first, we need to resolve the
//! raw schema. During resolution, we:
//!
//! - walk through the nodes, find `$ref` fields and assign references to
//! the actual definitions.
//! - identify anonymous definitions in body parameters and response schemas
//! and add them to the known map of definitions.
//!
//! ```rust,no_run
//! # use paperclip::v2::{self, ResolvableApi, DefaultSchema};
//! # let api: ResolvableApi<DefaultSchema> = v2::from_reader(&mut std::io::Cursor::new(vec![])).unwrap();
//!
//! let resolved = api.resolve().unwrap();
//! ```
//!
//! ```rust,no_run
//! # use paperclip::v2::{self, ResolvableApi, DefaultSchema};
//! # let api: ResolvableApi<DefaultSchema> = v2::from_reader(&mut std::io::Cursor::new(vec![])).unwrap();
//! use paperclip::v2::{DefaultEmitter, EmitterState, Emitter};
//!
//! let mut state = EmitterState::default();
//! state.working_dir = "/path/to/my/crate".into();
//! let emitter = DefaultEmitter::from(state);
//! emitter.generate(&api).unwrap(); // generate code!
//! ```

#[cfg(feature = "codegen")]
pub mod codegen;

use crate::error::PaperClipError;
use paperclip_core::v2::models::SpecFormat;
use serde::Deserialize;

use std::io::{Read, Seek, SeekFrom};

#[cfg(feature = "codegen")]
pub use self::codegen::{DefaultEmitter, Emitter, EmitterState};
pub use paperclip_core::{
    im,
    v2::{
        models::{self, DefaultSchema, ResolvableApi},
        schema::{self, Schema},
    },
};

/// Deserialize the schema from the given reader. Currently, this only supports
/// JSON and YAML formats.
pub fn from_reader<R, S>(mut reader: R) -> Result<ResolvableApi<S>, PaperClipError>
where
    R: Read + Seek,
    for<'de> S: Deserialize<'de> + Schema,
{
    let mut buf = [0; 1];
    reader.read_exact(&mut buf)?;
    reader.seek(SeekFrom::Start(0))?;

    // FIXME: Support whitespaces
    let (mut api, fmt) = if buf[0] == b'{' {
        (
            serde_json::from_reader::<_, ResolvableApi<S>>(reader)?,
            SpecFormat::Json,
        )
    } else {
        (
            serde_yaml::from_reader::<_, ResolvableApi<S>>(reader)?,
            SpecFormat::Yaml,
        )
    };

    api.spec_format = fmt;
    Ok(api)
}

'''
'''--- tests/README.md ---
**NOTE:** `k8s-v1.16.0-alpha.0-openapi-v2.json` was obtained from [kubernetes repository](https://github.com/kubernetes/kubernetes/tree/afd928b8bc81cea385eba4c94558373df7aeae75/api/openapi-spec). It seemed like an ideal candidate for testing.

'''
'''--- tests/test_app.rs ---
#[macro_use]
extern crate serde;
#[macro_use]
extern crate serde_json;

use actix_rt::System;
use actix_service::ServiceFactory;
use actix_web::{
    dev::{MessageBody, Payload, ServiceRequest, ServiceResponse},
    App, Error, FromRequest, HttpRequest, HttpServer, Responder,
};
use futures::future::{ok as fut_ok, ready, Future, Ready};
use once_cell::sync::Lazy;
use paperclip::{
    actix::{
        api_v2_errors, api_v2_operation, delete, get, post, put, web, Apiv2Schema, Apiv2Security,
        CreatedJson, NoContent, OpenApiExt,
    },
    v2::models::{DefaultApiRaw, Info, Tag},
};
use parking_lot::Mutex;

use std::{
    collections::{BTreeMap, HashMap, HashSet},
    sync::mpsc,
    thread,
};
use uuid_dev::Uuid;

static CLIENT: Lazy<reqwest::blocking::Client> = Lazy::new(|| reqwest::blocking::Client::new());
static PORTS: Lazy<Mutex<HashSet<u16>>> = Lazy::new(|| Mutex::new(HashSet::new()));

type OptionalUuid = Option<uuid_dev::Uuid>;

#[derive(Deserialize, Serialize, Apiv2Schema)]
#[serde(rename_all = "lowercase")]
enum PetClass {
    Dog,
    Cat,
    #[serde(rename = "other")]
    EverythingElse,
}

#[derive(Deserialize, Serialize, Apiv2Schema)]
#[serde(rename_all = "camelCase")]
/// Pets are awesome!
struct Pet {
    /// Pick a good one.
    name: String,
    class: PetClass,
    id: Option<u64>,
    birthday: chrono_dev::NaiveDate,
    updated_on: Option<chrono_dev::NaiveDateTime>,
    #[serde(rename = "uuid")]
    uid: OptionalUuid,
}

impl Default for Pet {
    fn default() -> Self {
        Self {
            name: "".to_string(),
            class: PetClass::EverythingElse,
            birthday: chrono_dev::NaiveDate::from_ymd(2012, 3, 10),
            id: None,
            updated_on: None,
            uid: None,
        }
    }
}

impl Responder for Pet {
    type Error = Error;
    type Future = Ready<Result<actix_web::HttpResponse, Error>>;

    fn respond_to(self, _req: &HttpRequest) -> Self::Future {
        let body = serde_json::to_string(&self).unwrap();

        // Create response and set content type
        ready(Ok(actix_web::HttpResponse::Ok()
            .content_type("application/json")
            .body(body)))
    }
}

#[test]
fn test_simple_app() {
    #[api_v2_operation]
    fn echo_pet(body: web::Json<Pet>) -> impl Future<Output = Result<web::Json<Pet>, Error>> {
        fut_ok(body)
    }

    #[api_v2_operation]
    async fn echo_pet_async(body: web::Json<Pet>) -> Result<web::Json<Pet>, actix_web::Error> {
        Ok(body)
    }

    async fn inner_async_func(body: web::Json<Pet>) -> Pet {
        body.into_inner()
    }

    #[api_v2_operation]
    async fn echo_pet_async_2(body: web::Json<Pet>) -> Result<web::Json<Pet>, actix_web::Error> {
        let pet = inner_async_func(body).await;
        Ok(web::Json(pet))
    }

    #[api_v2_operation]
    fn some_pet(_data: web::Data<String>) -> impl Future<Output = Result<web::Json<Pet>, Error>> {
        #[allow(unreachable_code)]
        fut_ok(unimplemented!())
    }

    #[api_v2_operation]
    async fn adopt_pet() -> Result<CreatedJson<Pet>, ()> {
        let pet: Pet = Pet::default();
        Ok(CreatedJson(pet))
    }

    #[api_v2_operation]
    async fn nothing() -> NoContent {
        NoContent
    }

    fn config(cfg: &mut web::ServiceConfig) {
        cfg.service(web::resource("/echo").route(web::post().to(echo_pet)))
            .service(web::resource("/async_echo").route(web::post().to(echo_pet_async)))
            .service(web::resource("/async_echo_2").route(web::post().to(echo_pet_async_2)))
            .service(web::resource("/adopt").route(web::post().to(adopt_pet)))
            .service(web::resource("/nothing").route(web::get().to(nothing)))
            .service(web::resource("/random").to(some_pet));
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::scope("/api").configure(config))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description":"Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/api/echo": {
                    "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                            "$ref": "#/definitions/Pet"
                            }
                        }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      }
                    },
                    "/api/async_echo": {
                      "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      }
                    },
                    "/api/async_echo_2": {
                      "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      }
                    },
                    "/api/random": {
                      "delete": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "get": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "head": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "options": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "patch": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "post": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      },
                      "put": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      }
                    },
                    "/api/adopt": {
                      "post": {
                        "responses": {
                          "201": {
                            "description": "Created",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }
                        }
                      }
                    },
                    "/api/nothing": {
                      "get": {
                        "responses": {
                          "204": {
                            "description": "No Content"
                          }
                        }
                      }
                    },
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
#[allow(dead_code)]
fn test_params() {
    #[derive(Deserialize, Apiv2Schema)]
    struct KnownResourceBadge {
        resource: String,
        name: String,
    }

    /// KnownBadge Id Doc
    #[derive(Serialize, Deserialize, Apiv2Schema)]
    struct KnownBadgeId(String);

    /// KnownBadge Id2 Doc
    #[derive(Deserialize, Apiv2Schema)]
    struct KnownBadgeId2(u64);

    /// KnownBadge Id3 Doc
    #[derive(Deserialize, Apiv2Schema)]
    struct KnownBadgeId3(
        /// Number Doc
        pub u64,
        /// String Doc
        pub String,
    );

    #[derive(Deserialize, Apiv2Schema)]
    struct BadgeParams {
        res: Option<u16>,
        colors: Vec<String>,
    }

    #[derive(Deserialize, Apiv2Schema)]
    struct BadgeBody {
        /// JSON value
        json: Option<serde_json::Value>,
        yaml: Option<serde_yaml::Value>,
    }

    #[derive(Deserialize, Apiv2Schema)]
    struct BadgeBodyPatch {
        /// JSON value
        json: Option<serde_json::Value>,
    }

    #[derive(Deserialize, Apiv2Schema)]
    struct BadgeForm {
        data: String,
    }

    #[derive(Deserialize, Apiv2Schema)]
    struct AppState {
        data: String,
    }

    async fn is_data_empty(p: &AppState) -> bool {
        p.data.is_empty()
    }

    // issue: https://github.com/wafflespeanut/paperclip/issues/216
    #[api_v2_operation]
    async fn check_data_ref_async(
        app: web::Data<AppState>,
        _req_data: Option<web::ReqData<bool>>, // this should compile and change nothing
    ) -> web::Json<bool> {
        web::Json(is_data_empty(app.get_ref()).await)
    }

    #[api_v2_operation]
    fn get_resource_2(_p: web::Path<u32>) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn get_known_badge_1(
        _p: web::Path<KnownResourceBadge>,
        _q: web::Query<BadgeParams>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn get_known_badge_2(
        _p: web::Path<(u32, String)>,
        _q: web::Query<BadgeParams>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn get_known_badge_3(
        _p: web::Path<KnownBadgeId>,
    ) -> impl Future<Output = Result<web::Json<KnownBadgeId>, ()>> {
        futures::future::ok(web::Json(KnownBadgeId("id".into())))
    }

    #[api_v2_operation]
    fn get_known_badge_4(
        _p1: web::Path<KnownBadgeId>,
        _p2: web::Path<(KnownBadgeId2, KnownBadgeId3)>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn post_badge_1(
        _p: web::Path<KnownResourceBadge>,
        _q: web::Query<BadgeParams>,
        _f: web::Form<BadgeForm>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn post_badge_2(
        _p: web::Path<(u32, String)>,
        _b: web::Json<BadgeBody>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn post_badge_3(
        _p: web::Path<u32>,
        _b: web::Json<BadgeBody>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    #[api_v2_operation]
    fn patch_badge_3(
        _p: web::Path<u32>,
        _b: web::Json<BadgeBodyPatch>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(
                    web::scope("/api")
                        .service(
                            web::resource("/v1/{resource}/v/{name}")
                                .route(web::Route::new().to(get_known_badge_1))
                                .route(web::post().to(post_badge_1)),
                        )
                        .service(
                            // Test that we can also have parameters in scopes
                            web::scope("/v2/{resource}")
                                .service(
                                    web::resource("/v/{name}")
                                        .route(web::get().to(get_known_badge_2))
                                        .route(web::post().to(post_badge_2)),
                                )
                                .service(
                                    web::resource("/v/{id}")
                                        .route(web::get().to(get_known_badge_3)),
                                )
                                .service(
                                    web::resource("/v/{id}/{id2}/{id3}/{id4}")
                                        .route(web::get().to(get_known_badge_4)),
                                )
                                .service(
                                    web::resource("/v")
                                        .route(web::post().to(post_badge_3))
                                        .route(web::patch().to(patch_badge_3)),
                                )
                                .service(
                                    web::resource("/foo").route(web::get().to(get_resource_2)),
                                ),
                        )
                        .service(
                            web::resource("/v2/check_data")
                                .route(web::get().to(check_data_ref_async)),
                        ),
                )
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions": {
                        "BadgeBody": {
                            "properties": {
                                "json": {
                                    "description": "JSON value",
                                },
                                "yaml": {
                                }
                            },
                            "type":"object"
                        },
                        "BadgeBodyPatch": {
                            "properties": {
                                "json": {
                                    "description": "JSON value",
                                }
                            },
                            "type":"object"
                        },
                        "KnownBadgeId": {
                            "description": "KnownBadge Id Doc",
                            "type": "string"
                        },
                    },
                    "info": {
                        "title": "",
                        "version": ""
                    },
                    "paths": {
                        "/api/v1/{resource}/v/{name}": {
                            "delete": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "get": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "head": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "options": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "patch": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "post": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    },
                                    {
                                        "in": "formData",
                                        "name": "data",
                                        "required": true,
                                        "type": "string"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "put": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            }
                        },
                        "/api/v2/{resource}/foo": {
                            "get": {
                                "parameters": [
                                    {
                                        "format": "int32",
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            }
                        },
                        "/api/v2/{resource}/v": {
                            "patch": {
                                "parameters": [
                                    {
                                        "format": "int32",
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "in": "body",
                                        "name": "body",
                                        "required": true,
                                        "schema": {
                                            "$ref": "#/definitions/BadgeBodyPatch"
                                        }
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "post": {
                                "parameters": [
                                    {
                                        "format": "int32",
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "in": "body",
                                        "name": "body",
                                        "required": true,
                                        "schema": {
                                            "$ref": "#/definitions/BadgeBody"
                                        }
                                    }
                                ],
                                "responses": {
                                }
                            }
                        },
                        "/api/v2/{resource}/v/{id}": {
                            "get": {
                                "parameters": [
                                    {
                                        "description": "KnownBadge Id Doc",
                                        "in": "path",
                                        "name": "id",
                                        "required": true,
                                        "type": "string"
                                    }
                                ],
                                "responses": {
                                    "200": {
                                        "description": "OK",
                                        "schema": {
                                            "$ref": "#/definitions/KnownBadgeId"
                                        }
                                    }
                                }
                            }
                        },
                        "/api/v2/{resource}/v/{id}/{id2}/{id3}/{id4}": {
                            "get": {
                                "parameters": [
                                    {
                                        "description": "KnownBadge Id Doc",
                                        "in": "path",
                                        "name": "id",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "description": "KnownBadge Id2 Doc",
                                        "format": "int64",
                                        "in": "path",
                                        "name": "id2",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "description": "Number Doc",
                                        "format": "int64",
                                        "in": "path",
                                        "name": "id3",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "description": "String Doc",
                                        "in": "path",
                                        "name": "id4",
                                        "required": true,
                                        "type": "string"
                                    },
                                ],
                                "responses": {
                                }
                            }
                        },
                        "/api/v2/{resource}/v/{name}": {
                            "get": {
                                "parameters": [
                                    {
                                        "format": "int32",
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "query",
                                        "items": {
                                            "type": "string"
                                        },
                                        "name": "colors",
                                        "required": true,
                                        "type": "array"
                                    },
                                    {
                                        "format": "int32",
                                        "in": "query",
                                        "name": "res",
                                        "type": "integer"
                                    }
                                ],
                                "responses": {
                                }
                            },
                            "post": {
                                "parameters": [
                                    {
                                        "format": "int32",
                                        "in": "path",
                                        "name": "resource",
                                        "required": true,
                                        "type": "integer"
                                    },
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "body",
                                        "name": "body",
                                        "required": true,
                                        "schema": {
                                            "$ref": "#/definitions/BadgeBody"
                                        }
                                    }
                                ],
                                "responses": {
                                }
                            }
                        },
                        "/api/v2/check_data": {
                            "get": {
                                "responses": {
                                    "200":{
                                        "description": "OK",
                                        "schema":{
                                           "type": "boolean"
                                        }
                                     }
                                }
                            }
                        },
                    },
                    "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_map_in_out() {
    #[derive(Deserialize, Serialize, Apiv2Schema)]
    struct ImageId(u64);

    #[derive(Serialize, Apiv2Schema)]
    struct Image {
        data: String,
        id: ImageId,
    }

    #[derive(Deserialize, Apiv2Schema)]
    struct Filter {
        pub folders: HashMap<String, Vec<ImageId>>,
    }

    #[derive(Serialize, Apiv2Schema)]
    struct Catalogue {
        pub folders: HashMap<Uuid, Vec<Image>>,
    }

    #[api_v2_operation]
    fn some_images() -> impl Future<Output = web::Json<BTreeMap<String, Image>>> {
        #[allow(unreachable_code)]
        ready(unimplemented!())
    }

    #[api_v2_operation]
    fn catalogue(_filter: web::Json<Filter>) -> impl Future<Output = web::Json<Catalogue>> {
        #[allow(unreachable_code)]
        ready(unimplemented!())
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/images").route(web::get().to(some_images)))
                .service(web::resource("/catalogue").route(web::post().to(catalogue)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions":{
                        "Catalogue":{
                           "properties":{
                              "folders":{
                                 "additionalProperties":{
                                    "items":{
                                       "properties":{
                                          "data":{
                                             "type":"string"
                                          },
                                          "id":{
                                             "format":"int64",
                                             "type":"integer"
                                          }
                                       },
                                       "required":[
                                          "data",
                                          "id"
                                       ],
                                       "type":"object"
                                    },
                                    "type":"array"
                                 },
                                 "type":"object"
                              }
                           },
                           "required":[
                              "folders"
                           ],
                           "type":"object"
                        },
                        "Filter":{
                           "properties":{
                              "folders":{
                                 "additionalProperties":{
                                    "items":{
                                       "format":"int64",
                                       "type":"integer"
                                    },
                                    "type":"array"
                                 },
                                 "type":"object"
                              }
                           },
                           "required":[
                              "folders"
                           ],
                           "type":"object"
                        },
                        "Image":{
                           "properties":{
                              "data":{
                                 "type":"string"
                              },
                              "id":{
                                 "format":"int64",
                                 "type":"integer"
                              }
                           },
                           "required":[
                              "data",
                              "id"
                           ],
                           "type":"object"
                        }
                     },
                     "info":{
                        "title":"",
                        "version":""
                     },
                     "paths":{
                        "/catalogue":{
                           "post":{
                              "parameters":[
                                 {
                                    "in":"body",
                                    "name":"body",
                                    "required":true,
                                    "schema":{
                                       "$ref":"#/definitions/Filter"
                                    }
                                 }
                              ],
                              "responses":{
                                 "200":{
                                    "description":"OK",
                                    "schema":{
                                       "$ref":"#/definitions/Catalogue"
                                    }
                                 }
                              }
                           }
                        },
                        "/images":{
                           "get":{
                              "responses":{
                                 "200":{
                                    "description":"OK",
                                    "schema":{
                                       "additionalProperties":{
                                          "$ref":"#/definitions/Image"
                                       },
                                       "type":"object"
                                    }
                                 }
                              }
                           }
                        }
                     },
                     "swagger":"2.0"
                }),
            );
        },
    );
}

#[test]
fn test_serde_flatten() {
    #[derive(Deserialize, Serialize, Apiv2Schema)]
    struct PagedQuery {
        /// First image number to return
        offset: Option<i32>,
        /// Return number of images
        size: Option<i32>,
    }

    #[derive(Deserialize, Serialize, Apiv2Schema)]
    struct Paging {
        /// Starting image number
        offset: i32,
        /// Total images found
        total: i32,
        /// Page size
        size: i32,
    }

    #[derive(Serialize, Apiv2Schema)]
    struct Image {
        data: String,
        id: Uuid,
        time: chrono_dev::DateTime<chrono_dev::Utc>,
    }

    /// Images response with paging information embedded
    #[derive(Serialize, Apiv2Schema)]
    struct Images {
        data: Vec<Image>,
        #[serde(flatten)]
        paging: Paging,
    }

    /// Query images from library by name
    #[derive(Deserialize, Apiv2Schema)]
    struct ImagesQuery {
        #[serde(flatten)]
        paging: PagedQuery,
        name: Option<String>,
    }

    #[api_v2_operation]
    async fn some_images(_filter: web::Query<ImagesQuery>) -> Result<web::Json<Images>, ()> {
        #[allow(unreachable_code)]
        if _filter.paging.offset.is_some() && _filter.name.is_some() {
            unimplemented!()
        }
        unimplemented!()
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/images").route(web::get().to(some_images)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions": {
                        "Images": {
                          "description": "Images response with paging information embedded",
                          "properties": {
                            "data": {
                              "items": {
                                "properties": {
                                  "data": {
                                    "type": "string"
                                  },
                                  "id": {
                                    "format": "uuid",
                                    "type": "string"
                                  },
                                  "time": {
                                    "format": "date-time",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "data",
                                  "id",
                                  "time"
                                ],
                                 "type":"object"
                              },
                              "type": "array"
                            },
                            "offset": {
                              "description": "Starting image number",
                              "format": "int32",
                              "type": "integer"
                            },
                            "size": {
                              "description": "Page size",
                              "format": "int32",
                              "type": "integer"
                            },
                            "total": {
                              "description": "Total images found",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "data",
                            "paging"
                          ],
                          "type":"object"
                        }
                      },
                      "info": {
                        "title": "",
                        "version": ""
                      },
                      "paths": {
                        "/images": {
                          "get": {
                            "parameters": [
                              {
                                "in": "query",
                                "name": "name",
                                "type": "string"
                              },
                              {
                                "description": "First image number to return",
                                "format": "int32",
                                "in": "query",
                                "name": "offset",
                                "type": "integer"
                              },
                              {
                                "description": "Return number of images",
                                "format": "int32",
                                "in": "query",
                                "name": "size",
                                "type": "integer"
                              }
                            ],
                            "responses": {
                              "200": {
                                "description": "OK",
                                "schema": {
                                  "$ref": "#/definitions/Images"
                                }
                              }
                            }
                          }
                        }
                      },
                      "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_list_in_out() {
    #[derive(Serialize, Deserialize, Apiv2Schema)]
    enum Sort {
        Asc,
        Desc,
    }

    #[derive(Serialize, Deserialize, Apiv2Schema)]
    struct Params {
        sort: Option<Sort>,
        limit: Option<u16>,
    }

    #[api_v2_operation]
    fn get_pets(_q: web::Query<Params>) -> impl Future<Output = web::Json<Vec<Pet>>> {
        #[allow(unreachable_code)]
        ready(unimplemented!())
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/pets").route(web::get().to(get_pets)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description": "Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/pets": {
                      "get": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "type": "array",
                              "items": {
                                "$ref": "#/definitions/Pet"
                              }
                            }
                          }
                        },
                        "parameters": [{
                            "format": "int32",
                            "in": "query",
                            "name": "limit",
                            "type": "integer"
                          }, {
                            "enum": ["Asc", "Desc"],
                            "in": "query",
                            "name": "sort",
                            "type": "string"
                        }],
                      },
                    }
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_tags() {
    #[derive(Serialize, Apiv2Schema)]
    struct Image {
        data: String,
        id: u64,
    }

    #[api_v2_operation(tags(Cats, Dogs))]
    fn some_pets_images() -> impl Future<Output = web::Json<Vec<Image>>> {
        ready(web::Json(Vec::new()))
    }

    #[api_v2_operation(tags(Cats, "Nice cars"))]
    fn some_cats_cars_images() -> impl Future<Output = web::Json<Vec<Image>>> {
        ready(web::Json(Vec::new()))
    }

    run_and_check_app(
        || {
            let mut spec = DefaultApiRaw::default();
            spec.tags = vec![
                Tag {
                    name: "Dogs".to_string(),
                    description: Some("Images of dogs".to_string()),
                    external_docs: None,
                },
                Tag {
                    name: "Cats".to_string(),
                    description: Some("Images of cats".to_string()),
                    external_docs: None,
                },
                Tag {
                    name: "Nice cars".to_string(),
                    description: Some("Images of nice cars".to_string()),
                    external_docs: None,
                },
            ];
            spec.info = Info {
                version: "0.1".into(),
                title: "Image server".into(),
                ..Default::default()
            };

            App::new()
                .wrap_api_with_spec(spec)
                .with_json_spec_at("/api/spec")
                .service(web::resource("/images/pets").route(web::get().to(some_pets_images)))
                .service(
                    web::resource("/images/cats/cars").route(web::get().to(some_cats_cars_images)),
                )
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions":{
                        "Image":{
                            "properties":{
                                "data":{
                                "type":"string"
                                },
                                "id":{
                                "format":"int64",
                                "type":"integer"
                                }
                            },
                            "required":[
                                "data",
                                "id"
                            ],
                            "type":"object"
                        }
                    },
                    "info":{
                        "title":"Image server",
                        "version":"0.1"
                    },
                    "paths":{
                        "/images/pets":{
                            "get":{
                                "responses":{
                                "200":{
                                    "description":"OK",
                                    "schema":{
                                        "items":{
                                            "$ref":"#/definitions/Image"
                                        },
                                        "type":"array"
                                    }
                                }
                                },
                                "tags":[ "Cats", "Dogs" ]
                            }
                        },
                        "/images/cats/cars":{
                            "get":{
                                "responses":{
                                "200":{
                                    "description":"OK",
                                    "schema":{
                                        "items":{
                                            "$ref":"#/definitions/Image"
                                        },
                                        "type":"array"
                                    }
                                }
                                },
                                "tags":[ "Cats", "Nice cars" ]
                            }
                        }
                    },
                    "swagger":"2.0",
                    "tags":[
                        {
                            "description":"Images of dogs",
                            "name":"Dogs"
                        },
                        {
                            "description":"Images of cats",
                            "name":"Cats"
                        },
                        {
                            "description":"Images of nice cars",
                            "name":"Nice cars"
                        }
                    ]
                }),
            );
        },
    );
}

#[test]
#[allow(unreachable_code)]
fn test_impl_traits() {
    #[api_v2_operation]
    fn index() -> impl Responder {
        ""
    }

    #[derive(Serialize, Deserialize, Apiv2Schema)]
    struct Params {
        limit: Option<u16>,
    }

    #[api_v2_operation]
    fn get_pets(
        _data: web::Data<String>,
        _q: web::Query<Params>,
    ) -> impl Future<Output = Result<web::Json<Vec<Pet>>, ()>> {
        if true {
            // test for return in wrapper blocks (#75)
            return futures::future::err(());
        }

        futures::future::err(())
    }

    #[api_v2_operation]
    async fn get_pet_async() -> impl Responder {
        Pet::default()
    }

    #[api_v2_operation]
    fn get_pet() -> impl Responder {
        Pet::default()
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/").route(web::get().to(index)))
                .service(web::resource("/pets").route(web::get().to(get_pets)))
                .service(web::resource("/pet").route(web::get().to(get_pet)))
                .service(web::resource("/pet_async").route(web::get().to(get_pet_async)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description": "Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/": {
                      "get": {
                        "responses": {}
                      }
                    },
                    "/pets": {
                      "get": {
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "type": "array",
                              "items": {
                                "$ref": "#/definitions/Pet"
                              }
                            }
                          }
                        },
                        "parameters": [{
                            "format": "int32",
                            "in": "query",
                            "name": "limit",
                            "type": "integer"
                        }]
                      },
                    },
                    "/pet": {
                      "get": {
                        "responses": {}
                      }
                    },
                    "/pet_async": {
                      "get": {
                        "responses": {}
                      }
                    }
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
#[allow(unreachable_code)]
fn test_operation_with_generics() {
    #[api_v2_operation]
    fn get_pet_by_id<I: paperclip::v2::schema::Apiv2Schema>(
        _path: web::Path<I>,
    ) -> impl Future<Output = Result<web::Json<Vec<Pet>>, ()>> {
        futures::future::ok(web::Json(vec![Pet::default()]))
    }

    #[api_v2_operation]
    async fn get_pet_by_name<S: paperclip::v2::schema::Apiv2Schema + ToString>(
        _path: web::Path<S>,
    ) -> Result<web::Json<Vec<Pet>>, ()> {
        Ok(web::Json(vec![Pet::default()]))
    }

    #[api_v2_operation]
    async fn get_pet_by_type<S>(_path: web::Path<S>) -> Result<web::Json<Vec<Pet>>, ()>
    where
        S: paperclip::v2::schema::Apiv2Schema + ToString,
    {
        Ok(web::Json(vec![Pet::default()]))
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/pet/id/{id}").route(web::get().to(get_pet_by_id::<u64>)))
                .service(
                    web::resource("/pet/name/{name}")
                        .route(web::get().to(get_pet_by_name::<String>)),
                )
                .service(
                    web::resource("/pet/type/{type}")
                        .route(web::get().to(get_pet_by_type::<String>)),
                )
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions":{
                        "Pet":{
                           "description":"Pets are awesome!",
                           "properties":{
                              "class":{
                                 "enum":[
                                    "dog",
                                    "cat",
                                    "other"
                                 ],
                                 "type":"string"
                              },
                              "id":{
                                 "format":"int64",
                                 "type":"integer"
                              },
                              "name":{
                                 "description":"Pick a good one.",
                                 "type":"string"
                              },
                              "birthday": {
                                "format": "date",
                                "type": "string"
                              },
                              "updatedOn":{
                                 "format":"date-time",
                                 "type":"string"
                              },
                              "uuid":{
                                 "format":"uuid",
                                 "type":"string"
                              }
                           },
                           "required":[
                             "birthday",
                              "class",
                              "name"
                           ],
                           "type":"object"
                        }
                     },
                     "info":{
                        "title":"",
                        "version":""
                     },
                     "paths":{
                        "/pet/id/{id}":{
                           "get":{
                              "responses":{
                                 "200":{
                                    "description":"OK",
                                    "schema":{
                                       "items":{
                                          "$ref":"#/definitions/Pet"
                                       },
                                       "type":"array"
                                    }
                                 }
                              },
                              "parameters":[
                                {
                                   "format":"int64",
                                   "in":"path",
                                   "name":"id",
                                   "required":true,
                                   "type":"integer"
                                }
                             ]
                          },
                        },
                        "/pet/name/{name}":{
                           "get":{
                              "responses":{
                                 "200":{
                                    "description":"OK",
                                    "schema":{
                                       "items":{
                                          "$ref":"#/definitions/Pet"
                                       },
                                       "type":"array"
                                    }
                                 }
                              },
                              "parameters":[
                                {
                                   "in":"path",
                                   "name":"name",
                                   "required":true,
                                   "type":"string"
                                }
                             ]
                          },
                        },
                        "/pet/type/{type}":{
                           "get":{
                              "responses":{
                                 "200":{
                                    "description":"OK",
                                    "schema":{
                                       "items":{
                                          "$ref":"#/definitions/Pet"
                                       },
                                       "type":"array"
                                    }
                                 }
                              },
                              "parameters":[
                                {
                                   "in":"path",
                                   "name":"type",
                                   "required":true,
                                   "type":"string"
                                }
                             ]
                          },
                        }
                     },
                     "swagger":"2.0"
                }),
            );
        },
    );
}

#[test]
#[allow(unreachable_code)]
fn test_operations_documentation() {
    /// Index call
    #[api_v2_operation]
    fn index() -> impl Responder {
        ""
    }

    #[derive(Serialize, Deserialize, Apiv2Schema)]
    struct Params {
        limit: Option<u16>,
    }

    /// List all pets
    ///
    /// Will provide list of all pets available for sale
    #[api_v2_operation]
    fn get_pets(
        _data: web::Data<String>,
        _q: web::Query<Params>,
    ) -> impl Future<Output = Result<web::Json<Vec<Pet>>, ()>> {
        if true {
            // test for return in wrapper blocks (#75)
            return futures::future::err(());
        }

        futures::future::err(())
    }

    /// Get pet info
    ///
    /// Will provide details on a pet
    #[api_v2_operation]
    async fn get_pet_async() -> impl Responder {
        Pet::default()
    }

    /// Get pet info
    /// sync version
    #[api_v2_operation]
    fn get_pet() -> impl Responder {
        Pet::default()
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/").route(web::get().to(index)))
                .service(web::resource("/pets").route(web::get().to(get_pets)))
                .service(web::resource("/pet").route(web::get().to(get_pet)))
                .service(web::resource("/pet_async").route(web::get().to(get_pet_async)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description": "Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/": {
                      "get": {
                        "responses": {},
                        "summary":"Index call"
                      }
                    },
                    "/pets": {
                      "get": {
                        "description":"Will provide list of all pets available for sale",
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "type": "array",
                              "items": {
                                "$ref": "#/definitions/Pet"
                              }
                            }
                          }
                        },
                        "summary":"List all pets",
                        "parameters": [{
                            "format": "int32",
                            "in": "query",
                            "name": "limit",
                            "type": "integer"
                        }]
                      },
                    },
                    "/pet": {
                      "get": {
                        "responses": {},
                        "summary":"Get pet info sync version"
                      }
                    },
                    "/pet_async": {
                      "get": {
                        "responses": {},
                        "description":"Will provide details on a pet",
                        "summary":"Get pet info"
                      }
                    }
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
#[allow(unreachable_code)]
fn test_operations_macro_attributes() {
    /// Index operation
    ///
    /// This doc comment will be overriden by macro attrs
    #[api_v2_operation(
        summary = "Root",
        description = "Provides an empty value in response",
        operation_id = "getIndex",
        consumes = "application/json, text/plain",
        produces = "text/plain"
    )]
    fn index() -> impl Responder {
        ""
    }

    #[derive(Serialize, Deserialize, Apiv2Schema)]
    struct Params {
        limit: Option<u16>,
    }

    /// List all pets (in summary)
    ///
    /// This doc comment will be used in description
    #[api_v2_operation(operation_id = "getPets")]
    fn get_pets(
        _data: web::Data<String>,
        _q: web::Query<Params>,
    ) -> impl Future<Output = Result<web::Json<Vec<Pet>>, ()>> {
        if true {
            // test for return in wrapper blocks (#75)
            return futures::future::err(());
        }

        futures::future::err(())
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::resource("/").route(web::get().to(index)))
                .service(web::resource("/pets").route(web::get().to(get_pets)))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions": {
                        "Pet": {
                            "description": "Pets are awesome!",
                            "properties": {
                                "class": {
                                "enum": ["dog", "cat", "other"],
                                    "type":"string"
                                },
                                "id": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "name": {
                                    "description": "Pick a good one.",
                                    "type": "string"
                                },
                                "birthday": {
                                  "format": "date",
                                  "type": "string"
                                },
                                "updatedOn": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "uuid":{
                                    "format": "uuid",
                                    "type": "string"
                                }
                            },
                            "required":[
                                "birthday",
                                "class",
                                "name"
                            ],
                            "type":"object"
                        }
                    },
                    "info": {
                        "title":"",
                        "version":""
                    },
                    "paths": {
                        "/": {
                            "get": {
                                "consumes": [
                                    "application/json",
                                    "text/plain"
                                ],
                                "description": "Provides an empty value in response",
                                "operationId": "getIndex",
                                "produces": [ "text/plain" ],
                                "responses": {},
                                "summary": "Root"
                            }
                        },
                        "/pets": {
                            "get": {
                                "description": "This doc comment will be used in description",
                                "operationId": "getPets",
                                "parameters":[{
                                    "format":"int32",
                                    "in":"query",
                                    "name":"limit",
                                    "type":"integer"
                                }],
                                "responses": {
                                "200": {
                                    "description": "OK",
                                    "schema": {
                                        "items": {
                                            "$ref": "#/definitions/Pet"
                                        },
                                        "type": "array"
                                    }
                                }
                                },
                                "summary": "List all pets (in summary)"
                            }
                        }
                    },
                    "swagger": "2.0"
                }),
            );
        },
    );
}

#[test] // issue #71
fn test_multiple_method_routes() {
    #[api_v2_operation]
    fn test_get() -> impl Future<Output = String> {
        ready("get".into())
    }

    #[api_v2_operation]
    fn test_post() -> impl Future<Output = String> {
        ready("post".into())
    }

    fn test_app<F, T, B>(f: F)
    where
        F: Fn() -> App<T, B> + Clone + Send + Sync + 'static,
        B: MessageBody + 'static,
        T: ServiceFactory<
                Config = (),
                Request = ServiceRequest,
                Response = ServiceResponse<B>,
                Error = Error,
                InitError = (),
            > + 'static,
    {
        run_and_check_app(f, |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/v1/foo", addr))
                .send()
                .expect("request failed?");
            assert_eq!(resp.status().as_u16(), 200);
            assert_eq!(resp.text().unwrap(), "get");

            let resp = CLIENT
                .post(&format!("http://{}/v1/foo", addr))
                .send()
                .expect("request failed?");
            assert_eq!(resp.status().as_u16(), 200);
            assert_eq!(resp.text().unwrap(), "post");

            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {},
                  "paths": {
                    "/v1/foo": {
                      "get": {
                        "responses": {},
                      },
                      "post": {
                        "responses": {},
                      },
                    }
                  },
                  "swagger": "2.0",
                }),
            );
        });
    }

    test_app(|| {
        App::new()
            .wrap_api()
            .with_json_spec_at("/api/spec")
            .route("/v1/foo", web::get().to(test_get))
            .route("/v1/foo", web::post().to(test_post))
            .build()
    });

    fn config(cfg: &mut web::ServiceConfig) {
        cfg.route("/foo", web::get().to(test_get))
            .route("/foo", web::post().to(test_post));
    }

    test_app(|| {
        App::new()
            .wrap_api()
            .with_json_spec_at("/api/spec")
            .service(web::scope("/v1").configure(config))
            .build()
    });

    fn config_1(cfg: &mut web::ServiceConfig) {
        cfg.route("/v1/foo", web::get().to(test_get));
    }

    fn config_2(cfg: &mut web::ServiceConfig) {
        cfg.route("/v1/foo", web::post().to(test_post));
    }

    test_app(|| {
        App::new()
            .wrap_api()
            .with_json_spec_at("/api/spec")
            .configure(config_1)
            .configure(config_2)
            .build()
    });
}

#[test]
fn test_custom_extractor_empty_schema() {
    #[derive(Apiv2Schema)]
    #[openapi(empty)]
    struct SomeUselessThing<T>(T);

    impl FromRequest for SomeUselessThing<String> {
        type Error = Error;
        type Future = Ready<Result<Self, Self::Error>>;
        type Config = ();

        fn from_request(_req: &HttpRequest, _payload: &mut Payload) -> Self::Future {
            fut_ok(SomeUselessThing(String::from("booya")))
        }
    }

    #[api_v2_operation]
    fn index(
        _req: HttpRequest,
        _payload: String,
        _thing: SomeUselessThing<String>,
    ) -> impl Future<Output = &'static str> {
        ready("")
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .service(web::resource("/").route(web::get().to(index)))
                .with_raw_json_spec(|app, spec| {
                    app.route(
                        "/api/spec",
                        web::get().to(move || actix_web::HttpResponse::Ok().json(&spec)),
                    )
                })
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {},
                  "paths": {
                    "/": {
                      "get": {
                        "responses": {}
                      }
                    }
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_errors_app() {
    use actix_web::{
        error::{ErrorBadRequest, ResponseError},
        HttpResponse,
    };
    use std::fmt;

    #[api_v2_errors(
        400,
        description = "Sorry, bad request",
        code = 401,
        code = 403,
        description = "Forbidden, go away",
        500
    )]
    #[derive(Debug)]
    struct PetError {}

    impl fmt::Display for PetError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "Bad Request")
        }
    }

    impl ResponseError for PetError {
        fn error_response(&self) -> HttpResponse {
            HttpResponse::from_error(ErrorBadRequest("Bad Request"))
        }
    }

    #[api_v2_operation]
    async fn echo_pet_with_errors(body: web::Json<Pet>) -> Result<web::Json<Pet>, PetError> {
        Ok(body)
    }

    fn config(cfg: &mut web::ServiceConfig) {
        cfg.service(web::resource("/echo").route(web::post().to(echo_pet_with_errors)));
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(web::scope("/api").configure(config))
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description": "Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/api/echo": {
                      "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          },
                          "400": {
                            "description": "Sorry, bad request"
                          },
                          "401": {
                            "description": "Unauthorized"
                          },
                          "403":{
                            "description":"Forbidden, go away"
                          },
                          "500": {
                            "description": "Internal Server Error"
                          }
                        }
                      }
                    },
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_security_app() {
    #[derive(Apiv2Security, Deserialize)]
    #[openapi(
        apiKey,
        alias = "JWT",
        in = "header",
        name = "Authorization",
        description = "Use format 'Bearer TOKEN'"
    )]
    struct AccessToken;

    impl FromRequest for AccessToken {
        type Future = Ready<Result<Self, Self::Error>>;
        type Error = Error;
        type Config = ();

        fn from_request(_: &HttpRequest, _payload: &mut actix_web::dev::Payload) -> Self::Future {
            ready(Ok(Self {}))
        }
    }

    #[derive(Apiv2Security, Deserialize)]
    #[openapi(
        oauth2,
        alias = "MyOAuth2",
        auth_url = "http://example.com/",
        token_url = "http://example.com/token",
        flow = "password"
    )]
    struct OAuth2Access;

    impl FromRequest for OAuth2Access {
        type Future = Ready<Result<Self, Self::Error>>;
        type Error = Error;
        type Config = ();

        fn from_request(_: &HttpRequest, _payload: &mut actix_web::dev::Payload) -> Self::Future {
            ready(Ok(Self {}))
        }
    }

    #[derive(Apiv2Security, Deserialize)]
    #[openapi(parent = "OAuth2Access", scopes("pets.read", "pets.write"))]
    struct PetScope;

    impl FromRequest for PetScope {
        type Future = Ready<Result<Self, Self::Error>>;
        type Error = Error;
        type Config = ();

        fn from_request(_: &HttpRequest, _payload: &mut actix_web::dev::Payload) -> Self::Future {
            ready(Ok(Self {}))
        }
    }

    #[api_v2_operation]
    async fn echo_pet_with_jwt(_: AccessToken, body: web::Json<Pet>) -> web::Json<Pet> {
        body
    }

    #[api_v2_operation]
    async fn echo_pet_with_petstore(_: PetScope, body: web::Json<Pet>) -> web::Json<Pet> {
        body
    }

    fn config(cfg: &mut web::ServiceConfig) {
        cfg.service(web::resource("/echo1").route(web::post().to(echo_pet_with_jwt)))
            .service(web::resource("/echo2").route(web::post().to(echo_pet_with_petstore)));
    }

    run_and_check_app(
        move || {
            App::new()
                .wrap_api()
                .service(web::scope("/api").configure(config))
                .with_json_spec_at("/spec")
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                  "info":{"title":"","version":""},
                  "definitions": {
                    "Pet": {
                      "description": "Pets are awesome!",
                      "properties": {
                        "class": {
                          "enum": ["dog", "cat", "other"],
                          "type": "string"
                        },
                        "id": {
                          "format": "int64",
                          "type": "integer"
                        },
                        "name": {
                          "description": "Pick a good one.",
                          "type": "string"
                        },
                        "birthday": {
                          "format": "date",
                          "type": "string"
                        },
                        "updatedOn": {
                          "format": "date-time",
                          "type": "string"
                        },
                        "uuid": {
                          "format": "uuid",
                          "type": "string"
                        }
                      },
                      "required":["birthday", "class", "name"],
                      "type":"object"
                    }
                  },
                  "paths": {
                    "/api/echo1": {
                      "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          },
                        },
                        "security": [
                          {
                            "JWT": []
                          }
                        ]
                      }
                    },
                    "/api/echo2": {
                      "post": {
                        "parameters": [{
                            "in": "body",
                            "name": "body",
                            "required": true,
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          }],
                        "responses": {
                          "200": {
                            "description": "OK",
                            "schema": {
                              "$ref": "#/definitions/Pet"
                            }
                          },
                        },
                        "security": [
                          {
                            "MyOAuth2": ["pets.read", "pets.write"]
                          }
                        ]
                      }
                    },
                  },
                  "securityDefinitions": {
                    "JWT": {
                        "description":"Use format 'Bearer TOKEN'",
                        "in": "header",
                        "name": "Authorization",
                        "type": "apiKey"
                    },
                    "MyOAuth2": {
                        "scopes": {
                          "pets.read": "pets.read",
                          "pets.write": "pets.write"
                        },
                        "type": "oauth2",
                        "authorizationUrl": "http://example.com/",
                        "tokenUrl": "http://example.com/token",
                        "flow": "password"
                    }
                  },
                  "swagger": "2.0"
                }),
            );
        },
    );
}

#[test]
fn test_method_macro() {
    #[get("/v0/pets")]
    #[api_v2_operation]
    fn get_pets() -> impl Future<Output = Result<web::Json<Vec<Pet>>, ()>> {
        futures::future::ready(Ok(web::Json(Default::default())))
    }
    #[put("/v0/pets/{name}")]
    #[api_v2_operation]
    fn put_pet(
        _name: web::Path<String>,
        pet: web::Json<Pet>,
    ) -> impl Future<Output = Result<web::Json<Pet>, ()>> {
        futures::future::ready(Ok(pet))
    }
    #[post("/v0/pets")]
    #[api_v2_operation]
    fn post_pet(pet: web::Json<Pet>) -> impl Future<Output = Result<web::Json<Pet>, ()>> {
        futures::future::ready(Ok(pet))
    }
    #[delete("/v0/pets/{name}")]
    #[api_v2_operation]
    fn delete_pet(_name: web::Path<String>) -> impl Future<Output = Result<web::Json<()>, ()>> {
        futures::future::ready(Ok(web::Json(())))
    }

    run_and_check_app(
        || {
            App::new()
                .wrap_api()
                .with_json_spec_at("/api/spec")
                .service(get_pets)
                .service(put_pet)
                .service(post_pet)
                .service(delete_pet)
                .build()
        },
        |addr| {
            let resp = CLIENT
                .get(&format!("http://{}/api/spec", addr))
                .send()
                .expect("request failed?");

            check_json(
                resp,
                json!({
                    "definitions": {
                        "Pet": {
                            "description": "Pets are awesome!",
                            "properties": {
                                "class": {
                                "enum": ["dog", "cat", "other"],
                                    "type":"string"
                                },
                                "id": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "name": {
                                    "description": "Pick a good one.",
                                    "type": "string"
                                },
                                "birthday": {
                                  "format": "date",
                                  "type": "string"
                                },
                                "updatedOn": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "uuid":{
                                    "format": "uuid",
                                    "type": "string"
                                }
                            },
                            "required":[
                                "birthday",
                                "class",
                                "name"
                            ],
                            "type":"object"
                        }
                    },
                    "info": {
                        "title":"",
                        "version":""
                    },
                    "paths": {
                        "/v0/pets": {
                            "get": {
                                "responses": {
                                    "200": {
                                        "description": "OK",
                                        "schema": {
                                            "items": {
                                                "$ref": "#/definitions/Pet"
                                            },
                                            "type": "array"
                                        }
                                    }
                                },
                            },
                            "post": {
                                "parameters": [
                                    {
                                        "in": "body",
                                        "name": "body",
                                        "required": true,
                                        "schema": {
                                            "$ref": "#/definitions/Pet"
                                        }
                                    }
                                ],
                                "responses": {
                                    "200": {
                                        "description": "OK",
                                        "schema": {
                                            "$ref": "#/definitions/Pet"
                                        }
                                    }
                                },
                            }
                        },
                        "/v0/pets/{name}": {
                            "delete": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                ],
                                "responses": {
                                    "200": {
                                        "description": "OK",
                                        "schema": {
                                        }
                                    }
                                },
                            },
                            "put": {
                                "parameters": [
                                    {
                                        "in": "path",
                                        "name": "name",
                                        "required": true,
                                        "type": "string"
                                    },
                                    {
                                        "in": "body",
                                        "name": "body",
                                        "required": true,
                                        "schema": {
                                            "$ref": "#/definitions/Pet"
                                        }
                                    }
                                ],
                                "responses": {
                                    "200": {
                                        "description": "OK",
                                        "schema": {
                                            "$ref": "#/definitions/Pet"
                                        }
                                    }
                                },
                            }
                        }
                    },
                    "swagger": "2.0"
                }),
            );
        },
    );
}

fn run_and_check_app<F, G, T, B, U>(factory: F, check: G) -> U
where
    F: Fn() -> App<T, B> + Clone + Send + Sync + 'static,
    B: MessageBody + 'static,
    T: ServiceFactory<
            Config = (),
            Request = ServiceRequest,
            Response = ServiceResponse<B>,
            Error = Error,
            InitError = (),
        > + 'static,
    G: Fn(String) -> U,
{
    let (tx, rx) = mpsc::channel();

    let _ = thread::spawn(move || {
        let sys = System::new("test");
        for port in 3000..30000 {
            if !PORTS.lock().insert(port) {
                continue;
            }

            let addr = format!("127.0.0.1:{}", port);
            let server = match HttpServer::new(factory.clone()).bind(&addr) {
                Ok(srv) => {
                    println!("Bound to {}", addr);
                    srv
                }
                Err(_) => continue,
            };

            let s = server.run();
            tx.send((s, addr)).unwrap();
            sys.run().expect("system error?");
            return;
        }

        unreachable!("No ports???");
    });

    let (_server, addr) = rx.recv().unwrap();
    let ret = check(addr);
    let _ = _server.stop(true);
    ret
}

fn check_json(resp: reqwest::blocking::Response, expected: serde_json::Value) {
    assert_eq!(resp.status().as_u16(), 200);
    let json = resp.json::<serde_json::Value>().expect("json error");

    if json != expected {
        panic!(
            "assertion failed:
  left: {}

 right: {}
",
            json.to_string(),
            expected.to_string()
        )
    }
}

'''
'''--- tests/test_codegen.rs ---
use paperclip::v2::{
    self,
    codegen::{CrateMeta, DefaultEmitter, EmitMode, Emitter, EmitterState},
    models::{DefaultSchema, ResolvableApi},
};

use once_cell::sync::Lazy;
use std::{fs::File, path::PathBuf};

static ROOT: Lazy<PathBuf> = Lazy::new(|| PathBuf::from(env!("CARGO_MANIFEST_DIR")));
static PET_SCHEMA: Lazy<ResolvableApi<DefaultSchema>> = Lazy::new(|| {
    let fd = File::open(ROOT.join("tests/pet-v2.yaml")).expect("file?");
    let raw: ResolvableApi<DefaultSchema> = v2::from_reader(fd).expect("deserializing spec");
    raw.resolve().expect("resolution")
});
static K8S_SCHEMA: Lazy<ResolvableApi<K8sSchema>> = Lazy::new(|| {
    let fd = File::open(ROOT.join("tests/k8s-v1.16.0-alpha.0-openapi-v2.json")).expect("file?");
    let raw: ResolvableApi<K8sSchema> = v2::from_reader(fd).expect("deserializing spec");
    raw.resolve().expect("resolution")
});
static CODEGEN_PET_LIB: Lazy<()> = Lazy::new(|| {
    let mut state = EmitterState::default();
    state.working_dir = ROOT.clone();
    state.working_dir.push("tests/test_pet");
    let mut meta = CrateMeta::default();
    meta.authors = Some(vec!["Me <me@example.com>".into()]);
    meta.mode = EmitMode::Crate;
    state.set_meta(meta);

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&PET_SCHEMA).expect("codegen");
});
static CODEGEN_PET_LIB_NO_ROOT: Lazy<()> = Lazy::new(|| {
    let mut state = EmitterState::default();
    state.working_dir = ROOT.clone();
    state.working_dir.push("tests/test_pet/no_root");
    let mut meta = CrateMeta::default();
    meta.authors = Some(vec!["Me <me@example.com>".into()]);
    meta.mode = EmitMode::Crate;
    meta.no_root = true;
    state.set_meta(meta);

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&PET_SCHEMA).expect("codegen");
});
static CODEGEN_PET_CLI: Lazy<()> = Lazy::new(|| {
    let mut state = EmitterState::default();
    state.working_dir = (&*ROOT).into();
    state.working_dir.push("tests/test_pet/cli");
    let mut meta = CrateMeta::default();
    meta.authors = Some(vec!["Me <me@example.com>".into()]);
    meta.mode = EmitMode::App;
    state.set_meta(meta);

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&PET_SCHEMA).expect("codegen");
});

static CODEGEN_K8S_LIB: Lazy<()> = Lazy::new(|| {
    let mut state = EmitterState::default();
    state.working_dir = (&*ROOT).into();
    state.working_dir.push("tests");
    state.working_dir.push("test_k8s");
    state.mod_prefix = "crate::codegen::";

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&K8S_SCHEMA).expect("codegen");
});
static CODEGEN_K8S_CLI: Lazy<()> = Lazy::new(|| {
    let mut state = EmitterState::default();
    state.working_dir = (&*ROOT).into();
    state.working_dir.push("tests/test_k8s/cli");
    let mut meta = CrateMeta::default();
    assert_eq!(meta.mode, EmitMode::Module);
    meta.name = Some("test-k8s-cli".into());
    meta.version = Some("0.0.0".into());
    meta.authors = Some(vec!["Me <me@example.com>".into()]);
    meta.mode = EmitMode::App;
    state.set_meta(meta);

    let emitter = DefaultEmitter::from(state);
    emitter.generate(&K8S_SCHEMA).expect("codegen");
});

#[derive(Debug, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
enum PatchStrategy {
    Merge,
    RetainKeys,
    #[serde(rename = "merge,retainKeys")]
    MergeAndRetain,
}

#[paperclip::api_v2_schema]
#[allow(dead_code)]
#[derive(Debug, serde::Deserialize)]
struct K8sSchema {
    #[serde(rename = "x-kubernetes-patch-strategy")]
    patch_strategy: Option<PatchStrategy>,
}

static CODEGEN: Lazy<()> = Lazy::new(|| {
    env_logger::builder()
        .filter(Some("paperclip"), log::LevelFilter::Info)
        .init();
    Lazy::force(&CODEGEN_PET_LIB);
    Lazy::force(&CODEGEN_PET_LIB_NO_ROOT);
    Lazy::force(&CODEGEN_PET_CLI);
    Lazy::force(&CODEGEN_K8S_LIB);
    Lazy::force(&CODEGEN_K8S_CLI);
});

fn assert_file(path: &str) {
    Lazy::force(&CODEGEN);

    let data = std::fs::read_to_string(ROOT.join(path))
        .unwrap_or_else(|err| panic!("missing file {}: {}", path, err));
    insta::assert_snapshot!(path, data);
}

#[cfg(test)]
mod tests_pet {
    use super::*;
    #[test]
    fn test_lib_root() {
        assert_file("tests/test_pet/lib.rs");
    }

    #[test]
    fn test_no_root_manifest() {
        assert_file("tests/test_pet/no_root/Cargo.toml");
    }

    #[test]
    fn test_manifest() {
        assert_file("tests/test_pet/Cargo.toml");
    }

    #[test]
    fn test_header_parameters() {
        assert_file("tests/test_pet/pet.rs");
    }

    #[test]
    fn test_cli_params() {
        assert_file("tests/test_pet/cli/app.yaml");
    }

    #[test]
    fn test_recusrive_object() {
        assert_file("tests/test_pet/recursive_container.rs");
        assert_file("tests/test_pet/recursive_object.rs");
    }

    #[test]
    fn test_anonymous_object_definition_in_schema() {
        // An object "can" define objects in its schema without referencing
        // them from known definitions. In that case, we autogenerate stuff.
        assert_file("tests/test_pet/order.rs");
    }
    #[test]
    fn test_anonymous_object_definition_in_body() {
        assert_file("tests/test_pet/post_shipments_body.rs");
    }

    #[test]
    fn test_anonumous_object_definition_in_response() {
        assert_file("tests/test_pet/get_shipments_id_response.rs");
    }

    #[test]
    fn test_simple_array_parameter_in_path() {
        assert_file("tests/test_pet/status.rs");
    }

    #[test]
    fn test_misc() {
        assert_file("tests/test_pet/miscellaneous.rs");
    }

    #[test]
    fn test_multipart_with_file() {
        assert_file("tests/test_pet/cli/status.rs");
    }

    #[test]
    fn test_simple_any_enum() {
        assert_file("tests/test_pet/test_enum.rs");
    }
}

#[cfg(test)]
mod tests_k8s {
    use super::*;
    use paperclip::v2::models::{HttpMethod, Version};

    #[test]
    fn test_definition_ref_cycles() {
        assert_eq!(K8S_SCHEMA.swagger, Version::V2);
        assert_eq!(K8S_SCHEMA.definitions.len(), 663);

        let json_props_def = &K8S_SCHEMA.definitions
            ["io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.JSONSchemaProps"];
        let desc = json_props_def.read().description.clone();
        let all_of = json_props_def.read().properties["allOf"].clone();
        let items = all_of.read().items.as_ref().unwrap().clone();
        assert_eq!(items.read().description, desc); // both point to same `JSONSchemaProps`
    }

    #[test]
    fn test_resolved_schema() {
        let resp = &K8S_SCHEMA.paths["/api/"].methods[&HttpMethod::Get].responses["200"].read();
        let schema = resp.schema.as_ref().expect("bleh?").read();
        assert!(schema.reference.is_none()); // this was a reference
        assert_eq!(
            &K8S_SCHEMA.definitions["io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions"]
                .read()
                .description
                .as_ref()
                .unwrap()
                .as_str(),
            schema.description.as_ref().unwrap()
        );
    }

    #[test]
    fn test_child_module_declarations() {
        assert_file("tests/test_k8s/io/k8s/api/mod.rs");
    }

    #[test]
    fn test_transparency_with_params() {
        assert_file("tests/test_k8s/io/k8s/apiextensions_apiserver/pkg/apis/apiextensions/v1beta1/custom_resource_definition.rs");
    }
    #[test]
    fn test_struct_for_complex_object() {
        assert_file("tests/test_k8s/io/k8s/apiextensions_apiserver/pkg/apis/apiextensions/v1beta1/json_schema_props.rs");
    }

    #[test]
    fn test_root_mod() {
        assert_file("tests/test_k8s/mod.rs");
    }

    #[test]
    fn test_generics_mod() {
        assert_file("tests/test_k8s/generics.rs");
    }

    #[test]
    fn test_same_object_creates_multiple_builders() {
        assert_file("tests/test_k8s/io/k8s/api/core/v1/config_map.rs")
    }

    #[test]
    fn test_same_object_with_multiple_builders_has_basic_builder() {
        assert_file("tests/test_k8s/io/k8s/api/core/v1/pod.rs")
    }

    #[test]
    fn test_simple_object_builder_with_required_fields() {
        assert_file("tests/test_k8s/io/k8s/api/rbac/v1/policy_rule.rs")
    }

    #[test]
    fn test_builder_with_field_parameter_collision_and_method_collision() {
        // grace_period_seconds, orphan_dependents and propagation_policy
        // exist in both the object and as a query parameter. If one is set,
        // we should also set the other.
        assert_file("tests/test_k8s/io/k8s/apimachinery/pkg/apis/meta/v1/delete_options.rs");
    }

    #[test]
    fn test_unit_builder_with_no_modifier() {
        assert_file("tests/test_k8s/io/k8s/apimachinery/pkg/apis/meta/v1/api_group_list.rs");
    }

    #[test]
    fn test_builder_field_with_iterators() {
        assert_file(
            "tests/test_k8s/io/k8s/api/certificates/v1beta1/certificate_signing_request_spec.rs",
        );
    }

    #[test]
    fn test_any_in_operation_bound_to_unrelated_struct() {
        assert_file("tests/test_k8s/io/k8s/apimachinery/pkg/apis/meta/v1/patch.rs");
    }

    #[test]
    fn test_cli_manifest() {
        assert_file("tests/test_k8s/cli/Cargo.toml");
    }

    #[test]
    fn test_cli_main() {
        assert_file("tests/test_k8s/cli/main.rs");
    }

    #[test]
    fn test_clap_yaml() {
        assert_file("tests/test_k8s/cli/app.yaml");
    }
}

'''
'''--- tests/test_errors.rs ---
use paperclip::v2::{
    self,
    codegen::{DefaultEmitter, Emitter, EmitterState},
    models::{DefaultSchema, ResolvableApi},
};

use std::io::Cursor;

#[test]
fn test_templated_path_missing_parameters() {
    let spec = Cursor::new(
        b"
swagger: \"2.0\"
definitions: {}
info:
  title:  \"Petstore\"
  version: \"1.0.0\"
paths:
  /pets/{petId}:
    get:
      responses:
        \"200\":
          schema:
            type: string
" as &[_],
    );

    let raw: ResolvableApi<DefaultSchema> = v2::from_reader(spec).expect("deserializing spec");
    let resolved = raw.resolve().expect("resolution");

    let state = EmitterState::default();
    let emitter = DefaultEmitter::from(state);
    let err = emitter.generate(&resolved).unwrap_err().to_string();
    assert_eq!(
        err,
        "Parameter(s) {\"petId\"} aren't defined for templated path \"/pets/{petId}\"",
    );
}

#[test]
fn test_templated_path_uniqueness() {
    let spec = Cursor::new(
        b"
swagger: \"2.0\"
definitions: {}
info:
  title:  \"Petstore\"
  version: \"1.0.0\"
paths:
  /store/{id1}/pets/{id2}:
    parameters:
    - name: id1
      in: path
      type: integer
      required: true
    - name: id2
      in: path
      type: integer
      required: true
    get:
      responses:
        \"200\":
          schema:
            type: string
  /store/{storeId}/pets/{petId}:
    get:
      responses:
        \"200\":
          schema:
            type: string
" as &[_],
    );

    let raw: ResolvableApi<DefaultSchema> = v2::from_reader(spec).expect("deserializing spec");
    let resolved = raw.resolve().expect("resolution");

    let state = EmitterState::default();
    let emitter = DefaultEmitter::from(state);
    let err = emitter.generate(&resolved).unwrap_err().to_string();
    assert_eq!(
        err,
        "Path similar to \"/store/{storeId}/pets/{petId}\" already exists.",
    );
}

'''
'''--- tests/test_k8s/Cargo.toml ---
[package]
name = "test-k8s"
version = "0.0.0"
authors = ["Ravi Shankar <wafflespeanut@gmail.com>"]
edition = "2018"

[lib]
path = "lib.rs"

[dependencies]
async-trait = "0.1"
bytes = "0.5"
thiserror = "1.0"
futures = "0.3"
http = "0.2"
lazy_static = "1.4"
log = "0.4"
mime = { git = "https://github.com/hyperium/mime" }
mime_guess = "2.0"
parking_lot = "0.11"
reqwest = { version = "0.10", features = ["stream", "json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.8"
tokio-util = { version = "0.4", features = ["codec"] }
tokio = { version = "0.3", features = ["fs", "io-util"] }
url = "2.1"

[workspace]

'''
'''--- tests/test_k8s/lib.rs ---
#[macro_use] extern crate serde;

mod codegen {
    include!("./mod.rs");
}

pub use codegen::{io::k8s::*, miscellaneous};
pub use codegen::client::{ApiError, Sendable};
pub use codegen::util::ResponseStream;

'''