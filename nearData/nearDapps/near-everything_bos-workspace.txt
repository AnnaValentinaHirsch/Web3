*GitHub Repository "near-everything/bos-workspace"*

'''--- .github/workflows/tests.yml ---
name: Run Tests

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  test:
    name: Execute Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "14" # Adjust according to your needs

      - name: Install Dependencies
        run: yarn install

      - name: Execute Test Tools
        run: yarn test:tools

'''
'''--- README.md ---

<!-- PROJECT LOGO -->
<br />
<div align="center">
  <a href="https://github.com/near-everything/bos-workspace">
    <img src="https://i.near.social/magic/thumbnail/https://near.social/magic/img/account/efiz.near" alt="Logo" width="80" height="80">
  </a>

  <h3 align="center">
     Everything BOS Workspace
  </h3>

  <p align="center">
    A Monorepo that holds multiple BOS apps/widgets
    <br />
    <a href="https://github.com/near-everything/bos-workspace/blob/main/docs/GETTING_STARTED.md"><strong>Explore the docs »</strong></a>
    <br />
    <br />
    <a href="https://github.com/near-everything/bos-workspace/issues">Report Bug</a>
    ·
    <a href="https://github.com/near-everything/bos-workspace/issues">Request Feature</a>
  </p>
</div>

<!-- GETTING STARTED -->
## Getting Started

To get a local copy up and running follow these simple steps.

### Prerequisites

1. Clone the repo

  ```sh
  git clone https://github.com/near-everything/bos-workspace.git
  ```

2. Install using your favorite package manager

  ```sh
  yarn
  ```

3. Run the development server

  ```sh
  yarn dev
  ```

4. Go to [https://everything.dev/flags](https://everything.dev/flags) or [https://near.org/flags](https://near.org/flags) and set the bos loader Url to

```sh
http://127.0.0.1:4040/
```

5. Now you can access the local apps in the gateway, for example to access `apps/create` go to [bos://createit.near/widget/home](https://near.org/createit.near/widget/home)

6. For more details on how to use this workspace, please refer to the [Documentation](https://github.com/sekaiking/bos-workspace)

'''
'''--- apps/archive/bos.config.json ---
{
  "appAccount": "archive.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/bos-blocks/bos.config.json ---
{
  "appAccount": "efiz.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/common/bos.config.json ---
{
  "appAccount": "common.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/create/bos.config.json ---
{
  "appAccount": "createit.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/devs/bos.config.json ---
{
  "appAccount": "devs.near",
  "aliases": {
    "hello": "<h1>Hello, world! Have a nice day!</h1>"
  }
}

'''
'''--- apps/docs/bos.config.json ---
{
  "appAccount": "docs.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/dummyapp/bos.config.json ---
{
  "appAccount": "dummy.near",
  "aliases": {
    "hello": "<h1>Hello, world! Have a nice day!</h1>"
  }
}

'''
'''--- apps/eventForm/bos.config.json ---
{
    "appAccount": "itexpert120-contra.near",
    "aliases": {}
}
  
'''
'''--- apps/every/bos.config.json ---
{
  "appAccount": "every.near",
  "aliases": {
    "hello": "<h1>Hello, world! Have a nice day!</h1>"
  }
}

'''
'''--- apps/experiment/bos.config.json ---
{
  "appAccount": "create.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/groups/bos.config.json ---
{
  "appAccount": "hack.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- apps/livepeer/bos.config.json ---
{
  "appAccount": "efiz.near",
  "aliases": {
    "nui": "nearui.near"
  }
}

'''
'''--- docs/GETTING_STARTED.md ---
# Getting Started

First, install [bos-workspace](https://github.com/sekaiking/bos-workspace)

```bash
npm install -g bos-workspace
```

Next,

bos://devs.near/widget/GithubForkButton

This is now your workspace. To use it, run:

```bash
yarn && yarn dev
```

This will broadcast your widgets.

```bash
|--------------------------------------------\
| Server running at http://127.0.0.1:4040/
|
| To use the local widgets, go to https://near.org/flags
| and paste the server link above.
| --------------------------------------------\
```

Copy this server address, and paste it as the BOS Loader Url [here](https://everything.dev/flags).

Now refresh the page.

bos://docs.near/widget/verify

'''
'''--- modules/QoL/Url.js ---
const Url = {
  construct: (url, params) => {
    let query = "";
    Object.keys(params || {}).forEach((key) => {
      if (params.hasOwnProperty(key)) {
        query += Url.encode(key) + "=" + Url.encode(params[key]);
        if (key !== Object.keys(params || {}).slice(-1)[0]) {
          query += "&";
        }
      }
    });
    return url + "?" + query;
  },
  // Alternative to encodeURIComponent
  encode: (str) => {
    return `${str}`
      .replace(/[!'()*]/g, (c) => {
        return "%" + c.charCodeAt(0).toString(16);
      })
      .replace(/[^!'\(\)~\*A-Za-z0-9\-_\.~]/g, (c) => {
        return "%" + c.charCodeAt(0).toString(16);
      });
  },
};

'''
'''--- modules/QoL/classNames.js ---
const classNames = (classes) =>
  classes.filter((className) => className).join(" ");

'''
'''--- modules/QoL/storage.js ---
const store = (k, v) => Storage.privateSet(k, v);
const retrieve = (k) => Storage.privateGet(k);

'''
'''--- modules/QoL/widget.js ---
const widget = (src, props, other) => (
  <Widget src={src} props={props} {...other} />
);

'''
'''--- modules/everything/sdk.js ---
/*__@import:everything/utils/UUID__*/

function filterByType(data, targetType) {
  return Object.keys(data || {}).reduce((result, key) => {
    if (data[key].metadata?.type === targetType) {
      result[key] = data[key];
    }
    return result;
  }, {});
}

function deepMerge(obj1, obj2) {
  return Object.keys({ ...obj1, ...obj2 }).reduce((acc, key) => {
    if (
      obj1[key] &&
      obj2[key] &&
      typeof obj1[key] === "object" &&
      typeof obj2[key] === "object"
    ) {
      acc[key] = deepMerge(obj1[key], obj2[key]);
    } else {
      acc[key] = obj2[key] !== undefined ? obj2[key] : obj1[key];
    }
    return acc;
  }, {});
}

/**
 * Gets all things of a given type, optionally filtered by accounts and blockHeight
 * @param {string} type - type of thing to filter by
 * @param {Array<string>} [accounts] - Optional list of accounts to filter by
 * @param {string|number} blockHeight - Optional blockHeight to use; defaults to "final"
 * @returns {object} - all things of the given type
 */
function getAllThings(type, accounts, blockHeight) {
  let paths;
  if (!blockHeight) {
    blockHeight = "final";
  }

  if (Array.isArray(accounts) && accounts.length) {
    // We could change this to get all metadata, metadata includes type
    // and then we have all we need in order to show on screens. Anything else can be fetched separately.
    paths = accounts.map((account) => `${account}/thing/*/metadata/*`);
  } else {
    paths = ["*/thing/*/metadata/*"];
  }
  const things = Social.get(paths, blockHeight);
  return filterByType(things, type) ?? {};
}

/**
 * Gets the thing matching id, optionally filtered by accounts and blockHeight
 * @param {string} id - thing id
 * @param {Array<string>} [accountIds] - Optional list of accounts to filter by. If not provided, defaults to any account.
 * @param {string|number} blockHeight - Optional blockHeight to use; defaults to "final"
 * @returns {object|null} - the thing, multiple things if matches id across accounts, or null if not found
 */
function getThing(id, accountIds, blockHeight) {
  let paths;
  if (!blockHeight) {
    blockHeight = "final";
  }

  if (Array.isArray(accountIds) && accountIds.length) {
    paths = accountIds.map((accountId) => `${accountId}/thing/${id}/**`);
  } else {
    paths = [`*/thing/${id}/**`];
  }

  const thing = Social.get(paths, blockHeight) || {};

  return thing;
}

function deleteThing(id) {
  Social.set({
    thing: {
      [id]: null,
    },
  });
}

/**
 * Creates a thing with the given type, data, and metadata
 * Subsequently calls onCommit or onCancel
 * @param {string} type - type of thing to create
 * @param {object} data - data to store
 * @param {object} metadata - metadata to store
 */
function createThing(type, data, metadata) {
  // Temporary small id
  const id = UUID.generate("xxxxxxx");
  return {
    [id]: {
      // I think there may be some value in stringify-ing the data and storing in empty key, but I'm not sure
      // Maybe it's for published data? Data that has no relations?
      // It's more space efficient for the social contract if we limit the number of keys
      "": JSON.stringify(data),
      data, // so I'm just gonna do both for right now :)
      metadata: { ...metadata, type },
    },
  };
}

'''
'''--- modules/everything/utils/UUID.js ---
const UUID = {
  generate: (template) => {
    if (typeof template !== "string") {
      template = "xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx";
    }
    return template.replace(/[xy]/g, (c) => {
      var r = (Math.random() * 16) | 0;
      var v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  },
};

'''
'''--- modules/everything/utils/date-time.js ---
const getCurrentDate = () => {
  const currentDate = new Date();

  const year = currentDate.getFullYear();
  const month = (currentDate.getMonth() + 1).toString().padStart(2, "0"); // Months are 0-indexed
  const day = currentDate.getDate().toString().padStart(2, "0");

  return `${year}-${month}-${day}`;
};

const getCurrentTime = () => {
  const currentDate = new Date();

  const hours = currentDate.getHours().toString().padStart(2, "0");
  const minutes = currentDate.getMinutes().toString().padStart(2, "0");

  return `${hours}:${minutes}`;
};

const isoTime = (date, time) => {
  const temp = new Date(`${date} ${time}`);
  const now = temp.toISOString();

  return now.split("T")[1];
};

const isoDate = (date, time) => {
  const temp = new Date(`${date} ${time}`);
  const now = temp.toISOString();

  return now.split("T")[0];
};

'''
'''--- modules/everything/utils/debounce.js ---
let timeoutId;

const debounce = (func, delay) => {
  if (!delay) {
    delay = 300;
  }
  clearTimeout(timeoutId);
  timeoutId = setTimeout(func, delay);
};

'''
'''--- modules/everything/utils/fetchEvents.js ---
// helper function to fetch all events
const fetchAllEvents = () => {
  const index = Social.index("every", "every.near/type/event");

  let fetchedEvents = [];

  index.map((item) => {
    const path = `${item.accountId}/thing/${item.value.id}`;
    const blockHeight = item.blockHeight;

    const eventThing = Social.getr(path, blockHeight);
    fetchedEvents.push(eventThing.data);
  });

  return fetchedEvents;
};

'''
'''--- modules/everything/utils/propsChecker.js ---
function checkProps(props, typeDef, prefix) {
  if (!prefix) {
    prefix = "";
  }
  const missingProps = [];

  for (const [key, value] of Object.entries(typeDef.properties)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (!props.hasOwnProperty(key)) {
      missingProps.push(`${fullKey}`);
      continue;
    }

    const propValue = props[key];

    if (value.type === "object" && value.properties) {
      missingProps.push(...checkProps(propValue, value, fullKey));
    }

    if (value.validation && value.validation.required && propValue == null) {
      missingProps.push(`${fullKey} (required)`);
    }
  }

  return missingProps;
}

function MissingPropsWarning({ props, typeDef }) {
  const missingProps = checkProps(props, typeDef);

  return (
    missingProps.length > 0 && (
      <div
        className="card border-warning mb-3 shadow"
        style={{ maxWidth: "30rem", margin: "auto" }}
      >
        <div className="card-header text-white bg-warning">
          <h4 className="card-title mb-0">Attention!</h4>
        </div>
        <div className="card-body text-danger">
          <p className="card-text">
            There {missingProps.length === 1 ? "is" : "are"}{" "}
            {missingProps.length} missing or invalid prop
            {missingProps.length === 1 ? "" : "s"}:
          </p>
          <ul className="list-group list-group-flush">
            {missingProps.map((prop) => (
              <li key={prop} className="list-group-item">
                <pre className="m-0">{prop}</pre>
              </li>
            ))}
          </ul>
        </div>
      </div>
    )
  );
}

'''
'''--- modules/hello.js ---
const hello = () => {
  console.log("Hello!");

  return "Hello!";
};

'''
'''--- package.json ---
{
  "name": "bos-workspace",
  "version": "0.0.1-alpha.0",
  "scripts": {
    "test:tools": "jest tools/lib.test.js",
    "test": "jest",
    "dev": "node tools/dev.js",
    "deploy": "node tools/deploy.js",
    "upload": "node tools/upload.js",
    "pretty": "prettier --write '**/*.{js,jsx,ts,tsx,json,jsonc}'",
    "build": "npm run pretty -- --log-level warn && node tools/build.js",
    "clean": "rm -rf build",
    "near": "near",
    "bos": "bos"
  },
  "devDependencies": {
    "bos-cli": "^0.3.2",
    "chokidar": "^3.5.3",
    "express": "^4.18.2",
    "jest": "^29.6.2",
    "mock-fs": "^5.2.0",
    "near-cli-rs": "^0.4.3",
    "prettier": "^3.0.1"
  }
}

'''
'''--- tools/build.js ---
const { build } = require("./lib.js");

build().catch(console.error);

'''
'''--- tools/deploy.js ---
const { deployCLI } = require("./lib.js");

deployCLI();

'''
'''--- tools/dev.js ---
const { dev } = require("./lib.js");

dev().catch(console.error);

'''
'''--- tools/lib.js ---
const distFolder = process.env.DIST_FOLDER || "build";
const fs = require("fs");
const path = require("path");
const glob = require("glob");
const chokidar = require("chokidar");
const express = require("express");
const { execSync } = require("child_process");
const readline = require("readline");

// read bos.config.json from app folders
function readBosConfig(appFolder) {
  const configPath = path.join("./apps", appFolder, "bos.config.json");
  if (!fs.existsSync(configPath)) {
    throw new Error(`bos.config.json not found in ${appFolder}`);
  }
  const configRaw = fs.readFileSync(configPath);
  try {
    JSON.parse(configRaw);
  } catch (e) {
    throw new Error(`${appFolder}/bos.config.json is not a valid json file`);
  }
  const config = JSON.parse(configRaw);
  if (!config.appAccount) {
    console.warn(
      `WARNING: appAccount not found in ${appFolder}/bos.config.json, build script may work but dev requires it`,
    );
  }
  return config;
}

// process comment commands and replace content in files
function processCommentCommands(fileContent, aliases, appAccount) {
  // Process the aliases
  if (aliases) {
    for (let alias in aliases) {
      let replacePattern = new RegExp(`/\\*__@replace:${alias}__\\*/`, "g");
      fileContent = fileContent.replace(replacePattern, aliases[alias]);
    }
  }

  // Replace the appAccount
  if (appAccount) {
    let accountPattern = /\/\*__@appAccount__\*\//g;
    fileContent = fileContent.replace(accountPattern, appAccount);
  }

  return fileContent;
}

// import modules from /modules folder
function importModules(fileContent) {
  let importPattern = /\/\*__@import:(.+?)__\*\//g;
  let match;

  while ((match = importPattern.exec(fileContent)) !== null) {
    let modulePath = path.join("./modules", `${match[1]}.js`);
    let moduleContent = fs.readFileSync(modulePath, "utf8");
    fileContent = fileContent.replace(match[0], moduleContent);
  }

  return fileContent;
}

// skip files
function shouldSkipFile(fileContent) {
  let skipPattern = /\/\*__@skip__\*\//;
  return skipPattern.test(fileContent);
}

// process each file
function processFile(filePath, aliases, appAccount) {
  let fileContent = fs.readFileSync(filePath, "utf8");

  if (shouldSkipFile(fileContent)) return;

  fileContent = processCommentCommands(fileContent, aliases, appAccount);
  fileContent = importModules(fileContent);

  fs.writeFileSync(filePath, fileContent);
}

// walk through each app folder
function processDistFolder(appFolder) {
  const files = glob.sync(
    `./${distFolder}/${appFolder}/**/*.{js,jsx,ts,tsx,json}`,
  );

  const config = readBosConfig(appFolder);

  files.forEach((file) => processFile(file, config.aliases, config.appAccount));
}

// generate the dist folder structure
function generateDistFolder(appFolder) {
  const distPath = path.join(`./${distFolder}`, appFolder);
  if (fs.existsSync(distPath)) {
    fs.rmSync(distPath, { recursive: true });
  }
  fs.mkdirSync(distPath, { recursive: true });

  const files = glob.sync(`./apps/${appFolder}/widget/**/*.{js,jsx,ts,tsx}`);
  files.forEach((file) => {
    const distFilePath = file
      .replace(appFolder + "/widget", appFolder + "/src")
      .replace("./apps", `./${distFolder}`);
    if (!fs.existsSync(path.dirname(distFilePath))) {
      fs.mkdirSync(path.dirname(distFilePath), { recursive: true });
    }
    fs.copyFileSync(file, distFilePath);
  });
}

// ignore files
function ignoreFiles(fileContent) {
  let ignorePattern = /\/\*__@ignore__\*\//;
  return ignorePattern.test(fileContent);
}

// no stringify json files
// TODO: need tests
function noStringifyJsonFiles(fileContent) {
  let noStringifyPattern = /\/\*__@noStringify__\*\//;
  return noStringifyPattern.test(fileContent);
}

// TODO: need tests
function removeComments(fileContent) {
  return fileContent
    .replace(/\/\*[\s\S]*?\*\/|(?<=[^:])\/\/.*|^\/\/.*/g, "")
    .trim();
}

// generate data.json file
function generateDataJson(appFolder) {
  const data = {};
  const files = glob.sync(`./apps/${appFolder}/**/*.{jsonc,txt}`);
  const config = readBosConfig(appFolder);

  files.forEach((file) => {
    let fileContent = fs.readFileSync(file, "utf8");
    if (ignoreFiles(fileContent)) return;
    if (file.endsWith(".jsonc")) {
      // If it's a JSONC file and has the noStringify marker, parse the content
      // Otherwise, just remove comments and spaces as before
      // first process comment commands
      fileContent = processCommentCommands(
        fileContent,
        config.aliases,
        config.appAccount,
      );
      if (noStringifyJsonFiles(fileContent)) {
        fileContent = JSON.parse(removeComments(fileContent));
      } else {
        fileContent = removeComments(fileContent).replace(/\s/g, ""); // remove comments and spaces
      }
    }
    const keys = file.replace(`./apps/${appFolder}/`, "").split("/");
    // remove file extension
    keys[keys.length - 1] = keys[keys.length - 1]
      .split(".")
      .slice(0, -1)
      .join(".");
    keys.reduce((obj, key, i) => {
      if (i === keys.length - 1) {
        if (typeof fileContent === "object") {
          obj[key] = { ...obj[key], ...fileContent }; // merge if object
        } else {
          obj[key] = fileContent;
        }
      } else {
        if (!obj[key]) obj[key] = {}; // if the key doesn't exist yet, create an object
      }
      return obj[key];
    }, data);
  });

  const dataPath = path.join(`./${distFolder}`, appFolder, "data.json");
  if (!fs.existsSync(dataPath)) {
    fs.mkdirSync(path.dirname(dataPath), { recursive: true });
  }
  fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));
}

// generate the development json from the apps widgets
function generateDevJson(appFolder) {
  let devJson = { components: {}, data: {} };

  const appConfig = readBosConfig(appFolder);
  if (!appConfig.appAccount) {
    return devJson;
  }
  const widgetFiles = glob.sync(
    `./${distFolder}/${appFolder}/src/**/*.{js,jsx,ts,tsx}`,
  );
  const dataJSON = JSON.parse(
    fs.readFileSync(`./${distFolder}/${appFolder}/data.json`, "utf8"),
  );
  devJson.data = { [appConfig.appAccount]: dataJSON };

  widgetFiles.forEach((file) => {
    let fileContent = fs.readFileSync(file, "utf8");
    let widgetPath = file
      .replace(`./${distFolder}/${appFolder}/src/`, "")
      .replace(path.extname(file), "");
    let widgetKey = `${appConfig.appAccount}/widget/${widgetPath
      .split(path.sep)
      .join(".")}`;
    devJson.components[widgetKey] = { code: fileContent };
  });

  return devJson;
}

// watch for changes in the specified folders and run the callback
function watchFolders(folders, callback) {
  const watcher = chokidar.watch(folders, { persistent: true });

  watcher.on("change", (path) => {
    callback(path);
  });
}

// serves the development json
function serveDevJson() {
  const app = express();

  app.use((req, res, next) => {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE,OPTIONS");
    res.header(
      "Access-Control-Allow-Headers",
      "Content-Type, Authorization, Content-Length, X-Requested-With",
    );

    next();
  });

  app.get("/", (req, res) => {
    let devJson = { components: {}, data: {} };
    const appFolders = fs.readdirSync("./apps");

    for (const appFolder of appFolders) {
      let appDevJson = generateDevJson(appFolder);
      devJson.components = { ...devJson.components, ...appDevJson.components };
      devJson.data = { ...devJson.data, ...appDevJson.data };
    }

    res.json(devJson);
  });

  app.listen(4040, "127.0.0.1", () => {
    console.log(
      "\n|--------------------------------------------\\\n|",
      "Server running at " + "http://127.0.0.1:4040/" + "\n|\n|",
      "To use the local widgets, go to " + "https://near.org/flags" + "\n|",
      "and paste the server link above.\n|",
      "--------------------------------------------\\\n",
    );
  });
}

// TODO: need tests
function deployApp(appFolder) {
  const config = readBosConfig(appFolder);
  const appAccount = config.appAccount;

  if (!appAccount) {
    console.error(
      `App account is not defined for ${appFolder}. Skipping deployment.`,
    );
    return;
  }

  const command = `bos components deploy "${appAccount}" sign-as "${appAccount}" network-config mainnet`;

  try {
    execSync(command, {
      cwd: path.join(distFolder, appFolder),
      stdio: "inherit",
    }).toString();
    console.log(`Deployed ${appFolder}`);
  } catch (error) {
    console.error(`Error deploying ${appFolder} widgets:\n${error.message}`);
  }
}

function uploadData(appFolder) {
  const config = readBosConfig(appFolder);
  const appAccount = config.appAccount;

  if (!appAccount) {
    console.error(
      `App account is not defined for ${appFolder}. Skipping data upload.`,
    );
    return;
  }

  const dataJSON = fs.readFileSync(
    path.join(distFolder, appFolder, "data.json"),
    "utf8",
  );
  const args = {
    data: {
      [appAccount]: JSON.parse(dataJSON),
    },
  };

  const argsBase64 = Buffer.from(JSON.stringify(args)).toString("base64");

  const command = `near contract call-function as-transaction social.near set base64-args '${argsBase64}' prepaid-gas '300.000 TeraGas' attached-deposit '0.001 NEAR' sign-as ${appAccount} network-config mainnet`;

  try {
    execSync(command, {
      cwd: path.join(distFolder, appFolder),
      stdio: "inherit",
    }).toString();
    console.log(`Uploaded data for ${appFolder}`);
  } catch (error) {
    console.error(`Error uploading data for ${appFolder}:\n${error.message}`);
  }
}

function appSelectorCLI(callback) {
  const appFolders = fs.readdirSync("./apps");

  // Check if appFolder is provided as a command line argument
  const specifiedAppFolder = process.argv[2];

  if (specifiedAppFolder && appFolders.includes(specifiedAppFolder)) {
    callback(specifiedAppFolder);
    return;
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  console.log("Please select an app:");
  appFolders.forEach((folder, index) => {
    console.log(`${index + 1}. ${folder}`);
  });

  rl.question("Enter the number of the app you want to use: ", (answer) => {
    const appIndex = parseInt(answer, 10) - 1;
    if (appIndex >= 0 && appIndex < appFolders.length) {
      const appFolder = appFolders[appIndex];
      callback(appFolder);
      rl.close();
    } else {
      console.error("Invalid selection. Exiting.");
      rl.close();
    }
  });
}

function deployCLI() {
  appSelectorCLI(deployApp);
}

function uploadDataCLI() {
  appSelectorCLI(uploadData);
}

// Main function to orchestrate the dev script
async function dev() {
  // the first build,
  await build();

  // Start serving the development JSON
  serveDevJson();

  setTimeout(() => {
    console.log("\nWatching for changes in the following folders");
    console.log(["./apps", "./modules"].join("\n"), "\n");
  }, 1000);
  watchFolders(["./apps", "./modules"], async (path) => {
    console.log(`\nChange detected in ${path}`);
    await build();
    console.log("Completed build successfully");
  });
}

// Main function to orchestrate the build script
async function build() {
  const appFolders = fs.readdirSync("./apps");

  for (const appFolder of appFolders) {
    console.log(`Building ${appFolder}...`);
    generateDistFolder(appFolder);
    processDistFolder(appFolder);
    generateDataJson(appFolder);
  }
}

// exports
module.exports = {
  readBosConfig,
  processCommentCommands,
  importModules,
  shouldSkipFile,
  processFile,
  processDistFolder,
  generateDistFolder,
  generateDataJson,
  generateDevJson,
  build,
  dev,
  deployCLI,
  deployApp,
  uploadDataCLI,
  uploadData,
};

'''
'''--- tools/lib.test.js ---
const mockFs = require("mock-fs");
const fs = require("fs");
const DIST_FOLDER = ".__test_dist__";
process.env.DIST_FOLDER = DIST_FOLDER;

const {
  readBosConfig,
  processCommentCommands,
  importModules,
  shouldSkipFile,
  processFile,
  processDistFolder,
  generateDistFolder,
  generateDataJson,
  generateDevJson,
  build,
  dev,
} = require("./lib.js");

// Before each test, set up the mock file system
beforeEach(() => {
  mockFs({
    "./apps/testAppFolder": {
      "bos.config.json": JSON.stringify({
        appAccount: "test",
        aliases: {
          test: "testAlias",
          nui: "nui.near",
        },
      }),
      widget: {
        "test.js":
          'console.log("/*__@replace:test__*/");<Widget src="/*__@replace:nui__*//widget/index" />',
        "skip.js": '/*__@skip__*/console.log("Hello");/*__@replace:nui__*/',
      },
      "test.jsonc": "{}",
      "ignore.jsonc": "/*__@ignore__*/{}",
      "hello.txt": "Hello, World!",
      "donothing.json": "{hi: 1}",
    },
    "./modules": {
      "module1.js": "module1 content",
    },
    ["./" + DIST_FOLDER]: {}, // build folder
  });
});

// After each test, restore the original (real) file system
afterEach(() => {
  jest.clearAllMocks();
  mockFs.restore();
});

// after all tests, delete the build folder
afterAll(() => {
  // if (fs.existsSync(DIST_FOLDER))
  //   fs.rmdirSync(DIST_FOLDER, { recursive: true });
});

describe("readBosConfig", () => {
  it("reads the bos.config.json file correctly", () => {
    const config = readBosConfig("testAppFolder");
    expect(config).toEqual({
      appAccount: "test",
      aliases: { test: "testAlias", nui: "nui.near" },
    });
  });
});

describe("processCommentCommands", () => {
  it("processes the comment commands correctly", () => {
    const aliases = { test: "testAlias" };
    const appAccount = "testAccount";
    const fileContent =
      'console.log("/*__@replace:test__*/"); console.log("/*__@appAccount__*/");';
    const result = processCommentCommands(fileContent, aliases, appAccount);
    expect(result).toEqual(
      'console.log("testAlias"); console.log("testAccount");',
    );
  });

  it("returns original content when no aliases are found", () => {
    const aliases = { test: "testAlias" };
    const appAccount = "testAccount";
    const fileContent = 'console.log("Hello, World!");';
    const result = processCommentCommands(fileContent, aliases, appAccount);
    expect(result).toEqual('console.log("Hello, World!");');
  });
});

describe("importModules", () => {
  it("imports module content correctly", () => {
    const fileContent = 'console.log("/*__@import:module1__*/");';
    const result = importModules(fileContent);
    expect(result).toEqual('console.log("module1 content");');
  });

  it("throws an error when a module does not exist", () => {
    const fileContent = 'console.log("/*__@import:nonexistentModule__*/");';
    expect(() => importModules(fileContent)).toThrow();
  });
});

describe("shouldSkipFile", () => {
  it("identifies files that should be skipped", () => {
    expect(shouldSkipFile('console.log("Hello"); /*__@skip__*/')).toBeTruthy();
    expect(shouldSkipFile('console.log("Hello");')).toBeFalsy();
  });
});

describe("processFile", () => {
  it("processes a file correctly", () => {
    let spy = jest.spyOn(fs, "writeFileSync");
    processFile(
      "./apps/testAppFolder/widget/test.js",
      {
        test: "testAlias",
        nui: "nui.near",
      },
      "testAccount",
    );
    expect(spy).toHaveBeenCalledWith(
      "./apps/testAppFolder/widget/test.js",
      'console.log("testAlias");<Widget src="nui.near/widget/index" />',
    );
  });

  it("does not modify the file when it should be skipped", () => {
    let spy = jest.spyOn(fs, "writeFileSync");
    processFile(
      "./apps/testAppFolder/widget/skip.js",
      {
        test: "testAlias",
        nui: "nui.near",
      },
      "testAccount",
    );
    expect(spy).not.toHaveBeenCalled();
  });
});

describe("processDistFolder", () => {
  it("processes an app folder correctly", async () => {
    const spy = jest.spyOn(fs, "writeFileSync");
    await generateDistFolder("testAppFolder");
    await processDistFolder("testAppFolder");
    expect(spy).toHaveBeenCalledWith(
      `./${DIST_FOLDER}/testAppFolder/src/test.js`,
      'console.log("testAlias");<Widget src="nui.near/widget/index" />',
    );
  });
});

describe("generateDistFolder", () => {
  it("generates the build folder structure correctly", () => {
    const spyc = jest.spyOn(fs, "copyFileSync");
    const spym = jest.spyOn(fs, "mkdirSync");
    generateDistFolder("testAppFolder");
    expect(spym).toHaveBeenCalledWith(DIST_FOLDER + "/testAppFolder", {
      recursive: true,
    });
    expect(spyc.mock.calls).toEqual([
      [
        "./apps/testAppFolder/widget/skip.js",
        "./" + DIST_FOLDER + "/testAppFolder/src/skip.js",
      ],
      [
        "./apps/testAppFolder/widget/test.js",
        "./" + DIST_FOLDER + "/testAppFolder/src/test.js",
      ],
    ]);
  });
});

describe("generateDataJson", () => {
  it("generates data.json file correctly", () => {
    const spy = jest.spyOn(fs, "writeFileSync");
    generateDataJson("testAppFolder");
    expect(spy.mock.calls[0][0]).toBe(DIST_FOLDER + "/testAppFolder/data.json");
    expect(spy.mock.calls[0][1].replace(/\s+/g, "")).toBe(
      '{"hello":"Hello,World!","test":"{}"}',
    );
  });
});

describe("generateDevJson", () => {
  it("generates the development JSON correctly", async () => {
    // mock a nested component
    fs.mkdirSync("./apps/testAppFolder/widget/Layout/Modal", {
      recursive: true,
    });
    fs.writeFileSync(
      "./apps/testAppFolder/widget/Layout/Modal/index.jsx",
      'return console.log("/*__@replace:test__*/");<Widget src="/*__@replace:nui__*//widget/index" />',
    );

    // first, build the app
    await generateDistFolder("testAppFolder");
    await processDistFolder("testAppFolder");
    await generateDataJson("testAppFolder");

    const devJson = generateDevJson("testAppFolder");

    // verify the structure of the devJson
    expect(devJson).toHaveProperty("components");
    expect(devJson).toHaveProperty("data");

    // verify the content of the component file
    expect(devJson.components["test/widget/Layout.Modal.index"].code).toEqual(
      'return console.log("testAlias");<Widget src="nui.near/widget/index" />',
    );
    expect(devJson.data).toEqual({
      test: {
        hello: "Hello, World!",
        test: "{}",
      },
    });
  });
});

// TODO: properly test the dev function
// describe("dev", () => {
//   it("executes the dev script correctly", async () => {
//     await dev();
//     setTimeout(() => {
//       throw "Force dev script to exit";
//     }, 3000);
//   });
// });

describe("build", () => {
  it("executes the build script correctly", async () => {
    const spyw = jest.spyOn(fs, "writeFileSync");
    const spyc = jest.spyOn(fs, "copyFileSync");
    const spym = jest.spyOn(fs, "mkdirSync");

    await build();
    expect(spym).toHaveBeenCalledWith(DIST_FOLDER + "/testAppFolder", {
      recursive: true,
    });
    expect(spyc).toHaveBeenCalledWith(
      "./apps/testAppFolder/widget/test.js",
      `./${DIST_FOLDER}/testAppFolder/src/test.js`,
    );
    expect(spyw).toHaveBeenCalledWith(
      `./${DIST_FOLDER}/testAppFolder/src/test.js`,
      'console.log("testAlias");<Widget src="nui.near/widget/index" />',
    );
    expect(spyw.mock.calls[spyw.mock.calls.length - 1][0]).toBe(
      DIST_FOLDER + "/testAppFolder/data.json",
    );
    expect(
      spyw.mock.calls[spyw.mock.calls.length - 1][1].replace(/\s+/g, ""),
    ).toBe('{"hello":"Hello,World!","test":"{}"}');
  });
});

'''
'''--- tools/upload.js ---
const { uploadDataCLI } = require("./lib.js");

uploadDataCLI();

'''