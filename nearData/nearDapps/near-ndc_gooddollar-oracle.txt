*GitHub Repository "near-ndc/gooddollar-oracle"*

'''--- .clippy.toml ---
msrv = "1.61"

'''
'''--- .github/workflows/rust.yml ---
name: Rust

on:
  pull_request:
    branches: [master, main]
  merge_group:
  push:
    branches: [master, main]

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            contracts/Cargo.lock
      - name: Build
        if: env.GIT_DIFF
        run: cargo build --verbose
      - name: Clippy
        if: env.GIT_DIFF
        run: cargo clippy
      - name: Run tests
        if: env.GIT_DIFF
        run: cargo test --verbose

'''
'''--- Cargo.toml ---
[package]
name = "gooddollar-oracle"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tokio = { version = "1.25.0", features = ["full"] }
axum = {version = "0.6.6", features = ["headers"]}
chrono = "0.4.23"
dotenv = "0.15.0"
tracing = "0.1.37"
tracing-appender = "0.2.2"
tracing-subscriber = { version = "0.3.16", features = ["env-filter", "registry", "json"] }
tower-http = { version = "0.4.0", features = ["cors"] }
config = { version = "0.13.3", default_features = false, features = ["json"] }
log = { version = "0.4", features = ["max_level_debug", "release_max_level_warn"] }
backtrace = "0.3"
hex = "0.4.3"
once_cell = "1.17.1"
secp256k1 = { version = "0.26.0", features = ["global-context", "rand"] }
web3 = "0.18.0"
ethereum-types = "0.14.1"
base64 = "0.21.0"
near-sdk = "4.1.1"
near-crypto = "0.16.0"

[dev_dependencies]
assert_matches = "1.5.0"

'''
'''--- README.md ---
# gooddollar-oracle

GoodDollar oracle for SBT issuer.

## Configuration

All default configuration is available in `config/default.json` file.
To override these settings, create a `config/local.jsom` file.

The GoodDollar identities are whitelisted in the following [contract](https://explorer.fuse.io/address/0x2F9C28de9e6d44b71B91b8BA337A5D82e308E7BE/internal-transactions#address-tabs). We can query the address tab to see if it was whitelisted.
A contract is whitelisted if it passes a Face verification.

### Credentials

Use `near generate-key i-am-human-credentials --networkId mainnet` to generate new credentials.
The above command will create a file `~/.near-credentials/mainnet/i-am-human-credentials.json` with required private key.

The `private_key` property from a resulting file could be either passed with environment variable `SIGNING_KEY` or set via configuration file as:

```
  "signer": {
    "credentials": {
      "signingKey": "{{PUT_PRIVATE_KEY_HERE}}"
    }
  }
```

The public key generated in a file `~/.near-credentials/mainnet/i-am-human-credentials.json` is in wrapped format.
If the ed25519 base64 encoded public key required (e.g. for i-am-human near contract), it could be obtained after service start from
an output (search for text `ED25519 public key (base64 encoded):`)

## Docker

Build docker image
`docker build -t gooddollar-oracle . &`

Prepare registry to be used with docker-compose
`docker run -d -p 5000:5000 --restart=always --name registry registry:2`

Tag previously built docker image
`docker tag gooddollar-oracle:latest localhost:5000/gooddollar-oracle`

Push built tag to registry
`docker push localhost:5000/gooddollar-oracle`

Pull & run docker image using docker-compose
`docker-compose pull && docker-compose --compatibility up -d`

'''
'''--- config/default.json ---
{
  "listenAddress": "0.0.0.0:8080",
  "verificationProvider": {
      "url": "https://rpc.fuse.io/",
      "identityContractAddress": "2F9C28de9e6d44b71B91b8BA337A5D82e308E7BE"
  },
  "signer": {
    "credentials": null
  }
}
'''
'''--- docker-compose.yml ---
version: "3.5"
services:
  gooddollar-oracle:
    image: localhost:5000/gooddollar-oracle
    restart: always
    command:
      - ./gooddollar-oracle
    ports:
      - 80:8080
    extra_hosts: []
    volumes:
      - type: bind
        source: /root/Projects/gooddollar-oracle/config/default.json
        target: /app/config/default.json
      - type: bind
        source: /root/Projects/gooddollar-oracle/config/local.json
        target: /app/config/local.json
    deploy:
      resources:
        limits:
          memory: 1000M
    environment:
      RUST_LOG: debug
    init: false

'''
'''--- interfaces/Identity.json ---
[
  {
    "inputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "BlacklistAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "BlacklistRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "ContractAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "ContractRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "IdentityAdminAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "IdentityAdminRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "PauserAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "PauserRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "WhitelistedAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "WhitelistedRemoved",
    "type": "event"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "addBlacklisted",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "addContract",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "addIdentityAdmin",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "addPauser",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "addWhitelisted",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "did",
        "type": "string"
      }
    ],
    "name": "addWhitelistedWithDID",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "addrToDID",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "authenticate",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "authenticationPeriod",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "dateAdded",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "dateAuthenticated",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "didHashToAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "isBlacklisted",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "isDAOContract",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "isIdentityAdmin",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "isOwner",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "isPauser",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "isRegistered",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "scheme",
        "type": "address"
      }
    ],
    "name": "isRegistered",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "isWhitelisted",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "lastAuthenticated",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "pause",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "paused",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "removeBlacklisted",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "removeContract",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "removeIdentityAdmin",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "removeWhitelisted",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "renounceIdentityAdmin",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "renouncePauser",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "renounceWhitelisted",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "uint256",
        "name": "period",
        "type": "uint256"
      }
    ],
    "name": "setAuthenticationPeriod",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "contract Avatar",
        "name": "_avatar",
        "type": "address"
      }
    ],
    "name": "setAvatar",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "unpause",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "whitelistedContracts",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "whitelistedCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]
'''
'''--- src/config.rs ---
use crate::signer::SignerConfig;
use crate::verification_provider::VerificationProviderConfig;
use config::{self, ConfigError};
use near_sdk::serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct AppConfig {
    pub listen_address: String,
    pub verification_provider: VerificationProviderConfig,
    pub signer: SignerConfig,
}

pub fn load_config() -> Result<AppConfig, ConfigError> {
    config::Config::builder()
        // Load default set of configuration
        .add_source(config::File::with_name("config/default"))
        // Overlay configuration with local configuration
        .add_source(config::File::with_name("config/local").required(false))
        .build()
        .and_then(|config| config.try_deserialize())
}

'''
'''--- src/error.rs ---
use axum::{http::StatusCode, response::IntoResponse, Json};
use near_sdk::serde_json::json;

#[derive(Debug)]
pub enum AppError {
    TransportProtocolError,
    SigningError,
    SignatureInvalid,
    UserAddressInvalid,
    UserNotVerified,
    UserAlreadyRegistered,
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, err_msg) = match self {
            Self::TransportProtocolError | Self::SigningError => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error")
            }
            Self::UserAddressInvalid => (StatusCode::BAD_REQUEST, "Invalid user address"),
            Self::SignatureInvalid => (StatusCode::BAD_REQUEST, "Invalid signature"),
            Self::UserNotVerified => (StatusCode::UNAUTHORIZED, "User didn't pass verification"),
            Self::UserAlreadyRegistered => (StatusCode::BAD_REQUEST, "User already registered"),
        };
        (status, Json(json!({ "error": err_msg }))).into_response()
    }
}

'''
'''--- src/main.rs ---
mod config;
mod error;
mod signer;
mod utils;
mod verification_provider;

use axum::{extract::State, routing::post, Json, Router};
use base64::{engine::general_purpose, Engine};
use chrono::Utc;
use error::AppError;
use hex::ToHex;
use near_crypto::Signature;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::str::FromStr;
use tower_http::cors::CorsLayer;
use web3::signing::{hash_message, recover};
use web3::types::Address;

use crate::config::AppConfig;
use utils::{enable_logging, parse_hex_signature, set_heavy_panic};
use verification_provider::FuseClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Exit on any panic in any async task
    set_heavy_panic();

    // Try load environment variables from `.env` if provided
    dotenv::dotenv().ok();

    enable_logging();
    let config = config::load_config()?;

    // Log a base64 encoded ed25519 public key to be used in smart contract for signature verification
    tracing::info!(
        "ED25519 public key (base64 encoded): {}",
        general_purpose::STANDARD.encode(
            config
                .signer
                .credentials
                .signing_key
                .public_key()
                .unwrap_as_ed25519()
                .as_ref()
        )
    );

    let addr = config
        .listen_address
        .parse()
        .expect("Can't parse socket address");

    let state = AppState::new(
        config.clone(),
        config.verification_provider.identity_contract_address,
    )?;

    let app = Router::new()
        .route("/verify", post(verify))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::debug!("Server listening on {}", addr);

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}

#[derive(Clone)]
pub struct AppState {
    pub config: AppConfig,
    pub client: FuseClient,
}

impl AppState {
    pub fn new(
        config: AppConfig,
        contract_addr: Address,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let web3 = web3::Web3::new(web3::transports::Http::new(
            &config.verification_provider.url,
        )?);

        Ok(Self {
            config,
            client: FuseClient::create(&web3, contract_addr.to_owned())?,
        })
    }
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VerificationReq {
    #[serde(rename = "m")]
    pub message: String,
    #[serde(rename = "c")]
    pub claimer: AccountId,
    #[serde(rename = "sig")]
    pub signature: String,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct User {
    #[serde(rename = "a")]
    pub account: Account,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub value: String,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct VerifiedAccountToken {
    pub claimer: AccountId,
    pub ext_account: String,
    pub timestamp: u64,
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct SignedResponse {
    #[serde(rename = "m")]
    pub message: String,
    #[serde(rename = "sig")]
    pub signature_ed25519: String,
}

pub async fn verify(
    State(state): State<AppState>,
    Json(req): Json<VerificationReq>,
) -> Result<Json<SignedResponse>, AppError> {
    tracing::debug!("Req: {:?}", req);

    let raw_signature =
        parse_hex_signature::<[u8; 65]>(&req.signature).map_err(|_| AppError::SignatureInvalid)?;
    let raw_message = req.message.as_bytes();

    // TODO: verify nonce

    let user = near_sdk::serde_json::from_str::<User>(&req.message)
        .map_err(|_| AppError::SignatureInvalid)?;

    let account_addr =
        Address::from_str(&user.account.value).map_err(|_| AppError::UserAddressInvalid)?;

    let recovered_ext_account = recover(
        hash_message(raw_message).as_bytes(),
        &raw_signature[..64],
        raw_signature[64] as i32 - 27,
    )
    .map(|account| ["0x", &account.as_bytes().encode_hex::<String>()].concat())
    .map_err(|_| AppError::SignatureInvalid)?;

    tracing::debug!(
        "User account address to verify: {:?}",
        recovered_ext_account
    );

    if recovered_ext_account != user.account.value.to_lowercase() {
        return Err(AppError::SignatureInvalid);
    }

    match state.client.is_whitelisted(account_addr).await {
        // Account is verified
        Ok(true) => {
            create_verified_account_response(&state.config, req.claimer, recovered_ext_account)
        }
        // Account is not verified
        Ok(false) => Err(AppError::UserNotVerified),
        // Any contract failure
        Err(_) => Err(AppError::TransportProtocolError),
    }
}

/// Creates signed json response with verified account
fn create_verified_account_response(
    config: &AppConfig,
    claimer: AccountId,
    ext_account: String,
) -> Result<Json<SignedResponse>, AppError> {
    let credentials = &config.signer.credentials;
    let raw_message = VerifiedAccountToken {
        claimer,
        ext_account,
        timestamp: Utc::now().timestamp() as u64,
    }
    .try_to_vec()
    .map_err(|_| AppError::SigningError)?;
    let signature = credentials.signing_key.sign(&raw_message);

    if !signature.verify(&raw_message, &credentials.signing_key.public_key()) {
        return Err(AppError::SigningError);
    }

    let raw_signature_ed25519 = match signature {
        Signature::ED25519(signature) => signature.to_bytes(),
        _ => return Err(AppError::SigningError),
    };

    let message = general_purpose::STANDARD.encode(&raw_message);
    let signature_ed25519 = general_purpose::STANDARD.encode(raw_signature_ed25519);

    Ok(Json(SignedResponse {
        message,
        signature_ed25519,
    }))
}

#[cfg(test)]
mod tests {
    use crate::signer::{SignerConfig, SignerCredentials};
    use crate::{
        create_verified_account_response, AppConfig, User, VerificationReq, VerifiedAccountToken,
    };
    use assert_matches::assert_matches;
    use base64::{engine::general_purpose, Engine};
    use near_crypto::{KeyType, Signature};
    use near_sdk::borsh::BorshDeserialize;
    use near_sdk::AccountId;

    #[test]
    fn test_verification_req_parser() {
        let req = near_sdk::serde_json::from_str::<VerificationReq>(r#"{"m":"{\"I\":{\"value\":\"Ukraine\",\"attestation\":\"\"},\"n\":{\"value\":\"Oleksandr Molotsylo\",\"attestation\":\"\"},\"e\":{\"value\":\"motzart66@gmail.com\",\"attestation\":\"\"},\"m\":{\"value\":\"\",\"attestation\":\"\"},\"a\":{\"value\":\"0xd6Bd36ce6f5e53da4eb7f83522441008F3A8644c\",\"attestation\":\"\"},\"v\":{\"value\":false,\"attestation\":\"\"},\"nonce\":{\"value\":1676466734313,\"attestation\":\"\"}}","c":"test.near","sig":"0x6cc861240b8f90f06ea519a536ceda0df7507518e87d3de13cfdeabc600dea531562a6fb8c8beba80d8b87384898679176df0a514be116d7c6c3c47a628e7d161b"}"#).unwrap();

        let _ = near_sdk::serde_json::from_str::<User>(&req.message).unwrap();
    }

    #[test]
    fn test_create_verified_account_response() {
        let signing_key = near_crypto::SecretKey::from_random(near_crypto::KeyType::ED25519);
        let config = AppConfig {
            signer: SignerConfig {
                credentials: SignerCredentials { signing_key },
            },
            listen_address: "0.0.0.0:8080".to_owned(),
            verification_provider: Default::default(),
        };

        let claimer = AccountId::new_unchecked("test.near".to_owned());
        let ext_account = "test".to_owned();
        let res = create_verified_account_response(&config, claimer.clone(), ext_account.clone())
            .unwrap();

        let credentials = &config.signer.credentials;

        let decoded_bytes = general_purpose::STANDARD.decode(&res.message).unwrap();

        assert!(Signature::from_parts(
            KeyType::ED25519,
            &general_purpose::STANDARD
                .decode(&res.signature_ed25519)
                .unwrap()
        )
        .unwrap()
        .verify(&decoded_bytes, &credentials.signing_key.public_key()));

        let decoded_msg = VerifiedAccountToken::try_from_slice(&decoded_bytes).unwrap();

        assert_matches!(decoded_msg, VerifiedAccountToken {
            claimer: claimer_res,
            ext_account: ext_account_res,
            timestamp: _
        } if claimer_res == claimer && ext_account_res == ext_account);
    }
}

'''
'''--- src/signer.rs ---
use near_crypto::SecretKey;
use near_sdk::serde::de::{self, Error};
use near_sdk::serde::Deserialize;
use std::{env::VarError, str::FromStr};

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct SignerConfig {
    pub credentials: SignerCredentials,
}

#[derive(Debug, Clone)]
pub struct SignerCredentials {
    pub signing_key: SecretKey,
}

impl<'de> Deserialize<'de> for SignerCredentials {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let properties: std::collections::HashMap<String, String> =
            Deserialize::deserialize(deserializer).unwrap_or_default();

        let raw_signing_key = match std::env::var("SIGNING_KEY") {
          Err(VarError::NotPresent) => properties.get("signingKey").cloned(),
          Err(VarError::NotUnicode(invalid_data)) => {
              return Err(de::Error::custom(format!("Invalid SIGNING_KEY {:?}", invalid_data)))
          },
          Ok(value) => Some(value),
        }.ok_or_else(|| {
            D::Error::custom("Signing key should be provided either with SIGNING_KEY env variable or within configuration file")
        })?;

        let signing_key = SecretKey::from_str(&raw_signing_key).map_err(|e| {
            de::Error::custom(format!("Signing key deserialization failure. Error {e}"))
        })?;

        if !verify_signing_key(&signing_key) {
            return Err(de::Error::custom("Signing key is incorrect"));
        }

        Ok(Self { signing_key })
    }
}

fn verify_signing_key(signing_key: &SecretKey) -> bool {
    let verification_data = "verify".as_bytes();
    let sig = signing_key.sign(verification_data);
    sig.verify(verification_data, &signing_key.public_key())
}

'''
'''--- src/utils.rs ---
use backtrace::Backtrace;
use hex::FromHex;
use std::{panic, thread};
use tracing_subscriber::prelude::*;
use tracing_subscriber::{fmt, EnvFilter, Registry};

pub fn set_heavy_panic() {
    panic::set_hook(Box::new(|panic_info| {
        let backtrace = Backtrace::new();

        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            log::error!("Panic occurred: {:?}", s);
        }

        // Get code location
        let location = panic_info.location().unwrap();

        // Extract msg
        let msg = match panic_info.payload().downcast_ref::<&'static str>() {
            Some(s) => *s,
            None => match panic_info.payload().downcast_ref::<String>() {
                Some(s) => &s[..],
                None => "Box<Any>",
            },
        };

        let handle = thread::current();
        let thread_name = handle.name().unwrap_or("<unnamed>");

        log::error!(
            "thread '{}' panicked at '{}', {}",
            thread_name,
            location,
            msg
        );

        log::error!("{:?}", backtrace);

        std::process::exit(1)
    }));
}

/// Enables console logging and optionally file logging
pub fn enable_logging() {
    // Setup subscriber to print out logs from tracing
    let subscriber = Registry::default().with(
        fmt::Layer::default()
            // disable colored output
            .with_ansi(false)
            // Write to console
            .with_writer(std::io::stdout)
            // Filter messages based on RUST_LOG env variable
            .with_filter(EnvFilter::from_default_env()),
    );

    tracing::subscriber::set_global_default(subscriber).unwrap();
}

pub fn parse_hex_signature<T>(hex_text: &str) -> Result<T, hex::FromHexError>
where
    T: FromHex<Error = hex::FromHexError>,
{
    let hex_text = hex_text.strip_prefix("0x").unwrap_or(hex_text);

    <T>::from_hex(hex_text)
}

'''
'''--- src/verification_provider.rs ---
use web3::{
    contract::{self, Contract, Options},
    ethabi,
    transports::Http,
    types::Address,
    Web3,
};

use near_sdk::serde::Deserialize;

#[derive(Deserialize, Debug, Default, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct VerificationProviderConfig {
    pub url: String,
    /// GoodDollar Identity contract address used to verify whitelisted users
    /// See more <https://github.com/GoodDollar/GoodProtocol/blob/master/releases/deployment.json>
    pub identity_contract_address: Address,
}

#[derive(Clone, Debug)]
pub struct FuseClient {
    contract: Contract<Http>,
}

impl FuseClient {
    pub fn create(web3: &Web3<Http>, address: Address) -> Result<Self, ethabi::Error> {
        let contract = Contract::from_json(
            web3.eth(),
            address,
            include_bytes!("../interfaces/Identity.json"),
        )?;

        Ok(Self { contract })
    }

    pub async fn is_whitelisted(&self, account: Address) -> contract::Result<bool> {
        self.contract
            .query("isWhitelisted", (account,), None, Options::default(), None)
            .await
    }
}

'''