*GitHub Repository "lhtvikaschauhan/rust-cross-contracts"*

'''--- README.md ---
# Donation in RUST

An example contract writen in RUST

'''
'''--- contract/Cargo.toml ---
[package]
name = "donation_contract"
version = "1.0.0"
authors = ["Guillermo Gallardo <guillermo@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.8.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/README.md ---
Donation Smart Contract
=======================

A [smart contract] written in [RUST] 

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile
   by running `cargo build`.
2. Tests: You can run smart contract tests by doing `cargo test`.

  [smart contract]: https://docs.near.org/
  [RUST]: https://doc.rust-lang.org/book/title-page.html
'''
'''--- contract/src/external.rs ---
use near_sdk::{env, ext_contract, log, PromiseResult};

pub const TGAS: u64 = 1_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

// Interface of this contract, for callbacks
#[ext_contract(this_contract)]
trait Callbacks {
  fn query_greeting_callback(&mut self) -> String;
  fn change_greeting_callback(&mut self) -> bool;
}

// Validator interface, for cross-contract calls
#[ext_contract(hello_near)]
trait HelloNear {
  #[payable]
  fn get_greeting(&mut self) -> String;
  fn set_greeting(&self, message: String);
}

// Aux functions to interact with the validator
pub fn did_promise_succeed() -> bool {
  if env::promise_results_count() != 1 {
    log!("Expected a result on the callback");
    return false;
  }

  match env::promise_result(0) {
    PromiseResult::Successful(_) => true,
    _ => false,
  }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Gas, Promise, PromiseResult, PanicOnDefault};

pub mod external;
pub use crate::external::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  pub hello_account: AccountId
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn new(hello_account: AccountId) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    Self {
      hello_account,
    }
  }

  // Public - query external greeting
  pub fn query_greeting(&self) -> Promise {
    // Create a promise to call HelloNEAR.get_greeting()
    let promise = hello_near::ext(self.hello_account.clone())
      .with_static_gas(Gas(5*TGAS))
      .get_greeting();
    
    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(5*TGAS))
      .query_greeting_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn query_greeting_callback(&self) -> String {
    // Check if the promise succeeded by calling the method outlined in external.rs
    if !did_promise_succeed() {
      log!("There was an error contacting Hello NEAR");
      return "".to_string();
    }

    // Get response, return "" if failed
    let greeting: String = match env::promise_result(0) {
      PromiseResult::Successful(value) => near_sdk::serde_json::from_slice::<String>(&value).unwrap(),
      _ => { log!("There was an error contacting Hello NEAR"); return "".to_string(); },
    };

    // Return the greeting
    greeting
  }

  // Public - change external greeting
  pub fn change_greeting(&mut self, new_greeting: String) -> Promise {
    // Create a promise to call HelloNEAR.set_greeting(message:string)
    hello_near::ext(self.hello_account.clone())
      .with_static_gas(Gas(5*TGAS))
      .set_greeting(new_greeting)
    .then( // Create a callback change_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(5*TGAS))
      .change_greeting_callback()
    )
  }

  #[private]
  pub fn change_greeting_callback(&mut self) -> bool {
    // Return whether or not the promise succeeded using the method outlined in external.rs
    if did_promise_succeed() {
      env::log_str("Promise was successful!");
      // `set_greeting` succeeded
      return true;
    } else {
      env::log_str("Promise failed...");
      // it failed
      return false;
    }
  }
}

#[cfg(test)]
mod tests {
    use super::*;

    const HELLO_NEAR: &str = "beneficiary";

    #[test]
    fn initializes() {
        let beneficiary: AccountId = HELLO_NEAR.parse().unwrap();
        let contract = Contract::new(beneficiary);
        assert_eq!(contract.hello_account, HELLO_NEAR.parse().unwrap())
    }
}

'''
'''--- package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "npm run build && cd contract && cargo test && cd .. && jest test --runInBand",
    "jest": "npm run build && jest test --runInBand",
    "build": "npm run build:rustup && npm run build:cpwasm",
      "build:rustup": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
      "build:cpwasm": "mkdir -p out && rm -f ./out/main.wasm && cp ./contract/target/wasm32-unknown-unknown/release/donation_contract.wasm ./out/main.wasm",
    "deploy": "npm run build && near dev-deploy"
  },
  "devDependencies": {
    "env-cmd": "~10.1.0",
    "jest": "~27.5.1",
    "jest-environment-node": "~27.5.1",
    "near-cli": "~3.2.0"
  },
  "dependencies": {
    "near-api-js": "^0.44.2"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- test/cross-hello.test.js ---
const { Near, Account, Contract } = nearAPI;
const { deploy_contract } = require('./near_wrapper')

describe('Cross-contract Greetings', function () {
  let contract
  const hello_address = `hello.${nearConfig.contractName}`

  jest.setTimeout(1200000);

  beforeAll(async function () {
    // Deploy hello-near contract
    await deploy_contract(hello_address, `${__dirname}/aux_contracts/hello-near.wasm`)

    // Connect to our contract
    const near = await new Near(nearConfig);
    const user = await new Account(near.connection, nearConfig.contractName);
    contract = await new Contract(
      user,
      nearConfig.contractName,
      { viewMethods: [], changeMethods: ["new", "query_greeting", "change_greeting"] });
  });

  describe('Cross-contract Greetings', function () {
    it("Initializes", async () => {
      await contract.new({args: {hello_account: hello_address}})
    })
    it("returns the default greeting", async () => {
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Hello");
    });
    it("should change the greeting", async () => {
      await contract.change_greeting({ args: { new_greeting: "Howdy" } });
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Howdy");
    });
  });
});
'''
'''--- test/near_wrapper.js ---
// Functions to interact with the NEAR network
const { keyStores: { InMemoryKeyStore }, Near, KeyPair, Account,
				Contract, utils: {format: { parseNearAmount, formatNearAmount } }, transactions: { deployContract } } = nearAPI
const BN = require('bn.js')
const fs = require("fs")

// Load credentials
const credPath = `./neardev/${nearConfig.networkId}/${nearConfig.contractName}.json`

let credentials
try {
	credentials = JSON.parse(fs.readFileSync(credPath));
} catch(e) {
	console.warn(e)
	/// attempt to load backup creds from local machine
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${nearConfig.networkId}/${nearConfig.contractName}.json`
		)
	);
}

// Create an InMemoryKeyStore
const keyStore = new InMemoryKeyStore();

keyStore.setKey(
	nearConfig.networkId,
	nearConfig.contractName,
	KeyPair.fromString(credentials.private_key)
);

// Connect to the NEAR blockchain
const near = new Near({
	networkId: nearConfig.networkId, nodeUrl:nearConfig.nodeUrl, deps: { keyStore } 
});

// Aux function to create accounts
const DEFAULT_NEW_ACCOUNT_AMOUNT = "20"

async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(near.connection, nearConfig.contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(nearConfig.networkId, accountId, newKeyPair);
	return new Account(near.connection, accountId);
}

// Get the account or create it if it doesn't exists
async function getOrCreateAccount(accountId) {
	// accountId must be with `${something}.${contractName}`
	const account = new Account(near.connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId);
};

// Create Contract
async function create_contract(accountId, viewMethods, changeMethods, contractId){
	let account = await getOrCreateAccount(accountId)
	const contractMethods = { viewMethods, changeMethods };
	return new Contract(account, contractId || nearConfig.contractName, contractMethods);
}

wallet_balance = async function (account_id) {
	let account = await near.account(account_id)
	let balance = await account.getAccountBalance()

	balance.total = parseFloat(formatNearAmount(balance.total))
	balance.available = parseFloat(formatNearAmount(balance.available))

	return balance
}

async function deploy_contract(accountId, filePath){
	const validator = await getOrCreateAccount(accountId)
	const validatorContractBytes = fs.readFileSync(filePath);

	await validator.signAndSendTransaction({
		receiverId: accountId,
		actions: [deployContract(validatorContractBytes)]
	});
}

module.exports = {create_contract, wallet_balance, deploy_contract}
'''