*GitHub Repository "nearvndev/counter-tutorial-rs"*

'''--- Cargo.toml ---
[package]
name = "counter"
version = "0.1.0"
authors = ["NEAR Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
Counter Contract Tutorial
===================

This repository include a example implementaion of Rust contract with NEAR-SDK, a contract which use basic contract, versioned and upgradeable contract

Prerequisites
=============
If you're using Gitpod, you can skip this step.

  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `out/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```bash
./build.sh
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.
```bash
cargo test -- --nocapture
```
The more complex simulation tests aren't run with this command, but we can find them in `tests/sim`.

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/docs/concepts/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile out/counter-tutorial.wasm
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to set the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new --accountId $ACCOUNT_NAME
```

To view the number in contract:

```bash
near view $CONTRACT_NAME get_num
```

To increment number

```bash
near call $CONTRACT_NAME increment --accountId $ACCOUNT_NAME
```

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/counter-tutorial.wasm
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1648266537391-59234553215446
'''
'''--- src/lib.rs ---
// Counter smart contract workshop
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde::{Serialize, Deserialize};
use near_sdk::{near_bindgen, AccountId, env, BorshStorageKey, PanicOnDefault, BlockHeight};

#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct OldCounter {
    value: u8,
    new_value: u8
}

#[derive(BorshSerialize, BorshDeserialize, Default, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountV1 {
    vote: u8,
    balance: u8
}

#[derive(BorshSerialize, BorshDeserialize, Default, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountV2 {
    vote: u8,
    balance: u8,
    bio: String
}

#[derive(BorshSerialize, BorshDeserialize, Default, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    vote: u8,
    balance: u8,
    bio: String,
    last_change: BlockHeight
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedAccount {
    V1(AccountV1),
    V2(AccountV2),
    Current(Account)
}

impl From<VersionedAccount> for Account {
    fn from(account: VersionedAccount) -> Self {
        match account {
            VersionedAccount::Current(account) => account,
            VersionedAccount::V1(v1) => Account {
                vote: v1.vote,
                balance: v1.balance,
                bio: String::from("migrate bio"),
                last_change: 0
            },
            VersionedAccount::V2(v2) => Account {
                vote: v2.vote,
                balance: v2.balance,
                bio: v2.bio,
                last_change: 0
            }
        }
    }
}

impl From<Account> for VersionedAccount {
    fn from(account: Account) -> Self {
        VersionedAccount::Current(account)
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Counter {
    value: u8,
    new_value: u8,
    accounts: LookupMap<AccountId, VersionedAccount>
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    AccountKey
}

#[near_bindgen]
impl Counter {

    #[init]
    pub fn new() -> Self {
        Counter { 
            value: 0, 
            new_value: 0,
            accounts: LookupMap::new(StorageKey::AccountKey)
        }
    }

    pub fn get_num(&self) -> u8 {
        self.value
    }

    pub fn get_new_num(&self) -> u8 {
        self.new_value
    }

    #[payable]
    pub fn set_num(&mut self, new_value: u8) {
        self.value = new_value;
    }

    pub fn increment(&mut self) {
        self.value += 1;
    }

    pub fn get_account(&self, account_id: AccountId) -> Account {
        let v_account = self.accounts.get(&account_id).unwrap();

        Account::from(v_account)
    }

    pub fn add_account(&mut self) {
        let v_account = self.accounts.get(&env::predecessor_account_id());

        if v_account.is_none() {
            let account = Account::default();
            let v_account = VersionedAccount::from(account);
            self.accounts.insert(&env::predecessor_account_id(), &v_account);
        }
    }

    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        let old_counter: OldCounter = env::state_read().expect("Can not read state");

        Counter { 
            value: old_counter.value, 
            new_value: 0,
            accounts: LookupMap::new(StorageKey::AccountKey)
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::{MockedBlockchain, VMContext};
    use near_sdk::{testing_env};

    use super::*;

    fn john() -> AccountId {
        return "john.testnet".to_string();
    }

    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "jane.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn test_num() {
        let context = get_context(john(), 0);
        testing_env!(context);

        let mut contract = Counter::new();
        let number_before = contract.get_num();
        assert_eq!(0, number_before, "Expected num should be zero");
        contract.set_num(1);

        let number_after = contract.get_num();
        assert_eq!(1, number_after, "Expected two values are the same");

        contract.increment();
        let number_after_increment = contract.get_num();
        assert_eq!(2, number_after_increment, "Expected after increment should be 2");
    }
  }
'''
'''--- tests/sim/main.rs ---
use near_sdk_sim::{init_simulator, UserAccount, ContractAccount, deploy, call, view};
use counter::CounterContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    COUNTER_BYTES => "out/counter-tutorial.wasm",
}

const CONTRACT_ID: &str = "counter_contract";

pub fn init() -> (UserAccount, ContractAccount<CounterContract>) {
    let root = init_simulator(None);

    let counter_countract: ContractAccount<CounterContract> = deploy!(
        contract: CounterContract,
        contract_id: CONTRACT_ID.to_string(),
        bytes: &COUNTER_BYTES,
        signer_account: root,
        init_method: new()
    );

    (root, counter_countract)
}

#[test]
pub fn counter_test() {
    let (root, counter_contract) = init();

    let num: u8 = view!(
        counter_contract.get_num()
    ).unwrap_json();

    assert_eq!(num, 0, "Initial number must be equal zero");

    call!(
        root,
        counter_contract.increment()
    ).assert_success();

    let new_num: u8 = view!(
        counter_contract.get_num()
    ).unwrap_json();

    assert_eq!(new_num, 1, "Increase number from zero to 1");
}
'''