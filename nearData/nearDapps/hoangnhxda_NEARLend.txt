*GitHub Repository "hoangnhxda/NEARLend"*

'''--- .github/workflows/firebase-hosting-merge.yml ---
# This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools

name: Deploy to Firebase Hosting on merge
'on':
  push:
    branches:
      - testnet
jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_NEARLEND }}'
          channelId: live
          projectId: nearlend

'''
'''--- .github/workflows/firebase-hosting-pull-request.yml ---
# This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools

name: Deploy to Firebase Hosting on PR
'on': pull_request
jobs:
  build_and_preview:
    if: '${{ github.event.pull_request.head.repo.full_name == github.repository }}'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT_NEARLEND }}'
          projectId: nearlend

'''
'''--- README.md ---
# NEARLend

function getBorrowRate(uint cash, uint borrows, uint reserves);

function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa);

function transferTokens(address spender, address src, address dst, uint tokens);

function repayBorrowInternal(uint repayAmount);

function doTransferIn(address from, uint amount);

function doTransferOut(address payable to, uint amount);

'''
'''--- backend/expressjs/app.js ---
var createError = require('http-errors');
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var indexRouter = require('./routes/index');
var usersRouter = require('./routes/users');
var priceRouter = require('./routes/getprice');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', indexRouter);
app.use('/users', usersRouter);
app.use('/getprice', priceRouter);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;

'''
'''--- backend/expressjs/package-lock.json ---
{
  "name": "nearlend-backend",
  "version": "0.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "nearlend-backend",
      "version": "0.0.0",
      "dependencies": {
        "axios": "^0.24.0",
        "cookie-parser": "~1.4.4",
        "debug": "~2.6.9",
        "ejs": "~2.6.1",
        "express": "~4.16.1",
        "http-errors": "~1.6.3",
        "morgan": "~1.9.1"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.7",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.7.tgz",
      "integrity": "sha512-Il80Qs2WjYlJIBNzNkK6KYqlVMTbZLXgHx2oT0pU/fjRHyEp+PEfEPY0R3WCwAGVOtauxh1hOxNgIf5bv7dQpA==",
      "dependencies": {
        "mime-types": "~2.1.24",
        "negotiator": "0.6.2"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha1-ml9pkFGx5wczKPKgCJaLZOopVdI="
    },
    "node_modules/axios": {
      "version": "0.24.0",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.24.0.tgz",
      "integrity": "sha512-Q6cWsys88HoPgAaFAVUb0WpPk0O8iTeisR9IMqy9G8AbO4NlpVknrnQS03zzF9PGAWgO3cgletO3VjV/P7VztA==",
      "dependencies": {
        "follow-redirects": "^1.14.4"
      }
    },
    "node_modules/basic-auth": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/basic-auth/-/basic-auth-2.0.1.tgz",
      "integrity": "sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==",
      "dependencies": {
        "safe-buffer": "5.1.2"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/body-parser": {
      "version": "1.18.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.18.3.tgz",
      "integrity": "sha1-WykhmP/dVTs6DyDe0FkrlWlVyLQ=",
      "dependencies": {
        "bytes": "3.0.0",
        "content-type": "~1.0.4",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "http-errors": "~1.6.3",
        "iconv-lite": "0.4.23",
        "on-finished": "~2.3.0",
        "qs": "6.5.2",
        "raw-body": "2.3.3",
        "type-is": "~1.6.16"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/bytes": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.0.0.tgz",
      "integrity": "sha1-0ygVQE1olpn4Wk6k+odV3ROpYEg=",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/content-disposition": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.2.tgz",
      "integrity": "sha1-DPaLud318r55YcOoUXjLhdunjLQ=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
      "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.1.tgz",
      "integrity": "sha512-ZwrFkGJxUR3EIoXtO+yVE69Eb7KlixbaeAWfBQB9vVsNn/o+Yw69gBWSSDK825hQNdN+wF8zELf3dFNl/kxkUA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-parser": {
      "version": "1.4.6",
      "resolved": "https://registry.npmjs.org/cookie-parser/-/cookie-parser-1.4.6.tgz",
      "integrity": "sha512-z3IzaNjdwUC2olLIB5/ITd0/setiaFMLYiZJle7xg5Fe9KWAceil7xszYfHHBtDFYLSgJduS2Ty0P1uJdPDJeA==",
      "dependencies": {
        "cookie": "0.4.1",
        "cookie-signature": "1.0.6"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha1-4wOogrNCzD7oylE6eZmXNNqzriw="
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/destroy": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.0.4.tgz",
      "integrity": "sha1-l4hXRCxEdJ5CBmE+N5RiBYJqvYA="
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0="
    },
    "node_modules/ejs": {
      "version": "2.6.2",
      "resolved": "https://registry.npmjs.org/ejs/-/ejs-2.6.2.tgz",
      "integrity": "sha512-PcW2a0tyTuPHz3tWyYqtK6r1fZ3gp+3Sop8Ph+ZYN81Ob5rwmbHEzaqs10N3BEsaGTkh/ooniXK+WwszGlc2+Q==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k=",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg="
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha1-Qa4u62XvpiJorr/qg6x9eSmbCIc=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.16.4",
      "resolved": "https://registry.npmjs.org/express/-/express-4.16.4.tgz",
      "integrity": "sha512-j12Uuyb4FMrd/qQAm6uCHAkPtO8FDTRJZBDd5D2KOL2eLaz1yUNdUB/NOIyq0iU4q4cFarsUCrnFDPBcnksuOg==",
      "dependencies": {
        "accepts": "~1.3.5",
        "array-flatten": "1.1.1",
        "body-parser": "1.18.3",
        "content-disposition": "0.5.2",
        "content-type": "~1.0.4",
        "cookie": "0.3.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.1.1",
        "fresh": "0.5.2",
        "merge-descriptors": "1.0.1",
        "methods": "~1.1.2",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.2",
        "path-to-regexp": "0.1.7",
        "proxy-addr": "~2.0.4",
        "qs": "6.5.2",
        "range-parser": "~1.2.0",
        "safe-buffer": "5.1.2",
        "send": "0.16.2",
        "serve-static": "1.13.2",
        "setprototypeof": "1.1.0",
        "statuses": "~1.4.0",
        "type-is": "~1.6.16",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      }
    },
    "node_modules/express/node_modules/cookie": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.3.1.tgz",
      "integrity": "sha1-5+Ch+e9DtMi6klxcWpboBtFoc7s=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.1.tgz",
      "integrity": "sha512-Y1GUDo39ez4aHAw7MysnUD5JzYX+WaIj8I57kO3aEPT1fFRL4sr7mjei97FgnwhAyyzRYmQZaTHb2+9uZ1dPtg==",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.2",
        "statuses": "~1.4.0",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.14.7",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.14.7.tgz",
      "integrity": "sha512-+hbxoLbFMbRKDwohX8GkTataGqO6Jb7jGwpAlwgy2bIz25XtRm7KEzJM76R1WiNT5SwZkX4Y75SwBolkpmE7iQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha1-PYyt2Q2XZWn6g1qx+OSyOhBWBac=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-errors": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
      "integrity": "sha1-i1VoC7S+KDoLW/TqLjhYC+HZMg0=",
      "dependencies": {
        "depd": "~1.1.2",
        "inherits": "2.0.3",
        "setprototypeof": "1.1.0",
        "statuses": ">= 1.4.0 < 2"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.23",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.23.tgz",
      "integrity": "sha512-neyTUVFtahjf0mB3dZT77u+8O0QB89jFdnBkd5P1JgYPbPaia3gXXOVL2fq8VyU2gMMD7SaN7QukTB/pmXYvDA==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
      "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4="
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
      "integrity": "sha1-sAqqVW3YtEVoFQ7J0blT8/kMu2E="
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha1-VSmk1nZUE07cxSZmVoNbD4Ua/O4=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.4.1.tgz",
      "integrity": "sha512-KI1+qOZu5DcW6wayYHSzR/tXKCDC5Om4s1z2QJjDULzLcmf3DvzS7oluY4HCTrc+9FiKmWUgeNLg7W3uIQvxtQ==",
      "bin": {
        "mime": "cli.js"
      }
    },
    "node_modules/mime-db": {
      "version": "1.51.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.51.0.tgz",
      "integrity": "sha512-5y8A56jg7XVQx2mbv1lu49NR4dokRnhZYTtL+KGfaa27uq4pSTXkwQkFJl4pkRMyNFz/EtYDSkiiEHx3F7UN6g==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.34",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.34.tgz",
      "integrity": "sha512-6cP692WwGIs9XXdOO4++N+7qjqv0rqxxVvJ3VHPh/Sc9mVZcQP+ZGhkKiTvWMQRr2tbHkJP/Yn7Y0npb3ZBs4A==",
      "dependencies": {
        "mime-db": "1.51.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/morgan": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/morgan/-/morgan-1.9.1.tgz",
      "integrity": "sha512-HQStPIV4y3afTiCYVxirakhlCfGkI161c76kKFca7Fk1JusM//Qeo1ej2XaMniiNeaZklMVrh3vTtIzpzwbpmA==",
      "dependencies": {
        "basic-auth": "~2.0.0",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "on-finished": "~2.3.0",
        "on-headers": "~1.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
    },
    "node_modules/negotiator": {
      "version": "0.6.2",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.2.tgz",
      "integrity": "sha512-hZXc7K2e+PgeI1eDBe/10Ard4ekbfrrqG8Ep+8Jmf4JID2bNg7NvCPOZN+kfF574pFQI7mum2AUqDidoKqcTOw==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/on-finished": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
      "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/on-headers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/on-headers/-/on-headers-1.0.2.tgz",
      "integrity": "sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
      "integrity": "sha1-32BBeABfUi8V60SQ5yR6G/qmf4w="
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/qs": {
      "version": "6.5.2",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.3.3.tgz",
      "integrity": "sha512-9esiElv1BrZoI3rCDuOuKCBRbuApGGaDPQfjSflGxdy4oyzqghxu6klEkkVIvBje+FF0BX9coEv8KqW6X/7njw==",
      "dependencies": {
        "bytes": "3.0.0",
        "http-errors": "1.6.3",
        "iconv-lite": "0.4.23",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/send": {
      "version": "0.16.2",
      "resolved": "https://registry.npmjs.org/send/-/send-0.16.2.tgz",
      "integrity": "sha512-E64YFPUssFHEFBvpbbjr44NCLtI1AohxQ8ZSiJjQLskAdKuriYEP6VyGEsRDH8ScozGpkaX1BGvhanqCwkcEZw==",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "destroy": "~1.0.4",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "~1.6.2",
        "mime": "1.4.1",
        "ms": "2.0.0",
        "on-finished": "~2.3.0",
        "range-parser": "~1.2.0",
        "statuses": "~1.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/serve-static": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.13.2.tgz",
      "integrity": "sha512-p/tdJrO4U387R9oMjb1oj7qSMaMfmOyd4j9hOFoxZe2baQszgHcSWjuya/CiT5kgZZKRudHNOA0pYXOl8rQ5nw==",
      "dependencies": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.2",
        "send": "0.16.2"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
      "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ=="
    },
    "node_modules/statuses": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.4.0.tgz",
      "integrity": "sha512-zhSCtt8v2NDrRlPQpCNtw/heZLtfUDqxBM1udqikb/Hbk52LK4nQSwr10u77iopCW5LsyHpuXS0GnEc48mLeew==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw=",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM=",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw=",
      "engines": {
        "node": ">= 0.8"
      }
    }
  },
  "dependencies": {
    "accepts": {
      "version": "1.3.7",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.7.tgz",
      "integrity": "sha512-Il80Qs2WjYlJIBNzNkK6KYqlVMTbZLXgHx2oT0pU/fjRHyEp+PEfEPY0R3WCwAGVOtauxh1hOxNgIf5bv7dQpA==",
      "requires": {
        "mime-types": "~2.1.24",
        "negotiator": "0.6.2"
      }
    },
    "array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha1-ml9pkFGx5wczKPKgCJaLZOopVdI="
    },
    "axios": {
      "version": "0.24.0",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.24.0.tgz",
      "integrity": "sha512-Q6cWsys88HoPgAaFAVUb0WpPk0O8iTeisR9IMqy9G8AbO4NlpVknrnQS03zzF9PGAWgO3cgletO3VjV/P7VztA==",
      "requires": {
        "follow-redirects": "^1.14.4"
      }
    },
    "basic-auth": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/basic-auth/-/basic-auth-2.0.1.tgz",
      "integrity": "sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==",
      "requires": {
        "safe-buffer": "5.1.2"
      }
    },
    "body-parser": {
      "version": "1.18.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.18.3.tgz",
      "integrity": "sha1-WykhmP/dVTs6DyDe0FkrlWlVyLQ=",
      "requires": {
        "bytes": "3.0.0",
        "content-type": "~1.0.4",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "http-errors": "~1.6.3",
        "iconv-lite": "0.4.23",
        "on-finished": "~2.3.0",
        "qs": "6.5.2",
        "raw-body": "2.3.3",
        "type-is": "~1.6.16"
      }
    },
    "bytes": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.0.0.tgz",
      "integrity": "sha1-0ygVQE1olpn4Wk6k+odV3ROpYEg="
    },
    "content-disposition": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.2.tgz",
      "integrity": "sha1-DPaLud318r55YcOoUXjLhdunjLQ="
    },
    "content-type": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
      "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA=="
    },
    "cookie": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.1.tgz",
      "integrity": "sha512-ZwrFkGJxUR3EIoXtO+yVE69Eb7KlixbaeAWfBQB9vVsNn/o+Yw69gBWSSDK825hQNdN+wF8zELf3dFNl/kxkUA=="
    },
    "cookie-parser": {
      "version": "1.4.6",
      "resolved": "https://registry.npmjs.org/cookie-parser/-/cookie-parser-1.4.6.tgz",
      "integrity": "sha512-z3IzaNjdwUC2olLIB5/ITd0/setiaFMLYiZJle7xg5Fe9KWAceil7xszYfHHBtDFYLSgJduS2Ty0P1uJdPDJeA==",
      "requires": {
        "cookie": "0.4.1",
        "cookie-signature": "1.0.6"
      }
    },
    "cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha1-4wOogrNCzD7oylE6eZmXNNqzriw="
    },
    "debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "requires": {
        "ms": "2.0.0"
      }
    },
    "depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
    },
    "destroy": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.0.4.tgz",
      "integrity": "sha1-l4hXRCxEdJ5CBmE+N5RiBYJqvYA="
    },
    "ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0="
    },
    "ejs": {
      "version": "2.6.2",
      "resolved": "https://registry.npmjs.org/ejs/-/ejs-2.6.2.tgz",
      "integrity": "sha512-PcW2a0tyTuPHz3tWyYqtK6r1fZ3gp+3Sop8Ph+ZYN81Ob5rwmbHEzaqs10N3BEsaGTkh/ooniXK+WwszGlc2+Q=="
    },
    "encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k="
    },
    "escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg="
    },
    "etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha1-Qa4u62XvpiJorr/qg6x9eSmbCIc="
    },
    "express": {
      "version": "4.16.4",
      "resolved": "https://registry.npmjs.org/express/-/express-4.16.4.tgz",
      "integrity": "sha512-j12Uuyb4FMrd/qQAm6uCHAkPtO8FDTRJZBDd5D2KOL2eLaz1yUNdUB/NOIyq0iU4q4cFarsUCrnFDPBcnksuOg==",
      "requires": {
        "accepts": "~1.3.5",
        "array-flatten": "1.1.1",
        "body-parser": "1.18.3",
        "content-disposition": "0.5.2",
        "content-type": "~1.0.4",
        "cookie": "0.3.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.1.1",
        "fresh": "0.5.2",
        "merge-descriptors": "1.0.1",
        "methods": "~1.1.2",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.2",
        "path-to-regexp": "0.1.7",
        "proxy-addr": "~2.0.4",
        "qs": "6.5.2",
        "range-parser": "~1.2.0",
        "safe-buffer": "5.1.2",
        "send": "0.16.2",
        "serve-static": "1.13.2",
        "setprototypeof": "1.1.0",
        "statuses": "~1.4.0",
        "type-is": "~1.6.16",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "dependencies": {
        "cookie": {
          "version": "0.3.1",
          "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.3.1.tgz",
          "integrity": "sha1-5+Ch+e9DtMi6klxcWpboBtFoc7s="
        }
      }
    },
    "finalhandler": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.1.tgz",
      "integrity": "sha512-Y1GUDo39ez4aHAw7MysnUD5JzYX+WaIj8I57kO3aEPT1fFRL4sr7mjei97FgnwhAyyzRYmQZaTHb2+9uZ1dPtg==",
      "requires": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.2",
        "statuses": "~1.4.0",
        "unpipe": "~1.0.0"
      }
    },
    "follow-redirects": {
      "version": "1.14.7",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.14.7.tgz",
      "integrity": "sha512-+hbxoLbFMbRKDwohX8GkTataGqO6Jb7jGwpAlwgy2bIz25XtRm7KEzJM76R1WiNT5SwZkX4Y75SwBolkpmE7iQ=="
    },
    "forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow=="
    },
    "fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha1-PYyt2Q2XZWn6g1qx+OSyOhBWBac="
    },
    "http-errors": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
      "integrity": "sha1-i1VoC7S+KDoLW/TqLjhYC+HZMg0=",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.3",
        "setprototypeof": "1.1.0",
        "statuses": ">= 1.4.0 < 2"
      }
    },
    "iconv-lite": {
      "version": "0.4.23",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.23.tgz",
      "integrity": "sha512-neyTUVFtahjf0mB3dZT77u+8O0QB89jFdnBkd5P1JgYPbPaia3gXXOVL2fq8VyU2gMMD7SaN7QukTB/pmXYvDA==",
      "requires": {
        "safer-buffer": ">= 2.1.2 < 3"
      }
    },
    "inherits": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
      "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4="
    },
    "ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g=="
    },
    "media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g="
    },
    "merge-descriptors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
      "integrity": "sha1-sAqqVW3YtEVoFQ7J0blT8/kMu2E="
    },
    "methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha1-VSmk1nZUE07cxSZmVoNbD4Ua/O4="
    },
    "mime": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.4.1.tgz",
      "integrity": "sha512-KI1+qOZu5DcW6wayYHSzR/tXKCDC5Om4s1z2QJjDULzLcmf3DvzS7oluY4HCTrc+9FiKmWUgeNLg7W3uIQvxtQ=="
    },
    "mime-db": {
      "version": "1.51.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.51.0.tgz",
      "integrity": "sha512-5y8A56jg7XVQx2mbv1lu49NR4dokRnhZYTtL+KGfaa27uq4pSTXkwQkFJl4pkRMyNFz/EtYDSkiiEHx3F7UN6g=="
    },
    "mime-types": {
      "version": "2.1.34",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.34.tgz",
      "integrity": "sha512-6cP692WwGIs9XXdOO4++N+7qjqv0rqxxVvJ3VHPh/Sc9mVZcQP+ZGhkKiTvWMQRr2tbHkJP/Yn7Y0npb3ZBs4A==",
      "requires": {
        "mime-db": "1.51.0"
      }
    },
    "morgan": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/morgan/-/morgan-1.9.1.tgz",
      "integrity": "sha512-HQStPIV4y3afTiCYVxirakhlCfGkI161c76kKFca7Fk1JusM//Qeo1ej2XaMniiNeaZklMVrh3vTtIzpzwbpmA==",
      "requires": {
        "basic-auth": "~2.0.0",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "on-finished": "~2.3.0",
        "on-headers": "~1.0.1"
      }
    },
    "ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
    },
    "negotiator": {
      "version": "0.6.2",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.2.tgz",
      "integrity": "sha512-hZXc7K2e+PgeI1eDBe/10Ard4ekbfrrqG8Ep+8Jmf4JID2bNg7NvCPOZN+kfF574pFQI7mum2AUqDidoKqcTOw=="
    },
    "on-finished": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
      "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
      "requires": {
        "ee-first": "1.1.1"
      }
    },
    "on-headers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/on-headers/-/on-headers-1.0.2.tgz",
      "integrity": "sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA=="
    },
    "parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ=="
    },
    "path-to-regexp": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
      "integrity": "sha1-32BBeABfUi8V60SQ5yR6G/qmf4w="
    },
    "proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "requires": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      }
    },
    "qs": {
      "version": "6.5.2",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA=="
    },
    "range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg=="
    },
    "raw-body": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.3.3.tgz",
      "integrity": "sha512-9esiElv1BrZoI3rCDuOuKCBRbuApGGaDPQfjSflGxdy4oyzqghxu6klEkkVIvBje+FF0BX9coEv8KqW6X/7njw==",
      "requires": {
        "bytes": "3.0.0",
        "http-errors": "1.6.3",
        "iconv-lite": "0.4.23",
        "unpipe": "1.0.0"
      }
    },
    "safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "send": {
      "version": "0.16.2",
      "resolved": "https://registry.npmjs.org/send/-/send-0.16.2.tgz",
      "integrity": "sha512-E64YFPUssFHEFBvpbbjr44NCLtI1AohxQ8ZSiJjQLskAdKuriYEP6VyGEsRDH8ScozGpkaX1BGvhanqCwkcEZw==",
      "requires": {
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "destroy": "~1.0.4",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "~1.6.2",
        "mime": "1.4.1",
        "ms": "2.0.0",
        "on-finished": "~2.3.0",
        "range-parser": "~1.2.0",
        "statuses": "~1.4.0"
      }
    },
    "serve-static": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.13.2.tgz",
      "integrity": "sha512-p/tdJrO4U387R9oMjb1oj7qSMaMfmOyd4j9hOFoxZe2baQszgHcSWjuya/CiT5kgZZKRudHNOA0pYXOl8rQ5nw==",
      "requires": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.2",
        "send": "0.16.2"
      }
    },
    "setprototypeof": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
      "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ=="
    },
    "statuses": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.4.0.tgz",
      "integrity": "sha512-zhSCtt8v2NDrRlPQpCNtw/heZLtfUDqxBM1udqikb/Hbk52LK4nQSwr10u77iopCW5LsyHpuXS0GnEc48mLeew=="
    },
    "type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "requires": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      }
    },
    "unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw="
    },
    "utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM="
    },
    "vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw="
    }
  }
}

'''
'''--- backend/expressjs/package.json ---
{
  "name": "nearlend-backend",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "ejs": "~2.6.1",
    "express": "~4.16.1",
    "http-errors": "~1.6.3",
    "morgan": "~1.9.1",
    "axios": "^0.24.0"
  }
}

'''
'''--- backend/expressjs/public/stylesheets/style.css ---
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}

a {
  color: #00B7FF;
}

'''
'''--- backend/expressjs/routes/getprice.js ---
var express = require('express');
var router = express.Router();
const axios = require('axios');

/* GET users listing. */
router.get('/', function(req, res, next) {
    //   res.send('respond with a resource');
    //res.json(req.params.currency);
    axios.get("https://api.coingecko.com/api/v3/simple/price?ids=ref-finance%2Cnear%2Caurora%2Cethereum&vs_currencies=usd")
    .then(function(response){
        res.json( {"Coingecko":response.data});
    })
    .catch(function(error){
        res.json(error);
    })
});

module.exports = router;
'''
'''--- backend/expressjs/routes/index.js ---
var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});

module.exports = router;

'''
'''--- backend/expressjs/routes/users.js ---
var express = require('express');
var router = express.Router();

/* GET users listing. */
router.get('/', function(req, res, next) {
  res.send('respond with a resource');
});

module.exports = router;

'''
'''--- backend/expressjs/views/server.js ---
var express = require("express");
var app = express();
const axios = require('axios');
var server = require("http").Server(app);

app.listen(3000);

app.get("/",function(req,res){
    //res.render(index);
})

app.get("/getprice",function(req,res){
    //res.json(req.params.currency);
    axios.get("https://api.coingecko.com/api/v3/simple/price?ids=ref-finance%2Cnear%2Caurora%2Cethereum&vs_currencies=usd")
    .then(function(response){
        res.json( {"Coingecko":response.data});
    })
    .catch(function(error){
        res.json(error);
    })
 
})

'''
'''--- duyhoag.testnet.json ---
{"account_id":"duyhoag.testnet","public_key":"ed25519:FAxbRGudhXdQbRxcREMd72RCwWHEJAKDgK56xPLZDyrF","private_key":"ed25519:57aNRrrvYG4BbqxPGQAW2KRpzhA2WSrkCpEW1GPWd44cGG5BuGKkMhkrR8qnbkVc2dJaWQ1hGSEtfBFhN24LEh2P"}
'''
'''--- frontend/README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `yarn test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

'''
'''--- frontend/firebase.json ---
{
  "hosting": {
    "public": "build",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@hookstate/core": "^3.0.13",
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@testing-library/user-event": "^13.2.1",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.13",
    "@types/react": "^17.0.20",
    "@types/react-dom": "^17.0.9",
    "antd": "^4.18.2",
    "axios": "^0.25.0",
    "buffer": "^6.0.3",
    "near-api-js": "^0.44.2",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^6.2.1",
    "react-scripts": "5.0.0",
    "web-vitals": "^2.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "build-deploy": "react-scripts build && firebase deploy",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@ant-design/plots": "^1.0.7",
    "html-webpack-plugin": "^5.5.0",
    "ts-loader": "^9.2.6",
    "typescript": "^4.5.4"
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>NEARLEND</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.css ---
/* @import "~antd/dist/antd.css"; */
/* @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap'); */
@import url("https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap");
@import "~antd/dist/antd.css";

:root {
  --white: #fff;
  --black: #2c2b2b;
  --origin-black: #000;
  --orange: #f3aa3a;
  --red: #ff1414;
  --space-gray: #929191;
  --greenlight: #2cffe4;
  --blue: #2196f3;
  --black-transparent: rgb(146 145 145 / 23%);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Fredoka One", sans-serif;
  font-weight: normal;
  font-style: normal;
  letter-spacing: 0.07rem;
}

/* Hide scrollbar for Chrome, Safari and Opera */
html::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge and Firefox */
html {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

.App {
  min-height: 100vh;
  /* padding-bottom: 140px; */
  background-color: #282c34;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}
h1,
h2,
h3,
h4,
h5,
h6,
p,
ul {
  color: var(--white);
  margin: 0;
}

ul {
  list-style: none;
}

a {
  text-decoration: none;
}

footer {
  padding: 40px;
  background: #000;
  color: #fff;
  text-align: center;
  font-style: italic;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
  position: relative;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

#not-found {
  padding: 1rem;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 30px;
  width: 100%;
  text-align: center;
}

/* HEADER */
.header {
  transition: 0.4s all;
  z-index: 9999;
  position: fixed;
  width: 100%;
  top: auto;
  left: 50%;
  transform: translateX(-50%);
}
.header.active {
  background-color: #000;
}

.header .container {
  max-width: 1400px;
  padding: 4px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--white);
}

.header h1 a {
  color: var(--white);
}

.header nav ul {
  display: flex;
  align-items: center;
  justify-content: flex-end;
}
.header nav ul li {
  margin-left: 24px;
  font-size: 15px;
}

.header nav a {
  color: var(--white);
  font-family: "Fredoka One", sans-serif;
}

.header .btn-connect {
  border: 1px solid var(--greenlight);
  padding: 10px;
  cursor: pointer;
  font-size: 12px;
  position: relative;
}

.header .btn-connect .more {
  display: none;
  position: absolute;
  bottom: -90px;
  width: 100%;
  left: 0;
  background: #282344;
  padding: 15px;
  text-align: center;
  border-radius: 4px;
}

.header .btn-connect .more a {
  display: block;
  margin-bottom: 4px;
}

.header .btn-connect .more.active {
  display: block;
}

.header .btn-connect .more p {
  padding-bottom: 10px;
}

.header .btn-connect .more a:hover {
  color: var(--greenlight);
}

.header .btn-connect .more p:last-child {
  padding-bottom: 0;
}

.header .link-active {
  color: var(--greenlight);
}

@media screen and (max-width: 1400px) {
  .header .container {
    margin: 0 40px;
  }
}

/* end HEADER */

/* Home Page */
.homepage {
  padding-top: 120px;
}
.homepage .wrap-total {
  display: inline-block;
  font-size: 17px;
  background: rgb(0 0 0 / 35%);
  color: var(--white);
  font-weight: bold;
  border-radius: 10px;
  /* border: 1px solid var(--greenlight) */
}

.homepage .wrap-total .total {
  padding: 20px;
  display: inline-block;
  min-width: 200px;
}

.homepage .wrap-total .title {
  padding-bottom: 8px;
  font-size: 15px;
}

.homepage .wrap-total .value {
  font-size: 22px;
}

.homepage .wrap-market {
  color: #c1c1c1;
  padding: 20px;
  background: rgb(0 0 0 / 40%);
  margin: 60px 20px;
  border-radius: 5px;
  overflow-x: scroll;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
}
/* Hide scrollbar for Chrome, Safari and Opera */
.homepage .wrap-market::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge and Firefox */
.homepage .wrap-market {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

.homepage .wrap-market .title {
  font-size: 26px;
  padding-bottom: 10px;
  padding-top: 14px;
  color: var(--greenlight);
  position: absolute;
}
.homepage .wrap-market .wrap-label {
  font-weight: bold;
  display: grid;
  grid-auto-flow: column;
  grid-row-gap: 40px;
  justify-content: space-around;
  border-bottom: 1px solid var(--greenlight);
  padding: 30px 0;
  margin-bottom: 30px;
  margin-top: 50px;
  min-width: 800px;
}
.homepage .wrap-market .wrap-label p {
  width: 100px;
  color: var(--space-gray);
  text-align: center;
}

.homepage .wrap-market .wrap-pool {
  display: grid;
  grid-auto-flow: column;
  grid-row-gap: 40px;
  justify-content: space-around;
  padding: 12px 0;
  margin-bottom: 10px;
  min-width: 800px;
}

.homepage .wrap-market .pools {
  min-width: 800px;
  height: 340px;
  overflow-y: scroll;
}

/* Hide scrollbar for Chrome, Safari and Opera */
.homepage .wrap-market .pools::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge and Firefox */
.homepage .wrap-market .pools {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

.homepage .wrap-market .wrap-pool:hover {
  background-color: rgb(255 255 255 / 3%);
}

.homepage .wrap-market .wrap-pool .top {
  margin-bottom: 4px;
}

.homepage .wrap-market .wrap-pool .mini {
  width: 100px;
  text-align: center;
}

.homepage .wrap-market .wrap-pool .apy {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin-bottom: 4px;
}
.homepage .wrap-market .wrap-pool .apy .icon-apy {
  padding: 0 7px;
  /* margin-bottom: -5px; */
}

.homepage .wrap-market .wrap-pool .apy .icon-apy img {
  background: var(--greenlight);
  border-radius: 50%;
  border: 1px solid #1c887a;
}

.homepage .wrap-market .wrap-pool .action {
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  flex-direction: column;
  align-items: center;
  transition: 0.4s all;
}

.homepage .wrap-market .wrap-pool .action:hover {
  opacity: 0.5;
}

.homepage .wrap-market .wrap-pool .action button {
  cursor: pointer;
  outline: none;
  border-radius: 4px;
  border: 1px solid var(--greenlight);
  padding: 3px 15px;
  margin-top: 2px;
  background: transparent;
  color: #fff;
  font-size: 12px;
  width: 100px;
}

.homepage .wrap-market .wrap-pool .icon {
  margin-right: 8px;
  border: 1px solid var(--greenlight);
  background: var(--greenlight);
  border-radius: 50%;
}

.homepage .wrap-market .wrap-pool .asset {
  position: relative;
  justify-content: flex-start;
  text-align: left;
}

.homepage .wrap-market .wrap-pool .asset .btn-claim {
  position: absolute;
  left: 100px;
  top: 10px;
}

.homepage .wrap-market .market-flex {
  display: flex;
  justify-content: flex-start;
  align-items: center;
}

/* end Home Page */

/* Introduce Page */
.introduce-page {
  margin-bottom: -140px;
  position: relative;
  background: #150a33;
}

.introduce-page .head {
  padding-top: 60px;
  display: block;
  min-height: 100vh;

  position: relative;
  background: url("./images/globe-block.png") no-repeat center bottom / contain;
}

.introduce-page .head .logo {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.introduce-page .head h2 {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-weight: bold;
  font-size: 70px;
  text-align: center;
  width: 640px;
}

.introduce-page .section-2 {
  padding: 100px 0;
}

.introduce-page .section-2.section-top {
}
.introduce-page .section-2.section-top .content {
  margin: 0;
}

.introduce-page .section-2 .title {
  text-align: center;
  font-size: 55px;
  font-weight: bold;
  padding-bottom: 20px;
  font-family: "Fredoka One", sans-serif;
}

.introduce-page .section-2 .img-background {
  height: 500px;
  background: url("./images/crypto.png") no-repeat -80px 0 / 1200px 1543px;
  width: 500px;
}
.introduce-page .section-2 .wrapper {
  max-width: 1200px;
  margin: auto;
}

.introduce-page .section-2 .flex {
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 30px;
}
.introduce-page .section-2 .content {
  max-width: 500px;
  font-size: 20px;
  text-align: justify;
  margin: auto;
}
.introduce-page .section-2.section-3 {
  /* padding-bottom: 160px; */
}

.introduce-page .section-2.section-3 .flex {
  flex-direction: row-reverse;
}
.introduce-page .section-2.section-3 .content {
  text-align: left;
}
.introduce-page .section-2.section-3 .img-background {
  background: url("./images/crypto.png") no-repeat -630px -470px / 1200px 1543px;
}

.introduce-page .section-2 .flex-side {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  text-align: center;
  padding-bottom: 60px;
}

.introduce-page .section-2 .flex-side .img {
  max-width: 512px;
  height: 445px;
}
.introduce-page .section-2 .flex-side .img > img {
  object-fit: contain;
}

.introduce-page .section-2 .flex-side .label {
  font-size: 24px;
  font-weight: bold;
  padding-bottom: 14px;
  text-decoration: underline;
}
.introduce-page .section-2 .flex-side .content {
  text-align: center;
}
.introduce-page .section-2 .flex-side .left {
}
.introduce-page .section-2 .flex-side .right {
}

.introduce-page .section-2 .last {
  text-align: center;
  font-size: 14px;
  font-weight: bold;
}

.introduce-page .section-2 .last p {
  padding-bottom: 4px;
}

.introduce-page .tokenomic {
  padding: 0 0 100px;
}

.introduce-page .social-media {
}
.introduce-page .social-media .title {
  text-align: center;
  font-size: 55px;
  font-weight: bold;
  padding-bottom: 20px;
  font-family: "Fredoka One", sans-serif;
}
.introduce-page .social-media .list-social {
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding-top: 50px;
  padding-bottom: 100px;
}
.introduce-page .social-media .list-social img {
  width: 120px;
  height: 120px;
}
.introduce-page .social-media .list-social .link {
  transition: 0.4s all;
}
.introduce-page .social-media .list-social .link:hover {
  transform: rotate(20deg);
}

.g2-tooltip {
  color: #000;
}
.g2-tooltip-list-item,
.g2-tooltip-value,
.g2-tooltip-name {
  color: #000;
}

.g2-tooltip-list-item {
  text-align: center;
}

/* end Introduce Page */

/* Portforlio Page */
.portforlio .total {
  text-align: center;
}

.portforlio .token-list {
  position: relative;
  /* border: 1px solid #20948a; */
  background-color: rgb(0 0 0 / 40%);
  display: flex;
  justify-content: space-between;
  padding: 20px 40px;
  margin: 60px 20px 20px;
  font-size: 20px;
  border-radius: 5px;
  min-height: 200px;
}

.portforlio .token-list::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 1px;
  height: 85%;
  background-color: #20948a;
}

.portforlio .token-list .side {
  width: 45%;
}
.portforlio .token-list .side .my-info {
  display: flex;
  justify-content: space-between;
  padding: 10px 0 20px;
  border-bottom: 1px solid #20948a;
}

.portforlio .token-list .side .my-info h5 {
  font-weight: bold;
}

.portforlio .token-list .side .detail {
  padding-bottom: 14px;
}
.portforlio .token-list .side .detail .label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
  margin-top: 24px;
  margin-bottom: 24px;
  /* pointer-events: none; */
}

.portforlio .token-list .label .title {
  width: 100px;
  text-align: center;
  color: var(--space-gray);
}
.portforlio .token-list .wrap-info {
  position: relative;
}
.portforlio .token-list .wrap-info .arrow-down {
  position: absolute;
  bottom: 0;
  left: 50%;
}
.portforlio .token-list .wrap-info .arrow-down.active {
  transform: rotate(180deg);
}
.portforlio .token-list .wrap-info .label.label__token__detail {
  display: none;
}
.portforlio .token-list .wrap-info.active .label.label__token__detail {
  display: block;
  margin-top: 0;
}

.portforlio .label.label__token__detail .token__detail__row {
  display: flex;
  width: 100%;
  justify-content: flex-start;
  margin-bottom: 7px;
  align-items: center;
  position: relative;
}

.token__detail__row .btn-plus {
  cursor: pointer;
  position: absolute;
  font-size: 24px;
  right: 60px;
  width: 50px;
  height: 32px;
}
.token__detail__row .btn-plus::before {
  content: "+";
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
}

.token__detail__row .btn-minus {
  cursor: pointer;
  position: absolute;
  font-size: 24px;
  right: 0;
  width: 50px;
  height: 32px;
}

.token__detail__row .btn-minus::before {
  content: "-";
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
}

.portforlio .label.label__token__detail .token__detail__row .title {
  text-align: left;
}
.portforlio .label.label__token__detail .token__detail__row .label__token-mini {
  text-align: left;
  font-size: 20px;
}

.portforlio .token__logo {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  text-align: left;
  max-width: 100px;
}

.portforlio .token__logo img {
  margin-right: 8px;
  border: 2px solid #04413c;
  border-radius: 50%;
}

.portforlio .token__price p {
  text-align: left;
  /* word-break: break-all; */
}

.portforlio .token-list .side .detail .label.label__token {
  position: relative;
  margin-top: 0;
  margin-bottom: 0;
  padding-bottom: 20px;
  cursor: pointer;
}
.portforlio .token-list .side .detail .label.label__token:hover {
  /* background-color: #fff; */
}

.portforlio .label__token-mini {
  width: 100px;
  text-align: center;
}

.portforlio .label__token-mini .token_name {
  font-weight: bold;
  text-transform: uppercase;
  width: 140px;
  word-break: break-word;
}

.portforlio .empty-account-line {
  width: 40px;
  height: 5px;
  background: var(--white);
  border-radius: 4px;
  margin: 30px auto 0;
}
/* end Portforlio Page */

/* marketplace Page */

.marketplace {
  padding-top: 100px;
  height: 100vh;
  background: #0e0d1a;
}

.marketplace .single-slide {
  height: 40vh;
  color: "#fff";
}
/* .marketplace .single-slide-1 {
  background: url("./images/nft_circle.jpeg") no-repeat center 70% / cover;
}
.marketplace .single-slide-2 {
  background: url("./images/nft_city.jpeg") no-repeat center 70% / cover;
}
.marketplace .single-slide-3 {
  background: url("./images/nft_moutain-land.jpeg") no-repeat center 70% / cover;
} */

.marketplace .ant-carousel .slick-dots-bottom {
  bottom: -38px;
}

.marketplace .list-card {
  background-color: var(--origin-black);
  position: relative;
  padding: 74px 0;
}
.marketplace .list-card .container {
  max-width: 1200px;
}
.marketplace .wrap-card {
  display: grid;
  grid-template-columns: repeat(auto-fill, 280px);
  grid-row-gap: 40px;
  grid-column-gap: 25px;
  justify-content: center;
}
.marketplace .wrap-card .card {
  cursor: pointer;
  max-width: 280px;
  padding: 12px;
  border-radius: 6px;
  border: 1px solid var(--origin-black);
  transition: 0.4s all;
}
.marketplace .wrap-card .card:hover {
  border: 1px solid var(--greenlight);
}
.marketplace .wrap-img {
  position: relative;
  width: 100%;
  border-radius: 6px;
  overflow: hidden;
}
.marketplace .wrap-img .img {
  width: 100%;
  height: 240px;
}
.marketplace .wrap-img .img img {
  object-fit: cover;
  width: inherit;
  height: inherit;
}
.marketplace .wrap-img .img video {
  overflow: hidden;
  width: inherit;
  height: auto;
}

.marketplace .wrap-img .type {
  z-index: 1;
  position: absolute;
  top: 12px;
  left: 12px;
  color: rgb(255, 255, 255);
  background-color: rgba(0, 0, 0, 0.6);
  padding: 5px 12px;
  border-radius: 5px;
  font-size: 11px;
}

.marketplace .wrap-img .like {
  z-index: 1;
  position: absolute;
  bottom: 12px;
  right: 12px;
  color: rgb(255, 255, 255);
  background-color: rgba(0, 0, 0, 0.6);
  padding: 5px 12px;
  border-radius: 5px;
  font-size: 11px;
}

.marketplace .wrap-card .card-name {
  padding: 10px 0 14px;
}
.marketplace .wrap-card .card-price {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 12px;
}
.marketplace .wrap-card .card-price .price {
  display: flex;
  align-items: center;
}
.marketplace .wrap-card .card-price .left {
  font-size: 12px;
}
.marketplace .wrap-card .card-price .right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}
.marketplace .wrap-card .card-price .price-token {
}
.marketplace .wrap-card .card-price .price-token {
  padding-left: 8px;
}
.marketplace .wrap-card .card-price .icon-token {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  overflow: hidden;
  background-color: var(--black-transparent);
}
.marketplace .wrap-card .price-text {
  align-self: flex-start;
}
.marketplace .wrap-card .card-price .left {
}
.marketplace .wrap-card .card-price .right {
}

.marketplace .wrap-card .price-usd {
  font-size: 12px;
  display: flex;
  align-items: center;
  height: 21px;
}

.marketplace .wrap-card .creator-verified {
  padding-right: 4px;
  color: var(--blue);
  font-size: 12px;
}

/* end marketplace Page */

/* nft-detail Page */
.nft-detail {
  min-height: 100vh;
  position: relative;
  color: var(--white);
  background-color: var(--origin-black);
}

.nft-detail .nft-info {
  padding-top: 194px;
  position: relative;
}

.nft-detail .nft-info .arrow-back {
  color: var(--white);
  font-size: 70px;
  position: absolute;
  top: -100px;
  left: 0;
  cursor: pointer;
}
.nft-detail .nft-info .container::after {
  content: "";
  display: block;
  clear: both;
}
.nft-detail .nft-info .container {
  max-width: 1400px;
  margin: auto;
}
.nft-detail .nft-info .nft-name {
  font-size: 24px;
  margin: 8px 8px 0 0;
}
.nft-detail .nft-info .nft-type {
  background: gray;
  padding: 4px;
  border-radius: 6px;
  margin: 8px 8px 0 0;
  font-size: 12px;
}
.nft-detail .nft-info .wrap-img {
  /* overflow: hidden; */
  border-radius: 6px;
  height: 700px;
  width: 60%;
  margin: 0 5% 0 0;
  float: left;
}
.nft-detail .nft-info .wrap-img .img {
  height: inherit;
  width: 100%;
  overflow: hidden;
  border-radius: 12px;
  box-shadow: 0px -2px 7px #2cffe3, 0px 2px 8px #2cffe4, 0px 0px 7px #2cffe4;
  border: 3px solid #6cffec;
}
.nft-detail .nft-info .wrap-img .img .video-background {
  width: 100%;
  height: 100%;
}
.nft-detail .nft-info .wrap-detail {
  position: relative;
  width: 35%;
  float: right;
  min-height: 700px;
  max-height: 700px;
  overflow-y: scroll;
}

.nft-detail .nft-info .wrap-detail .wrap-button {
  width: 100%;
  position: absolute;
  bottom: 0;
  left: 0;
  padding: 10px 0 0;
  background: var(--origin-black);
}

.nft-detail .nft-info .wrap-detail .wrap-button .price {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 0;
}

.nft-detail .wrap-button .price .token-icon-price {
  text-transform: uppercase;
  padding: 0 10px;
  font-size: 20px;
}
.nft-detail .wrap-button .price .token-usd {
}

.nft-detail .nft-info .wrap-detail .wrap-button .button {
  cursor: pointer;
  width: inherit;
  padding: 8px;
  background: var(--blue);
  font-size: 24px;
  text-transform: uppercase;
  border: none;
  border-radius: 4px;
  transition: 0.4s all;
}

.nft-detail .nft-info .wrap-detail .wrap-button .button:hover {
  opacity: 0.84;
}

.nft-detail .nft-info .wrap-detail .top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
}

.nft-detail .nft-info .wrap-detail .top .title {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
}

.nft-detail .nft-info .wrap-detail .top .like-share {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  margin: 8px 8px 0 0;
}
.nft-detail .nft-info .wrap-detail .top .like-share-icon {
  cursor: pointer;
  margin-right: 8px;
}
.nft-detail .nft-info .wrap-detail .top .like-share .like {
  border: 1px solid #fff;
  border-radius: 6px;
  padding: 2px 8px;
}
.nft-detail .nft-info .wrap-detail .top .like-share .share {
  font-size: 22px;
}

.nft-detail .owner-info {
  display: flex;
  justify-content: flex-start;
  flex-wrap: wrap;
  padding-bottom: 24px;
}
.nft-detail .owner-info .wrap-owner {
  display: flex;
  justify-content: flex-start;
  align-items: center;
  padding-right: 34px;
  padding-top: 25px;
}
.nft-detail .owner-info .wrap-owner .token-icon {
  padding-right: 8px;
}
.nft-detail .owner-info .wrap-owner .owner {
  /* padding-left: 12px; */
}

.nft-detail .owner-info .wrap-owner .owner-title {
  color: var(--space-gray);
  font-size: 12px;
}
.nft-detail .owner-info .wrap-owner .owner-name {
  font-size: 14px;
}

.nft-detail .wrap-detail .wrap-description {
  padding: 20px 0 24px;
  margin: 14px 0;
  border-bottom: 1px solid var(--space-gray);
  border-top: 1px solid var(--space-gray);
}
.nft-detail .wrap-detail .description {
  max-height: 100px;
  overflow-y: scroll;
}

@media screen and (max-width: 1400px) {
  .nft-detail .nft-info .container {
    margin: 0 40px;
  }
}

@media screen and (max-width: 1024px) {
  .nft-detail .nft-info .wrap-img,
  .nft-detail .nft-info .wrap-detail {
    min-height: 500px;
    height: 500px;
  }
  .nft-detail .nft-info .wrap-img {
    width: 55%;
  }
  .nft-detail .nft-info .wrap-detail {
    width: 40%;
  }
}

@media screen and (max-width: 974px) {
  .nft-detail .nft-info .container {
    margin: 0 30px;
  }
  .nft-detail .nft-info .wrap-img {
    width: 55%;
  }
  .nft-detail .nft-info .wrap-detail {
    width: 40%;
  }
}

@media screen and (max-width: 900px) {
  .nft-detail .nft-info .wrap-detail,
  .nft-detail .nft-info .wrap-img {
    float: none;
    width: 100%;
  }
  .nft-detail .nft-info .wrap-img {
    margin-bottom: 8px;
    height: 480px;
  }
  .nft-detail .nft-info .wrap-detail {
    min-height: auto;
    height: auto;
    max-height: auto;
    padding-bottom: 140px;
  }

  .nft-detail .nft-info .wrap-detail .wrap-button {
    position: fixed;
    width: 100%;
    padding: 0 30px 30px;
  }
}

@media screen and (max-width: 600px) {
  .nft-detail .nft-info .wrap-detail .top .like-share,
  .nft-detail .nft-info .nft-name {
    width: 100%;
  }
  .nft-detail .nft-info .wrap-detail .top .like-share {
    margin-top: 12px;
  }
}

@media screen and (max-width: 290px) {
  .nft-detail .nft-info .nft-type {
    margin: 10px 0 20px 0px;
  }
}

/* end nft-detail Page */

/* BACKGROUND WAVE */

.waveWrapper {
  z-index: 0;
  overflow: hidden;
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  margin: auto;
}
.waveWrapperInner {
  position: absolute;
  width: 100%;
  overflow: hidden;
  height: 100%;
  bottom: -1px;
  background: rgb(39, 39, 60);
  background: -moz-linear-gradient(180deg, #0c0817 0%, #150a33 100%);
  background: -webkit-linear-gradient(180deg, #0c0817 0%, #150a33 100%);
  background: linear-gradient(180deg, #0c0817 0%, #150a33 100%);
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#0c0817",endColorstr="#150a33",GradientType=1);
  /* background: rgb(0, 0, 0);
  background: -moz-linear-gradient(
    180deg,
    rgba(0, 0, 0, 1) 0%,
    rgba(3, 9, 46, 1) 100%
  );
  background: -webkit-linear-gradient(
    180deg,
    rgba(0, 0, 0, 1) 0%,
    rgba(3, 9, 46, 1) 100%
  );
  background: linear-gradient(
    180deg,
    rgba(0, 0, 0, 1) 0%,
    rgba(3, 9, 46, 1) 100%
  );
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#000000",endColorstr="#03092e",GradientType=1); */
}
.bgTop {
  z-index: 15;
  opacity: 0.2;
}
.bgMiddle {
  z-index: 10;
  opacity: 0.45;
}
.bgBottom {
  z-index: 5;
  opacity: 0.4;
}
.wave {
  position: absolute;
  left: 0;
  width: 200%;
  height: 100%;
  background-repeat: repeat no-repeat;
  background-position: 0 bottom;
  transform-origin: center bottom;
}
.waveTop {
  background-size: 50% 140px;
}
.waveAnimation .waveTop {
  animation: move-wave 3s;
  -webkit-animation: move-wave 3s;
  -webkit-animation-delay: 1s;
  animation-delay: 1s;
}
.waveMiddle {
  background-size: 50% 140px;
}
.waveAnimation .waveMiddle {
  animation: move_wave 10s linear infinite;
}
.waveBottom {
  background-size: 50% 140px;
}
.waveAnimation .waveBottom {
  animation: move_wave 15s linear infinite;
}

@keyframes move_wave {
  0% {
    transform: translateX(0) translateZ(0) scaleY(1);
  }
  50% {
    transform: translateX(-25%) translateZ(0) scaleY(0.55);
  }
  100% {
    transform: translateX(-50%) translateZ(0) scaleY(1);
  }
}
/* end BACKGROUND WAVE */

/* POPUP-CSS */
/* POPUP-CSS */
/* POPUP-CSS */
.wrap-popup {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgb(0 0 0 / 40%);
  z-index: 9999;
}

.wrap-popup .popup {
  color: var(--white);
  position: absolute;
  z-index: 99999;
  top: 45%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #341d73;
  min-width: 400px;
  min-height: 520px;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
  border-top: 5px solid #462893;
  overflow: hidden;
  /* padding: 14px; */
  animation: popup 0.1s ease;
}

.wrap-popup .popup.notification {
  min-width: 314px;
  min-height: 120px;
  background: rgb(0 0 0 / 80%);
  border: 1px solid var(--greenlight);
  border-radius: 8px;
  padding: 24px;
  text-align: center;
}

.popup.notification .text-notification {
  padding: 10px 0 0;
}

.popup.notification .text-notification strong {
  font-size: 15px;
}

.button-notification {
  cursor: pointer;
  min-width: 100px;
  padding: 4px 0 4px;
  margin: 15px;
  background: var(--blue);
  border: none;
  border-radius: 4px;
  transition: 0.4s all;
}
.popup.notification .title-notification {
  text-transform: uppercase;
  font-size: 20px;
}

.button-notification.button-gray {
  background: var(--space-gray);
}
.button-notification:hover {
  opacity: 0.84;
}

.popup .popup-available-price {
  font-size: 15px;
}

@keyframes popup {
  0% {
    transform: translate(-50%, 0%);
  }
  100% {
    transform: translate(-50%, -50%);
  }
}

.wrap-popup .popup .icon-close {
  cursor: pointer;
  z-index: inherit;
  position: absolute;
  right: 6px;
  top: 2px;
  padding: 13px 16px;
}

.wrap-popup .popup .title {
  font-size: 24px;
  font-weight: bold;
  letter-spacing: 0.1rem;
  text-align: center;
  padding-top: 12px;
  padding-bottom: 12px;
  position: relative;
  text-transform: uppercase;
}

.wrap-popup .popup .icon {
  text-align: center;
  position: relative;
  width: auto;
  width: 46px;
  height: 46px;
  margin: 0 auto 14px;
  border-radius: 50%;
  overflow: hidden;
}

.wrap-popup .popup .icon-name {
  text-align: center;
  font-size: 23px;
  position: relative;
  color: #1acab3;
  font-weight: bold;
  text-transform: uppercase;
}

.wrap-popup .popup .value-percent {
  color: #1acab3;
  position: relative;
  text-align: center;
  padding-top: 4px;
  padding-bottom: 14px;
}
.wrap-popup .popup .wrap-white {
  z-index: 9;
  background-color: transparent;
}

.wrap-popup .popup .info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  position: relative;
  color: var(--black);
  font-weight: bold;
  padding: 14px !important;
}
.wrap-popup .popup .info p {
  color: var(--black);
  width: 50%;
}

.wrap-popup .popup .input-number {
  position: relative;
  padding: 10px 0;
  width: 100%;
  border: 1px solid #000;
  border-radius: 4px;
  font-size: 15px;
  font-weight: bold;
  outline: none;
}
.wrap-popup .popup .ant-input-number-input {
  height: auto;
}

.wrap-popup .popup .slider-range {
  position: relative;
  width: 90%;
  margin: 20px auto 34px;
}

.wrap-popup .popup .slider-range .ant-slider-mark-text {
  font-size: 12px;
}

.wrap-popup .popup .slider-range .ant-slider-handle.ant-tooltip-open {
  /* background: #000; */
}

.popup .ant-slider-handle + .ant-slider-step .ant-slider-tooltip {
  display: none;
}

.popup .ant-slider-handle:focus + .ant-slider-step .ant-slider-tooltip {
  display: block;
}

.wrap-popup .popup .total {
  position: relative;
  text-align: center;
  color: var(--black);
  font-weight: bold;
  padding-bottom: 24px;
}

.wrap-popup .popup .rates-title {
  color: var(--black);
  padding-bottom: 8px;
}
.wrap-popup .popup .flex {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  color: var(--black);
  margin-bottom: 10px;
  margin-top: 10px;
}

.wrap-popup .popup .btn {
  text-align: center;
  min-width: 120px;
  margin: auto;
  display: block;
  padding: 5px 14px;
  outline: none;
  background: #000;
  border: none;
  border-radius: 4px;
  margin: 50px auto 20px;
  cursor: pointer;
}

.wrap-popup .popup .btn:active {
  opacity: 0.7;
}

.wrap-popup .text-error {
  position: absolute;
  left: 50%;
  transform: translate(-50%, 0);
}

/* end POPUP-CSS */
/* end POPUP-CSS */
/* end POPUP-CSS */

/* Switch-CSS */
.switch {
  position: relative;
  display: inline-block;
  width: 38px;
  height: 20px;
}

.switch .input-slider {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider.round {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: 0.4s;
  transition: 0.4s;
}

.slider.round:before {
  position: absolute;
  content: "";
  height: 12px;
  width: 12px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: 0.4s;
  transition: 0.4s;
}

.input-slider:checked + .slider.round {
  background-color: #2196f3;
}

.input-slider:focus + .slider.round {
  box-shadow: 0 0 1px #2196f3;
}

.input-slider:checked + .slider.round:before {
  -webkit-transform: translateX(16px);
  -ms-transform: translateX(16px);
  transform: translateX(16px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}
/* end Switch-CSS */

/* WAVE-CSS */
.Ocean {
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  width: inherit;
  height: inherit;
  overflow: hidden;
  position: absolute;
  top: 0;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  z-index: -1;
}

/* Hide scrollbar for Chrome, Safari and Opera */
.Wave::-webkit-scrollbar,
.Ocean::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge and Firefox */
.Ocean,
.Wave {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

.Wave {
  width: 6440px;
  animation-name: swell;
  animation-duration: 2s;
  animation-fill-mode: forwards;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  fill: var(--white);
}

.Wave .WavePath {
  width: 100%;
}

/* end WAVE-CSS */

@keyframes swell {
  /* 0% {
    transform: translateX(-50%);
  }
  25% {
    transform: translateX(0);
  }
  50% {
    transform: translateX(-50%);
  }
  75% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-50%);
  } */

  0% {
    transform: translateX(-50%);
  }

  100% {
    transform: translateX(0%);
  }
}

.roadmap {
  padding: 80px 20px 0px;
  overflow-x: hidden;
}

.roadmap .title {
  text-align: center;
  font-size: 55px;
  font-weight: bold;
  padding-bottom: 20px;
  font-family: "Fredoka One", sans-serif;
}

.roadmap .section-top .text {
  padding: 15px 0;
}

.roadmap .ship-1 {
  position: absolute;
  top: -66px;
  left: -10px;
  -webkit-animation: mover 1.5s infinite alternate;
  animation: mover 1.5s infinite alternate;
}
.roadmap .section-top .col {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
}
.roadmap .section-top .col .content {
  position: relative;
  width: 340px;
  padding-left: 30px;
  margin: 40px 0 0;
}

.roadmap .section-top .col .content.number::before {
  content: "1";
  position: absolute;
  top: -6px;
  left: 0;
  font-size: 24px;
  color: var(--yellow);
  font-weight: bold;
}

.roadmap .section-top .col .content.number.number-2::before {
  content: "2";
}

.roadmap .section-top .col .content.number.number-3::before {
  content: "3";
}

.roadmap .section-top .col .content.number.number-4::before {
  content: "4";
}

.roadmap .section-bot {
  padding: 80px 0 80px;
}

.roadmap .deco-stones {
  position: absolute;
  right: 0;
  bottom: 400px;
}
.roadmap .deco-big {
  position: absolute;
  top: -30px;
  left: -400px;
  width: 1410px;
  height: 1034px;
  /* background: url("/assets/bg-deco.png") no-repeat center center / contain; */
}

.roadmap .ship-2 {
  position: absolute;
  top: 60px;
  right: 0;
  -webkit-animation: mover 1.5s infinite alternate;
  animation: mover 1.5s infinite alternate;
}

.roadmap .wrap-line::before {
  content: "";
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 1px;
  height: 100%;
  background: var(--greenlight);
}
.roadmap .wrap-line .phase {
  position: relative;
  width: 270px;
  margin-bottom: 60px;
}

.roadmap .wrap-line .phase.left {
  margin-left: auto;
}
.roadmap .wrap-line .phase.right {
  text-align: right;
}

.roadmap .wrap-line .phase.right h4 {
  left: auto;
  right: -170px;
  margin-left: auto;
}

.roadmap .wrap-line .phase h4 {
  /* position: absolute; */
  font-weight: lighter;
  width: 100px;
  text-align: center;
  margin-bottom: 14px;
  /* left: -180px; */
  border: 1px solid var(--white);
  padding: 6px 15px;
  border-radius: 20px;
}
.roadmap .wrap-line .phase h5 {
  padding-bottom: 24px;
  font-size: 20px;
  letter-spacing: 2px;
}
.roadmap .wrap-line .phase .content p {
  font-weight: lighter;
  font-weight: normal;
  font-size: 16px;
}

.roadmap .wrap-line .wrap {
  position: relative;
}

.roadmap .wrap-line .wrap:last-child::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  background-color: #150a33;
  width: 100%;
  height: 100%;
}

.roadmap .wrap-line .wrap .planet {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
}

.roadmap .wrap-line .wrap .planet.grayscale {
  filter: gray;
  -webkit-filter: grayscale(1);
  filter: grayscale(1);
}

/* REUSE */
/* REUSE */
/* REUSE */
/* REUSE */
/* REUSE */

.text-error {
  color: var(--red);
  font-size: 10px;
  text-align: center;
  padding: 13px;
  width: 100%;
}

.button-basic {
  pointer-events: all;
  padding: 4px;
  background: transparent;
  border: 1px solid var(--greenlight);
  color: #fff;
  border-radius: 4px;
  transition: 0.4s all;
}

.button-basic:hover {
  opacity: 0.8;
}
.button-basic:active {
  opacity: 0.6;
}

.color-white {
  color: var(--white);
}

.color-space-gray {
  color: var(--space-gray);
}

.fwb {
  font-weight: bold;
}

.tac {
  text-align: center;
}

.tar {
  text-align: right;
}

.position-relative {
  position: relative;
}

.container {
  max-width: 1024px;
  margin: auto;
  position: relative;
}

.bg-white {
  background-color: #fff;
}
.pad-side-14 {
  padding: 0 14px !important;
}
.pdf-not-work {
  padding: 140px 20px 0;
}

'''
'''--- frontend/src/index.css ---
body {
  margin: 0;
  /* font-family: "Now Light"
    sans-serif; */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  /* font-family: "Now Light", monospace; */
}

'''
'''--- frontend/src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- frontend/src/react-app-env.d.ts ---
/// <reference types="react-scripts" />

'''
'''--- frontend/src/reportWebVitals.ts ---
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- frontend/src/responsive.css ---
@media only screen and (max-width: 1042px) {
  html {
    overflow-x: hidden;
  }
  .homepage .wrap-total {
    margin: 0 20px;
  }
  .header {
    padding: 0 20px;
  }
}
@media only screen and (max-width: 1024px) {
  .introduce-page .section-2 .flex,
  .introduce-page .section-2 .flex-side {
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding-bottom: 0;
  }

  .introduce-page .section-2 .flex-side .flex-side__side {
    padding-bottom: 100px;
  }

  .introduce-page .section-2.section-top .content {
    margin: 0;
    text-align: center;
    max-width: unset;
  }
}
@media screen and (max-width: 820px) {
  /* .homepage .wrap-market .title {
    position: absolute;
  } */

  #wrap-header-menu {
    background-color: var(--origin-black);
  }

  #wrap-header-menu .hamburger {
    font-size: 30px;
    position: fixed;
    top: 20px;
    right: 30px;
  }

  #wrap-header-menu .container {
    width: 100%;
    /* justify-content: center; */
    margin: auto;
    display: block;
    text-align: center;
  }

  #wrap-header-menu nav {
    display: none;
    min-height: 100vh;
    margin-top: 24px;
  }

  #wrap-header-menu nav.active {
    display: block;
  }

  #wrap-header-menu nav ul {
    display: flex;
    flex-direction: column;
  }
  #wrap-header-menu nav ul li {
    margin: 12px;
  }

  .homepage .wrap-market {
    max-height: 520px;
  }

  .homepage .wrap-market .pools {
    max-height: 300px;
    overflow-y: scroll;
    padding-bottom: 100px;
  }
  .App {
    padding-bottom: 0;
  }

  .waveWrapperInner {
    width: 250%;
    bottom: -15px;
  }
  .wrap-popup .popup {
    top: 50%;
  }

  .wrap-popup .popup .wrap-white {
    padding: 17px 0;
    background-color: #fff;
  }

  .Wave {
    width: auto;
  }
  .roadmap .section-bot .title,
  .introduce-page .section-2 .title,
  .introduce-page .social-media .title {
    font-size: 34px;
  }

  .introduce-page .section-2 .title {
    padding-bottom: 0;
  }

  .portforlio {
  }
  .portforlio .token__logo {
    flex-direction: column;
  }
  .portforlio .label__token-mini .token_name {
    display: none;
  }

  .portforlio .token__logo img {
    margin: auto;
  }
}

@media only screen and (max-width: 767px) {
  .introduce-page .head {
    background: url("./images/globe-block.png") no-repeat center bottom / cover;
  }
  .introduce-page .head .logo {
    /* display: none; */
    max-width: 320px;
    max-height: 320px;
  }
  .introduce-page .head h2 {
    top: 50%;
    width: auto;
    font-size: 54px;
  }

  .introduce-page .section-2 {
    padding: 100px 20px;
  }
  .introduce-page .section-2 .flex,
  .introduce-page .section-2.section-3 .flex {
    flex-direction: column;
  }

  .introduce-page .section-2.section-3 .content,
  .introduce-page .section-2 .content {
    text-align: center;
  }
  .introduce-page .section-2 .last {
    padding-top: 40px;
  }

  .roadmap {
    padding: 40px 0;
  }

  .roadmap .ship-1 {
    position: relative;
    top: -10px;
    left: 30px;
  }
  .roadmap .ship-2 {
    position: relative;
    text-align: right;
    right: 20px;
    top: 0;
    margin-bottom: -70px;
  }

  .roadmap .section-top .text {
    text-align: left;
  }
  .roadmap .section-top .col .content {
    width: auto;
    margin: 40px 14px;
  }

  .roadmap .section-bot {
    padding: 40px 0 80px;
  }
  .roadmap .section-bot .title {
    /* text-align: left; */
    margin: 0 14px 44px;
  }

  .roadmap .wrap-line::before,
  .roadmap .wrap-line .wrap .planet {
    left: 10%;
    height: 100%;
  }

  .roadmap .wrap-line .phase,
  .roadmap .wrap-line .phase.left {
    width: auto;
    margin: 0 14px 0 23%;
  }

  .roadmap .wrap-line .wrap {
    padding-bottom: 60px;
  }
  .roadmap .wrap-line .phase.right h4 {
    right: auto;
  }

  .roadmap .wrap-line .phase.right {
    text-align: left;
  }

  .roadmap .wrap-line .phase h4 {
    margin-bottom: 14px;
    position: relative;
    left: auto;
    right: auto;
    width: auto;
    display: inline-block;
  }

  /* Popup */
  .wrap-popup .popup {
    /* min-width: 100%; */
    max-width: 400px;
    margin: 0;
  }
  .popup-open {
    overflow: hidden;
  }
  /* end Popup */
}

@media only screen and (max-width: 600px) {
  .introduce-page .section-2 .flex-side .img {
    height: 320px;
  }

  .portforlio .token-list {
    flex-direction: column;
  }

  .portforlio .token-list .side {
    width: 100%;
    margin-bottom: 45px;
  }
  .portforlio .token-list::before {
    content: none;
  }
}
@media only screen and (max-width: 475px) {
  /* Popup */
  .wrap-popup .popup {
    min-width: 100%;
    max-width: 400px;
    margin: 0;
  }
  .wrap-popup .popup .info p {
    width: 50%;
  }
  /* end Popup */

  .introduce-page .social-media .list-social {
    flex-direction: column;
    align-items: center;
  }
  .introduce-page .social-media .list-social .link {
    margin-bottom: 30px;
  }

  .homepage .wrap-total {
    display: block;
    margin: 0 20px;
    text-align: center;
  }

  .homepage .wrap-total .total.deposit {
    border-bottom: 1px solid var(--white);
  }
}

'''
'''--- frontend/src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''
'''--- frontend/src/types/images.d.ts ---
declare global {
    interface Window {
      api?: any;
      ReactNativeWebView?: any;
      opera?: any;
      document?:any;
    }
  }
  declare module "*.pdf";
  declare module "*.jpg";
  declare module "*.jpeg";
  declare module "*.svg";
  declare module "*.png" {
    const value: any;
    export = value;
  }
  declare module "rimble-ui";
  declare module "react-jazzicon";
  declare module "qrcode";
  declare module "uuid";
  declare module "nprogress";
  declare module "lodash";
  declare module "react-tabs";
'''
'''--- frontend/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src", "src/types"]
}

'''
'''--- frontend/webpack.config.js ---
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [new HtmlWebpackPlugin()],
};
'''
'''--- git_push.sh ---
git pull
git status
git add *
git commit -m "Update"
git push
'''
'''--- references/ft-lockup-contract/trunk/Cargo.toml ---
[package]
name = "ft-lockup"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = { version = "0.9.0", default-features = false }

[dev-dependencies]
near-sdk-sim = "3.2.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/ft-lockup-contract/trunk/README.md ---
# Fungible Token Lockup contract

## Features

- A reusable lockup contract for a select fungible token.
- Lockup schedule can be set as a list of checkpoints with time and balance.
- Supports multiple lockups per account ID.
- Ability to create a lockup that can be terminated
  - A single lockup can be only terminated by a specific account ID.
  - Supports custom vesting schedule that should be ahead of the lockup schedule
  - The vesting schedule can be hidden behind a hash, so it only needs to be revealed in case of termnation.
- Automatic rollbacks if a FT transfer fails.
- Claiming all account's lockups in a single transaction.
- Ability to add new lockups.
- Whitelist for the accounts that can create new lockups.

'''
'''--- references/ft-lockup-contract/trunk/build.sh ---
#!/bin/bash
set -e
pushd "$(dirname $0)"

# Removing rlib for contract building
perl -i -pe 's/\["cdylib", "rlib"\]/\["cdylib"\]/' Cargo.toml

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./res
cp target/wasm32-unknown-unknown/release/ft_lockup.wasm ./res/

# Restoring rlib
perl -i -pe 's/\["cdylib"\]/\["cdylib", "rlib"\]/' Cargo.toml
popd

'''
'''--- references/ft-lockup-contract/trunk/src/callbacks.rs ---
use crate::*;

trait SelfCallbacks {
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        lockup_claims: Vec<LockupClaim>,
    ) -> WrappedBalance;

    fn after_lockup_termination(
        &mut self,
        account_id: AccountId,
        amount: WrappedBalance,
    ) -> WrappedBalance;
}

#[near_bindgen]
impl SelfCallbacks for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        lockup_claims: Vec<LockupClaim>,
    ) -> WrappedBalance {
        let promise_success = is_promise_success();
        let mut total_balance = 0;
        if promise_success {
            let mut remove_indices = vec![];
            for LockupClaim {
                index,
                is_final,
                unclaimed_balance,
            } in lockup_claims
            {
                if is_final {
                    remove_indices.push(index);
                }
                total_balance += unclaimed_balance.0;
            }
            if !remove_indices.is_empty() {
                let mut indices = self.account_lockups.get(&account_id).unwrap_or_default();
                for index in remove_indices {
                    indices.remove(&index);
                }
                self.internal_save_account_lockups(&account_id, indices);
            }
        } else {
            log!("Token transfer has failed. Refunding.");
            let mut modified = false;
            let mut indices = self.account_lockups.get(&account_id).unwrap_or_default();
            for LockupClaim {
                index,
                unclaimed_balance,
                ..
            } in lockup_claims
            {
                if indices.insert(index) {
                    modified = true;
                }
                let mut lockup = self.lockups.get(index as _).unwrap();
                lockup.claimed_balance -= unclaimed_balance.0;
                self.lockups.replace(index as _, &lockup);
            }

            if modified {
                self.internal_save_account_lockups(&account_id, indices);
            }
        }
        total_balance.into()
    }

    #[private]
    fn after_lockup_termination(
        &mut self,
        account_id: AccountId,
        amount: WrappedBalance,
    ) -> WrappedBalance {
        let promise_success = is_promise_success();
        if !promise_success {
            log!("Lockup termination transfer has failed.");
            // There is no internal balance, so instead we create a new lockup.
            let lockup = Lockup::new_unlocked(account_id, amount.0);
            let lockup_index = self.internal_add_lockup(&lockup);
            log!(
                "Generated a new lockup #{} as a refund of {} for account {}",
                lockup_index,
                amount.0,
                lockup.account_id.as_ref(),
            );
            0.into()
        } else {
            amount
        }
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/ft_token_receiver.rs ---
use crate::*;

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            env::predecessor_account_id(),
            self.token_account_id,
            "Invalid token ID"
        );
        self.assert_deposit_whitelist(sender_id.as_ref());
        let lockup: Lockup = serde_json::from_str(&msg).expect("Expected Lockup as msg");
        let amount = amount.into();
        lockup.assert_new_valid(amount);
        let index = self.internal_add_lockup(&lockup);
        log!(
            "Created new lockup for {} with index {}",
            lockup.account_id.as_ref(),
            index
        );
        PromiseOrValue::Value(0.into())
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/internal.rs ---
use crate::*;

impl Contract {
    pub(crate) fn assert_deposit_whitelist(&self, account_id: &AccountId) {
        assert!(
            self.deposit_whitelist.contains(account_id),
            "Not in deposit whitelist"
        );
    }

    pub(crate) fn internal_add_lockup(&mut self, lockup: &Lockup) -> LockupIndex {
        let index = self.lockups.len() as LockupIndex;
        self.lockups.push(lockup);
        let mut indices = self
            .account_lockups
            .get(lockup.account_id.as_ref())
            .unwrap_or_default();
        indices.insert(index);
        self.internal_save_account_lockups(lockup.account_id.as_ref(), indices);
        index
    }

    pub(crate) fn internal_save_account_lockups(
        &mut self,
        account_id: &AccountId,
        indices: HashSet<LockupIndex>,
    ) {
        if indices.is_empty() {
            self.account_lockups.remove(account_id);
        } else {
            self.account_lockups.insert(account_id, &indices);
        }
    }

    pub(crate) fn internal_get_account_lockups(
        &self,
        account_id: &AccountId,
    ) -> Vec<(LockupIndex, Lockup)> {
        self.account_lockups
            .get(account_id)
            .unwrap_or_default()
            .into_iter()
            .map(|lockup_index| (lockup_index, self.lockups.get(lockup_index as _).unwrap()))
            .collect()
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/lib.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::maybestd::collections::HashSet;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, Vector};
use near_sdk::json_types::{Base58CryptoHash, ValidAccountId, WrappedBalance, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, serde_json,
    AccountId, Balance, BorshStorageKey, CryptoHash, Gas, PanicOnDefault, PromiseOrValue,
    Timestamp,
};

pub mod callbacks;
pub mod ft_token_receiver;
pub mod internal;
pub mod lockup;
pub mod schedule;
pub mod termination;
pub mod util;
pub mod view;

use crate::lockup::*;
use crate::schedule::*;
use crate::termination::*;
use crate::util::*;

near_sdk::setup_alloc!();

pub type TimestampSec = u32;
pub type TokenAccountId = AccountId;

const GAS_FOR_FT_TRANSFER: Gas = 15_000_000_000_000;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 20_000_000_000_000;

const ONE_YOCTO: Balance = 1;
const NO_DEPOSIT: Balance = 0;

uint::construct_uint! {
    pub struct U256(4);
}

#[ext_contract(ext_self)]
pub trait SelfCallbacks {
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        lockup_claims: Vec<LockupClaim>,
    ) -> WrappedBalance;

    fn after_lockup_termination(
        &mut self,
        account_id: AccountId,
        amount: WrappedBalance,
    ) -> WrappedBalance;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub token_account_id: TokenAccountId,

    pub lockups: Vector<Lockup>,

    pub account_lockups: LookupMap<AccountId, HashSet<LockupIndex>>,

    /// Account IDs that can create new lockups.
    pub deposit_whitelist: UnorderedSet<AccountId>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Lockups,
    AccountLockups,
    DepositWhitelist,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(token_account_id: ValidAccountId, deposit_whitelist: Vec<ValidAccountId>) -> Self {
        let mut deposit_whitelist_set = UnorderedSet::new(StorageKey::DepositWhitelist);
        deposit_whitelist_set.extend(deposit_whitelist.into_iter().map(|a| a.into()));
        Self {
            lockups: Vector::new(StorageKey::Lockups),
            account_lockups: LookupMap::new(StorageKey::AccountLockups),
            token_account_id: token_account_id.into(),
            deposit_whitelist: deposit_whitelist_set,
        }
    }

    pub fn claim(&mut self) -> PromiseOrValue<WrappedBalance> {
        let account_id = env::predecessor_account_id();
        let lockups = self.internal_get_account_lockups(&account_id);

        if lockups.is_empty() {
            return PromiseOrValue::Value(0.into());
        }

        let mut lockup_claims = vec![];
        let mut total_unclaimed_balance = 0;
        for (lockup_index, mut lockup) in lockups {
            let lockup_claim = lockup.claim(lockup_index);
            if lockup_claim.unclaimed_balance.0 > 0 {
                log!(
                    "Claiming {} form lockup #{}",
                    lockup_claim.unclaimed_balance.0,
                    lockup_index
                );
                total_unclaimed_balance += lockup_claim.unclaimed_balance.0;
                self.lockups.replace(lockup_index as _, &lockup);
                lockup_claims.push(lockup_claim);
            }
        }
        log!("Total claim {}", total_unclaimed_balance);

        if total_unclaimed_balance > 0 {
            ext_fungible_token::ft_transfer(
                account_id.clone(),
                total_unclaimed_balance.into(),
                Some(format!(
                    "Claiming unlocked {} balance from {}",
                    total_unclaimed_balance,
                    env::current_account_id()
                )),
                &self.token_account_id,
                ONE_YOCTO,
                GAS_FOR_FT_TRANSFER,
            )
            .then(ext_self::after_ft_transfer(
                account_id,
                lockup_claims,
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_AFTER_FT_TRANSFER,
            ))
            .into()
        } else {
            PromiseOrValue::Value(0.into())
        }
    }

    pub fn terminate(
        &mut self,
        lockup_index: LockupIndex,
        hashed_schedule: Option<Schedule>,
    ) -> PromiseOrValue<WrappedBalance> {
        let account_id = env::predecessor_account_id();
        let mut lockup = self
            .lockups
            .get(lockup_index as _)
            .expect("Lockup not found");
        let unvested_balance = lockup.terminate(&account_id, hashed_schedule);
        self.lockups.replace(lockup_index as _, &lockup);
        if unvested_balance > 0 {
            ext_fungible_token::ft_transfer(
                account_id.clone(),
                unvested_balance.into(),
                Some(format!("Terminated lockup #{}", lockup_index)),
                &self.token_account_id,
                ONE_YOCTO,
                GAS_FOR_FT_TRANSFER,
            )
            .then(ext_self::after_lockup_termination(
                account_id,
                unvested_balance.into(),
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_AFTER_FT_TRANSFER,
            ))
            .into()
        } else {
            PromiseOrValue::Value(0.into())
        }
    }

    #[payable]
    pub fn add_to_deposit_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_deposit_whitelist(&env::predecessor_account_id());
        self.deposit_whitelist.insert(account_id.as_ref());
    }

    #[payable]
    pub fn remove_from_deposit_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_deposit_whitelist(&env::predecessor_account_id());
        self.deposit_whitelist.remove(account_id.as_ref());
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/lockup.rs ---
use crate::*;
use std::convert::TryInto;

pub type LockupIndex = u32;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct LockupClaim {
    pub index: LockupIndex,
    pub unclaimed_balance: WrappedBalance,
    pub is_final: bool,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    not(target_arch = "wasm32"),
    derive(Debug, PartialEq, Clone, Serialize)
)]
pub struct Lockup {
    pub account_id: ValidAccountId,
    pub schedule: Schedule,

    #[serde(default)]
    #[serde(with = "u128_dec_format")]
    pub claimed_balance: Balance,
    /// An optional configuration that allows vesting/lockup termination.
    pub termination_config: Option<TerminationConfig>,
}

impl Lockup {
    pub fn new_unlocked(account_id: AccountId, total_balance: Balance) -> Self {
        Self {
            account_id: account_id.try_into().unwrap(),
            schedule: Schedule::new_unlocked(total_balance),
            claimed_balance: 0,
            termination_config: None,
        }
    }

    pub fn claim(&mut self, index: LockupIndex) -> LockupClaim {
        let unlocked_balance = self.schedule.unlocked_balance(current_timestamp_sec());
        assert!(unlocked_balance >= self.claimed_balance, "Invariant");
        let unclaimed_balance = unlocked_balance - self.claimed_balance;
        self.claimed_balance = unlocked_balance;
        LockupClaim {
            index,
            unclaimed_balance: unclaimed_balance.into(),
            is_final: unlocked_balance == self.schedule.total_balance(),
        }
    }

    pub fn assert_new_valid(&self, total_balance: Balance) {
        assert_eq!(
            self.claimed_balance, 0,
            "The initial lockup claimed balance should be 0"
        );
        self.schedule.assert_valid(total_balance);

        if let Some(termination_config) = &self.termination_config {
            match &termination_config.vesting_schedule {
                None => {
                    // Ok, using lockup schedule.
                }
                Some(HashOrSchedule::Hash(_hash)) => {
                    // Ok, using unknown hash. Can't verify.
                }
                Some(HashOrSchedule::Schedule(schedule)) => {
                    schedule.assert_valid(total_balance);
                    self.schedule.assert_valid_termination_schedule(&schedule);
                }
            }
        }
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/schedule.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct Checkpoint {
    /// The unix-timestamp in seconds since the epoch.
    pub timestamp: TimestampSec,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
pub struct Schedule(pub Vec<Checkpoint>);

impl Schedule {
    pub fn new_unlocked(total_balance: Balance) -> Self {
        Self(vec![
            Checkpoint {
                timestamp: 0,
                balance: 0,
            },
            Checkpoint {
                timestamp: 1,
                balance: total_balance,
            },
        ])
    }

    pub fn assert_valid(&self, total_balance: Balance) {
        assert!(self.0.len() >= 2, "At least two checkpoints is required");
        assert_eq!(
            self.0.first().unwrap().balance,
            0,
            "The first checkpoint balance should be 0"
        );
        for i in 1..self.0.len() {
            assert!(self.0[i - 1].timestamp < self.0[i].timestamp, "The timestamp of checkpoint #{} should be less than the timestamp of the next checkpoint", i - 1);
            assert!(self.0[i - 1].balance <= self.0[i].balance, "The balance of checkpoint #{} should be not greater than the balance of the next checkpoint", i - 1);
        }
        assert_eq!(
            self.total_balance(),
            total_balance,
            "The schedule's total balance doesn't match the transferred balance"
        );
    }

    /// Verifies that this schedule is ahead of the given termination schedule at any point of time.
    /// Assumes they have equal total balance and both schedules are valid.
    pub fn assert_valid_termination_schedule(&self, termination_schedule: &Schedule) {
        for checkpoint in &self.0 {
            assert!(
                checkpoint.balance <= termination_schedule.unlocked_balance(checkpoint.timestamp),
                "The lockup schedule is ahead of the termination schedule at timestamp {}",
                checkpoint.timestamp
            );
        }
        for checkpoint in &termination_schedule.0 {
            assert!(
                checkpoint.balance >= self.unlocked_balance(checkpoint.timestamp),
                "The lockup schedule is ahead of the termination schedule at timestamp {}",
                checkpoint.timestamp
            );
        }
    }

    pub fn unlocked_balance(&self, current_timestamp: TimestampSec) -> Balance {
        // Using binary search by time to find the current checkpoint.
        let index = match self
            .0
            .binary_search_by_key(&current_timestamp, |checkpoint| checkpoint.timestamp)
        {
            // Exact timestamp found
            Ok(index) => index,
            // No match, the next index is given.
            Err(index) => {
                if index == 0 {
                    // Not started
                    return 0;
                }
                index - 1
            }
        };
        let checkpoint = &self.0[index];
        if index + 1 == self.0.len() {
            // The last checkpoint. Fully unlocked.
            return checkpoint.balance;
        }
        let next_checkpoint = &self.0[index + 1];

        let total_duration = next_checkpoint.timestamp - checkpoint.timestamp;
        let passed_duration = current_timestamp - checkpoint.timestamp;
        checkpoint.balance
            + (U256::from(passed_duration)
                * U256::from(next_checkpoint.balance - checkpoint.balance)
                / U256::from(total_duration))
            .as_u128()
    }

    pub fn total_balance(&self) -> Balance {
        self.0.last().unwrap().balance
    }

    /// Terminates the lockup schedule earlier.
    /// Assumes new_total_balance is not greater than the current total balance.
    pub fn terminate(&mut self, new_total_balance: Balance) {
        if new_total_balance == 0 {
            self.0 = Self::new_unlocked(0).0;
            return;
        }
        assert!(
            new_total_balance <= self.0.last().unwrap().balance,
            "Invariant"
        );
        while let Some(checkpoint) = self.0.pop() {
            if self.0.last().unwrap().balance < new_total_balance {
                let prev_checkpoint = self.0.last().unwrap().clone();
                let timestamp_diff = checkpoint.timestamp - prev_checkpoint.timestamp;
                let balance_diff = checkpoint.balance - prev_checkpoint.balance;
                let required_balance_diff = new_total_balance - prev_checkpoint.balance;
                // Computing the new timestamp rounding up
                let new_timestamp = ((U256::from(timestamp_diff)
                    * U256::from(required_balance_diff)
                    + U256::from(balance_diff - 1))
                    / U256::from(balance_diff))
                .as_u32();
                self.0.push(Checkpoint {
                    timestamp: new_timestamp,
                    balance: new_total_balance,
                });
                return;
            }
        }
        unreachable!();
    }

    pub fn hash(&self) -> CryptoHash {
        let value_hash = env::sha256(&self.try_to_vec().unwrap());
        let mut res = CryptoHash::default();
        res.copy_from_slice(&value_hash);

        res
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/termination.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
pub enum HashOrSchedule {
    Hash(Base58CryptoHash),
    Schedule(Schedule),
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
pub struct TerminationConfig {
    /// The account ID that can terminate vesting.
    pub terminator_id: ValidAccountId,
    /// An optional vesting schedule
    pub vesting_schedule: Option<HashOrSchedule>,
}

impl Lockup {
    pub fn terminate(
        &mut self,
        initiator_id: &AccountId,
        hashed_schedule: Option<Schedule>,
    ) -> Balance {
        let termination_config = self
            .termination_config
            .take()
            .expect("No termination config");
        assert_eq!(
            termination_config.terminator_id.as_ref(),
            initiator_id,
            "Unauthorized"
        );
        let total_balance = self.schedule.total_balance();
        let current_timestamp = current_timestamp_sec();
        let vested_balance = match &termination_config.vesting_schedule {
            None => &self.schedule,
            Some(HashOrSchedule::Hash(hash)) => {
                let schedule = hashed_schedule
                    .as_ref()
                    .expect("Revealed schedule required for the termination");
                let hash: CryptoHash = (*hash).into();
                assert_eq!(
                    hash,
                    schedule.hash(),
                    "The revealed schedule hash doesn't match"
                );
                schedule.assert_valid(total_balance);
                self.schedule.assert_valid_termination_schedule(schedule);
                schedule
            }
            Some(HashOrSchedule::Schedule(schedule)) => &schedule,
        }
        .unlocked_balance(current_timestamp);
        let unvested_balance = total_balance - vested_balance;
        if unvested_balance > 0 {
            self.schedule.terminate(vested_balance);
        }
        unvested_balance
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/util.rs ---
use crate::*;

pub(crate) fn nano_to_sec(timestamp: Timestamp) -> TimestampSec {
    (timestamp / 10u64.pow(9)) as _
}

pub(crate) fn current_timestamp_sec() -> TimestampSec {
    nano_to_sec(env::block_timestamp())
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

'''
'''--- references/ft-lockup-contract/trunk/src/view.rs ---
use crate::*;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Deserialize))]
pub struct LockupView {
    pub account_id: ValidAccountId,
    pub schedule: Schedule,

    #[serde(default)]
    #[serde(with = "u128_dec_format")]
    pub claimed_balance: Balance,
    /// An optional configuration that allows vesting/lockup termination.
    pub termination_config: Option<TerminationConfig>,

    #[serde(with = "u128_dec_format")]
    pub total_balance: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_balance: Balance,
    /// The current timestamp
    pub timestamp: TimestampSec,
}

impl From<Lockup> for LockupView {
    fn from(lockup: Lockup) -> Self {
        let total_balance = lockup.schedule.total_balance();
        let timestamp = current_timestamp_sec();
        let unclaimed_balance =
            lockup.schedule.unlocked_balance(timestamp) - lockup.claimed_balance;
        let Lockup {
            account_id,
            schedule,
            claimed_balance,
            termination_config,
        } = lockup;
        Self {
            account_id,
            schedule,
            claimed_balance,
            termination_config,
            total_balance,
            unclaimed_balance,
            timestamp,
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_account_lockups(
        &self,
        account_id: ValidAccountId,
    ) -> Vec<(LockupIndex, LockupView)> {
        self.internal_get_account_lockups(account_id.as_ref())
            .into_iter()
            .map(|(lockup_index, lockup)| (lockup_index, lockup.into()))
            .collect()
    }

    pub fn get_lockup(&self, index: LockupIndex) -> Option<LockupView> {
        self.lockups.get(index as _).map(|lockup| lockup.into())
    }

    pub fn get_lockups(&self, indices: Vec<LockupIndex>) -> Vec<(LockupIndex, LockupView)> {
        indices
            .into_iter()
            .filter_map(|index| self.get_lockup(index).map(|lockup| (index, lockup)))
            .collect()
    }

    pub fn get_num_lockups(&self) -> u32 {
        self.lockups.len() as _
    }

    pub fn get_lockups_paged(
        &self,
        from_index: Option<LockupIndex>,
        limit: Option<LockupIndex>,
    ) -> Vec<(LockupIndex, LockupView)> {
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(self.get_num_lockups());
        (from_index..std::cmp::min(self.get_num_lockups(), limit))
            .filter_map(|index| self.get_lockup(index).map(|lockup| (index, lockup)))
            .collect()
    }

    pub fn get_deposit_whitelist(&self) -> Vec<AccountId> {
        self.deposit_whitelist.to_vec()
    }

    pub fn hash_schedule(schedule: Schedule) -> Base58CryptoHash {
        schedule.hash().into()
    }

    pub fn validate_schedule(
        schedule: Schedule,
        total_balance: WrappedBalance,
        termination_schedule: Option<Schedule>,
    ) {
        schedule.assert_valid(total_balance.0);
        if let Some(termination_schedule) = termination_schedule {
            termination_schedule.assert_valid(total_balance.0);
            schedule.assert_valid_termination_schedule(&termination_schedule);
        }
    }
}

'''
'''--- references/ft-lockup-contract/trunk/tests/main.rs ---
mod setup;

use crate::setup::*;
use ft_lockup::lockup::Lockup;
use ft_lockup::schedule::{Checkpoint, Schedule};
use near_sdk::json_types::WrappedBalance;

const ONE_DAY_SEC: TimestampSec = 24 * 60 * 60;
const ONE_YEAR_SEC: TimestampSec = 365 * ONE_DAY_SEC;

const GENESIS_TIMESTAMP_SEC: TimestampSec = 1_600_000_000;

#[test]
fn test_init_env() {
    let e = Env::init(None);
    let _users = Users::init(&e);
}

#[test]
fn test_lockup_claim_logic() {
    let e = Env::init(None);
    let users = Users::init(&e);
    let amount = d(10000, TOKEN_DECIMALS);
    e.set_time_sec(GENESIS_TIMESTAMP_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());
    let lockup = Lockup {
        account_id: users.alice.valid_account_id(),
        schedule: Schedule(vec![
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC - 1,
                balance: 0,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC,
                balance: amount,
            },
        ]),
        claimed_balance: 0,
        termination_config: None,
    };
    let balance: WrappedBalance = e.add_lockup(&e.owner, amount, &lockup).unwrap_json();
    assert_eq!(balance.0, amount);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups.len(), 1);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // Claim attempt before unlock.
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, 0);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, 0);

    // Set time to the first checkpoint.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC - 1);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // Set time to the second checkpoint.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, amount);

    // Attempt to claim. No storage deposit for Alice.
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, 0);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, amount);

    ft_storage_deposit(&users.alice, TOKEN_ID, &users.alice.account_id);

    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, 0);

    // Claim tokens.
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount);
    // User's lockups should be empty, since fully claimed.
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());

    // Manually checking the lockup by index
    let lockup = e.get_lockup(0);
    assert_eq!(lockup.claimed_balance, amount);
    assert_eq!(lockup.unclaimed_balance, 0);

    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount);
}

#[test]
fn test_lockup_linear() {
    let e = Env::init(None);
    let users = Users::init(&e);
    let amount = d(60000, TOKEN_DECIMALS);
    e.set_time_sec(GENESIS_TIMESTAMP_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());
    let lockup = Lockup {
        account_id: users.alice.valid_account_id(),
        schedule: Schedule(vec![
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC,
                balance: 0,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC,
                balance: amount,
            },
        ]),
        claimed_balance: 0,
        termination_config: None,
    };
    let balance: WrappedBalance = e.add_lockup(&e.owner, amount, &lockup).unwrap_json();
    assert_eq!(balance.0, amount);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups.len(), 1);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // 1/3 unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 3);

    // Claim tokens
    ft_storage_deposit(&users.alice, TOKEN_ID, &users.alice.account_id);
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount / 3);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount / 3);

    // Check lockup after claim
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, amount / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // 1/2 unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC / 2);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, amount / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 6);

    // Remove storage from token to verify claim refund.
    // Note, this burns `amount / 3` tokens.
    storage_force_unregister(&users.alice, TOKEN_ID);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, 0);

    // Trying to claim, should fail and refund the amount back to the lockup
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, 0);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, amount / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 6);

    // Claim again but with storage deposit
    ft_storage_deposit(&users.alice, TOKEN_ID, &users.alice.account_id);
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount / 6);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount / 6);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, amount / 2);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // 2/3 unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 2 / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, amount / 2);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 6);

    // Claim tokens
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount / 6);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, amount * 2 / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // Claim again with no unclaimed_balance
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, 0);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, amount * 2 / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // full unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.claimed_balance, amount * 2 / 3);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 3);

    // Final claim
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount / 3);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount * 2 / 3);

    // User's lockups should be empty, since fully claimed.
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());

    // Manually checking the lockup by index
    let lockup = e.get_lockup(0);
    assert_eq!(lockup.claimed_balance, amount);
    assert_eq!(lockup.unclaimed_balance, 0);
}

#[test]
fn test_lockup_cliff_amazon() {
    let e = Env::init(None);
    let users = Users::init(&e);
    let amount = d(60000, TOKEN_DECIMALS);
    e.set_time_sec(GENESIS_TIMESTAMP_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());
    let lockup = Lockup {
        account_id: users.alice.valid_account_id(),
        schedule: Schedule(vec![
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC - 1,
                balance: 0,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC,
                balance: amount / 10,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 2,
                balance: 3 * amount / 10,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 3,
                balance: 6 * amount / 10,
            },
            Checkpoint {
                timestamp: GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 4,
                balance: amount,
            },
        ]),
        claimed_balance: 0,
        termination_config: None,
    };
    let balance: WrappedBalance = e.add_lockup(&e.owner, amount, &lockup).unwrap_json();
    assert_eq!(balance.0, amount);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups.len(), 1);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // 1/12 time. pre-cliff unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, 0);

    // 1/4 time. cliff unlock
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.total_balance, amount);
    assert_eq!(lockups[0].1.claimed_balance, 0);
    assert_eq!(lockups[0].1.unclaimed_balance, amount / 10);

    // 3/8 time. cliff unlock + 1/2 of 2nd year.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC + ONE_YEAR_SEC / 2);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 2 * amount / 10);

    // 1/2 time.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 2);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 3 * amount / 10);

    // 1/2 + 1/12 time.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 2 + ONE_YEAR_SEC / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 4 * amount / 10);

    // 1/2 + 2/12 time.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 2 + ONE_YEAR_SEC * 2 / 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 5 * amount / 10);

    // 3/4 time.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 3);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 6 * amount / 10);

    // 7/8 time.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 3 + ONE_YEAR_SEC / 2);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, 8 * amount / 10);

    // full unlock.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 4);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, amount);

    // after unlock.
    e.set_time_sec(GENESIS_TIMESTAMP_SEC + ONE_YEAR_SEC * 5);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, amount);

    // attempt to claim without storage.
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, 0);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, 0);
    let lockups = e.get_account_lockups(&users.alice);
    assert_eq!(lockups[0].1.unclaimed_balance, amount);

    // Claim tokens
    ft_storage_deposit(&users.alice, TOKEN_ID, &users.alice.account_id);
    let res: WrappedBalance = e.claim(&users.alice).unwrap_json();
    assert_eq!(res.0, amount);
    let balance = e.ft_balance_of(&users.alice);
    assert_eq!(balance, amount);

    // Check lockup after claim
    let lockups = e.get_account_lockups(&users.alice);
    assert!(lockups.is_empty());
    let lockup = e.get_lockup(0);
    assert_eq!(lockup.claimed_balance, amount);
    assert_eq!(lockup.unclaimed_balance, 0);
}

'''
'''--- references/ft-lockup-contract/trunk/tests/setup.rs ---
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_sdk::json_types::{ValidAccountId, WrappedBalance};
use near_sdk::serde_json::json;
use near_sdk::{env, serde_json, Balance, Gas, Timestamp};
use near_sdk_sim::runtime::GenesisConfig;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

pub use ft_lockup::lockup::{Lockup, LockupIndex};
use ft_lockup::view::LockupView;
pub use ft_lockup::{ContractContract as FtLockupContract, TimestampSec};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FT_LOCKUP_WASM_BYTES => "res/ft_lockup.wasm",
    FUNGIBLE_TOKEN_WASM_BYTES => "res/fungible_token.wasm",
}

pub const NEAR: &str = "near";
pub const TOKEN_ID: &str = "token.near";
pub const FT_LOCKUP_ID: &str = "ft-lockup.near";
pub const OWNER_ID: &str = "owner.near";

pub const T_GAS: Gas = 10u64.pow(12);
pub const DEFAULT_GAS: Gas = 15 * T_GAS;
pub const MAX_GAS: Gas = 300 * T_GAS;
pub const CLAIM_GAS: Gas = 100 * T_GAS;

pub const TOKEN_DECIMALS: u8 = 18;
pub const TOKEN_TOTAL_SUPPLY: Balance = d(1_000_000, TOKEN_DECIMALS);

pub struct Env {
    pub root: UserAccount,
    pub near: UserAccount,
    pub owner: UserAccount,
    pub contract: ContractAccount<FtLockupContract>,
    pub token: UserAccount,
}

pub struct Users {
    pub alice: UserAccount,
    pub bob: UserAccount,
    pub charlie: UserAccount,
    pub dude: UserAccount,
    pub eve: UserAccount,
}

pub fn storage_deposit(
    user: &UserAccount,
    contract_id: &str,
    account_id: &str,
    attached_deposit: Balance,
) {
    user.call(
        contract_id.to_string(),
        "storage_deposit",
        &json!({ "account_id": account_id }).to_string().into_bytes(),
        DEFAULT_GAS,
        attached_deposit,
    )
    .assert_success();
}

pub fn storage_force_unregister(user: &UserAccount, contract_id: &str) {
    user.call(
        contract_id.to_string(),
        "storage_unregister",
        &json!({ "force": true }).to_string().into_bytes(),
        DEFAULT_GAS,
        1,
    )
    .assert_success();
}

pub fn ft_storage_deposit(user: &UserAccount, token_account_id: &str, account_id: &str) {
    storage_deposit(
        user,
        token_account_id,
        account_id,
        125 * env::STORAGE_PRICE_PER_BYTE,
    );
}

pub fn to_nano(timestamp: u32) -> Timestamp {
    Timestamp::from(timestamp) * 10u64.pow(9)
}

impl Env {
    pub fn init(deposit_whitelist: Option<Vec<ValidAccountId>>) -> Self {
        let mut genesis_config = GenesisConfig::default();
        genesis_config.block_prod_time = 0;
        let root = init_simulator(Some(genesis_config));
        let near = root.create_user(NEAR.to_string(), to_yocto("1000000"));
        let owner = near.create_user(OWNER_ID.to_string(), to_yocto("10000"));

        let token = near.deploy_and_init(
            &FUNGIBLE_TOKEN_WASM_BYTES,
            TOKEN_ID.to_string(),
            "new",
            &json!({
                "owner_id": owner.valid_account_id(),
                "total_supply": WrappedBalance::from(TOKEN_TOTAL_SUPPLY),
                "metadata": FungibleTokenMetadata {
                    spec: FT_METADATA_SPEC.to_string(),
                    name: "Token".to_string(),
                    symbol: "TOKEN".to_string(),
                    icon: None,
                    reference: None,
                    reference_hash: None,
                    decimals: TOKEN_DECIMALS,
                }
            })
            .to_string()
            .into_bytes(),
            to_yocto("10"),
            DEFAULT_GAS,
        );

        let contract = deploy!(
            contract: FtLockupContract,
            contract_id: FT_LOCKUP_ID.to_string(),
            bytes: &FT_LOCKUP_WASM_BYTES,
            signer_account: near,
            deposit: to_yocto("10"),
            gas: DEFAULT_GAS,
            init_method: new(
                token.valid_account_id(),
                deposit_whitelist.unwrap_or_else(|| vec![owner.valid_account_id()])
            )
        );

        ft_storage_deposit(&owner, TOKEN_ID, FT_LOCKUP_ID);

        Self {
            root,
            near,
            owner,
            contract,
            token,
        }
    }

    pub fn ft_transfer_call(
        &self,
        user: &UserAccount,
        amount: Balance,
        msg: &str,
    ) -> ExecutionResult {
        user.call(
            self.token.account_id.clone(),
            "ft_transfer_call",
            &json!({
                "receiver_id": self.contract.user_account.valid_account_id(),
                "amount": WrappedBalance::from(amount),
                "msg": msg,
            })
            .to_string()
            .into_bytes(),
            MAX_GAS,
            1,
        )
    }

    pub fn add_lockup(
        &self,
        user: &UserAccount,
        amount: Balance,
        lockup: &Lockup,
    ) -> ExecutionResult {
        self.ft_transfer_call(user, amount, &serde_json::to_string(lockup).unwrap())
    }

    pub fn claim(&self, user: &UserAccount) -> ExecutionResult {
        user.function_call(self.contract.contract.claim(), CLAIM_GAS, 0)
    }

    pub fn get_account_lockups(&self, user: &UserAccount) -> Vec<(LockupIndex, LockupView)> {
        self.near
            .view_method_call(
                self.contract
                    .contract
                    .get_account_lockups(user.valid_account_id()),
            )
            .unwrap_json()
    }

    pub fn get_lockup(&self, lockup_index: LockupIndex) -> LockupView {
        let lockup: Option<LockupView> = self
            .near
            .view_method_call(self.contract.contract.get_lockup(lockup_index))
            .unwrap_json();
        lockup.unwrap()
    }

    pub fn ft_balance_of(&self, user: &UserAccount) -> Balance {
        let balance: WrappedBalance = self
            .near
            .view(
                self.token.account_id.clone(),
                "ft_balance_of",
                &json!({
                    "account_id": user.valid_account_id(),
                })
                .to_string()
                .into_bytes(),
            )
            .unwrap_json();
        balance.0
    }

    pub fn set_time_sec(&self, timestamp_sec: TimestampSec) {
        self.near.borrow_runtime_mut().cur_block.block_timestamp = to_nano(timestamp_sec);
    }
}

impl Users {
    pub fn init(e: &Env) -> Self {
        Self {
            alice: e
                .near
                .create_user("alice.near".to_string(), to_yocto("10000")),
            bob: e
                .near
                .create_user("bob.near".to_string(), to_yocto("10000")),
            charlie: e
                .near
                .create_user("charlie.near".to_string(), to_yocto("10000")),
            dude: e
                .near
                .create_user("dude.near".to_string(), to_yocto("10000")),
            eve: e
                .near
                .create_user("eve.near".to_string(), to_yocto("10000")),
        }
    }
}

pub const fn d(value: Balance, decimals: u8) -> Balance {
    value * 10u128.pow(decimals as _)
}

'''
'''--- references/ft-with-updatable-meta/trunk/Cargo.toml ---
[package]
name = "ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/ft-with-updatable-meta/trunk/build.sh ---
#!/bin/bash
set -e
pushd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./res
cp target/wasm32-unknown-unknown/release/ft.wasm ./res/

popd

'''
'''--- references/ft-with-updatable-meta/trunk/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    FungibleToken,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: ValidAccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(StorageKey::FungibleToken),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }

    #[private]
    pub fn update_metadata(&mut self, metadata: FungibleTokenMetadata) {
        metadata.assert_valid();
        self.metadata.set(&metadata);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- references/locked-ft/branches/ft-metadata/factory/Cargo.toml ---
[package]
name = "factory-locked-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/branches/ft-metadata/factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/factory_locked_ft.wasm ./res/main.wasm

'''
'''--- references/locked-ft/branches/ft-metadata/factory/deploy.txt ---
export CONTRACT_ID=dev-1632441018789-66705294329463

near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID && near call $CONTRACT_ID storage_deposit '{}' --accountId $CONTRACT_ID --deposit 10

near call $CONTRACT_ID whitelist_token '{"token_id": "wrap.testnet", "title": "NEAR", "decimals": 24}' --accountId $CONTRACT_ID

near call $CONTRACT_ID create_token '{"token_args": {"token_id": "wrap.testnet", "target_price": "60000", "metadata": {"spec": "ft-1.0.0", "name": "1", "symbol": "2", "decimals": 28}, "backup_trigger_account_id": "dev-1631912016116-42587207920552", "price_oracle_account_id": "dev-1631302633591-50236902542063" }}' --accountId $CONTRACT_ID --gas 200000000000000

near view $CONTRACT_ID get_token '{"token_id": "near_6"}'
near view near_6.$CONTRACT_ID get_info '{}'

near call dev-1631302633591-50236902542063 oracle_call '{"receiver_id": "near_6.'$CONTRACT_ID'","asset_ids": ["wrap.testnet"], "msg": ""}' --accountId $CONTRACT_ID --depositYocto 1
'''
'''--- references/locked-ft/branches/ft-metadata/factory/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::{
    AccountId, Balance, BorshStorageKey, env, ext_contract, Gas, log, near_bindgen, PanicOnDefault, Promise,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;

mod migrate;

near_sdk::setup_alloc!();

const FT_WASM_CODE: &[u8] = include_bytes!("../../token/res/locked_ft.wasm");

const EXTRA_BYTES: usize = 10000;
const GAS: Gas = 50_000_000_000_000;
const GAS_FT_METADATA_READ: Gas = 5_000_000_000_000;
const GAS_FT_METADATA_WRITE: Gas = 5_000_000_000_000;
const NO_DEPOSIT: Balance = 0;

type TokenId = String;

pub fn is_valid_symbol(token_id: &TokenId) -> bool {
    for c in token_id.as_bytes() {
        match c {
            b'0'..=b'9' | b'a'..=b'z' | b'_' | b'-' => (),
            _ => return false,
        }
    }
    true
}

#[ext_contract(ext_ft)]
pub trait ExtFT {
    /// Get FT metadata.
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[ext_contract(ext_self)]
pub trait ExtContract {
    /// Save FT metadata
    fn on_ft_metadata(
        &mut self,
        token_id: AccountId,
        asset_id: AccountId,
    );
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Tokens,
    StorageDeposits,
    WhitelistedTokens,
    WhitelistedTokensV1,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    pub tokens: UnorderedMap<TokenId, TokenArgs>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub storage_balance_cost: Balance,
    pub whitelisted_tokens: UnorderedMap<AccountId, WhitelistedToken>,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct WhitelistedToken {
    pub asset_id: String,
    pub metadata: FungibleTokenMetadata
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct InputTokenArgs {
    token_id: ValidAccountId,
    target_price: U128,
    backup_trigger_account_id: Option<AccountId>,
    price_oracle_account_id: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

pub type AssetId = String;
pub type TokenAccountId = AccountId;

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgs {
    pub locked_token_account_id: TokenAccountId,
    pub meta: FungibleTokenMetadata,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new() -> Self {
        let mut storage_deposits = LookupMap::new(StorageKey::StorageDeposits);

        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        storage_deposits.insert(&tmp_account_id, &0);
        let storage_balance_cost =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;
        storage_deposits.remove(&tmp_account_id);

        Self {
            tokens: UnorderedMap::new(StorageKey::Tokens),
            storage_deposits,
            storage_balance_cost,
            whitelisted_tokens: UnorderedMap::new(StorageKey::WhitelistedTokens),
        }
    }

    pub fn on_ft_metadata(
        &mut self,
        #[callback] ft_metadata: FungibleTokenMetadata,
        token_id: AccountId,
        asset_id: AssetId) {
        assert!(
            is_valid_symbol(&ft_metadata.name.to_ascii_lowercase()),
            "Invalid Token symbol"
        );

        self.whitelisted_tokens.insert(
            &(token_id.into()),
            &WhitelistedToken {
                asset_id: asset_id.into(),
                metadata: ft_metadata,
            },
        );
    }

    #[private]
    pub fn whitelist_token(
        &mut self,
        token_id: ValidAccountId,
        asset_id: ValidAccountId
    ) -> Promise {
            ext_ft::ft_metadata(
                &token_id,
                NO_DEPOSIT,
                GAS_FT_METADATA_READ,
            ).then(ext_self::on_ft_metadata(
                token_id.into(),
                asset_id.into(),
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FT_METADATA_WRITE,
            ))
    }

    fn get_min_attached_balance(&self, args: &TokenArgs) -> u128 {
        ((FT_WASM_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance
            * STORAGE_PRICE_PER_BYTE)
            .into()
    }

    #[payable]
    pub fn storage_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let deposit = env::attached_deposit();
        if let Some(previous_balance) = self.storage_deposits.get(&account_id) {
            self.storage_deposits
                .insert(&account_id, &(previous_balance + deposit));
        } else {
            assert!(deposit >= self.storage_balance_cost, "Deposit is too low");
            self.storage_deposits
                .insert(&account_id, &(deposit - self.storage_balance_cost));
        }
    }

    pub fn get_number_of_tokens(&self) -> u64 {
        self.tokens.len()
    }

    pub fn get_tokens(&self, from_index: u64, limit: u64) -> Vec<TokenArgs> {
        let tokens = self.tokens.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, tokens.len()))
            .filter_map(|index| tokens.get(index))
            .collect()
    }

    pub fn get_whitelisted_token_tickers(&self, from_index: u64, limit: u64) -> Vec<TokenAccountId> {
        let token_ids = self.whitelisted_tokens.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, token_ids.len()))
            .filter_map(|token_id| token_ids.get(token_id))
            .collect()
    }

    pub fn get_whitelisted_token(&self, token_id: TokenAccountId) -> (AccountId, FungibleTokenMetadata) {
        let token = self.whitelisted_tokens.get(&token_id).expect("Token not found");
        return (token.asset_id, token.metadata);
    }

    pub fn get_token(&self, token_id: TokenId) -> Option<TokenArgs> {
        self.tokens.get(&token_id)
    }

    #[payable]
    pub fn create_token(&mut self, token_args: InputTokenArgs) -> Promise {
        if env::attached_deposit() > 0 {
            self.storage_deposit();
        }

        let whitelisted_token = self
            .whitelisted_tokens
            .get(&(token_args.token_id.clone().into()))
            .expect("Token wasn't whitelisted");
        let token_name = TokenFactory::format_title(whitelisted_token.metadata.name.clone());
        let token_decimals = whitelisted_token.metadata.decimals;

        assert!(token_decimals > 0 && token_name != "", "Missing token metadata");

        let mut metadata = whitelisted_token.metadata;

        let minimum_unlock_price = Price {
            multiplier: token_args.target_price.0,
            decimals: token_decimals + 4,
        };

        let target_price_short: u128 = token_args.target_price.0 / 10000;
        let target_price_remainder: u128 = token_args.target_price.0 % 10000;

        let price = if target_price_remainder > 0 {
            format!("{}.{}", target_price_short, target_price_remainder)
        } else {
            format!("{}", target_price_short)
        };
        assert!(token_args.target_price.0 > 0, "Wrong target price");

        metadata.name = format!("{} at ${}", token_name, price);
        metadata.symbol = format!("{}@{}", token_name, price);

        metadata.assert_valid();

        let token_id = format!(
            "{}-{}-{:04}",
            token_name, target_price_short, target_price_remainder
        )
        .to_ascii_lowercase();

        let token_account_id = format!("{}.{}", token_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(token_account_id.as_bytes()),
            "Token Account ID is invalid"
        );

        let args: TokenArgs = TokenArgs {
            locked_token_account_id: token_args.token_id.clone().into(),
            meta: metadata,
            backup_trigger_account_id: token_args.backup_trigger_account_id.map(|a| a.into()),
            price_oracle_account_id: token_args.price_oracle_account_id.into(),
            asset_id: whitelisted_token.asset_id.clone(),
            minimum_unlock_price,
        };

        let account_id = env::predecessor_account_id();

        let required_balance = self.get_min_attached_balance(&args);
        let user_balance = self.storage_deposits.get(&account_id).unwrap_or(0);
        assert!(
            user_balance >= required_balance,
            "Not enough required balance"
        );
        self.storage_deposits
            .insert(&account_id, &(user_balance - required_balance));

        let initial_storage_usage = env::storage_usage();

        assert!(
            self.tokens.insert(&token_id, &args).is_none(),
            "Token ID {} is already taken",
            token_id
        );

        log!(
            "Creating token {} with asset {} at price {}",
            token_account_id,
            whitelisted_token.asset_id,
            price
        );

        let storage_balance_used =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;

        Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_WASM_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS)
    }

    fn format_title(s: String) -> String {
        s.chars().filter(|c| !c.is_whitespace()).collect()
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::serde::de;

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::serde::de;

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

'''
'''--- references/locked-ft/branches/ft-metadata/factory/src/migrate.rs ---
use crate::*;

#[near_bindgen]
impl TokenFactory {
    #[private]
    #[init(ignore_state)]
    #[allow(dead_code)]
    pub fn migrate_1() -> Self {
        #[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
        #[serde(crate = "near_sdk::serde")]
        pub struct WhitelistedTokenOld {
            pub title: String,
            pub asset_id: String,
            pub decimals: u8,
        }

        #[derive(BorshDeserialize)]
        pub struct TokenFactoryOld {
            pub tokens: UnorderedMap<TokenId, TokenArgs>,
            pub storage_deposits: LookupMap<AccountId, Balance>,
            pub storage_balance_cost: Balance,
            pub whitelisted_tokens: UnorderedMap<AccountId, WhitelistedTokenOld>,
        }

        let old_contract: TokenFactoryOld = env::state_read().expect("Old state doesn't exist");

        let mut whitelisted_tokens_new: UnorderedMap<AccountId, WhitelistedToken> = UnorderedMap::new(StorageKey::WhitelistedTokensV1);

        let token_ids = old_contract.whitelisted_tokens.keys_as_vector();
        for token_id in token_ids.to_vec() {
            if let Some(old_token) = old_contract.whitelisted_tokens.get(&token_id) {
                whitelisted_tokens_new.insert(&token_id,
                                              &WhitelistedToken {
                                                  asset_id: old_token.asset_id,
                                                  metadata: FungibleTokenMetadata {
                                                      spec: "ft-1.0.0".to_string(),
                                                      name: old_token.title,
                                                      symbol: "".to_string(),
                                                      icon: None,
                                                      reference: None,
                                                      reference_hash: None,
                                                      decimals: old_token.decimals,
                                                  },
                                              });
            }
        }

        TokenFactory {
            tokens: old_contract.tokens,
            storage_deposits: old_contract.storage_deposits,
            storage_balance_cost: old_contract.storage_balance_cost,
            whitelisted_tokens: whitelisted_tokens_new,
        }
    }
}

'''
'''--- references/locked-ft/branches/ft-metadata/token/Cargo.toml ---
[package]
name = "locked-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/branches/ft-metadata/token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/locked_ft.wasm ./res/

'''
'''--- references/locked-ft/branches/ft-metadata/token/src/lib.rs ---
mod price_receiver;

use crate::price_receiver::*;

use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue, Timestamp,
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;

pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    Locked,
    Unlocking {
        #[serde(with = "u64_dec_format")]
        initiated_timestamp: Timestamp,
    },
    Unlocked,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
    pub locked_token_account_id: TokenAccountId,
    pub status: Status,
}

near_contract_standards::impl_fungible_token_core!(Contract, ft, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        assert!(matches!(self.status, Status::Locked));
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        locked_token_account_id: ValidAccountId,
        meta: FungibleTokenMetadata,
        backup_trigger_account_id: Option<ValidAccountId>,
        price_oracle_account_id: ValidAccountId,
        asset_id: AssetId,
        minimum_unlock_price: Price,
    ) -> Self {
        Self {
            ft: FungibleToken::new(StorageKey::Ft),
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            backup_trigger_account_id: backup_trigger_account_id.map(|a| a.into()),
            locked_token_account_id: locked_token_account_id.into(),
            status: Status::Locked,
            price_oracle_account_id: price_oracle_account_id.into(),
            asset_id,
            minimum_unlock_price,
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn unlock(&mut self) {
        assert_one_yocto();
        assert_eq!(
            &Some(env::predecessor_account_id()),
            &self.backup_trigger_account_id
        );
        assert!(!matches!(self.status, Status::Unlocked));
        self.status = Status::Unlocked;
    }

    #[payable]
    pub fn unwrap(&mut self) -> Promise {
        assert_one_yocto();
        assert!(matches!(self.status, Status::Unlocked));
        let account_id = env::predecessor_account_id();
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

'''
'''--- references/locked-ft/branches/ft-metadata/token/src/price_receiver.rs ---
use crate::*;
use near_sdk::{Duration, Timestamp};
use std::cmp::Ordering;

pub type AssetId = String;
pub type DurationSec = u32;

const MAX_U128_DECIMALS: u8 = 38;
const UNLOCKING_DURATION: Duration = 24 * 60 * 60 * 10u64.pow(9);

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

impl PartialEq<Self> for Price {
    fn eq(&self, other: &Self) -> bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl PartialOrd for Price {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.decimals < other.decimals {
            return other.partial_cmp(self).map(|o| o.reverse());
        }

        let decimals_diff = self.decimals - other.decimals;

        if decimals_diff > MAX_U128_DECIMALS {
            return Some(Ordering::Less);
        }

        if let Some(om) = other
            .multiplier
            .checked_mul(10u128.pow(decimals_diff as u32))
        {
            Some(self.multiplier.cmp(&om))
        } else {
            Some(Ordering::Less)
        }
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    #[allow(unused_variables)]
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.price_oracle_account_id
        );
        for AssetOptionalPrice { asset_id, price } in data.prices {
            if asset_id == self.asset_id {
                if let Some(price) = price {
                    log!(
                        "maybe_unlock if {}/{} >= {}/{}",
                        price.multiplier,
                        price.decimals,
                        self.minimum_unlock_price.multiplier,
                        self.minimum_unlock_price.decimals
                    );
                    if price >= self.minimum_unlock_price {
                        self.maybe_unlock();
                        return;
                    }
                }
                self.maybe_lock();
                return;
            }
        }
    }
}

impl Contract {
    pub fn maybe_unlock(&mut self) {
        match self.status {
            Status::Locked => {
                let initiated_timestamp = env::block_timestamp();
                self.status = Status::Unlocking {
                    initiated_timestamp,
                };
                log!(
                    "Started unlocking at {}, unlocks at {}",
                    initiated_timestamp,
                    initiated_timestamp + UNLOCKING_DURATION
                );
            }
            Status::Unlocking {
                initiated_timestamp,
            } => {
                let timestamp = env::block_timestamp();
                if initiated_timestamp + UNLOCKING_DURATION > timestamp {
                    log!(
                        "Still unlocking, unlocks at {}, but current time is {}",
                        initiated_timestamp + UNLOCKING_DURATION,
                        timestamp
                    );
                } else {
                    log!("Unlocked!");
                    self.status = Status::Unlocked;
                }
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }

    pub fn maybe_lock(&mut self) {
        match self.status {
            Status::Locked => {
                env::panic(b"Still locked");
            }
            Status::Unlocking { .. } => {
                self.status = Status::Locked;
                log!("Locked again");
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn p(multiplier: u128, decimals: u8) -> Price {
        Price {
            multiplier,
            decimals,
        }
    }

    #[test]
    pub fn test_price_cmp() {
        assert!(p(10, 0) < p(11, 0));
        assert!(p(11, 0) > p(10, 0));
        assert!(p(11, 0) == p(11, 0));

        assert!(p(10, 10) < p(11, 10));
        assert!(p(11, 10) > p(10, 10));
        assert!(p(11, 10) == p(11, 10));

        assert!(p(100, 10) == p(10, 9));
        assert!(p(10, 9) == p(100, 10));

        assert!(p(101, 10) > p(10, 9));
        assert!(p(10, 9) < p(101, 10));
        assert!(p(99, 10) < p(10, 9));
        assert!(p(10, 9) > p(99, 10));

        assert!(p(101, 40) < p(10, 0));
        assert!(p(10, 0) > p(101, 40));
    }
}

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/factory/Cargo.toml ---
[package]
name = "factory-locked-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/factory_locked_ft.wasm ./res/main.wasm

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/factory/deploy.txt ---
export CONTRACT_ID=dev-1632441018789-66705294329463

near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID && near call $CONTRACT_ID storage_deposit '{}' --accountId $CONTRACT_ID --deposit 10

near call $CONTRACT_ID whitelist_token '{"token_id": "wrap.testnet", "title": "NEAR", "decimals": 24}' --accountId $CONTRACT_ID

near call $CONTRACT_ID create_token '{"token_args": {"token_id": "wrap.testnet", "target_price": "60000", "metadata": {"spec": "ft-1.0.0", "name": "1", "symbol": "2", "decimals": 28}, "backup_trigger_account_id": "dev-1631912016116-42587207920552", "price_oracle_account_id": "dev-1631302633591-50236902542063" }}' --accountId $CONTRACT_ID --gas 200000000000000

near view $CONTRACT_ID get_token '{"token_id": "near_6"}'
near view near_6.$CONTRACT_ID get_info '{}'

near call dev-1631302633591-50236902542063 oracle_call '{"receiver_id": "near_6.'$CONTRACT_ID'","asset_ids": ["wrap.testnet"], "msg": ""}' --accountId $CONTRACT_ID --depositYocto 1
'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/factory/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise,
};

near_sdk::setup_alloc!();

const FT_WASM_CODE: &[u8] = include_bytes!("../../token/res/locked_ft.wasm");

const EXTRA_BYTES: usize = 10000;
const GAS: Gas = 50_000_000_000_000;
type TokenId = String;

pub fn is_valid_symbol(token_id: &TokenId) -> bool {
    for c in token_id.as_bytes() {
        match c {
            b'0'..=b'9' | b'a'..=b'z' | b'_' | b'-' => (),
            _ => return false,
        }
    }
    true
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Tokens,
    StorageDeposits,
    WhitelistedTokens,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    pub tokens: UnorderedMap<TokenId, TokenArgs>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub storage_balance_cost: Balance,
    pub whitelisted_tokens: UnorderedMap<AccountId, WhitelistedToken>,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct WhitelistedToken {
    pub title: String,
    pub asset_id: String,
    pub decimals: u8,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct InputTokenArgs {
    token_id: ValidAccountId,
    target_price: U128,
    metadata: FungibleTokenMetadata,
    backup_trigger_account_id: Option<AccountId>,
    price_oracle_account_id: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

pub type AssetId = String;
pub type TokenAccountId = AccountId;

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgs {
    pub locked_token_account_id: TokenAccountId,
    pub meta: FungibleTokenMetadata,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new() -> Self {
        let mut storage_deposits = LookupMap::new(StorageKey::StorageDeposits);

        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        storage_deposits.insert(&tmp_account_id, &0);
        let storage_balance_cost =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;
        storage_deposits.remove(&tmp_account_id);

        Self {
            tokens: UnorderedMap::new(StorageKey::Tokens),
            storage_deposits,
            storage_balance_cost,
            whitelisted_tokens: UnorderedMap::new(StorageKey::WhitelistedTokens),
        }
    }

    #[private]
    pub fn whitelist_token(
        &mut self,
        token_id: ValidAccountId,
        asset_id: ValidAccountId,
        title: String,
        decimals: u8,
    ) {
        assert!(
            is_valid_symbol(&title.to_ascii_lowercase()),
            "Invalid Token symbol"
        );
        self.whitelisted_tokens.insert(
            &(token_id.into()),
            &WhitelistedToken {
                title,
                asset_id: asset_id.into(),
                decimals,
            },
        );
    }

    fn get_min_attached_balance(&self, args: &TokenArgs) -> u128 {
        ((FT_WASM_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance
            * STORAGE_PRICE_PER_BYTE)
            .into()
    }

    #[payable]
    pub fn storage_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let deposit = env::attached_deposit();
        if let Some(previous_balance) = self.storage_deposits.get(&account_id) {
            self.storage_deposits
                .insert(&account_id, &(previous_balance + deposit));
        } else {
            assert!(deposit >= self.storage_balance_cost, "Deposit is too low");
            self.storage_deposits
                .insert(&account_id, &(deposit - self.storage_balance_cost));
        }
    }

    pub fn get_number_of_tokens(&self) -> u64 {
        self.tokens.len()
    }

    pub fn get_tokens(&self, from_index: u64, limit: u64) -> Vec<TokenArgs> {
        let tokens = self.tokens.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, tokens.len()))
            .filter_map(|index| tokens.get(index))
            .collect()
    }

    pub fn get_whitelisted_tokens(&self, from_index: u64, limit: u64) -> Vec<TokenAccountId> {
        let token_ids = self.whitelisted_tokens.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, token_ids.len()))
            .filter_map(|token_id| token_ids.get(token_id))
            .collect()
    }

    pub fn get_token(&self, token_id: TokenId) -> Option<TokenArgs> {
        self.tokens.get(&token_id)
    }

    #[payable]
    pub fn create_token(&mut self, mut token_args: InputTokenArgs) -> Promise {
        if env::attached_deposit() > 0 {
            self.storage_deposit();
        }

        let whitelisted_token = self
            .whitelisted_tokens
            .get(&(token_args.token_id.clone().into()))
            .expect("Token wasn't whitelisted");
        let token_name = TokenFactory::format_title(whitelisted_token.title);
        let token_decimals = whitelisted_token.decimals;

        assert_eq!(
            token_args.metadata.decimals, token_decimals,
            "Wrong decimals"
        );

        let minimum_unlock_price = Price {
            multiplier: token_args.target_price.0,
            decimals: token_decimals + 4,
        };

        let target_price_short: u128 = token_args.target_price.0 / 10000;
        let target_price_remainder: u128 = token_args.target_price.0 % 10000;

        let price = if target_price_remainder > 0 {
            format!("{}.{}", target_price_short, target_price_remainder)
        } else {
            format!("{}", target_price_short)
        };
        assert!(token_args.target_price.0 > 0, "Wrong target price");

        token_args.metadata.name = format!("{} at ${}", token_name, price);
        token_args.metadata.symbol = format!("{}@{}", token_name, price);

        token_args.metadata.assert_valid();

        let token_id = format!(
            "{}-{}-{:04}",
            token_name, target_price_short, target_price_remainder
        )
        .to_ascii_lowercase();

        let token_account_id = format!("{}.{}", token_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(token_account_id.as_bytes()),
            "Token Account ID is invalid"
        );

        let args: TokenArgs = TokenArgs {
            locked_token_account_id: token_args.token_id.clone().into(),
            meta: token_args.metadata,
            backup_trigger_account_id: token_args.backup_trigger_account_id.map(|a| a.into()),
            price_oracle_account_id: token_args.price_oracle_account_id.into(),
            asset_id: whitelisted_token.asset_id.clone(),
            minimum_unlock_price,
        };

        let account_id = env::predecessor_account_id();

        let required_balance = self.get_min_attached_balance(&args);
        let user_balance = self.storage_deposits.get(&account_id).unwrap_or(0);
        assert!(
            user_balance >= required_balance,
            "Not enough required balance"
        );
        self.storage_deposits
            .insert(&account_id, &(user_balance - required_balance));

        let initial_storage_usage = env::storage_usage();

        assert!(
            self.tokens.insert(&token_id, &args).is_none(),
            "Token ID {} is already taken",
            token_id
        );

        log!(
            "Creating token {} with asset {} at price {}",
            token_account_id,
            whitelisted_token.asset_id,
            price
        );

        let storage_balance_used =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;

        Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_WASM_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS)
    }

    fn format_title(s: String) -> String {
        s.chars().filter(|c| !c.is_whitespace()).collect()
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/token/Cargo.toml ---
[package]
name = "locked-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/locked_ft.wasm ./res/

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/token/src/lib.rs ---
mod price_receiver;

use crate::price_receiver::*;

use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue, Timestamp,
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;

pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    Locked,
    Unlocking {
        #[serde(with = "u64_dec_format")]
        initiated_timestamp: Timestamp,
    },
    Unlocked,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
    pub locked_token_account_id: TokenAccountId,
    pub status: Status,
}

near_contract_standards::impl_fungible_token_core!(Contract, ft, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        assert!(matches!(self.status, Status::Locked));
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        locked_token_account_id: ValidAccountId,
        meta: FungibleTokenMetadata,
        backup_trigger_account_id: Option<ValidAccountId>,
        price_oracle_account_id: ValidAccountId,
        asset_id: AssetId,
        minimum_unlock_price: Price,
    ) -> Self {
        Self {
            ft: FungibleToken::new(StorageKey::Ft),
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            backup_trigger_account_id: backup_trigger_account_id.map(|a| a.into()),
            locked_token_account_id: locked_token_account_id.into(),
            status: Status::Locked,
            price_oracle_account_id: price_oracle_account_id.into(),
            asset_id,
            minimum_unlock_price,
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn unlock(&mut self) {
        assert_one_yocto();
        assert_eq!(
            &Some(env::predecessor_account_id()),
            &self.backup_trigger_account_id
        );
        assert!(!matches!(self.status, Status::Unlocked));
        self.status = Status::Unlocked;
    }

    #[payable]
    pub fn unwrap(&mut self) -> Promise {
        assert_one_yocto();
        assert!(matches!(self.status, Status::Unlocked));
        let account_id = env::predecessor_account_id();
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

'''
'''--- references/locked-ft/branches/revert-1-ft-metadata/token/src/price_receiver.rs ---
use crate::*;
use near_sdk::{Duration, Timestamp};
use std::cmp::Ordering;

pub type AssetId = String;
pub type DurationSec = u32;

const MAX_U128_DECIMALS: u8 = 38;
const UNLOCKING_DURATION: Duration = 24 * 60 * 60 * 10u64.pow(9);

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

impl PartialEq<Self> for Price {
    fn eq(&self, other: &Self) -> bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl PartialOrd for Price {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.decimals < other.decimals {
            return other.partial_cmp(self).map(|o| o.reverse());
        }

        let decimals_diff = self.decimals - other.decimals;

        if decimals_diff > MAX_U128_DECIMALS {
            return Some(Ordering::Less);
        }

        if let Some(om) = other
            .multiplier
            .checked_mul(10u128.pow(decimals_diff as u32))
        {
            Some(self.multiplier.cmp(&om))
        } else {
            Some(Ordering::Less)
        }
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    #[allow(unused_variables)]
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.price_oracle_account_id
        );
        for AssetOptionalPrice { asset_id, price } in data.prices {
            if asset_id == self.asset_id {
                if let Some(price) = price {
                    log!(
                        "maybe_unlock if {}/{} >= {}/{}",
                        price.multiplier,
                        price.decimals,
                        self.minimum_unlock_price.multiplier,
                        self.minimum_unlock_price.decimals
                    );
                    if price >= self.minimum_unlock_price {
                        self.maybe_unlock();
                        return;
                    }
                }
                self.maybe_lock();
                return;
            }
        }
    }
}

impl Contract {
    pub fn maybe_unlock(&mut self) {
        match self.status {
            Status::Locked => {
                let initiated_timestamp = env::block_timestamp();
                self.status = Status::Unlocking {
                    initiated_timestamp,
                };
                log!(
                    "Started unlocking at {}, unlocks at {}",
                    initiated_timestamp,
                    initiated_timestamp + UNLOCKING_DURATION
                );
            }
            Status::Unlocking {
                initiated_timestamp,
            } => {
                let timestamp = env::block_timestamp();
                if initiated_timestamp + UNLOCKING_DURATION > timestamp {
                    log!(
                        "Still unlocking, unlocks at {}, but current time is {}",
                        initiated_timestamp + UNLOCKING_DURATION,
                        timestamp
                    );
                } else {
                    log!("Unlocked!");
                    self.status = Status::Unlocked;
                }
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }

    pub fn maybe_lock(&mut self) {
        match self.status {
            Status::Locked => {
                env::panic(b"Still locked");
            }
            Status::Unlocking { .. } => {
                self.status = Status::Locked;
                log!("Locked again");
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn p(multiplier: u128, decimals: u8) -> Price {
        Price {
            multiplier,
            decimals,
        }
    }

    #[test]
    pub fn test_price_cmp() {
        assert!(p(10, 0) < p(11, 0));
        assert!(p(11, 0) > p(10, 0));
        assert!(p(11, 0) == p(11, 0));

        assert!(p(10, 10) < p(11, 10));
        assert!(p(11, 10) > p(10, 10));
        assert!(p(11, 10) == p(11, 10));

        assert!(p(100, 10) == p(10, 9));
        assert!(p(10, 9) == p(100, 10));

        assert!(p(101, 10) > p(10, 9));
        assert!(p(10, 9) < p(101, 10));
        assert!(p(99, 10) < p(10, 9));
        assert!(p(10, 9) > p(99, 10));

        assert!(p(101, 40) < p(10, 0));
        assert!(p(10, 0) > p(101, 40));
    }
}

'''
'''--- references/locked-ft/trunk/factory/Cargo.toml ---
[package]
name = "wentokensir"
version = "0.1.0"
authors = ["DreamProject"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/trunk/factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/wentokensir.wasm ./res/main.wasm

'''
'''--- references/locked-ft/trunk/factory/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_factory"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/factory \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2021-10-21; rustup default stable-2021-10-21; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/wentokensir.wasm $DIR/res/factory_release.wasm

'''
'''--- references/locked-ft/trunk/factory/deploy.txt ---
export CONTRACT_ID=dev-1632441018789-66705294329463

near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID && near call $CONTRACT_ID storage_deposit '{}' --accountId $CONTRACT_ID --deposit 10

near call $CONTRACT_ID whitelist_token '{"token_id": "wrap.testnet", "title": "NEAR", "decimals": 24}' --accountId $CONTRACT_ID

near call $CONTRACT_ID create_token '{"token_args": {"token_id": "wrap.testnet", "target_price": "60000", "metadata": {"spec": "ft-1.0.0", "name": "1", "symbol": "2", "decimals": 28}, "backup_trigger_account_id": "dev-1631912016116-42587207920552", "price_oracle_account_id": "dev-1631302633591-50236902542063" }}' --accountId $CONTRACT_ID --gas 200000000000000

near view $CONTRACT_ID get_token '{"token_id": "near_6"}'
near view near_6.$CONTRACT_ID get_info '{}'

near call dev-1631302633591-50236902542063 oracle_call '{"receiver_id": "near_6.'$CONTRACT_ID'","asset_ids": ["wrap.testnet"], "msg": ""}' --accountId $CONTRACT_ID --depositYocto 1
'''
'''--- references/locked-ft/trunk/factory/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::{
    AccountId, Balance, BorshStorageKey, env, ext_contract, Gas, log, near_bindgen, PanicOnDefault, Promise,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;

mod migrate;

near_sdk::setup_alloc!();

const FT_WASM_CODE: &[u8] = include_bytes!("../../token/res/locked_ft.wasm");

const EXTRA_BYTES: usize = 10000;
const GAS: Gas = 50_000_000_000_000;
const GAS_FT_METADATA_READ: Gas = 25_000_000_000_000;
const GAS_FT_METADATA_WRITE: Gas = 25_000_000_000_000;
const NO_DEPOSIT: Balance = 0;
const BACKUP_TRIGGER_ACCOUNT_ID: &str = "dreamproject.near";

type TokenId = String;
pub type AssetId = String;
pub type TokenAccountId = AccountId;

#[ext_contract(ext_ft)]
pub trait ExtFT {
    /// Get FT metadata.
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[ext_contract(ext_self)]
pub trait ExtContract {
    /// Save FT metadata
    fn on_ft_metadata(
        &mut self,
        token_id: AccountId,
        asset_id: AccountId,
        ticker: Option<String>
    );
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Tokens,
    StorageDeposits,
    WhitelistedTokens,
    WhitelistedTokensV1,
    WhitelistedPriceOracles
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    pub tokens: UnorderedMap<TokenId, TokenArgs>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub storage_balance_cost: Balance,
    pub whitelisted_tokens: UnorderedMap<AccountId, WhitelistedToken>,
    pub whitelisted_price_oracles: UnorderedSet<AccountId>,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WhitelistedToken {
    // Asset to track the price.
    pub asset_id: AssetId,
    // Ticker will be used for child tokens. May be different with metadata.symbol (wNear -> NEAR)
    pub ticker: Option<String>,
    pub metadata: FungibleTokenMetadata,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgsInput {
    token_id: ValidAccountId,
    target_price: U128,
    price_oracle_account_id: Option<ValidAccountId>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgs {
    pub locked_token_account_id: TokenAccountId,
    pub token_id: TokenId,
    pub meta: FungibleTokenMetadata,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WhitelistedTokenOutput {
    pub token_id: TokenAccountId,
    pub asset_id: AssetId,
    pub ticker: Option<String>,
    pub metadata: FungibleTokenMetadata,
}

impl WhitelistedTokenOutput {
    fn from(whitelisted_token: Option<WhitelistedToken>, token_id: TokenAccountId)
            -> Option<WhitelistedTokenOutput> {
        if let Some(token) = whitelisted_token {
            Some(WhitelistedTokenOutput {
                token_id,
                asset_id: token.asset_id,
                ticker: token.ticker,
                metadata: token.metadata,
            })
        } else {
            None
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenArgsOutput {
    pub token_id: Option<TokenAccountId>,
    pub locked_token_account_id: TokenAccountId,
    pub meta: FungibleTokenMetadata,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
}

impl TokenArgsOutput {
    fn from(token_args: Option<TokenArgs>, token_id: Option<TokenAccountId>) -> Option<TokenArgsOutput> {
        if let Some(token) = token_args {
            Some(TokenArgsOutput {
                token_id,
                locked_token_account_id: token.locked_token_account_id,
                meta: token.meta,
                backup_trigger_account_id: token.backup_trigger_account_id,
                price_oracle_account_id: token.price_oracle_account_id,
                asset_id: token.asset_id,
                minimum_unlock_price: token.minimum_unlock_price,
            })
        } else {
            None
        }
    }
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new() -> Self {
        let mut storage_deposits = LookupMap::new(StorageKey::StorageDeposits);

        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        storage_deposits.insert(&tmp_account_id, &0);
        let storage_balance_cost =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;
        storage_deposits.remove(&tmp_account_id);

        Self {
            tokens: UnorderedMap::new(StorageKey::Tokens),
            storage_deposits,
            storage_balance_cost,
            whitelisted_tokens: UnorderedMap::new(StorageKey::WhitelistedTokens),
            whitelisted_price_oracles: UnorderedSet::new(StorageKey::WhitelistedPriceOracles)
        }
    }

    #[private]
    pub fn on_ft_metadata(
        &mut self,
        #[callback] ft_metadata: FungibleTokenMetadata,
        token_id: AccountId,
        asset_id: AssetId,
        ticker: Option<String>) {
        self.internal_whitelist_token(&token_id, asset_id, ticker, ft_metadata);
    }

    #[private]
    pub fn whitelist_token(
        &mut self,
        token_id: ValidAccountId,
        asset_id: ValidAccountId,
        ticker: Option<String>,
    ) -> Promise {
            ext_ft::ft_metadata(
                &token_id,
                NO_DEPOSIT,
                GAS_FT_METADATA_READ,
            ).then(ext_self::on_ft_metadata(
                token_id.into(),
                asset_id.into(),
                ticker,
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FT_METADATA_WRITE,
            ))
    }

    #[private]
    pub fn whitelist_token_with_metadata(&mut self, token_id: ValidAccountId,
                                         asset_id: ValidAccountId,
                                         ticker: Option<String>,
                                         metadata: FungibleTokenMetadata) {
        self.internal_whitelist_token(&(token_id.into()), asset_id.into(), ticker, metadata);
    }

    #[private]
    pub fn whitelist_price_oracle(&mut self, account_id: ValidAccountId) {
        let account: AccountId = account_id.into();
        self.whitelisted_price_oracles.insert(&account);
    }

    #[payable]
    pub fn storage_deposit(&mut self) {
        let account_id = env::predecessor_account_id();
        let deposit = env::attached_deposit();
        if let Some(previous_balance) = self.storage_deposits.get(&account_id) {
            self.storage_deposits.insert(&account_id, &(previous_balance + deposit));
        } else {
            assert!(deposit >= self.storage_balance_cost, "Deposit is too low");
            self.storage_deposits.insert(&account_id, &(deposit - self.storage_balance_cost));
        }
    }

    fn get_min_attached_balance(&self, args: &TokenArgs) -> u128 {
        (FT_WASM_CODE.len() + EXTRA_BYTES + args.try_to_vec().unwrap().len() * 2) as Balance * STORAGE_PRICE_PER_BYTE
    }

    pub fn get_number_of_tokens(&self) -> u64 {
        self.tokens.len()
    }

    pub fn get_whitelisted_price_oracles(&self, from_index: u64, limit: u64) -> Vec<AccountId> {
        let contract_ids = self.whitelisted_price_oracles.as_vector();
        (from_index..std::cmp::min(from_index + limit, contract_ids.len())).filter_map(|contract_id| contract_ids.get(contract_id)).collect()
    }

    pub fn get_whitelisted_token_account_ids(&self, from_index: u64, limit: u64) -> Vec<TokenAccountId> {
        let token_ids = self.whitelisted_tokens.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, token_ids.len()))
           .filter_map(|token_id| token_ids.get(token_id)).collect()
    }

    pub fn get_whitelisted_tokens(&self, from_index: u64, limit: u64) -> Vec<Option<WhitelistedTokenOutput>> {
        self.get_whitelisted_token_account_ids(from_index, limit)
           .iter()
           .map(|token_id|
              WhitelistedTokenOutput::from(self.whitelisted_tokens.get(token_id), token_id.clone()))
           .collect()
    }

    pub fn get_whitelisted_token(&self, token_id: TokenAccountId) -> Option<WhitelistedTokenOutput> {
        WhitelistedTokenOutput::from(Some(self.internal_get_whitelisted_token(&token_id)), token_id)
    }

    pub fn get_tokens(&self, from_index: u64, limit: u64) -> Vec<TokenArgsOutput> {
        let keys = self.tokens.keys_as_vector();
        let tokens = self.tokens.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, tokens.len())).filter_map(|index| TokenArgsOutput::from(tokens.get(index), keys.get(index))).collect()
    }

    pub fn get_token(&self, token_id: TokenId) -> Option<TokenArgsOutput> {
        TokenArgsOutput::from(self.tokens.get(&token_id), Some(token_id))
    }

    pub fn ft_metadata(&self, token_id: TokenId) -> Option<FungibleTokenMetadata>{
        if let Some (token) = self.tokens.get(&token_id){
            Some(token.meta)
        }
        else{
            None
        }
    }

    pub fn get_token_name(&self, token_args: TokenArgsInput) -> AccountId {
        let whitelisted_token = self.internal_get_whitelisted_token(&(token_args.token_id.clone().into()));
        let (token_account_id, _, _, _) = generate_token_namespace(&token_args, &whitelisted_token);
        token_account_id
    }

    fn internal_whitelist_token(&mut self,
                                token_id: &AccountId,
                                asset_id: AccountId,
                                ticker: Option<String>,
                                metadata: FungibleTokenMetadata) {
        assert!(is_valid_symbol(&metadata.symbol.to_ascii_lowercase()), "Invalid Token symbol");

        self.whitelisted_tokens.insert(token_id, &WhitelistedToken { asset_id, ticker, metadata });
    }

    fn internal_get_whitelisted_token(&self, token_id: &AccountId) -> WhitelistedToken {
        self.whitelisted_tokens.get(token_id).expect("Token wasn't whitelisted")
    }

    fn internal_get_token(&self, token_id: &AccountId) -> TokenArgs {
        self.tokens.get(token_id).expect("Token wasn't created")
    }

    #[private]
    pub fn update_whitelisted_token_metadata(&mut self, token_id: TokenAccountId, metadata: FungibleTokenMetadata) {
        let mut token = self.internal_get_whitelisted_token(&token_id);
        token.metadata = metadata;
        self.whitelisted_tokens.insert(&token_id, &token);
    }

    #[private]
    pub fn update_token_metadata(&mut self, token_id: TokenAccountId, meta: FungibleTokenMetadata) {
        let mut token = self.internal_get_token(&token_id);
        token.meta = meta;
        self.tokens.insert(&token_id, &token);
    }

    #[payable]
    pub fn create_token(&mut self, token_args: TokenArgsInput) -> Promise {
        if env::attached_deposit() > 0 {
            self.storage_deposit();
        }

        let whitelisted_token = self.internal_get_whitelisted_token(&(token_args.token_id.clone().into()));
        let (token_account_id, ticker, price, token_id) = generate_token_namespace(&token_args, &whitelisted_token);

        let input_price_oracle_account_id: AccountId = token_args.price_oracle_account_id.expect("Price Oracle Contract is missing").into();
        assert!(self.whitelisted_price_oracles.contains(&input_price_oracle_account_id), "Price Oracle wasn't whitelisted");

        let token_decimals = whitelisted_token.metadata.decimals;

        assert!(token_decimals > 0, "Missing token decimals");
        assert!(token_args.target_price.0 > 0, "Illegal target price");

        let mut metadata = whitelisted_token.metadata;

        let minimum_unlock_price = Price {
            multiplier: token_args.target_price.0,
            decimals: token_decimals + 4,
        };

        metadata.name = format!("{} at ${}", ticker, price);
        metadata.symbol = format!("{}@{}", ticker, price);

        metadata.assert_valid();

        let args: TokenArgs = TokenArgs {
            locked_token_account_id: token_args.token_id.into(),
            token_id: token_id.clone(),
            meta: metadata,
            backup_trigger_account_id: Some(BACKUP_TRIGGER_ACCOUNT_ID.into()),
            price_oracle_account_id: input_price_oracle_account_id,
            asset_id: whitelisted_token.asset_id.clone(),
            minimum_unlock_price,
        };

        let account_id = env::predecessor_account_id();

        let required_balance = self.get_min_attached_balance(&args);
        let user_balance = self.storage_deposits.get(&account_id).unwrap_or(0);
        assert!(
            user_balance >= required_balance,
            "Not enough required balance"
        );
        self.storage_deposits
            .insert(&account_id, &(user_balance - required_balance));

        let initial_storage_usage = env::storage_usage();

        assert!(
            self.tokens.insert(&token_id, &args).is_none(),
            "Token ID {} is already taken",
            token_id
        );

        log!(
            "Creating token {} with asset {} at price {}",
            token_account_id,
            whitelisted_token.asset_id,
            price
        );

        let storage_balance_used =
            Balance::from(env::storage_usage() - initial_storage_usage) * STORAGE_PRICE_PER_BYTE;

        Promise::new(token_account_id)
            .create_account()
            .transfer(required_balance - storage_balance_used)
            .deploy_contract(FT_WASM_CODE.to_vec())
            .function_call(b"new".to_vec(), serde_json::to_vec(&args).unwrap(), 0, GAS)
    }

    fn format_title(s: String) -> String {
        s.chars().filter(|c| !c.is_whitespace()).collect()
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::serde::de;

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::serde::de;

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
        where
            D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

fn is_valid_symbol(token_id: &str) -> bool {
    for c in token_id.as_bytes() {
        match c {
            b'0'..=b'9' | b'a'..=b'z' | b'_' | b'-' => (),
            _ => return false,
        }
    }
    true
}

/// returns (token_account_id, ticker, price, token_id)
fn generate_token_namespace (token_args: &TokenArgsInput, whitelisted_token: &WhitelistedToken) -> (TokenAccountId, String, String, String){
    // name of the token we want to create
    let token_name = TokenFactory::format_title(whitelisted_token.metadata.symbol.clone());

    let ticker = if whitelisted_token.ticker.is_none() {
        token_name.clone()
    } else {
        whitelisted_token.ticker.clone().unwrap()
    };

    assert!(!ticker.is_empty() && !token_name.is_empty(), "Illegal token metadata");

    let target_price_short: u128 = token_args.target_price.0 / 10000;
    let target_price_remainder: u128 = token_args.target_price.0 % 10000;
    let target_price_remainder_without_trailing_zeros: String = remove_trailing_zeros(target_price_remainder);

    let price = if target_price_remainder > 0 {
        format!("{}.{}", target_price_short, target_price_remainder_without_trailing_zeros)
    } else {
        format!("{}", target_price_short)
    };

    let token_id = format!(
        "{}-at-{}-{}",
        token_name, target_price_short, target_price_remainder_without_trailing_zeros
    ).to_ascii_lowercase();

    let token_account_id: TokenAccountId = format!("{}.{}", token_id, env::current_account_id());
    assert!(
        env::is_valid_account_id(token_account_id.as_bytes()),
        "Token Account ID is invalid"
    );

    (token_account_id, ticker, price, token_id)
}

fn remove_trailing_zeros(amount: u128) -> String {
    let mut string = format!("{:04}", amount);
    for _ in 0..4 {
        if string.ends_with('0') && string.len() != 1 {
            string.pop();
        }
    }

    string
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_remove_trailing_zeros() {
        assert_eq!(remove_trailing_zeros(1000), "1");
        assert_eq!(remove_trailing_zeros(1200), "12");
        assert_eq!(remove_trailing_zeros(1230), "123");
        assert_eq!(remove_trailing_zeros(1234), "1234");
        assert_eq!(remove_trailing_zeros(1), "0001");
        assert_eq!(remove_trailing_zeros(10), "001");
        assert_eq!(remove_trailing_zeros(100), "01");
        assert_eq!(remove_trailing_zeros(1000), "1");
        assert_eq!(remove_trailing_zeros(0), "0");
    }
}

'''
'''--- references/locked-ft/trunk/factory/src/migrate.rs ---
use crate::*;

#[near_bindgen]
impl TokenFactory {
    #[private]
    #[init(ignore_state)]
    #[allow(dead_code)]
    pub fn migrate_1() -> Self {
        #[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
        #[serde(crate = "near_sdk::serde")]
        pub struct WhitelistedTokenOld {
            pub title: String,
            pub asset_id: String,
            pub decimals: u8,
        }

        #[derive(BorshDeserialize)]
        pub struct TokenFactoryOld {
            pub tokens: UnorderedMap<TokenId, TokenArgs>,
            pub storage_deposits: LookupMap<AccountId, Balance>,
            pub storage_balance_cost: Balance,
            pub whitelisted_tokens: UnorderedMap<AccountId, WhitelistedTokenOld>
        }

        let old_contract: TokenFactoryOld = env::state_read().expect("Old state doesn't exist");

        let mut whitelisted_tokens_new: UnorderedMap<AccountId, WhitelistedToken> = UnorderedMap::new(StorageKey::WhitelistedTokensV1);

        let token_ids = old_contract.whitelisted_tokens.keys_as_vector();
        for token_id in token_ids.to_vec() {
            if let Some(old_token) = old_contract.whitelisted_tokens.get(&token_id) {
                whitelisted_tokens_new.insert(&token_id,
                                              &WhitelistedToken {
                                                  asset_id: old_token.asset_id,
                                                  ticker: Some(old_token.title.clone()),
                                                  metadata: FungibleTokenMetadata {
                                                      spec: "ft-1.0.0".to_string(),
                                                      name: old_token.title.clone(),
                                                      symbol: old_token.title,
                                                      icon: None,
                                                      reference: None,
                                                      reference_hash: None,
                                                      decimals: old_token.decimals,
                                                  },
                                              });
            }
        }

        TokenFactory {
            tokens: old_contract.tokens,
            storage_deposits: old_contract.storage_deposits,
            storage_balance_cost: old_contract.storage_balance_cost,
            whitelisted_tokens: whitelisted_tokens_new,
            whitelisted_price_oracles: UnorderedSet::new(StorageKey::WhitelistedPriceOracles)
        }
    }

    #[private]
    pub fn migrate_11(&mut self)  {
        // delete because of wrong name
        self.tokens.remove(&"near-20-0000".to_string());
    }

    #[private]
    pub fn migrate_12(&mut self)  {
        self.tokens.clear();
        self.whitelisted_tokens.clear();
    }
}

'''
'''--- references/locked-ft/trunk/token/Cargo.toml ---
[package]
name = "locked_ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/locked-ft/trunk/token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/locked_ft.wasm ./res/

'''
'''--- references/locked-ft/trunk/token/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="locked_ft"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/token \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2021-10-21; rustup default stable-2021-10-21; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/locked_ft.wasm $DIR/res/locked_ft.wasm

'''
'''--- references/locked-ft/trunk/token/src/lib.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::FungibleToken;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::{
    AccountId, assert_one_yocto, Balance, BorshStorageKey, env, ext_contract, Gas, is_promise_success,
    log, near_bindgen, PanicOnDefault, Promise, PromiseOrValue, Timestamp,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};

use crate::price_receiver::*;

mod price_receiver;

near_sdk::setup_alloc!();

const OWNER_ID: &str = "dreamproject.near";
const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FT_METADATA_READ: Gas = 25 * TGAS;
const GAS_FT_METADATA_WRITE: Gas = 25 * TGAS;

type TokenId = String;
pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    Locked,
    Unlocking {
        #[serde(with = "u64_dec_format")]
        initiated_timestamp: Timestamp,
    },
    Unlocked,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;

    // Save FT metadata
    fn on_ft_metadata(
        &mut self
    );
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[ext_contract(ext_ft)]
pub trait ExtFT {
    // Get FT metadata.
    fn ft_metadata(&self, token_id: TokenAccountId) -> FungibleTokenMetadata;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    pub token_id: TokenId,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    pub backup_trigger_account_id: Option<AccountId>,
    pub price_oracle_account_id: AccountId,
    pub asset_id: AssetId,
    pub minimum_unlock_price: Price,
    pub locked_token_account_id: TokenAccountId,
    pub factory_account_id: AccountId,
    pub status: Status,
}

near_contract_standards::impl_fungible_token_core!(Contract, ft, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        assert!(matches!(self.status, Status::Locked));
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        locked_token_account_id: ValidAccountId,
        token_id: TokenAccountId,
        meta: FungibleTokenMetadata,
        backup_trigger_account_id: Option<ValidAccountId>,
        price_oracle_account_id: ValidAccountId,
        asset_id: AssetId,
        minimum_unlock_price: Price,
    ) -> Self {
        Self {
            ft: FungibleToken::new(StorageKey::Ft),
            token_id,
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            backup_trigger_account_id: backup_trigger_account_id.map(|a| a.into()),
            locked_token_account_id: locked_token_account_id.into(),
            status: Status::Locked,
            price_oracle_account_id: price_oracle_account_id.into(),
            asset_id,
            minimum_unlock_price,
            factory_account_id: env::predecessor_account_id()
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn unlock(&mut self) {
        assert_one_yocto();
        assert_eq!(
            &Some(env::predecessor_account_id()),
            &self.backup_trigger_account_id
        );
        assert!(!matches!(self.status, Status::Unlocked));
        self.status = Status::Unlocked;
    }

    #[payable]
    pub fn unwrap(&mut self) -> Promise {
        assert_one_yocto();
        assert!(matches!(self.status, Status::Unlocked));
        let account_id = env::predecessor_account_id();
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        ).then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    /// Sync meta of token from the factory with the current contract state
    pub fn update_meta(&mut self) -> Promise {
        ext_ft::ft_metadata(
            self.token_id.clone(),
            &self.factory_account_id,
            NO_DEPOSIT,
            GAS_FT_METADATA_READ,
        ).then(ext_self::on_ft_metadata(
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FT_METADATA_WRITE,
        ))
    }

    pub fn update_price_oracle_account_id(&mut self, price_oracle_account_id: ValidAccountId) {
        assert_owner();
        self.price_oracle_account_id = price_oracle_account_id.into();
    }

    pub fn get_status(&self) -> Status { self.status }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }

    #[private]
    pub fn on_ft_metadata(
        &mut self,
        #[callback] ft_metadata: Option<FungibleTokenMetadata>) {
        if let Some(ft_metadata_value) = ft_metadata {
            self.meta.set(&ft_metadata_value);
        }
        else {
            log!("Missing metadata");
        }

    }
}

fn assert_owner() {
    assert_eq!(env::predecessor_account_id(), OWNER_ID, "No Access");
}

'''
'''--- references/locked-ft/trunk/token/src/price_receiver.rs ---
use crate::*;
use near_sdk::{Duration, Timestamp};
use std::cmp::Ordering;

pub type AssetId = String;
pub type DurationSec = u32;

const MAX_U128_DECIMALS: u8 = 38;
const UNLOCKING_DURATION: Duration = 24 * 60 * 60 * 10u64.pow(9);

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

impl PartialEq<Self> for Price {
    fn eq(&self, other: &Self) -> bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl PartialOrd for Price {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.decimals < other.decimals {
            return other.partial_cmp(self).map(|o| o.reverse());
        }

        let decimals_diff = self.decimals - other.decimals;

        if decimals_diff > MAX_U128_DECIMALS {
            return Some(Ordering::Less);
        }

        if let Some(om) = other
            .multiplier
            .checked_mul(10u128.pow(decimals_diff as u32))
        {
            Some(self.multiplier.cmp(&om))
        } else {
            Some(Ordering::Less)
        }
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    #[allow(unused_variables)]
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.price_oracle_account_id
        );
        for AssetOptionalPrice { asset_id, price } in data.prices {
            if asset_id == self.asset_id {
                if let Some(price) = price {
                    log!(
                        "maybe_unlock if {}/{} >= {}/{}",
                        price.multiplier,
                        price.decimals,
                        self.minimum_unlock_price.multiplier,
                        self.minimum_unlock_price.decimals
                    );
                    if price >= self.minimum_unlock_price {
                        self.maybe_unlock();
                        return;
                    }
                }
                self.maybe_lock();
                return;
            }
        }
    }
}

impl Contract {
    pub fn maybe_unlock(&mut self) {
        match self.status {
            Status::Locked => {
                let initiated_timestamp = env::block_timestamp();
                self.status = Status::Unlocking {
                    initiated_timestamp,
                };
                log!(
                    "Started unlocking at {}, unlocks at {}",
                    initiated_timestamp,
                    initiated_timestamp + UNLOCKING_DURATION
                );
            }
            Status::Unlocking {
                initiated_timestamp,
            } => {
                let timestamp = env::block_timestamp();
                if initiated_timestamp + UNLOCKING_DURATION > timestamp {
                    log!(
                        "Still unlocking, unlocks at {}, but current time is {}",
                        initiated_timestamp + UNLOCKING_DURATION,
                        timestamp
                    );
                } else {
                    log!("Unlocked!");
                    self.status = Status::Unlocked;
                }
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }

    pub fn maybe_lock(&mut self) {
        match self.status {
            Status::Locked => {
                env::panic(b"Still locked");
            }
            Status::Unlocking { .. } => {
                self.status = Status::Locked;
                log!("Locked again");
            }
            Status::Unlocked => {
                env::panic(b"Already unlocked");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn p(multiplier: u128, decimals: u8) -> Price {
        Price {
            multiplier,
            decimals,
        }
    }

    #[test]
    pub fn test_price_cmp() {
        assert!(p(10, 0) < p(11, 0));
        assert!(p(11, 0) > p(10, 0));
        assert!(p(11, 0) == p(11, 0));

        assert!(p(10, 10) < p(11, 10));
        assert!(p(11, 10) > p(10, 10));
        assert!(p(11, 10) == p(11, 10));

        assert!(p(100, 10) == p(10, 9));
        assert!(p(10, 9) == p(100, 10));

        assert!(p(101, 10) > p(10, 9));
        assert!(p(10, 9) < p(101, 10));
        assert!(p(99, 10) < p(10, 9));
        assert!(p(10, 9) > p(99, 10));

        assert!(p(101, 40) < p(10, 0));
        assert!(p(10, 0) > p(101, 40));
    }
}

'''
'''--- references/main/Cargo.toml ---
[package]
name = "burrowland"
version = "0.1.1"
authors = ["Nearlend Team"]
edition = "2018"

[dev-dependencies]
near-sdk = "=4.0.0-pre.7"
near-sdk-sim = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"

common = { path = "./common"}
contract = { path = "./contract" }
test-oracle = { path = "./test-oracle" }

approx = "0.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "common",
    "contract",
    "test-oracle",
]

'''
'''--- references/main/README.md ---
# Burrowland contact

## How it works

### Interest model

The contract uses a compounding interest model similar to Aave.

Each asset defines interest rate configuration with the following values:

* `target_utilization` - the ideal percent at for the asset utilization, e.g. 80% borrowed comparing to the total supplied.
* `target_utilization_r` - the constant to use as a base for computing compounding APR at the target utilization.
* `max_utilization_r` - the constant to use as a base for computing compounding APR at the 100% utilization.
* `reserve_ratio` - the percentage of the acquired interest reserved for the platform.

Based on these values we define 3 points of utilization: `0%`, target utilization and `100%`.
For each of these points we have the `r` constant: `1.0`, `target_utilization_r` and `max_utilization_r` respectively.

To compute the APR, we can use the following formula:

`1 + APR = r ** MS_PER_YEAR`, where MS_PER_YEAR is the number of milliseconds in a year equal to `31536000000`. 

Based on the current supplied, reserved and borrowed balances, the current utilization is defined using the following formula:

`utilization = (supplied + reserved) / borrowed`

To compute current APR, we need to find the current `r` constant based on the linear interpolation between utilization points:

* if `utilization <= target_utilization`, `r = target_utilization_r * (utilization / target_utilization)`
* if `utilization > target_utilization`, `r = target_utilization_r + (max_utilization_r - target_utilization_r) * (utilization - target_utilization) / (1 - target_utilization)` 

To calculate the amount of interest acquired for the duration of `t` milliseconds, we can use the following formula:

`interest = (r ** t) * borrowed`

The interest are distributed to `reserved` and `supplied`, based on `reserve_ratio`, so the new values are:

```
reserved_interest = interest * reserve_ratio
new_reserved = reserved + reserved_interest
new_supplied = supplied + (interest - reserved_interest)
new_borrowed = borrowed + interest 
```

### Health factor

The health factor is computed per account instead of per asset.

Each account may supply multiple collateral assets and may borrow multiple assets.

Each asset has a configuration value `volatility_ratio` which indicates the expected price stability factor.
The higher the ratio, the higher expectation of the stability of the price of the corresponding asset.

To compute the current health factor for the account, we need to know the current prices of all collateral and borrowed assets.
Firstly, we compute the adjusted for volatility sums of all collateral assets and borrowed assets.

```
adjusted_collateral_sum = sum(collateral_i * price_i * volatility_ratio_i)
adjusted_borrowed_sum = sum(borrowed_i * price_i / volatility_ratio_i)
```

Now we can compute the health factor:

`health_factor = adjusted_collateral_sum / adjusted_borrowed_sum`

If the health factor is higher than 100%, it means the account is in a good state and can't be liquidated.
If the health factor is less than 100%, it means the account can be partially liquidated and can't borrow more without
repaying some amount of the existing assets or providing more collateral assets.

### Liquidations

Contract liquidations are designed to make liquidators compete for the profit that they make during liquidations to
minimize the loss taken by the unhealthy accounts. Instead of the fixed profit that is used in the legacy products,
this contract introduces a variable discount with variable liquidation size.

Liquidations rules:
1. the initial health factor of the liquidated accounts has to be below 100%
2. the discounted sum of the taken collateral should be less than the sum of repaid assets  
3. the final health factor of the liquidated accounts has to stay below 100%

A liquidation action consists of the following:
- `account_id` - the account ID that is being liquidated
- `in_assets` - the assets and corresponding amounts to repay form borrowed assets
- `out_assets` - the assets and corresponding amounts to take from collateral assets

The discount is computed based on the initial health factor of the liquidated account:

`discount = (1 - health_factor) / 2`

Now we can compute the taken discounted collateral sum and the repaid borrowed sum:

```
taken_sum = sum(out_asset_i * price_i)
discounted_collateral_sum = taken_sum * (1 - discount)
repaid_sum = sum(in_asset_i * price_i)
```

Once we action is completed, we can compute the final values and verify the liquidation rules:

1. `health_factor < 100%`
2. `discounted_collateral_sum <= repaid_sum`
3. `new_health_factor < 100%`

The first rule only allows to liquidate accounts in the unhealthy state.
The second rule prevents from taking more collateral than the repaid sum (after discount).
The third rule prevents the liquidator from repaying too much of the borrowed assets, only enough to bring closer to the 100%.

#### Liquidation example

Account `alice.near` supplied to collateral `1000 wNEAR` and borrowed `4000 nDAI`.

Let's say:
- the price of `wNEAR` is `10`
- the price of the `nDAI` is `1`
- the `volatility_ratio` of `wNEAR` is `0.5`
- the `volatility_ratio` of `nDAI` is `1`

The health factor of `alice.near` is the following:

```
adjusted_collateral_sum = sum(1000 * 10 * 0.5) = 5000
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 5000 / 4000 = 125% 
```

Let's say the price of `wNEAR` drops to `8`

```
adjusted_collateral_sum = sum(1000 * 8 * 0.5) = 4000
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 4000 / 4000 = 100% 
```

The health factor is 100%, so the account still can't be liquidated.

Let's say the price of `wNEAR` drops to `7`

```
adjusted_collateral_sum = sum(1000 * 7 * 0.5) = 3500
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 3500 / 4000 = 0.875 = 87.5% 
```

The health factor is below 100%, so the account can be liquidated. The discount is the following:

```
discount = (1 - 0.875) / 2 = 0.0625 = 6.25%
```

It means anyone can repay some `nDAI` and take some `wNEAR` from `alice.near` with `6.25%` discount.  

Account `bob.near` decides to liquidate `alice.near`

`bob.near` wants to repay `1000 nDAI`, we can compute the maximum sum of the collateral to take:

```
repaid_sum = sum(1000 * 1) = 1000
max_taken_sum = repaid_sum / (1 - discount) = 1000 / (1 - 0.0625) = 1066.666
```

And based on the `wNEAR` price, we can compute the maximum amount:

```
max_wnear_amount = max_taken_sum / wnear_price = 1066.666 / 7 = 152.38
```

But to avoid risk, `bob.near` takes `152` `wNEAR` - a bit less to avoid price fluctuation for the duration of the transaction.

Let's compute the liquidation action:

```
taken_sum = sum(out_asset_i * price_i) = sum(152 * 7) = 1064
discounted_collateral_sum = taken_sum * (1 - discount) = 1064 * (1 - 0.0625) = 997.5
repaid_sum = sum(in_asset_i * price_i) = sum(1000 * 1) = 1000

new_adjusted_collateral_sum = sum((1000 - 152) * 7 * 0.5) = 2968
new_adjusted_borrowed_sum = sum((4000 - 1000) * 1 / 1) = 3000

new_health_factor = 2968 / 3000 = 0.9893 = 98.93%
```

Now checking the liquidation rules:

```
1. 87.5% < 100%
2. 997.5 <= 1000
3. 98.93% < 100%
```

All rules satisfied, so the liquidation was successful.

Now, let's compute the profit of `bob.near` (or the loss for `alice.near`) for this liquidation:
```
profit = taken_sum - repaid_sum = 1064 - 1000 = 64
```

Notes:
- If someone during the time when the price of `wNEAR` was falling from `8` to `7` liquidated `alice.near` they would have
  made less profit, by liquidating a smaller amount with a smaller collateral discount.
- To fully realize the profit, `bob.near` has to take another action on some exchange and swap received `152` `wNEAR` for `nDAI`, which 
  may involve extra fees and transactional risks. That's why liquidators may wait for higher discount.

## Development

### Build (optional)

Requires Rust and wasm32 target.

```bash
./build.sh
```

### Deploy on the testnet

Requires NEAR CLI to be installed.

```bash
./scripts/dev_deploy.sh
```

This will provide a list of exports at the end. Execute them to get the CLI ready for further transactions.

Example exports:
```bash
export NEAR_ENV=testnet
export OWNER_ID=dev-1634411537975-18277461139961
export ORACLE_ID=dev-1634411553736-97024242878560
export CONTRACT_ID=dev-1634411561699-94876475207945
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
```

### Create a test account

Requires exports from running `dev_deploy`. 

```bash
./scripts/create_account.sh
```

This will create a new test account with fake assets. Execute the export at the end to get the account ID.

Example export:
```bash
export ACCOUNT_ID=dev-1634680029152-10252684568108
```

## Actions

### Register account by paying for storage

This has to be done one per account.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'
```

### Supply some token

Let's supply `5` USDT. USDT has `6` decimals, so amount should be `5000000`. For a simple deposit, the `msg` can be empty string.

```bash
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'
```

### View account information

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

Note: Since USDT asset has extra `12` decimals, it brings the 5 USDT in the balance to `5000000000000000000`

### View a given asset

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '5000000000000000000', balance: '5000000000000000000' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000000000000000',
  last_update_timestamp: '1634682347763275349',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 12,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

Note: You can also see `2000000000000000000000` reserved. That's `2000` USDT from the owner.

### Provide token as a collateral

Let's add all USDT to a collateral. If the `amount` for a given action is not specified, then all available amount will be used.

Increasing the collateral doesn't require prices from the oracle, because it can't decrease the existing collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Note, you can see the USDT asset was moved from `supplied` to `collateral`

### Borrow a token

Let's borrow `1` DAI. DAI has `18` decimals, so the amount should be `1000000000000000000`.

Since borrow action puts account into the debt, we have to call this action through the oracle.
The oracle should provide prices for all assets in the collateral as well as all existing borrowed assets and the new borrowed asset.

The `msg` passed to the oracle should be string. Since it's part of the JSON, it has to be double-encoded and can't have newlines.

FYI: The message that we pass to the contract from the oracle is the following:
```json
{
  "Execute": {
    "actions": [
      {
        "Borrow": {
          "token_id": "dai.fakes.testnet",
          "amount": "1000000000000000000"
        }
      }
    ]
  }
}
```

```bash
near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'
```

You should see a log message like: `Account dev-1634682124572-99167526870966 borrows 1000000000000000000 of dai.fakes.testnet`

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966', 
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000048216105',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000064288139',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Note, without extra action the borrowed assets are not withdrawn to the wallet, but instead supplied to earn interest.
From there they can be withdrawn.
You can also notice that the borrowed balance is larger than the supplied balance, that's because the some of the interest are going to the reserve.

If we view the account info again, then the balances should increase:

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000221528817',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000295371755',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '1000000000000000000', balance: '1000000000399150907' },
  borrowed: { shares: '1000000000000000000', balance: '1000000000532201209' },
  reserved: '2000000000000133050302',
  last_update_timestamp: '1634683708614246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Withdrawing the asset

Let's withdraw all DAI including interest.

Withdrawing doesn't need oracle prices, because it can only be taken from the supplied and not from the collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'
```

You should see the log, e.g. `Account dev-1634682124572-99167526870966 withdraws 1000000001658903820 of dai.fakes.testnet`

Now let's check the DAI balance (in the wallet) of the account:

```bash
near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result: `10001000000001658903820`, which corresponds roughly to `10001` DAI, plus some extra earned interests.

Withdrawal from the contract was possible, because the owner has supplied DAI into the reserve.

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000002496596924',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Notice, there is no supplied DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '0', balance: '0' },
  borrowed: { shares: '1000000000000000000', balance: '1000000002551410252' },
  reserved: '2000000000000892506432',
  last_update_timestamp: '1634685033009246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Deposit asset and repay it in one call.

Note, multiple actions can be combined into a single atomic update. Either all of them complete or all of them are reverted.
The invariants are only checked at the end, so this may be used to replace one collateral with another without repaying debts (but this requires oracle pricing). 

Let's deposit `5` DAI and use it to repay borrowed DAI. DAI has 18 decimal, so the amount is `5000000000000000000`
For this we need to pass a custom `msg` to `ft_transfer_call`.
The message has to be double-encoded into a string.

FYI: Non-encoded message in JSON:
```json
{
  "Execute": {
    "actions": [
      {
        "Repay": {
          "token_id": "dai.fakes.testnet"
        }
      }
    ]
  }
}
```

```bash
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'
```

You should see similar log messages:
```
Account dev-1634686749015-49146327775274 deposits 5000000000000000000 of dai.fakes.testnet
Account dev-1634686749015-49146327775274 repays 1000000001735752696 of dai.fakes.testnet
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Notice, there is no borrowed DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '3999999998264247304', balance: '3999999998264247304' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000001727179674',
  last_update_timestamp: '1634688121573861187',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

And no borrowed balance or shares after repaying.

### Decreasing collateral

Since there is no borrowed assets, we can take the collateral without providing prices.

Let's get all USDT collateral back.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    },
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

'''
'''--- references/main/branches/farm/Cargo.toml ---
[package]
name = "Nearlend"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dev-dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.1.0"

common = { path = "./common"}
contract = { path = "./contract" }
test-oracle = { path = "./test-oracle" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "common",
    "contract",
    "test-oracle",
]

'''
'''--- references/main/branches/farm/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/test_oracle.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/Nearlend.wasm

'''
'''--- references/main/branches/farm/common/Cargo.toml ---
[package]
name = "common"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dependencies]
near-sdk = "3.1.0"

'''
'''--- references/main/branches/farm/common/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{Balance, Gas, Timestamp};

pub type AssetId = String;
pub type DurationSec = u32;

pub const TGAS: Gas = 10u64.pow(12);
pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;

const MAX_VALID_DECIMALS: u8 = 77;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    pub multiplier: Balance,
    pub decimals: u8,
}

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

'''
'''--- references/main/branches/farm/contract/API.md ---
# The list of APIs that are provided by the contract

```rust
trait Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    fn new(config: Config) -> Self;

    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView>;

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account>;

    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    fn execute(&mut self, actions: Vec<Action>);

    /// Returns an asset for a given token_id.
    fn get_asset(&self, token_id: ValidAccountId) -> Option<Asset>;

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<(TokenId, Asset)>;

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)>;

    /// Returns the current config.
    fn get_config(&self) -> Config;

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_config(&mut self, config: Config);

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);
}
```

## Structures and types

```rust
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    pub shares: Shares,
}

pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
}

pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,

}

pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000
/// }
/// ```
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
}

pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

pub struct Config {
    pub oracle_account_id: ValidAccountId,

    pub owner_id: ValidAccountId,
}

pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
}

enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

pub type TokenId = AccountId;
```

## Also storage management

```rust
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregestering the account is not allowed to not break the order of accounts.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}
```

'''
'''--- references/main/branches/farm/contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = { version = "0.9.0", default-features = false }
common = { path = "../common/" }
once_cell = "1.8.0"

[dev-dependencies]
rand = "0.8"

'''
'''--- references/main/branches/farm/contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
    /// Keeping track of data required for farms for this account.
    #[serde(skip_serializing)]
    pub farms: UnorderedMap<FarmId, VAccountFarm>,
    #[borsh_skip]
    #[serde(skip_serializing)]
    pub affected_farms: Vec<FarmId>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v: VAccount) -> Self {
        match v {
            VAccount::Current(c) => c,
        }
    }
}

impl From<Account> for VAccount {
    fn from(c: Account) -> Self {
        VAccount::Current(c)
    }
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: UnorderedMap::new(StorageKey::AccountAssets {
                account_id: account_id.clone(),
            }),
            collateral: vec![],
            borrowed: vec![],
            farms: UnorderedMap::new(StorageKey::AccountFarms {
                account_id: account_id.clone(),
            }),
            affected_farms: vec![],
        }
    }

    pub fn increase_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(collateral) = self.collateral.iter_mut().find(|c| &c.token_id == token_id) {
            collateral.shares.0 += shares.0;
        } else {
            self.collateral.push(CollateralAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .collateral
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Collateral not found");
        if let Some(new_balance) = self.collateral[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.collateral[index].shares.0 = new_balance;
            } else {
                self.collateral.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough collateral balance");
        }
    }

    pub fn increase_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(borrowed) = self.borrowed.iter_mut().find(|c| &c.token_id == token_id) {
            borrowed.shares.0 += shares.0;
        } else {
            self.borrowed.push(BorrowedAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .borrowed
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found");
        if let Some(new_balance) = self.borrowed[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.borrowed[index].shares.0 = new_balance;
            } else {
                self.borrowed.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough borrowed balance");
        }
    }

    pub fn internal_unwrap_collateral(&mut self, token_id: &TokenId) -> Shares {
        self.collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Collateral not found")
            .shares
    }

    pub fn internal_unwrap_borrowed(&mut self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found")
            .shares
    }

    pub fn add_affected_farm(&mut self, farm_id: FarmId) {
        if !self.affected_farms.contains(&farm_id) {
            self.affected_farms.push(farm_id);
        }
    }

    pub fn get_supplied_shares(&self, token_id: &TokenId) -> Shares {
        let collateral_shares = self
            .collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .map(|ca| ca.shares.0)
            .unwrap_or(0);
        let supplied_shares = self
            .internal_get_asset(token_id)
            .map(|asset| asset.shares.0)
            .unwrap_or(0);
        (supplied_shares + collateral_shares).into()
    }

    pub fn get_borrowed_shares(&self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|b| &b.token_id == token_id)
            .map(|ba| ba.shares)
            .unwrap_or(0.into())
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account_with_storage(
        &self,
        account_id: &AccountId,
    ) -> (Account, Storage) {
        (
            self.internal_unwrap_account(account_id),
            self.internal_unwrap_storage(account_id),
        )
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(
        &mut self,
        account_id: &AccountId,
        account: Account,
        storage: Storage,
    ) {
        self.accounts.insert(account_id, &account.into());
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView> {
        self.internal_get_account(account_id.as_ref())
            .map(|account| self.account_into_detailed_view(account))
    }

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    pub fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account> {
        let values = self.accounts.values_as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(values.len());
        (from_index..std::cmp::min(values.len(), limit))
            .map(|index| values.get(index).unwrap().into())
            .collect()
    }
}

'''
'''--- references/main/branches/farm/contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountAsset {
    Current(AccountAsset),
}

impl From<VAccountAsset> for AccountAsset {
    fn from(v: VAccountAsset) -> Self {
        match v {
            VAccountAsset::Current(c) => c,
        }
    }
}

impl From<AccountAsset> for VAccountAsset {
    fn from(c: AccountAsset) -> Self {
        VAccountAsset::Current(c)
    }
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic(b"Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied.get(token_id).map(|o| o.into())
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id, &account_asset.into());
        }
        self.add_affected_farm(FarmId::Supplied(token_id.clone()));
    }
}

'''
'''--- references/main/branches/farm/contract/src/account_farm.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone, Hash, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

impl FarmId {
    pub fn get_token_id(&self) -> &TokenId {
        match self {
            FarmId::Supplied(token_id) => token_id,
            FarmId::Borrowed(token_id) => token_id,
        }
    }
}

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarm {
    pub block_timestamp: Timestamp,
    pub boosted_shares: Balance,
    pub last_reward_per_share: Vec<BigDecimal>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountFarm {
    Current(AccountFarm),
}

impl From<VAccountFarm> for AccountFarm {
    fn from(v: VAccountFarm) -> Self {
        match v {
            VAccountFarm::Current(c) => c,
        }
    }
}

impl From<AccountFarm> for VAccountFarm {
    fn from(c: AccountFarm) -> Self {
        VAccountFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_account_farm_claim(
        &mut self,
        account: &mut Account,
        farm_id: &FarmId,
        asset_farm: &AssetFarm,
    ) -> (AccountFarm, Vec<(TokenId, Balance)>) {
        let mut new_rewards = Vec::new();
        let block_timestamp = env::block_timestamp();
        let mut account_farm: AccountFarm = account
            .farms
            .get(farm_id)
            .map(|v| v.into())
            .unwrap_or_else(|| AccountFarm {
                block_timestamp,
                boosted_shares: 0,
                last_reward_per_share: vec![],
            });
        if account_farm.block_timestamp != block_timestamp {
            account_farm.block_timestamp = block_timestamp;
            for (
                i,
                Reward {
                    token_id,
                    reward_per_share,
                    ..
                },
            ) in asset_farm.rewards.iter().enumerate()
            {
                if let Some(last_reward_per_share) = account_farm.last_reward_per_share.get_mut(i) {
                    let diff = reward_per_share.clone() - last_reward_per_share.clone();
                    *last_reward_per_share = reward_per_share.clone();
                    let amount = diff.round_mul_u128(account_farm.boosted_shares);
                    if amount > 0 {
                        new_rewards.push((token_id.clone(), amount));
                    }
                } else {
                    account_farm
                        .last_reward_per_share
                        .push(reward_per_share.clone());
                }
            }
        }
        (account_farm, new_rewards)
    }

    pub fn internal_account_farm_claim_all(&mut self, account: &mut Account) {
        assert!(account.affected_farms.is_empty());
        account.affected_farms.extend(account.farms.keys());
        self.internal_account_apply_affected_farms(account);
    }

    pub fn internal_account_apply_affected_farms(&mut self, account: &mut Account) {
        let mut all_rewards: HashMap<TokenId, Balance> = HashMap::new();
        let mut i = 0;
        let mut farms = vec![];
        while i < account.affected_farms.len() {
            let farm_id = account.affected_farms[i].clone();
            if let Some(asset_farm) = self.internal_get_asset_farm(&farm_id) {
                let (account_farm, new_rewards) =
                    self.internal_account_farm_claim(account, &farm_id, &asset_farm);
                for (token_id, amount) in new_rewards {
                    let new_farm_id = FarmId::Supplied(token_id.clone());
                    account.add_affected_farm(new_farm_id);
                    *all_rewards.entry(token_id).or_default() += amount;
                }
                farms.push((farm_id, account_farm, asset_farm));
            }
            i += 1;
        }
        for (token_id, &reward) in &all_rewards {
            self.internal_deposit(account, &token_id, reward);
        }
        let booster = self.internal_compute_account_booster(account);
        for (farm_id, mut account_farm, mut asset_farm) in farms {
            asset_farm.boosted_shares -= account_farm.boosted_shares;
            match &farm_id {
                FarmId::Supplied(token_id) => {
                    account_farm.boosted_shares =
                        booster.round_mul_u128(account.get_supplied_shares(token_id).0);
                }
                FarmId::Borrowed(token_id) => {
                    account_farm.boosted_shares =
                        booster.round_mul_u128(account.get_borrowed_shares(token_id).0);
                }
            }
            asset_farm.boosted_shares += account_farm.boosted_shares;
            account.farms.insert(&farm_id, &account_farm.into());
            self.internal_set_asset_farm(&farm_id, asset_farm);
        }
    }

    pub fn internal_compute_account_booster(&self, account: &Account) -> BigDecimal {
        let BoosterConfig {
            token_id,
            booster_decimals,
            booster_log_base,
        } = self.internal_config().booster_config;
        let asset = self.internal_unwrap_asset(&token_id);
        let booster_shares = account.get_supplied_shares(&token_id);
        let booster_balance = asset.supplied.shares_to_amount(booster_shares, false);
        BigDecimal::from(
            1f64 + (1f64 + ((booster_balance as f64) / 10f64.powf(booster_decimals as f64)))
                .log(booster_log_base as f64),
        )
    }
}

'''
'''--- references/main/branches/farm/contract/src/actions.rs ---
use crate::*;

const MAX_NUM_ASSETS: usize = 8;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        storage: &mut Storage,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        let mut need_risk_check = false;
        let mut need_number_check = false;
        for action in actions {
            match action {
                Action::Withdraw(asset_amount) => {
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    let amount = self.internal_withdraw(account, &asset_amount);
                    self.internal_ft_transfer(account_id, &asset_amount.token_id, amount);
                }
                Action::IncreaseCollateral(asset_amount) => {
                    need_number_check = true;
                    self.internal_increase_collateral(account, &asset_amount);
                }
                Action::DecreaseCollateral(asset_amount) => {
                    need_risk_check = true;
                    let mut account_asset =
                        account.internal_get_asset_or_default(&asset_amount.token_id);
                    self.internal_decrease_collateral(&mut account_asset, account, &asset_amount);
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Borrow(asset_amount) => {
                    need_number_check = true;
                    need_risk_check = true;
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_borrow(account, &asset_amount);
                }
                Action::Repay(asset_amount) => {
                    let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_repay(&mut account_asset, account, &asset_amount);
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Liquidate {
                    account_id: liquidation_account_id,
                    in_assets,
                    out_assets,
                } => {
                    assert_ne!(
                        account_id,
                        liquidation_account_id.as_ref(),
                        "Can't liquidate yourself"
                    );
                    assert!(!in_assets.is_empty() && !out_assets.is_empty());
                    self.internal_liquidate(
                        account,
                        storage,
                        &prices,
                        liquidation_account_id,
                        in_assets,
                        out_assets,
                    );
                }
            }
        }
        if need_number_check {
            assert!(account.collateral.len() + account.borrowed.len() <= MAX_NUM_ASSETS);
        }
        if need_risk_check {
            assert!(self.compute_max_discount(account, &prices) == BigDecimal::zero());
        }
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }

    pub fn internal_withdraw(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        asset.supplied.withdraw(shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        amount
    }

    pub fn internal_increase_collateral(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        account.increase_collateral(&asset_amount.token_id, shares);

        amount
    }

    pub fn internal_decrease_collateral(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let collateral_shares = account.internal_unwrap_collateral(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, collateral_shares, &asset_amount, false);

        account.decrease_collateral(&asset_amount.token_id, shares);

        account_asset.deposit_shares(shares);

        amount
    }

    pub fn internal_borrow(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);

        let available_amount = asset.available_amount();
        let max_borrow_shares = asset.borrowed.amount_to_shares(available_amount, false);

        let (borrowed_shares, amount) =
            asset_amount_to_shares(&asset.borrowed, max_borrow_shares, &asset_amount, true);

        assert!(amount <= available_amount);

        let supplied_shares: Shares = asset.supplied.amount_to_shares(amount, false);

        asset.borrowed.deposit(borrowed_shares, amount);
        asset.supplied.deposit(supplied_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.increase_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.deposit_shares(supplied_shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        amount
    }

    pub fn internal_repay(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let available_borrowed_shares = account.internal_unwrap_borrowed(&asset_amount.token_id);

        let (mut borrowed_shares, mut amount) = asset_amount_to_shares(
            &asset.borrowed,
            available_borrowed_shares,
            &asset_amount,
            true,
        );

        let mut supplied_shares = asset.supplied.amount_to_shares(amount, true);
        if supplied_shares.0 > account_asset.shares.0 {
            supplied_shares = account_asset.shares;
            amount = asset.supplied.shares_to_amount(supplied_shares, false);
            if let Some(min_amount) = &asset_amount.amount {
                assert!(amount >= min_amount.0, "Not enough supplied balance");
            }
            assert!(amount > 0, "Repayment amount can't be 0");

            borrowed_shares = asset.borrowed.amount_to_shares(amount, false);
            assert!(borrowed_shares.0 > 0, "Shares can't be 0");
            assert!(borrowed_shares.0 <= available_borrowed_shares.0);
        }

        asset.supplied.withdraw(supplied_shares, amount);
        asset.borrowed.withdraw(borrowed_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.decrease_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.withdraw_shares(supplied_shares);

        amount
    }

    pub fn internal_liquidate(
        &mut self,
        account: &mut Account,
        storage: &mut Storage,
        prices: &Prices,
        liquidation_account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    ) {
        let (mut liquidation_account, liquidation_storage) =
            self.internal_unwrap_account_with_storage(liquidation_account_id.as_ref());

        let max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            max_discount > BigDecimal::zero(),
            "The liquidation account is not at risk"
        );

        let mut borrowed_repaid_sum = BigDecimal::zero();
        let mut collateral_taken_sum = BigDecimal::zero();

        for asset_amount in in_assets {
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
            let amount =
                self.internal_repay(&mut account_asset, &mut liquidation_account, &asset_amount);
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            borrowed_repaid_sum = borrowed_repaid_sum
                + BigDecimal::from_balance_price(amount, prices.get_unwrap(&asset_amount.token_id));
        }

        for asset_amount in out_assets {
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);
            let amount = self.internal_decrease_collateral(
                &mut account_asset,
                &mut liquidation_account,
                &asset_amount,
            );
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            collateral_taken_sum = collateral_taken_sum
                + BigDecimal::from_balance_price(amount, prices.get_unwrap(&asset_amount.token_id));
        }

        let discounted_collateral_taken = collateral_taken_sum * (BigDecimal::one() - max_discount);
        assert!(
            discounted_collateral_taken <= borrowed_repaid_sum,
            "Not enough balances repaid"
        );

        let new_max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            new_max_discount > BigDecimal::zero(),
            "The liquidation amount is too large. The liquidation account should stay in risk"
        );

        self.internal_account_apply_affected_farms(&mut liquidation_account);
        // TODO: Fix storage increase due to farming.
        // NOTE: This method can only decrease storage, by repaying some NEL assets and taking some
        // collateral.
        let released_bytes = env::storage_usage() - liquidation_storage.initial_storage_usage;
        // We have to adjust the initial_storage_usage for the acting account to not double count
        // the released bytes, since these released bytes belongs to the liquidation account.
        storage.initial_storage_usage += released_bytes;
        self.internal_set_account(
            liquidation_account_id.as_ref(),
            liquidation_account,
            liquidation_storage,
        );
    }

    pub fn compute_max_discount(&self, account: &Account, prices: &Prices) -> BigDecimal {
        let collateral_sum = account
            .collateral
            .iter()
            .fold(BigDecimal::zero(), |sum, c| {
                let asset = self.internal_unwrap_asset(&c.token_id);
                let balance = asset.supplied.shares_to_amount(c.shares, false);
                sum + BigDecimal::from_balance_price(balance, prices.get_unwrap(&c.token_id))
                    .mul_ratio(asset.config.volatility_ratio)
            });

        let borrowed_sum = account.borrowed.iter().fold(BigDecimal::zero(), |sum, b| {
            let asset = self.internal_unwrap_asset(&b.token_id);
            let balance = asset.borrowed.shares_to_amount(b.shares, true);
            sum + BigDecimal::from_balance_price(balance, prices.get_unwrap(&b.token_id))
                .mul_ratio(asset.config.volatility_ratio)
        });

        if borrowed_sum <= collateral_sum {
            BigDecimal::zero()
        } else {
            (borrowed_sum - collateral_sum) / borrowed_sum / BigDecimal::from(2u32)
        }
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    asset_amount: &AssetAmount,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = if let Some(min_amount) = &asset_amount.amount {
        (
            pool.amount_to_shares(min_amount.0, !inverse_round_direction),
            min_amount.0,
        )
    } else if let Some(max_amount) = &asset_amount.max_amount {
        let shares = std::cmp::min(
            available_shares.0,
            pool.amount_to_shares(max_amount.0, !inverse_round_direction)
                .0,
        )
        .into();
        (
            shares,
            std::cmp::min(
                pool.shares_to_amount(shares, inverse_round_direction),
                max_amount.0,
            ),
        )
    } else {
        (
            available_shares,
            pool.shares_to_amount(available_shares, inverse_round_direction),
        )
    };
    assert!(shares.0 > 0, "Shares can't be 0");
    assert!(amount > 0, "Amount can't be 0");
    (shares, amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let (mut account, mut storage) = self.internal_unwrap_account_with_storage(&account_id);
        self.internal_execute(
            &account_id,
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(&account_id, account, storage);
    }
}

'''
'''--- references/main/branches/farm/contract/src/asset.rs ---
use crate::*;

static ASSETS: Lazy<Mutex<HashMap<TokenId, Option<Asset>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    pub asset_decimal: u128;
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            asset_decimal: 0,
            supplied: Pool::new(),
            borrowed: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn get_rate(&self) -> BigDecimal {
        self.config
            .get_rate(self.borrowed.balance, self.supplied.balance + self.reserved)
    }

    // n = 31536000000 ms in a year (365 days)
    //
    // Compute `r` from `X`. `X` is desired APY
    // (1 + r / n) ** n = X (2 == 200%)
    // n * log(1 + r / n) = log(x)
    // log(1 + r / n) = log(x) / n
    // log(1 + r  / n) = log( x ** (1 / n))
    // 1 + r / n = x ** (1 / n)
    // r / n = (x ** (1 / n)) - 1
    // r = n * ((x ** (1 / n)) - 1)
    // n = in millis
    fn compound(&mut self, time_diff_ms: Duration) {
        let rate = self.get_rate();
        log!("Rate is {}", rate);
        let interest =
            rate.pow(time_diff_ms).round_mul_u128(self.borrowed.balance) - self.borrowed.balance;
        log!("Interest added: {}", interest);
        // TODO: Split interest based on ratio between reserved and supplied?
        let reserved = ratio(interest, self.config.reserve_ratio);
        self.supplied.balance += interest - reserved;
        self.reserved += reserved;
        self.borrowed.balance += interest;
    }

    pub fn update(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff_ms = nano_to_ms(timestamp - self.last_update_timestamp);
        if time_diff_ms > 0 {
            // update
            self.last_update_timestamp += ms_to_nano(time_diff_ms);
            self.compound(time_diff_ms);
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.borrowed.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        if let Some(asset) = ASSETS.lock().unwrap().get(token_id) {
            asset.clone()
        } else {
            let asset = self.assets.get(token_id).map(|o| {
                let mut asset: Asset = o.into();
                asset.update();
                asset
            });
            ASSETS
                .lock()
                .unwrap()
                .insert(token_id.clone(), asset.clone());
            asset
        }
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, asset: Asset) {
        ASSETS
            .lock()
            .unwrap()
            .insert(token_id.clone(), Some(asset.clone()));
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset for a given token_id.
    pub fn get_asset(&self, token_id: ValidAccountId) -> Option<Asset> {
        self.internal_get_asset(token_id.as_ref())
    }

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    pub fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<(TokenId, Asset)> {
        token_ids
            .into_iter()
            .filter_map(|token_id| {
                self.internal_get_asset(token_id.as_ref())
                    .map(|asset| (token_id.into(), asset))
            })
            .collect()
    }

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    pub fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&key).unwrap().into();
                asset.update();
                (key, asset)
            })
            .collect()
    }

    pub fn debug_get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let asset = self.assets.get(&key).unwrap().into();
                (key, asset)
            })
            .collect()
    }
}

'''
'''--- references/main/branches/farm/contract/src/asset_config.rs ---
use crate::*;

const MAX_POS: u32 = 10000;
const MAX_RATIO: u32 = 10000;

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000
/// }
/// ```
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
}

impl AssetConfig {
    pub fn assert_valid(&self) {
        assert!(self.reserve_ratio <= MAX_RATIO);
        assert!(self.target_utilization < MAX_POS);
        assert!(self.target_utilization_rate.0 <= self.max_utilization_rate.0);
    }

    pub fn get_rate(
        &self,
        borrowed_balance: Balance,
        total_supplied_balance: Balance,
    ) -> BigDecimal {
        if total_supplied_balance == 0 {
            BigDecimal::one()
        } else {
            // Fix overflow
            let pos = BigDecimal::from(borrowed_balance).div_u128(total_supplied_balance);
            let target_utilization = BigDecimal::from_ratio(self.target_utilization);
            if pos < target_utilization {
                BigDecimal::one()
                    + pos * (BigDecimal::from(self.target_utilization_rate) - BigDecimal::one())
                        / target_utilization
            } else {
                BigDecimal::from(self.target_utilization_rate)
                    + (pos - target_utilization)
                        * (BigDecimal::from(self.max_utilization_rate)
                            - BigDecimal::from(self.target_utilization_rate))
                        / BigDecimal::from(MAX_POS - self.target_utilization)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ONE_NEAR: u128 = 10u128.pow(24);

    fn test_config() -> AssetConfig {
        AssetConfig {
            reserve_ratio: 2500,
            target_utilization: 8000,
            target_utilization_rate: 1000000000003593629036885046u128.into(),
            max_utilization_rate: 1000000000039724853136740579u128.into(),
            volatility_ratio: 6000,
        }
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_get_rate() {
        let config = test_config();
        let rate = config.get_rate(3 * ONE_NEAR, 18 * ONE_NEAR);
        println!("{}", rate)
    }
}

'''
'''--- references/main/branches/farm/contract/src/asset_farm.rs ---
use crate::*;

static ASSET_FARMS: Lazy<Mutex<HashMap<FarmId, Option<AssetFarm>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

const NANOS_PER_DAY: Duration = 24 * 60 * 60 * 10u64.pow(9);

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct AssetFarm {
    pub block_timestamp: Timestamp,
    pub boosted_shares: Balance,
    pub rewards: Vec<Reward>,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct Reward {
    pub token_id: TokenId,
    pub reward_per_day: Balance,

    pub remaining_rewards: Balance,
    pub reward_per_share: BigDecimal,
}

impl AssetFarm {
    pub fn update(&mut self) {
        let block_timestamp = env::block_timestamp();
        if block_timestamp == self.block_timestamp {
            return;
        }
        let time_diff = block_timestamp - self.block_timestamp;
        self.block_timestamp = block_timestamp;
        if self.boosted_shares == 0 {
            return;
        }
        for reward in &mut self.rewards {
            let acquired_rewards = std::cmp::min(
                reward.remaining_rewards,
                u128_ratio(
                    reward.reward_per_day,
                    u128::from(time_diff),
                    u128::from(NANOS_PER_DAY),
                ),
            );
            reward.remaining_rewards -= acquired_rewards;
            reward.reward_per_share = reward.reward_per_share
                + BigDecimal::from(acquired_rewards) / BigDecimal::from(self.boosted_shares);
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAssetFarm {
    Current(AssetFarm),
}

impl From<VAssetFarm> for AssetFarm {
    fn from(v: VAssetFarm) -> Self {
        match v {
            VAssetFarm::Current(c) => c,
        }
    }
}

impl From<AssetFarm> for VAssetFarm {
    fn from(c: AssetFarm) -> Self {
        VAssetFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_unwrap_asset_farm(&self, farm_id: &FarmId) -> AssetFarm {
        self.internal_get_asset_farm(farm_id)
            .expect("Asset farm not found")
    }

    pub fn internal_get_asset_farm(&self, farm_id: &FarmId) -> Option<AssetFarm> {
        if let Some(asset) = ASSET_FARMS.lock().unwrap().get(farm_id) {
            asset.clone()
        } else {
            let asset_farm = self.asset_farms.get(farm_id).map(|v| {
                let mut asset_farm: AssetFarm = v.into();
                asset_farm.update();
                asset_farm
            });
            ASSET_FARMS
                .lock()
                .unwrap()
                .insert(farm_id.clone(), asset_farm.clone());
            asset_farm
        }
    }

    pub fn internal_set_asset_farm(&mut self, farm_id: &FarmId, asset_farm: AssetFarm) {
        ASSET_FARMS
            .lock()
            .unwrap()
            .insert(farm_id.clone(), Some(asset_farm.clone()));
        self.asset_farms.insert(farm_id, &asset_farm.into());
    }
}

'''
'''--- references/main/branches/farm/contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn from_balance_price(balance: Balance, price: &Price) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        if price.decimals > NUM_DECIMALS {
            Self(num / U384::exp10((price.decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - price.decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = 31536000000;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- references/main/branches/farm/contract/src/config.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    pub oracle_account_id: ValidAccountId,

    pub owner_id: ValidAccountId,

    pub booster_config: BoosterConfig,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BoosterConfig {
    pub token_id: TokenId,

    pub booster_decimals: u8,

    pub booster_log_base: u32,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            self.internal_config().owner_id.as_ref(),
            "Not an owner"
        );
    }
}

#[near_bindgen]
impl Contract {
    /// Returns the current config.
    pub fn get_config(&self) -> Config {
        self.internal_config()
    }

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_config(&mut self, config: Config) {
        assert_one_yocto();
        self.assert_owner();
        self.config.set(&config);
    }

    #[payable]
    pub fn debug_nuke_state(&mut self) {
        assert_one_yocto();
        self.assert_owner();
        for token_id in self.asset_ids.to_vec() {
            self.assets.remove(&token_id);
        }
        self.asset_ids.clear();
        for account in self.accounts.values() {
            let mut account: Account = account.into();
            self.storage.remove(&account.account_id);
            account.supplied.clear();
        }
        self.accounts.clear();
    }

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        assert!(self.asset_ids.insert(token_id.as_ref()));
        self.internal_set_asset(
            token_id.as_ref(),
            Asset::new(env::block_timestamp(), asset_config),
        )
    }

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        let mut asset = self.internal_unwrap_asset(token_id.as_ref());
        asset.config = asset_config;
        self.internal_set_asset(token_id.as_ref(), asset);
    }
}

'''
'''--- references/main/branches/farm/contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::{is_promise_success, serde_json, PromiseOrValue};

const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 20 * TGAS;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // TODO: We need to be careful that only whitelisted tokens can call this method with a
        //     given set of actions.
        let token_id = env::predecessor_account_id();

        let actions: Vec<Action> = if msg.is_empty() {
            vec![]
        } else {
            match serde_json::from_str(&msg).expect("Can't parse TokenReceiverMsg") {
                TokenReceiverMsg::Execute { actions } => actions,
            }
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        account.add_affected_farm(FarmId::Supplied(token_id.clone()));
        self.internal_deposit(&mut account, &token_id, amount.0);
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);

        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_ft_transfer(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
        amount: Balance,
    ) -> Promise {
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            amount.into(),
            None,
            token_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id.clone(),
            token_id.clone(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let (mut account, storage) = self.internal_unwrap_account_with_storage(&account_id);
            account.add_affected_farm(FarmId::Supplied(token_id.clone()));
            self.internal_deposit(&mut account, &token_id, amount.0);
            self.internal_set_account(&account_id, account, storage);
        }
        promise_success
    }
}

'''
'''--- references/main/branches/farm/contract/src/lib.rs ---
mod account;
mod account_asset;
mod account_farm;
mod actions;
mod asset;
mod asset_config;
mod asset_farm;
mod big_decimal;
mod config;
mod fungible_token;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod utils;
mod views;

use crate::account::*;
use crate::account_asset::*;
use crate::account_farm::*;
use crate::actions::*;
use crate::asset::*;
use crate::asset_config::*;
use crate::asset_farm::*;
use crate::big_decimal::*;
use crate::config::*;
use crate::pool::*;
use crate::prices::*;
use crate::storage::*;
use crate::utils::*;
use crate::views::*;

use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{ValidAccountId, WrappedBalance};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp,
};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;

near_sdk::setup_alloc!();

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountAssets { account_id: AccountId },
    AccountFarms { account_id: AccountId },
    Storage,
    Assets,
    AssetFarms,
    AssetIds,
    Config,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, VAccount>,
    pub storage: LookupMap<AccountId, VStorage>,
    pub assets: LookupMap<TokenId, VAsset>,
    pub asset_farms: LookupMap<FarmId, VAssetFarm>,
    pub asset_ids: UnorderedSet<TokenId>,
    pub config: LazyOption<Config>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKey::Accounts),
            storage: LookupMap::new(StorageKey::Storage),
            assets: LookupMap::new(StorageKey::Assets),
            asset_farms: LookupMap::new(StorageKey::AssetFarms),
            asset_ids: UnorderedSet::new(StorageKey::AssetIds),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
        }
    }
}

'''
'''--- references/main/branches/farm/contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn shares_to_amount(&self, shares: Shares, round_up: bool) -> Balance {
        if shares.0 >= self.balance {
            self.balance
        } else {
            let extra = if round_up {
                U256::from(self.shares.0 - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.balance) * U256::from(shares.0) + extra) / U256::from(self.shares.0))
                .as_u128()
        }
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- references/main/branches/farm/contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            data.into(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);
    }
}

'''
'''--- references/main/branches/farm/contract/src/prices.rs ---
use crate::*;

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    price.map(|price| (asset_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- references/main/branches/farm/contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 1000 bytes
const MIN_STORAGE_BALANCE: Balance = 1000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize, Clone)]
#[borsh_init(init)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub initial_storage_usage: StorageUsage,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VStorage {
    Current(Storage),
}

impl From<VStorage> for Storage {
    fn from(v: VStorage) -> Self {
        match v {
            VStorage::Current(c) => c,
        }
    }
}

impl From<Storage> for VStorage {
    fn from(c: Storage) -> Self {
        VStorage::Current(c)
    }
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            initial_storage_usage: env::storage_usage(),
        }
    }

    fn init(&mut self) {
        self.initial_storage_usage = env::storage_usage();
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        let storage_usage = env::storage_usage();
        if storage_usage > storage.initial_storage_usage {
            let extra_bytes_used = storage_usage - storage.initial_storage_usage;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released = storage.initial_storage_usage - storage_usage;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic(b"The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }
            // Saving storage object copy into the persistent storage to account for used bytes.
            self.internal_set_storage(&account_id, storage.clone());
            self.internal_set_account(&account_id, Account::new(&account_id), storage);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic(b"The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic(format!("The account {} is not registered", &account_id).as_bytes());
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic(b"The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(account_id.as_ref())
    }
}

'''
'''--- references/main/branches/farm/contract/src/utils.rs ---
use crate::*;

const MAX_RATIO: u32 = 10000;

pub(crate) type TokenId = AccountId;

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

pub(crate) fn nano_to_ms(nano: u64) -> u64 {
    nano / 10u64.pow(6)
}

pub(crate) fn ms_to_nano(ms: u64) -> u64 {
    ms * 10u64.pow(6)
}

pub(crate) fn u128_ratio(a: u128, num: u128, denom: u128) -> Balance {
    (U256::from(a) * U256::from(num) / U256::from(denom)).as_u128()
}

pub(crate) fn ratio(balance: Balance, r: u32) -> Balance {
    assert!(r <= MAX_RATIO);
    u128_ratio(balance, u128::from(r), u128::from(MAX_RATIO))
}

'''
'''--- references/main/branches/farm/contract/src/views.rs ---
use crate::*;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    pub shares: Shares,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Represents the current farming booster.
    pub farming_booster: String,
}

impl Contract {
    pub fn account_into_detailed_view(&self, account: Account) -> AccountDetailedView {
        AccountDetailedView {
            farming_booster: self.internal_compute_account_booster(&account).to_string(),
            account_id: account.account_id,
            supplied: unordered_map_pagination(&account.supplied, None, None)
                .into_iter()
                .map(|(token_id, AccountAsset { shares })| {
                    let balance = self
                        .internal_unwrap_asset(&token_id)
                        .supplied
                        .shares_to_amount(shares, false);
                    AssetView {
                        token_id,
                        balance,
                        shares,
                    }
                })
                .collect(),
            collateral: account
                .collateral
                .into_iter()
                .map(|CollateralAsset { token_id, shares }| {
                    let balance = self
                        .internal_unwrap_asset(&token_id)
                        .supplied
                        .shares_to_amount(shares, false);
                    AssetView {
                        token_id,
                        balance,
                        shares,
                    }
                })
                .collect(),
            borrowed: account
                .borrowed
                .into_iter()
                .map(|BorrowedAsset { token_id, shares }| {
                    let balance = self
                        .internal_unwrap_asset(&token_id)
                        .borrowed
                        .shares_to_amount(shares, true);
                    AssetView {
                        token_id,
                        balance,
                        shares,
                    }
                })
                .collect(),
        }
    }
}

'''
'''--- references/main/branches/farm/scripts/apr_to_rate.py ---
#!/usr/bin/env python3

import sys
from decimal import *

getcontext().prec = 60

n = 31536000000
input_apr = Decimal(sys.argv[1])
print("Input APR: %s%%" % (input_apr,))
print("n: %d" % (n,))

res = (((input_apr / Decimal(100)) + Decimal(1)) ** (Decimal(1) / Decimal(n)))
print("R: %s" % (res,))
print("R ** n: %s" % (res ** n,))

round_res = round(res * (Decimal(10) ** Decimal(27)))
print("rate: %s" % (round_res, ))

'''
'''--- references/main/branches/farm/test-oracle/Cargo.toml ---
[package]
name = "test-oracle"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
common = { path = "../common/" }

'''
'''--- references/main/branches/farm/test-oracle/src/lib.rs ---
use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
#[allow(unused_imports)]
use near_sdk::AccountId;
use near_sdk::{assert_one_yocto, env, ext_contract, near_bindgen, Gas, Promise};

near_sdk::setup_alloc!();

const GAS_FOR_PROMISE: Gas = 10 * TGAS;

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: ValidAccountId,
        price_data: PriceData,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

'''
'''--- references/main/branches/farm/tests/main.rs ---

'''
'''--- references/main/branches/improve-farm-performance/Cargo.toml ---
[package]
name = "Nearlend"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dev-dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.1.0"

common = { path = "./common"}
contract = { path = "./contract" }
test-oracle = { path = "./test-oracle" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "common",
    "contract",
    "test-oracle",
]

'''
'''--- references/main/branches/improve-farm-performance/README.md ---
# Nearlend contact

## Development

### Build (optional)

Requires Rust and wasm32 target.

```bash
./build.sh
```

### Deploy on the testnet

Requires NEAR CLI to be installed.

```bash
./scripts/dev_deploy.sh
```

This will provide a list of exports at the end. Execute them to get the CLI ready for further transactions.

Example exports:
```bash
export NEAR_ENV=testnet
export OWNER_ID=dev-1634411537975-18277461139961
export ORACLE_ID=dev-1634411553736-97024242878560
export CONTRACT_ID=dev-1634411561699-94876475207945
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
```

### Create a test account

Requires exports from running `dev_deploy`. 

```bash
./scripts/create_account.sh
```

This will create a new test account with fake assets. Execute the export at the end to get the account ID.

Example export:
```bash
export ACCOUNT_ID=dev-1634680029152-10252684568108
```

## Actions

### Register account by paying for storage

This has to be done one per account.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'
```

### Supply some token

Let's supply `5` USDT. USDT has `6` decimals, so amount should be `5000000`. For a simple deposit, the `msg` can be empty string.

```bash
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'
```

### View account information

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

Note: Since USDT asset has extra `12` decimals, it brings the 5 USDT in the balance to `5000000000000000000`

### View a given asset

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '5000000000000000000', balance: '5000000000000000000' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000000000000000',
  last_update_timestamp: '1634682347763275349',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 12,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

Note: You can also see `2000000000000000000000` reserved. That's `2000` USDT from the owner.

### Provide token as a collateral

Let's add all USDT to a collateral. If the `amount` for a given action is not specified, then all available amount will be used.

Increasing the collateral doesn't require prices from the oracle, because it can't decrease the existing collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Note, you can see the USDT asset was moved from `supplied` to `collateral`

### Borrow a token

Let's borrow `1` DAI. DAI has `18` decimals, so the amount should be `1000000000000000000`.

Since borrow action puts account into the debt, we have to call this action through the oracle.
The oracle should provide prices for all assets in the collateral as well as all existing borrowed assets and the new borrowed asset.

The `msg` passed to the oracle should be string. Since it's part of the JSON, it has to be double-encoded and can't have newlines.

FYI: The message that we pass to the contract from the oracle is the following:
```json
{
  "Execute": {
    "actions": [
      {
        "Borrow": {
          "token_id": "dai.fakes.testnet",
          "amount": "1000000000000000000"
        }
      }
    ]
  }
}
```

```bash
near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'
```

You should see a log message like: `Account dev-1634682124572-99167526870966 borrows 1000000000000000000 of dai.fakes.testnet`

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966', 
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000048216105',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000064288139',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Note, without extra action the borrowed assets are not withdrawn to the wallet, but instead supplied to earn interest.
From there they can be withdrawn.
You can also notice that the borrowed balance is larger than the supplied balance, that's because the some of the interest are going to the reserve.

If we view the account info again, then the balances should increase:

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000221528817',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000295371755',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '1000000000000000000', balance: '1000000000399150907' },
  borrowed: { shares: '1000000000000000000', balance: '1000000000532201209' },
  reserved: '2000000000000133050302',
  last_update_timestamp: '1634683708614246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Withdrawing the asset

Let's withdraw all DAI including interest.

Withdrawing doesn't need oracle prices, because it can only be taken from the supplied and not from the collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'
```

You should see the log, e.g. `Account dev-1634682124572-99167526870966 withdraws 1000000001658903820 of dai.fakes.testnet`

Now let's check the DAI balance (in the wallet) of the account:

```bash
near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result: `10001000000001658903820`, which corresponds roughly to `10001` DAI, plus some extra earned interests.

Withdrawal from the contract was possible, because the owner has supplied DAI into the reserve.

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000002496596924',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Notice, there is no supplied DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '0', balance: '0' },
  borrowed: { shares: '1000000000000000000', balance: '1000000002551410252' },
  reserved: '2000000000000892506432',
  last_update_timestamp: '1634685033009246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Deposit asset and repay it in one call.

Note, multiple actions can be combined into a single atomic update. Either all of them complete or all of them are reverted.
The invariants are only checked at the end, so this may be used to replace one collateral with another without repaying debts (but this requires oracle pricing). 

Let's deposit `5` DAI and use it to repay borrowed DAI. DAI has 18 decimal, so the amount is `5000000000000000000`
For this we need to pass a custom `msg` to `ft_transfer_call`.
The message has to be double-encoded into a string.

FYI: Non-encoded message in JSON:
```json
{
  "Execute": {
    "actions": [
      {
        "Repay": {
          "token_id": "dai.fakes.testnet"
        }
      }
    ]
  }
}
```

```bash
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'
```

You should see similar log messages:
```
Account dev-1634686749015-49146327775274 deposits 5000000000000000000 of dai.fakes.testnet
Account dev-1634686749015-49146327775274 repays 1000000001735752696 of dai.fakes.testnet
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Notice, there is no borrowed DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '3999999998264247304', balance: '3999999998264247304' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000001727179674',
  last_update_timestamp: '1634688121573861187',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

And no borrowed balance or shares after repaying.

### Decreasing collateral

Since there is no borrowed assets, we can take the collateral without providing prices.

Let's get all USDT collateral back.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    },
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

'''
'''--- references/main/branches/improve-farm-performance/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/test_oracle.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/Nearlend.wasm

'''
'''--- references/main/branches/improve-farm-performance/common/Cargo.toml ---
[package]
name = "common"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dependencies]
near-sdk = "3.1.0"

'''
'''--- references/main/branches/improve-farm-performance/common/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{Balance, Gas, Timestamp};

pub type AssetId = String;
pub type DurationSec = u32;

pub const TGAS: Gas = 10u64.pow(12);
pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;

const MAX_VALID_DECIMALS: u8 = 77;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    pub multiplier: Balance,
    pub decimals: u8,
}

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

'''
'''--- references/main/branches/improve-farm-performance/contract/API.md ---
# The list of APIs that are provided by the contract

Notes:
- `u128_dec_format`, `WrappedBalance`, `Shares` means the value is passed as a decimal string representation. E.g. `1` serialized as `"1"`
- `BigDecimal` is serialized as floating string representation. E.g. `1.5` serialized as `"1.5"`
- `u64` means the value is passed as an integer.
- `Option<_>` means the value can be omitted, or provided as `null`.
- Rust enums are serialized using JSON objects. E.g. `FarmId::Supplied("token.near")` is serialized as `{"Supplied": "token.near"}`
- `HashMap<_, _>` is serialized using JSON objects.

```rust
trait Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    fn new(config: Config) -> Self;

    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView>;

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account>;

    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    fn execute(&mut self, actions: Vec<Action>);

    /// Returns a detailed view asset for a given token_id.
    /// The detailed view includes current APR and corresponding farms.
    fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView>;

    /// Returns an list of detailed view assets a given list of token_id.
    /// Only returns existing assets.
    fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView>;

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)>;

    /// Returns a list of detailed view assets from a given index up to a given limit.
    fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView>;

    /// Returns the current config.
    fn get_config(&self) -> Config;

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_config(&mut self, config: Config);

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);

    /// Claims all unclaimed farm rewards.
    fn account_farm_claim_all(&mut self);

    /// Returns an asset farm for a given farm ID.
    fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm>;

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)>;

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)>;

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        extra_amount: WrappedBalance,
    );
}
```

## Structures and types

```rust
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

/// Limited view of the account structure for liquidations
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
}

pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
}

pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

/// Contract config
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    /// The entire amount will be deposited to the asset reserve. 
    DepositToReserve,
}

enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

pub type TokenId = AccountId;
```

## Also storage management

```rust
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregestering the account is not allowed to not break the order of accounts.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}
```

'''
'''--- references/main/branches/improve-farm-performance/contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = { version = "0.9.0", default-features = false }
common = { path = "../common/" }
once_cell = "1.8.0"

[dev-dependencies]
rand = "0.8"

'''
'''--- references/main/branches/improve-farm-performance/contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
    /// Keeping track of data required for farms for this account.
    #[serde(skip_serializing)]
    pub farms: UnorderedMap<FarmId, VAccountFarm>,
    #[borsh_skip]
    #[serde(skip_serializing)]
    pub affected_farms: Vec<FarmId>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v: VAccount) -> Self {
        match v {
            VAccount::Current(c) => c,
        }
    }
}

impl From<Account> for VAccount {
    fn from(c: Account) -> Self {
        VAccount::Current(c)
    }
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: UnorderedMap::new(StorageKey::AccountAssets {
                account_id: account_id.clone(),
            }),
            collateral: vec![],
            borrowed: vec![],
            farms: UnorderedMap::new(StorageKey::AccountFarms {
                account_id: account_id.clone(),
            }),
            affected_farms: vec![],
        }
    }

    pub fn increase_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(collateral) = self.collateral.iter_mut().find(|c| &c.token_id == token_id) {
            collateral.shares.0 += shares.0;
        } else {
            self.collateral.push(CollateralAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .collateral
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Collateral not found");
        if let Some(new_balance) = self.collateral[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.collateral[index].shares.0 = new_balance;
            } else {
                self.collateral.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough collateral balance");
        }
    }

    pub fn increase_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(borrowed) = self.borrowed.iter_mut().find(|c| &c.token_id == token_id) {
            borrowed.shares.0 += shares.0;
        } else {
            self.borrowed.push(BorrowedAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .borrowed
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found");
        if let Some(new_balance) = self.borrowed[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.borrowed[index].shares.0 = new_balance;
            } else {
                self.borrowed.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough borrowed balance");
        }
    }

    pub fn internal_unwrap_collateral(&mut self, token_id: &TokenId) -> Shares {
        self.collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Collateral not found")
            .shares
    }

    pub fn internal_unwrap_borrowed(&mut self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found")
            .shares
    }

    pub fn add_affected_farm(&mut self, farm_id: FarmId) {
        if !self.affected_farms.contains(&farm_id) {
            self.affected_farms.push(farm_id);
        }
    }

    pub fn add_all_affected_farms(&mut self) {
        let len = self.affected_farms.len();
        for farm_id in self.farms.keys() {
            if len == 0
                || self
                    .affected_farms
                    .iter()
                    .take(len)
                    .find(|f| *f == &farm_id)
                    .is_none()
            {
                self.affected_farms.push(farm_id);
            }
        }
    }

    pub fn get_supplied_shares(&self, token_id: &TokenId) -> Shares {
        let collateral_shares = self
            .collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .map(|ca| ca.shares.0)
            .unwrap_or(0);
        let supplied_shares = self
            .internal_get_asset(token_id)
            .map(|asset| asset.shares.0)
            .unwrap_or(0);
        (supplied_shares + collateral_shares).into()
    }

    pub fn get_borrowed_shares(&self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|b| &b.token_id == token_id)
            .map(|ba| ba.shares)
            .unwrap_or(0.into())
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account_with_storage(
        &self,
        account_id: &AccountId,
    ) -> (Account, Storage) {
        (
            self.internal_unwrap_account(account_id),
            self.internal_unwrap_storage(account_id),
        )
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(
        &mut self,
        account_id: &AccountId,
        account: Account,
        storage: Storage,
    ) {
        self.accounts.insert(account_id, &account.into());
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView> {
        self.internal_get_account(account_id.as_ref())
            .map(|account| self.account_into_detailed_view(account))
    }

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    pub fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account> {
        let values = self.accounts.values_as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(values.len());
        (from_index..std::cmp::min(values.len(), limit))
            .map(|index| values.get(index).unwrap().into())
            .collect()
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountAsset {
    Current(AccountAsset),
}

impl From<VAccountAsset> for AccountAsset {
    fn from(v: VAccountAsset) -> Self {
        match v {
            VAccountAsset::Current(c) => c,
        }
    }
}

impl From<AccountAsset> for VAccountAsset {
    fn from(c: AccountAsset) -> Self {
        VAccountAsset::Current(c)
    }
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic(b"Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied.get(token_id).map(|o| o.into())
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id, &account_asset.into());
        }
        self.add_affected_farm(FarmId::Supplied(token_id.clone()));
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/account_farm.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Hash, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

impl FarmId {
    pub fn get_token_id(&self) -> &TokenId {
        match self {
            FarmId::Supplied(token_id) => token_id,
            FarmId::Borrowed(token_id) => token_id,
        }
    }
}

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarm {
    pub block_timestamp: Timestamp,
    pub rewards: HashMap<TokenId, AccountFarmReward>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarmReward {
    pub boosted_shares: Balance,
    pub last_reward_per_share: BigDecimal,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountFarm {
    Current(AccountFarm),
}

impl From<VAccountFarm> for AccountFarm {
    fn from(v: VAccountFarm) -> Self {
        match v {
            VAccountFarm::Current(c) => c,
        }
    }
}

impl From<AccountFarm> for VAccountFarm {
    fn from(c: AccountFarm) -> Self {
        VAccountFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_account_farm_claim(
        &self,
        account: &Account,
        farm_id: &FarmId,
        asset_farm: &AssetFarm,
    ) -> (
        AccountFarm,
        Vec<(TokenId, Balance)>,
        Vec<(TokenId, Balance)>,
    ) {
        let mut new_rewards = vec![];
        let mut inactive_rewards = vec![];
        let block_timestamp = env::block_timestamp();
        let mut account_farm: AccountFarm = account
            .farms
            .get(farm_id)
            .map(|v| v.into())
            .unwrap_or_else(|| AccountFarm {
                block_timestamp: 0,
                rewards: HashMap::new(),
            });
        if account_farm.block_timestamp != block_timestamp {
            account_farm.block_timestamp = block_timestamp;
            let mut old_rewards = std::mem::take(&mut account_farm.rewards);
            for (
                token_id,
                AssetFarmReward {
                    reward_per_share, ..
                },
            ) in &asset_farm.rewards
            {
                let boosted_shares = if let Some(AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                }) = old_rewards.remove(token_id)
                {
                    let diff = reward_per_share.clone() - last_reward_per_share;
                    let amount = diff.round_mul_u128(boosted_shares);
                    if amount > 0 {
                        new_rewards.push((token_id.clone(), amount));
                    }
                    boosted_shares
                } else {
                    0
                };
                account_farm.rewards.insert(
                    token_id.clone(),
                    AccountFarmReward {
                        boosted_shares,
                        last_reward_per_share: reward_per_share.clone(),
                    },
                );
            }
            for (
                token_id,
                AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                },
            ) in old_rewards
            {
                let AssetFarmReward {
                    reward_per_share, ..
                } = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                let diff = reward_per_share - last_reward_per_share;
                let amount = diff.round_mul_u128(boosted_shares);
                inactive_rewards.push((token_id.clone(), boosted_shares));
                if amount > 0 {
                    new_rewards.push((token_id, amount));
                }
            }
        }
        (account_farm, new_rewards, inactive_rewards)
    }

    pub fn internal_account_apply_affected_farms(
        &mut self,
        account: &mut Account,
        verify_booster: bool,
    ) {
        let config = self.internal_config();
        if verify_booster
            && account
                .affected_farms
                .contains(&FarmId::Supplied(config.booster_token_id.clone()))
        {
            account.add_all_affected_farms();
        }
        if account.affected_farms.is_empty() {
            return;
        }
        let mut all_rewards: HashMap<TokenId, Balance> = HashMap::new();
        let mut i = 0;
        let mut farms = vec![];
        while i < account.affected_farms.len() {
            let farm_id = account.affected_farms[i].clone();
            if let Some(asset_farm) = self.internal_get_asset_farm(&farm_id) {
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(account, &farm_id, &asset_farm);
                for (token_id, amount) in new_rewards {
                    let new_farm_id = FarmId::Supplied(token_id.clone());
                    account.add_affected_farm(new_farm_id);
                    *all_rewards.entry(token_id).or_default() += amount;
                }
                farms.push((farm_id, account_farm, asset_farm, inactive_rewards));
            }
            i += 1;
        }
        for (token_id, &reward) in &all_rewards {
            self.internal_deposit(account, &token_id, reward);
        }
        let booster_balance = self
            .internal_unwrap_asset(&config.booster_token_id)
            .supplied
            .shares_to_amount(account.get_supplied_shares(&config.booster_token_id), false);
        let booster_base = 10u128.pow(config.booster_decimals as u32);

        for (farm_id, mut account_farm, mut asset_farm, inactive_rewards) in farms {
            let shares = match &farm_id {
                FarmId::Supplied(token_id) => account.get_supplied_shares(token_id).0,
                FarmId::Borrowed(token_id) => account.get_borrowed_shares(token_id).0,
            };
            for (token_id, asset_farm_reward) in asset_farm.rewards.iter_mut() {
                let account_farm_reward = account_farm.rewards.get_mut(token_id).unwrap();
                asset_farm_reward.boosted_shares -= account_farm_reward.boosted_shares;
                if shares > 0 {
                    let extra_shares = if booster_balance > booster_base {
                        let log_base =
                            (asset_farm_reward.booster_log_base as f64) / (booster_base as f64);
                        ((shares as f64)
                            * ((booster_balance as f64) / (booster_base as f64)).log(log_base))
                            as u128
                    } else {
                        0
                    };
                    account_farm_reward.boosted_shares = shares + extra_shares;
                    asset_farm_reward.boosted_shares += account_farm_reward.boosted_shares;
                }
            }
            for (token_id, boosted_shares) in inactive_rewards {
                let mut asset_farm_reward = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                asset_farm_reward.boosted_shares -= boosted_shares;
                asset_farm.internal_set_inactive_asset_farm_reward(&token_id, asset_farm_reward);
            }
            if shares > 0 {
                account.farms.insert(&farm_id, &account_farm.into());
            } else {
                account.farms.remove(&farm_id);
            }
            self.internal_set_asset_farm(&farm_id, asset_farm);
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Claims all unclaimed farm rewards.
    pub fn account_farm_claim_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let (mut account, storage) =
            self.internal_unwrap_account_with_storage(&env::predecessor_account_id());
        account.add_all_affected_farms();
        self.internal_account_apply_affected_farms(&mut account, false);
        self.internal_set_account(&account_id, account, storage);
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/account_view.rs ---
use crate::*;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

impl Contract {
    pub fn account_into_detailed_view(&self, account: Account) -> AccountDetailedView {
        let farms = account
            .farms
            .keys()
            .map(|farm_id| {
                let mut asset_farm = self.internal_unwrap_asset_farm(&farm_id);
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(&account, &farm_id, &asset_farm);
                AccountFarmView {
                    farm_id,
                    rewards: account_farm
                        .rewards
                        .into_iter()
                        .map(|(token_id, AccountFarmReward { boosted_shares, .. })| {
                            (token_id, boosted_shares)
                        })
                        .chain(inactive_rewards)
                        .map(|(reward_token_id, boosted_shares)| {
                            let asset_farm_reward = asset_farm
                                .rewards
                                .remove(&reward_token_id)
                                .or_else(|| {
                                    asset_farm
                                        .internal_get_inactive_asset_farm_reward(&reward_token_id)
                                })
                                .unwrap();
                            let unclaimed_amount = new_rewards
                                .iter()
                                .find(|(token_id, _)| token_id == &reward_token_id)
                                .map(|(_, amount)| *amount)
                                .unwrap_or(0);
                            AccountFarmRewardView {
                                reward_token_id,
                                asset_farm_reward,
                                boosted_shares,
                                unclaimed_amount,
                            }
                        })
                        .collect(),
                }
            })
            .collect();
        AccountDetailedView {
            account_id: account.account_id,
            supplied: unordered_map_pagination(&account.supplied, None, None)
                .into_iter()
                .map(|(token_id, AccountAsset { shares })| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            collateral: account
                .collateral
                .into_iter()
                .map(|CollateralAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            borrowed: account
                .borrowed
                .into_iter()
                .map(|BorrowedAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, true)
                })
                .collect(),
            farms,
        }
    }

    fn get_asset_view(&self, token_id: TokenId, shares: Shares, is_borrowing: bool) -> AssetView {
        let asset = self.internal_unwrap_asset(&token_id);
        let apr = if is_borrowing {
            asset.get_borrow_apr()
        } else {
            asset.get_supply_apr()
        };
        let balance = if is_borrowing {
            asset.borrowed.shares_to_amount(shares, true)
        } else {
            asset.supplied.shares_to_amount(shares, false)
        };

        AssetView {
            token_id,
            balance,
            shares,
            apr,
        }
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/actions.rs ---
use crate::*;

const MAX_NUM_ASSETS: usize = 8;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        storage: &mut Storage,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        let mut need_risk_check = false;
        let mut need_number_check = false;
        for action in actions {
            match action {
                Action::Withdraw(asset_amount) => {
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    let amount = self.internal_withdraw(account, &asset_amount);
                    self.internal_ft_transfer(account_id, &asset_amount.token_id, amount);
                    log!(
                        "Account {} withdraws {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::IncreaseCollateral(asset_amount) => {
                    need_number_check = true;
                    let amount = self.internal_increase_collateral(account, &asset_amount);
                    log!(
                        "Account {} increases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::DecreaseCollateral(asset_amount) => {
                    need_risk_check = true;
                    let mut account_asset =
                        account.internal_get_asset_or_default(&asset_amount.token_id);
                    let amount = self.internal_decrease_collateral(
                        &mut account_asset,
                        account,
                        &asset_amount,
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                    log!(
                        "Account {} decreases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Borrow(asset_amount) => {
                    need_number_check = true;
                    need_risk_check = true;
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_borrow(account, &asset_amount);
                    log!(
                        "Account {} borrows {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Repay(asset_amount) => {
                    let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_repay(&mut account_asset, account, &asset_amount);
                    log!(
                        "Account {} repays {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Liquidate {
                    account_id: liquidation_account_id,
                    in_assets,
                    out_assets,
                } => {
                    assert_ne!(
                        account_id,
                        liquidation_account_id.as_ref(),
                        "Can't liquidate yourself"
                    );
                    assert!(!in_assets.is_empty() && !out_assets.is_empty());
                    self.internal_liquidate(
                        account_id,
                        account,
                        storage,
                        &prices,
                        liquidation_account_id.as_ref(),
                        in_assets,
                        out_assets,
                    );
                }
            }
        }
        if need_number_check {
            assert!(account.collateral.len() + account.borrowed.len() <= MAX_NUM_ASSETS);
        }
        if need_risk_check {
            assert!(self.compute_max_discount(account, &prices) == BigDecimal::zero());
        }

        self.internal_account_apply_affected_farms(account, true);
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }

    pub fn internal_withdraw(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_withdraw,
            "Withdrawals for this asset are not enabled"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        let available_amount = asset.available_amount();

        assert!(
            amount <= available_amount,
            "Withdraw error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        asset.supplied.withdraw(shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        amount
    }

    pub fn internal_increase_collateral(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_use_as_collateral,
            "Thi asset can't be used as a collateral"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        account.increase_collateral(&asset_amount.token_id, shares);

        amount
    }

    pub fn internal_decrease_collateral(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let collateral_shares = account.internal_unwrap_collateral(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, collateral_shares, &asset_amount, false);

        account.decrease_collateral(&asset_amount.token_id, shares);

        account_asset.deposit_shares(shares);

        amount
    }

    pub fn internal_borrow(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(asset.config.can_borrow, "Thi asset can't be used borrowed");

        let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);

        let available_amount = asset.available_amount();
        let max_borrow_shares = asset.borrowed.amount_to_shares(available_amount, false);

        let (borrowed_shares, amount) =
            asset_amount_to_shares(&asset.borrowed, max_borrow_shares, &asset_amount, true);

        assert!(
            amount <= available_amount,
            "Borrow error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        let supplied_shares: Shares = asset.supplied.amount_to_shares(amount, false);

        asset.borrowed.deposit(borrowed_shares, amount);
        asset.supplied.deposit(supplied_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.increase_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.deposit_shares(supplied_shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        amount
    }

    pub fn internal_repay(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let available_borrowed_shares = account.internal_unwrap_borrowed(&asset_amount.token_id);

        let (mut borrowed_shares, mut amount) = asset_amount_to_shares(
            &asset.borrowed,
            available_borrowed_shares,
            &asset_amount,
            true,
        );

        let mut supplied_shares = asset.supplied.amount_to_shares(amount, true);
        if supplied_shares.0 > account_asset.shares.0 {
            supplied_shares = account_asset.shares;
            amount = asset.supplied.shares_to_amount(supplied_shares, false);
            if let Some(min_amount) = &asset_amount.amount {
                assert!(amount >= min_amount.0, "Not enough supplied balance");
            }
            assert!(amount > 0, "Repayment amount can't be 0");

            borrowed_shares = asset.borrowed.amount_to_shares(amount, false);
            assert!(borrowed_shares.0 > 0, "Shares can't be 0");
            assert!(borrowed_shares.0 <= available_borrowed_shares.0);
        }

        asset.supplied.withdraw(supplied_shares, amount);
        asset.borrowed.withdraw(borrowed_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.decrease_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.withdraw_shares(supplied_shares);

        amount
    }

    pub fn internal_liquidate(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        storage: &mut Storage,
        prices: &Prices,
        liquidation_account_id: &AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    ) {
        let (mut liquidation_account, mut liquidation_storage) =
            self.internal_unwrap_account_with_storage(liquidation_account_id);

        let max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            max_discount > BigDecimal::zero(),
            "The liquidation account is not at risk"
        );

        let mut borrowed_repaid_sum = BigDecimal::zero();
        let mut collateral_taken_sum = BigDecimal::zero();

        for asset_amount in in_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
            let amount =
                self.internal_repay(&mut account_asset, &mut liquidation_account, &asset_amount);
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            borrowed_repaid_sum = borrowed_repaid_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        for asset_amount in out_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);
            let amount = self.internal_decrease_collateral(
                &mut account_asset,
                &mut liquidation_account,
                &asset_amount,
            );
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            collateral_taken_sum = collateral_taken_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        let discounted_collateral_taken = collateral_taken_sum * (BigDecimal::one() - max_discount);
        assert!(
            discounted_collateral_taken <= borrowed_repaid_sum,
            "Not enough balances repaid"
        );

        let new_max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            new_max_discount > BigDecimal::zero(),
            "The liquidation amount is too large. The liquidation account should stay in risk"
        );

        self.internal_account_apply_affected_farms(&mut liquidation_account, true);

        // We have to adjust the initial_storage_usage for the acting account to not double count
        // the bytes from the liquidation account. As well as potentially cover the extra bytes
        // required by the liquidation account that might be added due to farms.
        let current_storage_usage = env::storage_usage();
        if current_storage_usage > liquidation_storage.initial_storage_usage {
            let required_bytes = current_storage_usage - liquidation_storage.initial_storage_usage;
            let available_bytes = liquidation_storage.available_bytes();
            if available_bytes < required_bytes {
                let extra_bytes = required_bytes - available_bytes;
                log!(
                    "Account {} has to cover extra storage of {} bytes for liquidation account {}",
                    account_id,
                    extra_bytes,
                    liquidation_account_id,
                );
                liquidation_storage.initial_storage_usage += extra_bytes;
                storage.initial_storage_usage += available_bytes;
            } else {
                storage.initial_storage_usage += required_bytes;
            }
        } else {
            let released_bytes = liquidation_storage.initial_storage_usage - current_storage_usage;
            storage.initial_storage_usage -= released_bytes;
        }
        self.internal_set_account(
            liquidation_account_id,
            liquidation_account,
            liquidation_storage,
        );

        log!(
            "Account {} liquidates account {}: takes {} for repaying {}",
            account_id,
            liquidation_account_id,
            collateral_taken_sum,
            borrowed_repaid_sum
        );
    }

    pub fn compute_max_discount(&self, account: &Account, prices: &Prices) -> BigDecimal {
        if account.borrowed.is_empty() {
            return BigDecimal::zero();
        }

        let collateral_sum = account
            .collateral
            .iter()
            .fold(BigDecimal::zero(), |sum, c| {
                let asset = self.internal_unwrap_asset(&c.token_id);
                let balance = asset.supplied.shares_to_amount(c.shares, false);
                sum + BigDecimal::from_balance_price(
                    balance,
                    prices.get_unwrap(&c.token_id),
                    asset.config.extra_decimals,
                )
                .mul_ratio(asset.config.volatility_ratio)
            });

        let borrowed_sum = account.borrowed.iter().fold(BigDecimal::zero(), |sum, b| {
            let asset = self.internal_unwrap_asset(&b.token_id);
            let balance = asset.borrowed.shares_to_amount(b.shares, true);
            sum + BigDecimal::from_balance_price(
                balance,
                prices.get_unwrap(&b.token_id),
                asset.config.extra_decimals,
            )
            .div_ratio(asset.config.volatility_ratio)
        });

        if borrowed_sum <= collateral_sum {
            BigDecimal::zero()
        } else {
            (borrowed_sum - collateral_sum) / borrowed_sum / BigDecimal::from(2u32)
        }
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    asset_amount: &AssetAmount,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = if let Some(amount) = &asset_amount.amount {
        (
            pool.amount_to_shares(amount.0, !inverse_round_direction),
            amount.0,
        )
    } else if let Some(max_amount) = &asset_amount.max_amount {
        let shares = std::cmp::min(
            available_shares.0,
            pool.amount_to_shares(max_amount.0, !inverse_round_direction)
                .0,
        )
        .into();
        (
            shares,
            std::cmp::min(
                pool.shares_to_amount(shares, inverse_round_direction),
                max_amount.0,
            ),
        )
    } else {
        (
            available_shares,
            pool.shares_to_amount(available_shares, inverse_round_direction),
        )
    };
    assert!(shares.0 > 0, "Shares can't be 0");
    assert!(amount > 0, "Amount can't be 0");
    (shares, amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let (mut account, mut storage) = self.internal_unwrap_account_with_storage(&account_id);
        self.internal_execute(
            &account_id,
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(&account_id, account, storage);
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/asset.rs ---
use crate::*;

pub(crate) const NANOS_PER_YEAR: u64 = 31536000000;

static ASSETS: Lazy<Mutex<HashMap<TokenId, Option<Asset>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            supplied: Pool::new(),
            borrowed: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn get_rate(&self) -> BigDecimal {
        self.config
            .get_rate(self.borrowed.balance, self.supplied.balance + self.reserved)
    }

    pub fn get_borrow_apr(&self) -> BigDecimal {
        let rate = self.get_rate();
        rate.pow(NANOS_PER_YEAR) - BigDecimal::one()
    }

    pub fn get_supply_apr(&self) -> BigDecimal {
        if self.supplied.balance == 0 || self.borrowed.balance == 0 {
            return BigDecimal::zero();
        }

        let borrow_apr = self.get_borrow_apr();
        if borrow_apr == BigDecimal::zero() {
            return borrow_apr;
        }

        let interest = borrow_apr.round_mul_u128(self.borrowed.balance);
        let supply_interest = ratio(interest, MAX_RATIO - self.config.reserve_ratio);
        BigDecimal::from(supply_interest).div_u128(self.supplied.balance)
    }

    // n = 31536000000 ms in a year (365 days)
    //
    // Compute `r` from `X`. `X` is desired APY
    // (1 + r / n) ** n = X (2 == 200%)
    // n * log(1 + r / n) = log(x)
    // log(1 + r / n) = log(x) / n
    // log(1 + r  / n) = log( x ** (1 / n))
    // 1 + r / n = x ** (1 / n)
    // r / n = (x ** (1 / n)) - 1
    // r = n * ((x ** (1 / n)) - 1)
    // n = in millis
    fn compound(&mut self, time_diff_ms: Duration) {
        let rate = self.get_rate();
        let interest =
            rate.pow(time_diff_ms).round_mul_u128(self.borrowed.balance) - self.borrowed.balance;
        // TODO: Split interest based on ratio between reserved and supplied?
        let reserved = ratio(interest, self.config.reserve_ratio);
        if self.supplied.shares.0 > 0 {
            self.supplied.balance += interest - reserved;
            self.reserved += reserved;
        } else {
            self.reserved += interest;
        }
        self.borrowed.balance += interest;
    }

    pub fn update(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff_ms = nano_to_ms(timestamp - self.last_update_timestamp);
        if time_diff_ms > 0 {
            // update
            self.last_update_timestamp += ms_to_nano(time_diff_ms);
            self.compound(time_diff_ms);
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.borrowed.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        let mut cache = ASSETS.lock().unwrap();
        cache.get(token_id).cloned().unwrap_or_else(|| {
            let asset = self.assets.get(token_id).map(|o| {
                let mut asset: Asset = o.into();
                asset.update();
                asset
            });
            cache.insert(token_id.clone(), asset.clone());
            asset
        })
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, mut asset: Asset) {
        if asset.supplied.shares.0 == 0 && asset.supplied.balance > 0 {
            asset.reserved += asset.supplied.balance;
            asset.supplied.balance = 0;
        }
        assert!(
            asset.borrowed.shares.0 > 0 || asset.borrowed.balance == 0,
            "Borrowed invariant broken"
        );
        ASSETS
            .lock()
            .unwrap()
            .insert(token_id.clone(), Some(asset.clone()));
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset for a given token_id.
    pub fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView> {
        self.internal_get_asset(token_id.as_ref())
            .map(|asset| self.asset_into_detailed_view(token_id.into(), asset))
    }

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    pub fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView> {
        token_ids
            .into_iter()
            .filter_map(|token_id| {
                self.internal_get_asset(token_id.as_ref())
                    .map(|asset| self.asset_into_detailed_view(token_id.into(), asset))
            })
            .collect()
    }

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    pub fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&key).unwrap().into();
                asset.update();
                (key, asset)
            })
            .collect()
    }

    pub fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let token_id = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&token_id).unwrap().into();
                asset.update();
                self.asset_into_detailed_view(token_id, asset)
            })
            .collect()
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/asset_config.rs ---
use crate::*;

const MAX_POS: u32 = 10000;
const MAX_RATIO: u32 = 10000;

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

impl AssetConfig {
    pub fn assert_valid(&self) {
        assert!(self.reserve_ratio <= MAX_RATIO);
        assert!(self.target_utilization < MAX_POS);
        assert!(self.target_utilization_rate.0 <= self.max_utilization_rate.0);
    }

    pub fn get_rate(
        &self,
        borrowed_balance: Balance,
        total_supplied_balance: Balance,
    ) -> BigDecimal {
        if total_supplied_balance == 0 {
            BigDecimal::one()
        } else {
            let pos = BigDecimal::from(borrowed_balance).div_u128(total_supplied_balance);
            let target_utilization = BigDecimal::from_ratio(self.target_utilization);
            if pos < target_utilization {
                BigDecimal::one()
                    + pos * (BigDecimal::from(self.target_utilization_rate) - BigDecimal::one())
                        / target_utilization
            } else {
                BigDecimal::from(self.target_utilization_rate)
                    + (pos - target_utilization)
                        * (BigDecimal::from(self.max_utilization_rate)
                            - BigDecimal::from(self.target_utilization_rate))
                        / BigDecimal::from_ratio(MAX_POS - self.target_utilization)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ONE_NEAR: u128 = 10u128.pow(24);

    fn test_config() -> AssetConfig {
        AssetConfig {
            reserve_ratio: 2500,
            target_utilization: 8000,
            target_utilization_rate: 1000000000003593629036885046u128.into(),
            max_utilization_rate: 1000000000039724853136740579u128.into(),
            volatility_ratio: 6000,
            extra_decimals: 0,
            can_deposit: true,
            can_withdraw: true,
            can_use_as_collateral: true,
            can_borrow: true,
        }
    }

    #[test]
    fn test_get_rate_and_apr() {
        let config = test_config();
        let rate = config.get_rate(81 * ONE_NEAR, 100 * ONE_NEAR);
        println!("Rate: {}", rate);

        let apr = rate.pow(NANOS_PER_YEAR) - BigDecimal::one();
        println!("APR: {}", apr)
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/asset_farm.rs ---
use crate::*;

static ASSET_FARMS: Lazy<Mutex<HashMap<FarmId, Option<AssetFarm>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

const NANOS_PER_DAY: Duration = 24 * 60 * 60 * 10u64.pow(9);

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
    /// Inactive rewards
    #[serde(skip_serializing)]
    pub inactive_rewards: LookupMap<TokenId, VAssetFarmReward>,
}

impl Clone for AssetFarm {
    fn clone(&self) -> Self {
        Self {
            block_timestamp: self.block_timestamp,
            rewards: self.rewards.clone(),
            inactive_rewards: BorshDeserialize::try_from_slice(
                &self.inactive_rewards.try_to_vec().unwrap(),
            )
            .unwrap(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VAssetFarmReward {
    Current(AssetFarmReward),
}

impl From<VAssetFarmReward> for AssetFarmReward {
    fn from(v: VAssetFarmReward) -> Self {
        match v {
            VAssetFarmReward::Current(c) => c,
        }
    }
}

impl From<AssetFarmReward> for VAssetFarmReward {
    fn from(c: AssetFarmReward) -> Self {
        VAssetFarmReward::Current(c)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Serialize, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(skip)]
    pub reward_per_share: BigDecimal,
}

impl AssetFarm {
    pub fn update(&mut self) {
        let block_timestamp = env::block_timestamp();
        if block_timestamp == self.block_timestamp {
            return;
        }
        let time_diff = block_timestamp - self.block_timestamp;
        self.block_timestamp = block_timestamp;
        let mut new_inactive_reward = vec![];
        for (token_id, reward) in self.rewards.iter_mut() {
            if reward.boosted_shares == 0 {
                continue;
            }
            let acquired_rewards = std::cmp::min(
                reward.remaining_rewards,
                u128_ratio(
                    reward.reward_per_day,
                    u128::from(time_diff),
                    u128::from(NANOS_PER_DAY),
                ),
            );
            reward.remaining_rewards -= acquired_rewards;
            reward.reward_per_share = reward.reward_per_share
                + BigDecimal::from(acquired_rewards) / BigDecimal::from(reward.boosted_shares);
            if reward.remaining_rewards == 0 {
                new_inactive_reward.push(token_id.clone());
            }
        }
        for token_id in new_inactive_reward {
            let reward = self.rewards.remove(&token_id).unwrap();
            self.internal_set_inactive_asset_farm_reward(&token_id, reward);
        }
    }

    pub fn internal_get_inactive_asset_farm_reward(
        &self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.get(token_id).map(|o| o.into())
    }

    pub fn internal_remove_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.remove(token_id).map(|o| o.into())
    }

    pub fn internal_set_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
        asset_farm_reward: AssetFarmReward,
    ) {
        self.inactive_rewards
            .insert(token_id, &asset_farm_reward.into());
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAssetFarm {
    Current(AssetFarm),
}

impl From<VAssetFarm> for AssetFarm {
    fn from(v: VAssetFarm) -> Self {
        match v {
            VAssetFarm::Current(c) => c,
        }
    }
}

impl From<AssetFarm> for VAssetFarm {
    fn from(c: AssetFarm) -> Self {
        VAssetFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_unwrap_asset_farm(&self, farm_id: &FarmId) -> AssetFarm {
        self.internal_get_asset_farm(farm_id)
            .expect("Asset farm not found")
    }

    pub fn internal_get_asset_farm(&self, farm_id: &FarmId) -> Option<AssetFarm> {
        let mut cache = ASSET_FARMS.lock().unwrap();
        cache.get(farm_id).cloned().unwrap_or_else(|| {
            let asset_farm = self.asset_farms.get(farm_id).map(|v| {
                let mut asset_farm: AssetFarm = v.into();
                asset_farm.update();
                asset_farm
            });
            cache.insert(farm_id.clone(), asset_farm.clone());
            asset_farm
        })
    }

    pub fn internal_set_asset_farm(&mut self, farm_id: &FarmId, asset_farm: AssetFarm) {
        ASSET_FARMS
            .lock()
            .unwrap()
            .insert(farm_id.clone(), Some(asset_farm.clone()));
        self.asset_farms.insert(farm_id, &asset_farm.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset farm for a given farm ID.
    pub fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm> {
        self.internal_get_asset_farm(&farm_id)
    }

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    pub fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)> {
        farm_ids
            .into_iter()
            .filter_map(|farm_id| {
                self.internal_get_asset_farm(&farm_id)
                    .map(|asset_farm| (farm_id, asset_farm))
            })
            .collect()
    }

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    pub fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        let mut farm_ids = vec![];
        for index in from_index..std::cmp::min(keys.len(), limit) {
            let token_id = keys.get(index).unwrap();
            farm_ids.push(FarmId::Supplied(token_id.clone()));
            farm_ids.push(FarmId::Borrowed(token_id));
        }
        self.get_asset_farms(farm_ids)
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/asset_view.rs ---
use crate::*;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

impl Contract {
    pub fn asset_into_detailed_view(&self, token_id: TokenId, asset: Asset) -> AssetDetailedView {
        let farms = self
            .get_asset_farms(vec![
                FarmId::Supplied(token_id.clone()),
                FarmId::Borrowed(token_id.clone()),
            ])
            .into_iter()
            .map(|(farm_id, asset_farm)| AssetFarmView {
                farm_id,
                rewards: asset_farm.rewards,
            })
            .collect();
        let supply_apr = asset.get_supply_apr();
        let borrow_apr = asset.get_borrow_apr();
        let Asset {
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
        } = asset;
        AssetDetailedView {
            token_id,
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
            supply_apr,
            borrow_apr,
            farms,
        }
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn from_balance_price(balance: Balance, price: &Price, extra_decimals: u8) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        let denominator_decimals = price.decimals + extra_decimals;
        if denominator_decimals > NUM_DECIMALS {
            Self(num / U384::exp10((denominator_decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - denominator_decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = NANOS_PER_YEAR;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/config.rs ---
use crate::*;

/// Contract config
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            self.internal_config().owner_id.as_ref(),
            "Not an owner"
        );
    }
}

#[near_bindgen]
impl Contract {
    /// Returns the current config.
    pub fn get_config(&self) -> Config {
        self.internal_config()
    }

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_config(&mut self, config: Config) {
        assert_one_yocto();
        self.assert_owner();
        self.config.set(&config);
    }

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        assert!(self.asset_ids.insert(token_id.as_ref()));
        self.internal_set_asset(
            token_id.as_ref(),
            Asset::new(env::block_timestamp(), asset_config),
        )
    }

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        let mut asset = self.internal_unwrap_asset(token_id.as_ref());
        asset.config = asset_config;
        self.internal_set_asset(token_id.as_ref(), asset);
    }

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        reward_token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        reward_amount: WrappedBalance,
    ) {
        assert_one_yocto();
        self.assert_owner();
        assert!(self.assets.contains_key(farm_id.get_token_id()));
        let reward_token_id: TokenId = reward_token_id.into();
        let mut reward_asset = self.internal_unwrap_asset(&reward_token_id);
        assert!(
            reward_asset.reserved >= reward_amount.0
                && reward_asset.available_amount() >= reward_amount.0,
            "Not enough reserved reward balance"
        );
        reward_asset.reserved -= reward_amount.0;
        self.internal_set_asset(&reward_token_id, reward_asset);
        let mut asset_farm = self
            .internal_get_asset_farm(&farm_id)
            .unwrap_or_else(|| AssetFarm {
                block_timestamp: env::block_timestamp(),
                rewards: HashMap::new(),
                inactive_rewards: LookupMap::new(StorageKey::InactiveAssetFarmRewards {
                    farm_id: farm_id.clone(),
                }),
            });

        let mut asset_farm_reward = asset_farm
            .rewards
            .remove(&reward_token_id)
            .or_else(|| asset_farm.internal_remove_inactive_asset_farm_reward(&reward_token_id))
            .unwrap_or_default();
        asset_farm_reward.reward_per_day = new_reward_per_day.into();
        asset_farm_reward.booster_log_base = new_booster_log_base.into();
        asset_farm_reward.remaining_rewards += reward_amount.0;
        asset_farm
            .rewards
            .insert(reward_token_id, asset_farm_reward);
        self.internal_set_asset_farm(&farm_id, asset_farm);
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::{is_promise_success, serde_json, PromiseOrValue};

const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 20 * TGAS;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    DepositToReserve,
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_id = env::predecessor_account_id();
        let mut asset = self.internal_unwrap_asset(&token_id);
        assert!(
            asset.config.can_deposit,
            "Deposits for this asset are not enabled"
        );

        let amount = amount.0 * 10u128.pow(asset.config.extra_decimals as u32);

        // TODO: We need to be careful that only whitelisted tokens can call this method with a
        //     given set of actions. Or verify which actions are possible to do.
        let actions: Vec<Action> = if msg.is_empty() {
            vec![]
        } else {
            let token_receiver_msg: TokenReceiverMsg =
                serde_json::from_str(&msg).expect("Can't parse TokenReceiverMsg");
            match token_receiver_msg {
                TokenReceiverMsg::Execute { actions } => actions,
                TokenReceiverMsg::DepositToReserve => {
                    asset.reserved += amount;
                    self.internal_set_asset(&token_id, asset);
                    log!(
                        "Account {} deposits to reserve {} of {}",
                        sender_id.as_ref(),
                        amount,
                        token_id
                    );
                    return PromiseOrValue::Value(U128(0));
                }
            }
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        account.add_affected_farm(FarmId::Supplied(token_id.clone()));
        self.internal_deposit(&mut account, &token_id, amount);
        log!("Account {} deposits {} of {}", sender_id, amount, token_id);
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);

        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_ft_transfer(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
        amount: Balance,
    ) -> Promise {
        let asset = self.internal_unwrap_asset(token_id);
        let ft_amount = amount / 10u128.pow(asset.config.extra_decimals as u32);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            ft_amount.into(),
            None,
            token_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id.clone(),
            token_id.clone(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let (mut account, storage) = self.internal_unwrap_account_with_storage(&account_id);
            account.add_affected_farm(FarmId::Supplied(token_id.clone()));
            self.internal_deposit(&mut account, &token_id, amount.0);
            log!(
                "Withdrawal has failed: Account {} deposits {} of {}",
                account_id,
                amount.0,
                token_id
            );
            self.internal_set_account(&account_id, account, storage);
        }
        promise_success
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/lib.rs ---
mod account;
mod account_asset;
mod account_farm;
mod account_view;
mod actions;
mod asset;
mod asset_config;
mod asset_farm;
mod asset_view;
mod big_decimal;
mod config;
mod fungible_token;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod utils;

use crate::account::*;
use crate::account_asset::*;
use crate::account_farm::*;
use crate::account_view::*;
use crate::actions::*;
use crate::asset::*;
use crate::asset_config::*;
use crate::asset_farm::*;
use crate::asset_view::*;
use crate::big_decimal::*;
use crate::config::*;
use crate::pool::*;
use crate::prices::*;
use crate::storage::*;
use crate::utils::*;

use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{ValidAccountId, WrappedBalance};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp,
};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;

near_sdk::setup_alloc!();

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountAssets { account_id: AccountId },
    AccountFarms { account_id: AccountId },
    Storage,
    Assets,
    AssetFarms,
    InactiveAssetFarmRewards { farm_id: FarmId },
    AssetIds,
    Config,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, VAccount>,
    pub storage: LookupMap<AccountId, VStorage>,
    pub assets: LookupMap<TokenId, VAsset>,
    pub asset_farms: LookupMap<FarmId, VAssetFarm>,
    pub asset_ids: UnorderedSet<TokenId>,
    pub config: LazyOption<Config>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKey::Accounts),
            storage: LookupMap::new(StorageKey::Storage),
            assets: LookupMap::new(StorageKey::Assets),
            asset_farms: LookupMap::new(StorageKey::AssetFarms),
            asset_ids: UnorderedSet::new(StorageKey::AssetIds),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
        }
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn shares_to_amount(&self, shares: Shares, round_up: bool) -> Balance {
        if shares.0 >= self.balance || shares.0 == self.shares.0 {
            self.balance
        } else {
            let extra = if round_up {
                U256::from(self.shares.0 - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.balance) * U256::from(shares.0) + extra) / U256::from(self.shares.0))
                .as_u128()
        }
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            data.into(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/prices.rs ---
use crate::*;

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    price.map(|price| (asset_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 1000 bytes
const MIN_STORAGE_BALANCE: Balance = 1000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize, Clone)]
#[borsh_init(init)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub initial_storage_usage: StorageUsage,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VStorage {
    Current(Storage),
}

impl From<VStorage> for Storage {
    fn from(v: VStorage) -> Self {
        match v {
            VStorage::Current(c) => c,
        }
    }
}

impl From<Storage> for VStorage {
    fn from(c: Storage) -> Self {
        VStorage::Current(c)
    }
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            initial_storage_usage: env::storage_usage(),
        }
    }

    pub(crate) fn available_bytes(&self) -> StorageUsage {
        let covered_bytes = (self.storage_balance / env::storage_byte_cost()) as StorageUsage;
        covered_bytes - self.used_bytes
    }

    fn init(&mut self) {
        self.initial_storage_usage = env::storage_usage();
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        let storage_usage = env::storage_usage();
        if storage_usage > storage.initial_storage_usage {
            let extra_bytes_used = storage_usage - storage.initial_storage_usage;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released = storage.initial_storage_usage - storage_usage;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic(b"The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }
            // Saving storage object copy into the persistent storage to account for used bytes.
            self.internal_set_storage(&account_id, storage.clone());
            self.internal_set_account(&account_id, Account::new(&account_id), storage);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic(b"The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic(format!("The account {} is not registered", &account_id).as_bytes());
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic(b"The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(account_id.as_ref())
    }
}

'''
'''--- references/main/branches/improve-farm-performance/contract/src/utils.rs ---
use crate::*;

pub(crate) type TokenId = AccountId;

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

pub(crate) fn nano_to_ms(nano: u64) -> u64 {
    nano / 10u64.pow(6)
}

pub(crate) fn ms_to_nano(ms: u64) -> u64 {
    ms * 10u64.pow(6)
}

pub(crate) fn u128_ratio(a: u128, num: u128, denom: u128) -> Balance {
    (U256::from(a) * U256::from(num) / U256::from(denom)).as_u128()
}

pub(crate) fn ratio(balance: Balance, r: u32) -> Balance {
    assert!(r <= MAX_RATIO);
    u128_ratio(balance, u128::from(r), u128::from(MAX_RATIO))
}

'''
'''--- references/main/branches/improve-farm-performance/scripts/add_farms.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Adding the farms $LG<<<<<<<<<<<<<<$NC"

for TOKEN_ID in $DAI_TOKEN_ID $USDT_TOKEN_ID $WETH_TOKEN_ID $WNEAR_TOKEN_ID
do

  echo -e "$LG>>>>>>>>>>>>>>$TC Adding farms for $TOKEN_ID $LG<<<<<<<<<<<<<<$NC"

  near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
    "farm_id": {
      "Supplied": "'$TOKEN_ID'"
    },
    "reward_token_id": "'$BOOSTER_TOKEN_ID'",
    "new_reward_per_day": "100000000000000000000",
    "new_booster_log_base": "100000000000000000000",
    "reward_amount": "700000000000000000000"
  }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$BOOSTER_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000",
      "new_booster_log_base": "100000000000000000000",
      "reward_amount": "1750000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Supplied": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "100000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "700000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "1750000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

done

near view $CONTRACT_ID get_asset_farms_paged

'''
'''--- references/main/branches/improve-farm-performance/scripts/apr_to_rate.py ---
#!/usr/bin/env python3

import sys
from decimal import *

getcontext().prec = 60

n = 31536000000
input_apr = Decimal(sys.argv[1])
print("Input APR: %s%%" % (input_apr,))
print("n: %d" % (n,))

res = (((input_apr / Decimal(100)) + Decimal(1)) ** (Decimal(1) / Decimal(n)))
print("R: %s" % (res,))
print("R ** n: %s" % (res ** n,))

round_res = round(res * (Decimal(10) ** Decimal(27)))
print("rate: %s" % (round_res, ))

'''
'''--- references/main/branches/improve-farm-performance/scripts/create_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

mv -f neardev/dev-account neardev/dev-account-old 2> /dev/null || true

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create a user's account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
export ACCOUNT_ID="$(cat neardev/dev-account)"

mv -f neardev/dev-account-old neardev/dev-account 2> /dev/null || true

scripts/mint_to_account.sh

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export ACCOUNT_ID=$ACCOUNT_ID"

'''
'''--- references/main/branches/improve-farm-performance/scripts/dev_deploy.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create an owner account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
OWNER_ID="$(cat neardev/dev-account)"

ORACLE_ID="priceoracle.testnet"

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy the main contract $LG<<<<<<<<<<<<<<$NC"
near dev-deploy -f res/Nearlend.wasm
CONTRACT_ID="$(cat neardev/dev-account)"

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing Booster token $LG<<<<<<<<<<<<<<$NC"
BOOSTER_TOKEN_ID="ref.fakes.testnet"

near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing the main contract $LG<<<<<<<<<<<<<<$NC"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wETH $LG<<<<<<<<<<<<<<$NC"
WETH_TOKEN_ID="weth.fakes.testnet"

near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing DAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing USDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$BOOSTER_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": false,
    "can_borrow": false
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "120000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export WETH_TOKEN_ID=$WETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- references/main/branches/improve-farm-performance/scripts/mint_to_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Registering storage for the user: $LG<<<<<<<<<<<<<<$NC"
near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "100000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID near_deposit '{}' --amount=100

'''
'''--- references/main/branches/improve-farm-performance/scripts/readme_test.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'

near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
sleep 1

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'

near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/config.js ---
module.exports = {
    API_SERVER_URL: "http://78.47.91.25:3000",
    CREDENTIALS_DIR: ".near-credentials/testnet/",
    FRACTION_DIGITS: 5,
    GAS: 100000000000000,
}

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/jest.config.js ---
module.exports = {
    testEnvironment: "node",
    testTimeout: 900000,
    globals: {
        Uint8Array: Uint8Array,
    },
};
'''
'''--- references/main/branches/improve-farm-performance/sim-tests/package.json ---
{
  "name": "sim-tests",
  "version": "1.0.0",
  "scripts": {
    "test": "jest rest-api.test.js --useStderr --verbose false",
    "test:accounts": "jest rest-api.test.js -t 'Accounts' --useStderr --verbose false",
    "test:collateral": "jest rest-api.test.js -t 'Collateral' --useStderr --verbose false",
    "test:borrow": "jest rest-api.test.js -t 'Borrow' --useStderr --verbose false",
    "test:withdraw": "jest rest-api.test.js -t 'Withdraw' --useStderr --verbose false",
    "test:repay": "jest rest-api.test.js -t 'Repay' --useStderr --verbose false",
    "test:decrease": "jest rest-api.test.js -t 'Decrease collateral' --useStderr --verbose false"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.6.0",
    "node-fetch": "^2.6.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.1.1",
    "near-api-js": "^0.41.0",
    "react": "~17.0.1",
    "react-dom": "~17.0.1",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  }
}

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/rest-api-dummy-data.test.js ---
/* export REACT_CONTRACT_ID=dev-1627393733545-88687685295664 */
import 'regenerator-runtime/runtime'

const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const contract_id  = process.env.CONTRACT_NAME;

const near = new contract(process.env.CONTRACT_NAME);

const MIN_TOKENS = 20;

describe("Contract set", () => {
    test("Contract set: " + process.env.CONTRACT_NAME, async () => {
        expect(process.env.CONTRACT_NAME).not.toBe(undefined)
    });

    test('Accounts has enough funds', async () => {
        const contract_wallet_balance = await near.accountNearBalance(contract_id);
        expect(contract_wallet_balance).toBeGreaterThan(MIN_TOKENS);
    });
});

describe("Insert dummy data", () => {
    console.log(contract_id)
    test('Insert players', async () => {
        for (let i = 500; i <= 600; i++) {
            let account = `account_${i}.testnet`;
            const start_game = await near.call("start_game_for_account_id",
                {quiz_id: 36, account_id: account},
                {account_id: contract_id});
            expect(start_game.type).not.toBe('FunctionCallError');
        }
    });
});

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/rest-api-test-utils.js ---
const utils = require('./utils');
const config = require("./config");

function contract(contract_id) {
    this.contract_id = contract_id;
}

contract.prototype.deploy = async function (contractName) {
    const body = {
        contract: contractName,
        account_id: this.contract_id,
        private_key: await utils.getPrivateKey(this.contract_id),
    };

    return await utils.PostResponse("deploy", body);
};

contract.prototype.view = async function (method, params, options) {
    const body = {
        method: method,
        params: params,
        contract: this.contract_id,
        disabled_cache: true
    };

    return await utils.PostResponse("view", body, options);
};

contract.prototype.viewNearBalance = async function (method, params, options) {
    options = options || {};
    options.convertToNear = true;
    return await this.view(method, params, options);
};

contract.prototype.viewFTe18Balance = async function (method, params, options) {
    options = options || {};
    options.convertFromFTe18 = true;
    return await this.view(method, params, options);
};

contract.prototype.accountNearBalance = async function (account_id, delay) {
    delay = delay || 1000;
    await timeout(delay);

    return await utils.GetResponse("balance", account_id, {convertToNear: true})
        .catch(e => console.error("AccountNearBalance error for " + JSON.stringify(account_id) + ". Error: " + e.message));
};

contract.prototype.call = async function (method, params, options) {
    options.attached_gas = options.gas || config.GAS;
    options.attached_tokens = options.tokens || 0;
    options.private_key = options.private_key || await utils.getPrivateKey(options.account_id);
    options.log_errors = options.log_errors || false;
    options.return_value = options.return_value || false;

    const body = {
        ...options,
        method: method,
        params: params,
        contract: this.contract_id,
    };

    return await utils.PostResponse("call", body, options)
        .catch(e => {
            if(e.message.includes("Unexpected token < in JSON at position 0"))
                console.error("RPC/JSON Error: " + e.message);
            else
                console.error("Call error for " + JSON.stringify(body) + ". Error: " + e.message)
        });
};

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = contract;

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/rest-api.test.js ---
import 'regenerator-runtime/runtime'

/*
export NEAR_ENV=testnet
export OWNER_ID=dev-1634805788173-90290670203248
export ORACLE_ID=priceoracle.testnet
export CONTRACT_ID=dev-1634805794596-68676200580325
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export ACCOUNT_ID=dev-1634809261182-39559532470451

 */
const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const alice = process.env.ACCOUNT_ID;
const contract_id = process.env.CONTRACT_ID;
const usdt_contract_id = process.env.USDT_TOKEN_ID;
const dai_contract_id = process.env.DAI_TOKEN_ID;
const oracle_contract_id = process.env.ORACLE_ID;

const bob = "place.testnet";

const burrow = new contract(contract_id);
const usdt = new contract(usdt_contract_id);
const dai = new contract(dai_contract_id);
const oracle = new contract(oracle_contract_id);

describe("Contract set", () => {
    test("Contract is not null " + contract_id, async () => {
        expect(contract_id).not.toBe(undefined)
    });

    test("USDT Contract is not null " + usdt_contract_id, async () => {
        expect(usdt_contract_id).not.toBe(undefined)
    });

    test("DAI Contract is not null " + usdt_contract_id, async () => {
        expect(dai_contract_id).not.toBe(undefined)
    });

    test("Oracle Contract is not null " + alice, async () => {
        expect(oracle_contract_id).not.toBe(undefined)
    });

    test("Alice Account is not null " + alice, async () => {
        expect(alice).not.toBe(undefined)
    });

    test('Alice has enough funds', async () => {
        const alice_wallet_balance = await burrow.accountNearBalance(alice, 0);
        expect(alice_wallet_balance).toBeGreaterThan(20);
    });
});

describe("Accounts", () => {
    test('Register account by paying for storage, deposit tokens', async () => {
        const storage_deposit = await burrow.call("storage_deposit",
            {}, {
                account_id: alice,
                tokens: utils.ConvertToNear(0.1),
                log_errors: true
            });
        expect(storage_deposit.is_error).toBeFalsy();

        const account_initial = await burrow.view("get_account",
            {account_id: alice}, {});

        // make ft deposit and check balance/shares
        const deposit_1 = 5;
        const asset_1 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});

        const ft_transfer_1 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_1.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        expect(account_1.account_id).toBe(alice);
        expect(account_1.supplied.length).toBeGreaterThan(0);

        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_1.length).toBe(1);

        const usdt_supplied_initial = account_initial.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.balance) + deposit_1);
        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.shares) + deposit_1);

        const asset_2 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});
        expect(utils.ConvertFromFTe18(asset_2.supplied.shares)
            - utils.ConvertFromFTe18(asset_1.supplied.shares)).toBe(5)

        const deposit_2 = 3;
        const ft_transfer_2 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_2.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_2.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance) + deposit_2);
        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares) + deposit_2);

        const deposit_3 = 0;
        const ft_transfer_3 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_3.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_3.is_error).toBeTruthy();

        const account_3 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_3 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_3.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Collateral", () => {
    test('Provide token as a collateral', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        const execute = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: usdt_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_collateral_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].balance)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].shares)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].shares));

        const execute_wrong_account = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {"token_id": usdt_contract_id}
                }]
            },
            {account_id: bob, tokens: 1})
        expect(execute_wrong_account.is_error).toBeTruthy();

        const execute_without_supply = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {
                        token_id: usdt_contract_id
                    }
                }]
            },
            {account_id: alice, tokens: 1})
        expect(execute_without_supply.is_error).toBeTruthy();
    });
});

describe("Borrow", () => {
    test('Borrow a token', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: 'dai.fakes.testnet',
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

describe("Withdraw", () => {
    test('Withdrawing the asset', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const ft_balance_1 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        const withdraw = await burrow.call("execute",
            {
                actions: [{
                    Withdraw: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(withdraw.is_error).toBeFalsy();

        const ft_balance_2 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        expect(ft_balance_2 - ft_balance_1)
            .toBeCloseTo(utils.ConvertFromFTe18(account_1.supplied.balance));

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.supplied.length).toBe(0);
    });
});

describe("Repay", () => {
    test('Deposit asset and repay it in one call', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const repay_amount_1 = 5;

        const ft_transfer_1 = await dai.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: repay_amount_1.toString() + "000000000000000000",
            msg: JSON.stringify({
                Execute: {
                    actions: [
                        {
                            Repay: {
                                token_id: 'dai.fakes.testnet'
                            }
                        }
                    ]
                }
            })
        }, {account_id: alice, tokens: 1, log_errors: true})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(0);

        expect(utils.ConvertFromFTe18(account_1.borrowed[0].balance) +
            utils.ConvertFromFTe18(account_2.supplied[0].balance)).toBeCloseTo(repay_amount_1);
    });
});

describe("Decrease collateral", () => {
    test('Decreasing collateral without providing prices', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        const decrease_collateral_wrong_asset = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral_wrong_asset.is_error).toBeTruthy();

        const decrease_collateral = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'usdt.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account", {account_id: alice}, {});
        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(usdt_collateral_2.length).toBe(0);
        expect(usdt_supplied_2.length).toBeGreaterThan(0);
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

'''
'''--- references/main/branches/improve-farm-performance/sim-tests/utils.js ---
const {utils} = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const {BN} = require('bn.js');
const fs = require('fs');
const fetch = require("node-fetch");
const config = require("./config");

module.exports = {
    ConvertYoctoNear: (value, frac_digits) => {
        try {
            return utils.format.formatNearAmount(value, frac_digits).replace(",", "");
        } catch (e) {
            console.log("ConvertYoctoNear error, value: " + value);
            console.log(e);
        }
    },

    ConvertFromFTe18: (value) => {
        if(value === undefined)
            return 0;

        return Number(Math.round(value / 100000000000000) / 10000);
    },

    ConvertToNear: (amount) => {
        return new BN(Math.round(amount * 100000000)).mul(new BN("10000000000000000")).toString();
    },

    RoundFloat: (amount) => {
        return +Number.parseFloat(amount).toFixed(config.FRACTION_DIGITS);
    },

    getPrivateKey: async (accountId) => {
        const credentialsPath = path.join(homedir, config.CREDENTIALS_DIR);
        const keyPath = credentialsPath + accountId + '.json';
        try {
            const credentials = JSON.parse(fs.readFileSync(keyPath));
            return (credentials.private_key);
        } catch (e) {
            console.error("Key not found for account " + keyPath + ". Error: " + e.message);
        }
    },

    PostResponse: async (operation, body, options) => {
        const response = fetch(`${config.API_SERVER_URL}/${operation}`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-type': 'application/json; charset=UTF-8'
            }
        })
            .then(res => {
                return res.text().then(response => {
                    if (options && options.log_errors) {
                        const response_json = JSON.parse(response);
                        if (response_json && response_json.error) {
                            const error = JSON.parse(response_json.error);
                            console.log(`Request: ${body.method}`);
                            console.log(`ERROR: ${error.type}: ${JSON.stringify(error.kind)}`);
                        }
                    }

                    if (options && (options.convertToNear || options.convertFromFTe18)) {
                        if (isNaN(response))
                            throw new Error(`Illegal balance value. Request: ${JSON.stringify(body)}. Response: ${response}`);

                        if (options.convertFromFTe18)
                            return module.exports.RoundFloat(module.exports.ConvertFromFTe18(response, config.FRACTION_DIGITS));
                        else
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(response, config.FRACTION_DIGITS));
                    } else {
                        try {
                            let json = JSON.parse(response);
                            json.is_error = json.error && JSON.parse(json.error).hasOwnProperty('kind');
                            try {
                                if (options.return_value)
                                    return Buffer.from( json.status.SuccessValue, 'base64').toString();
                                else
                                    return (json);
                            } catch (e) {
                                throw new Error("PostResponse error for " + operation + " request " + JSON.stringify(body) + ". Error: " + e.message);
                            }
                        } catch (e) {
                            return response;
                        }
                    }
                });

            });
        return response;
    },

    GetResponse: async (operation, value, options) => {
        const response = await fetch(`${config.API_SERVER_URL}/${operation}/${value}`, {
            method: 'GET'
        })
            .then(res => {
                if (options && options.convertToNear) {
                    return res.text().then(value => {
                        try {
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(value, config.FRACTION_DIGITS));
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                } else {
                    return res.json().then(json => {
                        try {
                            if (json.error)
                                return (JSON.parse(json.error));
                            else
                                return (json);
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                }
            });

        return response;
    },

    IsJson: (item) => {
        item = typeof item !== "string"
            ? JSON.stringify(item)
            : item;

        try {
            item = JSON.parse(item);
        } catch (e) {
            return false;
        }

        if (typeof item === "object" && item !== null) {
            return true;
        }

        return false;
    }
};

'''
'''--- references/main/branches/improve-farm-performance/test-oracle/Cargo.toml ---
[package]
name = "test-oracle"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
common = { path = "../common/" }

'''
'''--- references/main/branches/improve-farm-performance/test-oracle/src/lib.rs ---
use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
#[allow(unused_imports)]
use near_sdk::AccountId;
use near_sdk::{assert_one_yocto, env, ext_contract, near_bindgen, Gas, Promise};

near_sdk::setup_alloc!();

const GAS_FOR_PROMISE: Gas = 10 * TGAS;

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: ValidAccountId,
        price_data: PriceData,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

'''
'''--- references/main/branches/improve-farm-performance/tests/main.rs ---

'''
'''--- references/main/branches/tests/Cargo.toml ---
[package]
name = "Nearlend"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dev-dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.2.0"
near-contract-standards = "3.1.0"

common = { path = "./common"}
contract = { path = "./contract" }
test-oracle = { path = "./test-oracle" }

approx = "0.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "common",
    "contract",
    "test-oracle",
]

'''
'''--- references/main/branches/tests/README.md ---
# Nearlend contact

## Development

### Build (optional)

Requires Rust and wasm32 target.

```bash
./build.sh
```

### Deploy on the testnet

Requires NEAR CLI to be installed.

```bash
./scripts/dev_deploy.sh
```

This will provide a list of exports at the end. Execute them to get the CLI ready for further transactions.

Example exports:
```bash
export NEAR_ENV=testnet
export OWNER_ID=dev-1634411537975-18277461139961
export ORACLE_ID=dev-1634411553736-97024242878560
export CONTRACT_ID=dev-1634411561699-94876475207945
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
```

### Create a test account

Requires exports from running `dev_deploy`. 

```bash
./scripts/create_account.sh
```

This will create a new test account with fake assets. Execute the export at the end to get the account ID.

Example export:
```bash
export ACCOUNT_ID=dev-1634680029152-10252684568108
```

## Actions

### Register account by paying for storage

This has to be done one per account.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'
```

### Supply some token

Let's supply `5` USDT. USDT has `6` decimals, so amount should be `5000000`. For a simple deposit, the `msg` can be empty string.

```bash
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'
```

### View account information

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

Note: Since USDT asset has extra `12` decimals, it brings the 5 USDT in the balance to `5000000000000000000`

### View a given asset

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '5000000000000000000', balance: '5000000000000000000' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000000000000000',
  last_update_timestamp: '1634682347763275349',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 12,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

Note: You can also see `2000000000000000000000` reserved. That's `2000` USDT from the owner.

### Provide token as a collateral

Let's add all USDT to a collateral. If the `amount` for a given action is not specified, then all available amount will be used.

Increasing the collateral doesn't require prices from the oracle, because it can't decrease the existing collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Note, you can see the USDT asset was moved from `supplied` to `collateral`

### Borrow a token

Let's borrow `1` DAI. DAI has `18` decimals, so the amount should be `1000000000000000000`.

Since borrow action puts account into the debt, we have to call this action through the oracle.
The oracle should provide prices for all assets in the collateral as well as all existing borrowed assets and the new borrowed asset.

The `msg` passed to the oracle should be string. Since it's part of the JSON, it has to be double-encoded and can't have newlines.

FYI: The message that we pass to the contract from the oracle is the following:
```json
{
  "Execute": {
    "actions": [
      {
        "Borrow": {
          "token_id": "dai.fakes.testnet",
          "amount": "1000000000000000000"
        }
      }
    ]
  }
}
```

```bash
near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'
```

You should see a log message like: `Account dev-1634682124572-99167526870966 borrows 1000000000000000000 of dai.fakes.testnet`

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966', 
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000048216105',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000064288139',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Note, without extra action the borrowed assets are not withdrawn to the wallet, but instead supplied to earn interest.
From there they can be withdrawn.
You can also notice that the borrowed balance is larger than the supplied balance, that's because the some of the interest are going to the reserve.

If we view the account info again, then the balances should increase:

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000221528817',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000295371755',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '1000000000000000000', balance: '1000000000399150907' },
  borrowed: { shares: '1000000000000000000', balance: '1000000000532201209' },
  reserved: '2000000000000133050302',
  last_update_timestamp: '1634683708614246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Withdrawing the asset

Let's withdraw all DAI including interest.

Withdrawing doesn't need oracle prices, because it can only be taken from the supplied and not from the collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'
```

You should see the log, e.g. `Account dev-1634682124572-99167526870966 withdraws 1000000001658903820 of dai.fakes.testnet`

Now let's check the DAI balance (in the wallet) of the account:

```bash
near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result: `10001000000001658903820`, which corresponds roughly to `10001` DAI, plus some extra earned interests.

Withdrawal from the contract was possible, because the owner has supplied DAI into the reserve.

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000002496596924',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Notice, there is no supplied DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '0', balance: '0' },
  borrowed: { shares: '1000000000000000000', balance: '1000000002551410252' },
  reserved: '2000000000000892506432',
  last_update_timestamp: '1634685033009246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Deposit asset and repay it in one call.

Note, multiple actions can be combined into a single atomic update. Either all of them complete or all of them are reverted.
The invariants are only checked at the end, so this may be used to replace one collateral with another without repaying debts (but this requires oracle pricing). 

Let's deposit `5` DAI and use it to repay borrowed DAI. DAI has 18 decimal, so the amount is `5000000000000000000`
For this we need to pass a custom `msg` to `ft_transfer_call`.
The message has to be double-encoded into a string.

FYI: Non-encoded message in JSON:
```json
{
  "Execute": {
    "actions": [
      {
        "Repay": {
          "token_id": "dai.fakes.testnet"
        }
      }
    ]
  }
}
```

```bash
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'
```

You should see similar log messages:
```
Account dev-1634686749015-49146327775274 deposits 5000000000000000000 of dai.fakes.testnet
Account dev-1634686749015-49146327775274 repays 1000000001735752696 of dai.fakes.testnet
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Notice, there is no borrowed DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '3999999998264247304', balance: '3999999998264247304' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000001727179674',
  last_update_timestamp: '1634688121573861187',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

And no borrowed balance or shares after repaying.

### Decreasing collateral

Since there is no borrowed assets, we can take the collateral without providing prices.

Let's get all USDT collateral back.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    },
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

'''
'''--- references/main/branches/tests/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

perl -i -pe 's/\["cdylib", "rlib"\]/\["cdylib"\]/' contract/Cargo.toml

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/test_oracle.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/Nearlend.wasm

perl -i -pe 's/\["cdylib"\]/\["cdylib", "rlib"\]/' contract/Cargo.toml

'''
'''--- references/main/branches/tests/common/Cargo.toml ---
[package]
name = "common"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dependencies]
near-sdk = "3.1.0"

'''
'''--- references/main/branches/tests/common/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{Balance, Gas, Timestamp};

pub type AssetId = String;
pub type DurationSec = u32;

pub const TGAS: Gas = 10u64.pow(12);
pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;

const MAX_VALID_DECIMALS: u8 = 77;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    pub multiplier: Balance,
    pub decimals: u8,
}

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

'''
'''--- references/main/branches/tests/contract/API.md ---
# The list of APIs that are provided by the contract

Notes:
- `u128_dec_format`, `WrappedBalance`, `Shares` means the value is passed as a decimal string representation. E.g. `1` serialized as `"1"`
- `BigDecimal` is serialized as floating string representation. E.g. `1.5` serialized as `"1.5"`
- `u64` means the value is passed as an integer.
- `Option<_>` means the value can be omitted, or provided as `null`.
- Rust enums are serialized using JSON objects. E.g. `FarmId::Supplied("token.near")` is serialized as `{"Supplied": "token.near"}`
- `HashMap<_, _>` is serialized using JSON objects.

```rust
trait Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    fn new(config: Config) -> Self;

    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView>;

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account>;

    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    fn execute(&mut self, actions: Vec<Action>);

    /// Returns a detailed view asset for a given token_id.
    /// The detailed view includes current APR and corresponding farms.
    fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView>;

    /// Returns an list of detailed view assets a given list of token_id.
    /// Only returns existing assets.
    fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView>;

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)>;

    /// Returns a list of detailed view assets from a given index up to a given limit.
    fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView>;

    /// Returns the current config.
    fn get_config(&self) -> Config;

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_config(&mut self, config: Config);

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);

    /// Claims all unclaimed farm rewards.
    fn account_farm_claim_all(&mut self);

    /// Returns an asset farm for a given farm ID.
    fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm>;

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)>;

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)>;

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        extra_amount: WrappedBalance,
    );
}
```

## Structures and types

```rust
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

/// Limited view of the account structure for liquidations
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
}

pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
}

pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

/// Contract config
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    /// The entire amount will be deposited to the asset reserve. 
    DepositToReserve,
}

enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

pub type TokenId = AccountId;
```

## Also storage management

```rust
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregestering the account is not allowed to not break the order of accounts.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}
```

'''
'''--- references/main/branches/tests/contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
uint = { version = "0.9.0", default-features = false }
common = { path = "../common/" }
once_cell = "1.8.0"

[dev-dependencies]
rand = "0.8"

'''
'''--- references/main/branches/tests/contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
    /// Keeping track of data required for farms for this account.
    #[serde(skip_serializing)]
    pub farms: UnorderedMap<FarmId, VAccountFarm>,
    #[borsh_skip]
    #[serde(skip_serializing)]
    pub affected_farms: Vec<FarmId>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v: VAccount) -> Self {
        match v {
            VAccount::Current(c) => c,
        }
    }
}

impl From<Account> for VAccount {
    fn from(c: Account) -> Self {
        VAccount::Current(c)
    }
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: UnorderedMap::new(StorageKey::AccountAssets {
                account_id: account_id.clone(),
            }),
            collateral: vec![],
            borrowed: vec![],
            farms: UnorderedMap::new(StorageKey::AccountFarms {
                account_id: account_id.clone(),
            }),
            affected_farms: vec![],
        }
    }

    pub fn increase_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(collateral) = self.collateral.iter_mut().find(|c| &c.token_id == token_id) {
            collateral.shares.0 += shares.0;
        } else {
            self.collateral.push(CollateralAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .collateral
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Collateral not found");
        if let Some(new_balance) = self.collateral[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.collateral[index].shares.0 = new_balance;
            } else {
                self.collateral.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough collateral balance");
        }
    }

    pub fn increase_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(borrowed) = self.borrowed.iter_mut().find(|c| &c.token_id == token_id) {
            borrowed.shares.0 += shares.0;
        } else {
            self.borrowed.push(BorrowedAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .borrowed
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found");
        if let Some(new_balance) = self.borrowed[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.borrowed[index].shares.0 = new_balance;
            } else {
                self.borrowed.swap_remove(index);
            }
        } else {
            env::panic(b"Not enough borrowed balance");
        }
    }

    pub fn internal_unwrap_collateral(&mut self, token_id: &TokenId) -> Shares {
        self.collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Collateral not found")
            .shares
    }

    pub fn internal_unwrap_borrowed(&mut self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found")
            .shares
    }

    pub fn add_affected_farm(&mut self, farm_id: FarmId) {
        if !self.affected_farms.contains(&farm_id) {
            self.affected_farms.push(farm_id);
        }
    }

    pub fn add_all_affected_farms(&mut self) {
        let len = self.affected_farms.len();
        for farm_id in self.farms.keys() {
            if len == 0
                || self
                    .affected_farms
                    .iter()
                    .take(len)
                    .find(|f| *f == &farm_id)
                    .is_none()
            {
                self.affected_farms.push(farm_id);
            }
        }
    }

    pub fn get_supplied_shares(&self, token_id: &TokenId) -> Shares {
        let collateral_shares = self
            .collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .map(|ca| ca.shares.0)
            .unwrap_or(0);
        let supplied_shares = self
            .internal_get_asset(token_id)
            .map(|asset| asset.shares.0)
            .unwrap_or(0);
        (supplied_shares + collateral_shares).into()
    }

    pub fn get_borrowed_shares(&self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|b| &b.token_id == token_id)
            .map(|ba| ba.shares)
            .unwrap_or(0.into())
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account_with_storage(
        &self,
        account_id: &AccountId,
    ) -> (Account, Storage) {
        (
            self.internal_unwrap_account(account_id),
            self.internal_unwrap_storage(account_id),
        )
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(
        &mut self,
        account_id: &AccountId,
        account: Account,
        storage: Storage,
    ) {
        self.accounts.insert(account_id, &account.into());
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView> {
        self.internal_get_account(account_id.as_ref())
            .map(|account| self.account_into_detailed_view(account))
    }

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    pub fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account> {
        let values = self.accounts.values_as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(values.len());
        (from_index..std::cmp::min(values.len(), limit))
            .map(|index| values.get(index).unwrap().into())
            .collect()
    }
}

'''
'''--- references/main/branches/tests/contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountAsset {
    Current(AccountAsset),
}

impl From<VAccountAsset> for AccountAsset {
    fn from(v: VAccountAsset) -> Self {
        match v {
            VAccountAsset::Current(c) => c,
        }
    }
}

impl From<AccountAsset> for VAccountAsset {
    fn from(c: AccountAsset) -> Self {
        VAccountAsset::Current(c)
    }
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic(b"Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied.get(token_id).map(|o| o.into())
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id, &account_asset.into());
        }
        self.add_affected_farm(FarmId::Supplied(token_id.clone()));
    }
}

'''
'''--- references/main/branches/tests/contract/src/account_farm.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Hash, Eq, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

impl FarmId {
    pub fn get_token_id(&self) -> &TokenId {
        match self {
            FarmId::Supplied(token_id) => token_id,
            FarmId::Borrowed(token_id) => token_id,
        }
    }
}

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarm {
    pub block_timestamp: Timestamp,
    pub rewards: HashMap<TokenId, AccountFarmReward>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarmReward {
    pub boosted_shares: Balance,
    pub last_reward_per_share: BigDecimal,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountFarm {
    Current(AccountFarm),
}

impl From<VAccountFarm> for AccountFarm {
    fn from(v: VAccountFarm) -> Self {
        match v {
            VAccountFarm::Current(c) => c,
        }
    }
}

impl From<AccountFarm> for VAccountFarm {
    fn from(c: AccountFarm) -> Self {
        VAccountFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_account_farm_claim(
        &self,
        account: &Account,
        farm_id: &FarmId,
        asset_farm: &AssetFarm,
    ) -> (
        AccountFarm,
        Vec<(TokenId, Balance)>,
        Vec<(TokenId, Balance)>,
    ) {
        let mut new_rewards = vec![];
        let mut inactive_rewards = vec![];
        let block_timestamp = env::block_timestamp();
        let mut account_farm: AccountFarm = account
            .farms
            .get(farm_id)
            .map(|v| v.into())
            .unwrap_or_else(|| AccountFarm {
                block_timestamp: 0,
                rewards: HashMap::new(),
            });
        if account_farm.block_timestamp != block_timestamp {
            account_farm.block_timestamp = block_timestamp;
            let mut old_rewards = std::mem::take(&mut account_farm.rewards);
            for (
                token_id,
                AssetFarmReward {
                    reward_per_share, ..
                },
            ) in &asset_farm.rewards
            {
                let boosted_shares = if let Some(AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                }) = old_rewards.remove(token_id)
                {
                    let diff = reward_per_share.clone() - last_reward_per_share;
                    let amount = diff.round_mul_u128(boosted_shares);
                    if amount > 0 {
                        new_rewards.push((token_id.clone(), amount));
                    }
                    boosted_shares
                } else {
                    0
                };
                account_farm.rewards.insert(
                    token_id.clone(),
                    AccountFarmReward {
                        boosted_shares,
                        last_reward_per_share: reward_per_share.clone(),
                    },
                );
            }
            for (
                token_id,
                AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                },
            ) in old_rewards
            {
                let AssetFarmReward {
                    reward_per_share, ..
                } = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                let diff = reward_per_share - last_reward_per_share;
                let amount = diff.round_mul_u128(boosted_shares);
                inactive_rewards.push((token_id.clone(), boosted_shares));
                if amount > 0 {
                    new_rewards.push((token_id, amount));
                }
            }
        }
        (account_farm, new_rewards, inactive_rewards)
    }

    pub fn internal_account_apply_affected_farms(
        &mut self,
        account: &mut Account,
        verify_booster: bool,
    ) {
        let config = self.internal_config();
        if verify_booster
            && account
                .affected_farms
                .contains(&FarmId::Supplied(config.booster_token_id.clone()))
        {
            account.add_all_affected_farms();
        }
        if account.affected_farms.is_empty() {
            return;
        }
        let mut all_rewards: HashMap<TokenId, Balance> = HashMap::new();
        let mut i = 0;
        let mut farms = vec![];
        while i < account.affected_farms.len() {
            let farm_id = account.affected_farms[i].clone();
            if let Some(asset_farm) = self.internal_get_asset_farm(&farm_id, false) {
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(account, &farm_id, &asset_farm);
                for (token_id, amount) in new_rewards {
                    let new_farm_id = FarmId::Supplied(token_id.clone());
                    account.add_affected_farm(new_farm_id);
                    *all_rewards.entry(token_id).or_default() += amount;
                }
                farms.push((farm_id, account_farm, asset_farm, inactive_rewards));
            }
            i += 1;
        }
        for (token_id, &reward) in &all_rewards {
            self.internal_deposit(account, &token_id, reward);
        }
        let booster_balance = self
            .internal_unwrap_asset(&config.booster_token_id)
            .supplied
            .shares_to_amount(account.get_supplied_shares(&config.booster_token_id), false);
        let booster_base = 10u128.pow(config.booster_decimals as u32);

        for (farm_id, mut account_farm, mut asset_farm, inactive_rewards) in farms {
            let shares = match &farm_id {
                FarmId::Supplied(token_id) => account.get_supplied_shares(token_id).0,
                FarmId::Borrowed(token_id) => account.get_borrowed_shares(token_id).0,
            };
            for (token_id, asset_farm_reward) in asset_farm.rewards.iter_mut() {
                let account_farm_reward = account_farm.rewards.get_mut(token_id).unwrap();
                asset_farm_reward.boosted_shares -= account_farm_reward.boosted_shares;
                if shares > 0 {
                    let extra_shares = if booster_balance > booster_base {
                        let log_base =
                            (asset_farm_reward.booster_log_base as f64) / (booster_base as f64);
                        ((shares as f64)
                            * ((booster_balance as f64) / (booster_base as f64)).log(log_base))
                            as u128
                    } else {
                        0
                    };
                    account_farm_reward.boosted_shares = shares + extra_shares;
                    asset_farm_reward.boosted_shares += account_farm_reward.boosted_shares;
                }
            }
            for (token_id, boosted_shares) in inactive_rewards {
                let mut asset_farm_reward = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                asset_farm_reward.boosted_shares -= boosted_shares;
                asset_farm.internal_set_inactive_asset_farm_reward(&token_id, asset_farm_reward);
            }
            if shares > 0 {
                account.farms.insert(&farm_id, &account_farm.into());
            } else {
                account.farms.remove(&farm_id);
            }
            self.internal_set_asset_farm(&farm_id, asset_farm);
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Claims all unclaimed farm rewards.
    pub fn account_farm_claim_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let (mut account, storage) =
            self.internal_unwrap_account_with_storage(&env::predecessor_account_id());
        account.add_all_affected_farms();
        self.internal_account_apply_affected_farms(&mut account, false);
        self.internal_set_account(&account_id, account, storage);
    }
}

'''
'''--- references/main/branches/tests/contract/src/account_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

impl Contract {
    pub fn account_into_detailed_view(&self, account: Account) -> AccountDetailedView {
        let farms = account
            .farms
            .keys()
            .map(|farm_id| {
                let mut asset_farm = self.internal_unwrap_asset_farm(&farm_id, true);
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(&account, &farm_id, &asset_farm);
                AccountFarmView {
                    farm_id,
                    rewards: account_farm
                        .rewards
                        .into_iter()
                        .map(|(token_id, AccountFarmReward { boosted_shares, .. })| {
                            (token_id, boosted_shares)
                        })
                        .chain(inactive_rewards)
                        .map(|(reward_token_id, boosted_shares)| {
                            let asset_farm_reward = asset_farm
                                .rewards
                                .remove(&reward_token_id)
                                .or_else(|| {
                                    asset_farm
                                        .internal_get_inactive_asset_farm_reward(&reward_token_id)
                                })
                                .unwrap();
                            let unclaimed_amount = new_rewards
                                .iter()
                                .find(|(token_id, _)| token_id == &reward_token_id)
                                .map(|(_, amount)| *amount)
                                .unwrap_or(0);
                            AccountFarmRewardView {
                                reward_token_id,
                                asset_farm_reward,
                                boosted_shares,
                                unclaimed_amount,
                            }
                        })
                        .collect(),
                }
            })
            .collect();
        AccountDetailedView {
            account_id: account.account_id,
            supplied: unordered_map_pagination(&account.supplied, None, None)
                .into_iter()
                .map(|(token_id, AccountAsset { shares })| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            collateral: account
                .collateral
                .into_iter()
                .map(|CollateralAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            borrowed: account
                .borrowed
                .into_iter()
                .map(|BorrowedAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, true)
                })
                .collect(),
            farms,
        }
    }

    fn get_asset_view(&self, token_id: TokenId, shares: Shares, is_borrowing: bool) -> AssetView {
        let asset = self.internal_unwrap_asset(&token_id);
        let apr = if is_borrowing {
            asset.get_borrow_apr()
        } else {
            asset.get_supply_apr()
        };
        let balance = if is_borrowing {
            asset.borrowed.shares_to_amount(shares, true)
        } else {
            asset.supplied.shares_to_amount(shares, false)
        };

        AssetView {
            token_id,
            balance,
            shares,
            apr,
        }
    }
}

'''
'''--- references/main/branches/tests/contract/src/actions.rs ---
use crate::*;

const MAX_NUM_ASSETS: usize = 8;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        storage: &mut Storage,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        let mut need_risk_check = false;
        let mut need_number_check = false;
        for action in actions {
            match action {
                Action::Withdraw(asset_amount) => {
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    let amount = self.internal_withdraw(account, &asset_amount);
                    self.internal_ft_transfer(account_id, &asset_amount.token_id, amount);
                    log!(
                        "Account {} withdraws {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::IncreaseCollateral(asset_amount) => {
                    need_number_check = true;
                    let amount = self.internal_increase_collateral(account, &asset_amount);
                    log!(
                        "Account {} increases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::DecreaseCollateral(asset_amount) => {
                    need_risk_check = true;
                    let mut account_asset =
                        account.internal_get_asset_or_default(&asset_amount.token_id);
                    let amount = self.internal_decrease_collateral(
                        &mut account_asset,
                        account,
                        &asset_amount,
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                    log!(
                        "Account {} decreases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Borrow(asset_amount) => {
                    need_number_check = true;
                    need_risk_check = true;
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_borrow(account, &asset_amount);
                    log!(
                        "Account {} borrows {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Repay(asset_amount) => {
                    let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_repay(&mut account_asset, account, &asset_amount);
                    log!(
                        "Account {} repays {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Liquidate {
                    account_id: liquidation_account_id,
                    in_assets,
                    out_assets,
                } => {
                    assert_ne!(
                        account_id,
                        liquidation_account_id.as_ref(),
                        "Can't liquidate yourself"
                    );
                    assert!(!in_assets.is_empty() && !out_assets.is_empty());
                    self.internal_liquidate(
                        account_id,
                        account,
                        storage,
                        &prices,
                        liquidation_account_id.as_ref(),
                        in_assets,
                        out_assets,
                    );
                }
            }
        }
        if need_number_check {
            assert!(account.collateral.len() + account.borrowed.len() <= MAX_NUM_ASSETS);
        }
        if need_risk_check {
            assert!(self.compute_max_discount(account, &prices) == BigDecimal::zero());
        }

        self.internal_account_apply_affected_farms(account, true);
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }

    pub fn internal_withdraw(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_withdraw,
            "Withdrawals for this asset are not enabled"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        let available_amount = asset.available_amount();

        assert!(
            amount <= available_amount,
            "Withdraw error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        asset.supplied.withdraw(shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        amount
    }

    pub fn internal_increase_collateral(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_use_as_collateral,
            "Thi asset can't be used as a collateral"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        account.increase_collateral(&asset_amount.token_id, shares);

        amount
    }

    pub fn internal_decrease_collateral(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let collateral_shares = account.internal_unwrap_collateral(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, collateral_shares, &asset_amount, false);

        account.decrease_collateral(&asset_amount.token_id, shares);

        account_asset.deposit_shares(shares);

        amount
    }

    pub fn internal_borrow(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(asset.config.can_borrow, "Thi asset can't be used borrowed");

        let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);

        let available_amount = asset.available_amount();
        let max_borrow_shares = asset.borrowed.amount_to_shares(available_amount, false);

        let (borrowed_shares, amount) =
            asset_amount_to_shares(&asset.borrowed, max_borrow_shares, &asset_amount, true);

        assert!(
            amount <= available_amount,
            "Borrow error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        let supplied_shares: Shares = asset.supplied.amount_to_shares(amount, false);

        asset.borrowed.deposit(borrowed_shares, amount);
        asset.supplied.deposit(supplied_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.increase_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.deposit_shares(supplied_shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        amount
    }

    pub fn internal_repay(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let available_borrowed_shares = account.internal_unwrap_borrowed(&asset_amount.token_id);

        let (mut borrowed_shares, mut amount) = asset_amount_to_shares(
            &asset.borrowed,
            available_borrowed_shares,
            &asset_amount,
            true,
        );

        let mut supplied_shares = asset.supplied.amount_to_shares(amount, true);
        if supplied_shares.0 > account_asset.shares.0 {
            supplied_shares = account_asset.shares;
            amount = asset.supplied.shares_to_amount(supplied_shares, false);
            if let Some(min_amount) = &asset_amount.amount {
                assert!(amount >= min_amount.0, "Not enough supplied balance");
            }
            assert!(amount > 0, "Repayment amount can't be 0");

            borrowed_shares = asset.borrowed.amount_to_shares(amount, false);
            assert!(borrowed_shares.0 > 0, "Shares can't be 0");
            assert!(borrowed_shares.0 <= available_borrowed_shares.0);
        }

        asset.supplied.withdraw(supplied_shares, amount);
        asset.borrowed.withdraw(borrowed_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.decrease_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.withdraw_shares(supplied_shares);

        amount
    }

    pub fn internal_liquidate(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        storage: &mut Storage,
        prices: &Prices,
        liquidation_account_id: &AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    ) {
        let (mut liquidation_account, mut liquidation_storage) =
            self.internal_unwrap_account_with_storage(liquidation_account_id);

        let max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            max_discount > BigDecimal::zero(),
            "The liquidation account is not at risk"
        );

        let mut borrowed_repaid_sum = BigDecimal::zero();
        let mut collateral_taken_sum = BigDecimal::zero();

        for asset_amount in in_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
            let amount =
                self.internal_repay(&mut account_asset, &mut liquidation_account, &asset_amount);
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            borrowed_repaid_sum = borrowed_repaid_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        for asset_amount in out_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            liquidation_account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);
            let amount = self.internal_decrease_collateral(
                &mut account_asset,
                &mut liquidation_account,
                &asset_amount,
            );
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            collateral_taken_sum = collateral_taken_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        let discounted_collateral_taken = collateral_taken_sum * (BigDecimal::one() - max_discount);
        assert!(
            discounted_collateral_taken <= borrowed_repaid_sum,
            "Not enough balances repaid"
        );

        let new_max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            new_max_discount > BigDecimal::zero(),
            "The liquidation amount is too large. The liquidation account should stay in risk"
        );

        self.internal_account_apply_affected_farms(&mut liquidation_account, true);

        // We have to adjust the initial_storage_usage for the acting account to not double count
        // the bytes from the liquidation account. As well as potentially cover the extra bytes
        // required by the liquidation account that might be added due to farms.
        let current_storage_usage = env::storage_usage();
        if current_storage_usage > liquidation_storage.initial_storage_usage {
            let required_bytes = current_storage_usage - liquidation_storage.initial_storage_usage;
            let available_bytes = liquidation_storage.available_bytes();
            if available_bytes < required_bytes {
                let extra_bytes = required_bytes - available_bytes;
                log!(
                    "Account {} has to cover extra storage of {} bytes for liquidation account {}",
                    account_id,
                    extra_bytes,
                    liquidation_account_id,
                );
                liquidation_storage.initial_storage_usage += extra_bytes;
                storage.initial_storage_usage += available_bytes;
            } else {
                storage.initial_storage_usage += required_bytes;
            }
        } else {
            let released_bytes = liquidation_storage.initial_storage_usage - current_storage_usage;
            storage.initial_storage_usage -= released_bytes;
        }
        self.internal_set_account(
            liquidation_account_id,
            liquidation_account,
            liquidation_storage,
        );

        log!(
            "Account {} liquidates account {}: takes {} for repaying {}",
            account_id,
            liquidation_account_id,
            collateral_taken_sum,
            borrowed_repaid_sum
        );
    }

    pub fn compute_max_discount(&self, account: &Account, prices: &Prices) -> BigDecimal {
        if account.borrowed.is_empty() {
            return BigDecimal::zero();
        }

        let collateral_sum = account
            .collateral
            .iter()
            .fold(BigDecimal::zero(), |sum, c| {
                let asset = self.internal_unwrap_asset(&c.token_id);
                let balance = asset.supplied.shares_to_amount(c.shares, false);
                sum + BigDecimal::from_balance_price(
                    balance,
                    prices.get_unwrap(&c.token_id),
                    asset.config.extra_decimals,
                )
                .mul_ratio(asset.config.volatility_ratio)
            });

        let borrowed_sum = account.borrowed.iter().fold(BigDecimal::zero(), |sum, b| {
            let asset = self.internal_unwrap_asset(&b.token_id);
            let balance = asset.borrowed.shares_to_amount(b.shares, true);
            sum + BigDecimal::from_balance_price(
                balance,
                prices.get_unwrap(&b.token_id),
                asset.config.extra_decimals,
            )
            .div_ratio(asset.config.volatility_ratio)
        });

        if borrowed_sum <= collateral_sum {
            BigDecimal::zero()
        } else {
            (borrowed_sum - collateral_sum) / borrowed_sum / BigDecimal::from(2u32)
        }
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    asset_amount: &AssetAmount,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = if let Some(amount) = &asset_amount.amount {
        (
            pool.amount_to_shares(amount.0, !inverse_round_direction),
            amount.0,
        )
    } else if let Some(max_amount) = &asset_amount.max_amount {
        let shares = std::cmp::min(
            available_shares.0,
            pool.amount_to_shares(max_amount.0, !inverse_round_direction)
                .0,
        )
        .into();
        (
            shares,
            std::cmp::min(
                pool.shares_to_amount(shares, inverse_round_direction),
                max_amount.0,
            ),
        )
    } else {
        (
            available_shares,
            pool.shares_to_amount(available_shares, inverse_round_direction),
        )
    };
    assert!(shares.0 > 0, "Shares can't be 0");
    assert!(amount > 0, "Amount can't be 0");
    (shares, amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let (mut account, mut storage) = self.internal_unwrap_account_with_storage(&account_id);
        self.internal_execute(
            &account_id,
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(&account_id, account, storage);
    }
}

'''
'''--- references/main/branches/tests/contract/src/asset.rs ---
use crate::*;

pub const MS_PER_YEAR: u64 = 31536000000;

static ASSETS: Lazy<Mutex<HashMap<TokenId, Option<Asset>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            supplied: Pool::new(),
            borrowed: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn get_rate(&self) -> BigDecimal {
        self.config
            .get_rate(self.borrowed.balance, self.supplied.balance + self.reserved)
    }

    pub fn get_borrow_apr(&self) -> BigDecimal {
        let rate = self.get_rate();
        rate.pow(MS_PER_YEAR) - BigDecimal::one()
    }

    pub fn get_supply_apr(&self) -> BigDecimal {
        if self.supplied.balance == 0 || self.borrowed.balance == 0 {
            return BigDecimal::zero();
        }

        let borrow_apr = self.get_borrow_apr();
        if borrow_apr == BigDecimal::zero() {
            return borrow_apr;
        }

        let interest = borrow_apr.round_mul_u128(self.borrowed.balance);
        let supply_interest = ratio(interest, MAX_RATIO - self.config.reserve_ratio);
        BigDecimal::from(supply_interest).div_u128(self.supplied.balance)
    }

    // n = 31536000000 ms in a year (365 days)
    //
    // Compute `r` from `X`. `X` is desired APY
    // (1 + r / n) ** n = X (2 == 200%)
    // n * log(1 + r / n) = log(x)
    // log(1 + r / n) = log(x) / n
    // log(1 + r  / n) = log( x ** (1 / n))
    // 1 + r / n = x ** (1 / n)
    // r / n = (x ** (1 / n)) - 1
    // r = n * ((x ** (1 / n)) - 1)
    // n = in millis
    fn compound(&mut self, time_diff_ms: Duration) {
        let rate = self.get_rate();
        let interest =
            rate.pow(time_diff_ms).round_mul_u128(self.borrowed.balance) - self.borrowed.balance;
        // TODO: Split interest based on ratio between reserved and supplied?
        let reserved = ratio(interest, self.config.reserve_ratio);
        if self.supplied.shares.0 > 0 {
            self.supplied.balance += interest - reserved;
            self.reserved += reserved;
        } else {
            self.reserved += interest;
        }
        self.borrowed.balance += interest;
    }

    pub fn update(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff_ms = nano_to_ms(timestamp - self.last_update_timestamp);
        if time_diff_ms > 0 {
            // update
            self.last_update_timestamp += ms_to_nano(time_diff_ms);
            self.compound(time_diff_ms);
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.borrowed.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        let mut cache = ASSETS.lock().unwrap();
        cache.get(token_id).cloned().unwrap_or_else(|| {
            let asset = self.assets.get(token_id).map(|o| {
                let mut asset: Asset = o.into();
                asset.update();
                asset
            });
            cache.insert(token_id.clone(), asset.clone());
            asset
        })
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, mut asset: Asset) {
        if asset.supplied.shares.0 == 0 && asset.supplied.balance > 0 {
            asset.reserved += asset.supplied.balance;
            asset.supplied.balance = 0;
        }
        assert!(
            asset.borrowed.shares.0 > 0 || asset.borrowed.balance == 0,
            "Borrowed invariant broken"
        );
        ASSETS
            .lock()
            .unwrap()
            .insert(token_id.clone(), Some(asset.clone()));
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset for a given token_id.
    pub fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView> {
        self.internal_get_asset(token_id.as_ref())
            .map(|asset| self.asset_into_detailed_view(token_id.into(), asset))
    }

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    pub fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView> {
        token_ids
            .into_iter()
            .filter_map(|token_id| {
                self.internal_get_asset(token_id.as_ref())
                    .map(|asset| self.asset_into_detailed_view(token_id.into(), asset))
            })
            .collect()
    }

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    pub fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&key).unwrap().into();
                asset.update();
                (key, asset)
            })
            .collect()
    }

    pub fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let token_id = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&token_id).unwrap().into();
                asset.update();
                self.asset_into_detailed_view(token_id, asset)
            })
            .collect()
    }
}

'''
'''--- references/main/branches/tests/contract/src/asset_config.rs ---
use crate::*;

const MAX_POS: u32 = 10000;
const MAX_RATIO: u32 = 10000;

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

impl AssetConfig {
    pub fn assert_valid(&self) {
        assert!(self.reserve_ratio <= MAX_RATIO);
        assert!(self.target_utilization < MAX_POS);
        assert!(self.target_utilization_rate.0 <= self.max_utilization_rate.0);
    }

    pub fn get_rate(
        &self,
        borrowed_balance: Balance,
        total_supplied_balance: Balance,
    ) -> BigDecimal {
        if total_supplied_balance == 0 {
            BigDecimal::one()
        } else {
            let pos = BigDecimal::from(borrowed_balance).div_u128(total_supplied_balance);
            let target_utilization = BigDecimal::from_ratio(self.target_utilization);
            if pos < target_utilization {
                BigDecimal::one()
                    + pos * (BigDecimal::from(self.target_utilization_rate) - BigDecimal::one())
                        / target_utilization
            } else {
                BigDecimal::from(self.target_utilization_rate)
                    + (pos - target_utilization)
                        * (BigDecimal::from(self.max_utilization_rate)
                            - BigDecimal::from(self.target_utilization_rate))
                        / BigDecimal::from_ratio(MAX_POS - self.target_utilization)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ONE_NEAR: u128 = 10u128.pow(24);

    fn test_config() -> AssetConfig {
        AssetConfig {
            reserve_ratio: 2500,
            target_utilization: 8000,
            target_utilization_rate: 1000000000003593629036885046u128.into(),
            max_utilization_rate: 1000000000039724853136740579u128.into(),
            volatility_ratio: 6000,
            extra_decimals: 0,
            can_deposit: true,
            can_withdraw: true,
            can_use_as_collateral: true,
            can_borrow: true,
        }
    }

    #[test]
    fn test_get_rate_and_apr() {
        let config = test_config();
        let rate = config.get_rate(81 * ONE_NEAR, 100 * ONE_NEAR);
        println!("Rate: {}", rate);

        let apr = rate.pow(MS_PER_YEAR) - BigDecimal::one();
        println!("APR: {}", apr)
    }
}

'''
'''--- references/main/branches/tests/contract/src/asset_farm.rs ---
use crate::*;

static ASSET_FARMS: Lazy<Mutex<HashMap<FarmId, Option<AssetFarm>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

const NANOS_PER_DAY: Duration = 24 * 60 * 60 * 10u64.pow(9);

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
    /// Inactive rewards
    #[serde(skip_serializing)]
    pub inactive_rewards: LookupMap<TokenId, VAssetFarmReward>,
}

impl Clone for AssetFarm {
    fn clone(&self) -> Self {
        Self {
            block_timestamp: self.block_timestamp,
            rewards: self.rewards.clone(),
            inactive_rewards: BorshDeserialize::try_from_slice(
                &self.inactive_rewards.try_to_vec().unwrap(),
            )
            .unwrap(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VAssetFarmReward {
    Current(AssetFarmReward),
}

impl From<VAssetFarmReward> for AssetFarmReward {
    fn from(v: VAssetFarmReward) -> Self {
        match v {
            VAssetFarmReward::Current(c) => c,
        }
    }
}

impl From<AssetFarmReward> for VAssetFarmReward {
    fn from(c: AssetFarmReward) -> Self {
        VAssetFarmReward::Current(c)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Serialize, Default)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(skip)]
    pub reward_per_share: BigDecimal,
}

impl AssetFarm {
    pub fn update(&mut self, is_view: bool) {
        let block_timestamp = env::block_timestamp();
        if block_timestamp == self.block_timestamp {
            return;
        }
        let time_diff = block_timestamp - self.block_timestamp;
        self.block_timestamp = block_timestamp;
        let mut new_inactive_reward = vec![];
        for (token_id, reward) in self.rewards.iter_mut() {
            if reward.boosted_shares == 0 {
                continue;
            }
            let acquired_rewards = std::cmp::min(
                reward.remaining_rewards,
                u128_ratio(
                    reward.reward_per_day,
                    u128::from(time_diff),
                    u128::from(NANOS_PER_DAY),
                ),
            );
            reward.remaining_rewards -= acquired_rewards;
            reward.reward_per_share = reward.reward_per_share
                + BigDecimal::from(acquired_rewards) / BigDecimal::from(reward.boosted_shares);
            if reward.remaining_rewards == 0 {
                new_inactive_reward.push(token_id.clone());
            }
        }
        if !is_view {
            for token_id in new_inactive_reward {
                let reward = self.rewards.remove(&token_id).unwrap();
                self.internal_set_inactive_asset_farm_reward(&token_id, reward);
            }
        }
    }

    pub fn internal_get_inactive_asset_farm_reward(
        &self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.get(token_id).map(|o| o.into())
    }

    pub fn internal_remove_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.remove(token_id).map(|o| o.into())
    }

    pub fn internal_set_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
        asset_farm_reward: AssetFarmReward,
    ) {
        self.inactive_rewards
            .insert(token_id, &asset_farm_reward.into());
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAssetFarm {
    Current(AssetFarm),
}

impl From<VAssetFarm> for AssetFarm {
    fn from(v: VAssetFarm) -> Self {
        match v {
            VAssetFarm::Current(c) => c,
        }
    }
}

impl From<AssetFarm> for VAssetFarm {
    fn from(c: AssetFarm) -> Self {
        VAssetFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_unwrap_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> AssetFarm {
        self.internal_get_asset_farm(farm_id, is_view)
            .expect("Asset farm not found")
    }

    pub fn internal_get_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> Option<AssetFarm> {
        let mut cache = ASSET_FARMS.lock().unwrap();
        cache.get(farm_id).cloned().unwrap_or_else(|| {
            let asset_farm = self.asset_farms.get(farm_id).map(|v| {
                let mut asset_farm: AssetFarm = v.into();
                asset_farm.update(is_view);
                asset_farm
            });
            cache.insert(farm_id.clone(), asset_farm.clone());
            asset_farm
        })
    }

    pub fn internal_set_asset_farm(&mut self, farm_id: &FarmId, asset_farm: AssetFarm) {
        ASSET_FARMS
            .lock()
            .unwrap()
            .insert(farm_id.clone(), Some(asset_farm.clone()));
        self.asset_farms.insert(farm_id, &asset_farm.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset farm for a given farm ID.
    pub fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm> {
        self.internal_get_asset_farm(&farm_id, true)
    }

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    pub fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)> {
        farm_ids
            .into_iter()
            .filter_map(|farm_id| {
                self.internal_get_asset_farm(&farm_id, true)
                    .map(|asset_farm| (farm_id, asset_farm))
            })
            .collect()
    }

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    pub fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        let mut farm_ids = vec![];
        for index in from_index..std::cmp::min(keys.len(), limit) {
            let token_id = keys.get(index).unwrap();
            farm_ids.push(FarmId::Supplied(token_id.clone()));
            farm_ids.push(FarmId::Borrowed(token_id));
        }
        self.get_asset_farms(farm_ids)
    }
}

'''
'''--- references/main/branches/tests/contract/src/asset_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

impl Contract {
    pub fn asset_into_detailed_view(&self, token_id: TokenId, asset: Asset) -> AssetDetailedView {
        let farms = self
            .get_asset_farms(vec![
                FarmId::Supplied(token_id.clone()),
                FarmId::Borrowed(token_id.clone()),
            ])
            .into_iter()
            .map(|(farm_id, asset_farm)| AssetFarmView {
                farm_id,
                rewards: asset_farm.rewards,
            })
            .collect();
        let supply_apr = asset.get_supply_apr();
        let borrow_apr = asset.get_borrow_apr();
        let Asset {
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
        } = asset;
        AssetDetailedView {
            token_id,
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
            supply_apr,
            borrow_apr,
            farms,
        }
    }
}

'''
'''--- references/main/branches/tests/contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
#[cfg(not(target_arch = "wasm32"))]
use std::str::FromStr;

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

#[cfg(not(target_arch = "wasm32"))]
const PARSE_INT_ERROR: &'static str = "Parse int error";

#[cfg(not(target_arch = "wasm32"))]
impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<27}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(&int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Ok(Self::from_str(&s).map_err(|err| near_sdk::serde::de::Error::custom(err))?)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn from_balance_price(balance: Balance, price: &Price, extra_decimals: u8) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        let denominator_decimals = price.decimals + extra_decimals;
        if denominator_decimals > NUM_DECIMALS {
            Self(num / U384::exp10((denominator_decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - denominator_decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = MS_PER_YEAR;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- references/main/branches/tests/contract/src/config.rs ---
use crate::*;

/// Contract config
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            self.internal_config().owner_id.as_ref(),
            "Not an owner"
        );
    }
}

#[near_bindgen]
impl Contract {
    /// Returns the current config.
    pub fn get_config(&self) -> Config {
        self.internal_config()
    }

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_config(&mut self, config: Config) {
        assert_one_yocto();
        self.assert_owner();
        self.config.set(&config);
    }

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        assert!(self.asset_ids.insert(token_id.as_ref()));
        self.internal_set_asset(
            token_id.as_ref(),
            Asset::new(env::block_timestamp(), asset_config),
        )
    }

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        let mut asset = self.internal_unwrap_asset(token_id.as_ref());
        asset.config = asset_config;
        self.internal_set_asset(token_id.as_ref(), asset);
    }

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        reward_token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        reward_amount: WrappedBalance,
    ) {
        assert_one_yocto();
        self.assert_owner();
        assert!(self.assets.contains_key(farm_id.get_token_id()));
        let reward_token_id: TokenId = reward_token_id.into();
        let mut reward_asset = self.internal_unwrap_asset(&reward_token_id);
        assert!(
            reward_asset.reserved >= reward_amount.0
                && reward_asset.available_amount() >= reward_amount.0,
            "Not enough reserved reward balance"
        );
        reward_asset.reserved -= reward_amount.0;
        self.internal_set_asset(&reward_token_id, reward_asset);
        let mut asset_farm = self
            .internal_get_asset_farm(&farm_id, false)
            .unwrap_or_else(|| AssetFarm {
                block_timestamp: env::block_timestamp(),
                rewards: HashMap::new(),
                inactive_rewards: LookupMap::new(StorageKey::InactiveAssetFarmRewards {
                    farm_id: farm_id.clone(),
                }),
            });

        let mut asset_farm_reward = asset_farm
            .rewards
            .remove(&reward_token_id)
            .or_else(|| asset_farm.internal_remove_inactive_asset_farm_reward(&reward_token_id))
            .unwrap_or_default();
        asset_farm_reward.reward_per_day = new_reward_per_day.into();
        asset_farm_reward.booster_log_base = new_booster_log_base.into();
        asset_farm_reward.remaining_rewards += reward_amount.0;
        asset_farm
            .rewards
            .insert(reward_token_id, asset_farm_reward);
        self.internal_set_asset_farm(&farm_id, asset_farm);
    }
}

'''
'''--- references/main/branches/tests/contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::{is_promise_success, serde_json, PromiseOrValue};

const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 20 * TGAS;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    DepositToReserve,
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_id = env::predecessor_account_id();
        let mut asset = self.internal_unwrap_asset(&token_id);
        assert!(
            asset.config.can_deposit,
            "Deposits for this asset are not enabled"
        );

        let amount = amount.0 * 10u128.pow(asset.config.extra_decimals as u32);

        // TODO: We need to be careful that only whitelisted tokens can call this method with a
        //     given set of actions. Or verify which actions are possible to do.
        let actions: Vec<Action> = if msg.is_empty() {
            vec![]
        } else {
            let token_receiver_msg: TokenReceiverMsg =
                serde_json::from_str(&msg).expect("Can't parse TokenReceiverMsg");
            match token_receiver_msg {
                TokenReceiverMsg::Execute { actions } => actions,
                TokenReceiverMsg::DepositToReserve => {
                    asset.reserved += amount;
                    self.internal_set_asset(&token_id, asset);
                    log!(
                        "Account {} deposits to reserve {} of {}",
                        sender_id.as_ref(),
                        amount,
                        token_id
                    );
                    return PromiseOrValue::Value(U128(0));
                }
            }
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        account.add_affected_farm(FarmId::Supplied(token_id.clone()));
        self.internal_deposit(&mut account, &token_id, amount);
        log!("Account {} deposits {} of {}", sender_id, amount, token_id);
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            Prices::new(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);

        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_ft_transfer(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
        amount: Balance,
    ) -> Promise {
        let asset = self.internal_unwrap_asset(token_id);
        let ft_amount = amount / 10u128.pow(asset.config.extra_decimals as u32);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            ft_amount.into(),
            None,
            token_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id.clone(),
            token_id.clone(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let (mut account, storage) = self.internal_unwrap_account_with_storage(&account_id);
            account.add_affected_farm(FarmId::Supplied(token_id.clone()));
            self.internal_deposit(&mut account, &token_id, amount.0);
            log!(
                "Withdrawal has failed: Account {} deposits {} of {}",
                account_id,
                amount.0,
                token_id
            );
            self.internal_set_account(&account_id, account, storage);
        }
        promise_success
    }
}

'''
'''--- references/main/branches/tests/contract/src/lib.rs ---
mod account;
mod account_asset;
mod account_farm;
mod account_view;
mod actions;
mod asset;
mod asset_config;
mod asset_farm;
mod asset_view;
mod big_decimal;
mod config;
mod fungible_token;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod utils;

pub use crate::account::*;
pub use crate::account_asset::*;
pub use crate::account_farm::*;
pub use crate::account_view::*;
pub use crate::actions::*;
pub use crate::asset::*;
pub use crate::asset_config::*;
pub use crate::asset_farm::*;
pub use crate::asset_view::*;
pub use crate::big_decimal::*;
pub use crate::config::*;
pub use crate::fungible_token::*;
pub use crate::pool::*;
pub use crate::price_receiver::*;
pub use crate::prices::*;
pub use crate::storage::*;
use crate::utils::*;

use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{ValidAccountId, WrappedBalance};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp,
};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;

near_sdk::setup_alloc!();

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountAssets { account_id: AccountId },
    AccountFarms { account_id: AccountId },
    Storage,
    Assets,
    AssetFarms,
    InactiveAssetFarmRewards { farm_id: FarmId },
    AssetIds,
    Config,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, VAccount>,
    pub storage: LookupMap<AccountId, VStorage>,
    pub assets: LookupMap<TokenId, VAsset>,
    pub asset_farms: LookupMap<FarmId, VAssetFarm>,
    pub asset_ids: UnorderedSet<TokenId>,
    pub config: LazyOption<Config>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKey::Accounts),
            storage: LookupMap::new(StorageKey::Storage),
            assets: LookupMap::new(StorageKey::Assets),
            asset_farms: LookupMap::new(StorageKey::AssetFarms),
            asset_ids: UnorderedSet::new(StorageKey::AssetIds),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
        }
    }
}

'''
'''--- references/main/branches/tests/contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn shares_to_amount(&self, shares: Shares, round_up: bool) -> Balance {
        if shares.0 >= self.balance || shares.0 == self.shares.0 {
            self.balance
        } else {
            let extra = if round_up {
                U256::from(self.shares.0 - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.balance) * U256::from(shares.0) + extra) / U256::from(self.shares.0))
                .as_u128()
        }
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- references/main/branches/tests/contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let (mut account, mut storage) =
            self.internal_unwrap_account_with_storage(sender_id.as_ref());
        self.internal_execute(
            sender_id.as_ref(),
            &mut account,
            &mut storage,
            actions,
            data.into(),
        );
        self.internal_set_account(sender_id.as_ref(), account, storage);
    }
}

'''
'''--- references/main/branches/tests/contract/src/prices.rs ---
use crate::*;

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    price.map(|price| (asset_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- references/main/branches/tests/contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 1000 bytes
const MIN_STORAGE_BALANCE: Balance = 1000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize, Clone)]
#[borsh_init(init)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub initial_storage_usage: StorageUsage,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VStorage {
    Current(Storage),
}

impl From<VStorage> for Storage {
    fn from(v: VStorage) -> Self {
        match v {
            VStorage::Current(c) => c,
        }
    }
}

impl From<Storage> for VStorage {
    fn from(c: Storage) -> Self {
        VStorage::Current(c)
    }
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            initial_storage_usage: env::storage_usage(),
        }
    }

    pub(crate) fn available_bytes(&self) -> StorageUsage {
        let covered_bytes = (self.storage_balance / env::storage_byte_cost()) as StorageUsage;
        covered_bytes - self.used_bytes
    }

    fn init(&mut self) {
        self.initial_storage_usage = env::storage_usage();
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        let storage_usage = env::storage_usage();
        if storage_usage > storage.initial_storage_usage {
            let extra_bytes_used = storage_usage - storage.initial_storage_usage;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released = storage.initial_storage_usage - storage_usage;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic(b"The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }
            // Saving storage object copy into the persistent storage to account for used bytes.
            self.internal_set_storage(&account_id, storage.clone());
            self.internal_set_account(&account_id, Account::new(&account_id), storage);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic(b"The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic(format!("The account {} is not registered", &account_id).as_bytes());
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic(b"The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(account_id.as_ref())
    }
}

'''
'''--- references/main/branches/tests/contract/src/utils.rs ---
use crate::*;

pub(crate) type TokenId = AccountId;

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

pub(crate) fn nano_to_ms(nano: u64) -> u64 {
    nano / 10u64.pow(6)
}

pub(crate) fn ms_to_nano(ms: u64) -> u64 {
    ms * 10u64.pow(6)
}

pub(crate) fn u128_ratio(a: u128, num: u128, denom: u128) -> Balance {
    (U256::from(a) * U256::from(num) / U256::from(denom)).as_u128()
}

pub(crate) fn ratio(balance: Balance, r: u32) -> Balance {
    assert!(r <= MAX_RATIO);
    u128_ratio(balance, u128::from(r), u128::from(MAX_RATIO))
}

'''
'''--- references/main/branches/tests/scripts/add_farms.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Adding the farms $LG<<<<<<<<<<<<<<$NC"

for TOKEN_ID in $DAI_TOKEN_ID $USDT_TOKEN_ID $WETH_TOKEN_ID $WNEAR_TOKEN_ID
do

  echo -e "$LG>>>>>>>>>>>>>>$TC Adding farms for $TOKEN_ID $LG<<<<<<<<<<<<<<$NC"

  near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
    "farm_id": {
      "Supplied": "'$TOKEN_ID'"
    },
    "reward_token_id": "'$BOOSTER_TOKEN_ID'",
    "new_reward_per_day": "100000000000000000000",
    "new_booster_log_base": "100000000000000000000",
    "reward_amount": "700000000000000000000"
  }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$BOOSTER_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000",
      "new_booster_log_base": "100000000000000000000",
      "reward_amount": "1750000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Supplied": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "100000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "700000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "1750000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

done

near view $CONTRACT_ID get_asset_farms_paged

'''
'''--- references/main/branches/tests/scripts/apr_to_rate.py ---
#!/usr/bin/env python3

import sys
from decimal import *

getcontext().prec = 60

n = 31536000000
input_apr = Decimal(sys.argv[1])
print("Input APR: %s%%" % (input_apr,))
print("n: %d" % (n,))

res = (((input_apr / Decimal(100)) + Decimal(1)) ** (Decimal(1) / Decimal(n)))
print("R: %s" % (res,))
print("R ** n: %s" % (res ** n,))

round_res = round(res * (Decimal(10) ** Decimal(27)))
print("rate: %s" % (round_res, ))

'''
'''--- references/main/branches/tests/scripts/create_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

mv -f neardev/dev-account neardev/dev-account-old 2> /dev/null || true

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create a user's account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
export ACCOUNT_ID="$(cat neardev/dev-account)"

mv -f neardev/dev-account-old neardev/dev-account 2> /dev/null || true

scripts/mint_to_account.sh

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export ACCOUNT_ID=$ACCOUNT_ID"

'''
'''--- references/main/branches/tests/scripts/dev_deploy.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create an owner account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
OWNER_ID="$(cat neardev/dev-account)"

ORACLE_ID="priceoracle.testnet"

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy the main contract $LG<<<<<<<<<<<<<<$NC"
near dev-deploy -f res/Nearlend.wasm
CONTRACT_ID="$(cat neardev/dev-account)"

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing Booster token $LG<<<<<<<<<<<<<<$NC"
BOOSTER_TOKEN_ID="ref.fakes.testnet"

near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing the main contract $LG<<<<<<<<<<<<<<$NC"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wETH $LG<<<<<<<<<<<<<<$NC"
WETH_TOKEN_ID="weth.fakes.testnet"

near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing DAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing USDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$BOOSTER_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": false,
    "can_borrow": false
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "120000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export WETH_TOKEN_ID=$WETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- references/main/branches/tests/scripts/mint_to_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Registering storage for the user: $LG<<<<<<<<<<<<<<$NC"
near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "100000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID near_deposit '{}' --amount=100

'''
'''--- references/main/branches/tests/scripts/readme_test.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'

near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
sleep 1

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'

near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

'''
'''--- references/main/branches/tests/sim-tests/babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- references/main/branches/tests/sim-tests/config.js ---
module.exports = {
    API_SERVER_URL: "http://78.47.91.25:3000",
    CREDENTIALS_DIR: ".near-credentials/testnet/",
    FRACTION_DIGITS: 5,
    GAS: 100000000000000,
}

'''
'''--- references/main/branches/tests/sim-tests/jest.config.js ---
module.exports = {
    testEnvironment: "node",
    testTimeout: 900000,
    globals: {
        Uint8Array: Uint8Array,
    },
};
'''
'''--- references/main/branches/tests/sim-tests/package.json ---
{
  "name": "sim-tests",
  "version": "1.0.0",
  "scripts": {
    "test": "jest rest-api.test.js --useStderr --verbose false",
    "test:accounts": "jest rest-api.test.js -t 'Accounts' --useStderr --verbose false",
    "test:collateral": "jest rest-api.test.js -t 'Collateral' --useStderr --verbose false",
    "test:borrow": "jest rest-api.test.js -t 'Borrow' --useStderr --verbose false",
    "test:withdraw": "jest rest-api.test.js -t 'Withdraw' --useStderr --verbose false",
    "test:repay": "jest rest-api.test.js -t 'Repay' --useStderr --verbose false",
    "test:decrease": "jest rest-api.test.js -t 'Decrease collateral' --useStderr --verbose false"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.6.0",
    "node-fetch": "^2.6.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.1.1",
    "near-api-js": "^0.41.0",
    "react": "~17.0.1",
    "react-dom": "~17.0.1",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  }
}

'''
'''--- references/main/branches/tests/sim-tests/rest-api-dummy-data.test.js ---
/* export REACT_CONTRACT_ID=dev-1627393733545-88687685295664 */
import 'regenerator-runtime/runtime'

const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const contract_id  = process.env.CONTRACT_NAME;

const near = new contract(process.env.CONTRACT_NAME);

const MIN_TOKENS = 20;

describe("Contract set", () => {
    test("Contract set: " + process.env.CONTRACT_NAME, async () => {
        expect(process.env.CONTRACT_NAME).not.toBe(undefined)
    });

    test('Accounts has enough funds', async () => {
        const contract_wallet_balance = await near.accountNearBalance(contract_id);
        expect(contract_wallet_balance).toBeGreaterThan(MIN_TOKENS);
    });
});

describe("Insert dummy data", () => {
    console.log(contract_id)
    test('Insert players', async () => {
        for (let i = 500; i <= 600; i++) {
            let account = `account_${i}.testnet`;
            const start_game = await near.call("start_game_for_account_id",
                {quiz_id: 36, account_id: account},
                {account_id: contract_id});
            expect(start_game.type).not.toBe('FunctionCallError');
        }
    });
});

'''
'''--- references/main/branches/tests/sim-tests/rest-api-test-utils.js ---
const utils = require('./utils');
const config = require("./config");

function contract(contract_id) {
    this.contract_id = contract_id;
}

contract.prototype.deploy = async function (contractName) {
    const body = {
        contract: contractName,
        account_id: this.contract_id,
        private_key: await utils.getPrivateKey(this.contract_id),
    };

    return await utils.PostResponse("deploy", body);
};

contract.prototype.view = async function (method, params, options) {
    const body = {
        method: method,
        params: params,
        contract: this.contract_id,
        disabled_cache: true
    };

    return await utils.PostResponse("view", body, options);
};

contract.prototype.viewNearBalance = async function (method, params, options) {
    options = options || {};
    options.convertToNear = true;
    return await this.view(method, params, options);
};

contract.prototype.viewFTe18Balance = async function (method, params, options) {
    options = options || {};
    options.convertFromFTe18 = true;
    return await this.view(method, params, options);
};

contract.prototype.accountNearBalance = async function (account_id, delay) {
    delay = delay || 1000;
    await timeout(delay);

    return await utils.GetResponse("balance", account_id, {convertToNear: true})
        .catch(e => console.error("AccountNearBalance error for " + JSON.stringify(account_id) + ". Error: " + e.message));
};

contract.prototype.call = async function (method, params, options) {
    options.attached_gas = options.gas || config.GAS;
    options.attached_tokens = options.tokens || 0;
    options.private_key = options.private_key || await utils.getPrivateKey(options.account_id);
    options.log_errors = options.log_errors || false;
    options.return_value = options.return_value || false;

    const body = {
        ...options,
        method: method,
        params: params,
        contract: this.contract_id,
    };

    return await utils.PostResponse("call", body, options)
        .catch(e => {
            if(e.message.includes("Unexpected token < in JSON at position 0"))
                console.error("RPC/JSON Error: " + e.message);
            else
                console.error("Call error for " + JSON.stringify(body) + ". Error: " + e.message)
        });
};

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = contract;

'''
'''--- references/main/branches/tests/sim-tests/rest-api.test.js ---
import 'regenerator-runtime/runtime'

/*
export NEAR_ENV=testnet
export OWNER_ID=dev-1634805788173-90290670203248
export ORACLE_ID=priceoracle.testnet
export CONTRACT_ID=dev-1634805794596-68676200580325
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export ACCOUNT_ID=dev-1634809261182-39559532470451

 */
const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const alice = process.env.ACCOUNT_ID;
const contract_id = process.env.CONTRACT_ID;
const usdt_contract_id = process.env.USDT_TOKEN_ID;
const dai_contract_id = process.env.DAI_TOKEN_ID;
const oracle_contract_id = process.env.ORACLE_ID;

const bob = "place.testnet";

const burrow = new contract(contract_id);
const usdt = new contract(usdt_contract_id);
const dai = new contract(dai_contract_id);
const oracle = new contract(oracle_contract_id);

describe("Contract set", () => {
    test("Contract is not null " + contract_id, async () => {
        expect(contract_id).not.toBe(undefined)
    });

    test("USDT Contract is not null " + usdt_contract_id, async () => {
        expect(usdt_contract_id).not.toBe(undefined)
    });

    test("DAI Contract is not null " + usdt_contract_id, async () => {
        expect(dai_contract_id).not.toBe(undefined)
    });

    test("Oracle Contract is not null " + alice, async () => {
        expect(oracle_contract_id).not.toBe(undefined)
    });

    test("Alice Account is not null " + alice, async () => {
        expect(alice).not.toBe(undefined)
    });

    test('Alice has enough funds', async () => {
        const alice_wallet_balance = await burrow.accountNearBalance(alice, 0);
        expect(alice_wallet_balance).toBeGreaterThan(20);
    });
});

describe("Accounts", () => {
    test('Register account by paying for storage, deposit tokens', async () => {
        const storage_deposit = await burrow.call("storage_deposit",
            {}, {
                account_id: alice,
                tokens: utils.ConvertToNear(0.1),
                log_errors: true
            });
        expect(storage_deposit.is_error).toBeFalsy();

        const account_initial = await burrow.view("get_account",
            {account_id: alice}, {});

        // make ft deposit and check balance/shares
        const deposit_1 = 5;
        const asset_1 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});

        const ft_transfer_1 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_1.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        expect(account_1.account_id).toBe(alice);
        expect(account_1.supplied.length).toBeGreaterThan(0);

        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_1.length).toBe(1);

        const usdt_supplied_initial = account_initial.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.balance) + deposit_1);
        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.shares) + deposit_1);

        const asset_2 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});
        expect(utils.ConvertFromFTe18(asset_2.supplied.shares)
            - utils.ConvertFromFTe18(asset_1.supplied.shares)).toBe(5)

        const deposit_2 = 3;
        const ft_transfer_2 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_2.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_2.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance) + deposit_2);
        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares) + deposit_2);

        const deposit_3 = 0;
        const ft_transfer_3 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_3.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_3.is_error).toBeTruthy();

        const account_3 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_3 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_3.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Collateral", () => {
    test('Provide token as a collateral', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        const execute = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: usdt_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_collateral_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].balance)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].shares)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].shares));

        const execute_wrong_account = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {"token_id": usdt_contract_id}
                }]
            },
            {account_id: bob, tokens: 1})
        expect(execute_wrong_account.is_error).toBeTruthy();

        const execute_without_supply = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {
                        token_id: usdt_contract_id
                    }
                }]
            },
            {account_id: alice, tokens: 1})
        expect(execute_without_supply.is_error).toBeTruthy();
    });
});

describe("Borrow", () => {
    test('Borrow a token', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: 'dai.fakes.testnet',
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

describe("Withdraw", () => {
    test('Withdrawing the asset', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const ft_balance_1 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        const withdraw = await burrow.call("execute",
            {
                actions: [{
                    Withdraw: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(withdraw.is_error).toBeFalsy();

        const ft_balance_2 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        expect(ft_balance_2 - ft_balance_1)
            .toBeCloseTo(utils.ConvertFromFTe18(account_1.supplied.balance));

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.supplied.length).toBe(0);
    });
});

describe("Repay", () => {
    test('Deposit asset and repay it in one call', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const repay_amount_1 = 5;

        const ft_transfer_1 = await dai.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: repay_amount_1.toString() + "000000000000000000",
            msg: JSON.stringify({
                Execute: {
                    actions: [
                        {
                            Repay: {
                                token_id: 'dai.fakes.testnet'
                            }
                        }
                    ]
                }
            })
        }, {account_id: alice, tokens: 1, log_errors: true})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(0);

        expect(utils.ConvertFromFTe18(account_1.borrowed[0].balance) +
            utils.ConvertFromFTe18(account_2.supplied[0].balance)).toBeCloseTo(repay_amount_1);
    });
});

describe("Decrease collateral", () => {
    test('Decreasing collateral without providing prices', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        const decrease_collateral_wrong_asset = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral_wrong_asset.is_error).toBeTruthy();

        const decrease_collateral = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'usdt.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account", {account_id: alice}, {});
        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(usdt_collateral_2.length).toBe(0);
        expect(usdt_supplied_2.length).toBeGreaterThan(0);
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

'''
'''--- references/main/branches/tests/sim-tests/utils.js ---
const {utils} = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const {BN} = require('bn.js');
const fs = require('fs');
const fetch = require("node-fetch");
const config = require("./config");

module.exports = {
    ConvertYoctoNear: (value, frac_digits) => {
        try {
            return utils.format.formatNearAmount(value, frac_digits).replace(",", "");
        } catch (e) {
            console.log("ConvertYoctoNear error, value: " + value);
            console.log(e);
        }
    },

    ConvertFromFTe18: (value) => {
        if(value === undefined)
            return 0;

        return Number(Math.round(value / 100000000000000) / 10000);
    },

    ConvertToNear: (amount) => {
        return new BN(Math.round(amount * 100000000)).mul(new BN("10000000000000000")).toString();
    },

    RoundFloat: (amount) => {
        return +Number.parseFloat(amount).toFixed(config.FRACTION_DIGITS);
    },

    getPrivateKey: async (accountId) => {
        const credentialsPath = path.join(homedir, config.CREDENTIALS_DIR);
        const keyPath = credentialsPath + accountId + '.json';
        try {
            const credentials = JSON.parse(fs.readFileSync(keyPath));
            return (credentials.private_key);
        } catch (e) {
            console.error("Key not found for account " + keyPath + ". Error: " + e.message);
        }
    },

    PostResponse: async (operation, body, options) => {
        const response = fetch(`${config.API_SERVER_URL}/${operation}`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-type': 'application/json; charset=UTF-8'
            }
        })
            .then(res => {
                return res.text().then(response => {
                    if (options && options.log_errors) {
                        const response_json = JSON.parse(response);
                        if (response_json && response_json.error) {
                            const error = JSON.parse(response_json.error);
                            console.log(`Request: ${body.method}`);
                            console.log(`ERROR: ${error.type}: ${JSON.stringify(error.kind)}`);
                        }
                    }

                    if (options && (options.convertToNear || options.convertFromFTe18)) {
                        if (isNaN(response))
                            throw new Error(`Illegal balance value. Request: ${JSON.stringify(body)}. Response: ${response}`);

                        if (options.convertFromFTe18)
                            return module.exports.RoundFloat(module.exports.ConvertFromFTe18(response, config.FRACTION_DIGITS));
                        else
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(response, config.FRACTION_DIGITS));
                    } else {
                        try {
                            let json = JSON.parse(response);
                            json.is_error = json.error && JSON.parse(json.error).hasOwnProperty('kind');
                            try {
                                if (options.return_value)
                                    return Buffer.from( json.status.SuccessValue, 'base64').toString();
                                else
                                    return (json);
                            } catch (e) {
                                throw new Error("PostResponse error for " + operation + " request " + JSON.stringify(body) + ". Error: " + e.message);
                            }
                        } catch (e) {
                            return response;
                        }
                    }
                });

            });
        return response;
    },

    GetResponse: async (operation, value, options) => {
        const response = await fetch(`${config.API_SERVER_URL}/${operation}/${value}`, {
            method: 'GET'
        })
            .then(res => {
                if (options && options.convertToNear) {
                    return res.text().then(value => {
                        try {
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(value, config.FRACTION_DIGITS));
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                } else {
                    return res.json().then(json => {
                        try {
                            if (json.error)
                                return (JSON.parse(json.error));
                            else
                                return (json);
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                }
            });

        return response;
    },

    IsJson: (item) => {
        item = typeof item !== "string"
            ? JSON.stringify(item)
            : item;

        try {
            item = JSON.parse(item);
        } catch (e) {
            return false;
        }

        if (typeof item === "object" && item !== null) {
            return true;
        }

        return false;
    }
};

'''
'''--- references/main/branches/tests/test-oracle/Cargo.toml ---
[package]
name = "test-oracle"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
common = { path = "../common/" }

'''
'''--- references/main/branches/tests/test-oracle/src/lib.rs ---
use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
#[allow(unused_imports)]
use near_sdk::AccountId;
use near_sdk::{assert_one_yocto, env, ext_contract, near_bindgen, Gas, Promise};

near_sdk::setup_alloc!();

const GAS_FOR_PROMISE: Gas = 10 * TGAS;

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: ValidAccountId,
        price_data: PriceData,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

'''
'''--- references/main/branches/tests/tests/main.rs ---
mod setup;

use crate::setup::*;
use contract::{BigDecimal, MS_PER_YEAR};

const SEC_PER_YEAR: u32 = (MS_PER_YEAR / 1000) as u32;

#[macro_use]
extern crate approx;

fn basic_setup() -> (Env, Tokens, Users) {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
    storage_deposit(
        &users.alice,
        &e.contract.account_id(),
        &users.alice.account_id(),
        d(1, 23),
    );
    e.mint_tokens(&tokens, &users.bob);
    storage_deposit(
        &users.bob,
        &e.contract.account_id(),
        &users.bob.account_id(),
        d(1, 23),
    );

    (e, tokens, users)
}

#[test]
fn test_init_env() {
    let e = Env::init();
    let _tokens = Tokens::init(&e);
    let _users = Users::init(&e);
}

#[test]
fn test_mint_tokens() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
}

#[test]
fn test_dev_setup() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.reserved, d(10000, 24));
}

#[test]
fn test_supply() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.contract_ft_transfer_call(&tokens.wnear, &users.alice, amount, "")
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
    assert_eq!(account.supplied[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_supply_to_collateral() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, amount)
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.collateral[0].balance, amount);
    assert_eq!(account.collateral[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_borrow() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, borrow_amount);
    assert!(asset.supply_apr > BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, borrow_amount);
    assert_eq!(account.supplied[0].token_id, tokens.ndai.account_id());
    assert!(account.supplied[0].apr > BigDecimal::zero());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_borrow_and_withdraw() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, 0);
    assert_eq!(asset.supply_apr, BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_interest() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(10000, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(8000, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert_relative_eq!(asset.borrow_apr.f64(), 0.08f64);

    e.skip_time(SEC_PER_YEAR);

    let expected_borrow_amount = borrow_amount * 108 / 100;

    let asset = e.get_asset(&tokens.ndai);
    assert_relative_eq!(asset.borrowed.balance as f64, expected_borrow_amount as f64);

    let account = e.get_account(&users.alice);
    assert_relative_eq!(
        account.borrowed[0].balance as f64,
        expected_borrow_amount as f64
    );
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
}

'''
'''--- references/main/branches/tests/tests/setup.rs ---
use common::{AssetOptionalPrice, Price, PriceData, ONE_YOCTO};
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{env, serde_json, Balance, Gas, Timestamp};
use near_sdk_sim::runtime::GenesisConfig;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};
use std::convert::TryInto;

pub use contract::{
    AccountDetailedView, Action, AssetAmount, AssetConfig, AssetDetailedView, Config,
    ContractContract as NearlendContract, PriceReceiverMsg, TokenReceiverMsg,
};
use test_oracle::ContractContract as OracleContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    Nearlend_WASM_BYTES => "res/Nearlend.wasm",
    TEST_ORACLE_WASM_BYTES => "res/test_oracle.wasm",

    FUNGIBLE_TOKEN_WASM_BYTES => "res/fungible_token.wasm",
}

pub const NEAR: &str = "near";
pub const ORACLE_ID: &str = "oracle.near";
pub const Nearlend_ID: &str = "Nearlend.near";
pub const BOOSTER_TOKEN_ID: &str = "token.Nearlend.near";
pub const OWNER_ID: &str = "owner.near";

pub const T_GAS: Gas = 1_000_000_000_000;
pub const DEFAULT_GAS: Gas = 15 * T_GAS;
pub const MAX_GAS: Gas = 300 * T_GAS;
pub const BOOSTER_TOKEN_DECIMALS: u8 = 18;
pub const BOOSTER_TOKEN_TOTAL_SUPPLY: Balance =
    1_000_000_000 * 10u128.pow(BOOSTER_TOKEN_DECIMALS as _);

pub const DEPOSIT_TO_RESERVE: &str = "\"DepositToReserve\"";

pub struct Env {
    pub root: UserAccount,
    pub near: UserAccount,
    pub owner: UserAccount,
    pub oracle: ContractAccount<OracleContract>,
    pub contract: ContractAccount<NearlendContract>,
    pub booster_token: UserAccount,
}

pub struct Tokens {
    pub wnear: UserAccount,
    pub neth: UserAccount,
    pub ndai: UserAccount,
    pub nusdt: UserAccount,
    pub nusdc: UserAccount,
}

pub struct Users {
    pub alice: UserAccount,
    pub bob: UserAccount,
    pub charlie: UserAccount,
    pub dude: UserAccount,
    pub eve: UserAccount,
}

pub fn storage_deposit(
    user: &UserAccount,
    contract_id: &str,
    account_id: &str,
    attached_deposit: Balance,
) {
    user.call(
        contract_id.to_string(),
        "storage_deposit",
        &json!({ "account_id": account_id }).to_string().into_bytes(),
        DEFAULT_GAS,
        attached_deposit,
    )
    .assert_success();
}

pub fn ft_storage_deposit(user: &UserAccount, token_account_id: &str, account_id: &str) {
    storage_deposit(
        user,
        token_account_id,
        account_id,
        125 * env::STORAGE_PRICE_PER_BYTE,
    );
}

pub fn to_nano(timestamp: u32) -> Timestamp {
    Timestamp::from(timestamp) * 10u64.pow(9)
}

impl Env {
    pub fn init() -> Self {
        let mut genesis_config = GenesisConfig::default();
        genesis_config.block_prod_time = 0;
        let root = init_simulator(Some(genesis_config));
        let near = root.create_user(NEAR.to_string(), to_yocto("1000000"));
        let owner = near.create_user(OWNER_ID.to_string(), to_yocto("10000"));

        let oracle = deploy!(
            contract: OracleContract,
            contract_id: ORACLE_ID.to_string(),
            bytes: &TEST_ORACLE_WASM_BYTES,
            signer_account: near,
            deposit: to_yocto("10")
        );

        let contract = deploy!(
            contract: NearlendContract,
            contract_id: Nearlend_ID.to_string(),
            bytes: &Nearlend_WASM_BYTES,
            signer_account: near,
            deposit: to_yocto("20"),
            gas: DEFAULT_GAS,
            init_method: new(
                Config {
                    oracle_account_id: ORACLE_ID.to_string().try_into().unwrap(),
                    owner_id: owner.valid_account_id(),
                    booster_token_id: BOOSTER_TOKEN_ID.to_string(),
                    booster_decimals: BOOSTER_TOKEN_DECIMALS,
                }
            )
        );

        let booster_token = contract.user_account.deploy_and_init(
            &FUNGIBLE_TOKEN_WASM_BYTES,
            BOOSTER_TOKEN_ID.to_string(),
            "new",
            &json!({
                "owner_id": owner.valid_account_id(),
                "total_supply": U128::from(BOOSTER_TOKEN_TOTAL_SUPPLY),
                "metadata": FungibleTokenMetadata {
                    spec: FT_METADATA_SPEC.to_string(),
                    name: "Booster Token".to_string(),
                    symbol: "BOOSTER".to_string(),
                    icon: None,
                    reference: None,
                    reference_hash: None,
                    decimals: BOOSTER_TOKEN_DECIMALS,
                }
            })
            .to_string()
            .into_bytes(),
            to_yocto("10"),
            DEFAULT_GAS,
        );

        ft_storage_deposit(&owner, BOOSTER_TOKEN_ID, Nearlend_ID);

        Self {
            root,
            near,
            owner,
            contract,
            oracle,
            booster_token,
        }
    }

    pub fn setup_assets(&self, tokens: &Tokens) {
        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    self.booster_token.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000008319516250272147),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 2000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: false,
                        can_borrow: false,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.neth.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000001547125956667610),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.ndai.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdt.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdc.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.wnear.valid_account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000003593629036885046),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS,
                ONE_YOCTO,
            )
            .assert_success();
    }

    pub fn deposit_reserves(&self, tokens: &Tokens) {
        self.contract_ft_transfer_call(
            &tokens.wnear,
            &self.owner,
            d(10000, 24),
            DEPOSIT_TO_RESERVE,
        );
        self.contract_ft_transfer_call(&tokens.neth, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.ndai, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdt, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdc, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(
            &self.booster_token,
            &self.owner,
            d(10000, 18),
            DEPOSIT_TO_RESERVE,
        );
    }

    pub fn contract_ft_transfer_call(
        &self,
        token: &UserAccount,
        user: &UserAccount,
        amount: Balance,
        msg: &str,
    ) -> ExecutionResult {
        user.call(
            token.account_id.clone(),
            "ft_transfer_call",
            &json!({
                "receiver_id": self.contract.user_account.valid_account_id(),
                "amount": U128::from(amount),
                "msg": msg,
            })
            .to_string()
            .into_bytes(),
            MAX_GAS,
            1,
        )
    }

    pub fn mint_ft(&self, token: &UserAccount, receiver: &UserAccount, amount: Balance) {
        self.owner
            .call(
                token.account_id.clone(),
                "ft_transfer",
                &json!({
                    "receiver_id": receiver.valid_account_id(),
                    "amount": U128::from(amount),
                })
                .to_string()
                .into_bytes(),
                DEFAULT_GAS,
                1,
            )
            .assert_success();
    }

    pub fn mint_tokens(&self, tokens: &Tokens, user: &UserAccount) {
        ft_storage_deposit(user, &tokens.wnear.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.neth.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.ndai.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdt.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdc.account_id(), &user.account_id());
        ft_storage_deposit(user, &self.booster_token.account_id(), &user.account_id());

        let amount = 1000000;
        self.mint_ft(&tokens.wnear, user, d(amount, 24));
        self.mint_ft(&tokens.neth, user, d(amount, 18));
        self.mint_ft(&tokens.ndai, user, d(amount, 18));
        self.mint_ft(&tokens.nusdt, user, d(amount, 6));
        self.mint_ft(&tokens.nusdc, user, d(amount, 6));
        self.mint_ft(&self.booster_token, user, d(amount, 18));
    }

    pub fn get_asset(&self, token: &UserAccount) -> AssetDetailedView {
        let asset: Option<AssetDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_asset(token.valid_account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn get_account(&self, user: &UserAccount) -> AccountDetailedView {
        let asset: Option<AccountDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_account(user.valid_account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn supply_to_collateral(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        amount: Balance,
    ) -> ExecutionResult {
        self.contract_ft_transfer_call(
            &token,
            &user,
            amount,
            &serde_json::to_string(&TokenReceiverMsg::Execute {
                actions: vec![Action::IncreaseCollateral(AssetAmount {
                    token_id: token.account_id(),
                    amount: None,
                    max_amount: None,
                })],
            })
            .unwrap(),
        )
    }

    pub fn oracle_call(
        &self,
        user: &UserAccount,
        price_data: PriceData,
        msg: PriceReceiverMsg,
    ) -> ExecutionResult {
        user.function_call(
            self.oracle.contract.oracle_call(
                self.contract.user_account.valid_account_id(),
                price_data,
                serde_json::to_string(&msg).unwrap(),
            ),
            MAX_GAS,
            ONE_YOCTO,
        )
    }

    pub fn borrow(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![Action::Borrow(AssetAmount {
                    token_id: token.account_id(),
                    amount: Some(amount.into()),
                    max_amount: None,
                })],
            },
        )
    }

    pub fn borrow_and_withdraw(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![
                    Action::Borrow(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                    Action::Withdraw(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                ],
            },
        )
    }

    pub fn skip_time(&self, seconds: u32) {
        self.near.borrow_runtime_mut().cur_block.block_timestamp += to_nano(seconds);
    }
}

pub fn init_token(e: &Env, token_account_id: &str, decimals: u8) -> UserAccount {
    let token = e.near.deploy_and_init(
        &FUNGIBLE_TOKEN_WASM_BYTES,
        token_account_id.to_string(),
        "new",
        &json!({
            "owner_id": e.owner.valid_account_id(),
            "total_supply": U128::from(10u128.pow((9 + decimals) as _)),
            "metadata": FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: token_account_id.to_string(),
                symbol: token_account_id.to_string(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: decimals,
            }
        })
        .to_string()
        .into_bytes(),
        to_yocto("10"),
        DEFAULT_GAS,
    );

    ft_storage_deposit(&e.owner, token_account_id, Nearlend_ID);
    token
}

impl Tokens {
    pub fn init(e: &Env) -> Self {
        Self {
            wnear: init_token(e, "wrap.near", 24),
            neth: init_token(e, "neth.near", 18),
            ndai: init_token(e, "dai.near", 18),
            nusdt: init_token(e, "nusdt.near", 6),
            nusdc: init_token(e, "nusdc.near", 6),
        }
    }
}

impl Users {
    pub fn init(e: &Env) -> Self {
        Self {
            alice: e
                .near
                .create_user("alice.near".to_string(), to_yocto("10000")),
            bob: e
                .near
                .create_user("bob.near".to_string(), to_yocto("10000")),
            charlie: e
                .near
                .create_user("charlie.near".to_string(), to_yocto("10000")),
            dude: e
                .near
                .create_user("dude.near".to_string(), to_yocto("10000")),
            eve: e
                .near
                .create_user("eve.near".to_string(), to_yocto("10000")),
        }
    }
}

pub fn d(value: Balance, decimals: u8) -> Balance {
    value * 10u128.pow(decimals as _)
}

pub fn price_data(
    tokens: &Tokens,
    wnear_mul: Option<Balance>,
    neth_mul: Option<Balance>,
) -> PriceData {
    let mut prices = vec![
        AssetOptionalPrice {
            asset_id: tokens.ndai.account_id(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 22,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdc.account_id(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdt.account_id(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
    ];
    if let Some(wnear_mul) = wnear_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.wnear.account_id(),
            price: Some(Price {
                multiplier: wnear_mul,
                decimals: 28,
            }),
        })
    }
    if let Some(neth_mul) = neth_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.neth.account_id(),
            price: Some(Price {
                multiplier: neth_mul,
                decimals: 22,
            }),
        })
    }
    PriceData {
        timestamp: 0,
        recency_duration_sec: 90,
        prices,
    }
}

'''
'''--- references/main/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

perl -i -pe 's/\["cdylib", "rlib"\]/\["cdylib"\]/' contract/Cargo.toml

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/test_oracle.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/burrowland.wasm

perl -i -pe 's/\["cdylib"\]/\["cdylib", "rlib"\]/' contract/Cargo.toml

'''
'''--- references/main/common/Cargo.toml ---
[package]
name = "common"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dependencies]
near-sdk = "=4.0.0-pre.7"

'''
'''--- references/main/common/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Timestamp};

pub type AssetId = String;
pub type DurationSec = u32;

pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;

const MAX_VALID_DECIMALS: u8 = 77;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    pub multiplier: Balance,
    pub decimals: u8,
}

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

'''
'''--- references/main/contract/API.md ---
# The list of APIs that are provided by the contract

Notes:
- `u128_dec_format`, `WrappedBalance`, `Shares` means the value is passed as a decimal string representation. E.g. `1` serialized as `"1"`
- `BigDecimal` is serialized as floating string representation. E.g. `1.5` serialized as `"1.5"`
- `u64` means the value is passed as an integer.
- `Option<_>` means the value can be omitted, or provided as `null`.
- Rust enums are serialized using JSON objects. E.g. `FarmId::Supplied("token.near")` is serialized as `{"Supplied": "token.near"}`
- `HashMap<_, _>` is serialized using JSON objects.

```rust
trait Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    fn new(config: Config) -> Self;

    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView>;

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account>;

    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    fn execute(&mut self, actions: Vec<Action>);

    /// Returns a detailed view asset for a given token_id.
    /// The detailed view includes current APR and corresponding farms.
    fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView>;

    /// Returns an list of detailed view assets a given list of token_id.
    /// Only returns existing assets.
    fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView>;

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)>;

    /// Returns a list of detailed view assets from a given index up to a given limit.
    fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView>;

    /// Returns the current config.
    fn get_config(&self) -> Config;

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_config(&mut self, config: Config);

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);

    /// Claims all unclaimed farm rewards.
    fn account_farm_claim_all(&mut self);

    /// Returns an asset farm for a given farm ID.
    fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm>;

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)>;

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)>;

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        extra_amount: WrappedBalance,
    );
}
```

## Structures and types

```rust
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

/// Limited view of the account structure for liquidations
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
}

pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
}

pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

/// Contract config
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    /// The entire amount will be deposited to the asset reserve. 
    DepositToReserve,
}

enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

pub type TokenId = AccountId;
```

## Also storage management

```rust
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregestering the account is not allowed to not break the order of accounts.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}
```

'''
'''--- references/main/contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"
uint = { version = "0.9.0", default-features = false }
common = { path = "../common/" }
once_cell = "1.8.0"

[dev-dependencies]
rand = "0.8"

'''
'''--- references/main/contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
    /// Keeping track of data required for farms for this account.
    #[serde(skip_serializing)]
    pub farms: UnorderedMap<FarmId, VAccountFarm>,
    #[borsh_skip]
    #[serde(skip_serializing)]
    pub affected_farms: Vec<FarmId>,

    /// Tracks changes in storage usage by persistent collections in this account.
    #[borsh_skip]
    #[serde(skip)]
    pub storage_tracker: StorageTracker,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v: VAccount) -> Self {
        match v {
            VAccount::Current(c) => c,
        }
    }
}

impl From<Account> for VAccount {
    fn from(c: Account) -> Self {
        VAccount::Current(c)
    }
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: UnorderedMap::new(StorageKey::AccountAssets {
                account_id: account_id.clone(),
            }),
            collateral: vec![],
            borrowed: vec![],
            farms: UnorderedMap::new(StorageKey::AccountFarms {
                account_id: account_id.clone(),
            }),
            affected_farms: vec![],
            storage_tracker: Default::default(),
        }
    }

    pub fn increase_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(collateral) = self.collateral.iter_mut().find(|c| &c.token_id == token_id) {
            collateral.shares.0 += shares.0;
        } else {
            self.collateral.push(CollateralAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .collateral
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Collateral not found");
        if let Some(new_balance) = self.collateral[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.collateral[index].shares.0 = new_balance;
            } else {
                self.collateral.swap_remove(index);
            }
        } else {
            env::panic_str("Not enough collateral balance");
        }
    }

    pub fn increase_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(borrowed) = self.borrowed.iter_mut().find(|c| &c.token_id == token_id) {
            borrowed.shares.0 += shares.0;
        } else {
            self.borrowed.push(BorrowedAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .borrowed
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found");
        if let Some(new_balance) = self.borrowed[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.borrowed[index].shares.0 = new_balance;
            } else {
                self.borrowed.swap_remove(index);
            }
        } else {
            env::panic_str("Not enough borrowed balance");
        }
    }

    pub fn internal_unwrap_collateral(&mut self, token_id: &TokenId) -> Shares {
        self.collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Collateral not found")
            .shares
    }

    pub fn internal_unwrap_borrowed(&mut self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found")
            .shares
    }

    pub fn add_affected_farm(&mut self, farm_id: FarmId) {
        if !self.affected_farms.contains(&farm_id) {
            self.affected_farms.push(farm_id);
        }
    }

    pub fn add_all_affected_farms(&mut self) {
        let len = self.affected_farms.len();
        for farm_id in self.farms.keys() {
            if len == 0
                || self
                    .affected_farms
                    .iter()
                    .take(len)
                    .find(|f| *f == &farm_id)
                    .is_none()
            {
                self.affected_farms.push(farm_id);
            }
        }
    }

    pub fn get_supplied_shares(&self, token_id: &TokenId) -> Shares {
        let collateral_shares = self
            .collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .map(|ca| ca.shares.0)
            .unwrap_or(0);
        let supplied_shares = self
            .internal_get_asset(token_id)
            .map(|asset| asset.shares.0)
            .unwrap_or(0);
        (supplied_shares + collateral_shares).into()
    }

    pub fn get_borrowed_shares(&self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|b| &b.token_id == token_id)
            .map(|ba| ba.shares)
            .unwrap_or(0.into())
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(&mut self, account_id: &AccountId, mut account: Account) {
        let mut storage = self.internal_unwrap_storage(account_id);
        storage
            .storage_tracker
            .consume(&mut account.storage_tracker);
        storage.storage_tracker.start();
        self.accounts.insert(account_id, &account.into());
        storage.storage_tracker.stop();
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: AccountId) -> Option<AccountDetailedView> {
        self.internal_get_account(&account_id)
            .map(|account| self.account_into_detailed_view(account))
    }

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    pub fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account> {
        let values = self.accounts.values_as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(values.len());
        (from_index..std::cmp::min(values.len(), limit))
            .map(|index| values.get(index).unwrap().into())
            .collect()
    }

    /// Returns the number of accounts
    pub fn get_num_accounts(&self) -> u32 {
        self.accounts.len() as _
    }
}

'''
'''--- references/main/contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountAsset {
    Current(AccountAsset),
}

impl From<VAccountAsset> for AccountAsset {
    fn from(v: VAccountAsset) -> Self {
        match v {
            VAccountAsset::Current(c) => c,
        }
    }
}

impl From<AccountAsset> for VAccountAsset {
    fn from(c: AccountAsset) -> Self {
        VAccountAsset::Current(c)
    }
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic_str("Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied.get(token_id).map(|o| o.into())
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        self.storage_tracker.start();
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id, &account_asset.into());
        }
        self.storage_tracker.stop();
        self.add_affected_farm(FarmId::Supplied(token_id.clone()));
    }
}

'''
'''--- references/main/contract/src/account_farm.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Hash, Eq, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

impl FarmId {
    pub fn get_token_id(&self) -> &TokenId {
        match self {
            FarmId::Supplied(token_id) => token_id,
            FarmId::Borrowed(token_id) => token_id,
        }
    }
}

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarm {
    pub block_timestamp: Timestamp,
    pub rewards: HashMap<TokenId, AccountFarmReward>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarmReward {
    pub boosted_shares: Balance,
    pub last_reward_per_share: BigDecimal,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountFarm {
    Current(AccountFarm),
}

impl From<VAccountFarm> for AccountFarm {
    fn from(v: VAccountFarm) -> Self {
        match v {
            VAccountFarm::Current(c) => c,
        }
    }
}

impl From<AccountFarm> for VAccountFarm {
    fn from(c: AccountFarm) -> Self {
        VAccountFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_account_farm_claim(
        &self,
        account: &Account,
        farm_id: &FarmId,
        asset_farm: &AssetFarm,
    ) -> (
        AccountFarm,
        Vec<(TokenId, Balance)>,
        Vec<(TokenId, Balance)>,
    ) {
        let mut new_rewards = vec![];
        let mut inactive_rewards = vec![];
        let block_timestamp = env::block_timestamp();
        let mut account_farm: AccountFarm = account
            .farms
            .get(farm_id)
            .map(|v| v.into())
            .unwrap_or_else(|| AccountFarm {
                block_timestamp: 0,
                rewards: HashMap::new(),
            });
        if account_farm.block_timestamp != block_timestamp {
            account_farm.block_timestamp = block_timestamp;
            let mut old_rewards = std::mem::take(&mut account_farm.rewards);
            for (
                token_id,
                AssetFarmReward {
                    reward_per_share, ..
                },
            ) in &asset_farm.rewards
            {
                let boosted_shares = if let Some(AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                }) = old_rewards.remove(token_id)
                {
                    let diff = reward_per_share.clone() - last_reward_per_share;
                    let amount = diff.round_mul_u128(boosted_shares);
                    if amount > 0 {
                        new_rewards.push((token_id.clone(), amount));
                    }
                    boosted_shares
                } else {
                    0
                };
                account_farm.rewards.insert(
                    token_id.clone(),
                    AccountFarmReward {
                        boosted_shares,
                        last_reward_per_share: reward_per_share.clone(),
                    },
                );
            }
            for (
                token_id,
                AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                },
            ) in old_rewards
            {
                let AssetFarmReward {
                    reward_per_share, ..
                } = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                let diff = reward_per_share - last_reward_per_share;
                let amount = diff.round_mul_u128(boosted_shares);
                inactive_rewards.push((token_id.clone(), boosted_shares));
                if amount > 0 {
                    new_rewards.push((token_id, amount));
                }
            }
        }
        (account_farm, new_rewards, inactive_rewards)
    }

    pub fn internal_account_apply_affected_farms(
        &mut self,
        account: &mut Account,
        verify_booster: bool,
    ) {
        let config = self.internal_config();
        if verify_booster
            && account
                .affected_farms
                .contains(&FarmId::Supplied(config.booster_token_id.clone()))
        {
            account.add_all_affected_farms();
        }
        if account.affected_farms.is_empty() {
            return;
        }
        let mut all_rewards: HashMap<TokenId, Balance> = HashMap::new();
        let mut i = 0;
        let mut farms = vec![];
        while i < account.affected_farms.len() {
            let farm_id = account.affected_farms[i].clone();
            if let Some(asset_farm) = self.internal_get_asset_farm(&farm_id, false) {
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(account, &farm_id, &asset_farm);
                for (token_id, amount) in new_rewards {
                    let new_farm_id = FarmId::Supplied(token_id.clone());
                    account.add_affected_farm(new_farm_id);
                    *all_rewards.entry(token_id).or_default() += amount;
                }
                farms.push((farm_id, account_farm, asset_farm, inactive_rewards));
            }
            i += 1;
        }
        for (token_id, &reward) in &all_rewards {
            self.internal_deposit(account, &token_id, reward);
        }
        let booster_balance = self
            .internal_get_asset(&config.booster_token_id)
            .map(|booster| {
                booster
                    .supplied
                    .shares_to_amount(account.get_supplied_shares(&config.booster_token_id), false)
            })
            .unwrap_or(0);
        let booster_base = 10u128.pow(config.booster_decimals as u32);

        for (farm_id, mut account_farm, mut asset_farm, inactive_rewards) in farms {
            let shares = match &farm_id {
                FarmId::Supplied(token_id) => account.get_supplied_shares(token_id).0,
                FarmId::Borrowed(token_id) => account.get_borrowed_shares(token_id).0,
            };
            for (token_id, asset_farm_reward) in asset_farm.rewards.iter_mut() {
                let account_farm_reward = account_farm.rewards.get_mut(token_id).unwrap();
                asset_farm_reward.boosted_shares -= account_farm_reward.boosted_shares;
                if shares > 0 {
                    let extra_shares = if booster_balance > booster_base {
                        let log_base =
                            (asset_farm_reward.booster_log_base as f64) / (booster_base as f64);
                        ((shares as f64)
                            * ((booster_balance as f64) / (booster_base as f64)).log(log_base))
                            as u128
                    } else {
                        0
                    };
                    account_farm_reward.boosted_shares = shares + extra_shares;
                    asset_farm_reward.boosted_shares += account_farm_reward.boosted_shares;
                }
            }
            for (token_id, boosted_shares) in inactive_rewards {
                let mut asset_farm_reward = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                asset_farm_reward.boosted_shares -= boosted_shares;
                asset_farm.internal_set_inactive_asset_farm_reward(&token_id, asset_farm_reward);
            }
            account.storage_tracker.start();
            if shares > 0 {
                account.farms.insert(&farm_id, &account_farm.into());
            } else {
                account.farms.remove(&farm_id);
            }
            account.storage_tracker.stop();
            self.internal_set_asset_farm(&farm_id, asset_farm);
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Claims all unclaimed farm rewards.
    pub fn account_farm_claim_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&env::predecessor_account_id());
        account.add_all_affected_farms();
        self.internal_account_apply_affected_farms(&mut account, false);
        self.internal_set_account(&account_id, account);
    }
}

'''
'''--- references/main/contract/src/account_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

impl Contract {
    pub fn account_into_detailed_view(&self, account: Account) -> AccountDetailedView {
        let farms = account
            .farms
            .keys()
            .map(|farm_id| {
                let mut asset_farm = self.internal_unwrap_asset_farm(&farm_id, true);
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(&account, &farm_id, &asset_farm);
                AccountFarmView {
                    farm_id,
                    rewards: account_farm
                        .rewards
                        .into_iter()
                        .map(|(token_id, AccountFarmReward { boosted_shares, .. })| {
                            (token_id, boosted_shares)
                        })
                        .chain(inactive_rewards)
                        .map(|(reward_token_id, boosted_shares)| {
                            let asset_farm_reward = asset_farm
                                .rewards
                                .remove(&reward_token_id)
                                .or_else(|| {
                                    asset_farm
                                        .internal_get_inactive_asset_farm_reward(&reward_token_id)
                                })
                                .unwrap();
                            let unclaimed_amount = new_rewards
                                .iter()
                                .find(|(token_id, _)| token_id == &reward_token_id)
                                .map(|(_, amount)| *amount)
                                .unwrap_or(0);
                            AccountFarmRewardView {
                                reward_token_id,
                                asset_farm_reward,
                                boosted_shares,
                                unclaimed_amount,
                            }
                        })
                        .collect(),
                }
            })
            .collect();
        AccountDetailedView {
            account_id: account.account_id,
            supplied: unordered_map_pagination(&account.supplied, None, None)
                .into_iter()
                .map(|(token_id, AccountAsset { shares })| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            collateral: account
                .collateral
                .into_iter()
                .map(|CollateralAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            borrowed: account
                .borrowed
                .into_iter()
                .map(|BorrowedAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, true)
                })
                .collect(),
            farms,
        }
    }

    fn get_asset_view(&self, token_id: TokenId, shares: Shares, is_borrowing: bool) -> AssetView {
        let asset = self.internal_unwrap_asset(&token_id);
        let apr = if is_borrowing {
            asset.get_borrow_apr()
        } else {
            asset.get_supply_apr()
        };
        let balance = if is_borrowing {
            asset.borrowed.shares_to_amount(shares, true)
        } else {
            asset.supplied.shares_to_amount(shares, false)
        };

        AssetView {
            token_id,
            balance,
            shares,
            apr,
        }
    }
}

'''
'''--- references/main/contract/src/actions.rs ---
use crate::*;

const MAX_NUM_ASSETS: usize = 10;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<U128>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<U128>,
}

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        let mut need_risk_check = false;
        let mut need_number_check = false;
        for action in actions {
            match action {
                Action::Withdraw(asset_amount) => {
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    let amount = self.internal_withdraw(account, &asset_amount);
                    self.internal_ft_transfer(account_id, &asset_amount.token_id, amount);
                    log!(
                        "Account {} withdraws {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::IncreaseCollateral(asset_amount) => {
                    need_number_check = true;
                    let amount = self.internal_increase_collateral(account, &asset_amount);
                    log!(
                        "Account {} increases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::DecreaseCollateral(asset_amount) => {
                    need_risk_check = true;
                    let mut account_asset =
                        account.internal_get_asset_or_default(&asset_amount.token_id);
                    let amount = self.internal_decrease_collateral(
                        &mut account_asset,
                        account,
                        &asset_amount,
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                    log!(
                        "Account {} decreases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Borrow(asset_amount) => {
                    need_number_check = true;
                    need_risk_check = true;
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_borrow(account, &asset_amount);
                    log!(
                        "Account {} borrows {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Repay(asset_amount) => {
                    let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_repay(&mut account_asset, account, &asset_amount);
                    log!(
                        "Account {} repays {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Liquidate {
                    account_id: liquidation_account_id,
                    in_assets,
                    out_assets,
                } => {
                    assert_ne!(
                        account_id, &liquidation_account_id,
                        "Can't liquidate yourself"
                    );
                    assert!(!in_assets.is_empty() && !out_assets.is_empty());
                    self.internal_liquidate(
                        account_id,
                        account,
                        &prices,
                        &liquidation_account_id,
                        in_assets,
                        out_assets,
                    );
                }
            }
        }
        if need_number_check {
            assert!(account.collateral.len() + account.borrowed.len() <= MAX_NUM_ASSETS);
        }
        if need_risk_check {
            assert!(self.compute_max_discount(account, &prices) == BigDecimal::zero());
        }

        self.internal_account_apply_affected_farms(account, true);
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }

    pub fn internal_withdraw(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_withdraw,
            "Withdrawals for this asset are not enabled"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        let available_amount = asset.available_amount();

        assert!(
            amount <= available_amount,
            "Withdraw error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        asset.supplied.withdraw(shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        amount
    }

    pub fn internal_increase_collateral(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_use_as_collateral,
            "Thi asset can't be used as a collateral"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        account.increase_collateral(&asset_amount.token_id, shares);

        amount
    }

    pub fn internal_decrease_collateral(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let collateral_shares = account.internal_unwrap_collateral(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, collateral_shares, &asset_amount, false);

        account.decrease_collateral(&asset_amount.token_id, shares);

        account_asset.deposit_shares(shares);

        amount
    }

    pub fn internal_borrow(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(asset.config.can_borrow, "Thi asset can't be used borrowed");

        let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);

        let available_amount = asset.available_amount();
        let max_borrow_shares = asset.borrowed.amount_to_shares(available_amount, false);

        let (borrowed_shares, amount) =
            asset_amount_to_shares(&asset.borrowed, max_borrow_shares, &asset_amount, true);

        assert!(
            amount <= available_amount,
            "Borrow error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        let supplied_shares: Shares = asset.supplied.amount_to_shares(amount, false);

        asset.borrowed.deposit(borrowed_shares, amount);
        asset.supplied.deposit(supplied_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.increase_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.deposit_shares(supplied_shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        amount
    }

    pub fn internal_repay(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let available_borrowed_shares = account.internal_unwrap_borrowed(&asset_amount.token_id);

        let (mut borrowed_shares, mut amount) = asset_amount_to_shares(
            &asset.borrowed,
            available_borrowed_shares,
            &asset_amount,
            true,
        );

        let mut supplied_shares = asset.supplied.amount_to_shares(amount, true);
        if supplied_shares.0 > account_asset.shares.0 {
            supplied_shares = account_asset.shares;
            amount = asset.supplied.shares_to_amount(supplied_shares, false);
            if let Some(min_amount) = &asset_amount.amount {
                assert!(amount >= min_amount.0, "Not enough supplied balance");
            }
            assert!(amount > 0, "Repayment amount can't be 0");

            borrowed_shares = asset.borrowed.amount_to_shares(amount, false);
            assert!(borrowed_shares.0 > 0, "Shares can't be 0");
            assert!(borrowed_shares.0 <= available_borrowed_shares.0);
        }

        asset.supplied.withdraw(supplied_shares, amount);
        asset.borrowed.withdraw(borrowed_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.decrease_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.withdraw_shares(supplied_shares);

        amount
    }

    pub fn internal_liquidate(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        prices: &Prices,
        liquidation_account_id: &AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    ) {
        let mut liquidation_account = self.internal_unwrap_account(liquidation_account_id);

        let max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            max_discount > BigDecimal::zero(),
            "The liquidation account is not at risk"
        );

        let mut borrowed_repaid_sum = BigDecimal::zero();
        let mut collateral_taken_sum = BigDecimal::zero();

        for asset_amount in in_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            liquidation_account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
            let amount =
                self.internal_repay(&mut account_asset, &mut liquidation_account, &asset_amount);
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            borrowed_repaid_sum = borrowed_repaid_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        for asset_amount in out_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            liquidation_account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);
            let amount = self.internal_decrease_collateral(
                &mut account_asset,
                &mut liquidation_account,
                &asset_amount,
            );
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            collateral_taken_sum = collateral_taken_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        let discounted_collateral_taken = collateral_taken_sum * (BigDecimal::one() - max_discount);
        assert!(
            discounted_collateral_taken <= borrowed_repaid_sum,
            "Not enough balances repaid: discounted collateral {} > borrowed repaid sum {}",
            discounted_collateral_taken,
            borrowed_repaid_sum
        );

        let new_max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            new_max_discount > BigDecimal::zero(),
            "The liquidation amount is too large. The liquidation account should stay in risk"
        );

        self.internal_account_apply_affected_farms(&mut liquidation_account, true);
        self.internal_set_account(liquidation_account_id, liquidation_account);

        log!(
            "Account {} liquidates account {}: takes {} for repaying {}",
            account_id,
            liquidation_account_id,
            collateral_taken_sum,
            borrowed_repaid_sum
        );
    }

    pub fn compute_max_discount(&self, account: &Account, prices: &Prices) -> BigDecimal {
        if account.borrowed.is_empty() {
            return BigDecimal::zero();
        }

        let collateral_sum = account
            .collateral
            .iter()
            .fold(BigDecimal::zero(), |sum, c| {
                let asset = self.internal_unwrap_asset(&c.token_id);
                let balance = asset.supplied.shares_to_amount(c.shares, false);
                sum + BigDecimal::from_balance_price(
                    balance,
                    prices.get_unwrap(&c.token_id),
                    asset.config.extra_decimals,
                )
                .mul_ratio(asset.config.volatility_ratio)
            });

        let borrowed_sum = account.borrowed.iter().fold(BigDecimal::zero(), |sum, b| {
            let asset = self.internal_unwrap_asset(&b.token_id);
            let balance = asset.borrowed.shares_to_amount(b.shares, true);
            sum + BigDecimal::from_balance_price(
                balance,
                prices.get_unwrap(&b.token_id),
                asset.config.extra_decimals,
            )
            .div_ratio(asset.config.volatility_ratio)
        });

        if borrowed_sum <= collateral_sum {
            BigDecimal::zero()
        } else {
            (borrowed_sum - collateral_sum) / borrowed_sum / BigDecimal::from(2u32)
        }
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    asset_amount: &AssetAmount,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = if let Some(amount) = &asset_amount.amount {
        (
            pool.amount_to_shares(amount.0, !inverse_round_direction),
            amount.0,
        )
    } else if let Some(max_amount) = &asset_amount.max_amount {
        let shares = std::cmp::min(
            available_shares.0,
            pool.amount_to_shares(max_amount.0, !inverse_round_direction)
                .0,
        )
        .into();
        (
            shares,
            std::cmp::min(
                pool.shares_to_amount(shares, inverse_round_direction),
                max_amount.0,
            ),
        )
    } else {
        (
            available_shares,
            pool.shares_to_amount(available_shares, inverse_round_direction),
        )
    };
    assert!(shares.0 > 0, "Shares can't be 0");
    assert!(amount > 0, "Amount can't be 0");
    (shares, amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&account_id);
        self.internal_execute(&account_id, &mut account, actions, Prices::new());
        self.internal_set_account(&account_id, account);
    }
}

'''
'''--- references/main/contract/src/asset.rs ---
use crate::*;

pub const MS_PER_YEAR: u64 = 31536000000;

static ASSETS: Lazy<Mutex<HashMap<TokenId, Option<Asset>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            supplied: Pool::new(),
            borrowed: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn get_rate(&self) -> BigDecimal {
        self.config
            .get_rate(self.borrowed.balance, self.supplied.balance + self.reserved)
    }

    pub fn get_borrow_apr(&self) -> BigDecimal {
        let rate = self.get_rate();
        rate.pow(MS_PER_YEAR) - BigDecimal::one()
    }

    pub fn get_supply_apr(&self) -> BigDecimal {
        if self.supplied.balance == 0 || self.borrowed.balance == 0 {
            return BigDecimal::zero();
        }

        let borrow_apr = self.get_borrow_apr();
        if borrow_apr == BigDecimal::zero() {
            return borrow_apr;
        }

        let interest = borrow_apr.round_mul_u128(self.borrowed.balance);
        let supply_interest = ratio(interest, MAX_RATIO - self.config.reserve_ratio);
        BigDecimal::from(supply_interest).div_u128(self.supplied.balance)
    }

    // n = 31536000000 ms in a year (365 days)
    //
    // Compute `r` from `X`. `X` is desired APY
    // (1 + r / n) ** n = X (2 == 200%)
    // n * log(1 + r / n) = log(x)
    // log(1 + r / n) = log(x) / n
    // log(1 + r  / n) = log( x ** (1 / n))
    // 1 + r / n = x ** (1 / n)
    // r / n = (x ** (1 / n)) - 1
    // r = n * ((x ** (1 / n)) - 1)
    // n = in millis
    fn compound(&mut self, time_diff_ms: Duration) {
        let rate = self.get_rate();
        let interest =
            rate.pow(time_diff_ms).round_mul_u128(self.borrowed.balance) - self.borrowed.balance;
        // TODO: Split interest based on ratio between reserved and supplied?
        let reserved = ratio(interest, self.config.reserve_ratio);
        if self.supplied.shares.0 > 0 {
            self.supplied.balance += interest - reserved;
            self.reserved += reserved;
        } else {
            self.reserved += interest;
        }
        self.borrowed.balance += interest;
    }

    pub fn update(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff_ms = nano_to_ms(timestamp - self.last_update_timestamp);
        if time_diff_ms > 0 {
            // update
            self.last_update_timestamp += ms_to_nano(time_diff_ms);
            self.compound(time_diff_ms);
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.borrowed.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        let mut cache = ASSETS.lock().unwrap();
        cache.get(token_id).cloned().unwrap_or_else(|| {
            let asset = self.assets.get(token_id).map(|o| {
                let mut asset: Asset = o.into();
                asset.update();
                asset
            });
            cache.insert(token_id.clone(), asset.clone());
            asset
        })
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, mut asset: Asset) {
        if asset.supplied.shares.0 == 0 && asset.supplied.balance > 0 {
            asset.reserved += asset.supplied.balance;
            asset.supplied.balance = 0;
        }
        assert!(
            asset.borrowed.shares.0 > 0 || asset.borrowed.balance == 0,
            "Borrowed invariant broken"
        );
        ASSETS
            .lock()
            .unwrap()
            .insert(token_id.clone(), Some(asset.clone()));
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset for a given token_id.
    pub fn get_asset(&self, token_id: AccountId) -> Option<AssetDetailedView> {
        self.internal_get_asset(&token_id)
            .map(|asset| self.asset_into_detailed_view(token_id, asset))
    }

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    pub fn get_assets(&self, token_ids: Vec<AccountId>) -> Vec<AssetDetailedView> {
        token_ids
            .into_iter()
            .filter_map(|token_id| {
                self.internal_get_asset(&token_id)
                    .map(|asset| self.asset_into_detailed_view(token_id, asset))
            })
            .collect()
    }

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    pub fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&key).unwrap().into();
                asset.update();
                (key, asset)
            })
            .collect()
    }

    pub fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let token_id = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&token_id).unwrap().into();
                asset.update();
                self.asset_into_detailed_view(token_id, asset)
            })
            .collect()
    }
}

'''
'''--- references/main/contract/src/asset_config.rs ---
use crate::*;

const MAX_POS: u32 = 10000;
const MAX_RATIO: u32 = 10000;

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

impl AssetConfig {
    pub fn assert_valid(&self) {
        assert!(self.reserve_ratio <= MAX_RATIO);
        assert!(self.target_utilization < MAX_POS);
        assert!(self.target_utilization_rate.0 <= self.max_utilization_rate.0);
    }

    pub fn get_rate(
        &self,
        borrowed_balance: Balance,
        total_supplied_balance: Balance,
    ) -> BigDecimal {
        if total_supplied_balance == 0 {
            BigDecimal::one()
        } else {
            let pos = BigDecimal::from(borrowed_balance).div_u128(total_supplied_balance);
            let target_utilization = BigDecimal::from_ratio(self.target_utilization);
            if pos < target_utilization {
                BigDecimal::one()
                    + pos * (BigDecimal::from(self.target_utilization_rate) - BigDecimal::one())
                        / target_utilization
            } else {
                BigDecimal::from(self.target_utilization_rate)
                    + (pos - target_utilization)
                        * (BigDecimal::from(self.max_utilization_rate)
                            - BigDecimal::from(self.target_utilization_rate))
                        / BigDecimal::from_ratio(MAX_POS - self.target_utilization)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ONE_NEAR: u128 = 10u128.pow(24);

    fn test_config() -> AssetConfig {
        AssetConfig {
            reserve_ratio: 2500,
            target_utilization: 8000,
            target_utilization_rate: 1000000000003593629036885046u128.into(),
            max_utilization_rate: 1000000000039724853136740579u128.into(),
            volatility_ratio: 6000,
            extra_decimals: 0,
            can_deposit: true,
            can_withdraw: true,
            can_use_as_collateral: true,
            can_borrow: true,
        }
    }

    #[test]
    fn test_get_rate_and_apr() {
        let config = test_config();
        let rate = config.get_rate(81 * ONE_NEAR, 100 * ONE_NEAR);
        println!("Rate: {}", rate);

        let apr = rate.pow(MS_PER_YEAR) - BigDecimal::one();
        println!("APR: {}", apr)
    }
}

'''
'''--- references/main/contract/src/asset_farm.rs ---
use crate::*;

static ASSET_FARMS: Lazy<Mutex<HashMap<FarmId, Option<AssetFarm>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

const NANOS_PER_DAY: Duration = 24 * 60 * 60 * 10u64.pow(9);

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
    /// Inactive rewards
    #[serde(skip_serializing)]
    pub inactive_rewards: LookupMap<TokenId, VAssetFarmReward>,
}

impl Clone for AssetFarm {
    fn clone(&self) -> Self {
        Self {
            block_timestamp: self.block_timestamp,
            rewards: self.rewards.clone(),
            inactive_rewards: BorshDeserialize::try_from_slice(
                &self.inactive_rewards.try_to_vec().unwrap(),
            )
            .unwrap(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VAssetFarmReward {
    Current(AssetFarmReward),
}

impl From<VAssetFarmReward> for AssetFarmReward {
    fn from(v: VAssetFarmReward) -> Self {
        match v {
            VAssetFarmReward::Current(c) => c,
        }
    }
}

impl From<AssetFarmReward> for VAssetFarmReward {
    fn from(c: AssetFarmReward) -> Self {
        VAssetFarmReward::Current(c)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Serialize, Default)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(skip)]
    pub reward_per_share: BigDecimal,
}

impl AssetFarm {
    pub fn update(&mut self, is_view: bool) {
        let block_timestamp = env::block_timestamp();
        if block_timestamp == self.block_timestamp {
            return;
        }
        let time_diff = block_timestamp - self.block_timestamp;
        self.block_timestamp = block_timestamp;
        let mut new_inactive_reward = vec![];
        for (token_id, reward) in self.rewards.iter_mut() {
            if reward.boosted_shares == 0 {
                continue;
            }
            let acquired_rewards = std::cmp::min(
                reward.remaining_rewards,
                u128_ratio(
                    reward.reward_per_day,
                    u128::from(time_diff),
                    u128::from(NANOS_PER_DAY),
                ),
            );
            reward.remaining_rewards -= acquired_rewards;
            reward.reward_per_share = reward.reward_per_share
                + BigDecimal::from(acquired_rewards) / BigDecimal::from(reward.boosted_shares);
            if reward.remaining_rewards == 0 {
                new_inactive_reward.push(token_id.clone());
            }
        }
        if !is_view {
            for token_id in new_inactive_reward {
                let reward = self.rewards.remove(&token_id).unwrap();
                self.internal_set_inactive_asset_farm_reward(&token_id, reward);
            }
        }
    }

    pub fn internal_get_inactive_asset_farm_reward(
        &self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.get(token_id).map(|o| o.into())
    }

    pub fn internal_remove_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.remove(token_id).map(|o| o.into())
    }

    pub fn internal_set_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
        asset_farm_reward: AssetFarmReward,
    ) {
        self.inactive_rewards
            .insert(token_id, &asset_farm_reward.into());
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAssetFarm {
    Current(AssetFarm),
}

impl From<VAssetFarm> for AssetFarm {
    fn from(v: VAssetFarm) -> Self {
        match v {
            VAssetFarm::Current(c) => c,
        }
    }
}

impl From<AssetFarm> for VAssetFarm {
    fn from(c: AssetFarm) -> Self {
        VAssetFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_unwrap_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> AssetFarm {
        self.internal_get_asset_farm(farm_id, is_view)
            .expect("Asset farm not found")
    }

    pub fn internal_get_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> Option<AssetFarm> {
        let mut cache = ASSET_FARMS.lock().unwrap();
        cache.get(farm_id).cloned().unwrap_or_else(|| {
            let asset_farm = self.asset_farms.get(farm_id).map(|v| {
                let mut asset_farm: AssetFarm = v.into();
                asset_farm.update(is_view);
                asset_farm
            });
            cache.insert(farm_id.clone(), asset_farm.clone());
            asset_farm
        })
    }

    pub fn internal_set_asset_farm(&mut self, farm_id: &FarmId, asset_farm: AssetFarm) {
        ASSET_FARMS
            .lock()
            .unwrap()
            .insert(farm_id.clone(), Some(asset_farm.clone()));
        self.asset_farms.insert(farm_id, &asset_farm.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset farm for a given farm ID.
    pub fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm> {
        self.internal_get_asset_farm(&farm_id, true)
    }

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    pub fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)> {
        farm_ids
            .into_iter()
            .filter_map(|farm_id| {
                self.internal_get_asset_farm(&farm_id, true)
                    .map(|asset_farm| (farm_id, asset_farm))
            })
            .collect()
    }

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    pub fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        let mut farm_ids = vec![];
        for index in from_index..std::cmp::min(keys.len(), limit) {
            let token_id = keys.get(index).unwrap();
            farm_ids.push(FarmId::Supplied(token_id.clone()));
            farm_ids.push(FarmId::Borrowed(token_id));
        }
        self.get_asset_farms(farm_ids)
    }
}

'''
'''--- references/main/contract/src/asset_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

impl Contract {
    pub fn asset_into_detailed_view(&self, token_id: TokenId, asset: Asset) -> AssetDetailedView {
        let farms = self
            .get_asset_farms(vec![
                FarmId::Supplied(token_id.clone()),
                FarmId::Borrowed(token_id.clone()),
            ])
            .into_iter()
            .map(|(farm_id, asset_farm)| AssetFarmView {
                farm_id,
                rewards: asset_farm.rewards,
            })
            .collect();
        let supply_apr = asset.get_supply_apr();
        let borrow_apr = asset.get_borrow_apr();
        let Asset {
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
        } = asset;
        AssetDetailedView {
            token_id,
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
            supply_apr,
            borrow_apr,
            farms,
        }
    }
}

'''
'''--- references/main/contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
#[cfg(not(target_arch = "wasm32"))]
use std::str::FromStr;

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

#[cfg(not(target_arch = "wasm32"))]
const PARSE_INT_ERROR: &'static str = "Parse int error";

#[cfg(not(target_arch = "wasm32"))]
impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<27}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(&int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Ok(Self::from_str(&s).map_err(|err| near_sdk::serde::de::Error::custom(err))?)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn from_balance_price(balance: Balance, price: &Price, extra_decimals: u8) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        let denominator_decimals = price.decimals + extra_decimals;
        if denominator_decimals > NUM_DECIMALS {
            Self(num / U384::exp10((denominator_decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - denominator_decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = MS_PER_YEAR;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- references/main/contract/src/config.rs ---
use crate::*;

/// Contract config
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: AccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: AccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.internal_config().owner_id,
            "Not an owner"
        );
    }
}

#[near_bindgen]
impl Contract {
    /// Returns the current config.
    pub fn get_config(&self) -> Config {
        self.internal_config()
    }

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_config(&mut self, config: Config) {
        assert_one_yocto();
        self.assert_owner();
        self.config.set(&config);
    }

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset(&mut self, token_id: AccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        assert!(self.asset_ids.insert(&token_id));
        self.internal_set_asset(&token_id, Asset::new(env::block_timestamp(), asset_config))
    }

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_asset(&mut self, token_id: AccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        let mut asset = self.internal_unwrap_asset(&token_id);
        asset.config = asset_config;
        self.internal_set_asset(&token_id, asset);
    }

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        reward_token_id: AccountId,
        new_reward_per_day: U128,
        new_booster_log_base: U128,
        reward_amount: U128,
    ) {
        assert_one_yocto();
        self.assert_owner();
        assert!(self.assets.contains_key(farm_id.get_token_id()));
        let reward_token_id: TokenId = reward_token_id.into();
        let mut reward_asset = self.internal_unwrap_asset(&reward_token_id);
        assert!(
            reward_asset.reserved >= reward_amount.0
                && reward_asset.available_amount() >= reward_amount.0,
            "Not enough reserved reward balance"
        );
        reward_asset.reserved -= reward_amount.0;
        self.internal_set_asset(&reward_token_id, reward_asset);
        let mut asset_farm = self
            .internal_get_asset_farm(&farm_id, false)
            .unwrap_or_else(|| AssetFarm {
                block_timestamp: env::block_timestamp(),
                rewards: HashMap::new(),
                inactive_rewards: LookupMap::new(StorageKey::InactiveAssetFarmRewards {
                    farm_id: farm_id.clone(),
                }),
            });

        let mut asset_farm_reward = asset_farm
            .rewards
            .remove(&reward_token_id)
            .or_else(|| asset_farm.internal_remove_inactive_asset_farm_reward(&reward_token_id))
            .unwrap_or_default();
        asset_farm_reward.reward_per_day = new_reward_per_day.into();
        asset_farm_reward.booster_log_base = new_booster_log_base.into();
        asset_farm_reward.remaining_rewards += reward_amount.0;
        asset_farm
            .rewards
            .insert(reward_token_id, asset_farm_reward);
        self.internal_set_asset_farm(&farm_id, asset_farm);
    }
}

'''
'''--- references/main/contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::{is_promise_success, serde_json, PromiseOrValue};

const GAS_FOR_FT_TRANSFER: Gas = Gas(Gas::ONE_TERA.0 * 10);
const GAS_FOR_AFTER_FT_TRANSFER: Gas = Gas(Gas::ONE_TERA.0 * 20);

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    DepositToReserve,
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_id = env::predecessor_account_id();
        let mut asset = self.internal_unwrap_asset(&token_id);
        assert!(
            asset.config.can_deposit,
            "Deposits for this asset are not enabled"
        );

        let amount = amount.0 * 10u128.pow(asset.config.extra_decimals as u32);

        // TODO: We need to be careful that only whitelisted tokens can call this method with a
        //     given set of actions. Or verify which actions are possible to do.
        let actions: Vec<Action> = if msg.is_empty() {
            vec![]
        } else {
            let token_receiver_msg: TokenReceiverMsg =
                serde_json::from_str(&msg).expect("Can't parse TokenReceiverMsg");
            match token_receiver_msg {
                TokenReceiverMsg::Execute { actions } => actions,
                TokenReceiverMsg::DepositToReserve => {
                    asset.reserved += amount;
                    self.internal_set_asset(&token_id, asset);
                    log!(
                        "Account {} deposits to reserve {} of {}",
                        sender_id,
                        amount,
                        token_id
                    );
                    return PromiseOrValue::Value(U128(0));
                }
            }
        };

        let mut account = self.internal_unwrap_account(&sender_id);
        account.add_affected_farm(FarmId::Supplied(token_id.clone()));
        self.internal_deposit(&mut account, &token_id, amount);
        log!("Account {} deposits {} of {}", sender_id, amount, token_id);
        self.internal_execute(&sender_id, &mut account, actions, Prices::new());
        self.internal_set_account(&sender_id, account);

        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_ft_transfer(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
        amount: Balance,
    ) -> Promise {
        let asset = self.internal_unwrap_asset(token_id);
        let ft_amount = amount / 10u128.pow(asset.config.extra_decimals as u32);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            ft_amount.into(),
            None,
            token_id.clone(),
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id.clone(),
            token_id.clone(),
            amount.into(),
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let mut account = self.internal_unwrap_account(&account_id);
            account.add_affected_farm(FarmId::Supplied(token_id.clone()));
            self.internal_deposit(&mut account, &token_id, amount.0);
            log!(
                "Withdrawal has failed: Account {} deposits {} of {}",
                account_id,
                amount.0,
                token_id
            );
            self.internal_set_account(&account_id, account);
        }
        promise_success
    }
}

'''
'''--- references/main/contract/src/lib.rs ---
mod account;
mod account_asset;
mod account_farm;
mod account_view;
mod actions;
mod asset;
mod asset_config;
mod asset_farm;
mod asset_view;
mod big_decimal;
mod config;
mod fungible_token;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod storage_tracker;
mod utils;

pub use crate::account::*;
pub use crate::account_asset::*;
pub use crate::account_farm::*;
pub use crate::account_view::*;
pub use crate::actions::*;
pub use crate::asset::*;
pub use crate::asset_config::*;
pub use crate::asset_farm::*;
pub use crate::asset_view::*;
pub use crate::big_decimal::*;
pub use crate::config::*;
pub use crate::fungible_token::*;
pub use crate::pool::*;
pub use crate::price_receiver::*;
pub use crate::prices::*;
pub use crate::storage::*;
use crate::storage_tracker::*;
use crate::utils::*;

use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp,
};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountAssets { account_id: AccountId },
    AccountFarms { account_id: AccountId },
    Storage,
    Assets,
    AssetFarms,
    InactiveAssetFarmRewards { farm_id: FarmId },
    AssetIds,
    Config,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, VAccount>,
    pub storage: LookupMap<AccountId, VStorage>,
    pub assets: LookupMap<TokenId, VAsset>,
    pub asset_farms: LookupMap<FarmId, VAssetFarm>,
    pub asset_ids: UnorderedSet<TokenId>,
    pub config: LazyOption<Config>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKey::Accounts),
            storage: LookupMap::new(StorageKey::Storage),
            assets: LookupMap::new(StorageKey::Assets),
            asset_farms: LookupMap::new(StorageKey::AssetFarms),
            asset_ids: UnorderedSet::new(StorageKey::AssetIds),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
        }
    }
}

'''
'''--- references/main/contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn shares_to_amount(&self, shares: Shares, round_up: bool) -> Balance {
        if shares.0 >= self.balance || shares.0 == self.shares.0 {
            self.balance
        } else {
            let extra = if round_up {
                U256::from(self.shares.0 - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.balance) * U256::from(shares.0) + extra) / U256::from(self.shares.0))
                .as_u128()
        }
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- references/main/contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let mut account = self.internal_unwrap_account(&sender_id);
        self.internal_execute(&sender_id, &mut account, actions, data.into());
        self.internal_set_account(&sender_id, account);
    }
}

'''
'''--- references/main/contract/src/prices.rs ---
use crate::*;
use std::convert::TryFrom;

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    let token_id =
                        AccountId::try_from(asset_id).expect("Asset is not a valid token ID");
                    price.map(|price| (token_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- references/main/contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 10000 bytes
const MIN_STORAGE_BALANCE: Balance = 10000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub storage_tracker: StorageTracker,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VStorage {
    Current(Storage),
}

impl From<VStorage> for Storage {
    fn from(v: VStorage) -> Self {
        match v {
            VStorage::Current(c) => c,
        }
    }
}

impl From<Storage> for VStorage {
    fn from(c: Storage) -> Self {
        VStorage::Current(c)
    }
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            storage_tracker: Default::default(),
        }
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        if storage.storage_tracker.bytes_added >= storage.storage_tracker.bytes_released {
            let extra_bytes_used =
                storage.storage_tracker.bytes_added - storage.storage_tracker.bytes_released;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released =
                storage.storage_tracker.bytes_released - storage.storage_tracker.bytes_added;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        storage.storage_tracker.bytes_released = 0;
        storage.storage_tracker.bytes_added = 0;
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }

            let mut account = Account::new(&account_id);
            // HACK: Tracking the extra bytes required to store the storage object itself and
            // recording this under account storage tracker. It'll be accounted when saving the
            // account below.
            account.storage_tracker.start();
            self.internal_set_storage(&account_id, storage);
            account.storage_tracker.stop();
            self.internal_set_account(&account_id, account);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic_str("The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic_str(&format!("The account {} is not registered", &account_id));
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic_str("The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(&account_id)
    }
}

'''
'''--- references/main/contract/src/storage_tracker.rs ---
use crate::*;
use near_sdk::StorageUsage;

/// A helper object that tracks changes in state storage.
#[derive(Default)]
pub struct StorageTracker {
    pub bytes_added: StorageUsage,
    pub bytes_released: StorageUsage,
    pub initial_storage_usage: Option<StorageUsage>,
}

/// Safety guard for the storage tracker.
impl Drop for StorageTracker {
    fn drop(&mut self) {
        assert!(self.is_empty(), "Bug, non-tracked storage change");
    }
}

impl StorageTracker {
    /// Starts tracking the state storage changes.
    pub fn start(&mut self) {
        assert!(
            self.initial_storage_usage
                .replace(env::storage_usage())
                .is_none(),
            "The storage tracker is already tracking"
        );
    }

    /// Stop tracking the state storage changes and record changes in bytes.
    pub fn stop(&mut self) {
        let initial_storage_usage = self
            .initial_storage_usage
            .take()
            .expect("The storage tracker wasn't tracking");
        let storage_usage = env::storage_usage();
        if storage_usage >= initial_storage_usage {
            self.bytes_added += storage_usage - initial_storage_usage;
        } else {
            self.bytes_released += initial_storage_usage - storage_usage;
        }
    }

    /// Consumes the other storage tracker changes.
    pub fn consume(&mut self, other: &mut StorageTracker) {
        self.bytes_added += other.bytes_added;
        other.bytes_added = 0;
        self.bytes_released = other.bytes_released;
        other.bytes_released = 0;
        assert!(
            other.initial_storage_usage.is_none(),
            "Can't merge storage tracker that is tracking storage"
        );
    }

    /// Returns true if no bytes is added or released, and the tracker is not active.
    pub fn is_empty(&self) -> bool {
        self.bytes_added == 0 && self.bytes_released == 0 && self.initial_storage_usage.is_none()
    }
}

'''
'''--- references/main/contract/src/utils.rs ---
use crate::*;

pub(crate) type TokenId = AccountId;

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

pub(crate) fn nano_to_ms(nano: u64) -> u64 {
    nano / 10u64.pow(6)
}

pub(crate) fn ms_to_nano(ms: u64) -> u64 {
    ms * 10u64.pow(6)
}

pub(crate) fn u128_ratio(a: u128, num: u128, denom: u128) -> Balance {
    (U256::from(a) * U256::from(num) / U256::from(denom)).as_u128()
}

pub(crate) fn ratio(balance: Balance, r: u32) -> Balance {
    assert!(r <= MAX_RATIO);
    u128_ratio(balance, u128::from(r), u128::from(MAX_RATIO))
}

'''
'''--- references/main/scripts/add_farms.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Adding the farms $LG<<<<<<<<<<<<<<$NC"

for TOKEN_ID in $DAI_TOKEN_ID $USDT_TOKEN_ID $WETH_TOKEN_ID $WNEAR_TOKEN_ID
do

  echo -e "$LG>>>>>>>>>>>>>>$TC Adding farms for $TOKEN_ID $LG<<<<<<<<<<<<<<$NC"

  near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
    "farm_id": {
      "Supplied": "'$TOKEN_ID'"
    },
    "reward_token_id": "'$BOOSTER_TOKEN_ID'",
    "new_reward_per_day": "100000000000000000000",
    "new_booster_log_base": "100000000000000000000",
    "reward_amount": "700000000000000000000"
  }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$BOOSTER_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000",
      "new_booster_log_base": "100000000000000000000",
      "reward_amount": "1750000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Supplied": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "100000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "700000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "1750000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

done

near view $CONTRACT_ID get_asset_farms_paged

'''
'''--- references/main/scripts/apr_to_rate.py ---
#!/usr/bin/env python3

import sys
from decimal import *

getcontext().prec = 60

n = 31536000000
input_apr = Decimal(sys.argv[1])
print("Input APR: %s%%" % (input_apr,))
print("n: %d" % (n,))

res = (((input_apr / Decimal(100)) + Decimal(1)) ** (Decimal(1) / Decimal(n)))
print("R: %s" % (res,))
print("R ** n: %s" % (res ** n,))

round_res = round(res * (Decimal(10) ** Decimal(27)))
print("rate: %s" % (round_res, ))

'''
'''--- references/main/scripts/create_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

mv -f neardev/dev-account neardev/dev-account-old 2> /dev/null || true

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create a user's account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
export ACCOUNT_ID="$(cat neardev/dev-account)"

mv -f neardev/dev-account-old neardev/dev-account 2> /dev/null || true

scripts/mint_to_account.sh

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export ACCOUNT_ID=$ACCOUNT_ID"

'''
'''--- references/main/scripts/dev_deploy.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create an owner account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
OWNER_ID="$(cat neardev/dev-account)"

ORACLE_ID="priceoracle.testnet"

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy the main contract $LG<<<<<<<<<<<<<<$NC"
near dev-deploy -f res/burrowland.wasm
CONTRACT_ID="$(cat neardev/dev-account)"

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing Booster token $LG<<<<<<<<<<<<<<$NC"
BOOSTER_TOKEN_ID="ref.fakes.testnet"

near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing the main contract $LG<<<<<<<<<<<<<<$NC"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wETH $LG<<<<<<<<<<<<<<$NC"
WETH_TOKEN_ID="weth.fakes.testnet"

near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing DAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing USDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$BOOSTER_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": false,
    "can_borrow": false
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "120000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export WETH_TOKEN_ID=$WETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- references/main/scripts/mint_to_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to fund the account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
TMP_ACCOUNT="$(cat neardev/dev-account)"
echo -e "$LG>>>>>>>>>>>>>>$TC Funding the account $LG<<<<<<<<<<<<<<$NC"
near delete $TMP_ACCOUNT $ACCOUNT_ID

echo -e "$LG>>>>>>>>>>>>>>$TC Registering storage for the user: $LG<<<<<<<<<<<<<<$NC"
# near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDC_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the user: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 100000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 10 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 wNEAR (wrapped) $NC"
#near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "100000000000000000000000"
#}'
#near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "10000000000000000000"
#}'
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $USDC_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID near_deposit '{}' --amount=100

'''
'''--- references/main/scripts/readme_test.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'

near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
sleep 1

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'

near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

'''
'''--- references/main/scripts/testnet_deploy.sh ---
#!/bin/bash
set -e

MASTER_ACCOUNT=$1
TIME=$(date +%s)

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to fund main account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
TMP_ACCOUNT="$(cat neardev/dev-account)"

MAIN="${TIME}.${MASTER_ACCOUNT}"

echo -e "$LG>>>>>>>>>>>>>>$TC Creating main account: $MAIN $LG<<<<<<<<<<<<<<$NC"
near create-account $MAIN --masterAccount=$MASTER_ACCOUNT --initialBalance=0.01

echo -e "$LG>>>>>>>>>>>>>>$TC Funding main account: $MAIN $LG<<<<<<<<<<<<<<$NC"
near delete $TMP_ACCOUNT $MAIN

OWNER_ID="owner.$MAIN"
echo -e "$LG>>>>>>>>>>>>>>$TC Creating owner account: $OWNER_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $OWNER_ID --masterAccount=$MAIN --initialBalance=130

BOOSTER_TOKEN_ID="token.$MAIN"
echo -e "$LG>>>>>>>>>>>>>>$TC Creating and deploying booster token: $BOOSTER_TOKEN_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $BOOSTER_TOKEN_ID --masterAccount=$MAIN --initialBalance=3
near deploy $BOOSTER_TOKEN_ID res/fungible_token.wasm new '{
   "owner_id": "'$OWNER_ID'",
   "total_supply": "1000000000000000000000000000",
   "metadata": {
       "spec": "ft-1.0.0",
       "name": "Booster Token ('$TIME')",
       "symbol": "BOOSTER-'$TIME'",
       "decimals": 18
   }
}'

ORACLE_ID="priceoracle.testnet"

CONTRACT_ID="contract.$MAIN"

echo -e "$LG>>>>>>>>>>>>>>$TC Creating and deploying contract account: $CONTRACT_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $CONTRACT_ID --masterAccount=$MAIN --initialBalance=10
near deploy $CONTRACT_ID res/burrowland.wasm new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Booster token storage for contract $LG<<<<<<<<<<<<<<$NC"
near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nETH $LG<<<<<<<<<<<<<<$NC"
NETH_TOKEN_ID="aurora"

near call $NETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.0125
near call $NETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.0125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nDAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nUSDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nUSDC $LG<<<<<<<<<<<<<<$NC"
USDC_TOKEN_ID="usdc.fakes.testnet"

near call $USDC_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDC_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
#near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
#  "token_id": "'$BOOSTER_TOKEN_ID'",
#  "asset_config": {
#    "reserve_ratio": 2500,
#    "target_utilization": 8000,
#    "target_utilization_rate": "1000000000008319516250272147",
#    "max_utilization_rate": "1000000000039724853136740579",
#    "volatility_ratio": 2000,
#    "extra_decimals": 0,
#    "can_deposit": true,
#    "can_withdraw": true,
#    "can_use_as_collateral": false,
#    "can_borrow": false
#  }
#}' --amount=$ONE_YOCTO --gas=$GAS

# nETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$NETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDC APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDC by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDC_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 12 nETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
#near call $NETH_TOKEN_ID --accountId=$OWNER_ID mint '{
#  "account_id": "'$OWNER_ID'",
#  "amount": "12000000000000000000"
#}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'
near call $USDC_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
#near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
#  "receiver_id": "'$CONTRACT_ID'",
#  "amount": "20000000000000000000000",
#  "msg": "\"DepositToReserve\""
#}' --amount=$ONE_YOCTO --gas=$GAS

near call $NETH_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDC_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Registering the owner: $LG<<<<<<<<<<<<<<$NC"

near call $CONTRACT_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.1

echo -e "$LG>>>>>>>>>>>>>>$TC Adding regular deposits from the owner: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 1 wNEAR $NC"

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "100000000000000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "100000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDC_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1000000000000000000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export NETH_TOKEN_ID=$NETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export USDC_TOKEN_ID=$USDC_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- references/main/sim-tests/babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- references/main/sim-tests/config.js ---
module.exports = {
    API_SERVER_URL: "http://78.47.91.25:3000",
    CREDENTIALS_DIR: ".near-credentials/testnet/",
    FRACTION_DIGITS: 5,
    GAS: 100000000000000,
}

'''
'''--- references/main/sim-tests/jest.config.js ---
module.exports = {
    testEnvironment: "node",
    testTimeout: 900000,
    globals: {
        Uint8Array: Uint8Array,
    },
};
'''
'''--- references/main/sim-tests/package.json ---
{
  "name": "sim-tests",
  "version": "1.0.0",
  "scripts": {
    "test": "jest rest-api.test.js --useStderr --verbose false",
    "test:accounts": "jest rest-api.test.js -t 'Accounts' --useStderr --verbose false",
    "test:collateral": "jest rest-api.test.js -t 'Collateral' --useStderr --verbose false",
    "test:borrow": "jest rest-api.test.js -t 'Borrow' --useStderr --verbose false",
    "test:withdraw": "jest rest-api.test.js -t 'Withdraw' --useStderr --verbose false",
    "test:repay": "jest rest-api.test.js -t 'Repay' --useStderr --verbose false",
    "test:decrease": "jest rest-api.test.js -t 'Decrease collateral' --useStderr --verbose false",
    "test:liquidate": "jest rest-api.test.js -t 'Liquidate' --useStderr --verbose false"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.6.0",
    "node-fetch": "^2.6.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.1.1",
    "near-api-js": "^0.41.0",
    "react": "~17.0.1",
    "react-dom": "~17.0.1",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  }
}

'''
'''--- references/main/sim-tests/rest-api-dummy-data.test.js ---
/* export REACT_CONTRACT_ID=dev-1627393733545-88687685295664 */
import 'regenerator-runtime/runtime'

const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const contract_id  = process.env.CONTRACT_NAME;

const near = new contract(process.env.CONTRACT_NAME);

const MIN_TOKENS = 20;

describe("Contract set", () => {
    test("Contract set: " + process.env.CONTRACT_NAME, async () => {
        expect(process.env.CONTRACT_NAME).not.toBe(undefined)
    });

    test('Accounts has enough funds', async () => {
        const contract_wallet_balance = await near.accountNearBalance(contract_id);
        expect(contract_wallet_balance).toBeGreaterThan(MIN_TOKENS);
    });
});

describe("Insert dummy data", () => {
    console.log(contract_id)
    test('Insert players', async () => {
        for (let i = 500; i <= 600; i++) {
            let account = `account_${i}.testnet`;
            const start_game = await near.call("start_game_for_account_id",
                {quiz_id: 36, account_id: account},
                {account_id: contract_id});
            expect(start_game.type).not.toBe('FunctionCallError');
        }
    });
});

'''
'''--- references/main/sim-tests/rest-api-test-utils.js ---
const utils = require('./utils');
const config = require("./config");

function contract(contract_id) {
    this.contract_id = contract_id;
}

contract.prototype.deploy = async function (contractName) {
    const body = {
        contract: contractName,
        account_id: this.contract_id,
        private_key: await utils.getPrivateKey(this.contract_id),
    };

    return await utils.PostResponse("deploy", body);
};

contract.prototype.view = async function (method, params, options) {
    const body = {
        method: method,
        params: params,
        contract: this.contract_id,
        disabled_cache: true
    };

    return await utils.PostResponse("view", body, options);
};

contract.prototype.viewNearBalance = async function (method, params, options) {
    options = options || {};
    options.convertToNear = true;
    return await this.view(method, params, options);
};

contract.prototype.viewFTe18Balance = async function (method, params, options) {
    options = options || {};
    options.convertFromFTe18 = true;
    return await this.view(method, params, options);
};

contract.prototype.accountNearBalance = async function (account_id, delay) {
    delay = delay || 1000;
    await timeout(delay);

    return await utils.GetResponse("balance", account_id, {convertToNear: true})
        .catch(e => console.error("AccountNearBalance error for " + JSON.stringify(account_id) + ". Error: " + e.message));
};

contract.prototype.call = async function (method, params, options) {
    options.attached_gas = options.gas || config.GAS;
    options.attached_tokens = options.tokens || 0;
    options.private_key = options.private_key || await utils.getPrivateKey(options.account_id);
    options.log_errors = options.log_errors || false;
    options.return_value = options.return_value || false;

    const body = {
        ...options,
        method: method,
        params: params,
        contract: this.contract_id,
    };

    return await utils.PostResponse("call", body, options)
        .catch(e => {
            if(e.message.includes("Unexpected token < in JSON at position 0"))
                console.error("RPC/JSON Error: " + e.message);
            else
                console.error("Call error for " + JSON.stringify(body) + ". Error: " + e.message)
        });
};

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = contract;

'''
'''--- references/main/sim-tests/rest-api.test.js ---
import 'regenerator-runtime/runtime'

/*
export NEAR_ENV=testnet
export OWNER_ID=dev-1634805788173-90290670203248
export ORACLE_ID=priceoracle.testnet
export CONTRACT_ID=dev-1634805794596-68676200580325
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export ACCOUNT_ID=dev-1634809261182-39559532470451

 */
const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const alice = process.env.ACCOUNT_ID;
const contract_id = process.env.CONTRACT_ID;
const usdt_contract_id = process.env.USDT_TOKEN_ID;
const dai_contract_id = process.env.DAI_TOKEN_ID;
const oracle_contract_id = process.env.ORACLE_ID;

const bob = "place.testnet";

const burrow = new contract(contract_id);
const usdt = new contract(usdt_contract_id);
const dai = new contract(dai_contract_id);
const oracle = new contract(oracle_contract_id);

describe("Contract set", () => {
    test("Contract is not null " + contract_id, async () => {
        expect(contract_id).not.toBe(undefined)
    });

    test("USDT Contract is not null " + usdt_contract_id, async () => {
        expect(usdt_contract_id).not.toBe(undefined)
    });

    test("DAI Contract is not null " + usdt_contract_id, async () => {
        expect(dai_contract_id).not.toBe(undefined)
    });

    test("Oracle Contract is not null " + alice, async () => {
        expect(oracle_contract_id).not.toBe(undefined)
    });

    test("Alice Account is not null " + alice, async () => {
        expect(alice).not.toBe(undefined)
    });

    test('Alice has enough funds', async () => {
        const alice_wallet_balance = await burrow.accountNearBalance(alice, 0);
        expect(alice_wallet_balance).toBeGreaterThan(20);
    });
});

describe("Accounts", () => {
    test('Register account by paying for storage, deposit tokens', async () => {
        const storage_deposit = await burrow.call("storage_deposit",
            {}, {
                account_id: alice,
                tokens: utils.ConvertToNear(0.1),
                log_errors: true
            });
        expect(storage_deposit.is_error).toBeFalsy();

        const account_initial = await burrow.view("get_account",
            {account_id: alice}, {});

        // make ft deposit and check balance/shares
        const deposit_1 = 5;
        const asset_1 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});

        const ft_transfer_1 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_1.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        expect(account_1.account_id).toBe(alice);
        expect(account_1.supplied.length).toBeGreaterThan(0);

        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_1.length).toBe(1);

        const usdt_supplied_initial = account_initial.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.balance) + deposit_1);
        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.shares) + deposit_1);

        const asset_2 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});
        expect(utils.ConvertFromFTe18(asset_2.supplied.shares)
            - utils.ConvertFromFTe18(asset_1.supplied.shares)).toBe(5)

        const deposit_2 = 3;
        const ft_transfer_2 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_2.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_2.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance) + deposit_2);
        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares) + deposit_2);

        const deposit_3 = 0;
        const ft_transfer_3 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_3.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_3.is_error).toBeTruthy();

        const account_3 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_3 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_3.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Collateral", () => {
    test('Provide token as a collateral', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        const execute = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: usdt_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_collateral_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].balance)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].shares)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].shares));

        const execute_wrong_account = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {"token_id": usdt_contract_id}
                }]
            },
            {account_id: bob, tokens: 1})
        expect(execute_wrong_account.is_error).toBeTruthy();

        const execute_without_supply = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {
                        token_id: usdt_contract_id
                    }
                }]
            },
            {account_id: alice, tokens: 1})
        expect(execute_without_supply.is_error).toBeTruthy();
    });
});

describe("Borrow", () => {
    test('Borrow a token', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: 'dai.fakes.testnet',
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

describe("Withdraw", () => {
    test('Withdrawing the asset', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const ft_balance_1 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        const withdraw = await burrow.call("execute",
            {
                actions: [{
                    Withdraw: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(withdraw.is_error).toBeFalsy();

        const ft_balance_2 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        expect(ft_balance_2 - ft_balance_1)
            .toBeCloseTo(utils.ConvertFromFTe18(account_1.supplied.balance));

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.supplied.length).toBe(0);
    });
});

describe("Repay", () => {
    test('Deposit asset and repay it in one call', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const repay_amount_1 = 5;

        const ft_transfer_1 = await dai.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: repay_amount_1.toString() + "000000000000000000",
            msg: JSON.stringify({
                Execute: {
                    actions: [
                        {
                            Repay: {
                                token_id: 'dai.fakes.testnet'
                            }
                        }
                    ]
                }
            })
        }, {account_id: alice, tokens: 1, log_errors: true})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(0);

        expect(utils.ConvertFromFTe18(account_1.borrowed[0].balance) +
            utils.ConvertFromFTe18(account_2.supplied[0].balance)).toBeCloseTo(repay_amount_1);
    });
});

describe("Decrease collateral", () => {
    test('Decreasing collateral without providing prices', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        const decrease_collateral_wrong_asset = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(decrease_collateral_wrong_asset.is_error).toBeTruthy();

        const decrease_collateral = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'usdt.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account", {account_id: alice}, {});
        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(usdt_collateral_2.length).toBe(0);
        expect(usdt_supplied_2.length).toBeGreaterThan(0);
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Liquidate", () => {
    test('Liquidate', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        console.log(account_1);

        const increaseCollateral = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: dai_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(increaseCollateral.is_error).toBeFalsy();

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: dai_contract_id,
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const liquidate = await burrow.call("execute",
            {
                actions: [{
                    Liquidate: {
                        token_id: 'usdt.fakes.testnet',
                        in_assets: {
                            token_id: 'dai.fakes.testnet',
                            max_amount: borrow_amount_1.toString() + "000000000000000000"
                        }
                    }
                }]
            },
            {
                account_id: bob,
                tokens: 1,
                log_errors: true
            })
        expect(liquidate.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

'''
'''--- references/main/sim-tests/utils.js ---
const {utils} = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const {BN} = require('bn.js');
const fs = require('fs');
const fetch = require("node-fetch");
const config = require("./config");

module.exports = {
    ConvertYoctoNear: (value, frac_digits) => {
        try {
            return utils.format.formatNearAmount(value, frac_digits).replace(",", "");
        } catch (e) {
            console.log("ConvertYoctoNear error, value: " + value);
            console.log(e);
        }
    },

    ConvertFromFTe18: (value) => {
        if(value === undefined)
            return 0;

        return Number(Math.round(value / 100000000000000) / 10000);
    },

    ConvertToNear: (amount) => {
        return new BN(Math.round(amount * 100000000)).mul(new BN("10000000000000000")).toString();
    },

    RoundFloat: (amount) => {
        return +Number.parseFloat(amount).toFixed(config.FRACTION_DIGITS);
    },

    getPrivateKey: async (accountId) => {
        const credentialsPath = path.join(homedir, config.CREDENTIALS_DIR);
        const keyPath = credentialsPath + accountId + '.json';
        try {
            const credentials = JSON.parse(fs.readFileSync(keyPath));
            return (credentials.private_key);
        } catch (e) {
            console.error("Key not found for account " + keyPath + ". Error: " + e.message);
        }
    },

    PostResponse: async (operation, body, options) => {
        const response = fetch(`${config.API_SERVER_URL}/${operation}`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-type': 'application/json; charset=UTF-8'
            }
        })
            .then(res => {
                return res.text().then(response => {
                    if (options && options.log_errors) {
                        const response_json = JSON.parse(response);
                        if (response_json && response_json.error) {
                            const error = JSON.parse(response_json.error);
                            console.log(`Request: ${body.method}`);
                            console.log(`ERROR: ${error.type}: ${JSON.stringify(error.kind)}`);
                        }
                    }

                    if (options && (options.convertToNear || options.convertFromFTe18)) {
                        if (isNaN(response))
                            throw new Error(`Illegal balance value. Request: ${JSON.stringify(body)}. Response: ${response}`);

                        if (options.convertFromFTe18)
                            return module.exports.RoundFloat(module.exports.ConvertFromFTe18(response, config.FRACTION_DIGITS));
                        else
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(response, config.FRACTION_DIGITS));
                    } else {
                        try {
                            let json = JSON.parse(response);
                            json.is_error = json.error && JSON.parse(json.error).hasOwnProperty('kind');
                            try {
                                if (options.return_value)
                                    return Buffer.from( json.status.SuccessValue, 'base64').toString();
                                else
                                    return (json);
                            } catch (e) {
                                throw new Error("PostResponse error for " + operation + " request " + JSON.stringify(body) + ". Error: " + e.message);
                            }
                        } catch (e) {
                            return response;
                        }
                    }
                });

            });
        return response;
    },

    GetResponse: async (operation, value, options) => {
        const response = await fetch(`${config.API_SERVER_URL}/${operation}/${value}`, {
            method: 'GET'
        })
            .then(res => {
                if (options && options.convertToNear) {
                    return res.text().then(value => {
                        try {
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(value, config.FRACTION_DIGITS));
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                } else {
                    return res.json().then(json => {
                        try {
                            if (json.error)
                                return (JSON.parse(json.error));
                            else
                                return (json);
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                }
            });

        return response;
    },

    IsJson: (item) => {
        item = typeof item !== "string"
            ? JSON.stringify(item)
            : item;

        try {
            item = JSON.parse(item);
        } catch (e) {
            return false;
        }

        if (typeof item === "object" && item !== null) {
            return true;
        }

        return false;
    }
};

'''
'''--- references/main/test-oracle/Cargo.toml ---
[package]
name = "test-oracle"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
common = { path = "../common/" }

'''
'''--- references/main/test-oracle/src/lib.rs ---
use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Gas, Promise};

const GAS_FOR_PROMISE: Gas = Gas(Gas::ONE_TERA.0 * 10);

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: AccountId,
        price_data: PriceData,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id,
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

'''
'''--- references/main/tests/basic.rs ---
mod setup;

use crate::setup::*;

use contract::{BigDecimal, MS_PER_YEAR};

const SEC_PER_YEAR: u32 = (MS_PER_YEAR / 1000) as u32;

#[macro_use]
extern crate approx;

#[test]
fn test_init_env() {
    let e = Env::init();
    let _tokens = Tokens::init(&e);
    let _users = Users::init(&e);
}

#[test]
fn test_mint_tokens() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
}

#[test]
fn test_dev_setup() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.reserved, d(10000, 24));
}

#[test]
fn test_supply() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.contract_ft_transfer_call(&tokens.wnear, &users.alice, amount, "")
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
    assert_eq!(account.supplied[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_supply_to_collateral() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, amount)
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.collateral[0].balance, amount);
    assert_eq!(account.collateral[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_borrow() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, borrow_amount);
    assert!(asset.supply_apr > BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, borrow_amount);
    assert_eq!(account.supplied[0].token_id, tokens.ndai.account_id());
    assert!(account.supplied[0].apr > BigDecimal::zero());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_borrow_and_withdraw() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, 0);
    assert_eq!(asset.supply_apr, BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_interest() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(10000, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(8000, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert_relative_eq!(asset.borrow_apr.f64(), 0.08f64);

    e.skip_time(SEC_PER_YEAR);

    let expected_borrow_amount = borrow_amount * 108 / 100;

    let asset = e.get_asset(&tokens.ndai);
    assert_relative_eq!(asset.borrowed.balance as f64, expected_borrow_amount as f64);

    let account = e.get_account(&users.alice);
    assert_relative_eq!(
        account.borrowed[0].balance as f64,
        expected_borrow_amount as f64
    );
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
}

'''
'''--- references/main/tests/setup/mod.rs ---
#![allow(dead_code)]

use common::{AssetOptionalPrice, Price, PriceData, ONE_YOCTO};
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{env, serde_json, AccountId, Balance, Gas, Timestamp};
use near_sdk_sim::runtime::GenesisConfig;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

pub use contract::{
    AccountDetailedView, Action, AssetAmount, AssetConfig, AssetDetailedView, Config,
    ContractContract as BurrowlandContract, PriceReceiverMsg, TokenReceiverMsg,
};
use test_oracle::ContractContract as OracleContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    BURROWLAND_WASM_BYTES => "res/burrowland.wasm",
    BURROWLAND_0_1_0_WASM_BYTES => "res/burrowland_0.1.0.wasm",
    TEST_ORACLE_WASM_BYTES => "res/test_oracle.wasm",

    FUNGIBLE_TOKEN_WASM_BYTES => "res/fungible_token.wasm",
}

pub fn burrowland_0_1_0_wasm_bytes() -> &'static [u8] {
    &BURROWLAND_0_1_0_WASM_BYTES
}

pub const NEAR: &str = "near";
pub const ORACLE_ID: &str = "oracle.near";
pub const BURROWLAND_ID: &str = "burrowland.near";
pub const BOOSTER_TOKEN_ID: &str = "token.burrowland.near";
pub const OWNER_ID: &str = "owner.near";

pub const DEFAULT_GAS: Gas = Gas(Gas::ONE_TERA.0 * 15);
pub const MAX_GAS: Gas = Gas(Gas::ONE_TERA.0 * 300);
pub const BOOSTER_TOKEN_DECIMALS: u8 = 18;
pub const BOOSTER_TOKEN_TOTAL_SUPPLY: Balance =
    1_000_000_000 * 10u128.pow(BOOSTER_TOKEN_DECIMALS as _);

pub const DEPOSIT_TO_RESERVE: &str = "\"DepositToReserve\"";

pub struct Env {
    pub root: UserAccount,
    pub near: UserAccount,
    pub owner: UserAccount,
    pub oracle: ContractAccount<OracleContract>,
    pub contract: ContractAccount<BurrowlandContract>,
    pub booster_token: UserAccount,
}

pub struct Tokens {
    pub wnear: UserAccount,
    pub neth: UserAccount,
    pub ndai: UserAccount,
    pub nusdt: UserAccount,
    pub nusdc: UserAccount,
}

pub struct Users {
    pub alice: UserAccount,
    pub bob: UserAccount,
    pub charlie: UserAccount,
    pub dude: UserAccount,
    pub eve: UserAccount,
}

pub fn storage_deposit(
    user: &UserAccount,
    contract_id: &AccountId,
    account_id: &AccountId,
    attached_deposit: Balance,
) {
    user.call(
        contract_id.clone(),
        "storage_deposit",
        &json!({ "account_id": account_id }).to_string().into_bytes(),
        DEFAULT_GAS.0,
        attached_deposit,
    )
    .assert_success();
}

pub fn ft_storage_deposit(
    user: &UserAccount,
    token_account_id: &AccountId,
    account_id: &AccountId,
) {
    storage_deposit(
        user,
        token_account_id,
        account_id,
        125 * env::STORAGE_PRICE_PER_BYTE,
    );
}

pub fn to_nano(timestamp: u32) -> Timestamp {
    Timestamp::from(timestamp) * 10u64.pow(9)
}

impl Env {
    pub fn init_with_contract(contract_bytes: &[u8]) -> Self {
        let mut genesis_config = GenesisConfig::default();
        genesis_config.block_prod_time = 0;
        let root = init_simulator(Some(genesis_config));
        let near = root.create_user(
            AccountId::new_unchecked(NEAR.to_string()),
            to_yocto("1000000"),
        );
        let owner = near.create_user(
            AccountId::new_unchecked(OWNER_ID.to_string()),
            to_yocto("10000"),
        );

        let oracle = deploy!(
            contract: OracleContract,
            contract_id: ORACLE_ID.to_string(),
            bytes: &TEST_ORACLE_WASM_BYTES,
            signer_account: near,
            deposit: to_yocto("10")
        );

        let contract = deploy!(
            contract: BurrowlandContract,
            contract_id: BURROWLAND_ID.to_string(),
            bytes: &contract_bytes,
            signer_account: near,
            deposit: to_yocto("20"),
            gas: DEFAULT_GAS.0,
            init_method: new(
                Config {
                    oracle_account_id: a(ORACLE_ID),
                    owner_id: owner.account_id(),
                    booster_token_id: a(BOOSTER_TOKEN_ID),
                    booster_decimals: BOOSTER_TOKEN_DECIMALS,
                }
            )
        );

        let booster_token = contract.user_account.deploy_and_init(
            &FUNGIBLE_TOKEN_WASM_BYTES,
            a(BOOSTER_TOKEN_ID),
            "new",
            &json!({
                "owner_id": owner.account_id(),
                "total_supply": U128::from(BOOSTER_TOKEN_TOTAL_SUPPLY),
                "metadata": FungibleTokenMetadata {
                    spec: FT_METADATA_SPEC.to_string(),
                    name: "Booster Token".to_string(),
                    symbol: "BOOSTER".to_string(),
                    icon: None,
                    reference: None,
                    reference_hash: None,
                    decimals: BOOSTER_TOKEN_DECIMALS,
                }
            })
            .to_string()
            .into_bytes(),
            to_yocto("10"),
            DEFAULT_GAS.0,
        );

        ft_storage_deposit(&owner, &a(BOOSTER_TOKEN_ID), &a(BURROWLAND_ID));

        Self {
            root,
            near,
            owner,
            contract,
            oracle,
            booster_token,
        }
    }

    pub fn init() -> Self {
        Self::init_with_contract(&BURROWLAND_WASM_BYTES)
    }

    pub fn redeploy_latest(&self) {
        self.contract
            .user_account
            .create_transaction(a(BURROWLAND_ID))
            .deploy_contract(BURROWLAND_WASM_BYTES.to_vec())
            .submit()
            .assert_success();
    }

    pub fn setup_assets(&self, tokens: &Tokens) {
        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    self.booster_token.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000008319516250272147),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 2000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: false,
                        can_borrow: false,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.neth.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000001547125956667610),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.ndai.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdt.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdc.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.wnear.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000003593629036885046),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();
    }

    pub fn deposit_reserves(&self, tokens: &Tokens) {
        self.contract_ft_transfer_call(
            &tokens.wnear,
            &self.owner,
            d(10000, 24),
            DEPOSIT_TO_RESERVE,
        );
        self.contract_ft_transfer_call(&tokens.neth, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.ndai, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdt, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdc, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(
            &self.booster_token,
            &self.owner,
            d(10000, 18),
            DEPOSIT_TO_RESERVE,
        );
    }

    pub fn contract_ft_transfer_call(
        &self,
        token: &UserAccount,
        user: &UserAccount,
        amount: Balance,
        msg: &str,
    ) -> ExecutionResult {
        user.call(
            token.account_id.clone(),
            "ft_transfer_call",
            &json!({
                "receiver_id": self.contract.user_account.account_id(),
                "amount": U128::from(amount),
                "msg": msg,
            })
            .to_string()
            .into_bytes(),
            MAX_GAS.0,
            1,
        )
    }

    pub fn mint_ft(&self, token: &UserAccount, receiver: &UserAccount, amount: Balance) {
        self.owner
            .call(
                token.account_id.clone(),
                "ft_transfer",
                &json!({
                    "receiver_id": receiver.account_id(),
                    "amount": U128::from(amount),
                })
                .to_string()
                .into_bytes(),
                DEFAULT_GAS.0,
                1,
            )
            .assert_success();
    }

    pub fn mint_tokens(&self, tokens: &Tokens, user: &UserAccount) {
        ft_storage_deposit(user, &tokens.wnear.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.neth.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.ndai.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdt.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdc.account_id(), &user.account_id());
        ft_storage_deposit(user, &self.booster_token.account_id(), &user.account_id());

        let amount = 1000000;
        self.mint_ft(&tokens.wnear, user, d(amount, 24));
        self.mint_ft(&tokens.neth, user, d(amount, 18));
        self.mint_ft(&tokens.ndai, user, d(amount, 18));
        self.mint_ft(&tokens.nusdt, user, d(amount, 6));
        self.mint_ft(&tokens.nusdc, user, d(amount, 6));
        self.mint_ft(&self.booster_token, user, d(amount, 18));
    }

    pub fn get_asset(&self, token: &UserAccount) -> AssetDetailedView {
        let asset: Option<AssetDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_asset(token.account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn get_account(&self, user: &UserAccount) -> AccountDetailedView {
        let asset: Option<AccountDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_account(user.account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn supply_to_collateral(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        amount: Balance,
    ) -> ExecutionResult {
        self.contract_ft_transfer_call(
            &token,
            &user,
            amount,
            &serde_json::to_string(&TokenReceiverMsg::Execute {
                actions: vec![Action::IncreaseCollateral(AssetAmount {
                    token_id: token.account_id(),
                    amount: None,
                    max_amount: None,
                })],
            })
            .unwrap(),
        )
    }

    pub fn oracle_call(
        &self,
        user: &UserAccount,
        price_data: PriceData,
        msg: PriceReceiverMsg,
    ) -> ExecutionResult {
        user.function_call(
            self.oracle.contract.oracle_call(
                self.contract.user_account.account_id(),
                price_data,
                serde_json::to_string(&msg).unwrap(),
            ),
            MAX_GAS.0,
            ONE_YOCTO,
        )
    }

    pub fn borrow(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![Action::Borrow(AssetAmount {
                    token_id: token.account_id(),
                    amount: Some(amount.into()),
                    max_amount: None,
                })],
            },
        )
    }

    pub fn borrow_and_withdraw(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![
                    Action::Borrow(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                    Action::Withdraw(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                ],
            },
        )
    }

    pub fn skip_time(&self, seconds: u32) {
        self.near.borrow_runtime_mut().cur_block.block_timestamp += to_nano(seconds);
    }
}

pub fn init_token(e: &Env, token_account_id: &AccountId, decimals: u8) -> UserAccount {
    let token = e.near.deploy_and_init(
        &FUNGIBLE_TOKEN_WASM_BYTES,
        token_account_id.clone(),
        "new",
        &json!({
            "owner_id": e.owner.account_id(),
            "total_supply": U128::from(10u128.pow((9 + decimals) as _)),
            "metadata": FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: token_account_id.to_string(),
                symbol: token_account_id.to_string(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: decimals,
            }
        })
        .to_string()
        .into_bytes(),
        to_yocto("10"),
        DEFAULT_GAS.0,
    );

    ft_storage_deposit(&e.owner, token_account_id, &e.contract.account_id());
    token
}

impl Tokens {
    pub fn init(e: &Env) -> Self {
        Self {
            wnear: init_token(e, &a("wrap.near"), 24),
            neth: init_token(e, &a("neth.near"), 18),
            ndai: init_token(e, &a("dai.near"), 18),
            nusdt: init_token(e, &a("nusdt.near"), 6),
            nusdc: init_token(e, &a("nusdc.near"), 6),
        }
    }
}

impl Users {
    pub fn init(e: &Env) -> Self {
        Self {
            alice: e.near.create_user(a("alice.near"), to_yocto("10000")),
            bob: e.near.create_user(a("bob.near"), to_yocto("10000")),
            charlie: e.near.create_user(a("charlie.near"), to_yocto("10000")),
            dude: e.near.create_user(a("dude.near"), to_yocto("10000")),
            eve: e.near.create_user(a("eve.near"), to_yocto("10000")),
        }
    }
}

pub fn d(value: Balance, decimals: u8) -> Balance {
    value * 10u128.pow(decimals as _)
}
pub fn a(account_id: &str) -> AccountId {
    AccountId::new_unchecked(account_id.to_string())
}

pub fn price_data(
    tokens: &Tokens,
    wnear_mul: Option<Balance>,
    neth_mul: Option<Balance>,
) -> PriceData {
    let mut prices = vec![
        AssetOptionalPrice {
            asset_id: tokens.ndai.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 22,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdc.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdt.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
    ];
    if let Some(wnear_mul) = wnear_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.wnear.account_id().to_string(),
            price: Some(Price {
                multiplier: wnear_mul,
                decimals: 28,
            }),
        })
    }
    if let Some(neth_mul) = neth_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.neth.account_id().to_string(),
            price: Some(Price {
                multiplier: neth_mul,
                decimals: 22,
            }),
        })
    }
    PriceData {
        timestamp: 0,
        recency_duration_sec: 90,
        prices,
    }
}

pub fn basic_setup_with_contract(contract_bytes: &[u8]) -> (Env, Tokens, Users) {
    let e = Env::init_with_contract(contract_bytes);
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
    storage_deposit(
        &users.alice,
        &e.contract.account_id(),
        &users.alice.account_id(),
        d(1, 23),
    );
    e.mint_tokens(&tokens, &users.bob);
    storage_deposit(
        &users.bob,
        &e.contract.account_id(),
        &users.bob.account_id(),
        d(1, 23),
    );

    (e, tokens, users)
}

pub fn basic_setup() -> (Env, Tokens, Users) {
    basic_setup_with_contract(&BURROWLAND_WASM_BYTES)
}

'''
'''--- references/main/tests/upgrade.rs ---
mod setup;

use crate::setup::*;

#[test]
fn test_upgrade() {
    let (e, tokens, users) = basic_setup_with_contract(burrowland_0_1_0_wasm_bytes());

    let amount = d(100, 24);
    e.contract_ft_transfer_call(&tokens.wnear, &users.alice, amount, "")
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
    assert_eq!(account.supplied[0].token_id, tokens.wnear.account_id());

    e.redeploy_latest();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
}

'''
'''--- references/mint-ft/mintft.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- references/mint-ft/readme.md ---

Build webassemply từ code (nhớ chỉnh target) 

>> ./build.sh

Cấu hình env sang testnet hoặc mainnet

>> export NEAR_ENV=testnet

Login near

>> near login

Đổi account bằng ID cho ngắn gọn (chú ý, sửa MY_ACCOUNT_NAME là tên ID của mình)

>> ID=MY_ACCOUNT_NAME

Kiểm tra lại bằng câu lệnh

>> echo $ID

Deploy smart contract  (nhớ chỉnh target)

>> near deploy --wasmFile res/fungible_token.wasm --accountId $ID

Gọi tới hàm mint token

>> near call $ID new '{"owner_id": "'$ID'", "total_supply": "1000000000000000000000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Nearlend", "symbol": "NEL", "decimals": 24 }}' --accountId $ID

Hiện metadata

>> near view $ID ft_metadata

Chuyển token bằng CLI

>> near call $ID ft_transfer '{"receiver_id": "'bob.$ID'", "amount": "19"}' --accountId $ID --amount 0.000000000000000000000001
'''
'''--- references/old-contract.rs ---
use near_sdk::collections::UnorderedMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, EpochHeight,Promise
};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{U128};

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq, Serialize, Deserialize)]
pub struct Account {

	pub borrowed: Balance,
	pub borrow_shares: NumStakeShares,
	pub supplied: Balance,
	pub supply_shares: NumStakeShares,
	pub borrowed_available_epoch_height: EpochHeight,
    pub supplied_available_epoch_height: EpochHeight

}

impl Default for Account {
    fn default() -> Self {
        Self {
            borrowed: 0,
            borrow_shares: 0,
			supplied:0,
			supply_shares:0,
			borrowed_available_epoch_height:0,
            supplied_available_epoch_height: 0
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
//const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;
#[near_bindgen]

#[derive(BorshDeserialize, BorshSerialize)]

pub struct NEARLendContract {
    pub owner_id: AccountId,
    pub last_epoch_height: EpochHeight,
    pub total_pool_balance: Balance,
	pub accounts: UnorderedMap<AccountId, Account>,
    pub paused: bool,
}

impl Default for NEARLendContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }

}

#[near_bindgen]
impl NEARLendContract{
	#[init]
	pub fn new() -> Self{
		assert!(!env::state_exists(), "Already initialized");
		assert!(
            env::is_valid_account_id(env::current_account_id().as_bytes()),
            "The owner account ID is invalid"
        );
		// let account_balance = env::account_balance();
		let mut this = Self {
            owner_id : env::current_account_id(),
            last_epoch_height : env::epoch_height(),
            total_pool_balance : 0,
			accounts : UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
		this
	}

    #[payable]
	pub fn supply(&mut self){
		let amount: Balance = env::attached_deposit();
        assert!(env::account_balance() >= amount, "You don't have enought balance");
		//let amount: Balance = 2;
        self.total_pool_balance += amount; // Add in total pool
		let account_id  = env::signer_account_id();
        let mut account =  self.accounts.get(&account_id).unwrap_or_default();
		account.supplied += amount; //add in account
        self.accounts.insert(&account_id, &account);
	}

    pub fn withdraw_supply(&mut self, am:U128){
        let account_id = env::signer_account_id();
        let mut account =  self.accounts.get(&account_id).unwrap_or_default();
        let amount: Balance = am.into();
        assert!(amount > 0, "Withdrawal amount should be positive");
        assert!(amount <= self.get_account_supplied_balance(), "Withdrawal amount should be less or equal to your supply");
        self.total_pool_balance -= amount;
        account.supplied -= amount; //add in account
        // self.accounts.insert(&account_id, &account);
        Promise::new(env::signer_account_id()).transfer(amount);
    }

    
	/****************/
    /* View methods */
    /****************/
	pub fn get_account_supplied_balance(&self) -> Balance {
        let account_id = env::signer_account_id();
        self.accounts.get(&account_id).unwrap_or_default().supplied
    }

    pub fn test1() -> i128 {
        return 100;
    }

     /// Returns the total pool balance.
    pub fn get_total_pool_balance(&self) -> U128 {
        self.total_pool_balance.into()
    }
    
    pub fn get_account(&self) -> Account {
        let account_id = env::signer_account_id();
        self.accounts.get(&account_id).unwrap_or_default()
    }

}

'''
'''--- references/price-oracle/Cargo.toml ---
[package]
name = "price-oracle"
version = "0.1.1"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/price-oracle/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/price_oracle.wasm ./res/

'''
'''--- references/price-oracle/check.sh ---
#!/bin/bash
export MAIN_ACCOUNT=lam-test6.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.$MAIN_ACCOUNT
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

./build.sh

echo "################### DELETE ACCOUNT ###################"
near delete $ORACLE_ID $ACCOUNT_ID

echo "################### CREATE ACCOUNT ###################"

near create-account $ORACLE_ID --masterAccount $ACCOUNT_ID --initialBalance 10
# near create-account $CONTRACT_ID --masterAccount $ACCOUNT_ID --initialBalance 10

echo "################### CREATE CONTRACT ###################"
near deploy $ORACLE_ID --accountId $ACCOUNT_ID --wasmFile ./res/price_oracle.wasm 

near call $ORACLE_ID  new '{"recency_duration_sec": 5000}'  --accountId=$CONTRACT_ID
# #########################

near call $ORACLE_ID  add_oracle '{"account_id": "'$CONTRACT_ID'"}'  --accountId=$ORACLE_ID

near call $ORACLE_ID add_asset '{"asset_id": "'$DAI_TOKEN_ID'"}' --accountId=$ORACLE_ID
near call $ORACLE_ID add_asset '{"asset_id": "'$USDT_TOKEN_ID'"}' --accountId=$ORACLE_ID

near call $ORACLE_ID  report_prices '{
    "prices": 
    [{
        "asset_id": "'$DAI_TOKEN_ID'", 
        "price": {
            "multiplier": "10", 
            "decimals": 0
        }
    }, {
        "asset_id": "'$USDT_TOKEN_ID'", 
        "price": {
            "multiplier": "10", 
            "decimals": 12
        }
    }]
}'  --accountId=$CONTRACT_ID

near view $ORACLE_ID get_oracles '{"from_index": 0, "limit": 10}'

near view $ORACLE_ID get_assets '{"from_index": 0, "limit": 10}'

near view $ORACLE_ID get_price_data '{"asset_ids": ["'$DAI_TOKEN_ID'", "'$USDT_TOKEN_ID'"]}'

'''
'''--- references/price-oracle/src/asset.rs ---
use crate::*;

pub type AssetId = String;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    pub reports: Vec<Report>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Report {
    pub oracle_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub price: Price,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetPrice {
    pub asset_id: AssetId,
    pub price: Price,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new() -> Self {
        Self {
            reports: Vec::new(),
        }
    }

    pub fn add_report(&mut self, report: Report) {
        self.reports.push(report);
    }

    pub fn remove_report(&mut self, oracle_id: &AccountId) -> bool {
        let initial_len = self.reports.len();
        self.reports.retain(|rp| &rp.oracle_id != oracle_id);
        self.reports.len() != initial_len
    }

    pub fn median_price(
        &self,
        timestamp_cut: Timestamp,
        min_num_recent_reports: usize,
    ) -> Option<Price> {
        let mut recent_reports: Vec<_> = self
            .reports
            .iter()
            .filter(|rp| rp.timestamp >= timestamp_cut)
            .collect();
        log!("==> recent_reports {}", recent_reports.len());
        if recent_reports.len() < min_num_recent_reports {
            return None;
        }
        let index = recent_reports.len() / 2;
        recent_reports.select_nth_unstable_by(index, |a, b| a.price.cmp(&b.price));
        recent_reports.get(index).map(|tp| tp.price)
    }
}

impl Contract {
    pub fn internal_get_asset(&self, asset_id: &AssetId) -> Option<Asset> {
        self.assets.get(asset_id).map(|v| v.into())
    }

    pub fn internal_set_asset(&mut self, asset_id: &AssetId, asset: Asset) {
        self.assets.insert(asset_id, &asset.into());
    }
}

'''
'''--- references/price-oracle/src/lib.rs ---
mod asset;
mod oracle;
mod utils;

use crate::asset::*;
use crate::oracle::*;
use crate::utils::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp, log
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;

const TGAS: Gas = 10u64.pow(12);
const GAS_FOR_PROMISE: Gas = 10 * TGAS;

const NEAR_CLAIM: Balance = 30 * 10u128.pow(23);
const NEAR_CLAIM_DURATION: Duration = 24 * 60 * 60 * 10u64.pow(9);

pub type DurationSec = u32;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Oracles,
    Assets,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub oracles: UnorderedMap<AccountId, VOracle>,

    pub assets: UnorderedMap<AssetId, VAsset>,

    pub recency_duration_sec: DurationSec,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(recency_duration_sec: DurationSec) -> Self {
        Self {
            oracles: UnorderedMap::new(StorageKey::Oracles),
            assets: UnorderedMap::new(StorageKey::Assets),
            recency_duration_sec,
        }
    }

    #[private]
    pub fn set_recency_duration_sec(&mut self, recency_duration_sec: DurationSec) {
        self.recency_duration_sec = recency_duration_sec;
    }

    #[private]
    pub fn add_oracle(&mut self, account_id: ValidAccountId) {
        assert!(self.internal_get_oracle(account_id.as_ref()).is_none());
        self.internal_set_oracle(account_id.as_ref(), Oracle::new());
    }

    #[private]
    pub fn remove_oracle(&mut self, account_id: ValidAccountId) {
        assert!(self.oracles.remove(account_id.as_ref()).is_some());
    }

    /// Remove price data from removed oracle.
    pub fn clean_oracle_data(&mut self, account_id: ValidAccountId, asset_ids: Vec<AssetId>) {
        assert!(self.internal_get_oracle(account_id.as_ref()).is_none());
        for asset_id in asset_ids {
            let mut asset = self.internal_get_asset(&asset_id).expect("Unknown asset");
            if asset.remove_report(account_id.as_ref()) {
                self.internal_set_asset(&asset_id, asset);
            }
        }
    }

    #[private]
    pub fn add_asset(&mut self, asset_id: AssetId) {
        assert!(self.internal_get_asset(&asset_id).is_none());
        self.internal_set_asset(&asset_id, Asset::new());
    }

    pub fn get_oracle(&self, account_id: ValidAccountId) -> Option<Oracle> {
        self.internal_get_oracle(account_id.as_ref())
    }

    pub fn get_oracles(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(AccountId, Oracle)> {
        unordered_map_pagination(&self.oracles, from_index, limit)
    }

    pub fn get_assets(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(AccountId, Asset)> {
        unordered_map_pagination(&self.assets, from_index, limit)
    }

    pub fn get_asset(&self, asset_id: AssetId) -> Option<Asset> {
        self.internal_get_asset(&asset_id)
    }

    pub fn get_price_data(&self, asset_ids: Vec<AssetId>) -> PriceData {

        log!("Asset Id => {:?}", asset_ids);

        let timestamp = env::block_timestamp();
        let timestamp_cut = timestamp.saturating_sub(to_nano(self.recency_duration_sec));
        let min_num_recent_reports = std::cmp::max(1, (self.oracles.len() + 1) / 2) as usize;
        log!("Min_num_recent_reports Id => {}", min_num_recent_reports);

        log!("Timestamp => {:?}", timestamp);
        log!("Timestamp_cut => {:?}", timestamp_cut);
        PriceData {
            timestamp,
            recency_duration_sec: self.recency_duration_sec,
            prices: asset_ids
                .into_iter()
                .map(|asset_id| {
                    let asset = self.internal_get_asset(&asset_id);
                    log!("Asset get price => {:?}", asset);
                    let asset_clone = asset.clone();
                    let prices = asset_clone.and_then(|asset| {
                        asset.median_price(timestamp_cut, min_num_recent_reports)
                    });
                    log!("Prices get in asset clone => {:?}", prices);
                    AssetOptionalPrice {
                        asset_id,
                        price: asset.and_then(|asset| {
                            asset.median_price(timestamp_cut, min_num_recent_reports)
                        }),
                    }
                })
                .collect(),
        }
    }

    /// Returns price data for a given oracle ID and given list of asset IDs.
    pub fn get_oracle_price_data(
        &self,
        account_id: ValidAccountId,
        asset_ids: Vec<AssetId>,
    ) -> PriceData {
        let timestamp = env::block_timestamp();
        let timestamp_cut = timestamp.saturating_sub(to_nano(self.recency_duration_sec));

        let oracle_id: AccountId = account_id.into();
        PriceData {
            timestamp,
            recency_duration_sec: self.recency_duration_sec,
            prices: asset_ids
                .into_iter()
                .map(|asset_id| {
                    let asset = self.internal_get_asset(&asset_id);
                    AssetOptionalPrice {
                        asset_id,
                        price: asset.and_then(|asset| {
                            asset
                                .reports
                                .into_iter()
                                .find(|report| report.oracle_id == oracle_id)
                                .filter(|report| report.timestamp >= timestamp_cut)
                                .map(|report| report.price)
                        }),
                    }
                })
                .collect(),
        }
    }

    pub fn report_prices(&mut self, prices: Vec<AssetPrice>) {
        assert!(!prices.is_empty());
        let oracle_id = env::predecessor_account_id();
        log!("Oracle id = {:?}", oracle_id);
        let timestamp = env::block_timestamp();

        // Oracle stats
        let mut oracle = self.internal_get_oracle(&oracle_id).expect("Not an oracle");
        oracle.last_report = timestamp;
        oracle.price_reports += prices.len() as u64;

        if oracle.last_near_claim + NEAR_CLAIM_DURATION <= timestamp {
            oracle.last_near_claim = timestamp;
            Promise::new(oracle_id.clone()).transfer(NEAR_CLAIM);
        }

        self.internal_set_oracle(&oracle_id, oracle);

        // Updating prices
        for AssetPrice { asset_id, price } in prices {
            price.assert_valid();
            let mut asset = self.internal_get_asset(&asset_id).expect("Unknown asset");
            asset.remove_report(&oracle_id);
            asset.add_report(Report {
                oracle_id: oracle_id.clone(),
                timestamp,
                price,
            });
            self.internal_set_asset(&asset_id, asset);
        }
    }

    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: ValidAccountId,
        asset_ids: Vec<AssetId>,
        msg: String,
    ) -> Promise {
        self.assert_well_paid();

        let sender_id = env::predecessor_account_id();
        let price_data = self.get_price_data(asset_ids);
        log!("Price data = {:?}", price_data);
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

impl Contract {
    pub fn assert_well_paid(&self) {
        assert_one_yocto();
    }
}

'''
'''--- references/price-oracle/src/oracle.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Oracle {
    #[serde(with = "u64_dec_format")]
    pub last_report: Timestamp,
    pub price_reports: u64,

    #[serde(with = "u64_dec_format")]
    pub last_near_claim: Timestamp,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OracleV0 {
    #[serde(with = "u64_dec_format")]
    pub last_report: Timestamp,
    pub price_reports: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VOracle {
    V0(OracleV0),
    Current(Oracle),
}

impl From<VOracle> for Oracle {
    fn from(v: VOracle) -> Self {
        match v {
            VOracle::V0(o) => Oracle {
                last_report: o.last_report,
                price_reports: o.price_reports,
                last_near_claim: 0,
            },
            VOracle::Current(c) => c,
        }
    }
}

impl From<Oracle> for VOracle {
    fn from(c: Oracle) -> Self {
        VOracle::Current(c)
    }
}

impl Oracle {
    pub fn new() -> Self {
        Self {
            last_report: 0,
            price_reports: 0,
            last_near_claim: 0,
        }
    }
}

impl Contract {
    pub fn internal_get_oracle(&self, account_id: &AccountId) -> Option<Oracle> {
        self.oracles.get(account_id).map(|o| o.into())
    }

    pub fn internal_set_oracle(&mut self, account_id: &AccountId, oracle: Oracle) {
        self.oracles.insert(account_id, &oracle.into());
    }
}

'''
'''--- references/price-oracle/src/utils.rs ---
use crate::*;
use std::cmp::Ordering;

const MAX_U128_DECIMALS: u8 = 38;
const MAX_VALID_DECIMALS: u8 = 77;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

// 5 NEAR = 5 * 10**24 "wrap.near"
// 50 DAI = 50 * 10**18 "dai.bridge.near"

// Price NEAR { multiplier: 1000, decimals: 26 }
// 5 NEAR in USD = 5 * 10**24 * 1000 / 10**(26 - 18) = 50 * 10**18
// Price DAI { multiplier: 101, decimals: 20 }
// 50 DAI in USD = 50 * 10**18 * 101 / 10**(20 - 18) = 505 * 10**17

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

impl PartialEq<Self> for Price {
    fn eq(&self, other: &Self) -> bool {
        self.partial_cmp(other) == Some(Ordering::Equal)
    }
}

impl PartialOrd for Price {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.decimals < other.decimals {
            return Some(other.cmp(self).reverse());
        }

        let decimals_diff = self.decimals - other.decimals;

        if decimals_diff > MAX_U128_DECIMALS {
            return Some(Ordering::Less);
        }

        if let Some(om) = other
            .multiplier
            .checked_mul(10u128.pow(decimals_diff as u32))
        {
            Some(self.multiplier.cmp(&om))
        } else {
            Some(Ordering::Less)
        }
    }
}

impl Eq for Price {}

impl Ord for Price {
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other).unwrap()
    }
}

pub(crate) mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub(crate) mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub(crate) fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

'''
'''--- references/price/Cargo.toml ---
[package]
name = "price"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- references/price/src/main.rs ---
fn main() {
    println!("Hello, world!");
}

'''
'''--- references/wrapped-ft/branches/lock-unlock-transfer-restriction/Cargo.toml ---
[package]
name = "wrapped-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/wrapped-ft/branches/lock-unlock-transfer-restriction/README.md ---
## Example with wNEAR on testnet

* `$CONTRACT_ID` - the account ID of the new token fNEAR
* `$OWNER_ID` - the account ID of the controller/owner.
* `wrap.testnet` - the token ID that is being wrapped/locked. wNEAR is used for the example.
* `$ACCOUNT_ID` - the account ID of a test account.

#### Init

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID new '{
  "locked_token_account_id": "wrap.testnet",
  "meta": {"spec": "ft-1.0.0", "name": "Future NEAR", "symbol": "fNEAR", "decimals": 24},
  "owner_id": "'$OWNER_ID'"
}'
```

#### Wrap 20 NEAR into wNEAR (optional)

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '' --amount=0.00125
near call wrap.testnet --accountId=$OWNER_ID near_deposit --amount=20
```

#### Storage deposit

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --amount=0.00125
```

#### Lock 10 wNEAR into fNEAR

```bash
near call wrap.testnet --accountId=$OWNER_ID --depositYocto=1 --gas=100000000000000 ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10000000000000000000000000",
  "msg": ""
}'
```

#### View methods

```bash
near view $CONTRACT_ID get_info
near view $CONTRACT_ID ft_metadata
near view $CONTRACT_ID ft_total_supply
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
```

#### Storage for the new account

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Transfer 1 fNEAR from the owner

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$ACCOUNT_ID'",
  "amount": "1000000000000000000000000"
}' 
```

#### Check balance

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Attempt to transfer back (should fail, because not whitelisted)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$OWNER_ID'",
  "amount": "1000000000000000000000000"
}' 
```

Expected error:
```
'Not whitelisted for transfers'
```

#### Attempt to unwrap (should fail, still locked)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

Expected error:
```
'The token is still locked'
```

#### Whitelist transfers for the account

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 add_transfer_whitelist '{
  "account_id": "'$ACCOUNT_ID'"
}'
```

#### Transfer of 0.1 by the account to the owner

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$OWNER_ID'",
  "amount": "100000000000000000000000"
}' 
```

#### Unlock the unwrapping by the owner

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 unlock ''
```

#### Attempt to unwrap the token (should fail, no wNEAR storage)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

Expected error:
```
'The account is not registered'
```

#### Verify balances didn't change

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Storage deposit for wNEAR

```bash
near call wrap.testnet --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Unwrap the token

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

#### Verify balances of the account for fNEAR and wNEAR

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
near view wrap.testnet ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

'''
'''--- references/wrapped-ft/branches/lock-unlock-transfer-restriction/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/wrapped_ft.wasm ./res/

'''
'''--- references/wrapped-ft/branches/lock-unlock-transfer-restriction/src/lib.rs ---
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::resolver::FungibleTokenResolver;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue,
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;

pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
    TransferWhitelist,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    Locked,
    Unlocked,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    #[serde(with = "unordered_set_expensive")]
    pub transfer_whitelist: UnorderedSet<AccountId>,
    pub owner_id: AccountId,
    pub locked_token_account_id: TokenAccountId,
    pub status: Status,
}

near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        assert!(matches!(self.status, Status::Locked));
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        self.assert_transfer_whitelist();
        self.ft.ft_transfer(receiver_id, amount, memo)
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        self.assert_transfer_whitelist();
        self.ft.ft_transfer_call(receiver_id, amount, memo, msg)
    }

    fn ft_total_supply(&self) -> U128 {
        self.ft.ft_total_supply()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.ft.ft_balance_of(account_id)
    }
}

#[near_bindgen]
impl FungibleTokenResolver for Contract {
    #[private]
    fn ft_resolve_transfer(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> U128 {
        let sender_id: AccountId = sender_id.into();
        let (used_amount, burned_amount) =
            self.ft
                .internal_ft_resolve_transfer(&sender_id, receiver_id, amount);
        if burned_amount > 0 {
            self.on_tokens_burned(sender_id, burned_amount);
        }
        used_amount.into()
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        locked_token_account_id: ValidAccountId,
        meta: FungibleTokenMetadata,
        owner_id: ValidAccountId,
    ) -> Self {
        let mut transfer_whitelist = UnorderedSet::new(StorageKey::TransferWhitelist);
        transfer_whitelist.insert(owner_id.as_ref());

        let mut ft = FungibleToken::new(StorageKey::Ft);
        ft.internal_register_account(owner_id.as_ref());

        Self {
            ft,
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            transfer_whitelist,
            owner_id: owner_id.into(),
            locked_token_account_id: locked_token_account_id.into(),
            status: Status::Locked,
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn add_transfer_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.transfer_whitelist.insert(account_id.as_ref());
    }

    #[payable]
    pub fn remove_transfer_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.transfer_whitelist.remove(account_id.as_ref());
    }

    #[payable]
    pub fn unlock(&mut self) {
        assert_one_yocto();
        self.assert_owner();
        assert!(!matches!(self.status, Status::Unlocked));
        self.status = Status::Unlocked;
    }

    #[payable]
    pub fn lock(&mut self) {
        assert_one_yocto();
        self.assert_owner();
        assert!(!matches!(self.status, Status::Locked));
        self.status = Status::Locked;
    }

    #[payable]
    pub fn unwrap(&mut self, account_id: Option<ValidAccountId>) -> Promise {
        assert_one_yocto();
        assert!(
            matches!(self.status, Status::Unlocked),
            "The token is still locked"
        );
        let predecessor_id = env::predecessor_account_id();

        let account_id = if let Some(account_id) = account_id {
            let account_id: AccountId = account_id.into();
            if account_id != predecessor_id {
                self.assert_owner();
            }
            account_id
        } else {
            predecessor_id
        };
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

impl Contract {
    fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Not the owner"
        );
    }

    fn assert_transfer_whitelist(&self) {
        assert!(
            self.transfer_whitelist
                .contains(&env::predecessor_account_id()),
            "Not whitelisted for transfers"
        );
    }
}

mod unordered_set_expensive {
    use super::*;
    use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
    use near_sdk::serde::Serializer;

    pub fn serialize<S, T>(set: &UnorderedSet<T>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
        T: Serialize + BorshDeserialize + BorshSerialize,
    {
        serializer.collect_seq(set.iter())
    }
}

'''
'''--- references/wrapped-ft/branches/simplest/Cargo.toml ---
[package]
name = "wrapped-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/wrapped-ft/branches/simplest/README.md ---
## Example with wNEAR on testnet

* `$CONTRACT_ID` - the account ID of the new token fNEAR
* `wrap.testnet` - the token ID that is being wrapped/locked. wNEAR is used for the example.
* `$ACCOUNT_ID` - the account ID of a test account.

#### Init

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID new '{
  "locked_token_account_id": "wrap.testnet",
  "meta": {"spec": "ft-1.0.0", "name": "Future NEAR", "symbol": "fNEAR", "decimals": 24},
}'
```

#### Wrap 20 NEAR into wNEAR (optional)

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '' --amount=0.00125
near call wrap.testnet --accountId=$OWNER_ID near_deposit --amount=20
```

#### Storage deposit

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --amount=0.00125
```

#### Lock 10 wNEAR into fNEAR

```bash
near call wrap.testnet --accountId=$OWNER_ID --depositYocto=1 --gas=100000000000000 ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10000000000000000000000000",
  "msg": ""
}'
```

#### View methods

```bash
near view $CONTRACT_ID get_info
near view $CONTRACT_ID ft_metadata
near view $CONTRACT_ID ft_total_supply
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
```

#### Storage for the new account

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Transfer 1 fNEAR from the owner

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$ACCOUNT_ID'",
  "amount": "1000000000000000000000000"
}' 
```

#### Check balance

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Transfer of 0.1 by the account to the owner

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$OWNER_ID'",
  "amount": "100000000000000000000000"
}' 
```

#### Attempt to unwrap the token (should fail, no wNEAR storage)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

Expected error:
```
'The account is not registered'
```

#### Verify balances didn't change

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Storage deposit for wNEAR

```bash
near call wrap.testnet --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Unwrap the token

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

#### Verify balances of the account for fNEAR and wNEAR

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
near view wrap.testnet ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

'''
'''--- references/wrapped-ft/branches/simplest/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/wrapped_ft.wasm ./res/

'''
'''--- references/wrapped-ft/branches/simplest/src/lib.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue,
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 20 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;

pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    pub locked_token_account_id: TokenAccountId,
}

near_contract_standards::impl_fungible_token_core!(Contract, ft, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(locked_token_account_id: ValidAccountId, meta: FungibleTokenMetadata) -> Self {
        Self {
            ft: FungibleToken::new(StorageKey::Ft),
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            locked_token_account_id: locked_token_account_id.into(),
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn unwrap(&mut self) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

'''
'''--- references/wrapped-ft/trunk/Cargo.toml ---
[package]
name = "wrapped-ft"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- references/wrapped-ft/trunk/README.md ---
## Example with wNEAR on testnet

* `$CONTRACT_ID` - the account ID of the new token fNEAR
* `$OWNER_ID` - the account ID of the controller/owner.
* `wrap.testnet` - the token ID that is being wrapped/locked. wNEAR is used for the example.
* `$ACCOUNT_ID` - the account ID of a test account.

#### Init

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID new '{
  "locked_token_account_id": "wrap.testnet",
  "meta": {"spec": "ft-1.0.0", "name": "Future NEAR", "symbol": "fNEAR", "decimals": 24},
  "owner_id": "'$OWNER_ID'"
}'
```

#### Wrap 20 NEAR into wNEAR (optional)

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '' --amount=0.00125
near call wrap.testnet --accountId=$OWNER_ID near_deposit --amount=20
```

#### Storage deposit

```bash
near call wrap.testnet --accountId=$OWNER_ID storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --amount=0.00125
```

#### Lock 10 wNEAR into fNEAR

```bash
near call wrap.testnet --accountId=$OWNER_ID --depositYocto=1 --gas=100000000000000 ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10000000000000000000000000",
  "msg": ""
}'
```

#### View methods

```bash
near view $CONTRACT_ID get_info
near view $CONTRACT_ID ft_metadata
near view $CONTRACT_ID ft_total_supply
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
```

#### Storage for the new account

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Transfer 1 fNEAR from the owner

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$ACCOUNT_ID'",
  "amount": "1000000000000000000000000"
}' 
```

#### Check balance

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Attempt to transfer back (should fail, because not whitelisted)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$OWNER_ID'",
  "amount": "1000000000000000000000000"
}' 
```

Expected error:
```
'Not whitelisted for transfers'
```

#### Attempt to unwrap (should fail, still locked)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

Expected error:
```
'The token is still locked'
```

#### Whitelist transfers for the account

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 add_transfer_whitelist '{
  "account_id": "'$ACCOUNT_ID'"
}'
```

#### Transfer of 0.1 by the account to the owner

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 ft_transfer '{
  "receiver_id": "'$OWNER_ID'",
  "amount": "100000000000000000000000"
}' 
```

#### Unlock the unwrapping by the owner

```bash
near call $CONTRACT_ID --accountId=$OWNER_ID --depositYocto=1 unlock ''
```

#### Attempt to unwrap the token (should fail, no wNEAR storage)

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

Expected error:
```
'The account is not registered'
```

#### Verify balances didn't change

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$OWNER_ID'"}' 
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

#### Storage deposit for wNEAR

```bash
near call wrap.testnet --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
```

#### Unwrap the token

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --depositYocto=1 --gas=100000000000000 unwrap ''
```

#### Verify balances of the account for fNEAR and wNEAR

```bash
near view $CONTRACT_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
near view wrap.testnet ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}' 
```

'''
'''--- references/wrapped-ft/trunk/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/wrapped_ft.wasm ./res/

'''
'''--- references/wrapped-ft/trunk/src/lib.rs ---
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::resolver::FungibleTokenResolver;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue,
};

near_sdk::setup_alloc!();

const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;

const TGAS: Gas = 1_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 10 * TGAS;
const GAS_FOR_AFTER_FT_TRANSFER: Gas = 10 * TGAS;

pub type TokenAccountId = AccountId;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Ft,
    FtMeta,
    TransferWhitelist,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    Locked,
    Unlocked,
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

pub trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    #[serde(skip)]
    pub ft: FungibleToken,
    #[serde(skip)]
    pub meta: LazyOption<FungibleTokenMetadata>,
    #[serde(with = "unordered_set_expensive")]
    pub transfer_whitelist: UnorderedSet<AccountId>,
    pub owner_id: AccountId,
    pub locked_token_account_id: TokenAccountId,
    pub status: Status,
}

near_contract_standards::impl_fungible_token_storage!(Contract, ft, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.meta.get().unwrap()
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.locked_token_account_id
        );
        assert!(matches!(self.status, Status::Locked));
        self.ft.internal_deposit(sender_id.as_ref(), amount.0);
        return PromiseOrValue::Value(U128(0));
    }
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(&mut self, account_id: AccountId, balance: U128) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            if let Some(balance) = self.ft.accounts.get(&account_id) {
                if balance == 0 {
                    self.ft.accounts.remove(&account_id);
                    Promise::new(account_id).transfer(self.storage_balance_bounds().min.0);
                }
            }
        } else {
            log!("Failed to transfer {} to account {}", account_id, balance.0);
            self.ft.internal_deposit(&account_id, balance.into());
        }
        promise_success
    }
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        self.assert_transfer_whitelist();
        self.ft.ft_transfer(receiver_id, amount, memo)
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        self.assert_transfer_whitelist();
        self.ft.ft_transfer_call(receiver_id, amount, memo, msg)
    }

    fn ft_total_supply(&self) -> U128 {
        self.ft.ft_total_supply()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.ft.ft_balance_of(account_id)
    }
}

#[near_bindgen]
impl FungibleTokenResolver for Contract {
    #[private]
    fn ft_resolve_transfer(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> U128 {
        let sender_id: AccountId = sender_id.into();
        let (used_amount, burned_amount) =
            self.ft
                .internal_ft_resolve_transfer(&sender_id, receiver_id, amount);
        if burned_amount > 0 {
            self.on_tokens_burned(sender_id, burned_amount);
        }
        used_amount.into()
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        locked_token_account_id: ValidAccountId,
        meta: FungibleTokenMetadata,
        owner_id: ValidAccountId,
    ) -> Self {
        let mut transfer_whitelist = UnorderedSet::new(StorageKey::TransferWhitelist);
        transfer_whitelist.insert(owner_id.as_ref());

        let mut ft = FungibleToken::new(StorageKey::Ft);
        ft.internal_register_account(owner_id.as_ref());

        Self {
            ft,
            meta: LazyOption::new(StorageKey::FtMeta, Some(&meta)),
            transfer_whitelist,
            owner_id: owner_id.into(),
            locked_token_account_id: locked_token_account_id.into(),
            status: Status::Locked,
        }
    }

    pub fn get_info(self) -> Self {
        self
    }

    #[payable]
    pub fn add_transfer_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.transfer_whitelist.insert(account_id.as_ref());
    }

    #[payable]
    pub fn remove_transfer_whitelist(&mut self, account_id: ValidAccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.transfer_whitelist.remove(account_id.as_ref());
    }

    #[payable]
    pub fn unlock(&mut self) {
        assert_one_yocto();
        self.assert_owner();
        assert!(!matches!(self.status, Status::Unlocked));
        self.status = Status::Unlocked;
    }

    #[payable]
    pub fn lock(&mut self) {
        assert_one_yocto();
        self.assert_owner();
        assert!(!matches!(self.status, Status::Locked));
        self.status = Status::Locked;
    }

    #[payable]
    pub fn unwrap(&mut self, account_id: Option<ValidAccountId>) -> Promise {
        assert_one_yocto();
        assert!(
            matches!(self.status, Status::Unlocked),
            "The token is still locked"
        );
        let predecessor_id = env::predecessor_account_id();

        let account_id = if let Some(account_id) = account_id {
            let account_id: AccountId = account_id.into();
            if account_id != predecessor_id {
                self.assert_owner();
            }
            account_id
        } else {
            predecessor_id
        };
        let balance = self.ft.accounts.get(&account_id).unwrap_or(0);
        self.ft.internal_withdraw(&account_id, balance);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(balance),
            Some(format!("Unwrapping {} tokens", env::current_account_id())),
            &self.locked_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id,
            U128(balance),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

impl Contract {
    fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_id,
            "Not the owner"
        );
    }

    fn assert_transfer_whitelist(&self) {
        assert!(
            self.transfer_whitelist
                .contains(&env::predecessor_account_id()),
            "Not whitelisted for transfers"
        );
    }
}

mod unordered_set_expensive {
    use super::*;
    use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
    use near_sdk::serde::Serializer;

    pub fn serialize<S, T>(set: &UnorderedSet<T>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
        T: Serialize + BorshDeserialize + BorshSerialize,
    {
        serializer.collect_seq(set.iter())
    }
}

'''
'''--- run_test.sh ---
export NEAR_ENV=testnet
export OWNER_ID=nthellious.testnet
export ORACLE_ID=nthellious.testnet
export ACCOUNT_ID=nthellious.testnet
export ACCOUNT_ID_2=tn666.testnet
export ACCOUNT_ID_3=tn777.testnet
export CONTRACT_ID=nel.nthellious.testnet
export REF_TOKEN_ID=ref.fakes.testnet

export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet

export AURORAX_TOKEN_ID_2=aurorax.testnet
export AURORAX_TOKEN_ID=auroraf.token-factory.tokenhub.testnet
export NEL_TOKEN_ID=neltest.token-factory.tokenhub.testnet

export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000

near delete $CONTRACT_ID $ACCOUNT_ID

near create-account $CONTRACT_ID --masterAccount $ACCOUNT_ID --initialBalance 10

near deploy $CONTRACT_ID --accountId $ACCOUNT_ID --wasmFile ./res/Nearlend.wasm

near call $CONTRACT_ID new '{"config" : {"oracle_account_id": "'$ACCOUNT_ID'", "owner_id": "'$ACCOUNT_ID'", "booster_token_id": "'$REF_TOKEN_ID'", "booster_decimals": 24}}' --accountId $ACCOUNT_ID

near call $CONTRACT_ID --accountId=test2.hoangnh_xda.testnet --gas=$GAS --amount=0.1 storage_deposit '{
  "account_id": "test2.hoangnh_xda.testnet",
  "registration_only": true
}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID storage_balance_of '{
  "account_id": "nearlend.lam-test1.testnet"
}'

#CHECK TOKEN IS DEPOSITED
near view $NEL_TOKEN_ID --accountId=$ACCOUNT_ID storage_balance_of '{
  "account_id": "'$ACCOUNT_ID_3'"
}'

// near call $CONTRACT_ID addAccount '{"account_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID

near call $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID

near call $CONTRACT_ID get_accounts_paged '{"from_index": 0, "limit": 100}' --accountId $ACCOUNT_ID

near call $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}' --accountId $ACCOUNT_ID 

near call $CONTRACT_ID get_assets_paged_detailed '{"from_index": 0, "limit": 10}' --accountId $ACCOUNT_ID 

near call $CONTRACT_ID get_asset '{"token_id": "'$AURORAX_TOKEN_ID'"}' --accountId $ACCOUNT_ID 

near view $AURORAX_TOKEN_ID ft_metadata
near view $WNEAR_TOKEN_ID ft_metadata
near view $USDT_TOKEN_ID ft_metadata
near view $DAI_TOKEN_ID ft_metadata
near view $WETH_TOKEN_ID ft_metadata
near view $REF_TOKEN_ID ft_metadata
near view $NEL_TOKEN_ID ft_metadata

near view $AURORAX_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'
near view $NEL_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'

near view $AURORAX_TOKEN_ID_2 ft_balance_of '{"account_id": "'$ACCOUNT_ID_3'"}'

near view $NEL_TOKEN_ID storage_balance_bounds

#REGISTOR newest TOKEN for USER_ACCOUNT #IF USER_ACCOUNT NEVER EVER HAVE IT YET !
near call $CONTRACT_ID storage_deposit '{"account_id": "'$ACCOUNT_ID_2'"}' --accountId $ACCOUNT_ID --deposit 0.00125

#SEND TOKEN DIRECTLY TO RECEIVER
near call $AURORAX_TOKEN_ID_2 ft_transfer '{"receiver_id": "'$ACCOUNT_ID_3'", "amount": "2000000000"}' --accountId $ACCOUNT_ID --amount $ONE_YOCTO

near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$AURORAX_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 24,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$NEL_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 24,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$REF_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 18,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 18,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

near call $AURORAX_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1",
  "msg": "{\"Execute\": {\"actions\": [{\"Withdraw\": {\"token_id\": \"'$AURORAX_TOKEN_ID'\", \"amount\": \"3000000000000000000000000\"}}]}}"
}'

near call $AURORAX_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1",
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$AURORAX_TOKEN_ID'\", \"amount\": \"3000000000000000000000000\"}}]}}"
}'

near call $AURORAX_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1000000000000000000000000000000000",
  "msg": ""
}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$AURORAX_TOKEN_ID'",
        "amount": "1000000000000000000000000000000000"
      }
    }
  ]
}'
'''
'''--- smart-contract/Cargo.toml ---
[package]
name = "nearlend"
version = "0.1.1"
authors = ["Nearlend Team"]
edition = "2018"

[dev-dependencies]
near-sdk = "=4.0.0-pre.7"
near-sdk-sim = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"

common = { path = "./common"}
contract = { path = "./contract" }
test-oracle = { path = "./test-oracle" }

approx = "0.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "common",
    "contract",
    "test-oracle",
]

'''
'''--- smart-contract/README.md ---
# Burrowland contact

## How it works

### Interest model

The contract uses a compounding interest model similar to Aave.

Each asset defines interest rate configuration with the following values:

* `target_utilization` - the ideal percent at for the asset utilization, e.g. 80% borrowed comparing to the total supplied.
* `target_utilization_r` - the constant to use as a base for computing compounding APR at the target utilization.
* `max_utilization_r` - the constant to use as a base for computing compounding APR at the 100% utilization.
* `reserve_ratio` - the percentage of the acquired interest reserved for the platform.

Based on these values we define 3 points of utilization: `0%`, target utilization and `100%`.
For each of these points we have the `r` constant: `1.0`, `target_utilization_r` and `max_utilization_r` respectively.

To compute the APR, we can use the following formula:

`1 + APR = r ** MS_PER_YEAR`, where MS_PER_YEAR is the number of milliseconds in a year equal to `31536000000`. 

Based on the current supplied, reserved and borrowed balances, the current utilization is defined using the following formula:

`utilization = (supplied + reserved) / borrowed`

To compute current APR, we need to find the current `r` constant based on the linear interpolation between utilization points:

* if `utilization <= target_utilization`, `r = target_utilization_r * (utilization / target_utilization)`
* if `utilization > target_utilization`, `r = target_utilization_r + (max_utilization_r - target_utilization_r) * (utilization - target_utilization) / (1 - target_utilization)` 

To calculate the amount of interest acquired for the duration of `t` milliseconds, we can use the following formula:

`interest = (r ** t) * borrowed`

The interest are distributed to `reserved` and `supplied`, based on `reserve_ratio`, so the new values are:

```
reserved_interest = interest * reserve_ratio
new_reserved = reserved + reserved_interest
new_supplied = supplied + (interest - reserved_interest)
new_borrowed = borrowed + interest 
```

### Health factor

The health factor is computed per account instead of per asset.

Each account may supply multiple collateral assets and may borrow multiple assets.

Each asset has a configuration value `volatility_ratio` which indicates the expected price stability factor.
The higher the ratio, the higher expectation of the stability of the price of the corresponding asset.

To compute the current health factor for the account, we need to know the current prices of all collateral and borrowed assets.
Firstly, we compute the adjusted for volatility sums of all collateral assets and borrowed assets.

```
adjusted_collateral_sum = sum(collateral_i * price_i * volatility_ratio_i)
adjusted_borrowed_sum = sum(borrowed_i * price_i / volatility_ratio_i)
```

Now we can compute the health factor:

`health_factor = adjusted_collateral_sum / adjusted_borrowed_sum`

If the health factor is higher than 100%, it means the account is in a good state and can't be liquidated.
If the health factor is less than 100%, it means the account can be partially liquidated and can't borrow more without
repaying some amount of the existing assets or providing more collateral assets.

### Liquidations

Contract liquidations are designed to make liquidators compete for the profit that they make during liquidations to
minimize the loss taken by the unhealthy accounts. Instead of the fixed profit that is used in the legacy products,
this contract introduces a variable discount with variable liquidation size.

Liquidations rules:
1. the initial health factor of the liquidated accounts has to be below 100%
2. the discounted sum of the taken collateral should be less than the sum of repaid assets  
3. the final health factor of the liquidated accounts has to stay below 100%

A liquidation action consists of the following:
- `account_id` - the account ID that is being liquidated
- `in_assets` - the assets and corresponding amounts to repay form borrowed assets
- `out_assets` - the assets and corresponding amounts to take from collateral assets

The discount is computed based on the initial health factor of the liquidated account:

`discount = (1 - health_factor) / 2`

Now we can compute the taken discounted collateral sum and the repaid borrowed sum:

```
taken_sum = sum(out_asset_i * price_i)
discounted_collateral_sum = taken_sum * (1 - discount)
repaid_sum = sum(in_asset_i * price_i)
```

Once we action is completed, we can compute the final values and verify the liquidation rules:

1. `health_factor < 100%`
2. `discounted_collateral_sum <= repaid_sum`
3. `new_health_factor < 100%`

The first rule only allows to liquidate accounts in the unhealthy state.
The second rule prevents from taking more collateral than the repaid sum (after discount).
The third rule prevents the liquidator from repaying too much of the borrowed assets, only enough to bring closer to the 100%.

#### Liquidation example

Account `alice.near` supplied to collateral `1000 wNEAR` and borrowed `4000 nDAI`.

Let's say:
- the price of `wNEAR` is `10`
- the price of the `nDAI` is `1`
- the `volatility_ratio` of `wNEAR` is `0.5`
- the `volatility_ratio` of `nDAI` is `1`

The health factor of `alice.near` is the following:

```
adjusted_collateral_sum = sum(1000 * 10 * 0.5) = 5000
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 5000 / 4000 = 125% 
```

Let's say the price of `wNEAR` drops to `8`

```
adjusted_collateral_sum = sum(1000 * 8 * 0.5) = 4000
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 4000 / 4000 = 100% 
```

The health factor is 100%, so the account still can't be liquidated.

Let's say the price of `wNEAR` drops to `7`

```
adjusted_collateral_sum = sum(1000 * 7 * 0.5) = 3500
adjusted_borrowed_sum = sum(4000 * 1 / 1) = 4000
health_factor = 3500 / 4000 = 0.875 = 87.5% 
```

The health factor is below 100%, so the account can be liquidated. The discount is the following:

```
discount = (1 - 0.875) / 2 = 0.0625 = 6.25%
```

It means anyone can repay some `nDAI` and take some `wNEAR` from `alice.near` with `6.25%` discount.  

Account `bob.near` decides to liquidate `alice.near`

`bob.near` wants to repay `1000 nDAI`, we can compute the maximum sum of the collateral to take:

```
repaid_sum = sum(1000 * 1) = 1000
max_taken_sum = repaid_sum / (1 - discount) = 1000 / (1 - 0.0625) = 1066.666
```

And based on the `wNEAR` price, we can compute the maximum amount:

```
max_wnear_amount = max_taken_sum / wnear_price = 1066.666 / 7 = 152.38
```

But to avoid risk, `bob.near` takes `152` `wNEAR` - a bit less to avoid price fluctuation for the duration of the transaction.

Let's compute the liquidation action:

```
taken_sum = sum(out_asset_i * price_i) = sum(152 * 7) = 1064
discounted_collateral_sum = taken_sum * (1 - discount) = 1064 * (1 - 0.0625) = 997.5
repaid_sum = sum(in_asset_i * price_i) = sum(1000 * 1) = 1000

new_adjusted_collateral_sum = sum((1000 - 152) * 7 * 0.5) = 2968
new_adjusted_borrowed_sum = sum((4000 - 1000) * 1 / 1) = 3000

new_health_factor = 2968 / 3000 = 0.9893 = 98.93%
```

Now checking the liquidation rules:

```
1. 87.5% < 100%
2. 997.5 <= 1000
3. 98.93% < 100%
```

All rules satisfied, so the liquidation was successful.

Now, let's compute the profit of `bob.near` (or the loss for `alice.near`) for this liquidation:
```
profit = taken_sum - repaid_sum = 1064 - 1000 = 64
```

Notes:
- If someone during the time when the price of `wNEAR` was falling from `8` to `7` liquidated `alice.near` they would have
  made less profit, by liquidating a smaller amount with a smaller collateral discount.
- To fully realize the profit, `bob.near` has to take another action on some exchange and swap received `152` `wNEAR` for `nDAI`, which 
  may involve extra fees and transactional risks. That's why liquidators may wait for higher discount.

## Development

### Build (optional)

Requires Rust and wasm32 target.

```bash
./build.sh
```

### Deploy on the testnet

Requires NEAR CLI to be installed.

```bash
./scripts/dev_deploy.sh
```

This will provide a list of exports at the end. Execute them to get the CLI ready for further transactions.

Example exports:
```bash
export NEAR_ENV=testnet
export OWNER_ID=dev-1634411537975-18277461139961
export ORACLE_ID=dev-1634411553736-97024242878560
export CONTRACT_ID=dev-1634411561699-94876475207945
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
```

### Create a test account

Requires exports from running `dev_deploy`. 

```bash
./scripts/create_account.sh
```

This will create a new test account with fake assets. Execute the export at the end to get the account ID.

Example export:
```bash
export ACCOUNT_ID=dev-1634680029152-10252684568108
```

## Actions

### Register account by paying for storage

This has to be done one per account.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'
```

### Supply some token

Let's supply `5` USDT. USDT has `6` decimals, so amount should be `5000000`. For a simple deposit, the `msg` can be empty string.

```bash
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'
```

### View account information

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

Note: Since USDT asset has extra `12` decimals, it brings the 5 USDT in the balance to `5000000000000000000`

### View a given asset

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '5000000000000000000', balance: '5000000000000000000' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000000000000000',
  last_update_timestamp: '1634682347763275349',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 12,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

Note: You can also see `2000000000000000000000` reserved. That's `2000` USDT from the owner.

### Provide token as a collateral

Let's add all USDT to a collateral. If the `amount` for a given action is not specified, then all available amount will be used.

Increasing the collateral doesn't require prices from the oracle, because it can't decrease the existing collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Note, you can see the USDT asset was moved from `supplied` to `collateral`

### Borrow a token

Let's borrow `1` DAI. DAI has `18` decimals, so the amount should be `1000000000000000000`.

Since borrow action puts account into the debt, we have to call this action through the oracle.
The oracle should provide prices for all assets in the collateral as well as all existing borrowed assets and the new borrowed asset.

The `msg` passed to the oracle should be string. Since it's part of the JSON, it has to be double-encoded and can't have newlines.

FYI: The message that we pass to the contract from the oracle is the following:
```json
{
  "Execute": {
    "actions": [
      {
        "Borrow": {
          "token_id": "dai.fakes.testnet",
          "amount": "1000000000000000000"
        }
      }
    ]
  }
}
```

```bash
near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'
```

You should see a log message like: `Account dev-1634682124572-99167526870966 borrows 1000000000000000000 of dai.fakes.testnet`

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966', 
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000048216105',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000064288139',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Note, without extra action the borrowed assets are not withdrawn to the wallet, but instead supplied to earn interest.
From there they can be withdrawn.
You can also notice that the borrowed balance is larger than the supplied balance, that's because the some of the interest are going to the reserve.

If we view the account info again, then the balances should increase:

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000221528817',
      shares: '1000000000000000000'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000000295371755',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '1000000000000000000', balance: '1000000000399150907' },
  borrowed: { shares: '1000000000000000000', balance: '1000000000532201209' },
  reserved: '2000000000000133050302',
  last_update_timestamp: '1634683708614246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Withdrawing the asset

Let's withdraw all DAI including interest.

Withdrawing doesn't need oracle prices, because it can only be taken from the supplied and not from the collateral.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'
```

You should see the log, e.g. `Account dev-1634682124572-99167526870966 withdraws 1000000001658903820 of dai.fakes.testnet`

Now let's check the DAI balance (in the wallet) of the account:

```bash
near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result: `10001000000001658903820`, which corresponds roughly to `10001` DAI, plus some extra earned interests.

Withdrawal from the contract was possible, because the owner has supplied DAI into the reserve.

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634682124572-99167526870966',
  supplied: [],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '1000000002496596924',
      shares: '1000000000000000000'
    }
  ],
  farms: []
}
```

Notice, there is no supplied DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '0', balance: '0' },
  borrowed: { shares: '1000000000000000000', balance: '1000000002551410252' },
  reserved: '2000000000000892506432',
  last_update_timestamp: '1634685033009246127',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

### Deposit asset and repay it in one call.

Note, multiple actions can be combined into a single atomic update. Either all of them complete or all of them are reverted.
The invariants are only checked at the end, so this may be used to replace one collateral with another without repaying debts (but this requires oracle pricing). 

Let's deposit `5` DAI and use it to repay borrowed DAI. DAI has 18 decimal, so the amount is `5000000000000000000`
For this we need to pass a custom `msg` to `ft_transfer_call`.
The message has to be double-encoded into a string.

FYI: Non-encoded message in JSON:
```json
{
  "Execute": {
    "actions": [
      {
        "Repay": {
          "token_id": "dai.fakes.testnet"
        }
      }
    ]
  }
}
```

```bash
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'
```

You should see similar log messages:
```
Account dev-1634686749015-49146327775274 deposits 5000000000000000000 of dai.fakes.testnet
Account dev-1634686749015-49146327775274 repays 1000000001735752696 of dai.fakes.testnet
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    }
  ],
  collateral: [
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  borrowed: [],
  farms: []
}
```

Notice, there is no borrowed DAI anymore.

Let's view the DAI asset info:

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'
```

Example result:
```javascript
{
  supplied: { shares: '3999999998264247304', balance: '3999999998264247304' },
  borrowed: { shares: '0', balance: '0' },
  reserved: '2000000000001727179674',
  last_update_timestamp: '1634688121573861187',
  config: {
    reserve_ratio: 2500,
    target_utilization: 8000,
    target_utilization_rate: '1000000000002440418605283556',
    max_utilization_rate: '1000000000039724853136740579',
    volatility_ratio: 9500,
    extra_decimals: 0,
    can_deposit: true,
    can_withdraw: true,
    can_use_as_collateral: true,
    can_borrow: true
  }
}
```

And no borrowed balance or shares after repaying.

### Decreasing collateral

Since there is no borrowed assets, we can take the collateral without providing prices.

Let's get all USDT collateral back.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'
```

Let's view the account info again:

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

Example result:
```javascript
{
  account_id: 'dev-1634686749015-49146327775274',
  supplied: [
    {
      token_id: 'dai.fakes.testnet',
      balance: '3999999998264247304',
      shares: '3999999998264247304'
    },
    {
      token_id: 'usdt.fakes.testnet',
      balance: '5000000000000000000',
      shares: '5000000000000000000'
    }
  ],
  collateral: [],
  borrowed: [],
  farms: []
}
```

'''
'''--- smart-contract/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

perl -i -pe 's/\["cdylib", "rlib"\]/\["cdylib"\]/' contract/Cargo.toml

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/test_oracle.wasm ./res/
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/nearlend.wasm

perl -i -pe 's/\["cdylib"\]/\["cdylib", "rlib"\]/' contract/Cargo.toml

'''
'''--- smart-contract/common/Cargo.toml ---
[package]
name = "common"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[dependencies]
near-sdk = "=4.0.0-pre.7"

'''
'''--- smart-contract/common/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Timestamp};

pub type AssetId = String;
pub type DurationSec = u32;

pub const NO_DEPOSIT: Balance = 0;
pub const ONE_YOCTO: Balance = 1;

const MAX_VALID_DECIMALS: u8 = 77;

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    #[serde(with = "u128_dec_format")]
    pub multiplier: Balance,
    pub decimals: u8,
}

impl Price {
    pub fn assert_valid(&self) {
        assert!(self.decimals <= MAX_VALID_DECIMALS);
    }
}

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub fn to_nano(ts: u32) -> Timestamp {
    Timestamp::from(ts) * 10u64.pow(9)
}

'''
'''--- smart-contract/contract/API.md ---
# The list of APIs that are provided by the contract

Notes:
- `u128_dec_format`, `WrappedBalance`, `Shares` means the value is passed as a decimal string representation. E.g. `1` serialized as `"1"`
- `BigDecimal` is serialized as floating string representation. E.g. `1.5` serialized as `"1.5"`
- `u64` means the value is passed as an integer.
- `Option<_>` means the value can be omitted, or provided as `null`.
- Rust enums are serialized using JSON objects. E.g. `FarmId::Supplied("token.near")` is serialized as `{"Supplied": "token.near"}`
- `HashMap<_, _>` is serialized using JSON objects.

```rust
trait Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    fn new(config: Config) -> Self;

    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    fn get_account(&self, account_id: ValidAccountId) -> Option<AccountDetailedView>;

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account>;

    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    fn execute(&mut self, actions: Vec<Action>);

    /// Returns a detailed view asset for a given token_id.
    /// The detailed view includes current APR and corresponding farms.
    fn get_asset(&self, token_id: ValidAccountId) -> Option<AssetDetailedView>;

    /// Returns an list of detailed view assets a given list of token_id.
    /// Only returns existing assets.
    fn get_assets(&self, token_ids: Vec<ValidAccountId>) -> Vec<AssetDetailedView>;

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)>;

    /// Returns a list of detailed view assets from a given index up to a given limit.
    fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView>;

    /// Returns the current config.
    fn get_config(&self) -> Config;

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_config(&mut self, config: Config);

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn update_asset(&mut self, token_id: ValidAccountId, asset_config: AssetConfig);

    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: ValidAccountId, data: PriceData, msg: String);

    /// Claims all unclaimed farm rewards.
    fn account_farm_claim_all(&mut self);

    /// Returns an asset farm for a given farm ID.
    fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm>;

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)>;

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)>;

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        token_id: ValidAccountId,
        new_reward_per_day: WrappedBalance,
        new_booster_log_base: WrappedBalance,
        extra_amount: WrappedBalance,
    );
}
```

## Structures and types

```rust
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

/// Limited view of the account structure for liquidations
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
}

pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
}

pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<WrappedBalance>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<WrappedBalance>,
}

/// Contract config
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: ValidAccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: ValidAccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: ValidAccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    /// The entire amount will be deposited to the asset reserve. 
    DepositToReserve,
}

enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

pub type TokenId = AccountId;
```

## Also storage management

```rust
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available Ⓝ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregestering the account is not allowed to not break the order of accounts.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}
```

'''
'''--- smart-contract/contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"
uint = { version = "0.9.0", default-features = false }
common = { path = "../common/" }
once_cell = "1.8.0"

[dev-dependencies]
rand = "0.8"

'''
'''--- smart-contract/contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    /// It's not returned for account pagination.
    #[serde(skip_serializing)]
    pub supplied: UnorderedMap<TokenId, VAccountAsset>,
    /// A list of collateral assets.
    pub collateral: Vec<CollateralAsset>,
    /// A list of borrowed assets.
    pub borrowed: Vec<BorrowedAsset>,
    /// Keeping track of data required for farms for this account.
    #[serde(skip_serializing)]
    pub farms: UnorderedMap<FarmId, VAccountFarm>,
    #[borsh_skip]
    #[serde(skip_serializing)]
    pub affected_farms: Vec<FarmId>,

    /// Tracks changes in storage usage by persistent collections in this account.
    #[borsh_skip]
    #[serde(skip)]
    pub storage_tracker: StorageTracker,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v: VAccount) -> Self {
        match v {
            VAccount::Current(c) => c,
        }
    }
}

impl From<Account> for VAccount {
    fn from(c: Account) -> Self {
        VAccount::Current(c)
    }
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: UnorderedMap::new(StorageKey::AccountAssets {
                account_id: account_id.clone(),
            }),
            collateral: vec![],
            borrowed: vec![],
            farms: UnorderedMap::new(StorageKey::AccountFarms {
                account_id: account_id.clone(),
            }),
            affected_farms: vec![],
            storage_tracker: Default::default(),
        }
    }

    pub fn increase_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(collateral) = self.collateral.iter_mut().find(|c| &c.token_id == token_id) {
            collateral.shares.0 += shares.0;
        } else {
            self.collateral.push(CollateralAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_collateral(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .collateral
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Collateral not found");
        if let Some(new_balance) = self.collateral[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.collateral[index].shares.0 = new_balance;
            } else {
                self.collateral.swap_remove(index);
            }
        } else {
            env::panic_str("Not enough collateral balance");
        }
    }

    pub fn increase_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        if let Some(borrowed) = self.borrowed.iter_mut().find(|c| &c.token_id == token_id) {
            borrowed.shares.0 += shares.0;
        } else {
            self.borrowed.push(BorrowedAsset {
                token_id: token_id.clone(),
                shares,
            })
        }
    }

    pub fn decrease_borrowed(&mut self, token_id: &TokenId, shares: Shares) {
        let index = self
            .borrowed
            .iter()
            .position(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found");
        if let Some(new_balance) = self.borrowed[index].shares.0.checked_sub(shares.0) {
            if new_balance > 0 {
                self.borrowed[index].shares.0 = new_balance;
            } else {
                self.borrowed.swap_remove(index);
            }
        } else {
            env::panic_str("Not enough borrowed balance");
        }
    }

    pub fn internal_unwrap_collateral(&mut self, token_id: &TokenId) -> Shares {
        self.collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Collateral not found")
            .shares
    }

    pub fn internal_unwrap_borrowed(&mut self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|c| &c.token_id == token_id)
            .expect("Borrowed asset not found")
            .shares
    }

    pub fn add_affected_farm(&mut self, farm_id: FarmId) {
        if !self.affected_farms.contains(&farm_id) {
            self.affected_farms.push(farm_id);
        }
    }

    pub fn add_all_affected_farms(&mut self) {
        let len = self.affected_farms.len();
        for farm_id in self.farms.keys() {
            if len == 0
                || self
                    .affected_farms
                    .iter()
                    .take(len)
                    .find(|f| *f == &farm_id)
                    .is_none()
            {
                self.affected_farms.push(farm_id);
            }
        }
    }

    pub fn get_supplied_shares(&self, token_id: &TokenId) -> Shares {
        let collateral_shares = self
            .collateral
            .iter()
            .find(|c| &c.token_id == token_id)
            .map(|ca| ca.shares.0)
            .unwrap_or(0);
        let supplied_shares = self
            .internal_get_asset(token_id)
            .map(|asset| asset.shares.0)
            .unwrap_or(0);
        (supplied_shares + collateral_shares).into()
    }

    pub fn get_borrowed_shares(&self, token_id: &TokenId) -> Shares {
        self.borrowed
            .iter()
            .find(|b| &b.token_id == token_id)
            .map(|ba| ba.shares)
            .unwrap_or(0.into())
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CollateralAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BorrowedAsset {
    pub token_id: TokenId,
    pub shares: Shares,
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(&mut self, account_id: &AccountId, mut account: Account) {
        let mut storage = self.internal_unwrap_storage(account_id);
        storage
            .storage_tracker
            .consume(&mut account.storage_tracker);
        storage.storage_tracker.start();
        self.accounts.insert(account_id, &account.into());
        storage.storage_tracker.stop();
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets, collateral and borrowed.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: AccountId) -> Option<AccountDetailedView> {
        self.internal_get_account(&account_id)
            .map(|account| self.account_into_detailed_view(account))
    }

    /// Returns limited account information for accounts from a given index up to a given limit.
    /// The information includes number of shares for collateral and borrowed assets.
    /// This method can be used to iterate on the accounts for liquidation.
    pub fn get_accounts_paged(&self, from_index: Option<u64>, limit: Option<u64>) -> Vec<Account> {
        let values = self.accounts.values_as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(values.len());
        (from_index..std::cmp::min(values.len(), limit))
            .map(|index| values.get(index).unwrap().into())
            .collect()
    }

    /// Returns the number of accounts
    pub fn get_num_accounts(&self) -> u32 {
        self.accounts.len() as _
    }
}

'''
'''--- smart-contract/contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountAsset {
    Current(AccountAsset),
}

impl From<VAccountAsset> for AccountAsset {
    fn from(v: VAccountAsset) -> Self {
        match v {
            VAccountAsset::Current(c) => c,
        }
    }
}

impl From<AccountAsset> for VAccountAsset {
    fn from(c: AccountAsset) -> Self {
        VAccountAsset::Current(c)
    }
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic_str("Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied.get(token_id).map(|o| o.into())
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        self.storage_tracker.start();
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id, &account_asset.into());
        }
        self.storage_tracker.stop();
        self.add_affected_farm(FarmId::Supplied(token_id.clone()));
    }
}

'''
'''--- smart-contract/contract/src/account_farm.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Hash, Eq, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum FarmId {
    Supplied(TokenId),
    Borrowed(TokenId),
}

impl FarmId {
    pub fn get_token_id(&self) -> &TokenId {
        match self {
            FarmId::Supplied(token_id) => token_id,
            FarmId::Borrowed(token_id) => token_id,
        }
    }
}

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarm {
    pub block_timestamp: Timestamp,
    pub rewards: HashMap<TokenId, AccountFarmReward>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountFarmReward {
    pub boosted_shares: Balance,
    pub last_reward_per_share: BigDecimal,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccountFarm {
    Current(AccountFarm),
}

impl From<VAccountFarm> for AccountFarm {
    fn from(v: VAccountFarm) -> Self {
        match v {
            VAccountFarm::Current(c) => c,
        }
    }
}

impl From<AccountFarm> for VAccountFarm {
    fn from(c: AccountFarm) -> Self {
        VAccountFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_account_farm_claim(
        &self,
        account: &Account,
        farm_id: &FarmId,
        asset_farm: &AssetFarm,
    ) -> (
        AccountFarm,
        Vec<(TokenId, Balance)>,
        Vec<(TokenId, Balance)>,
    ) {
        let mut new_rewards = vec![];
        let mut inactive_rewards = vec![];
        let block_timestamp = env::block_timestamp();
        let mut account_farm: AccountFarm = account
            .farms
            .get(farm_id)
            .map(|v| v.into())
            .unwrap_or_else(|| AccountFarm {
                block_timestamp: 0,
                rewards: HashMap::new(),
            });
        if account_farm.block_timestamp != block_timestamp {
            account_farm.block_timestamp = block_timestamp;
            let mut old_rewards = std::mem::take(&mut account_farm.rewards);
            for (
                token_id,
                AssetFarmReward {
                    reward_per_share, ..
                },
            ) in &asset_farm.rewards
            {
                let boosted_shares = if let Some(AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                }) = old_rewards.remove(token_id)
                {
                    let diff = reward_per_share.clone() - last_reward_per_share;
                    let amount = diff.round_mul_u128(boosted_shares);
                    if amount > 0 {
                        new_rewards.push((token_id.clone(), amount));
                    }
                    boosted_shares
                } else {
                    0
                };
                account_farm.rewards.insert(
                    token_id.clone(),
                    AccountFarmReward {
                        boosted_shares,
                        last_reward_per_share: reward_per_share.clone(),
                    },
                );
            }
            for (
                token_id,
                AccountFarmReward {
                    boosted_shares,
                    last_reward_per_share,
                },
            ) in old_rewards
            {
                let AssetFarmReward {
                    reward_per_share, ..
                } = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                let diff = reward_per_share - last_reward_per_share;
                let amount = diff.round_mul_u128(boosted_shares);
                inactive_rewards.push((token_id.clone(), boosted_shares));
                if amount > 0 {
                    new_rewards.push((token_id, amount));
                }
            }
        }
        (account_farm, new_rewards, inactive_rewards)
    }

    pub fn internal_account_apply_affected_farms(
        &mut self,
        account: &mut Account,
        verify_booster: bool,
    ) {
        let config = self.internal_config();
        if verify_booster
            && account
                .affected_farms
                .contains(&FarmId::Supplied(config.booster_token_id.clone()))
        {
            account.add_all_affected_farms();
        }
        if account.affected_farms.is_empty() {
            return;
        }
        let mut all_rewards: HashMap<TokenId, Balance> = HashMap::new();
        let mut i = 0;
        let mut farms = vec![];
        while i < account.affected_farms.len() {
            let farm_id = account.affected_farms[i].clone();
            if let Some(asset_farm) = self.internal_get_asset_farm(&farm_id, false) {
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(account, &farm_id, &asset_farm);
                for (token_id, amount) in new_rewards {
                    let new_farm_id = FarmId::Supplied(token_id.clone());
                    account.add_affected_farm(new_farm_id);
                    *all_rewards.entry(token_id).or_default() += amount;
                }
                farms.push((farm_id, account_farm, asset_farm, inactive_rewards));
            }
            i += 1;
        }
        for (token_id, &reward) in &all_rewards {
            self.internal_deposit(account, &token_id, reward);
        }
        let booster_balance = self
            .internal_get_asset(&config.booster_token_id)
            .map(|booster| {
                booster
                    .supplied
                    .shares_to_amount(account.get_supplied_shares(&config.booster_token_id), false)
            })
            .unwrap_or(0);
        let booster_base = 10u128.pow(config.booster_decimals as u32);

        for (farm_id, mut account_farm, mut asset_farm, inactive_rewards) in farms {
            let shares = match &farm_id {
                FarmId::Supplied(token_id) => account.get_supplied_shares(token_id).0,
                FarmId::Borrowed(token_id) => account.get_borrowed_shares(token_id).0,
            };
            for (token_id, asset_farm_reward) in asset_farm.rewards.iter_mut() {
                let account_farm_reward = account_farm.rewards.get_mut(token_id).unwrap();
                asset_farm_reward.boosted_shares -= account_farm_reward.boosted_shares;
                if shares > 0 {
                    let extra_shares = if booster_balance > booster_base {
                        let log_base =
                            (asset_farm_reward.booster_log_base as f64) / (booster_base as f64);
                        ((shares as f64)
                            * ((booster_balance as f64) / (booster_base as f64)).log(log_base))
                            as u128
                    } else {
                        0
                    };
                    account_farm_reward.boosted_shares = shares + extra_shares;
                    asset_farm_reward.boosted_shares += account_farm_reward.boosted_shares;
                }
            }
            for (token_id, boosted_shares) in inactive_rewards {
                let mut asset_farm_reward = asset_farm
                    .internal_get_inactive_asset_farm_reward(&token_id)
                    .unwrap();
                asset_farm_reward.boosted_shares -= boosted_shares;
                asset_farm.internal_set_inactive_asset_farm_reward(&token_id, asset_farm_reward);
            }
            account.storage_tracker.start();
            if shares > 0 {
                account.farms.insert(&farm_id, &account_farm.into());
            } else {
                account.farms.remove(&farm_id);
            }
            account.storage_tracker.stop();
            self.internal_set_asset_farm(&farm_id, asset_farm);
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Claims all unclaimed farm rewards.
    pub fn account_farm_claim_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&env::predecessor_account_id());
        account.add_all_affected_farms();
        self.internal_account_apply_affected_farms(&mut account, false);
        self.internal_set_account(&account_id, account);
    }
}

'''
'''--- smart-contract/contract/src/account_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetView {
    pub token_id: TokenId,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    /// The number of shares this account holds in the corresponding asset pool
    pub shares: Shares,
    /// The current APR for this asset (either supply or borrow APR).
    pub apr: BigDecimal,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountDetailedView {
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account (but not used a collateral).
    pub supplied: Vec<AssetView>,
    /// A list of assets that are used as a collateral.
    pub collateral: Vec<AssetView>,
    /// A list of assets that are borrowed.
    pub borrowed: Vec<AssetView>,
    /// Account farms
    pub farms: Vec<AccountFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmView {
    pub farm_id: FarmId,
    pub rewards: Vec<AccountFarmRewardView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountFarmRewardView {
    pub reward_token_id: TokenId,
    pub asset_farm_reward: AssetFarmReward,
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(with = "u128_dec_format")]
    pub unclaimed_amount: Balance,
}

impl Contract {
    pub fn account_into_detailed_view(&self, account: Account) -> AccountDetailedView {
        let farms = account
            .farms
            .keys()
            .map(|farm_id| {
                let mut asset_farm = self.internal_unwrap_asset_farm(&farm_id, true);
                let (account_farm, new_rewards, inactive_rewards) =
                    self.internal_account_farm_claim(&account, &farm_id, &asset_farm);
                AccountFarmView {
                    farm_id,
                    rewards: account_farm
                        .rewards
                        .into_iter()
                        .map(|(token_id, AccountFarmReward { boosted_shares, .. })| {
                            (token_id, boosted_shares)
                        })
                        .chain(inactive_rewards)
                        .map(|(reward_token_id, boosted_shares)| {
                            let asset_farm_reward = asset_farm
                                .rewards
                                .remove(&reward_token_id)
                                .or_else(|| {
                                    asset_farm
                                        .internal_get_inactive_asset_farm_reward(&reward_token_id)
                                })
                                .unwrap();
                            let unclaimed_amount = new_rewards
                                .iter()
                                .find(|(token_id, _)| token_id == &reward_token_id)
                                .map(|(_, amount)| *amount)
                                .unwrap_or(0);
                            AccountFarmRewardView {
                                reward_token_id,
                                asset_farm_reward,
                                boosted_shares,
                                unclaimed_amount,
                            }
                        })
                        .collect(),
                }
            })
            .collect();
        AccountDetailedView {
            account_id: account.account_id,
            supplied: unordered_map_pagination(&account.supplied, None, None)
                .into_iter()
                .map(|(token_id, AccountAsset { shares })| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            collateral: account
                .collateral
                .into_iter()
                .map(|CollateralAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, false)
                })
                .collect(),
            borrowed: account
                .borrowed
                .into_iter()
                .map(|BorrowedAsset { token_id, shares }| {
                    self.get_asset_view(token_id, shares, true)
                })
                .collect(),
            farms,
        }
    }

    fn get_asset_view(&self, token_id: TokenId, shares: Shares, is_borrowing: bool) -> AssetView {
        let asset = self.internal_unwrap_asset(&token_id);
        let apr = if is_borrowing {
            asset.get_borrow_apr()
        } else {
            asset.get_supply_apr()
        };
        let balance = if is_borrowing {
            asset.borrowed.shares_to_amount(shares, true)
        } else {
            asset.supplied.shares_to_amount(shares, false)
        };

        AssetView {
            token_id,
            balance,
            shares,
            apr,
        }
    }
}

'''
'''--- smart-contract/contract/src/actions.rs ---
use crate::*;

const MAX_NUM_ASSETS: usize = 10;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetAmount {
    pub token_id: TokenId,
    /// The amount of tokens intended to be used for the action.
    /// If `None`, then the maximum amount will be tried.
    pub amount: Option<U128>,
    /// The maximum amount of tokens that can be used for the action.
    /// If `None`, then the maximum `available` amount will be used.
    pub max_amount: Option<U128>,
}

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Withdraw(AssetAmount),
    IncreaseCollateral(AssetAmount),
    DecreaseCollateral(AssetAmount),
    Borrow(AssetAmount),
    Repay(AssetAmount),
    Liquidate {
        account_id: AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    },
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        let mut need_risk_check = false;
        let mut need_number_check = false;
        for action in actions {
            match action {
                Action::Withdraw(asset_amount) => {
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    let amount = self.internal_withdraw(account, &asset_amount);
                    self.internal_ft_transfer(account_id, &asset_amount.token_id, amount);
                    log!(
                        "Account {} withdraws {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::IncreaseCollateral(asset_amount) => {
                    need_number_check = true;
                    let amount = self.internal_increase_collateral(account, &asset_amount);
                    log!(
                        "Account {} increases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::DecreaseCollateral(asset_amount) => {
                    need_risk_check = true;
                    let mut account_asset =
                        account.internal_get_asset_or_default(&asset_amount.token_id);
                    let amount = self.internal_decrease_collateral(
                        &mut account_asset,
                        account,
                        &asset_amount,
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                    log!(
                        "Account {} decreases collateral {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Borrow(asset_amount) => {
                    need_number_check = true;
                    need_risk_check = true;
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_borrow(account, &asset_amount);
                    log!(
                        "Account {} borrows {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                }
                Action::Repay(asset_amount) => {
                    let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
                    account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
                    account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
                    let amount = self.internal_repay(&mut account_asset, account, &asset_amount);
                    log!(
                        "Account {} repays {} of {}",
                        account_id,
                        amount,
                        asset_amount.token_id
                    );
                    account.internal_set_asset(&asset_amount.token_id, account_asset);
                }
                Action::Liquidate {
                    account_id: liquidation_account_id,
                    in_assets,
                    out_assets,
                } => {
                    assert_ne!(
                        account_id, &liquidation_account_id,
                        "Can't liquidate yourself"
                    );
                    assert!(!in_assets.is_empty() && !out_assets.is_empty());
                    self.internal_liquidate(
                        account_id,
                        account,
                        &prices,
                        &liquidation_account_id,
                        in_assets,
                        out_assets,
                    );
                }
            }
        }
        if need_number_check {
            assert!(account.collateral.len() + account.borrowed.len() <= MAX_NUM_ASSETS);
        }
        if need_risk_check {
            assert!(self.compute_max_discount(account, &prices) == BigDecimal::zero());
        }

        self.internal_account_apply_affected_farms(account, true);
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }

    pub fn internal_withdraw(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_withdraw,
            "Withdrawals for this asset are not enabled"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        let available_amount = asset.available_amount();

        assert!(
            amount <= available_amount,
            "Withdraw error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        asset.supplied.withdraw(shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        amount
    }

    pub fn internal_increase_collateral(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(
            asset.config.can_use_as_collateral,
            "Thi asset can't be used as a collateral"
        );

        let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, account_asset.shares, &asset_amount, false);

        account_asset.withdraw_shares(shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        account.increase_collateral(&asset_amount.token_id, shares);

        amount
    }

    pub fn internal_decrease_collateral(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let collateral_shares = account.internal_unwrap_collateral(&asset_amount.token_id);

        let (shares, amount) =
            asset_amount_to_shares(&asset.supplied, collateral_shares, &asset_amount, false);

        account.decrease_collateral(&asset_amount.token_id, shares);

        account_asset.deposit_shares(shares);

        amount
    }

    pub fn internal_borrow(
        &mut self,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        assert!(asset.config.can_borrow, "Thi asset can't be used borrowed");

        let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);

        let available_amount = asset.available_amount();
        let max_borrow_shares = asset.borrowed.amount_to_shares(available_amount, false);

        let (borrowed_shares, amount) =
            asset_amount_to_shares(&asset.borrowed, max_borrow_shares, &asset_amount, true);

        assert!(
            amount <= available_amount,
            "Borrow error: Exceeded available amount {} of {}",
            available_amount,
            &asset_amount.token_id
        );

        let supplied_shares: Shares = asset.supplied.amount_to_shares(amount, false);

        asset.borrowed.deposit(borrowed_shares, amount);
        asset.supplied.deposit(supplied_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.increase_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.deposit_shares(supplied_shares);
        account.internal_set_asset(&asset_amount.token_id, account_asset);

        amount
    }

    pub fn internal_repay(
        &mut self,
        account_asset: &mut AccountAsset,
        account: &mut Account,
        asset_amount: &AssetAmount,
    ) -> Balance {
        let mut asset = self.internal_unwrap_asset(&asset_amount.token_id);
        let available_borrowed_shares = account.internal_unwrap_borrowed(&asset_amount.token_id);

        let (mut borrowed_shares, mut amount) = asset_amount_to_shares(
            &asset.borrowed,
            available_borrowed_shares,
            &asset_amount,
            true,
        );

        let mut supplied_shares = asset.supplied.amount_to_shares(amount, true);
        if supplied_shares.0 > account_asset.shares.0 {
            supplied_shares = account_asset.shares;
            amount = asset.supplied.shares_to_amount(supplied_shares, false);
            if let Some(min_amount) = &asset_amount.amount {
                assert!(amount >= min_amount.0, "Not enough supplied balance");
            }
            assert!(amount > 0, "Repayment amount can't be 0");

            borrowed_shares = asset.borrowed.amount_to_shares(amount, false);
            assert!(borrowed_shares.0 > 0, "Shares can't be 0");
            assert!(borrowed_shares.0 <= available_borrowed_shares.0);
        }

        asset.supplied.withdraw(supplied_shares, amount);
        asset.borrowed.withdraw(borrowed_shares, amount);
        self.internal_set_asset(&asset_amount.token_id, asset);

        account.decrease_borrowed(&asset_amount.token_id, borrowed_shares);

        account_asset.withdraw_shares(supplied_shares);

        amount
    }

    pub fn internal_liquidate(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        prices: &Prices,
        liquidation_account_id: &AccountId,
        in_assets: Vec<AssetAmount>,
        out_assets: Vec<AssetAmount>,
    ) {
        let mut liquidation_account = self.internal_unwrap_account(liquidation_account_id);

        let max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            max_discount > BigDecimal::zero(),
            "The liquidation account is not at risk"
        );

        let mut borrowed_repaid_sum = BigDecimal::zero();
        let mut collateral_taken_sum = BigDecimal::zero();

        for asset_amount in in_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            liquidation_account.add_affected_farm(FarmId::Borrowed(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_unwrap_asset(&asset_amount.token_id);
            let amount =
                self.internal_repay(&mut account_asset, &mut liquidation_account, &asset_amount);
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            borrowed_repaid_sum = borrowed_repaid_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        for asset_amount in out_assets {
            let asset = self.internal_unwrap_asset(&asset_amount.token_id);
            liquidation_account.add_affected_farm(FarmId::Supplied(asset_amount.token_id.clone()));
            let mut account_asset = account.internal_get_asset_or_default(&asset_amount.token_id);
            let amount = self.internal_decrease_collateral(
                &mut account_asset,
                &mut liquidation_account,
                &asset_amount,
            );
            account.internal_set_asset(&asset_amount.token_id, account_asset);

            collateral_taken_sum = collateral_taken_sum
                + BigDecimal::from_balance_price(
                    amount,
                    prices.get_unwrap(&asset_amount.token_id),
                    asset.config.extra_decimals,
                );
        }

        let discounted_collateral_taken = collateral_taken_sum * (BigDecimal::one() - max_discount);
        assert!(
            discounted_collateral_taken <= borrowed_repaid_sum,
            "Not enough balances repaid: discounted collateral {} > borrowed repaid sum {}",
            discounted_collateral_taken,
            borrowed_repaid_sum
        );

        let new_max_discount = self.compute_max_discount(&liquidation_account, &prices);
        assert!(
            new_max_discount > BigDecimal::zero(),
            "The liquidation amount is too large. The liquidation account should stay in risk"
        );

        self.internal_account_apply_affected_farms(&mut liquidation_account, true);
        self.internal_set_account(liquidation_account_id, liquidation_account);

        log!(
            "Account {} liquidates account {}: takes {} for repaying {}",
            account_id,
            liquidation_account_id,
            collateral_taken_sum,
            borrowed_repaid_sum
        );
    }

    pub fn compute_max_discount(&self, account: &Account, prices: &Prices) -> BigDecimal {
        if account.borrowed.is_empty() {
            return BigDecimal::zero();
        }

        let collateral_sum = account
            .collateral
            .iter()
            .fold(BigDecimal::zero(), |sum, c| {
                let asset = self.internal_unwrap_asset(&c.token_id);
                let balance = asset.supplied.shares_to_amount(c.shares, false);
                sum + BigDecimal::from_balance_price(
                    balance,
                    prices.get_unwrap(&c.token_id),
                    asset.config.extra_decimals,
                )
                .mul_ratio(asset.config.volatility_ratio)
            });

        let borrowed_sum = account.borrowed.iter().fold(BigDecimal::zero(), |sum, b| {
            let asset = self.internal_unwrap_asset(&b.token_id);
            let balance = asset.borrowed.shares_to_amount(b.shares, true);
            sum + BigDecimal::from_balance_price(
                balance,
                prices.get_unwrap(&b.token_id),
                asset.config.extra_decimals,
            )
            .div_ratio(asset.config.volatility_ratio)
        });

        if borrowed_sum <= collateral_sum {
            BigDecimal::zero()
        } else {
            (borrowed_sum - collateral_sum) / borrowed_sum / BigDecimal::from(2u32)
        }
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    asset_amount: &AssetAmount,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = if let Some(amount) = &asset_amount.amount {
        (
            pool.amount_to_shares(amount.0, !inverse_round_direction),
            amount.0,
        )
    } else if let Some(max_amount) = &asset_amount.max_amount {
        let shares = std::cmp::min(
            available_shares.0,
            pool.amount_to_shares(max_amount.0, !inverse_round_direction)
                .0,
        )
        .into();
        (
            shares,
            std::cmp::min(
                pool.shares_to_amount(shares, inverse_round_direction),
                max_amount.0,
            ),
        )
    } else {
        (
            available_shares,
            pool.shares_to_amount(available_shares, inverse_round_direction),
        )
    };
    assert!(shares.0 > 0, "Shares can't be 0");
    assert!(amount > 0, "Amount can't be 0");
    (shares, amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&account_id);
        self.internal_execute(&account_id, &mut account, actions, Prices::new());
        self.internal_set_account(&account_id, account);
    }
}

'''
'''--- smart-contract/contract/src/asset.rs ---
use crate::*;

pub const MS_PER_YEAR: u64 = 31536000000;

static ASSETS: Lazy<Mutex<HashMap<TokenId, Option<Asset>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAsset {
    Current(Asset),
}

impl From<VAsset> for Asset {
    fn from(v: VAsset) -> Self {
        match v {
            VAsset::Current(c) => c,
        }
    }
}

impl From<Asset> for VAsset {
    fn from(c: Asset) -> Self {
        VAsset::Current(c)
    }
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            supplied: Pool::new(),
            borrowed: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn get_rate(&self) -> BigDecimal {
        self.config
            .get_rate(self.borrowed.balance, self.supplied.balance + self.reserved)
    }

    pub fn get_borrow_apr(&self) -> BigDecimal {
        let rate = self.get_rate();
        // 1 + APR = r ** MS_PER_YEAR
        // APR = r ** MS_PER_YEAR - 1
        rate.pow(MS_PER_YEAR) - BigDecimal::one()
    }

    pub fn get_supply_apr(&self) -> BigDecimal {
        if self.supplied.balance == 0 || self.borrowed.balance == 0 {
            return BigDecimal::zero();
        }

        let borrow_apr = self.get_borrow_apr();
        if borrow_apr == BigDecimal::zero() {
            return borrow_apr;
        }

        // interest(lãi suất) =  APR(borrow)* borrowed.balanced(tài sản đang mượn)
        let interest = borrow_apr.round_mul_u128(self.borrowed.balance);

        log!("interest: {}", interest);
        // tổng lãi suất  
        let supply_interest = ratio(interest, MAX_RATIO - self.config.reserve_ratio);
        log!("supply_interest: {}", supply_interest);
        log!("supply_apr: {}", BigDecimal::from(supply_interest).div_u128(self.supplied.balance));
        BigDecimal::from(supply_interest).div_u128(self.supplied.balance)
    }

    // n = 31536000000 ms in a year (365 days)
    //
    // Compute `r` from `X`. `X` is desired APY
    // (1 + r / n) ** n = X (2 == 200%)
    // n * log(1 + r / n) = log(x)
    // log(1 + r / n) = log(x) / n
    // log(1 + r  / n) = log( x ** (1 / n))
    // 1 + r / n = x ** (1 / n)
    // r / n = (x ** (1 / n)) - 1
    // r = n * ((x ** (1 / n)) - 1)
    // n = in millis
    fn compound(&mut self, time_diff_ms: Duration) {
        let rate = self.get_rate();
        let interest =
            rate.pow(time_diff_ms).round_mul_u128(self.borrowed.balance) - self.borrowed.balance;
        // TODO: Split interest based on ratio between reserved and supplied?
        let reserved = ratio(interest, self.config.reserve_ratio);
        if self.supplied.shares.0 > 0 {
            self.supplied.balance += interest - reserved;
            self.reserved += reserved;
        } else {
            self.reserved += interest;
        }
        self.borrowed.balance += interest;
    }

    pub fn update(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff_ms = nano_to_ms(timestamp - self.last_update_timestamp);
        if time_diff_ms > 0 {
            // update
            self.last_update_timestamp += ms_to_nano(time_diff_ms);
            self.compound(time_diff_ms);
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.borrowed.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        let mut cache = ASSETS.lock().unwrap();
        cache.get(token_id).cloned().unwrap_or_else(|| {
            let asset = self.assets.get(token_id).map(|o| {
                let mut asset: Asset = o.into();
                asset.update();
                asset
            });
            cache.insert(token_id.clone(), asset.clone());
            asset
        })
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, mut asset: Asset) {
        if asset.supplied.shares.0 == 0 && asset.supplied.balance > 0 {
            asset.reserved += asset.supplied.balance;
            asset.supplied.balance = 0;
        }
        assert!(
            asset.borrowed.shares.0 > 0 || asset.borrowed.balance == 0,
            "Borrowed invariant broken"
        );
        ASSETS
            .lock()
            .unwrap()
            .insert(token_id.clone(), Some(asset.clone()));
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset for a given token_id.
    pub fn get_asset(&self, token_id: AccountId) -> Option<AssetDetailedView> {
        self.internal_get_asset(&token_id)
            .map(|asset| self.asset_into_detailed_view(token_id, asset))
    }

    /// Returns an list of pairs (token_id, asset) for assets a given list of token_id.
    /// Only returns pais for existing assets.
    pub fn get_assets(&self, token_ids: Vec<AccountId>) -> Vec<AssetDetailedView> {
        token_ids
            .into_iter()
            .filter_map(|token_id| {
                self.internal_get_asset(&token_id)
                    .map(|asset| self.asset_into_detailed_view(token_id, asset))
            })
            .collect()
    }

    /// Returns a list of pairs (token_id, asset) for assets from a given index up to a given limit.
    pub fn get_assets_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(TokenId, Asset)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let key = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&key).unwrap().into();
                asset.update();
                (key, asset)
            })
            .collect()
    }

    pub fn get_assets_paged_detailed(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<AssetDetailedView> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        (from_index..std::cmp::min(keys.len(), limit))
            .map(|index| {
                let token_id = keys.get(index).unwrap();
                let mut asset: Asset = self.assets.get(&token_id).unwrap().into();
                asset.update();
                self.asset_into_detailed_view(token_id, asset)
            })
            .collect()
    }
}

'''
'''--- smart-contract/contract/src/asset_config.rs ---
use crate::*;

const MAX_POS: u32 = 10000;
const MAX_RATIO: u32 = 10000;

/// Represents an asset config.
/// Example:
/// 25% reserve, 80% target utilization, 12% target APR, 250% max APR, 60% vol
/// no extra decimals, can be deposited, withdrawn, used as a collateral, borrowed
/// JSON:
/// ```json
/// {
///   "reserve_ratio": 2500,
///   "target_utilization": 8000,
///   "target_utilization_rate": "1000000000003593629036885046",
///   "max_utilization_rate": "1000000000039724853136740579",
///   "volatility_ratio": 6000,
///   "extra_decimals": 0,
///   "can_deposit": true,
///   "can_withdraw": true,
///   "can_use_as_collateral": true,
///   "can_borrow": true
/// }
/// ```
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from borrowed interests goes to the reserve.
    pub reserve_ratio: u32,
    /// Target utilization ratio (multiplied by 10000).
    /// E.g. 8000 means the protocol targets 80% of assets are borrowed.
    pub target_utilization: u32,
    /// The compounding rate at target utilization ratio.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000003593629036885046" for 12% APR.
    pub target_utilization_rate: LowU128,
    /// The compounding rate at 100% utilization.
    /// Use `apr_to_rate.py` script to compute the value for a given APR.
    /// Given as a decimal string. E.g. "1000000000039724853136740579" for 250% APR.
    pub max_utilization_rate: LowU128,
    /// Volatility ratio (multiplied by 10000).
    /// It defines which percentage collateral that covers borrowing as well as which percentage of
    /// borrowed asset can be taken.
    /// E.g. 6000 means 60%. If an account has 100 $ABC in collateral and $ABC is at 10$ per token,
    /// the collateral value is 1000$, but the borrowing power is 60% or $600.
    /// Now if you're trying to borrow $XYZ and it's volatility ratio is 80%, then you can only
    /// borrow less than 80% of $600 = $480 of XYZ before liquidation can begin.
    pub volatility_ratio: u32,
    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
    /// Whether this assets can be used as collateral.
    pub can_use_as_collateral: bool,
    /// Whether this assets can be borrowed.
    pub can_borrow: bool,
}

impl AssetConfig {
    pub fn assert_valid(&self) {
        assert!(self.reserve_ratio <= MAX_RATIO);
        assert!(self.target_utilization < MAX_POS);
        assert!(self.target_utilization_rate.0 <= self.max_utilization_rate.0);
    }

    pub fn get_rate(
        &self,
        borrowed_balance: Balance,
        total_supplied_balance: Balance,
    ) -> BigDecimal {
        if total_supplied_balance == 0 {
            BigDecimal::one()
        } else {
            // utilization = (supplied + reserved) / borrowed
            // total_supplied_balance  = self.supplied.balance + self.reserved
            let pos = BigDecimal::from(borrowed_balance).div_u128(total_supplied_balance);

            let target_utilization = BigDecimal::from_ratio(self.target_utilization);

            // if utilization <= target_utilization, 
            //     r = target_utilization_r * (utilization / target_utilization)
            // if utilization > target_utilization, 
            //     r = target_utilization_r + (max_utilization_r - target_utilization_r) 
            //         * (utilization - target_utilization) / (1 - target_utilization)

            if pos < target_utilization {
                BigDecimal::one()
                    + pos * (BigDecimal::from(self.target_utilization_rate) - BigDecimal::one())
                        / target_utilization
            } else {
                BigDecimal::from(self.target_utilization_rate)
                    + (pos - target_utilization)
                        * (BigDecimal::from(self.max_utilization_rate)
                            - BigDecimal::from(self.target_utilization_rate))
                        / BigDecimal::from_ratio(MAX_POS - self.target_utilization)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const ONE_NEAR: u128 = 10u128.pow(24);

    fn test_config() -> AssetConfig {
        AssetConfig {
            reserve_ratio: 2500,
            target_utilization: 8000,
            target_utilization_rate: 1000000000003593629036885046u128.into(),
            max_utilization_rate: 1000000000039724853136740579u128.into(),
            volatility_ratio: 6000,
            extra_decimals: 0,
            can_deposit: true,
            can_withdraw: true,
            can_use_as_collateral: true,
            can_borrow: true,
        }
    }

    #[test]
    fn test_get_rate_and_apr() {
        let config = test_config();
        let rate = config.get_rate(81 * ONE_NEAR, 100 * ONE_NEAR);
        println!("Rate: {}", rate);

        let apr = rate.pow(MS_PER_YEAR) - BigDecimal::one();
        println!("APR: {}", apr)
    }
}

'''
'''--- smart-contract/contract/src/asset_farm.rs ---
use crate::*;

static ASSET_FARMS: Lazy<Mutex<HashMap<FarmId, Option<AssetFarm>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

const NANOS_PER_DAY: Duration = 24 * 60 * 60 * 10u64.pow(9);

/// A data required to keep track of a farm for an account.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarm {
    #[serde(with = "u64_dec_format")]
    pub block_timestamp: Timestamp,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
    /// Inactive rewards
    #[serde(skip_serializing)]
    pub inactive_rewards: LookupMap<TokenId, VAssetFarmReward>,
}

impl Clone for AssetFarm {
    fn clone(&self) -> Self {
        Self {
            block_timestamp: self.block_timestamp,
            rewards: self.rewards.clone(),
            inactive_rewards: BorshDeserialize::try_from_slice(
                &self.inactive_rewards.try_to_vec().unwrap(),
            )
            .unwrap(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VAssetFarmReward {
    Current(AssetFarmReward),
}

impl From<VAssetFarmReward> for AssetFarmReward {
    fn from(v: VAssetFarmReward) -> Self {
        match v {
            VAssetFarmReward::Current(c) => c,
        }
    }
}

impl From<AssetFarmReward> for VAssetFarmReward {
    fn from(c: AssetFarmReward) -> Self {
        VAssetFarmReward::Current(c)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Serialize, Default)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmReward {
    /// The amount of reward distributed per day.
    #[serde(with = "u128_dec_format")]
    pub reward_per_day: Balance,
    /// The log base for the booster. Used to compute boosted shares per account.
    /// Including decimals of the booster.
    #[serde(with = "u128_dec_format")]
    pub booster_log_base: Balance,

    /// The amount of rewards remaining to distribute.
    #[serde(with = "u128_dec_format")]
    pub remaining_rewards: Balance,

    /// The total number of boosted shares.
    #[serde(with = "u128_dec_format")]
    pub boosted_shares: Balance,
    #[serde(skip)]
    pub reward_per_share: BigDecimal,
}

impl AssetFarm {
    pub fn update(&mut self, is_view: bool) {
        let block_timestamp = env::block_timestamp();
        if block_timestamp == self.block_timestamp {
            return;
        }
        let time_diff = block_timestamp - self.block_timestamp;
        self.block_timestamp = block_timestamp;
        let mut new_inactive_reward = vec![];
        for (token_id, reward) in self.rewards.iter_mut() {
            if reward.boosted_shares == 0 {
                continue;
            }
            let acquired_rewards = std::cmp::min(
                reward.remaining_rewards,
                u128_ratio(
                    reward.reward_per_day,
                    u128::from(time_diff),
                    u128::from(NANOS_PER_DAY),
                ),
            );
            reward.remaining_rewards -= acquired_rewards;
            reward.reward_per_share = reward.reward_per_share
                + BigDecimal::from(acquired_rewards) / BigDecimal::from(reward.boosted_shares);
            if reward.remaining_rewards == 0 {
                new_inactive_reward.push(token_id.clone());
            }
        }
        if !is_view {
            for token_id in new_inactive_reward {
                let reward = self.rewards.remove(&token_id).unwrap();
                self.internal_set_inactive_asset_farm_reward(&token_id, reward);
            }
        }
    }

    pub fn internal_get_inactive_asset_farm_reward(
        &self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.get(token_id).map(|o| o.into())
    }

    pub fn internal_remove_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
    ) -> Option<AssetFarmReward> {
        self.inactive_rewards.remove(token_id).map(|o| o.into())
    }

    pub fn internal_set_inactive_asset_farm_reward(
        &mut self,
        token_id: &TokenId,
        asset_farm_reward: AssetFarmReward,
    ) {
        self.inactive_rewards
            .insert(token_id, &asset_farm_reward.into());
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAssetFarm {
    Current(AssetFarm),
}

impl From<VAssetFarm> for AssetFarm {
    fn from(v: VAssetFarm) -> Self {
        match v {
            VAssetFarm::Current(c) => c,
        }
    }
}

impl From<AssetFarm> for VAssetFarm {
    fn from(c: AssetFarm) -> Self {
        VAssetFarm::Current(c)
    }
}

impl Contract {
    pub fn internal_unwrap_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> AssetFarm {
        self.internal_get_asset_farm(farm_id, is_view)
            .expect("Asset farm not found")
    }

    pub fn internal_get_asset_farm(&self, farm_id: &FarmId, is_view: bool) -> Option<AssetFarm> {
        let mut cache = ASSET_FARMS.lock().unwrap();
        cache.get(farm_id).cloned().unwrap_or_else(|| {
            let asset_farm = self.asset_farms.get(farm_id).map(|v| {
                let mut asset_farm: AssetFarm = v.into();
                asset_farm.update(is_view);
                asset_farm
            });
            cache.insert(farm_id.clone(), asset_farm.clone());
            asset_farm
        })
    }

    pub fn internal_set_asset_farm(&mut self, farm_id: &FarmId, asset_farm: AssetFarm) {
        ASSET_FARMS
            .lock()
            .unwrap()
            .insert(farm_id.clone(), Some(asset_farm.clone()));
        self.asset_farms.insert(farm_id, &asset_farm.into());
    }
}

#[near_bindgen]
impl Contract {
    /// Returns an asset farm for a given farm ID.
    pub fn get_asset_farm(&self, farm_id: FarmId) -> Option<AssetFarm> {
        self.internal_get_asset_farm(&farm_id, true)
    }

    /// Returns a list of pairs (farm ID, asset farm) for a given list of farm IDs.
    pub fn get_asset_farms(&self, farm_ids: Vec<FarmId>) -> Vec<(FarmId, AssetFarm)> {
        farm_ids
            .into_iter()
            .filter_map(|farm_id| {
                self.internal_get_asset_farm(&farm_id, true)
                    .map(|asset_farm| (farm_id, asset_farm))
            })
            .collect()
    }

    /// Returns a list of pairs (farm ID, asset farm) from a given index up to a given limit.
    ///
    /// Note, the number of returned elements may be twice larger than the limit, due to the
    /// pagination implementation. To continue to the next page use `from_index + limit`.
    pub fn get_asset_farms_paged(
        &self,
        from_index: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(FarmId, AssetFarm)> {
        let keys = self.asset_ids.as_vector();
        let from_index = from_index.unwrap_or(0);
        let limit = limit.unwrap_or(keys.len());
        let mut farm_ids = vec![];
        for index in from_index..std::cmp::min(keys.len(), limit) {
            let token_id = keys.get(index).unwrap();
            farm_ids.push(FarmId::Supplied(token_id.clone()));
            farm_ids.push(FarmId::Borrowed(token_id));
        }
        self.get_asset_farms(farm_ids)
    }
}

'''
'''--- smart-contract/contract/src/asset_view.rs ---
use crate::*;

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetDetailedView {
    pub token_id: TokenId,
    /// Total supplied including collateral, but excluding reserved.
    pub supplied: Pool,
    /// Total borrowed.
    pub borrowed: Pool,
    /// The amount reserved for the stability. This amount can also be borrowed and affects
    /// borrowing rate.
    #[serde(with = "u128_dec_format")]
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    #[serde(with = "u64_dec_format")]
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
    /// Current APR excluding farms for supplying the asset.
    pub supply_apr: BigDecimal,
    /// Current APR excluding farms for borrowing the asset.
    pub borrow_apr: BigDecimal,
    /// Asset farms
    pub farms: Vec<AssetFarmView>,
}

#[derive(Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetFarmView {
    pub farm_id: FarmId,
    /// Active rewards for the farm
    pub rewards: HashMap<TokenId, AssetFarmReward>,
}

impl Contract {
    pub fn asset_into_detailed_view(&self, token_id: TokenId, asset: Asset) -> AssetDetailedView {
        let farms = self
            .get_asset_farms(vec![
                FarmId::Supplied(token_id.clone()),
                FarmId::Borrowed(token_id.clone()),
            ])
            .into_iter()
            .map(|(farm_id, asset_farm)| AssetFarmView {
                farm_id,
                rewards: asset_farm.rewards,
            })
            .collect();
        let supply_apr = asset.get_supply_apr();
        let borrow_apr = asset.get_borrow_apr();
        let Asset {
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
        } = asset;
        AssetDetailedView {
            token_id,
            supplied,
            borrowed,
            reserved,
            last_update_timestamp,
            config,
            supply_apr,
            borrow_apr,
            farms,
        }
    }
}

'''
'''--- smart-contract/contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
#[cfg(not(target_arch = "wasm32"))]
use std::str::FromStr;

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

#[cfg(not(target_arch = "wasm32"))]
const PARSE_INT_ERROR: &'static str = "Parse int error";

#[cfg(not(target_arch = "wasm32"))]
impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<27}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(&int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Ok(Self::from_str(&s).map_err(|err| near_sdk::serde::de::Error::custom(err))?)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn from_balance_price(balance: Balance, price: &Price, extra_decimals: u8) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        let denominator_decimals = price.decimals + extra_decimals;
        if denominator_decimals > NUM_DECIMALS {
            Self(num / U384::exp10((denominator_decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - denominator_decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = MS_PER_YEAR;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- smart-contract/contract/src/config.rs ---
use crate::*;

/// Contract config
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the oracle contract
    pub oracle_account_id: AccountId,

    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: AccountId,

    /// The account ID of the booster token contract.
    pub booster_token_id: TokenId,

    /// The number of decimals of the booster fungible token.
    pub booster_decimals: u8,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.internal_config().owner_id,
            "Not an owner"
        );
    }
}

#[near_bindgen]
impl Contract {
    /// Returns the current config.
    pub fn get_config(&self) -> Config {
        self.internal_config()
    }

    /// Updates the current config.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_config(&mut self, config: Config) {
        assert_one_yocto();
        self.assert_owner();
        self.config.set(&config);
    }

    /// Adds an asset with a given token_id and a given asset_config.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id already exists.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset(&mut self, token_id: AccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        assert!(self.asset_ids.insert(&token_id));
        self.internal_set_asset(&token_id, Asset::new(env::block_timestamp(), asset_config))
    }

    /// Updates the asset config for the asset with the a given token_id.
    /// - Panics if the asset config is invalid.
    /// - Panics if an asset with the given token_id doesn't exist.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn update_asset(&mut self, token_id: AccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        asset_config.assert_valid();
        self.assert_owner();
        let mut asset = self.internal_unwrap_asset(&token_id);
        asset.config = asset_config;
        self.internal_set_asset(&token_id, asset);
    }

    /// Adds an asset farm reward for the farm with a given farm_id. The reward is of token_id with
    /// the new reward per day amount and a new booster log base. The extra amount of reward is
    /// taken from the asset reserved balance.
    /// - The booster log base should include decimals of the token for better precision of the log
    ///    base. For example, if token decimals is `6` the log base of `10_500_000` will be `10.5`.
    /// - Panics if the farm asset token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't exists.
    /// - Panics if an asset with the given token_id doesn't have enough reserved balance.
    /// - Requires one yoctoNEAR.
    /// - Requires to be called by the contract owner.
    #[payable]
    pub fn add_asset_farm_reward(
        &mut self,
        farm_id: FarmId,
        reward_token_id: AccountId,
        new_reward_per_day: U128,
        new_booster_log_base: U128,
        reward_amount: U128,
    ) {
        assert_one_yocto();
        self.assert_owner();
        assert!(self.assets.contains_key(farm_id.get_token_id()));
        let reward_token_id: TokenId = reward_token_id.into();
        let mut reward_asset = self.internal_unwrap_asset(&reward_token_id);
        assert!(
            reward_asset.reserved >= reward_amount.0
                && reward_asset.available_amount() >= reward_amount.0,
            "Not enough reserved reward balance"
        );
        reward_asset.reserved -= reward_amount.0;
        self.internal_set_asset(&reward_token_id, reward_asset);
        let mut asset_farm = self
            .internal_get_asset_farm(&farm_id, false)
            .unwrap_or_else(|| AssetFarm {
                block_timestamp: env::block_timestamp(),
                rewards: HashMap::new(),
                inactive_rewards: LookupMap::new(StorageKey::InactiveAssetFarmRewards {
                    farm_id: farm_id.clone(),
                }),
            });

        let mut asset_farm_reward = asset_farm
            .rewards
            .remove(&reward_token_id)
            .or_else(|| asset_farm.internal_remove_inactive_asset_farm_reward(&reward_token_id))
            .unwrap_or_default();
        asset_farm_reward.reward_per_day = new_reward_per_day.into();
        asset_farm_reward.booster_log_base = new_booster_log_base.into();
        asset_farm_reward.remaining_rewards += reward_amount.0;
        asset_farm
            .rewards
            .insert(reward_token_id, asset_farm_reward);
        self.internal_set_asset_farm(&farm_id, asset_farm);
    }
}

'''
'''--- smart-contract/contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::{is_promise_success, serde_json, PromiseOrValue};

const GAS_FOR_FT_TRANSFER: Gas = Gas(Gas::ONE_TERA.0 * 10);
const GAS_FOR_AFTER_FT_TRANSFER: Gas = Gas(Gas::ONE_TERA.0 * 20);

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum TokenReceiverMsg {
    Execute { actions: Vec<Action> },
    DepositToReserve,
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Receives the transfer from the fungible token and executes a list of actions given in the
    /// message on behalf of the sender. The actions that can be executed should be limited to a set
    /// that doesn't require pricing.
    /// - Requires to be called by the fungible token account.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_id = env::predecessor_account_id();
        let mut asset = self.internal_unwrap_asset(&token_id);
        assert!(
            asset.config.can_deposit,
            "Deposits for this asset are not enabled"
        );

        let amount = amount.0 * 10u128.pow(asset.config.extra_decimals as u32);

        // TODO: We need to be careful that only whitelisted tokens can call this method with a
        //     given set of actions. Or verify which actions are possible to do.
        let actions: Vec<Action> = if msg.is_empty() {
            vec![]
        } else {
            let token_receiver_msg: TokenReceiverMsg =
                serde_json::from_str(&msg).expect("Can't parse TokenReceiverMsg");
            match token_receiver_msg {
                TokenReceiverMsg::Execute { actions } => actions,
                TokenReceiverMsg::DepositToReserve => {
                    asset.reserved += amount;
                    self.internal_set_asset(&token_id, asset);
                    log!(
                        "Account {} deposits to reserve {} of {}",
                        sender_id,
                        amount,
                        token_id
                    );
                    return PromiseOrValue::Value(U128(0));
                }
            }
        };

        let mut account = self.internal_unwrap_account(&sender_id);
        account.add_affected_farm(FarmId::Supplied(token_id.clone()));
        self.internal_deposit(&mut account, &token_id, amount);
        log!("Account {} deposits {} of {}", sender_id, amount, token_id);
        self.internal_execute(&sender_id, &mut account, actions, Prices::new());
        self.internal_set_account(&sender_id, account);

        PromiseOrValue::Value(U128(0))
    }
}

impl Contract {
    pub fn internal_ft_transfer(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
        amount: Balance,
    ) -> Promise {
        let asset = self.internal_unwrap_asset(token_id);
        let ft_amount = amount / 10u128.pow(asset.config.extra_decimals as u32);
        ext_fungible_token::ft_transfer(
            account_id.clone(),
            ft_amount.into(),
            None,
            token_id.clone(),
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::after_ft_transfer(
            account_id.clone(),
            token_id.clone(),
            amount.into(),
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_AFTER_FT_TRANSFER,
        ))
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

trait ExtSelf {
    fn after_ft_transfer(&mut self, account_id: AccountId, token_id: TokenId, amount: U128)
        -> bool;
}

#[near_bindgen]
impl ExtSelf for Contract {
    #[private]
    fn after_ft_transfer(
        &mut self,
        account_id: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let mut account = self.internal_unwrap_account(&account_id);
            account.add_affected_farm(FarmId::Supplied(token_id.clone()));
            self.internal_deposit(&mut account, &token_id, amount.0);
            log!(
                "Withdrawal has failed: Account {} deposits {} of {}",
                account_id,
                amount.0,
                token_id
            );
            self.internal_set_account(&account_id, account);
        }
        promise_success
    }
}

'''
'''--- smart-contract/contract/src/lib.rs ---
mod account;
mod account_asset;
mod account_farm;
mod account_view;
mod actions;
mod asset;
mod asset_config;
mod asset_farm;
mod asset_view;
mod big_decimal;
mod config;
mod fungible_token;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod storage_tracker;
mod utils;

pub use crate::account::*;
pub use crate::account_asset::*;
pub use crate::account_farm::*;
pub use crate::account_view::*;
pub use crate::actions::*;
pub use crate::asset::*;
pub use crate::asset_config::*;
pub use crate::asset_farm::*;
pub use crate::asset_view::*;
pub use crate::big_decimal::*;
pub use crate::config::*;
pub use crate::fungible_token::*;
pub use crate::pool::*;
pub use crate::price_receiver::*;
pub use crate::prices::*;
pub use crate::storage::*;
use crate::storage_tracker::*;
use crate::utils::*;

use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, near_bindgen, AccountId, Balance, BorshStorageKey,
    Duration, Gas, PanicOnDefault, Promise, Timestamp,
};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountAssets { account_id: AccountId },
    AccountFarms { account_id: AccountId },
    Storage,
    Assets,
    AssetFarms,
    InactiveAssetFarmRewards { farm_id: FarmId },
    AssetIds,
    Config,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, VAccount>,
    pub storage: LookupMap<AccountId, VStorage>,
    pub assets: LookupMap<TokenId, VAsset>,
    pub asset_farms: LookupMap<FarmId, VAssetFarm>,
    pub asset_ids: UnorderedSet<TokenId>,
    pub config: LazyOption<Config>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKey::Accounts),
            storage: LookupMap::new(StorageKey::Storage),
            assets: LookupMap::new(StorageKey::Assets),
            asset_farms: LookupMap::new(StorageKey::AssetFarms),
            asset_ids: UnorderedSet::new(StorageKey::AssetIds),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
        }
    }
}

'''
'''--- smart-contract/contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn shares_to_amount(&self, shares: Shares, round_up: bool) -> Balance {
        if shares.0 >= self.balance || shares.0 == self.shares.0 {
            self.balance
        } else {
            let extra = if round_up {
                U256::from(self.shares.0 - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.balance) * U256::from(shares.0) + extra) / U256::from(self.shares.0))
                .as_u128()
        }
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- smart-contract/contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        log!("Data price: {:?}", data);
        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let mut account = self.internal_unwrap_account(&sender_id);
        self.internal_execute(&sender_id, &mut account, actions, data.into());
        self.internal_set_account(&sender_id, account);
    }
}

'''
'''--- smart-contract/contract/src/prices.rs ---
use crate::*;
use std::convert::TryFrom;

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    let token_id =
                        AccountId::try_from(asset_id).expect("Asset is not a valid token ID");
                    price.map(|price| (token_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- smart-contract/contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 10000 bytes
const MIN_STORAGE_BALANCE: Balance = 10000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub storage_tracker: StorageTracker,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VStorage {
    Current(Storage),
}

impl From<VStorage> for Storage {
    fn from(v: VStorage) -> Self {
        match v {
            VStorage::Current(c) => c,
        }
    }
}

impl From<Storage> for VStorage {
    fn from(c: Storage) -> Self {
        VStorage::Current(c)
    }
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            storage_tracker: Default::default(),
        }
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        if storage.storage_tracker.bytes_added >= storage.storage_tracker.bytes_released {
            let extra_bytes_used =
                storage.storage_tracker.bytes_added - storage.storage_tracker.bytes_released;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released =
                storage.storage_tracker.bytes_released - storage.storage_tracker.bytes_added;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        storage.storage_tracker.bytes_released = 0;
        storage.storage_tracker.bytes_added = 0;
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }

            let mut account = Account::new(&account_id);
            // HACK: Tracking the extra bytes required to store the storage object itself and
            // recording this under account storage tracker. It'll be accounted when saving the
            // account below.
            account.storage_tracker.start();
            self.internal_set_storage(&account_id, storage);
            account.storage_tracker.stop();
            self.internal_set_account(&account_id, account);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic_str("The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic_str(&format!("The account {} is not registered", &account_id));
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic_str("The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(&account_id)
    }
}

'''
'''--- smart-contract/contract/src/storage_tracker.rs ---
use crate::*;
use near_sdk::StorageUsage;

/// A helper object that tracks changes in state storage.
#[derive(Default)]
pub struct StorageTracker {
    pub bytes_added: StorageUsage,
    pub bytes_released: StorageUsage,
    pub initial_storage_usage: Option<StorageUsage>,
}

/// Safety guard for the storage tracker.
impl Drop for StorageTracker {
    fn drop(&mut self) {
        assert!(self.is_empty(), "Bug, non-tracked storage change");
    }
}

impl StorageTracker {
    /// Starts tracking the state storage changes.
    pub fn start(&mut self) {
        assert!(
            self.initial_storage_usage
                .replace(env::storage_usage())
                .is_none(),
            "The storage tracker is already tracking"
        );
    }

    /// Stop tracking the state storage changes and record changes in bytes.
    pub fn stop(&mut self) {
        let initial_storage_usage = self
            .initial_storage_usage
            .take()
            .expect("The storage tracker wasn't tracking");
        let storage_usage = env::storage_usage();
        if storage_usage >= initial_storage_usage {
            self.bytes_added += storage_usage - initial_storage_usage;
        } else {
            self.bytes_released += initial_storage_usage - storage_usage;
        }
    }

    /// Consumes the other storage tracker changes.
    pub fn consume(&mut self, other: &mut StorageTracker) {
        self.bytes_added += other.bytes_added;
        other.bytes_added = 0;
        self.bytes_released = other.bytes_released;
        other.bytes_released = 0;
        assert!(
            other.initial_storage_usage.is_none(),
            "Can't merge storage tracker that is tracking storage"
        );
    }

    /// Returns true if no bytes is added or released, and the tracker is not active.
    pub fn is_empty(&self) -> bool {
        self.bytes_added == 0 && self.bytes_released == 0 && self.initial_storage_usage.is_none()
    }
}

'''
'''--- smart-contract/contract/src/utils.rs ---
use crate::*;

pub(crate) type TokenId = AccountId;

pub(crate) fn unordered_map_pagination<K, VV, V>(
    m: &UnorderedMap<K, VV>,
    from_index: Option<u64>,
    limit: Option<u64>,
) -> Vec<(K, V)>
where
    K: BorshSerialize + BorshDeserialize,
    VV: BorshSerialize + BorshDeserialize,
    V: From<VV>,
{
    let keys = m.keys_as_vector();
    let values = m.values_as_vector();
    let from_index = from_index.unwrap_or(0);
    let limit = limit.unwrap_or(keys.len());
    (from_index..std::cmp::min(keys.len(), limit))
        .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
        .collect()
}

pub(crate) fn nano_to_ms(nano: u64) -> u64 {
    nano / 10u64.pow(6)
}

pub(crate) fn ms_to_nano(ms: u64) -> u64 {
    ms * 10u64.pow(6)
}

pub(crate) fn u128_ratio(a: u128, num: u128, denom: u128) -> Balance {
    (U256::from(a) * U256::from(num) / U256::from(denom)).as_u128()
}

pub(crate) fn ratio(balance: Balance, r: u32) -> Balance {
    assert!(r <= MAX_RATIO);
    u128_ratio(balance, u128::from(r), u128::from(MAX_RATIO))
}

'''
'''--- smart-contract/script-testcases/0_deploy.sh ---
#!/bin/bash
export MAIN_ACCOUNT=lam-test6.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
# export ORACLE_ID=priceoracle.testnet
export ORACLE_ID=priceoracle.$MAIN_ACCOUNT
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

#####################################
# - Sử dụng đồng DAI cho việc test, nếu muốn test vs các token khác thì tương tự
# - Ví dụ:
#     B1: Deploy Nearland contract 
#     B2: Init Nearland contract
#     B3: Deposit storage cho CONTRACT_ID, OWNER_ID với token DAI_TOKEN_ID và USDT_TOKEN_ID
#     B4: Thực hiện mint để token về ACCOUNT_ID cho việc test 
#     B5: Thực hiện add asset DAI_TOKEN_ID và USDT_TOKEN_ID vào Nearland 

################## B1: Deploy Nearland contract ##################
echo "###################### Build Contract #####################"
../build.sh

echo "################### DELETE ACCOUNT ###################"
near delete $CONTRACT_ID $ACCOUNT_ID

echo "################### CREATE ACCOUNT ###################"

near create-account $CONTRACT_ID --masterAccount $ACCOUNT_ID --initialBalance 10

echo "################### CREATE CONTRACT ###################"
near deploy $CONTRACT_ID --accountId $ACCOUNT_ID --wasmFile ../res/nearlend.wasm

###################### End B1: Deploy Nearland contract #####################

######################### B2: Init Nearland contract #########################

echo "################### INIT CONTRACT ###################"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{"config" : {"oracle_account_id": "'$ORACLE_ID'", "owner_id": "'$ACCOUNT_ID'", "booster_token_id": "'$BOOSTER_TOKEN_ID'", "booster_decimals": 18}}'

###################### End B2: Init Nearland contract #####################

######################### B3: Deposit storage #########################

# Deposit BOOSTER_TOKEN_ID
# near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
# near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

# Deposit CONTRACT_ID
near call $CONTRACT_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.1
near call $CONTRACT_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.1

# Deposit WETH_TOKEN_ID
# near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
# near call $WETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

# Deposit DAI_TOKEN_ID
near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

# Deposit USDT_TOKEN_ID
near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

# Deposit WNEAR_TOKEN_ID
# near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
# near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

###################### End B3: Deposit storage #####################

######################### B4: Mint tokens #########################

# Mint BOOTER_TOKEN_ID
# near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "100000000000000000000000"
# }'

## Mint WETH_TOKEN_ID
# near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "10000000000000000000"
# }'

## Mint DAI_TOKEN_ID
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "100000000000000000000000"
}'

# Mint USDT_TOKEN_ID
# near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#   "account_id": "'$ACCOUNT_ID'",
#   "amount": "10000000000"
# }'

## Mint WNEAR_TOKEN_ID
# near call $USDC_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#   "account_id": "'$ACCOUNT_ID'",
#   "amount": "10000000000"
# }'

###################### End B4: Mint tokens #####################

###################### B5: Add asset #####################

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
# near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
#   "token_id": "'$BOOSTER_TOKEN_ID'",
#   "asset_config": {
#     "reserve_ratio": 2500,
#     "target_utilization": 8000,
#     "target_utilization_rate": "1000000000008319516250272147",
#     "max_utilization_rate": "1000000000039724853136740579",
#     "volatility_ratio": 2000,
#     "extra_decimals": 18,
#     "can_deposit": true,
#     "can_withdraw": true,
#     "can_use_as_collateral": true,
#     "can_borrow": true
#   }
# }' --amount=$ONE_YOCTO --gas=$GAS

# # wETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# # Volatility ratio is 60%, since it's somewhat liquid on NEAR
# near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
#   "token_id": "'$WETH_TOKEN_ID'",
#   "asset_config": {
#     "reserve_ratio": 2500,
#     "target_utilization": 8000,
#     "target_utilization_rate": "1000000000001547125956667610",
#     "max_utilization_rate": "1000000000039724853136740579",
#     "volatility_ratio": 6000,
#     "extra_decimals": 0,
#     "can_deposit": true,
#     "can_withdraw": true,
#     "can_use_as_collateral": true,
#     "can_borrow": true
#   }
# }' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# # wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# # Target utilization is 60% (for some reason)
# # Volatility ratio is 60%
# near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
#   "token_id": "'$WNEAR_TOKEN_ID'",
#   "asset_config": {
#     "reserve_ratio": 2500,
#     "target_utilization": 6000,
#     "target_utilization_rate": "1000000000003593629036885046",
#     "max_utilization_rate": "1000000000039724853136740579",
#     "volatility_ratio": 6000,
#     "extra_decimals": 0,
#     "can_deposit": true,
#     "can_withdraw": true,
#     "can_use_as_collateral": true,
#     "can_borrow": true
#   }
# }' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B5: Add asset #####################
'''
'''--- smart-contract/script-testcases/1_deposit.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test1.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.testnet
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI 
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################
'''
'''--- smart-contract/script-testcases/2_deposit_withdraw.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test6.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.testnet
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI  và withdraw 5 DAI
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID
    # B3: Thực hiện WithDraw vs 5 DAI

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

###################### B3: Thực hiện WithDraw vs 5 DAI #####################

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "5'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B3: Thực hiện WithDraw vs 5 DAI #####################
'''
'''--- smart-contract/script-testcases/3_deposit_with_collateral.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test1.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.testnet
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI  và withdraw 5 DAI
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID
    # B3: Thực hiện IncreaseCollateral vs 5 DAI
    # B4: Thực hiện deposit and IncreaseCollateral vs 10 DAI

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

###################### B3: Thực hiện IncreaseCollateral vs 5 DAI #####################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "5'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B3: Thực hiện IncreaseCollateral vs 5 DAI #####################

###################### B4: Thực hiện deposit and IncreaseCollateral vs 10 DAI #####################
near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": "{\"Execute\": {\"actions\": [{\"IncreaseCollateral\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"10'$DECIMAL_18'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B4: Thực hiện deposit and IncreaseCollateral vs 10 DAI #####################
'''
'''--- smart-contract/script-testcases/4_deposit_collateral_adjust.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test1.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.testnet
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI  và withdraw 5 DAI
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID
    # B3: Thực hiện IncreaseCollateral vs 5 DAI
    # B4: Thực hiện DecreaseCollateral vs 3 DAI
    # B5: Thực hiện deposit and IncreaseCollateral vs 10 DAI
    # B6: Thực hiện DecreaseCollateral vs 6 DAI

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

###################### B3: Thực hiện IncreaseCollateral vs 5 DAI #####################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "5'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B3: Thực hiện IncreaseCollateral vs 5 DAI #####################

###################### B4: Thực hiện DecreaseCollateral vs 3 DAI #####################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "3'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B4: Thực hiện DecreaseCollateral vs 3 DAI #####################

###################### B5: Thực hiện deposit and IncreaseCollateral vs 10 DAI #####################
near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": "{\"Execute\": {\"actions\": [{\"IncreaseCollateral\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"10'$DECIMAL_18'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B5: Thực hiện deposit and IncreaseCollateral vs 10 DAI #####################

###################### B6: Thực hiện DecreaseCollateral vs 6 DAI ########################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "6'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B6: Thực hiện DecreaseCollateral vs 6 DAI ########################
'''
'''--- smart-contract/script-testcases/5_borrow.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test6.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
# export ORACLE_ID=priceoracle.testnet
export ORACLE_ID=priceoracle.$MAIN_ACCOUNT
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI  và withdraw 5 DAI
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID
    # B3: Thực hiện IncreaseCollateral vs 5 DAI
    # B4: Thực hiện Borrow 1 DAI

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

###################### B3: Thực hiện IncreaseCollateral vs 5 DAI #####################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "5'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B3: Thực hiện IncreaseCollateral vs 5 DAI #####################

###################### B4: Thực hiện Borrow 1 DAI #####################
near call $ORACLE_ID --accountId=$OWNER_ID oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1'$DECIMAL_18'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B4: Thực hiện Borrow 1 DAI #####################

near view nearlend.lam-test6.testnet get_account '{"account_id": "lam-test6.testnet"}' 
near view nearlend.lam-test6.testnet get_assets_paged '{"from_index": 0, "limit": 10}'
'''
'''--- smart-contract/script-testcases/6_borrow_repay.sh ---
#!/bin/bash

export MAIN_ACCOUNT=lam-test6.testnet
export NEAR_ENV=testnet
export OWNER_ID=$MAIN_ACCOUNT
export ORACLE_ID=priceoracle.$MAIN_ACCOUNT
export ACCOUNT_ID=$MAIN_ACCOUNT
export CONTRACT_ID=nearlend.$MAIN_ACCOUNT
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export USDC_TOKEN_ID=usdc.testnet
export AURORAX_TOKEN_ID=aurorax.$OWNER_ID
export NEL_TOKEN_ID=nearlendtest.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000

# Chạy test deposit:
# Ví dụ: Deposit vs 10 DAI  và withdraw 5 DAI
    # B1: Chạy file deploy
    # B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID
    # B3: Thực hiện IncreaseCollateral vs 5 DAI
    # B4: Thực hiện Borrow 2 DAI
    # B5: Thực hiện Repay 1 DAI

###################### B1: Chạy file deploy #####################
./0_deploy.sh
###################### End B1: Chạy file deploy #####################

###################### B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B2: Thực hiện deposit vs 10 DAI vào ACCOUNT_ID #####################

###################### B3: Thực hiện IncreaseCollateral vs 5 DAI #####################
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$DAI_TOKEN_ID'",
        "amount": "5'$DECIMAL_18'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}' 
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B3: Thực hiện IncreaseCollateral vs 5 DAI #####################

###################### B4: Thực hiện Borrow 1 DAI #####################
near call $ORACLE_ID --accountId=$OWNER_ID oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"2'$DECIMAL_18'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'

###################### End B4: Thực hiện Borrow 1 DAI #####################

###################### B5: Thực hiện Repay 1 DAI #####################
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1'$DECIMAL_18'",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1'$DECIMAL_18'\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
near view $CONTRACT_ID get_assets_paged '{"from_index": 0, "limit": 10}'
###################### End B5: Thực hiện Repay 1 DAI #####################
'''
'''--- smart-contract/scripts/add_farms.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Adding the farms $LG<<<<<<<<<<<<<<$NC"

for TOKEN_ID in $DAI_TOKEN_ID $USDT_TOKEN_ID $WETH_TOKEN_ID $WNEAR_TOKEN_ID
do

  echo -e "$LG>>>>>>>>>>>>>>$TC Adding farms for $TOKEN_ID $LG<<<<<<<<<<<<<<$NC"

  near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
    "farm_id": {
      "Supplied": "'$TOKEN_ID'"
    },
    "reward_token_id": "'$BOOSTER_TOKEN_ID'",
    "new_reward_per_day": "100000000000000000000",
    "new_booster_log_base": "100000000000000000000",
    "reward_amount": "700000000000000000000"
  }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$BOOSTER_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000",
      "new_booster_log_base": "100000000000000000000",
      "reward_amount": "1750000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Supplied": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "100000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "700000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

    near call $CONTRACT_ID --accountId=$OWNER_ID add_asset_farm_reward '{
      "farm_id": {
        "Borrowed": "'$TOKEN_ID'"
      },
      "reward_token_id": "'$WNEAR_TOKEN_ID'",
      "new_reward_per_day": "250000000000000000000000",
      "new_booster_log_base": "10000000000000000000",
      "reward_amount": "1750000000000000000000000"
    }' --amount=$ONE_YOCTO --gas=$GAS

done

near view $CONTRACT_ID get_asset_farms_paged

'''
'''--- smart-contract/scripts/apr_to_rate.py ---
#!/usr/bin/env python3

import sys
from decimal import *

getcontext().prec = 60

n = 31536000000
input_apr = Decimal(sys.argv[1])
print("Input APR: %s%%" % (input_apr,))
print("n: %d" % (n,))

res = (((input_apr / Decimal(100)) + Decimal(1)) ** (Decimal(1) / Decimal(n)))
print("R: %s" % (res,))
print("R ** n: %s" % (res ** n,))

round_res = round(res * (Decimal(10) ** Decimal(27)))
print("rate: %s" % (round_res, ))

'''
'''--- smart-contract/scripts/create_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

mv -f neardev/dev-account neardev/dev-account-old 2> /dev/null || true

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create a user's account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
export ACCOUNT_ID="$(cat neardev/dev-account)"

mv -f neardev/dev-account-old neardev/dev-account 2> /dev/null || true

scripts/mint_to_account.sh

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export ACCOUNT_ID=$ACCOUNT_ID"

'''
'''--- smart-contract/scripts/dev_deploy.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to create an owner account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
OWNER_ID="$(cat neardev/dev-account)"

ORACLE_ID="priceoracle.testnet"

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy the main contract $LG<<<<<<<<<<<<<<$NC"
near dev-deploy -f res/burrowland.wasm
CONTRACT_ID="$(cat neardev/dev-account)"

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing Booster token $LG<<<<<<<<<<<<<<$NC"
BOOSTER_TOKEN_ID="ref.fakes.testnet"

near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing the main contract $LG<<<<<<<<<<<<<<$NC"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wETH $LG<<<<<<<<<<<<<<$NC"
WETH_TOKEN_ID="weth.fakes.testnet"

near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing DAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing USDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$BOOSTER_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000008319516250272147",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 2000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": false,
    "can_borrow": false
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "120000000000000000000000"
}'
near call $WETH_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000"
}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export WETH_TOKEN_ID=$WETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- smart-contract/scripts/mint_to_account.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to fund the account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
TMP_ACCOUNT="$(cat neardev/dev-account)"
echo -e "$LG>>>>>>>>>>>>>>$TC Funding the account $LG<<<<<<<<<<<<<<$NC"
near delete $TMP_ACCOUNT $ACCOUNT_ID

echo -e "$LG>>>>>>>>>>>>>>$TC Registering storage for the user: $LG<<<<<<<<<<<<<<$NC"
# near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $USDC_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the user: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 100000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 10 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 10000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 wNEAR (wrapped) $NC"
#near call $BOOSTER_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "100000000000000000000000"
#}'
#near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
#  "account_id": "'$ACCOUNT_ID'",
#  "amount": "10000000000000000000"
#}'
near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $USDC_TOKEN_ID --accountId=$ACCOUNT_ID mint '{
  "account_id": "'$ACCOUNT_ID'",
  "amount": "10000000000"
}'
near call $WNEAR_TOKEN_ID --accountId=$ACCOUNT_ID near_deposit '{}' --amount=100

'''
'''--- smart-contract/scripts/readme_test.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)/.."

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'

near call $USDT_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000",
  "msg": ""
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$USDT_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "IncreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near call $ORACLE_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO oracle_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$USDT_TOKEN_ID'",
    "'$DAI_TOKEN_ID'"
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Borrow\": {\"token_id\": \"'$DAI_TOKEN_ID'\", \"amount\": \"1000000000000000000\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
sleep 1

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "Withdraw": {
        "token_id": "'$DAI_TOKEN_ID'"
      }
    }
  ]
}'

near view $DAI_TOKEN_ID ft_balance_of '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $DAI_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": "{\"Execute\": {\"actions\": [{\"Repay\": {\"token_id\": \"'$DAI_TOKEN_ID'\"}}]}}"
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_ID get_asset '{"token_id": "'$DAI_TOKEN_ID'"}'

near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO execute '{
  "actions": [
    {
      "DecreaseCollateral": {
        "token_id": "'$USDT_TOKEN_ID'"
      }
    }
  ]
}'

near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'

'''
'''--- smart-contract/scripts/testnet_deploy.sh ---
#!/bin/bash
set -e

MASTER_ACCOUNT=$1
TIME=$(date +%s)

cd "$(dirname $0)/.."

export NEAR_ENV=testnet
LG='\033[1;30m' # Arrows color (Dark gray)
TC='\033[0;33m' # Text color (Orange)
NC='\033[0m' # No Color

echo -e "$LG>>>>>>>>>>>>>>$TC Deploy an empty contract to fund main account $LG<<<<<<<<<<<<<<$NC"
echo -n "" > /tmp/empty
near dev-deploy -f /tmp/empty
TMP_ACCOUNT="$(cat neardev/dev-account)"

MAIN="${TIME}.${MASTER_ACCOUNT}"

echo -e "$LG>>>>>>>>>>>>>>$TC Creating main account: $MAIN $LG<<<<<<<<<<<<<<$NC"
near create-account $MAIN --masterAccount=$MASTER_ACCOUNT --initialBalance=0.01

echo -e "$LG>>>>>>>>>>>>>>$TC Funding main account: $MAIN $LG<<<<<<<<<<<<<<$NC"
near delete $TMP_ACCOUNT $MAIN

OWNER_ID="owner.$MAIN"
echo -e "$LG>>>>>>>>>>>>>>$TC Creating owner account: $OWNER_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $OWNER_ID --masterAccount=$MAIN --initialBalance=130

BOOSTER_TOKEN_ID="token.$MAIN"
echo -e "$LG>>>>>>>>>>>>>>$TC Creating and deploying booster token: $BOOSTER_TOKEN_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $BOOSTER_TOKEN_ID --masterAccount=$MAIN --initialBalance=3
near deploy $BOOSTER_TOKEN_ID res/fungible_token.wasm new '{
   "owner_id": "'$OWNER_ID'",
   "total_supply": "1000000000000000000000000000",
   "metadata": {
       "spec": "ft-1.0.0",
       "name": "Booster Token ('$TIME')",
       "symbol": "BOOSTER-'$TIME'",
       "decimals": 18
   }
}'

ORACLE_ID="priceoracle.testnet"

CONTRACT_ID="contract.$MAIN"

echo -e "$LG>>>>>>>>>>>>>>$TC Creating and deploying contract account: $CONTRACT_ID $LG<<<<<<<<<<<<<<$NC"
near create-account $CONTRACT_ID --masterAccount=$MAIN --initialBalance=10
near deploy $CONTRACT_ID res/burrowland.wasm new '{"config": {
  "oracle_account_id": "'$ORACLE_ID'",
  "owner_id": "'$OWNER_ID'",
  "booster_token_id": "'$BOOSTER_TOKEN_ID'",
  "booster_decimals": 18
}}'

echo -e "$LG>>>>>>>>>>>>>>$TC Booster token storage for contract $LG<<<<<<<<<<<<<<$NC"
near call $BOOSTER_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nETH $LG<<<<<<<<<<<<<<$NC"
NETH_TOKEN_ID="aurora"

near call $NETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.0125
near call $NETH_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.0125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nDAI $LG<<<<<<<<<<<<<<$NC"
DAI_TOKEN_ID="dai.fakes.testnet"

near call $DAI_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $DAI_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nUSDT $LG<<<<<<<<<<<<<<$NC"
USDT_TOKEN_ID="usdt.fakes.testnet"

near call $USDT_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDT_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing nUSDC $LG<<<<<<<<<<<<<<$NC"
USDC_TOKEN_ID="usdc.fakes.testnet"

near call $USDC_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $USDC_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Preparing wNEAR $LG<<<<<<<<<<<<<<$NC"
WNEAR_TOKEN_ID="wrap.testnet"

near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.00125
near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.00125

echo -e "$LG>>>>>>>>>>>>>>$TC Initializing assets $LG<<<<<<<<<<<<<<$NC"
ONE_YOCTO="0.000000000000000000000001"
GAS="200000000000000"

# Booster APR is 30%, to verify run ./scripts/apr_to_rate.py 30
# Max APR for all assets is 250%
# Booster can't be used as a collateral or borrowed (for now), so APR doesn't matter.
#near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
#  "token_id": "'$BOOSTER_TOKEN_ID'",
#  "asset_config": {
#    "reserve_ratio": 2500,
#    "target_utilization": 8000,
#    "target_utilization_rate": "1000000000008319516250272147",
#    "max_utilization_rate": "1000000000039724853136740579",
#    "volatility_ratio": 2000,
#    "extra_decimals": 0,
#    "can_deposit": true,
#    "can_withdraw": true,
#    "can_use_as_collateral": false,
#    "can_borrow": false
#  }
#}' --amount=$ONE_YOCTO --gas=$GAS

# nETH APR is 6%, to verify run ./scripts/apr_to_rate.py 5
# Volatility ratio is 60%, since it's somewhat liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$NETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000001547125956667610",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# DAI APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$DAI_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDT APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDT by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDT_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# USDC APR is 8%, to verify run ./scripts/apr_to_rate.py 8
# Volatility ratio is 95%, since it's stable and liquid on NEAR
# USDC by default has 6 decimals, the config adds extra 12 decimals, to bring the total to 18
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$USDC_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 8000,
    "target_utilization_rate": "1000000000002440418605283556",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 9500,
    "extra_decimals": 12,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

# wNEAR APR is 12%, to verify run ./scripts/apr_to_rate.py 12
# Target utilization is 60% (for some reason)
# Volatility ratio is 60%
near call $CONTRACT_ID --accountId=$OWNER_ID add_asset '{
  "token_id": "'$WNEAR_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "target_utilization": 6000,
    "target_utilization_rate": "1000000000003593629036885046",
    "max_utilization_rate": "1000000000039724853136740579",
    "volatility_ratio": 6000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true,
    "can_use_as_collateral": true,
    "can_borrow": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Minting tokens for the owner and the user: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 12 nETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 12000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 120 wNEAR (wrapped) $NC"
#near call $NETH_TOKEN_ID --accountId=$OWNER_ID mint '{
#  "account_id": "'$OWNER_ID'",
#  "amount": "12000000000000000000"
#}'
near call $DAI_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000000000000000"
}'
near call $USDT_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'
near call $USDC_TOKEN_ID --accountId=$OWNER_ID mint '{
  "account_id": "'$OWNER_ID'",
  "amount": "12000000000"
}'

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID near_deposit '{}' --amount=120

echo -e "$LG>>>>>>>>>>>>>>$TC Adding some reserves from the owner: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 2000 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 20 wNEAR $NC"
#near call $BOOSTER_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
#  "receiver_id": "'$CONTRACT_ID'",
#  "amount": "20000000000000000000000",
#  "msg": "\"DepositToReserve\""
#}' --amount=$ONE_YOCTO --gas=$GAS

near call $NETH_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDC_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "20000000000000000000000000",
  "msg": "\"DepositToReserve\""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Registering the owner: $LG<<<<<<<<<<<<<<$NC"

near call $CONTRACT_ID --accountId=$OWNER_ID storage_deposit '' --amount=0.1

echo -e "$LG>>>>>>>>>>>>>>$TC Adding regular deposits from the owner: $LG<<<<<<<<<<<<<<$NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 20000 BOOSTER $NC"
# echo -e "$LG>>>>>>>>>>>>>>$TC * 2 wETH $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 DAI $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 USDT $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 100 USDC $NC"
echo -e "$LG>>>>>>>>>>>>>>$TC * 1 wNEAR $NC"

near call $DAI_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "100000000000000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDT_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "100000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $USDC_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "2000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

near call $WNEAR_TOKEN_ID --accountId=$OWNER_ID ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "1000000000000000000000000",
  "msg": ""
}' --amount=$ONE_YOCTO --gas=$GAS

echo -e "$LG>>>>>>>>>>>>>>$TC Dropping info to continue working from NEAR CLI: $LG<<<<<<<<<<<<<<$NC"
echo -e "export NEAR_ENV=testnet"
echo -e "export OWNER_ID=$OWNER_ID"
echo -e "export ORACLE_ID=$ORACLE_ID"
echo -e "export CONTRACT_ID=$CONTRACT_ID"
echo -e "export BOOSTER_TOKEN_ID=$BOOSTER_TOKEN_ID"
echo -e "export NETH_TOKEN_ID=$NETH_TOKEN_ID"
echo -e "export DAI_TOKEN_ID=$DAI_TOKEN_ID"
echo -e "export USDT_TOKEN_ID=$USDT_TOKEN_ID"
echo -e "export USDC_TOKEN_ID=$USDC_TOKEN_ID"
echo -e "export WNEAR_TOKEN_ID=$WNEAR_TOKEN_ID"
echo -e "export ONE_YOCTO=$ONE_YOCTO"
echo -e "export GAS=$GAS"

'''
'''--- smart-contract/sim-tests/babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- smart-contract/sim-tests/config.js ---
module.exports = {
    API_SERVER_URL: "http://78.47.91.25:3000",
    CREDENTIALS_DIR: ".near-credentials/testnet/",
    FRACTION_DIGITS: 5,
    GAS: 100000000000000,
}

'''
'''--- smart-contract/sim-tests/jest.config.js ---
module.exports = {
    testEnvironment: "node",
    testTimeout: 900000,
    globals: {
        Uint8Array: Uint8Array,
    },
};
'''
'''--- smart-contract/sim-tests/package.json ---
{
  "name": "sim-tests",
  "version": "1.0.0",
  "scripts": {
    "test": "jest rest-api.test.js --useStderr --verbose false",
    "test:accounts": "jest rest-api.test.js -t 'Accounts' --useStderr --verbose false",
    "test:collateral": "jest rest-api.test.js -t 'Collateral' --useStderr --verbose false",
    "test:borrow": "jest rest-api.test.js -t 'Borrow' --useStderr --verbose false",
    "test:withdraw": "jest rest-api.test.js -t 'Withdraw' --useStderr --verbose false",
    "test:repay": "jest rest-api.test.js -t 'Repay' --useStderr --verbose false",
    "test:decrease": "jest rest-api.test.js -t 'Decrease collateral' --useStderr --verbose false",
    "test:liquidate": "jest rest-api.test.js -t 'Liquidate' --useStderr --verbose false"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.6.0",
    "node-fetch": "^2.6.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "cross-env": "^7.0.3",
    "crypto-js": "^4.1.1",
    "near-api-js": "^0.41.0",
    "react": "~17.0.1",
    "react-dom": "~17.0.1",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  }
}

'''
'''--- smart-contract/sim-tests/rest-api-dummy-data.test.js ---
/* export REACT_CONTRACT_ID=dev-1627393733545-88687685295664 */
import 'regenerator-runtime/runtime'

const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const contract_id  = process.env.CONTRACT_NAME;

const near = new contract(process.env.CONTRACT_NAME);

const MIN_TOKENS = 20;

describe("Contract set", () => {
    test("Contract set: " + process.env.CONTRACT_NAME, async () => {
        expect(process.env.CONTRACT_NAME).not.toBe(undefined)
    });

    test('Accounts has enough funds', async () => {
        const contract_wallet_balance = await near.accountNearBalance(contract_id);
        expect(contract_wallet_balance).toBeGreaterThan(MIN_TOKENS);
    });
});

describe("Insert dummy data", () => {
    console.log(contract_id)
    test('Insert players', async () => {
        for (let i = 500; i <= 600; i++) {
            let account = `account_${i}.testnet`;
            const start_game = await near.call("start_game_for_account_id",
                {quiz_id: 36, account_id: account},
                {account_id: contract_id});
            expect(start_game.type).not.toBe('FunctionCallError');
        }
    });
});

'''
'''--- smart-contract/sim-tests/rest-api-test-utils.js ---
const utils = require('./utils');
const config = require("./config");

function contract(contract_id) {
    this.contract_id = contract_id;
}

contract.prototype.deploy = async function (contractName) {
    const body = {
        contract: contractName,
        account_id: this.contract_id,
        private_key: await utils.getPrivateKey(this.contract_id),
    };

    return await utils.PostResponse("deploy", body);
};

contract.prototype.view = async function (method, params, options) {
    const body = {
        method: method,
        params: params,
        contract: this.contract_id,
        disabled_cache: true
    };

    return await utils.PostResponse("view", body, options);
};

contract.prototype.viewNearBalance = async function (method, params, options) {
    options = options || {};
    options.convertToNear = true;
    return await this.view(method, params, options);
};

contract.prototype.viewFTe18Balance = async function (method, params, options) {
    options = options || {};
    options.convertFromFTe18 = true;
    return await this.view(method, params, options);
};

contract.prototype.accountNearBalance = async function (account_id, delay) {
    delay = delay || 1000;
    await timeout(delay);

    return await utils.GetResponse("balance", account_id, {convertToNear: true})
        .catch(e => console.error("AccountNearBalance error for " + JSON.stringify(account_id) + ". Error: " + e.message));
};

contract.prototype.call = async function (method, params, options) {
    options.attached_gas = options.gas || config.GAS;
    options.attached_tokens = options.tokens || 0;
    options.private_key = options.private_key || await utils.getPrivateKey(options.account_id);
    options.log_errors = options.log_errors || false;
    options.return_value = options.return_value || false;

    const body = {
        ...options,
        method: method,
        params: params,
        contract: this.contract_id,
    };

    return await utils.PostResponse("call", body, options)
        .catch(e => {
            if(e.message.includes("Unexpected token < in JSON at position 0"))
                console.error("RPC/JSON Error: " + e.message);
            else
                console.error("Call error for " + JSON.stringify(body) + ". Error: " + e.message)
        });
};

function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = contract;

'''
'''--- smart-contract/sim-tests/rest-api.test.js ---
import 'regenerator-runtime/runtime'

/*
export NEAR_ENV=testnet
export OWNER_ID=dev-1634805788173-90290670203248
export ORACLE_ID=priceoracle.testnet
export CONTRACT_ID=dev-1634805794596-68676200580325
export BOOSTER_TOKEN_ID=ref.fakes.testnet
export WETH_TOKEN_ID=weth.fakes.testnet
export DAI_TOKEN_ID=dai.fakes.testnet
export USDT_TOKEN_ID=usdt.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export ACCOUNT_ID=dev-1634809261182-39559532470451

 */
const contract = require('./rest-api-test-utils');
const utils = require('./utils');

const alice = process.env.ACCOUNT_ID;
const contract_id = process.env.CONTRACT_ID;
const usdt_contract_id = process.env.USDT_TOKEN_ID;
const dai_contract_id = process.env.DAI_TOKEN_ID;
const oracle_contract_id = process.env.ORACLE_ID;

const bob = "place.testnet";

const burrow = new contract(contract_id);
const usdt = new contract(usdt_contract_id);
const dai = new contract(dai_contract_id);
const oracle = new contract(oracle_contract_id);

describe("Contract set", () => {
    test("Contract is not null " + contract_id, async () => {
        expect(contract_id).not.toBe(undefined)
    });

    test("USDT Contract is not null " + usdt_contract_id, async () => {
        expect(usdt_contract_id).not.toBe(undefined)
    });

    test("DAI Contract is not null " + usdt_contract_id, async () => {
        expect(dai_contract_id).not.toBe(undefined)
    });

    test("Oracle Contract is not null " + alice, async () => {
        expect(oracle_contract_id).not.toBe(undefined)
    });

    test("Alice Account is not null " + alice, async () => {
        expect(alice).not.toBe(undefined)
    });

    test('Alice has enough funds', async () => {
        const alice_wallet_balance = await burrow.accountNearBalance(alice, 0);
        expect(alice_wallet_balance).toBeGreaterThan(20);
    });
});

describe("Accounts", () => {
    test('Register account by paying for storage, deposit tokens', async () => {
        const storage_deposit = await burrow.call("storage_deposit",
            {}, {
                account_id: alice,
                tokens: utils.ConvertToNear(0.1),
                log_errors: true
            });
        expect(storage_deposit.is_error).toBeFalsy();

        const account_initial = await burrow.view("get_account",
            {account_id: alice}, {});

        // make ft deposit and check balance/shares
        const deposit_1 = 5;
        const asset_1 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});

        const ft_transfer_1 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_1.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        expect(account_1.account_id).toBe(alice);
        expect(account_1.supplied.length).toBeGreaterThan(0);

        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_1.length).toBe(1);

        const usdt_supplied_initial = account_initial.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.balance) + deposit_1);
        expect(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_initial[0]?.shares) + deposit_1);

        const asset_2 = await burrow.view("get_asset",
            {token_id: usdt_contract_id}, {});
        expect(utils.ConvertFromFTe18(asset_2.supplied.shares)
            - utils.ConvertFromFTe18(asset_1.supplied.shares)).toBe(5)

        const deposit_2 = 3;
        const ft_transfer_2 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_2.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_2.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance) + deposit_2);
        expect(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares) + deposit_2);

        const deposit_3 = 0;
        const ft_transfer_3 = await usdt.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: deposit_3.toString() + "000000",
            msg: ""
        }, {account_id: alice, tokens: 1})
        expect(ft_transfer_3.is_error).toBeTruthy();

        const account_3 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_supplied_3 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_supplied_3.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_supplied_3[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Collateral", () => {
    test('Provide token as a collateral', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');

        const execute = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: usdt_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');
        expect(usdt_collateral_2.length).toBe(1);

        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].balance)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_2[0].shares)
            - utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares))
            .toBe(utils.ConvertFromFTe18(usdt_supplied_1[0].shares));

        const execute_wrong_account = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {"token_id": usdt_contract_id}
                }]
            },
            {account_id: bob, tokens: 1})
        expect(execute_wrong_account.is_error).toBeTruthy();

        const execute_without_supply = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {
                        token_id: usdt_contract_id
                    }
                }]
            },
            {account_id: alice, tokens: 1})
        expect(execute_without_supply.is_error).toBeTruthy();
    });
});

describe("Borrow", () => {
    test('Borrow a token', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: 'dai.fakes.testnet',
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

describe("Withdraw", () => {
    test('Withdrawing the asset', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const ft_balance_1 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        const withdraw = await burrow.call("execute",
            {
                actions: [{
                    Withdraw: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(withdraw.is_error).toBeFalsy();

        const ft_balance_2 = await usdt.view("ft_balance_of",
            {account_id: alice},
            {convertFromFTe18: true})

        expect(ft_balance_2 - ft_balance_1)
            .toBeCloseTo(utils.ConvertFromFTe18(account_1.supplied.balance));

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.supplied.length).toBe(0);
    });
});

describe("Repay", () => {
    test('Deposit asset and repay it in one call', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        const repay_amount_1 = 5;

        const ft_transfer_1 = await dai.call("ft_transfer_call", {
            receiver_id: contract_id,
            amount: repay_amount_1.toString() + "000000000000000000",
            msg: JSON.stringify({
                Execute: {
                    actions: [
                        {
                            Repay: {
                                token_id: 'dai.fakes.testnet'
                            }
                        }
                    ]
                }
            })
        }, {account_id: alice, tokens: 1, log_errors: true})
        expect(ft_transfer_1.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(0);

        expect(utils.ConvertFromFTe18(account_1.borrowed[0].balance) +
            utils.ConvertFromFTe18(account_2.supplied[0].balance)).toBeCloseTo(repay_amount_1);
    });
});

describe("Decrease collateral", () => {
    test('Decreasing collateral without providing prices', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});
        const usdt_supplied_1 = account_1.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_1 = account_1.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        const decrease_collateral_wrong_asset = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'dai.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(decrease_collateral_wrong_asset.is_error).toBeTruthy();

        const decrease_collateral = await burrow.call("execute",
            {
                actions: [{
                    DecreaseCollateral: {
                        token_id: 'usdt.fakes.testnet'
                    }
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(decrease_collateral.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account", {account_id: alice}, {});
        const usdt_supplied_2 = account_2.supplied.filter(token => token.token_id === 'usdt.fakes.testnet');
        const usdt_collateral_2 = account_2.collateral.filter(token => token.token_id === 'usdt.fakes.testnet');

        expect(usdt_collateral_2.length).toBe(0);
        expect(usdt_supplied_2.length).toBeGreaterThan(0);
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.balance) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.balance))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.balance));
        expect(utils.ConvertFromFTe18(usdt_collateral_1[0]?.shares) +
            utils.ConvertFromFTe18(usdt_supplied_1[0]?.shares))
            .toBeCloseTo(utils.ConvertFromFTe18(usdt_supplied_2[0]?.shares));
    });
});

describe("Liquidate", () => {
    test('Liquidate', async () => {
        const account_1 = await burrow.view("get_account",
            {account_id: alice}, {});

        console.log(account_1);

        const increaseCollateral = await burrow.call("execute",
            {
                actions: [{
                    IncreaseCollateral: {token_id: dai_contract_id}
                }]
            },
            {
                account_id: alice,
                tokens: 1,
                log_errors: true
            })
        expect(increaseCollateral.is_error).toBeFalsy();

        const borrow_amount_1 = 1;
        const execute = await oracle.call("oracle_call",
            {
                receiver_id: contract_id,
                asset_ids: [
                    'usdt.fakes.testnet',
                    'dai.fakes.testnet'
                ],
                msg: JSON.stringify({
                    Execute: {
                        actions:
                            [{
                                Borrow: {
                                    token_id: dai_contract_id,
                                    amount: borrow_amount_1.toString() + "000000000000000000"
                                }
                            }]
                    }
                })
            },
            {
                account_id: alice,
                tokens: 1
            })
        expect(execute.is_error).toBeFalsy();

        const liquidate = await burrow.call("execute",
            {
                actions: [{
                    Liquidate: {
                        token_id: 'usdt.fakes.testnet',
                        in_assets: {
                            token_id: 'dai.fakes.testnet',
                            max_amount: borrow_amount_1.toString() + "000000000000000000"
                        }
                    }
                }]
            },
            {
                account_id: bob,
                tokens: 1,
                log_errors: true
            })
        expect(liquidate.is_error).toBeFalsy();

        const account_2 = await burrow.view("get_account",
            {account_id: alice}, {});

        expect(account_2.borrowed.length).toBe(1);
        expect(account_2.borrowed[0].token_id).toBe('dai.fakes.testnet');
        // check borrowed funds
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].balance)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.borrowed[0].shares)
            - utils.ConvertFromFTe18(account_1?.borrowed[0]?.shares))
            .toBe(borrow_amount_1);

        // check supplied funds
        expect(utils.ConvertFromFTe18(account_2.supplied[0].balance)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.balance))
            .toBeCloseTo(borrow_amount_1);
        expect(utils.ConvertFromFTe18(account_2.supplied[0].shares)
            - utils.ConvertFromFTe18(account_1?.supplied[0]?.shares))
            .toBe(borrow_amount_1);
    });
});

'''
'''--- smart-contract/sim-tests/utils.js ---
const {utils} = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const {BN} = require('bn.js');
const fs = require('fs');
const fetch = require("node-fetch");
const config = require("./config");

module.exports = {
    ConvertYoctoNear: (value, frac_digits) => {
        try {
            return utils.format.formatNearAmount(value, frac_digits).replace(",", "");
        } catch (e) {
            console.log("ConvertYoctoNear error, value: " + value);
            console.log(e);
        }
    },

    ConvertFromFTe18: (value) => {
        if(value === undefined)
            return 0;

        return Number(Math.round(value / 100000000000000) / 10000);
    },

    ConvertToNear: (amount) => {
        return new BN(Math.round(amount * 100000000)).mul(new BN("10000000000000000")).toString();
    },

    RoundFloat: (amount) => {
        return +Number.parseFloat(amount).toFixed(config.FRACTION_DIGITS);
    },

    getPrivateKey: async (accountId) => {
        const credentialsPath = path.join(homedir, config.CREDENTIALS_DIR);
        const keyPath = credentialsPath + accountId + '.json';
        try {
            const credentials = JSON.parse(fs.readFileSync(keyPath));
            return (credentials.private_key);
        } catch (e) {
            console.error("Key not found for account " + keyPath + ". Error: " + e.message);
        }
    },

    PostResponse: async (operation, body, options) => {
        const response = fetch(`${config.API_SERVER_URL}/${operation}`, {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'Content-type': 'application/json; charset=UTF-8'
            }
        })
            .then(res => {
                return res.text().then(response => {
                    if (options && options.log_errors) {
                        const response_json = JSON.parse(response);
                        if (response_json && response_json.error) {
                            const error = JSON.parse(response_json.error);
                            console.log(`Request: ${body.method}`);
                            console.log(`ERROR: ${error.type}: ${JSON.stringify(error.kind)}`);
                        }
                    }

                    if (options && (options.convertToNear || options.convertFromFTe18)) {
                        if (isNaN(response))
                            throw new Error(`Illegal balance value. Request: ${JSON.stringify(body)}. Response: ${response}`);

                        if (options.convertFromFTe18)
                            return module.exports.RoundFloat(module.exports.ConvertFromFTe18(response, config.FRACTION_DIGITS));
                        else
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(response, config.FRACTION_DIGITS));
                    } else {
                        try {
                            let json = JSON.parse(response);
                            json.is_error = json.error && JSON.parse(json.error).hasOwnProperty('kind');
                            try {
                                if (options.return_value)
                                    return Buffer.from( json.status.SuccessValue, 'base64').toString();
                                else
                                    return (json);
                            } catch (e) {
                                throw new Error("PostResponse error for " + operation + " request " + JSON.stringify(body) + ". Error: " + e.message);
                            }
                        } catch (e) {
                            return response;
                        }
                    }
                });

            });
        return response;
    },

    GetResponse: async (operation, value, options) => {
        const response = await fetch(`${config.API_SERVER_URL}/${operation}/${value}`, {
            method: 'GET'
        })
            .then(res => {
                if (options && options.convertToNear) {
                    return res.text().then(value => {
                        try {
                            return module.exports.RoundFloat(module.exports.ConvertYoctoNear(value, config.FRACTION_DIGITS));
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                } else {
                    return res.json().then(json => {
                        try {
                            if (json.error)
                                return (JSON.parse(json.error));
                            else
                                return (json);
                        } catch (e) {
                            throw new Error("GetResponse error for " + operation + " request " + JSON.stringify(value) + ". Error: " + e.message);
                        }
                    });
                }
            });

        return response;
    },

    IsJson: (item) => {
        item = typeof item !== "string"
            ? JSON.stringify(item)
            : item;

        try {
            item = JSON.parse(item);
        } catch (e) {
            return false;
        }

        if (typeof item === "object" && item !== null) {
            return true;
        }

        return false;
    }
};

'''
'''--- smart-contract/test-oracle/Cargo.toml ---
[package]
name = "test-oracle"
version = "0.1.0"
authors = ["Nearlend Team"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
common = { path = "../common/" }

'''
'''--- smart-contract/test-oracle/src/lib.rs ---
use common::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Gas, Promise};

const GAS_FOR_PROMISE: Gas = Gas(Gas::ONE_TERA.0 * 10);

#[ext_contract(ext_price_receiver)]
pub trait ExtPriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn oracle_call(
        &mut self,
        receiver_id: AccountId,
        price_data: PriceData,
        msg: String,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let remaining_gas = env::prepaid_gas() - env::used_gas();
        assert!(remaining_gas >= GAS_FOR_PROMISE);

        ext_price_receiver::oracle_on_call(
            sender_id,
            price_data,
            msg,
            receiver_id,
            NO_DEPOSIT,
            remaining_gas - GAS_FOR_PROMISE,
        )
    }
}

'''
'''--- smart-contract/tests/basic.rs ---
mod setup;

use crate::setup::*;

use contract::{BigDecimal, MS_PER_YEAR};

const SEC_PER_YEAR: u32 = (MS_PER_YEAR / 1000) as u32;

#[macro_use]
extern crate approx;

#[test]
fn test_init_env() {
    let e = Env::init();
    let _tokens = Tokens::init(&e);
    let _users = Users::init(&e);
}

#[test]
fn test_mint_tokens() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
}

#[test]
fn test_dev_setup() {
    let e = Env::init();
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.reserved, d(10000, 24));
}

#[test]
fn test_supply() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.contract_ft_transfer_call(&tokens.wnear, &users.alice, amount, "")
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
    assert_eq!(account.supplied[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_supply_to_collateral() {
    let (e, tokens, users) = basic_setup();

    let amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, amount)
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.collateral[0].balance, amount);
    assert_eq!(account.collateral[0].token_id, tokens.wnear.account_id());
}

#[test]
fn test_borrow() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, borrow_amount);
    assert!(asset.supply_apr > BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, borrow_amount);
    assert_eq!(account.supplied[0].token_id, tokens.ndai.account_id());
    assert!(account.supplied[0].apr > BigDecimal::zero());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_borrow_and_withdraw() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(100, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(200, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert!(asset.borrow_apr > BigDecimal::zero());
    assert_eq!(asset.supplied.balance, 0);
    assert_eq!(asset.supply_apr, BigDecimal::zero());

    let account = e.get_account(&users.alice);
    assert!(account.supplied.is_empty());
    assert_eq!(account.borrowed[0].balance, borrow_amount);
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
    assert!(account.borrowed[0].apr > BigDecimal::zero());
}

#[test]
fn test_interest() {
    let (e, tokens, users) = basic_setup();

    let supply_amount = d(10000, 24);
    e.supply_to_collateral(&users.alice, &tokens.wnear, supply_amount)
        .assert_success();

    let borrow_amount = d(8000, 18);
    e.borrow_and_withdraw(
        &users.alice,
        &tokens.ndai,
        price_data(&tokens, Some(100000), None),
        borrow_amount,
    )
    .assert_success();

    let asset = e.get_asset(&tokens.ndai);
    assert_eq!(asset.borrowed.balance, borrow_amount);
    assert_relative_eq!(asset.borrow_apr.f64(), 0.08f64);

    e.skip_time(SEC_PER_YEAR);

    let expected_borrow_amount = borrow_amount * 108 / 100;

    let asset = e.get_asset(&tokens.ndai);
    assert_relative_eq!(asset.borrowed.balance as f64, expected_borrow_amount as f64);

    let account = e.get_account(&users.alice);
    assert_relative_eq!(
        account.borrowed[0].balance as f64,
        expected_borrow_amount as f64
    );
    assert_eq!(account.borrowed[0].token_id, tokens.ndai.account_id());
}

'''
'''--- smart-contract/tests/setup/mod.rs ---
#![allow(dead_code)]

use common::{AssetOptionalPrice, Price, PriceData, ONE_YOCTO};
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{env, serde_json, AccountId, Balance, Gas, Timestamp};
use near_sdk_sim::runtime::GenesisConfig;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

pub use contract::{
    AccountDetailedView, Action, AssetAmount, AssetConfig, AssetDetailedView, Config,
    ContractContract as BurrowlandContract, PriceReceiverMsg, TokenReceiverMsg,
};
use test_oracle::ContractContract as OracleContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    BURROWLAND_WASM_BYTES => "res/burrowland.wasm",
    BURROWLAND_0_1_0_WASM_BYTES => "res/burrowland_0.1.0.wasm",
    TEST_ORACLE_WASM_BYTES => "res/test_oracle.wasm",

    FUNGIBLE_TOKEN_WASM_BYTES => "res/fungible_token.wasm",
}

pub fn burrowland_0_1_0_wasm_bytes() -> &'static [u8] {
    &BURROWLAND_0_1_0_WASM_BYTES
}

pub const NEAR: &str = "near";
pub const ORACLE_ID: &str = "oracle.near";
pub const BURROWLAND_ID: &str = "burrowland.near";
pub const BOOSTER_TOKEN_ID: &str = "token.burrowland.near";
pub const OWNER_ID: &str = "owner.near";

pub const DEFAULT_GAS: Gas = Gas(Gas::ONE_TERA.0 * 15);
pub const MAX_GAS: Gas = Gas(Gas::ONE_TERA.0 * 300);
pub const BOOSTER_TOKEN_DECIMALS: u8 = 18;
pub const BOOSTER_TOKEN_TOTAL_SUPPLY: Balance =
    1_000_000_000 * 10u128.pow(BOOSTER_TOKEN_DECIMALS as _);

pub const DEPOSIT_TO_RESERVE: &str = "\"DepositToReserve\"";

pub struct Env {
    pub root: UserAccount,
    pub near: UserAccount,
    pub owner: UserAccount,
    pub oracle: ContractAccount<OracleContract>,
    pub contract: ContractAccount<BurrowlandContract>,
    pub booster_token: UserAccount,
}

pub struct Tokens {
    pub wnear: UserAccount,
    pub neth: UserAccount,
    pub ndai: UserAccount,
    pub nusdt: UserAccount,
    pub nusdc: UserAccount,
}

pub struct Users {
    pub alice: UserAccount,
    pub bob: UserAccount,
    pub charlie: UserAccount,
    pub dude: UserAccount,
    pub eve: UserAccount,
}

pub fn storage_deposit(
    user: &UserAccount,
    contract_id: &AccountId,
    account_id: &AccountId,
    attached_deposit: Balance,
) {
    user.call(
        contract_id.clone(),
        "storage_deposit",
        &json!({ "account_id": account_id }).to_string().into_bytes(),
        DEFAULT_GAS.0,
        attached_deposit,
    )
    .assert_success();
}

pub fn ft_storage_deposit(
    user: &UserAccount,
    token_account_id: &AccountId,
    account_id: &AccountId,
) {
    storage_deposit(
        user,
        token_account_id,
        account_id,
        125 * env::STORAGE_PRICE_PER_BYTE,
    );
}

pub fn to_nano(timestamp: u32) -> Timestamp {
    Timestamp::from(timestamp) * 10u64.pow(9)
}

impl Env {
    pub fn init_with_contract(contract_bytes: &[u8]) -> Self {
        let mut genesis_config = GenesisConfig::default();
        genesis_config.block_prod_time = 0;
        let root = init_simulator(Some(genesis_config));
        let near = root.create_user(
            AccountId::new_unchecked(NEAR.to_string()),
            to_yocto("1000000"),
        );
        let owner = near.create_user(
            AccountId::new_unchecked(OWNER_ID.to_string()),
            to_yocto("10000"),
        );

        let oracle = deploy!(
            contract: OracleContract,
            contract_id: ORACLE_ID.to_string(),
            bytes: &TEST_ORACLE_WASM_BYTES,
            signer_account: near,
            deposit: to_yocto("10")
        );

        let contract = deploy!(
            contract: BurrowlandContract,
            contract_id: BURROWLAND_ID.to_string(),
            bytes: &contract_bytes,
            signer_account: near,
            deposit: to_yocto("20"),
            gas: DEFAULT_GAS.0,
            init_method: new(
                Config {
                    oracle_account_id: a(ORACLE_ID),
                    owner_id: owner.account_id(),
                    booster_token_id: a(BOOSTER_TOKEN_ID),
                    booster_decimals: BOOSTER_TOKEN_DECIMALS,
                }
            )
        );

        let booster_token = contract.user_account.deploy_and_init(
            &FUNGIBLE_TOKEN_WASM_BYTES,
            a(BOOSTER_TOKEN_ID),
            "new",
            &json!({
                "owner_id": owner.account_id(),
                "total_supply": U128::from(BOOSTER_TOKEN_TOTAL_SUPPLY),
                "metadata": FungibleTokenMetadata {
                    spec: FT_METADATA_SPEC.to_string(),
                    name: "Booster Token".to_string(),
                    symbol: "BOOSTER".to_string(),
                    icon: None,
                    reference: None,
                    reference_hash: None,
                    decimals: BOOSTER_TOKEN_DECIMALS,
                }
            })
            .to_string()
            .into_bytes(),
            to_yocto("10"),
            DEFAULT_GAS.0,
        );

        ft_storage_deposit(&owner, &a(BOOSTER_TOKEN_ID), &a(BURROWLAND_ID));

        Self {
            root,
            near,
            owner,
            contract,
            oracle,
            booster_token,
        }
    }

    pub fn init() -> Self {
        Self::init_with_contract(&BURROWLAND_WASM_BYTES)
    }

    pub fn redeploy_latest(&self) {
        self.contract
            .user_account
            .create_transaction(a(BURROWLAND_ID))
            .deploy_contract(BURROWLAND_WASM_BYTES.to_vec())
            .submit()
            .assert_success();
    }

    pub fn setup_assets(&self, tokens: &Tokens) {
        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    self.booster_token.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000008319516250272147),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 2000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: false,
                        can_borrow: false,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.neth.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000001547125956667610),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.ndai.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdt.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.nusdc.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000002440418605283556),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 9500,
                        extra_decimals: 12,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();

        self.owner
            .function_call(
                self.contract.contract.add_asset(
                    tokens.wnear.account_id(),
                    AssetConfig {
                        reserve_ratio: 2500,
                        target_utilization: 8000,
                        target_utilization_rate: U128(1000000000003593629036885046),
                        max_utilization_rate: U128(1000000000039724853136740579),
                        volatility_ratio: 6000,
                        extra_decimals: 0,
                        can_deposit: true,
                        can_withdraw: true,
                        can_use_as_collateral: true,
                        can_borrow: true,
                    },
                ),
                DEFAULT_GAS.0,
                ONE_YOCTO,
            )
            .assert_success();
    }

    pub fn deposit_reserves(&self, tokens: &Tokens) {
        self.contract_ft_transfer_call(
            &tokens.wnear,
            &self.owner,
            d(10000, 24),
            DEPOSIT_TO_RESERVE,
        );
        self.contract_ft_transfer_call(&tokens.neth, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.ndai, &self.owner, d(10000, 18), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdt, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(&tokens.nusdc, &self.owner, d(10000, 6), DEPOSIT_TO_RESERVE);
        self.contract_ft_transfer_call(
            &self.booster_token,
            &self.owner,
            d(10000, 18),
            DEPOSIT_TO_RESERVE,
        );
    }

    pub fn contract_ft_transfer_call(
        &self,
        token: &UserAccount,
        user: &UserAccount,
        amount: Balance,
        msg: &str,
    ) -> ExecutionResult {
        user.call(
            token.account_id.clone(),
            "ft_transfer_call",
            &json!({
                "receiver_id": self.contract.user_account.account_id(),
                "amount": U128::from(amount),
                "msg": msg,
            })
            .to_string()
            .into_bytes(),
            MAX_GAS.0,
            1,
        )
    }

    pub fn mint_ft(&self, token: &UserAccount, receiver: &UserAccount, amount: Balance) {
        self.owner
            .call(
                token.account_id.clone(),
                "ft_transfer",
                &json!({
                    "receiver_id": receiver.account_id(),
                    "amount": U128::from(amount),
                })
                .to_string()
                .into_bytes(),
                DEFAULT_GAS.0,
                1,
            )
            .assert_success();
    }

    pub fn mint_tokens(&self, tokens: &Tokens, user: &UserAccount) {
        ft_storage_deposit(user, &tokens.wnear.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.neth.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.ndai.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdt.account_id(), &user.account_id());
        ft_storage_deposit(user, &tokens.nusdc.account_id(), &user.account_id());
        ft_storage_deposit(user, &self.booster_token.account_id(), &user.account_id());

        let amount = 1000000;
        self.mint_ft(&tokens.wnear, user, d(amount, 24));
        self.mint_ft(&tokens.neth, user, d(amount, 18));
        self.mint_ft(&tokens.ndai, user, d(amount, 18));
        self.mint_ft(&tokens.nusdt, user, d(amount, 6));
        self.mint_ft(&tokens.nusdc, user, d(amount, 6));
        self.mint_ft(&self.booster_token, user, d(amount, 18));
    }

    pub fn get_asset(&self, token: &UserAccount) -> AssetDetailedView {
        let asset: Option<AssetDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_asset(token.account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn get_account(&self, user: &UserAccount) -> AccountDetailedView {
        let asset: Option<AccountDetailedView> = self
            .near
            .view_method_call(self.contract.contract.get_account(user.account_id()))
            .unwrap_json();
        asset.unwrap()
    }

    pub fn supply_to_collateral(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        amount: Balance,
    ) -> ExecutionResult {
        self.contract_ft_transfer_call(
            &token,
            &user,
            amount,
            &serde_json::to_string(&TokenReceiverMsg::Execute {
                actions: vec![Action::IncreaseCollateral(AssetAmount {
                    token_id: token.account_id(),
                    amount: None,
                    max_amount: None,
                })],
            })
            .unwrap(),
        )
    }

    pub fn oracle_call(
        &self,
        user: &UserAccount,
        price_data: PriceData,
        msg: PriceReceiverMsg,
    ) -> ExecutionResult {
        user.function_call(
            self.oracle.contract.oracle_call(
                self.contract.user_account.account_id(),
                price_data,
                serde_json::to_string(&msg).unwrap(),
            ),
            MAX_GAS.0,
            ONE_YOCTO,
        )
    }

    pub fn borrow(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![Action::Borrow(AssetAmount {
                    token_id: token.account_id(),
                    amount: Some(amount.into()),
                    max_amount: None,
                })],
            },
        )
    }

    pub fn borrow_and_withdraw(
        &self,
        user: &UserAccount,
        token: &UserAccount,
        price_data: PriceData,
        amount: Balance,
    ) -> ExecutionResult {
        self.oracle_call(
            &user,
            price_data,
            PriceReceiverMsg::Execute {
                actions: vec![
                    Action::Borrow(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                    Action::Withdraw(AssetAmount {
                        token_id: token.account_id(),
                        amount: Some(amount.into()),
                        max_amount: None,
                    }),
                ],
            },
        )
    }

    pub fn skip_time(&self, seconds: u32) {
        self.near.borrow_runtime_mut().cur_block.block_timestamp += to_nano(seconds);
    }
}

pub fn init_token(e: &Env, token_account_id: &AccountId, decimals: u8) -> UserAccount {
    let token = e.near.deploy_and_init(
        &FUNGIBLE_TOKEN_WASM_BYTES,
        token_account_id.clone(),
        "new",
        &json!({
            "owner_id": e.owner.account_id(),
            "total_supply": U128::from(10u128.pow((9 + decimals) as _)),
            "metadata": FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: token_account_id.to_string(),
                symbol: token_account_id.to_string(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: decimals,
            }
        })
        .to_string()
        .into_bytes(),
        to_yocto("10"),
        DEFAULT_GAS.0,
    );

    ft_storage_deposit(&e.owner, token_account_id, &e.contract.account_id());
    token
}

impl Tokens {
    pub fn init(e: &Env) -> Self {
        Self {
            wnear: init_token(e, &a("wrap.near"), 24),
            neth: init_token(e, &a("neth.near"), 18),
            ndai: init_token(e, &a("dai.near"), 18),
            nusdt: init_token(e, &a("nusdt.near"), 6),
            nusdc: init_token(e, &a("nusdc.near"), 6),
        }
    }
}

impl Users {
    pub fn init(e: &Env) -> Self {
        Self {
            alice: e.near.create_user(a("alice.near"), to_yocto("10000")),
            bob: e.near.create_user(a("bob.near"), to_yocto("10000")),
            charlie: e.near.create_user(a("charlie.near"), to_yocto("10000")),
            dude: e.near.create_user(a("dude.near"), to_yocto("10000")),
            eve: e.near.create_user(a("eve.near"), to_yocto("10000")),
        }
    }
}

pub fn d(value: Balance, decimals: u8) -> Balance {
    value * 10u128.pow(decimals as _)
}
pub fn a(account_id: &str) -> AccountId {
    AccountId::new_unchecked(account_id.to_string())
}

pub fn price_data(
    tokens: &Tokens,
    wnear_mul: Option<Balance>,
    neth_mul: Option<Balance>,
) -> PriceData {
    let mut prices = vec![
        AssetOptionalPrice {
            asset_id: tokens.ndai.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 22,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdc.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
        AssetOptionalPrice {
            asset_id: tokens.nusdt.account_id().to_string(),
            price: Some(Price {
                multiplier: 10000,
                decimals: 10,
            }),
        },
    ];
    if let Some(wnear_mul) = wnear_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.wnear.account_id().to_string(),
            price: Some(Price {
                multiplier: wnear_mul,
                decimals: 28,
            }),
        })
    }
    if let Some(neth_mul) = neth_mul {
        prices.push(AssetOptionalPrice {
            asset_id: tokens.neth.account_id().to_string(),
            price: Some(Price {
                multiplier: neth_mul,
                decimals: 22,
            }),
        })
    }
    PriceData {
        timestamp: 0,
        recency_duration_sec: 90,
        prices,
    }
}

pub fn basic_setup_with_contract(contract_bytes: &[u8]) -> (Env, Tokens, Users) {
    let e = Env::init_with_contract(contract_bytes);
    let tokens = Tokens::init(&e);
    e.setup_assets(&tokens);
    e.deposit_reserves(&tokens);

    let users = Users::init(&e);
    e.mint_tokens(&tokens, &users.alice);
    storage_deposit(
        &users.alice,
        &e.contract.account_id(),
        &users.alice.account_id(),
        d(1, 23),
    );
    e.mint_tokens(&tokens, &users.bob);
    storage_deposit(
        &users.bob,
        &e.contract.account_id(),
        &users.bob.account_id(),
        d(1, 23),
    );

    (e, tokens, users)
}

pub fn basic_setup() -> (Env, Tokens, Users) {
    basic_setup_with_contract(&BURROWLAND_WASM_BYTES)
}

'''
'''--- smart-contract/tests/upgrade.rs ---
mod setup;

use crate::setup::*;

#[test]
fn test_upgrade() {
    let (e, tokens, users) = basic_setup_with_contract(burrowland_0_1_0_wasm_bytes());

    let amount = d(100, 24);
    e.contract_ft_transfer_call(&tokens.wnear, &users.alice, amount, "")
        .assert_success();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
    assert_eq!(account.supplied[0].token_id, tokens.wnear.account_id());

    e.redeploy_latest();

    let asset = e.get_asset(&tokens.wnear);
    assert_eq!(asset.supplied.balance, amount);

    let account = e.get_account(&users.alice);
    assert_eq!(account.supplied[0].balance, amount);
}

'''
'''--- sub.duyhoag.testnet.json ---
{"account_id":"sub.duyhoag.testnet","public_key":"ed25519:5k7gnfWcBqN8voKxhpSmTosh7NBbAgpD3X6D8RE3GcrE","private_key":"ed25519:3TjLzn22wXCdeozxWJoUCmuyE9tcjeeUWDqFJroWXTYML62wzFoiePwWf54FKBXkwkQhMXSAcMfe7Q1xWKXvPDt"}
'''