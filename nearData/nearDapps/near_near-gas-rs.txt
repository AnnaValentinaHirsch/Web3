*GitHub Repository "near/near-gas-rs"*

'''--- .github/workflows/ci.yml ---
name: CI

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  RUSTFLAGS: -D warnings
  RUST_BACKTRACE: short
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0

jobs:
  test-msrv:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Install minimal supported Rust version
      uses: dtolnay/rust-toolchain@1.68

    - name: Run cargo test
      run: cargo test --verbose

  test-all-features:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Install minimal supported Rust version
      uses: dtolnay/rust-toolchain@stable

    - name: Run cargo test
      run: cargo test --verbose --all-features

  clippy:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Run clippy
      run: cargo clippy --all-features -- -D clippy::all

  cargo-fmt:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Run cargo fmt
      run: cargo fmt -- --check

  release-plz:
    runs-on: ubuntu-latest
    needs: [test-msrv, test-all-features, clippy, cargo-fmt]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://marcoieni.github.io/release-plz/github-action.html#triggering-further-workflow-runs
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.5](https://github.com/near/near-gas/compare/v0.2.4...v0.2.5) - 2023-10-23

### Other
- Update README.md
- Fixed typo and added badges in README.md ([#12](https://github.com/near/near-gas/pull/12))

## [0.2.4](https://github.com/near/near-gas/compare/v0.2.3...v0.2.4) - 2023-10-22

### Other
- Small cleanups in various places ([#10](https://github.com/near/near-gas/pull/10))
- Update `borsh`, separate `borsh/unstable__schema` and `schemars` under `abi` feature ([#8](https://github.com/near/near-gas/pull/8))
- Add github actions jobs from rust template ([#9](https://github.com/near/near-gas/pull/9))
- Split lib.rs into smaller files to ease testing, extension, and review ([#5](https://github.com/near/near-gas/pull/5))

'''
'''--- Cargo.toml ---
[package]
name = "near-gas"
version = "0.2.5"
edition = "2021"
authors = ["Serhieiev Ivan <serhieievivan6@gmail.com>", "Vlad Frolov <frolvlad@gmail.com>"]
repository = "https://github.com/near/near-gas"
rust-version = "1.68.0"
categories = ["parser-implementations", "value-formatting", "no-std"]
license = "MIT OR Apache-2.0"
description = "a small crate to work with NEAR Gas unit values ergonomically and efficiently (NEAR Protocol)"

[dependencies]
serde = { version = "1", features = ["derive"], optional = true }
borsh = { version = "1", features = ["derive"], optional = true }
schemars = { version = "0.8.8", optional = true }
interactive-clap = { version = "0.2.4", optional = true }

[dev-dependencies]
serde_json = { version = "1" }

[features]
abi = ["borsh/unstable__schema", "schemars"]

'''
'''--- README.md ---
# near-gas

<p>
    <a href="https://crates.io/crates/near-gas"><img src="https://img.shields.io/crates/d/near-gas?style=flat-square&logo=near&label=crates.io" alt="Crates.io (downloads)"></a>
    <a href="https://docs.rs/near-gas/latest/near_gas/"><img src="https://img.shields.io/docsrs/near-gas?style=flat-square" alt="Docs.rs"></a>
    <img src="https://img.shields.io/badge/rustc-1.68%2B-lightgray.svg?style=flat-square" alt="Rust Version">
</p>

near-gas is crate to ergonomically operate with NEAR Protocol gas unit in Rust projects.

The crate includes NearGas type and constructors for converting data as NearGas and as u64 type values.

## near-gas examples 

```rust
use near_gas::NearGas;

fn main() {
    let data = "12.657 tgas";

    let near_gas: NearGas = data.parse().unwrap();

    // Convert the value to the most precise "gas" unit
    assert_eq!(near_gas.as_gas(), 12657000000000);
    // Convert the value to "gigagas" unit
    assert_eq!(near_gas.as_ggas(), 12657);
    
    // Display Gas. It will print: "Here is 12.7 Tgas"
    println!("Here is {}", near_gas);

    // When `serde` feature is enabled, NearGas can be used in serde-serializable structs.
    // NearGas will be serialized to a gas-precision u64 value encoded as string.
    #[derive(serde::Serialize)]
    struct FunctionCallDetails {
        used_gas: NearGas,
    }

    let details = FunctionCallDetails { used_gas: near_gas };

    assert_eq!(serde_json::to_string(&details).unwrap(), r#"{"used_gas":"12657000000000"}"#);
}
```

## NearGas information

On every transaction you send to the network NEAR charges you a fee (aka gas fee). This fee is used to indirectly pay the people that keep the network infrastructure, and to incentivize developers of smart contracts. [For more information].

[Gas usage in Near Protocol]

## Crate Features

* `serde` - [serde](https://serde.rs/) support
* `borsh` - [borsh](https://github.com/near/borsh-rs) support
* `abi` - [near-abi](https://github.com/near/abi) support
* `schemars` - [schemars](https://github.com/GREsau/schemars) support
* `interactive-clap` - [interactive-clap](https://github.com/near-cli-rs/interactive-clap) support

### License

This project is licensed under the [MIT license] and [Apache-2.0 license].

[MIT license]: https://github.com/Mr0melian/near_gas/blob/master/LICENSE-MIT
[Apache-2.0 license]:  https://github.com/Mr0melian/near_gas/blob/master/LICENSE-APACHE
[For more information]: https://docs.near.org/concepts/basics/transactions/gas
[Gas usage in Near Protocol]: https://nomicon.io/RuntimeSpec/Fees/

'''
'''--- src/error.rs ---
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NearGasError {
    IncorrectNumber(crate::utils::DecimalNumberParsingError),
    IncorrectUnit(String),
}

impl std::error::Error for NearGasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            NearGasError::IncorrectNumber(err) => Some(err),
            NearGasError::IncorrectUnit(_) => None,
        }
    }
}

'''
'''--- src/lib.rs ---
//! A `NearGas` type to represent a value of Gas.
//!
//! Each `NearGas` is composed of a whole number of Gases.
//! `NearGas` is implementing the common trait `FromStr`. Also, have utils function to parse from `str` into `u64`.
//!
//! # Examples
//! ```
//! use near_gas::*;
//!
//! let one_tera_gas = NearGas::from_gas(10_u64.pow(12));
//! assert_eq!(one_tera_gas, NearGas::from_tgas(1));
//! assert_eq!(one_tera_gas, NearGas::from_ggas(1000));
//! ```
//!
//! # Crate features
//!
//! * **borsh** (optional) -
//!   When enabled allows `NearGas` to serialized and deserialized by `borsh`.
//!
//! * **serde** (optional) -
//!   When enabled allows `NearGas` to serialized and deserialized by `serde`.
//!
//! * **schemars** (optional) -
//!  Implements `schemars::JsonSchema` for `NearGas`.
//!
//! * **interactive-clap** (optional) -
//!  Implements `interactive_clap::ToCli` for `NearGas`.
mod error;
mod trait_impls;
mod utils;

pub use self::error::NearGasError;
pub use self::utils::DecimalNumberParsingError;

#[derive(Default, Debug, Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Hash)]
#[cfg_attr(
    feature = "borsh",
    derive(borsh::BorshDeserialize, borsh::BorshSerialize)
)]
#[cfg_attr(feature = "abi", derive(borsh::BorshSchema))]
#[repr(transparent)]
pub struct NearGas {
    inner: u64,
}

const ONE_TERA_GAS: u64 = 10u64.pow(12);
const ONE_GIGA_GAS: u64 = 10u64.pow(9);

impl NearGas {
    /// Creates a new `NearGas` from the specified number of whole tera Gas.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    ///
    /// let tera_gas = NearGas::from_tgas(5);
    ///
    /// assert_eq!(tera_gas.as_gas(), 5 * 1_000_000_000_000);
    /// ```
    pub const fn from_tgas(mut inner: u64) -> Self {
        inner *= ONE_TERA_GAS;
        Self { inner }
    }

    /// Creates a new `NearGas` from the specified number of whole giga Gas.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    ///
    /// let giga_gas = NearGas::from_ggas(5);
    ///
    /// assert_eq!(giga_gas.as_gas(), 5 * 1_000_000_000);
    /// ```
    pub const fn from_ggas(mut inner: u64) -> Self {
        inner *= ONE_GIGA_GAS;
        Self { inner }
    }

    /// Creates a new `NearGas` from the specified number of whole Gas.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    ///
    /// let gas = NearGas::from_gas(5 * 1_000_000_000_000);
    ///
    /// assert_eq!(gas.as_tgas(), 5);
    /// ```
    pub const fn from_gas(inner: u64) -> Self {
        Self { inner }
    }

    /// Returns the total number of whole Gas contained by this `NearGas`.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// let neargas = NearGas::from_gas(12345);
    /// assert_eq!(neargas.as_gas(), 12345);
    /// ```
    pub const fn as_gas(self) -> u64 {
        self.inner
    }

    /// Returns the total number of a whole part of giga Gas contained by this `NearGas`.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// let neargas = NearGas::from_gas(1 * 1_000_000_000);
    /// assert_eq!(neargas.as_ggas(), 1);
    /// ```
    pub const fn as_ggas(self) -> u64 {
        self.inner / ONE_GIGA_GAS
    }

    /// Returns the total number of a whole part of tera Gas contained by this `NearGas`.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// let neargas = NearGas::from_gas(1 * 1_000_000_000_000);
    /// assert_eq!(neargas.as_tgas(), 1);
    /// ```
    pub const fn as_tgas(self) -> u64 {
        self.inner / ONE_TERA_GAS
    }

    /// Checked integer addition. Computes self + rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// use std::u64;
    /// assert_eq!(NearGas::from_gas(u64::MAX -2).checked_add(NearGas::from_gas(2)), Some(NearGas::from_gas(u64::MAX)));
    /// assert_eq!(NearGas::from_gas(u64::MAX -2).checked_add(NearGas::from_gas(3)), None);
    /// ```
    pub const fn checked_add(self, rhs: NearGas) -> Option<Self> {
        if let Some(gas) = self.as_gas().checked_add(rhs.as_gas()) {
            Some(Self::from_gas(gas))
        } else {
            None
        }
    }

    /// Checked integer subtraction. Computes self - rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// assert_eq!(NearGas::from_gas(2).checked_sub(NearGas::from_gas(2)), Some(NearGas::from_gas(0)));
    /// assert_eq!(NearGas::from_gas(2).checked_sub(NearGas::from_gas(3)), None);
    /// ```
    pub const fn checked_sub(self, rhs: NearGas) -> Option<Self> {
        if let Some(gas) = self.as_gas().checked_sub(rhs.as_gas()) {
            Some(Self::from_gas(gas))
        } else {
            None
        }
    }

    /// Checked integer multiplication. Computes self * rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// use std::u64;
    /// assert_eq!(NearGas::from_gas(2).checked_mul(2), Some(NearGas::from_gas(4)));
    /// assert_eq!(NearGas::from_gas(u64::MAX).checked_mul(2), None)
    pub const fn checked_mul(self, rhs: u64) -> Option<Self> {
        if let Some(gas) = self.as_gas().checked_mul(rhs) {
            Some(Self::from_gas(gas))
        } else {
            None
        }
    }

    /// Checked integer division. Computes self / rhs, returning None if rhs == 0.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// assert_eq!(NearGas::from_gas(10).checked_div(2), Some(NearGas::from_gas(5)));
    /// assert_eq!(NearGas::from_gas(2).checked_div(0), None);
    /// ```
    pub const fn checked_div(self, rhs: u64) -> Option<Self> {
        if let Some(gas) = self.as_gas().checked_div(rhs) {
            Some(Self::from_gas(gas))
        } else {
            None
        }
    }

    /// Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// assert_eq!(NearGas::from_gas(5).saturating_add(NearGas::from_gas(5)), NearGas::from_gas(10));
    /// assert_eq!(NearGas::from_gas(u64::MAX).saturating_add(NearGas::from_gas(1)), NearGas::from_gas(u64::MAX));
    /// ```
    pub const fn saturating_add(self, rhs: NearGas) -> NearGas {
        NearGas::from_gas(self.as_gas().saturating_add(rhs.as_gas()))
    }

    /// Saturating integer subtraction. Computes self - rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// assert_eq!(NearGas::from_gas(5).saturating_sub(NearGas::from_gas(2)), NearGas::from_gas(3));
    /// assert_eq!(NearGas::from_gas(1).saturating_sub(NearGas::from_gas(2)), NearGas::from_gas(0));
    /// ```
    pub const fn saturating_sub(self, rhs: NearGas) -> NearGas {
        NearGas::from_gas(self.as_gas().saturating_sub(rhs.as_gas()))
    }

    /// Saturating integer multiplication. Computes self * rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// use std::u64;
    /// assert_eq!(NearGas::from_gas(2).saturating_mul(5), NearGas::from_gas(10));
    /// assert_eq!(NearGas::from_gas(u64::MAX).saturating_mul(2), NearGas::from_gas(u64::MAX));
    /// ```
    pub const fn saturating_mul(self, rhs: u64) -> NearGas {
        NearGas::from_gas(self.as_gas().saturating_mul(rhs))
    }

    /// Saturating integer division. Computes self / rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_gas::NearGas;
    /// assert_eq!(NearGas::from_gas(10).saturating_div(2), NearGas::from_gas(5));
    /// assert_eq!(NearGas::from_gas(10).saturating_div(0), NearGas::from_gas(0))
    /// ```
    pub const fn saturating_div(self, rhs: u64) -> NearGas {
        if rhs == 0 {
            return NearGas::from_gas(0);
        }
        NearGas::from_gas(self.as_gas().saturating_div(rhs))
    }
}

#[cfg(test)]
mod test {
    use crate::NearGas;

    #[test]
    fn checked_add_gas() {
        let gas = NearGas::from_gas(u64::MAX - 3);
        let any_gas = NearGas::from_gas(3);
        let more_gas = NearGas::from_gas(4);
        assert_eq!(gas.checked_add(any_gas), Some(NearGas::from_gas(u64::MAX)));
        assert_eq!(gas.checked_add(more_gas), None);
    }

    #[test]
    fn checked_sub_gas() {
        let gas = NearGas::from_gas(3);
        let any_gas = NearGas::from_gas(1);
        let more_gas = NearGas::from_gas(4);
        assert_eq!(gas.checked_sub(any_gas), Some(NearGas::from_gas(2)));
        assert_eq!(gas.checked_sub(more_gas), None);
    }

    #[test]
    fn checked_mul_gas() {
        let gas = NearGas::from_gas(u64::MAX / 10);
        assert_eq!(
            gas.checked_mul(10),
            Some(NearGas::from_gas(u64::MAX / 10 * 10))
        );
        assert_eq!(gas.checked_mul(11), None);
    }

    #[test]
    fn checked_div_gas() {
        let gas = NearGas::from_gas(10);
        assert_eq!(gas.checked_div(2), Some(NearGas::from_gas(5)));
        assert_eq!(gas.checked_div(11), Some(NearGas::from_gas(0)));
        assert_eq!(gas.checked_div(0), None);
    }

    #[test]
    fn saturating_add_gas() {
        let gas = NearGas::from_gas(100);
        let added_gas = NearGas::from_gas(1);
        let another_gas = NearGas::from_gas(u64::MAX);
        assert_eq!(
            gas.saturating_add(added_gas.clone()),
            NearGas::from_gas(101)
        );
        assert_eq!(
            another_gas.saturating_add(added_gas),
            NearGas::from_gas(u64::MAX)
        );
    }

    #[test]
    fn saturating_sub_gas() {
        let gas = NearGas::from_gas(100);
        let rhs_gas = NearGas::from_gas(1);
        let another_gas = NearGas::from_gas(u64::MIN);
        assert_eq!(gas.saturating_sub(rhs_gas.clone()), NearGas::from_gas(99));
        assert_eq!(
            another_gas.saturating_sub(rhs_gas),
            NearGas::from_gas(u64::MIN)
        );
    }

    #[test]
    fn saturating_mul_gas() {
        let gas = NearGas::from_gas(2);
        let rhs = 10;
        let another_gas = u64::MAX;
        assert_eq!(gas.saturating_mul(rhs), NearGas::from_gas(20));
        assert_eq!(gas.saturating_mul(another_gas), NearGas::from_gas(u64::MAX));
    }

    #[test]
    fn saturating_div_gas() {
        let gas = NearGas::from_gas(10);
        let rhs = 2;
        let another_gas = 20;
        assert_eq!(gas.saturating_div(rhs), NearGas::from_gas(5));
        assert_eq!(gas.saturating_div(another_gas), NearGas::from_gas(0));
    }
}

'''
'''--- src/trait_impls/borsh.rs ---
#[cfg(test)]
mod test {
    use borsh::{to_vec, BorshDeserialize};

    use crate::NearGas;

    #[test]
    fn borsh() {
        fn test_borsh_ser(val: u64, expected_serialized_value: [u8; 8]) {
            let gas = NearGas::from_gas(val);
            let ser = to_vec(&gas).unwrap();
            // println!("{:?}", ser);
            assert_eq!(expected_serialized_value, ser.as_slice());
            let de: NearGas = NearGas::try_from_slice(&ser).unwrap();
            assert_eq!(de.as_gas(), val);
        }

        test_borsh_ser(u64::MAX, [255, 255, 255, 255, 255, 255, 255, 255]);
        test_borsh_ser(8, [8, 0, 0, 0, 0, 0, 0, 0]);
        test_borsh_ser(0, [0, 0, 0, 0, 0, 0, 0, 0]);
    }
}

'''
'''--- src/trait_impls/display.rs ---
use crate::{NearGas, NearGasError, ONE_GIGA_GAS};

/// NearGas Display implementation rounds up the gas usage to the relevant precision point.
/// There are 4 breakpoints:
/// 1. exactly 0 Tgas
/// 2. <0.001 Tgas
/// 3. 0.001 - 0.999 Tgas (uses 3 digits after the floating point)
/// 4. >1 Tgas (uses 1 digit after the floating point)
impl std::fmt::Display for NearGas {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if *self == NearGas::from_gas(0) {
            write!(f, "0 Tgas")
        } else if *self < NearGas::from_ggas(1) {
            write!(f, "<0.001 Tgas")
        } else if *self <= NearGas::from_ggas(999) {
            let gigagas_rounded_up = self.as_gas().saturating_add(ONE_GIGA_GAS - 1) / ONE_GIGA_GAS;
            write!(f, "0.{:03} Tgas", gigagas_rounded_up)
        } else {
            let terragas_rounded_up =
                self.as_gas().saturating_add(100 * ONE_GIGA_GAS - 1) / ONE_GIGA_GAS / 100;
            write!(
                f,
                "{}.{} Tgas",
                terragas_rounded_up / 10,
                terragas_rounded_up % 10
            )
        }
    }
}

impl std::fmt::Display for NearGasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            NearGasError::IncorrectNumber(err) => write!(f, "Incorrect number: {:?}", err),
            NearGasError::IncorrectUnit(err) => write!(f, "Incorrect unit: {}", err),
        }
    }
}

#[cfg(test)]
mod test {
    use crate::NearGas;

    #[test]
    fn test_display() {
        for (near_gas, expected_display) in [
            (NearGas::from_gas(0), "0 Tgas"),
            (NearGas::from_gas(1), "<0.001 Tgas"),
            (NearGas::from_gas(999_999_999), "<0.001 Tgas"),
            (NearGas::from_gas(1_000_000_000), "0.001 Tgas"),
            (NearGas::from_gas(1_000_000_001), "0.002 Tgas"),
            (NearGas::from_gas(2_000_000_000), "0.002 Tgas"),
            (NearGas::from_gas(200_000_000_000), "0.200 Tgas"),
            (NearGas::from_gas(999_000_000_000), "0.999 Tgas"),
            (NearGas::from_gas(999_000_000_001), "1.0 Tgas"),
            (NearGas::from_gas(999_999_999_999), "1.0 Tgas"),
            (NearGas::from_gas(1_000_000_000_000), "1.0 Tgas"),
            (NearGas::from_gas(1_000_000_000_001), "1.1 Tgas"),
            (NearGas::from_gas(1_234_567_000_000), "1.3 Tgas"),
            (NearGas::from_gas(1_500_000_000_000), "1.5 Tgas"),
            (NearGas::from_gas(10_000_000_000_000), "10.0 Tgas"),
            (NearGas::from_gas(10_500_000_000_000), "10.5 Tgas"),
            (NearGas::from_gas(99_999_999_999_999), "100.0 Tgas"),
            (NearGas::from_gas(100_000_000_000_000), "100.0 Tgas"),
            (NearGas::from_gas(100_500_000_000_000), "100.5 Tgas"),
            (NearGas::from_gas(1_000_500_000_000_000), "1000.5 Tgas"),
            (
                NearGas::from_gas(1_000_000_500_000_000_000),
                "1000000.5 Tgas",
            ),
        ] {
            assert_eq!(
                near_gas.to_string(),
                expected_display,
                "gas: {}",
                near_gas.as_gas()
            );
        }
    }
}

'''
'''--- src/trait_impls/from_str.rs ---
use crate::{NearGas, NearGasError, ONE_GIGA_GAS, ONE_TERA_GAS};

impl std::str::FromStr for NearGas {
    type Err = NearGasError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let uppercase_s = s.trim().to_ascii_uppercase();
        let (value, unit) = uppercase_s.split_at(
            s.find(|c: char| c.is_ascii_alphabetic())
                .ok_or_else(|| NearGasError::IncorrectUnit(s.to_owned()))?,
        );
        let unit_precision = match unit {
            "TGAS" | "TERAGAS" => ONE_TERA_GAS,
            "GIGAGAS" | "GGAS" => ONE_GIGA_GAS,
            _ => return Err(NearGasError::IncorrectUnit(s.to_owned())),
        };
        Ok(NearGas::from_gas(
            crate::utils::parse_decimal_number(value.trim(), unit_precision)
                .map_err(NearGasError::IncorrectNumber)?,
        ))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::{DecimalNumberParsingError, NearGas, NearGasError};

    #[test]
    fn doubledot() {
        let data = "1.1.1 TeraGas";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearGasError::IncorrectNumber(
                DecimalNumberParsingError::InvalidNumber("1.1.1".to_owned())
            ))
        )
    }

    #[test]
    fn space_after_dot() {
        let data = "1. 0 TeraGas";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearGasError::IncorrectNumber(
                DecimalNumberParsingError::InvalidNumber("1. 0".to_owned())
            ))
        )
    }

    #[test]
    fn decimal_tgas() {
        let data = "0.5 TGas";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(gas, Ok(NearGas::from_ggas(500)))
    }

    #[test]
    fn incorect_currency() {
        let data = "0 pas";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(gas, Err(NearGasError::IncorrectUnit(data.to_owned())))
    }

    #[test]
    fn without_currency() {
        let data = "0";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(gas, Err(NearGasError::IncorrectUnit("0".to_owned())))
    }

    #[test]
    fn invalid_whole() {
        let data = "-1 TeraGas";
        let gas: Result<NearGas, NearGasError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearGasError::IncorrectNumber(
                DecimalNumberParsingError::InvalidNumber("-1".to_owned())
            ))
        )
    }

    #[test]
    fn test_from_str_f64_gas_without_int() {
        let near_gas = NearGas::from_str(".055ggas").unwrap_err();
        assert_eq!(
            near_gas,
            NearGasError::IncorrectNumber(DecimalNumberParsingError::InvalidNumber(
                ".055".to_string()
            ))
        );
    }

    #[test]
    fn test_from_str_without_unit() {
        let near_gas = NearGas::from_str("100").unwrap_err();
        assert_eq!(near_gas, NearGasError::IncorrectUnit("100".to_string()));
    }

    #[test]
    fn test_from_str_incorrect_unit() {
        let near_gas = NearGas::from_str("100 UAH").unwrap_err();
        assert_eq!(near_gas, NearGasError::IncorrectUnit("100 UAH".to_string()));
    }

    #[test]
    fn test_from_str_invalid_double_dot() {
        let near_gas = NearGas::from_str("100.55.").unwrap_err();
        assert_eq!(near_gas, NearGasError::IncorrectUnit("100.55.".to_string()));
    }

    #[test]
    fn test_from_str_large_fractional_part() {
        let near_gas = NearGas::from_str("100.1111122222333 ggas").unwrap_err(); // 13 digits after "."
        assert_eq!(
            near_gas,
            NearGasError::IncorrectNumber(DecimalNumberParsingError::LongFractional(
                "1111122222333".to_string()
            ))
        );
    }

    #[test]
    fn test_from_str_large_int_part() {
        let near_gas = NearGas::from_str("200123456789123.0 tgas").unwrap_err();
        assert_eq!(
            near_gas,
            NearGasError::IncorrectNumber(DecimalNumberParsingError::LongWhole(
                "200123456789123".to_string()
            ))
        );
    }

    #[test]
    fn test_from_str_negative_value() {
        let near_gas = NearGas::from_str("-100 ggas").unwrap_err();
        assert_eq!(
            near_gas,
            NearGasError::IncorrectNumber(DecimalNumberParsingError::InvalidNumber(
                "-100".to_string()
            ))
        );
    }

    #[test]
    fn near_gas_from_str_currency_tgas() {
        assert_eq!(
            NearGas::from_str("10 tgas").unwrap(),
            NearGas::from_gas(10_000_000_000_000) // 14 digits
        );
        assert_eq!(
            NearGas::from_str("10.055TERAGAS").unwrap(),
            NearGas::from_gas(10_055_000_000_000) // 14 digits
        );
    }

    #[test]
    fn near_gas_from_str_currency_gigagas() {
        assert_eq!(
            NearGas::from_str("10 gigagas").unwrap(),
            NearGas::from_gas(10_000_000_000) // 11 digits
        );
        assert_eq!(
            NearGas::from_str("10GGAS ").unwrap(),
            NearGas::from_gas(10_000_000_000) // 11 digits
        );
    }

    #[test]
    fn near_gas_from_str_f64_tgas() {
        assert_eq!(
            NearGas::from_str("0.000001 tgas").unwrap(),
            NearGas::from_gas(1_000_000) // 7 digits
        );
    }
}

'''
'''--- src/trait_impls/interactive_clap.rs ---
use crate::NearGas;

impl interactive_clap::ToCli for NearGas {
    type CliVariant = NearGas;
}

'''
'''--- src/trait_impls/mod.rs ---
#[cfg(feature = "borsh")]
mod borsh;
mod display;
mod from_str;
#[cfg(feature = "interactive-clap")]
mod interactive_clap;
#[cfg(feature = "schemars")]
mod schemars;
#[cfg(feature = "serde")]
mod serde;

'''
'''--- src/trait_impls/schemars.rs ---
use crate::NearGas;

impl schemars::JsonSchema for NearGas {
    fn is_referenceable() -> bool {
        false
    }

    fn schema_name() -> String {
        String::schema_name()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        String::json_schema(gen)
    }
}

'''
'''--- src/trait_impls/serde.rs ---
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};

use crate::NearGas;

impl Serialize for NearGas {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::Error;
        let mut buf = [0u8; 20];
        let remainder = {
            use std::io::Write;
            let mut w: &mut [u8] = &mut buf;
            write!(w, "{}", self.inner)
                .map_err(|err| Error::custom(format!("Failed to serialize: {}", err)))?;
            w.len()
        };
        let len = buf.len() - remainder;

        let s = std::str::from_utf8(&buf[..len])
            .map_err(|err| Error::custom(format!("Failed to serialize: {}", err)))?;
        serializer.serialize_str(s)
    }
}

impl<'de> Deserialize<'de> for NearGas {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        s.parse::<u64>()
            .map(NearGas::from_gas)
            .map_err(|err| de::Error::custom(err.to_string()))
    }
}

#[cfg(test)]
mod test {
    use crate::NearGas;

    #[test]
    fn json_ser() {
        fn test_json_ser(val: u64) {
            let gas = NearGas::from_gas(val);
            let ser = serde_json::to_string(&gas).unwrap();
            assert_eq!(ser, format!("\"{}\"", val));
            let de: NearGas = serde_json::from_str(&ser).unwrap();
            assert_eq!(de.as_gas(), val);
        }

        test_json_ser(u64::MAX);
        test_json_ser(8);
        test_json_ser(0);
    }
}

'''
'''--- src/utils.rs ---
/// Parsing decimal numbers from `&str` type in `u64`.
/// Function also takes a value of metric prefix in u64 type.
/// `parse_str` use the `u64` type, and have the same max and min values.
///
/// If the fractional part is longer than several zeros in the prefix, it will return the error `DecimalNumberParsingError::LongFractional`.
///
/// If the string slice has invalid chars, it will return the error `DecimalNumberParsingError::InvalidNumber`.
///
/// If the whole part of the number has a value more than the `u64` maximum value, it will return the error `DecimalNumberParsingError::LongWhole`.
pub(crate) fn parse_decimal_number(
    s: &str,
    pref_const: u64,
) -> Result<u64, DecimalNumberParsingError> {
    let (int, fract) = if let Some((whole, fractional)) = s.trim().split_once('.') {
        let int: u64 = whole
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        let mut fract: u64 = fractional
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        let len = u32::try_from(fractional.len())
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        fract = fract
            .checked_mul(
                pref_const
                    .checked_div(10u64.checked_pow(len).ok_or_else(|| {
                        DecimalNumberParsingError::LongFractional(fractional.to_owned())
                    })?)
                    .filter(|n| *n != 0u64)
                    .ok_or_else(|| {
                        DecimalNumberParsingError::LongFractional(fractional.to_owned())
                    })?,
            )
            .ok_or_else(|| DecimalNumberParsingError::LongFractional(fractional.to_owned()))?;
        (int, fract)
    } else {
        let int: u64 = s
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        (int, 0)
    };
    let result = fract
        .checked_add(
            int.checked_mul(pref_const)
                .ok_or_else(|| DecimalNumberParsingError::LongWhole(int.to_string()))?,
        )
        .ok_or_else(|| DecimalNumberParsingError::LongWhole(int.to_string()))?;
    Ok(result)
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DecimalNumberParsingError {
    InvalidNumber(String),
    LongWhole(String),
    LongFractional(String),
}

impl std::error::Error for DecimalNumberParsingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }

    fn description(&self) -> &str {
        "description() is deprecated; use Display"
    }

    fn cause(&self) -> Option<&dyn std::error::Error> {
        self.source()
    }
}

impl std::fmt::Display for DecimalNumberParsingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecimalNumberParsingError::InvalidNumber(s) => {
                write!(f, "Invalid number: {}", s)
            }
            DecimalNumberParsingError::LongWhole(s) => {
                write!(f, "Long whole part: {}", s)
            }
            DecimalNumberParsingError::LongFractional(s) => {
                write!(f, "Long fractional part: {}", s)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TEST: [(u64, &'static str, u64); 6] = [
        (129380_000_001u64, "129.380000001", 10u64.pow(9)),
        (12938_000_000_100_000_000u64, "12938000000.1", 10u64.pow(9)),
        (129380_000_001u64, "0.129380000001", 10u64.pow(12)),
        (129380_000_001_000u64, "129.380000001000", 10u64.pow(12)),
        (9488129380_000_001u64, "9488.129380000001", 10u64.pow(12)),
        (129380_000_001u64, "00.129380000001", 10u64.pow(12)),
    ];

    #[test]
    fn parse_test() {
        for (expected_value, str_value, precision) in TEST {
            let parsed_value = parse_decimal_number(str_value, precision).unwrap();
            assert_eq!(parsed_value, expected_value)
        }
    }

    #[test]
    fn test_long_fract() {
        let data = "1.23456";
        let prefix = 10000u64;
        assert_eq!(
            parse_decimal_number(data, prefix),
            Err(DecimalNumberParsingError::LongFractional(23456.to_string()))
        );
    }

    #[test]
    fn invalidnumber_whole() {
        let num = "1h4.7859";
        let prefix: u64 = 10000;
        assert_eq!(
            parse_decimal_number(num, prefix),
            Err(DecimalNumberParsingError::InvalidNumber(
                "1h4.7859".to_owned()
            ))
        );
    }
    #[test]
    fn invalidnumber_fract() {
        let num = "14.785h9";
        let prefix: u64 = 10000;
        assert_eq!(
            parse_decimal_number(num, prefix),
            Err(DecimalNumberParsingError::InvalidNumber(
                "14.785h9".to_owned()
            ))
        );
    }

    #[test]
    fn max_long_fract() {
        let max_data = 10u64.pow(17) + 1;
        let data = "1.".to_string() + max_data.to_string().as_str();
        let prefix = 10u64.pow(17);
        assert_eq!(
            parse_decimal_number(data.as_str(), prefix),
            Err(DecimalNumberParsingError::LongFractional(
                max_data.to_string()
            ))
        );
    }

    #[test]
    fn long_whole_test() {
        let data = 10u64.pow(17) + 1;
        let prefix = 10u64.pow(12);
        let s = data.to_string() + "." + "1";
        assert_eq!(
            parse_decimal_number(s.as_str(), prefix),
            Err(DecimalNumberParsingError::LongWhole(data.to_string()))
        );
    }

    #[test]
    fn parse_u64_errortest() {
        let test_data = u64::MAX.to_string();
        let gas = parse_decimal_number(&test_data, 10u64.pow(9));
        assert_eq!(
            gas,
            Err(DecimalNumberParsingError::LongWhole(u64::MAX.to_string()))
        );
    }

    #[test]
    fn test() {
        let data = "1.000000000000000000000000000000000000001";
        let prefix = 100u64;
        assert_eq!(
            parse_decimal_number(data, prefix),
            Err(DecimalNumberParsingError::LongFractional(
                "000000000000000000000000000000000000001".to_string()
            ))
        );
    }
}

'''