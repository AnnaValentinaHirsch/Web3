*GitHub Repository "hashcloak/NEAR-Vulnerabilities"*

'''--- Million_Small_Deposits/Cargo.toml ---
[package]
name = "million_small_deposits"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- Million_Small_Deposits/README.md ---
# Million Small Deposits Attack

## **Status:** Complete

## Vulnerability
On NEAR, your contract pays for the storage it uses. This means that the more data you store, the more balance you need to cover for storage. If you don't handle these costs correctly (e.g. asking the user to cover their storage usage), then a million little deposits can drain your contract of its funds. Currently it costs ~1 â“ƒ to store 100kb.

## Reference: [Million Small Deposits](https://docs.near.org/develop/contracts/security/storage)
'''
'''--- Million_Small_Deposits/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use near_sdk::{env, AccountId, Balance, near_bindgen};
use near_sdk::collections::{Vector};
use near_sdk::json_types::{U128};

const POINT_ONE: Balance = 100_000_000_000_000_000_000_000;

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PostedMessage {
  pub premium: bool, 
  pub sender: AccountId,
  pub text: String
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct GuestBook {
  messages: Vector<PostedMessage>,
}

impl Default for GuestBook{
  fn default() -> Self {
    Self{messages: Vector::new(b"m")}
  }
}

#[near_bindgen]
impl GuestBook {

  #[payable]
  pub fn add_message(&mut self, text: String) {
    // If the user attaches more than 0.01N the message is premium
    let premium = env::attached_deposit() >= POINT_ONE;
    let sender = env::predecessor_account_id();

    let message = PostedMessage{premium, sender, text};
    self.messages.push(&message);
  }

  pub fn get_messages(&self, from_index:Option<U128>, limit:Option<u64>) -> Vec<PostedMessage>{
    let from = u128::from(from_index.unwrap_or(U128(0)));

    self.messages.iter()
    .skip(from as usize)
    .take(limit.unwrap_or(10) as usize)
    .collect()
  }
}
'''
'''--- README.md ---
# Getting Started
- Follow this [instructions](https://doc.rust-lang.org/book/ch01-01-installation.html#installation) to install rust. 
- Add the WASM (WebAssembly) target to our toolchain
```shell
rustup target add wasm32-unknown-unknown
```
- Move to the specific directory of specific vulnerability and Compile the contract:
```bash
cargo build --target wasm32-unknown-unknown --release
```
- Follow below to steps to deploy the contract on chain:
    - First Login your Account
    ```bash
    near login
    ```
    - Giving Our Contract a Name
    ```bash
    near create-account CONTRACT_NAME.ACCOUNT_ID --masterAccount ACCOUNT_ID
    ```
    - Deploy the contract
    ```Shell
    near deploy --wasmFile target/wasm32-unknown-unknown/release/<filename>.wasm --accountId CONTRACT_ID --initFunction init_function_name --initArgs '{"key": "value", "key": value}'
    ```
- Interacting with the contract
    - Calling a function
    ```bash
    near call CONTRACT_ID function_name_to_call '{"key": "value", "key": value}' --accountId ACCOUNT_ID
    ```
**Now you can play with the function to reproduce the issues.**

# List of vulnerabilities

### [Re-Entrancy](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/reentrancy)
**Status:** Incomplete

### [Overflow](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/overflow)
**Status:** Complete

### [signer_account_id - phishing](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/phishing)
**Status:** Complete

### [Million Small Deposits](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/Million_Small_Deposits)
**Status:** Complete

### [Error Prone Patterns](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/error_prone_pattern)
**Status:** Incomplete
- **[Bug 1](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/error_prone_pattern/Bug_1)** 
- **[Bug 2](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/error_prone_pattern/Bug_2)** 

### [Unchecked Return Value](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/UnsafeCall)
**Status:** Complete
'''
'''--- UnsafeCall/Cargo.toml ---
[package]
name = "unsafe_external_call"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- UnsafeCall/README.md ---
# Unchecked Return Value

## **Status:** Complete

## Vulnerability:
The return value of external function call is not checked. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.

'''
'''--- UnsafeCall/src/lib.rs ---
use near_sdk::{near_bindgen, AccountId, env, ext_contract, PromiseOrValue};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    pub fn query_greeting(receiver_id: AccountId, amount: U128, msg: String) {
        let sender_id = env::predecessor_account_id();
        ext_ft_receiver::ext(receiver_id.clone())
            .with_static_gas(env::prepaid_gas())
            .ft_on_transfer(sender_id.clone(), amount, msg);
    }
}
'''
'''--- error_prone_pattern/Bug_1/Cargo.toml ---
[package]
name = "replace_any_collections_without_clearing_state"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- error_prone_pattern/Bug_1/src/lib.rs ---
use near_sdk::collections::UnorderedMap;
use near_sdk::{near_bindgen, PanicOnDefault};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    m: UnorderedMap<u8, String>,
}

// Bug 1: Should not replace any collections without clearing state, this will reset any
// metadata, such as the number of elements, leading to bugs. If you replace the collection
// with something with a different prefix, it will be functional, but you will lose any
// previous data and the old values will not be removed from storage.
        

#[near_bindgen]
impl Contract {

    #[init]
    pub fn new() -> Self {
        Self { m: UnorderedMap::<u8, String>::new(b"m")}
    }

    pub fn ep_clear_state(&mut self) -> bool {
        // let mut m = UnorderedMap::<u8, String>::new(b"m");
        self.m.insert(&1, &"test".to_string());
        assert_eq!(self.m.len(), 1, "we are testing collections with {} and {}", self.m.len(), 1);
        assert_eq!(self.m.get(&1), Some("test".to_string()), "we are testing collections with {:#?} and {:#?}", self.m.get(&1), Some("test".to_string()));

        return self.m.get(&1) == Some("test".to_string());
    }

    // pub fn ep_re_initialize(&mut self) {
    //     self.m = UnorderedMap::new(b"m");
    // }

    pub fn ep_check_state(&mut self) -> (bool, bool) {
        self.m = UnorderedMap::new(b"m");
        assert!(self.m.is_empty(), "is_empty value: {}", self.m.is_empty());
        assert_eq!(self.m.get(&1), Some("test".to_string()), "we are testing collections with {:#?} and {:#?}", self.m.get(&1), Some("test".to_string()));
        return (self.m.is_empty(), self.m.get(&1) == Some("test".to_string()));
    }
}

'''
'''--- error_prone_pattern/Bug_2/Cargo.toml ---
[package]
name = "use_the_same_prefix_as_another_collections"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- error_prone_pattern/Bug_2/src/lib.rs ---
use near_sdk::collections::UnorderedMap;
use near_sdk::{near_bindgen, PanicOnDefault};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    m: UnorderedMap<u8, String>,
    m2: UnorderedMap<u8, String>,
}

// Bug 2: Should not use the same prefix as another collection
// or there will be unexpected side effects.

#[near_bindgen]
impl Contract {

    #[init]
    pub fn new() -> Self {
        Self { m: UnorderedMap::<u8, String>::new(b"m"), m2: UnorderedMap::<u8, String>::new(b"m")}
    }

    pub fn ep_add_state(&mut self) -> bool {
        self.m.insert(&1, &"test".to_string());
        assert_eq!(self.m.len(), 1, "we are testing collections with {} and {}", self.m.len(), 1);
        assert_eq!(self.m.get(&1), Some("test".to_string()), "we are testing collections with {:#?} and {:#?}", self.m.get(&1), Some("test".to_string()));

        return self.m.get(&1) == Some("test".to_string());
    }

    pub fn ep_check_state(&mut self) -> (bool, bool) {
        // self.m = UnorderedMap::new(b"m");
        assert!(self.m2.is_empty(), "is_empty value: {}", self.m2.is_empty());
        assert_eq!(self.m2.get(&1), Some("test".to_string()), "we are testing collections with {:#?} and {:#?}", self.m2.get(&1), Some("test".to_string()));
        return (self.m2.is_empty(), self.m2.get(&1) == Some("test".to_string()));
    }
}

'''
'''--- error_prone_pattern/README.md ---
# Error Prone Patterns

## **Status:** Incomplete

## [Bug 1](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/error_prone_pattern/Bug_1):

### Vulnerability:
We should not replace any collections without clearing state, this will reset any metadata, such as the number of elements, leading to bugs. If you replace the collection with something with a different prefix, it will be functional, but you will lose any previous data and the old values will not be removed from storage.

## [Bug 2](https://github.com/hashcloak/NEAR-Vulnerabilities/tree/main/error_prone_pattern/Bug_2):

### Vulnerability:
We should not use the same prefix as another collection or there will be unexpected side effects.

### Blocker:
Whenever using same prefix the contracts state are changed in  a state that's it will not work any more and will show some issues regarding contracts state.
'''
'''--- overflow/Cargo.toml ---
[package]
name = "overflow"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
# overflow-checks = true
'''
'''--- overflow/README.md ---
# Arithmetic Overflow

## **Status:** Complete

## Vulnerability
Integers in Rust overflow / underflow without any errors, If we don't use `overflow-checks = true` in `Cargo.toml`.
'''
'''--- overflow/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    counter: u8,
}

#[near_bindgen]
impl Contract {
    pub fn view_counter(&self) -> u8 {
        self.counter
    }

    pub fn update_counter(&mut self, number: u8) {
        self.counter += number;
    }

    pub fn update_counter_by_1(&mut self) {
        self.counter += 1;
    }
}
'''
'''--- phishing/Cargo.toml ---
[package]
name = "phishing"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- phishing/README.md ---
# signer_account_id - phishing

## **Status:** Complete

## What's the difference between predecessor_account_id and signer_account_id ?
If contract A calls B, and B calls C, in C predecessor_account_id is B and signer_account_id is A.

## Vulnerability
A malicious contract can deceive the owner of a contract into calling a function that only the owner should be able to call.
'''
'''--- phishing/attack/Cargo.toml ---
[package]
name = "phishing_attack"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- phishing/attack/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, ext_contract, AccountId, Balance};

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {}

// phishing interface, for cross-contract calls
#[ext_contract(phishing)]
trait PhishingExt {
  fn transfer(&self, account_id: AccountId, balance: Balance);
}

#[near_bindgen]
impl Contract {
    pub fn callback_transfer(&self, receiver_id: AccountId, caller_id: AccountId, balance: Balance) {
        phishing::ext(receiver_id.clone()).transfer(caller_id, balance);
    }
}

'''
'''--- phishing/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, AccountId, env, PanicOnDefault, Balance, Promise, require};

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    owner: AccountId,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_address: AccountId) -> Self {
        assert!(!env::state_exists(), "Already Initialized");
        Self {owner: owner_address}
    }

    pub fn transfer(&self, account_id: AccountId, balance: Balance) {
        require!(env::signer_account_id() == self.owner, "Not owner");
        Promise::new(account_id).transfer(balance);
    }
}

'''
'''--- reentrancy/Cargo.toml ---
[package]
name = "reentrancy"
version = "0.1.0"
authors = ["Soumen | HashCloak inc"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- reentrancy/README.md ---
# Re-Entrancy

## **Status:** Incomplete

## Vulnerability:
Between a cross-contract call and its callback any method of your contract can be executed. Not taking this into account anyone can result in exploits.

## Reference: [re-entrancy](https://docs.near.org/develop/contracts/security/callbacks)

### Blocker:
Unable to call withdraw function in between deposit and it's callback function's call to reproduce the re-entrancy bug. Need to figure out a way if the code's logic have some mistake or there is any other requirement to call the withdraw function on time.

'''
'''--- reentrancy/src/external.rs ---
use near_sdk::{ext_contract};

// Validator interface, for cross-contract calls
#[ext_contract(re_entrancy)]
trait ReEntrancy {
  fn reentrancy(&mut self);
}
'''
'''--- reentrancy/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{near_bindgen, env, AccountId, Balance, PanicOnDefault, PromiseError, log, Gas, require, Promise};

pub mod external;
pub use crate::external::*;

const GAS_FOR_RESOLVE_CALLBACK: Gas = Gas(5_000_000_000_000);
const GAS_FOR_EXTERNAL_CALL: Gas = Gas(15_000_000_000_000 + GAS_FOR_RESOLVE_CALLBACK.0);

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub accounts: LookupMap<AccountId, Balance>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already Initialized");
        Self {accounts:LookupMap::new(b"a".to_vec())}
    }

    #[payable]
    pub fn deposit(&mut self, receiver_id: AccountId) -> Promise{
        require!(env::prepaid_gas() > GAS_FOR_EXTERNAL_CALL, "More gas is required");
        let user = env::predecessor_account_id();
        let balance = env::attached_deposit();
        let new_balance = self.get_balance(&user) + balance;
        self.set_account(&user, &new_balance);

        let promise = re_entrancy::ext(receiver_id)
            .with_attached_deposit(balance).with_static_gas(env::prepaid_gas() - GAS_FOR_EXTERNAL_CALL)
            .reentrancy();
            
        return promise.then(
                Self::ext(env::current_account_id())
                .with_static_gas(GAS_FOR_RESOLVE_CALLBACK)
                .deposit_callback(user, balance),
            );
    }

    #[private]
    pub fn deposit_callback(&mut self, #[callback_result]call_result: Result<String, PromiseError>, user: AccountId, balance: Balance){
        if call_result.is_err() {
            log!("There was an error contacting Callback");
            Promise::new(user.clone()).transfer(balance);
            let new_balance = self.get_balance(&user) - balance;
            self.set_account(&user, &new_balance);
        } else {
            log!("The Deposit was Successful");
        }
    }

    pub fn balance_of(&self, account_id: AccountId) -> U128 {
        let balance = self.get_balance(&account_id);
        balance.into()
    }

    pub fn withdraw(&mut self) {
        let caller_id = env::predecessor_account_id();
        let amount = self.get_balance(&caller_id);

        Promise::new(caller_id.clone()).transfer(amount);

        self.set_account(&caller_id, &0);
    }
}

impl Contract {
    fn get_balance(&self, user: &AccountId) -> u128 {
        self.accounts.get(user).unwrap_or_else(|| 0)
    }

    fn set_account(&mut self, owner_id: &AccountId, balance: &Balance) {
        self.accounts.insert(&owner_id, &balance);
}
}
'''