*GitHub Repository "here-wallet/near-zmq-indexer"*

'''--- Cargo.toml ---
[package]
name = "near-zmq"
version = "0.1.0"
authors = ["Volno Petr <petr@herewallet.app>"]
edition = "2021"
rust-version = "1.71.0"

[dependencies]
actix = "0.13.0"
anyhow = "1.0.51"
aws-config = "0.6.0"
aws-endpoint = "0.6.0"
aws-sdk-s3 = "0.6.0"
aws-smithy-http = "0.36.0"
clap = { version = "3.1.6", features = ["color", "derive", "env"] }
futures = "0.3.5"
http = "0.2"
humantime = "2.1.0"
itertools = "0.10.0"
openssl-probe = "0.1.5"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
tokio = { version = "1.1", features = ["sync", "time"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.34"
tracing-subscriber = "0.2.4"
zmq = "0.9.2"
async_zmq = "0.2.0"

near-indexer = { git = "https://github.com/near/nearcore", rev = "f97e1ab46de694504ce3baeea7e0f724f1658b5f" }
near-indexer-primitives = { git = "https://github.com/near/nearcore", rev = "f97e1ab46de694504ce3baeea7e0f724f1658b5f" }
near-client = { git = "https://github.com/near/nearcore", rev = "f97e1ab46de694504ce3baeea7e0f724f1658b5f" }
near-o11y = { git = "https://github.com/near/nearcore", rev = "f97e1ab46de694504ce3baeea7e0f724f1658b5f" }
'''
'''--- Cross.toml ---
[target.x86_64-unknown-linux-gnu]
# Run the following command to get the build environment:
# ```
# docker build --tag cross:x86_64-unknown-linux-gnu ./cross/x86_64-unknown-linux-gnu/
# ```
image = "cross:x86_64-unknown-linux-gnu"

'''
'''--- README.md ---
NEAR Indexer ZMQ
==================================

Implementation of a NEAR Blockchein RPC node to publish all blocks by ZMQ. 

Technical requirements for running

- 8+ Gb RAM
- 4+ CPUS
- 500+ Gb SSD

## Build indexer

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

sudo apt-get update
sudo apt-get upgrade

sudo apt-get install cargo
source $HOME/.cargo/env

sudo apt-get install clang libzmq3-dev libssl-dev pkg-config libpq-dev build-essential awscli git -y

# Init genesis
https://github.com/here-wallet/near-indexer

```

## Download data for RPC node

```bash
mkdir ~/.near/mainnet/data
cd ~/.near/mainnet/data

aws s3 --no-sign-request cp s3://near-protocol-public/backups/mainnet/rpc/latest .
LATEST=$(cat latest)
aws s3 --no-sign-request cp --no-sign-request --recursive s3://near-protocol-public/backups/mainnet/rpc/$LATEST . 

```

## Run

- `-z` - zmq port
- `--home` - path to folder with config and near blockchein data
- `--block-height` - "0" if u want send to zmq all transactions from 0 block
```bash

cargo run --release -- --home /near/mainnet init --chain-id mainnet --download-config	--download-genesis

cargo run --release -- --home ~/.near/mainnet/ run sync-from-latest

```

## Run with docker

Init genesis

```
docker build -t near-zmq-indexer .
NEAR_HOME=~/.near/mainnet

docker run --rm  --name near-init -v $NEAR_HOME:/near/mainnet/   near-zmq-indexer cargo run --release -- --home /near/mainnet init --chain-id mainnet --download-config	--download-genesis	
```

Run indexer

```

docker run  --name near-mainnet -d --restart unless-stopped -p 3030:3030 -p 9555:9555 -p 24567:24567 -v $NEAR_HOME:/near/mainnet/  near-zmq-indexer cargo run --release -- --home /near/mainnet run  sync-from-latest

```

Commands to run NEAR Indexer

| Command 	| Key/Subcommand               	| Required/Default                                                 	| Responsible for                                                                                                                                                                                                                                                                                                                                                         	|
|---------	|--------------------------	|------------------------------------------------------------------	|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
|         	| `--home`                 	| Default <br>`~/.near`                                            	| Tells the node where too look for necessary files: <br>`config.json`<br>, <br>`genesis.json`<br>, <br>`node_key.json`<br>, and <br>`data`<br> folder                                                                                                                                                                                                                    	|
| `init`  	|                              	|                                                                  	| Tells the node to generate config files in `--home-dir`                                                                                                                                                                                                                                                                                                                 	|
|         	| `--chain-id`                 	| Required<br><br>  * `localnet`<br>  * `testnet`<br>  * `mainnet` 	| Defines the chain to generate config files for                                                                                                                                                                                                                                                                                                                          	|
|         	| `--download-config`          	| Optional                                                         	| If provided tells the node to download `config.json` from the public URL. You can download them manually<br><br> - [testnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/config.json)<br> - [mainnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/config.json)      	|
|         	| `--download-genesis`         	| Optional                                                         	| If provided tells the node to download `genesis.json` from the public URL. You can download them manually<br><br> - [testnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/genesis.json)<br> - [mainnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/genesis.json) 	|
|         	| TODO:<br>Other `neard` keys  	|   

## Event processing on pyhon

`pip install pyzmq==22.3.0`

```python

import zmq

ctx = zmq.Context()
socket = ctx.socket(zmq.SUB)
socket.connect("tcp://0.0.0.0:9555")
socket.subscribe("")  # noqa

while True:
    messages = socket.recv_multipart()  # noqa
    for message in messages:
        dat = json.loads(message.decode("utf8"))
        print(dat)
```
'''
'''--- src/configs.rs ---
use clap::Parser;

/// NEAR ZMQ Indexer
/// Watches for stream of blocks from the chain and puts it in S3 bucket
#[derive(Parser, Clone, Debug)]
#[clap(
    version,
    author,
    about,
    disable_help_subcommand(true),
    propagate_version(true),
    next_line_help(true)
)]
pub(crate) struct Opts {
    /// Sets a custom config dir. Defaults to ~/.near/
    #[clap(short, long)]
    pub home: Option<std::path::PathBuf>,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Parser, Clone, Debug)]
pub(crate) enum SubCommand {
    /// Run NEAR Indexer Example. Start observe the network
    Run(RunArgs),
    /// Initialize necessary configs
    Init(InitConfigArgs),
}

#[derive(Parser, Debug, Clone)]
pub(crate) struct RunArgs {
    #[clap(long)]
    pub stream_while_syncing: bool,
    /// Sets the starting point for indexing
    #[clap(subcommand)]
    pub sync_mode: SyncModeSubCommand,
}

impl RunArgs {
    pub(crate) fn to_indexer_config(
        &self,
        home_dir: std::path::PathBuf,
    ) -> near_indexer::IndexerConfig {
        near_indexer::IndexerConfig {
            home_dir,
            sync_mode: self.sync_mode.clone().into(),
            await_for_node_synced: if self.stream_while_syncing {
                near_indexer::AwaitForNodeSyncedEnum::StreamWhileSyncing
            } else {
                near_indexer::AwaitForNodeSyncedEnum::WaitForFullSync
            },
            validate_genesis: false,
        }
    }
}

#[allow(clippy::enum_variant_names)] // we want commands to be more explicit
#[derive(Parser, Debug, Clone)]
pub(crate) enum SyncModeSubCommand {
    /// continue from the block Indexer was interrupted
    SyncFromInterruption,
    /// start from the newest block after node finishes syncing
    SyncFromLatest,
    /// start from specified block height
    SyncFromBlock(BlockArgs),
}

#[derive(Parser, Debug, Clone)]
pub(crate) struct BlockArgs {
    /// block height for block sync mode
    #[clap(long)]
    pub height: u64,
}

impl From<SyncModeSubCommand> for near_indexer::SyncModeEnum {
    fn from(sync_mode: SyncModeSubCommand) -> Self {
        match sync_mode {
            SyncModeSubCommand::SyncFromInterruption => Self::FromInterruption,
            SyncModeSubCommand::SyncFromLatest => Self::LatestSynced,
            SyncModeSubCommand::SyncFromBlock(args) => Self::BlockHeight(args.height),
        }
    }
}

#[derive(Parser, Clone, Debug)]
pub(crate) struct InitConfigArgs {
    /// chain/network id (localnet, testnet, devnet, betanet)
    #[clap(short, long)]
    pub chain_id: Option<String>,
    /// Account ID for the validator key
    #[clap(long)]
    pub account_id: Option<String>,
    /// Specify private key generated from seed (TESTING ONLY)
    #[clap(long)]
    pub test_seed: Option<String>,
    /// Number of shards to initialize the chain with
    #[clap(short, long, default_value = "1")]
    pub num_shards: u64,
    /// Makes block production fast (TESTING ONLY)
    #[clap(short, long)]
    pub fast: bool,
    /// Genesis file to use when initialize testnet (including downloading)
    #[clap(short, long)]
    pub genesis: Option<String>,
    #[clap(short, long)]
    /// Download the verified NEAR config file automatically.
    #[clap(long)]
    pub download_config: bool,
    #[clap(long)]
    pub download_config_url: Option<String>,
    /// Download the verified NEAR genesis file automatically.
    #[clap(long)]
    pub download_genesis: bool,
    /// Specify a custom download URL for the genesis-file.
    #[clap(long)]
    pub download_genesis_url: Option<String>,
    /// Customize max_gas_burnt_view runtime limit.  If not specified, value
    /// from genesis configuration will be taken.
    #[clap(long)]
    pub max_gas_burnt_view: Option<u64>,
    /// Initialize boots nodes in <node_key>@<ip_addr> format seperated by commas
    /// to bootstrap the network and store them in config.json
    #[clap(long)]
    pub boot_nodes: Option<String>,
}

'''
'''--- src/main.rs ---
use std::sync::Arc;

use clap::Parser;
use configs::{Opts, SubCommand};
use futures::SinkExt;
use tokio::sync::Mutex;
use tracing_subscriber::EnvFilter;

mod configs;
mod utils;

const INDEXER: &str = "near_zmq";

#[derive(Debug, Clone)]
struct Stats {
    pub block_heights_processing: std::collections::BTreeSet<u64>,
    pub blocks_processed_count: u64,
    pub last_processed_block_height: u64,
}

impl Stats {
    pub fn new() -> Self {
        Self {
            block_heights_processing: std::collections::BTreeSet::new(),
            blocks_processed_count: 0,
            last_processed_block_height: 0,
        }
    }
}

fn main() {
    // We use it to automatically search the for root certificates to perform HTTPS calls
    // (sending telemetry and downloading genesis)
    openssl_probe::init_ssl_cert_env_vars();
    init_tracing();

    let opts: Opts = Opts::parse();

    let home_dir = opts.home.unwrap_or_else(near_indexer::get_default_home);

    match opts.subcmd {
        SubCommand::Run(args) => {
            tracing::info!(
                target: INDEXER,
                "NEAR Indexer v{} starting...",
                env!("CARGO_PKG_VERSION")
            );

            let system = actix::System::new();
            system.block_on(async move {
                let indexer_config = args.clone().to_indexer_config(home_dir);
                let indexer = near_indexer::Indexer::new(indexer_config)
                    .expect("Failed to initialize the Indexer");

                let stream = indexer.streamer();
                let view_client = indexer.client_actors().0;
                let stats: Arc<Mutex<Stats>> = Arc::new(Mutex::new(Stats::new()));

                actix::spawn(logger(Arc::clone(&stats), view_client));
                listen_blocks(stream, Arc::clone(&stats)).await;

                actix::System::current().stop();
            });
            system.run().unwrap();
        }
        SubCommand::Init(config) => near_indexer::init_configs(
            &home_dir,
            None,
            None,
            None,
            config.num_shards,
            config.fast,
            None,
            false,
            None,
            None,
            false,
            config.download_config_url.as_ref().map(AsRef::as_ref),
            None,
            None,
        )
        .expect("Failed to initialize the node config files"),
    }
}

async fn logger(stats: Arc<Mutex<Stats>>, view_client: actix::Addr<near_client::ViewClientActor>) {
    let interval_secs = 10;
    let mut prev_blocks_processed_count: u64 = 0;

    loop {
        tokio::time::sleep(std::time::Duration::from_secs(interval_secs)).await;
        let stats_lock = stats.lock().await;
        let stats_copy = stats_lock.clone();
        drop(stats_lock);

        let block_processing_speed: f64 = ((stats_copy.blocks_processed_count
            - prev_blocks_processed_count) as f64)
            / (interval_secs as f64);

        let time_to_catch_the_tip_duration = if block_processing_speed > 0.0 {
            if let Ok(block_height) = utils::fetch_latest_block(&view_client).await {
                Some(std::time::Duration::from_millis(
                    (((block_height - stats_copy.last_processed_block_height) as f64
                        / block_processing_speed)
                        * 1000f64) as u64,
                ))
            } else {
                None
            }
        } else {
            None
        };

        tracing::info!(
            target: INDEXER,
            "# {} | Blocks processing: {}| Blocks done: {}. Bps {:.2} b/s {}",
            stats_copy.last_processed_block_height,
            stats_copy.block_heights_processing.len(),
            stats_copy.blocks_processed_count,
            block_processing_speed,
            if let Some(duration) = time_to_catch_the_tip_duration {
                format!(
                    " | {} to catch up the tip",
                    humantime::format_duration(duration)
                )
            } else {
                "".to_string()
            }
        );
        prev_blocks_processed_count = stats_copy.blocks_processed_count;
    }
}

async fn listen_blocks(
    mut stream: tokio::sync::mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
    stats: Arc<Mutex<Stats>>,
) {
    let url = "tcp://0.0.0.0:9555".to_owned();

    let mut zmq = async_zmq::xpublish(url.as_str()).unwrap().bind().unwrap();

    while let Some(streamer_message) = stream.recv().await {
        for shard in streamer_message.shards {
            let dat = serde_json::to_string(&shard).unwrap();
            zmq.send(vec![dat.as_str()]).await.unwrap();
        }
        let block_height = streamer_message.block.header.height;
        let mut stats_lock = stats.lock().await;
        stats_lock.block_heights_processing.insert(block_height);
        drop(stats_lock);
        let mut stats_lock = stats.lock().await;
        stats_lock.block_heights_processing.remove(&block_height);
        stats_lock.blocks_processed_count += 1;
        stats_lock.last_processed_block_height = block_height;
        drop(stats_lock);
    }
}

fn init_tracing() {
    let mut env_filter = EnvFilter::new(
        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer=info,near_zmq=info,aggregated=info",
    );

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    eprintln!("Ignoring directive `{}`: {}", s, err);
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}

'''
'''--- src/utils.rs ---
use near_indexer_primitives::types;
use near_o11y::WithSpanContextExt;

/// Fetches the status to retrieve `latest_block_height` to determine if we need to fetch
/// entire block or we already fetched this block.
pub(crate) async fn fetch_latest_block(
    client: &actix::Addr<near_client::ViewClientActor>,
) -> anyhow::Result<u64> {
    let block = client
        .send(
            near_client::GetBlock(types::BlockReference::Finality(types::Finality::Final))
                .with_span_context(),
        )
        .await??;
    Ok(block.header.height)
}
'''