*GitHub Repository "gandhisamay/Teen-Patti-On-The-Chain"*

'''--- Cargo.toml ---
[package]
name = "teen_patti_on_the_chain"
version = "0.1.0"
authors = ["NEAR Friend <gandhisamay200@gmail.com>"]
edition = "2021"

[lib]
name = "library"
path = "./teenpatti/src/lib.rs"
crate-type = ["cdylib", "rlib"]

[[bin]]
name = "init"
path = "./teenpatti/src/init.rs"

[dependencies]
near-sdk = "4.0.0"
text_io = "0.1.10"
rand = "0.8.5"
getrandom = { version = "0.2.6", features = ["js"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
# Decentralized Teen Patti (NEAR Protocol)
Teenpatti is an Indian origin card game. The objective of this game is to make the best 3 card hand as per the hand ranking and to maximize the pot (prize pool) before the showdown for you to win. A standard 52-card pack (without the jokers) is used in this game.

## Problem Statement
Online card games like Rummy,TeenPatti are huge in India,attracting numerous masses and involving real money. But there are many problems in this sector namely :- 
### Accessibility and confidentiality

Businesses in the gaming industry offer crypto casino customers who use cryptocurrencies as an alternative to fiat money or a solid solution as their principal payment method. Players actively wagering on the platform can do so without providing identifying documentation. Additionally, there arenâ€™t many restrictions on new participants entering the market with cryptocurrency. As a result, new players in the lottery system are exempted from the regulations that apply to traditional lotteries.

### Traceability

By utilizing the transparency feature built into blockchain technology, participants of the DeFi lottery platforms can access open records and examine all the historical information of trades. If any cyber attack occurs, participants can use the transparency function of a DeFi lottery platform to track and analyze it.

### Making Crypto Payments feasible

Participants can use their cryptos to subscribe for the use of the Defi lottery systems. Players on the DeFi lottery platform wonâ€™t have to be confined to their national borders thanks to the crypto payment system, which enables them to participate in events regulated outside their own countries. Since cryptocurrencies make payments and redemptions cheaper, utilizing DeFi lottery sites is significantly less expensive than conventional lottery platforms

## Rules of the game

### Ranking of the card hands from highest to lowest is

1) Trail (three of a kind) : 3 cards of the same rank. AAA is the best hand in the game.
2) Pure Sequence (Straight Flush): Three consecutive cards of the same suit.
3) Sequence (Straight): Three consecutive cards not all in the same suit.
4) Color (Flush): A flush of 3 cards in the same suit, with the highest card winning in the case of a draw.
5) Pair (two of a kind): A pair of 2 cards of the same rank. In case of a draw, the highest-ranking 3rd card will denote the winner.
6) High Card: When neither the dealer nor player has a pair, then the hand with the highest card wins.

For more detailed rules refer [Deltin](https://www.deltin.com/games/indian-flush-teen-patti#:~:text=In%20this%20game%2C%20the%20dealer,best%20hand%20wins%20the%20round.). 

## Installation

To get it up and running up for your machine :

1) Set up the [prerequisites](https://github.com/near/near-sdk-rs#pre-requisites)
2) Create a [NEAR](https://wallet.near.org/) account on the testnet or the mainnet network . 
3) Best practice is to create a sub account for eg. game.teenpatti.testnet and deploy your smart contract to that by using the deploy script.
![tree](https://user-images.githubusercontent.com/75066364/173606222-d22c643f-063a-477a-a2ce-2f8db8c5d750.jpg)
4) Clone the project and cd into the folder. 
 
Everywhere replace,<br> 
    `<accountId>` by your NEAR testnet account <br>
    `<contract-account>` by the NEAR sub-account created where the game is deployed.

## Game Play

### Start game
To start the game, run the following command, after successful compilation of the files it will start by asking for player details and once the details are filled all the details will be pushed on the NEAR blockchain. 
```
cargo run --bin init
```
Now to further play game follow the actions given below.

### Game State
To to find information about 
1) All registered players 
2) Total staked tokens in the game by all players (i.e the pot)
3) Currently folded players 
4) Players currently in the game  

**Run**
```
near view <contract-account> game_state
```

**Output**
```
View call: gaming.teen_patti2.testnet.game_state()
{
  players: [
    {
      account_id: 'samay200.testnet',
      hand: {
        cards: [
          { card_type: 'J', suit: 'Heart', value: 11 },
          { card_type: '9', suit: 'Spade', value: 9 },
          { card_type: 'J', suit: 'Diamond', value: 11 }
        ]
      },
      name: 'Samay',
      betting_amount: 80,
      is_folded: false,
      play_blind: false,
      balance_amount: 420
    },
    {
      account_id: 'harshrathi2511.testnet',
      hand: {
        cards: [
          { card_type: '8', suit: 'Spade', value: 8 },
          { card_type: 'Q', suit: 'Diamond', value: 12 },
          { card_type: '10', suit: 'Heart', value: 10 }
        ]
      },
      name: 'Harsh',
      betting_amount: 0,
      is_folded: true,
      play_blind: false,
      balance_amount: 500
    },
    {
      account_id: 'teen_patti2.testnet',
      hand: {
        cards: [
          { card_type: '7', suit: 'Club', value: 7 },
          { card_type: '9', suit: 'Club', value: 9 },
          { card_type: '3', suit: 'Club', value: 3 }
        ]
      },
      name: 'TeenPatti',
      betting_amount: 60,
      is_folded: false,
      play_blind: false,
      balance_amount: 580
    }
  ],
  folded_players: [
    {
      account_id: 'harshrathi2511.testnet',
      hand: {
        cards: [
          { card_type: '8', suit: 'Spade', value: 8 },
          { card_type: 'Q', suit: 'Diamond', value: 12 },
          { card_type: '10', suit: 'Heart', value: 10 }
        ]
      },
      name: 'Harsh',
      betting_amount: 0,
      is_folded: true,
      play_blind: false,
      balance_amount: 500
    }
  ],
  tokens_staked: 140,
  unfolded_players: [
    {
      account_id: 'samay200.testnet',
      hand: {
        cards: [
          { card_type: 'J', suit: 'Heart', value: 11 },
          { card_type: '9', suit: 'Spade', value: 9 },
          { card_type: 'J', suit: 'Diamond', value: 11 }
        ]
      },
      name: 'Samay',
      betting_amount: 80,
      is_folded: false,
      play_blind: false,
      balance_amount: 420
    },
    {
      account_id: 'teen_patti2.testnet',
      hand: {
        cards: [
          { card_type: '7', suit: 'Club', value: 7 },
          { card_type: '9', suit: 'Club', value: 9 },
          { card_type: '3', suit: 'Club', value: 3 }
        ]
      },
      name: 'TeenPatti',
      betting_amount: 60,
      is_folded: false,
      play_blind: false,
      balance_amount: 580
    }
  ]
} 
```

### Play Actions

There are 3 actions that a TeenPatti registered player can be done using the NEAR CLI, namely:
1) **RAISE** - specify the raise amount,which should not be greater than the number of chips you have(i.e balance amount) in an argument provided to action to raise in the game 

```
near call <contract-account> play 
    '{
       "action": "Raise{"amount": 45.0}", 
       "account_id": <accountId>
     }' 
--accountId <accountId>
```
 
2) **FOLD** - when your cards are not good enough ,its better of to fold them using the following command . 

 ```
 near call <contract-account> play 
     '{
        "action": "Fold", 
        "account_id": <accountId>
      }' 
--accountId <accountId>
 ```
 
3) **SHOW** - can only be called when 2 players are left in the game who have not yet folded their cards . After show the winner script runs and the winner is           announced . 

 ```
 near call <contract-account> play 
     '{
        "action": "Show", 
        "account_id": <accountId>
      }' 
--accountId <accountId>
 ```
 
 ### Game Winner
 Whenever the winner of game is found it is declared in the logs when either one of the 2 actions are performed :- 
 1. Only one player is left with unfolded cards and rest of the players jave folded theirs 
 2. When only 2 players remain with unfolded cards and a player calls "show" , then the winner is decided upon the hierarchy of their cards 

All the tokens staked in the game is then transferred to the winner instantly !(under development)
 
 ## Get more info

* [Rust Smart Contract Quick Start](https://docs.near.org/docs/develop/contracts/rust/intro)
* [Rust SDK Book](https://www.near-sdk.io/)
* [NEAR SDK Docs](https://www.near-sdk.io/)

## Contributors
Made with ðŸ’– by Web3 enthusiasts, [Samay Gandhi](https://www.github.com/gandhisamay) and [Harsh Rathi](https://github.com/harshRathi2511)

'''
'''--- build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e
chmod +x scripts/build.sh 

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- scripts/delete.sh ---
#!/bin/bash

echo ""
echo "deleting subaccount poker.teenpatti.testnet and sending the rest of NEAR to master account"

near delete game.teenpatti.testnet teenpatti.testnet
# deleting account also creates a tx for the masterAccount 

echo ""
echo "sub-account deleted"
'''
'''--- scripts/deploy.sh ---
#!/bin/bash
set -e
chmod +x scripts/deploy.sh 

# echo "enter masterAccount..."
# read masterAccount
# echo "master account is $masterAccount"

echo ""
echo "building wasm file to be deployed........."
echo ""
# giving permissions to the build script to execute  
./scripts/build.sh

echo ""
echo "creating a new testnet subaccount of teenpatti.testnet"
echo ""
# should ideally create a random testnet account and then deploy to it  
near create-account game.teenpatti.testnet --masterAccount teenpatti.testnet
echo ""

echo "viewing the state of the subaccount game.teenpatti.testnet"
echo ""

echo "if the code hash has all ones :- NO CONTRACT DEPLOYED YET "
echo ""

near state game.teenpatti.testnet
echo ""

echo "deploying the contract (wasm file) to the subaccount ...using batch actions to #[init] "
echo ""

# using batch actions to instantiate the function 
near deploy game.teenpatti.testnet --wasmFile res/library.wasm \
# #  --initFunction 'new'  \
# #  --initArgs '{"owner_id": "game.teenpatti.testnet"}'
 
echo ""
echo ""

echo " checking if the code hashes are all ones.........."
echo ""
echo ""

near state game.teenpatti.testnet 
echo ""
echo ""
echo ""

echo "contract deployed successfully    "
echo ""
'''
'''--- scripts/method_calls.sh ---
#!/bin/bash 

# echo ""
# near call game.teenpatti.testnet start_game --accountId harshrathi2511.testnet

echo ""
echo "registering players "
near call game.teenpatti.testnet add_players '{
    "input_players" : [
        {
            "account_id": "harshrathi2511.testnet",
            "name": "Harsh Rathi"
        },
        {
            "account_id": "samay200.testnet",
            "name": "Samay Gandhi"
        },
        {
            "account_id": "sonali.testnet",
            "name": "Sonali"
        },
    ] 
}' --accountId teenpatti.testnet

echo ""
echo "view registered players .... "

near view game.teenpatti.testnet get_players_data

echo ""
near view game.teenpatti.testnet game_state
echo ""

echo ""
echo "getting a player by its account id working "
near call game.teenpatti.testnet get_player  '{
    "account_id" : "harshrathi2511.testnet"
}' --accountId teenpatti.testnet

echo ""
echo ""
echo " getting a player action"
near call game.teenpatti.testnet play '{"action": "Raise(45)" , "account_id": ""}' --accountId harshrathi2511.testnet

# better to parse the arguments through a json formatter for not getting fuckin syntax errors

echo ""
echo "viewing the current state of the game"
near view game.teenpatti.testnet game_state
echo ""

'''
'''--- scripts/redeploy.sh ---
#!/bin/bash
set -e

./scripts/delete.sh 

./scripts/deploy.sh 

'''
'''--- scripts/test.sh ---
#!/bin/bash
set -e

chmod +x scripts/test.sh 

cargo test -- --nocapture

'''
'''--- start.sh ---
cd client 
npm start

'''
'''--- teenpatti/src/add_player_input.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::card::Card;

//Helper structs
#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AddPlayerInput {
    pub account_id: String,
    pub name: String,
    pub cards: Vec<Card>,
}
'''
'''--- teenpatti/src/card.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Card {
    pub card_type: String,
    pub suit: String,
    pub value: u16,
}
'''
'''--- teenpatti/src/constants.rs ---
// 5 â“ƒ in yoctoNEAR
pub const INITIAL_BET: u128 = 5_000_000_000_000_000_000_000_000;

pub const INITIAL_COLLATERAL: u128 = 100_000_000_000_000_000_000_000_000;

pub const SUITS: [&str; 4] = ["Spade", "Heart", "Club", "Diamond"];

pub const CARD_TYPES: [&str; 13] = [
    "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A",
];

pub const VALUES: [u16; 13] = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
'''
'''--- teenpatti/src/contract.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId};
use std::convert::From;
use std::convert::Into;
use crate::hand::Hand;
use crate::player_actions::PlayerActions;
use crate::player::Player;
use crate::add_player_input::AddPlayerInput;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct Game {
    pub players: Vec<Player>,
    pub folded_players: Vec<Player>,
    pub tokens_staked: f64,
    pub unfolded_players: Vec<Player>,
    pub current_turn_player: Player,
}

#[near_bindgen]
impl Game {
    pub fn game_state(self) -> Game {
        self
    }
    pub fn get_players_data(self) -> Vec<Player> {
        self.players
    }

    pub fn get_player(self, account_id: AccountId) -> Player {
        for player in self.players {
            if player.account_id == account_id {
                // println!("{:?}",player);
                return player;
            }
        }

        let player1 = Player {
            account_id: "default.testnet"
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            hand: Hand { cards: Vec::new() },
            name: String::from("dummy"),
            betting_amount: 0.0,
            is_folded: false,
            play_blind: false,
            balance_amount: 100.0,
        };

        player1
    }
    pub fn get_unfolded_players(&self) -> Vec<Player> {
        let mut unfolded_players: Vec<Player> = Vec::new();
        for player in &self.players {
            if player.is_folded == false {
                unfolded_players.push(player.clone())
            }
        }
        unfolded_players
    }

    pub fn get_player_by_account_id(
        &self,
        account_id: AccountId,
        player_list: &Vec<Player>,
    ) -> Player {
        for player in player_list {
            if player.account_id == account_id {
                env::log_str("found the account id");
                return player.clone();
            }
        }
        env::log_str("ERR: get_player_by_account_id: did not find player with account id");
        let player1 = Player {
            account_id: "dummy.testnet"
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            hand: Hand { cards: Vec::new() },
            name: String::from("dummy"),
            betting_amount: 0.0,
            is_folded: false,
            play_blind: false,
            balance_amount: 100.0,
        };
        player1
    }

    pub fn print_unfolded(&self, unfolded_list: &Vec<Player>) {
        for player in unfolded_list {
            println!("{:?}", player);
        }
    }

    pub fn add_players(&mut self, input_players: Vec<AddPlayerInput>) {
        for p in input_players {
            let player = Player::from(p.account_id, p.name, p.cards, 0.0, false, false, 500.0);
            self.players.push(player);

            // set the unfolded list for the game
            self.unfolded_players = self.get_unfolded_players();

            // set the current turn for the player
            self.current_turn_player = self.players[0].clone();
        }
    }

    pub fn play(&mut self, action: PlayerActions, account_id: AccountId) {
        env::log_str(&env::predecessor_account_id().to_string());
        env::log_str(&env::current_account_id().to_string());
        env::log_str(&env::signer_account_id().to_string());

        env::log_str("getting whose turn to play");

        //set the unfolded players
        self.unfolded_players = self.get_unfolded_players();

        env::log_str("getting player making the request");
        let mut player = self.get_player_by_account_id(account_id, &self.players);

        if env::signer_account_id() != player.account_id{
            env::log_str("Cannot play someone else's turn with your account");
            env::panic_str("ERR: Signer account id is not equal to the player account id");
        }

        // see if the player has its turn
        if self.current_turn_player.account_id != player.account_id {
            env::panic_str("ERR: NOT YOUR TURN");
        }

        // check if the current player has folded cards
        if player.is_folded == true {
            //works
            env::panic_str("ERR: you have folded already, can't play again");
        }

        match action {
            PlayerActions::Idle => env::log_str("ERR:PLAYER IDLE "),
            PlayerActions::Fold => {
                env::log_str("Folding");
                if let Some(index) = self.unfolded_players.iter().position(|x| *x == player) {
                    env::log_str("entered here :- folding the player");
                    // self.unfolded_players[index].is_folded = true;
                    self.unfolded_players.remove(index); //this will change the game state of the unfolded players

                    if let Some(index) = self.players.iter().position(|x| *x == player) {
                        env::log_str("making self.players updated");
                        self.players[index].is_folded = true; //this will change the game state of the self.players
                    }

                    //push in the list of folded players
                    self.folded_players.push(player.clone());
                    // update the state in the folded players list too
                    if let Some(index) = self.folded_players.iter().position(|x| *x == player) {
                        self.folded_players[index].is_folded = true; //updated state
                    }

                    if self.unfolded_players.len() == 1 {
                        env::log_str("Winner");
                        env::log_str(&self.unfolded_players.get(0).unwrap().name);
                        //0,1,
                        env::log_str("Congrats you are the winner, because you are the only player left");
                    }

                    //set the current player to the new player
                    if index == self.unfolded_players.len() {
                        //current turn is now of the first player
                        self.current_turn_player = self.unfolded_players[0].clone();
                    } else {
                        //normal case where index player is now the current player as list popped left
                        self.current_turn_player = self.unfolded_players[index].clone();
                    }
                } else {
                    env::panic_str("ERR: could not find the player in the list of unfolded people");
                }
            }
            PlayerActions::Raise(raise_amount) => {
                // let val : f64 = read!();
                env::log_str("Raise is called");
                if let Some(indice) = self.unfolded_players.iter().position(|x| *x == player) {
                    env::log_str("raising amount");
                    player.raise_amount(raise_amount); //just checks the balance of the player

                    // updating in the players list
                    let iters = self.players.iter_mut();

                    for p in iters {
                        if p.account_id == self.unfolded_players.get(indice).unwrap().account_id {
                            env::log_str("Player Index");
                            env::log_str(&raise_amount.to_string());
                            p.balance_amount -= raise_amount;
                            p.betting_amount += raise_amount;
                        }
                    }

                    self.unfolded_players.get_mut(indice).expect("Player not found").balance_amount -= raise_amount;
                    self.unfolded_players.get_mut(indice).expect("Player not found").betting_amount += raise_amount;

                    //self.tokens_staked
                    self.tokens_staked += raise_amount;

                    // set the turn to the next player in the index if it exists
                    if indice < self.unfolded_players.len() - 1 {
                        //eg p1 raises but 3 players are there
                        self.current_turn_player = self.unfolded_players[indice + 1].clone();
                    } else {
                        //when index is equal to the len of the unfolded players
                        // indice = self.unfolded_players.len()-1;
                        // p3 raises when 3 players there
                        self.current_turn_player = self.unfolded_players[0].clone();
                    }
                } else {
                    env::panic_str("ERR: could not find the player in the list of unfolded people");
                }
            }
            PlayerActions::Show => {
                env::log_str("showing action");
                if self.unfolded_players.len() == 2 {
                    let player: Player = self.find_winner();
                    env::log_str("Winner");

                    let iters = self.players.iter_mut();

                    for p in iters {
                        if p.account_id == player.account_id {
                            p.balance_amount += self.tokens_staked;
                        }
                    }

                    let iters2 = self.unfolded_players.iter_mut();

                    for p in iters2 {
                        if p.account_id == player.account_id {
                            p.balance_amount += self.tokens_staked;
                        }
                    }

                    env::log_str(&player.name);
                    let mut winnerMessage = String::new();
                    let name = player.name;
                    let hand_type = player.hand.get_players_hand_type().to_string();

                    winnerMessage = format!("Congratulations the winner is {name}, due to hand type {hand_type}");

                    env::log_str(&winnerMessage);
                    // env::log_str("should run winner script");
                } else {
                    env::panic_str(
                        "ERR:cant use the show action when more than 2 players are remaining",
                    )
                }
            }
        }

        // designate the current turn to other player in the unfolded list
    }

    pub fn find_winner(&mut self) -> Player {
        //first find the players who have not folded
        let player1: Player;
        let player2: Player;

        let mut not_folded_players: Vec<Player> = Vec::new();

        let player_iter = self.players.iter();

        for player in player_iter {

            if !player.is_folded {
                not_folded_players.push(player.clone());
            }
        }

        player1 = not_folded_players[0].clone();
        player2 = not_folded_players[1].clone();

        let val1: i32 = player1.hand.get_players_hand_type().into();
        let val2: i32 = player2.hand.get_players_hand_type().into();

        env::log_str("Into values");
        env::log_str(&val1.to_string());
        env::log_str(&val2.to_string());

        dbg!(val1);
        dbg!(val2);

        if val1 < val2 {
            player1
        } else if val1 == val2 {
            let max_card1 = player1.hand.max_card_val();
            let max_card2 = player2.hand.max_card_val();

            if max_card1 >= max_card2 {
                player1
            } else {
                player2
            }
        } else {
            player2
        }
    }
}

'''
'''--- teenpatti/src/deck.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde::{Deserialize, Serialize};
use crate::card::Card;
use crate::constants::*;

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Deck {
    pub cards: Vec<Card>,
}

impl Deck {
    pub fn new() -> Self {
        // generate the 52 cards here
        let mut hash_map: LookupMap<String, u16> = LookupMap::new(b"p");

        // generate the lookup map
        for (index, card) in CARD_TYPES.into_iter().enumerate() {
            hash_map.insert(&card.to_string(), &VALUES[index]);
        }

        //generate the deck
        let mut cards: Vec<Card> = Vec::new();
        for suit in SUITS {
            for card_type in CARD_TYPES {
                let card = Card {
                    suit: suit.to_string(),
                    card_type: card_type.to_string(),
                    value: hash_map
                        .get(&card_type.to_string())
                        .expect("index out of bound error"),
                };
                cards.insert(cards.len(), card);
            }
        }
        Deck { cards: cards }
    }
}
'''
'''--- teenpatti/src/hand.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use crate::card::Card;
use crate::hand_type::HandType;

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Hand {
    pub cards: Vec<Card>, //list of cards
}

impl Hand {
    pub fn max_card_val(&self) -> u16 {
        let mut largest = &self.cards[0].value;

        for card in &self.cards {
            if largest > &card.value {
                largest = &card.value;
            }
        }

        *largest
    }

    pub fn check_for_trail(&self) -> bool {
        let cards = &self.cards;

        if cards[0].value == cards[1].value
            && cards[0].value == cards[2].value
            && cards[1].value == cards[2].value
        {
            true
        } else {
            false
        }
    }

    pub fn check_for_pair(&self) -> bool {
        let cards = &self.cards;

        if cards[0].value == cards[1].value && cards[1].value != cards[2].value {
            true
        } else if cards[1].value == cards[2].value && cards[1].value != cards[0].value {
            true
        } else if cards[0].value == cards[2].value && cards[0].value != cards[1].value {
            true
        } else {
            false
        }
    }

    pub fn check_for_flush(&self) -> bool {
        let cards = &self.cards;

        if cards[0].suit == cards[1].suit
            && cards[0].suit == cards[2].suit
            && cards[1].suit == cards[2].suit
        {
            true
        } else {
            false
        }
    }

    pub fn check_for_pure_sequence(&self) -> bool {
        let cards = &self.cards;

        let mut cards_value: Vec<i32> = Vec::new();

        for card in cards {
            cards_value.push(card.value as i32);
        }

        cards_value.sort();

        if (cards_value.get(2).unwrap() - cards_value.get(1).unwrap() == 1)
            && (cards_value.get(1).unwrap() - cards_value.get(0).unwrap() == 1)
        {
            if (cards[0].suit == cards[1].suit) && (cards[1].suit == cards[2].suit) {
                true
            } else {
                false
            }
        } else {
            false
        }
    }

    pub fn check_for_sequence(&self) -> bool {
        let cards = &self.cards;

        let mut cards_value: Vec<i32> = Vec::new();

        for card in cards {
            cards_value.push(card.value as i32);
        }

        cards_value.sort();

        if (cards_value.get(2).unwrap() - cards_value.get(1).unwrap() == 1)
            && (cards_value.get(1).unwrap() - cards_value.get(0).unwrap() == 1)
        {
            true
        } else {
            false
        }
    }

    pub fn get_players_hand_type(&self) -> HandType {
        if self.check_for_trail() {
            HandType::Trail
        } else if self.check_for_pure_sequence() {
            HandType::PureSequence
        } else if self.check_for_sequence() {
            HandType::Sequence
        } else if self.check_for_flush() {
            HandType::Flush
        } else if self.check_for_pair() {
            HandType::Pair
        } else {
            HandType::HighCard
        }
    }
}

'''
'''--- teenpatti/src/hand_type.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::fmt::{Display, Formatter, Result};

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum HandType {
    // init field if required
    Trail, //3 of same rank
    PureSequence,
    Sequence,
    Flush, //3 cards of the same color,
    Pair,  //2 cards of the same rank
    HighCard,
}

impl From<HandType> for i32 {
    fn from(val: HandType) -> Self {
        match val {
            HandType::Trail => 1,
            HandType::PureSequence => 2,
            HandType::Sequence => 3,
            HandType::Flush => 4,
            HandType::Pair => 5,
            HandType::HighCard => 6,
        }
    }
}

impl Display for HandType{
    fn fmt(&self, f: &mut Formatter<'_>) -> Result{
        let message = match self{
            HandType::Trail => "Hand Type Trail".to_string(),
            HandType::PureSequence => "Hand Type Pure Sequence".to_string(),
            HandType::Sequence => "Hand Type Sequence".to_string(),
            HandType::Flush => "Hand Type Flush".to_string(),
            HandType::Pair => "Hand Type Pair".to_string(),
            HandType::HighCard => "Hand Type High Card".to_string(),
        };

        write!(f, "{}", message)
    }
}
'''
'''--- teenpatti/src/init.rs ---
use std::io::{self, Write};
use text_io::read;
use std::fs::File;
use library::card::Card;
use library::deck::Deck;
use rand;
use rand::seq::SliceRandom;
use std::process::Command;

fn main() -> std::io::Result<()>{
    let mut file = File::create("add_players.sh")?;
    file.write_all("near call gaming.teen_patti2.testnet add_players '{\n \"input_players\":  [\n".as_bytes()).unwrap();
    print!("Welcome to Teen Patti \n");
    io::stdout().flush().unwrap();

    print!("Enter your no. of players: ");
    io::stdout().flush().unwrap();
    let num: i32 = read!();

    println!("Please enter your names!\n");

    for i in 0..num{
        println!("Player {}", i+1);
        println!("Testnet Account Name.");
        let account_id : String = read!();

        println!("Player Name.");
        let name : String = read!();

        let mut message = String::new();

        let cards = generate_cards();

        let card1_string = generate_card_string(cards.get(0).expect("Expected a card at index 0"), false);
        let card2_string = generate_card_string(cards.get(1).expect("Expected a card at index 1"), false);
        let card3_string = generate_card_string(cards.get(2).expect("Expected a card at index 2"), true);

        if i+1 != num {
            message = format!("    {{\n      \"account_id\": \"{account_id}\",\n      \"name\": \"{name}\",\n      \"cards\": [\n{card1_string}{card2_string}{card3_string}      ]\n    }},\n");
        }
        else{
            message = format!("    {{\n      \"account_id\": \"{account_id}\",\n      \"name\": \"{name}\",\n      \"cards\": [\n{card1_string}{card2_string}{card3_string}      ]\n    }}\n");
        }
        println!();
        file.write_all(message.as_bytes()).unwrap();
    }

    file.write_all("  ]\n}' --accountId teen_patti2.testnet".as_bytes()).unwrap();

    Command::new("bash").arg("add_players.sh").current_dir("/home/samaygandhi/Teen-Patti-On-The-Chain").spawn().unwrap();

    Ok(())

}

pub fn generate_card_string(card: &Card, last_card: bool) -> String{
    let card_type = &card.card_type;
    let suit  = &card.suit;
    let value = card.value;
    if last_card{
        let message = format!("        {{\n          \"card_type\": \"{card_type}\",\n          \"suit\": \"{suit}\",\n          \"value\": {value}    \n        }}\n");
        message
    }
    else{
        let message = format!("        {{\n          \"card_type\": \"{card_type}\",\n          \"suit\": \"{suit}\",\n          \"value\": {value}    \n        }},\n");
        message
    }
}

pub fn generate_cards() -> Vec<Card>{
    let deck = Deck::new();
    let hand: Vec<Card> = deck
    .cards
    .choose_multiple(&mut rand::thread_rng(), 3)
    .cloned()
    .collect();
// Chooses amount elements from the slice at random, without repetition, and in random order.
    hand
}
'''
'''--- teenpatti/src/lib.rs ---
pub use contract::Game;
pub mod deck;
pub mod card;
pub mod hand;
pub mod constants;
pub mod hand_type;
pub mod player_actions;
pub mod suit_type;
pub mod player;
pub mod add_player_input;
pub mod contract;
'''
'''--- teenpatti/src/player.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId};
use crate::hand::Hand;
use crate::card::Card;
use crate::player_actions::PlayerActions;

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Player {
    pub account_id: AccountId,
    pub hand: Hand, //cards of the player and its type
    pub name: String,
    pub betting_amount: f64, //tokens staked till now in the game
    pub is_folded: bool,
    pub play_blind: bool,
    pub balance_amount: f64,
    // pub player_action: PlayerActions,
}

impl Player {
    pub fn from(
        account_id: String,
        name: String,
        cards: Vec<Card>,
        betting_amount: f64,
        is_folded: bool,
        play_blind: bool,
        balance_amount: f64,
        // player_action: PlayerActions,
    ) -> Self {
        Self {
            account_id: account_id
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            name,
            hand: Hand { cards },
            betting_amount,
            is_folded,
            play_blind,
            balance_amount,
            // player_action,
        }
    }

    pub fn fold_cards(&mut self) {
        self.is_folded = true;
    }

    // performs basic validation and returns the enum along with the amount, where the main logic is handled
    pub fn raise_amount(&mut self, raise_amount: f64) -> f64 {
        if raise_amount > self.balance_amount {
            env::panic_str("ERR: not enough balance")
        } else {
            // decrease from the balance and increase the betting amount
            self.balance_amount -= raise_amount;

            self.betting_amount += raise_amount;

            raise_amount
        }
    }

    pub fn show_cards(&mut self, players_remaining: usize) -> PlayerActions {
        if players_remaining == 2 {
            PlayerActions::Show
        } else {
            env::panic_str("ERR:cant use the show action when more than 2 players are remaining")
        }
    }
}

impl Default for Player{
    fn default() -> Self{
        Player{
            account_id: "dummy.testnet".parse::<AccountId>().unwrap(),
            balance_amount: 500.0,
            betting_amount: 0.0,
            hand: Hand{
                cards: Vec::new(),
            },
            is_folded: false,
            name: "dummy".to_string(),
            play_blind: false,
             
        }
    }
}
'''
'''--- teenpatti/src/player_actions.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum PlayerActions {
    Idle,
    Fold,
    Raise(f64),
    Show, //only when two players are remaining
}
'''
'''--- teenpatti/src/suit_type.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum SuitType {
    Spade,
    Heart,
    Club,
    Diamond,
}

'''
'''--- teenpatti/src/tests.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId};

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::AccountId;

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    // TESTS HERE
    #[test]
    fn generate_deck() {
        let mut hash_map: LookupMap<String, u16> = LookupMap::new(b"p");

        // generate the lookup map
        for (index, card) in CARD_TYPES.into_iter().enumerate() {
            hash_map.insert(&card.to_string(), &VALUES[index]);
        }

        //generate the deck
        let mut cards: Vec<Card> = Vec::new();
        for suit in SUITS {
            for card_type in CARD_TYPES {
                let card = Card {
                    suit: suit.to_string(),
                    card_type: card_type.to_string(),
                    value: hash_map
                        .get(&card_type.to_string())
                        .expect("index out of bound error"),
                };
                // println!("{:?}", card);
                cards.insert(cards.len(), card);
            }
        }
    }

    pub fn get_unfolded_players(player_list: &Vec<Player>) -> Vec<Player> {
        let mut unfolded_players: Vec<Player> = Vec::new();
        for player in player_list {
            if player.is_folded == false {
                unfolded_players.push(player.clone())
            }
        }
        unfolded_players
    }

    pub fn get_player_by_account_id(account_id: AccountId, player_list: &Vec<Player>) -> Player {
        for player in player_list {
            if player.account_id == account_id {
                return player.clone();
            }
        }

        let player1 = Player {
            account_id: "dummy.testnet"
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            hand: Hand { cards: Vec::new() },
            name: String::from("dummy"),
            betting_amount: 0.0,
            is_folded: false,
            play_blind: false,
            balance_amount: 100.0,
        };
        player1
    }

    pub fn print_unfolded(unfolded_list: &Vec<Player>) {
        for player in unfolded_list {
            println!("{:?}", player);
        }
    }

    #[test]
    pub fn get_player() {
        let mut player_list: Vec<Player> = Vec::new();
        let mut cards: Vec<Card> = Vec::new();

        let card1 = Card {
            card_type: "J".to_owned(),
            suit: "Club".to_owned(),
            value: 11,
        };
        let card2 = Card {
            card_type: "3".to_owned(),
            suit: "Club".to_owned(),
            value: 11,
        };
        let card3 = Card {
            card_type: "4".to_owned(),
            suit: "Club".to_owned(),
            value: 11,
        };

        cards.push(card1);
        cards.push(card2);
        cards.push(card3);

        let player1 = Player {
            account_id: "harshrathi2511.testnet"
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            hand: Hand { cards: cards },
            name: String::from("Harsh Rathi"),
            betting_amount: 0.0,
            is_folded: false,
            play_blind: false,
            balance_amount: 100.0,
        };
        let player2 = Player {
            account_id: "samay200.testnet"
                .parse::<AccountId>()
                .expect("failed to parse account id"),
            hand: Hand { cards: Vec::new() },
            name: String::from("Samay Gandhi"),
            betting_amount: 0.0,
            is_folded: false,
            play_blind: false,
            balance_amount: 100.0,
        };
        player_list.push(player1);
        player_list.push(player2);

        let account_id = "harshrathi2511.testnet"
            .parse::<AccountId>()
            .expect("failed to parse account id");

        // println!("{:?}", player_data);
        let action = PlayerActions::Fold;
        let current_turn_player = &player_list[0];
        let mut unfolded_players = get_unfolded_players(&player_list);
        let mut player = get_player_by_account_id(account_id, &player_list);
        let mut tokens_staked = 0.0;

        if current_turn_player.account_id != player.account_id {
            env::panic_str("ERR: NOT YOUR TURN");
        }

        match action {
            PlayerActions::Idle => env::log_str("ERR:PLAYER IDLE "),
            PlayerActions::Fold => {
                print_unfolded(&unfolded_players);

                println!("FOLDING");
                if let Some(index) = unfolded_players.iter().position(|x| *x == player) {
                    println!("{}", index);
                    println!("entered here");
                    unfolded_players.remove(index);
                    // self.unfolded_players  equivalent
                    print_unfolded(&unfolded_players);
                } else {
                    env::panic_str("ERR: could not find the player in the list of unfolded people");
                }

                // fold the cards of the user
                player.fold_cards();
                // or
                player.is_folded = true;
            }
            PlayerActions::Raise(raise_amount) => {
                player.raise_amount(raise_amount);
                //self.tokens_staked
                tokens_staked += raise_amount;
            }
            PlayerActions::Show => {
                if unfolded_players.len() == 2 {
                } else {
                    env::panic_str(
                        "ERR:cant use the show action when more than 2 players are remaining",
                    )
                }
            }
        }
    }
}
'''
'''--- todo.txt ---
betting 
taking initial money
giving final money to everyone (Wallet)
    
plaeyrs 
p1   p2   p3   p4   indeix =3 , unfolded len = 3 
t

unfolded 

p1  p2   p3   p4    (len-1  = 3 , index max = 3 )
t   

raise :- unfolded same , next person

fold :- jo fold hua vahi index would be the current player 
'''