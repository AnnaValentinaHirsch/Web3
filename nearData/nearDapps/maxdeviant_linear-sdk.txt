*GitHub Repository "maxdeviant/linear-sdk"*

'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.0.1] - 2022-10-29

### Added

- Initial release

[unreleased]: https://github.com/maxdeviant/linear-sdk/compare/v0.0.1...HEAD
[0.0.1]: https://github.com/maxdeviant/linear-sdk/compare/57ddb11...v0.0.1

'''
'''--- Cargo.toml ---
[workspace]
members = ["crates/*"]

'''
'''--- README.md ---
# linear_sdk

A Linear SDK for Rust.

## Development

### Update GraphQL Schema

```
graphql-client introspect-schema https://api.linear.app/graphql --output schema.json
```

### Run GraphQL Codegen

```
graphql-client generate --schema-path=schema.json --custom-scalars-module='crate::graphql::custom_scalars' --response-derives='Debug' --output-directory crates/linear_sdk/src/graphql/generated/ crates/linear_sdk/src/graphql/issue.graphql
```

'''
'''--- crates/linear_sdk/Cargo.toml ---
[package]
name = "linear_sdk"
version = "0.0.1"
description = "A Linear SDK for interacting with the Linear GraphQL API."
repository = "https://github.com/maxdeviant/linear-sdk"
documentation = "https://docs.rs/linear_sdk/"
categories = ["api-bindings"]
keywords = ["linear", "api", "sdk"]
authors = ["Marshall Bowers <elliott.codes@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[features]
default = ["rustls-tls"]
native-tls = ["reqwest/default-tls", "openssl"]
rustls-tls = ["reqwest/rustls-tls", "ring", "pem"]

[dependencies]
graphql_client = "0.11"
openssl = { version = "0.10", default-features = false, optional = true }
pem = { version = "1.1", default-features = false, optional = true }
reqwest = { version = "0.11", default-features = false, features = ["json"] }
ring = { version = "0.16", default-features = false, optional = true }
serde = { version = "1.0", features = ["derive"] }
url = "2.3"

'''
'''--- crates/linear_sdk/README.md ---
# linear_sdk

A Linear SDK for Rust.

'''
'''--- crates/linear_sdk/src/client.rs ---
use graphql_client::GraphQLQuery;
use url::{ParseError, Url};

use crate::ApiKey;

/// The Linear client.
pub struct LinearClient {
    base_url: Url,
    key: ApiKey,
    client: reqwest::Client,
}

impl LinearClient {
    /// Returns a new instance of the Linear client using the provided API key.
    pub fn new(key: &ApiKey) -> Self {
        LinearClientBuilder::new(key).build()
    }

    /// Returns a [`LinearClientBuilder`] that may be used to construct a Linear client.
    pub fn builder(key: &ApiKey) -> LinearClientBuilder {
        LinearClientBuilder::new(key)
    }

    pub(crate) fn base_url(&self) -> &Url {
        &self.base_url
    }

    pub(crate) fn key(&self) -> &ApiKey {
        &self.key
    }

    pub(crate) async fn post_graphql<Q: GraphQLQuery>(
        &self,
        variables: Q::Variables,
    ) -> Result<graphql_client::Response<Q::ResponseData>, reqwest::Error> {
        let body = Q::build_query(variables);

        let response = self
            .client
            .post(self.base_url().clone())
            .bearer_auth(self.key())
            .json(&body)
            .send()
            .await?;

        response.json().await
    }
}

/// A builder for a Linear client.
pub struct LinearClientBuilder<'a> {
    base_url: Url,
    key: &'a ApiKey,
}

impl<'a> LinearClientBuilder<'a> {
    /// Returns a new [`LinearClientBuilder`] using the provided API key.
    pub fn new(key: &'a ApiKey) -> Self {
        Self {
            base_url: Url::parse("https://api.linear.app/graphql").unwrap(),
            key,
        }
    }

    /// Sets the base URL of the Linear API that the client should point to.
    pub fn base_url(mut self, base_url: &'a str) -> Result<LinearClientBuilder, ParseError> {
        self.base_url = Url::parse(base_url)?;
        Ok(self)
    }

    /// Sets the API key that the client will use.
    pub fn key(mut self, key: &'a ApiKey) -> Self {
        self.key = key;
        self
    }

    /// Consumes the builder and returns the constructed client.
    pub fn build(self) -> LinearClient {
        let client = reqwest::Client::builder()
            .user_agent(concat!("linear_sdk/", env!("CARGO_PKG_VERSION")))
            .build()
            .unwrap();

        LinearClient {
            base_url: self.base_url,
            key: self.key.to_owned(),
            client,
        }
    }
}

'''
'''--- crates/linear_sdk/src/client_generated.rs ---
impl crate::LinearClient {
    pub async fn sync_bootstrap(
        &self,
        variables: crate::graphql::sync_bootstrap::Variables,
    ) -> Result<crate::graphql::sync_bootstrap::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::SyncBootstrap>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn sync_entity_count(
        &self,
        variables: crate::graphql::sync_entity_count::Variables,
    ) -> Result<crate::graphql::sync_entity_count::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::SyncEntityCount>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn sync_batch(
        &self,
        variables: crate::graphql::sync_batch::Variables,
    ) -> Result<crate::graphql::sync_batch::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::SyncBatch>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn dependent_model_sync(
        &self,
        variables: crate::graphql::dependent_model_sync::Variables,
    ) -> Result<crate::graphql::dependent_model_sync::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::DependentModelSync>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn archived_model_sync(
        &self,
        variables: crate::graphql::archived_model_sync::Variables,
    ) -> Result<crate::graphql::archived_model_sync::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ArchivedModelSync>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn archived_models_sync(
        &self,
        variables: crate::graphql::archived_models_sync::Variables,
    ) -> Result<crate::graphql::archived_models_sync::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ArchivedModelsSync>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn api_keys(
        &self,
        variables: crate::graphql::api_keys::Variables,
    ) -> Result<crate::graphql::api_keys::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ApiKeys>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn application_info(
        &self,
        variables: crate::graphql::application_info::Variables,
    ) -> Result<crate::graphql::application_info::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ApplicationInfo>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn application_info_by_ids(
        &self,
        variables: crate::graphql::application_info_by_ids::Variables,
    ) -> Result<crate::graphql::application_info_by_ids::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ApplicationInfoByIds>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn application_with_authorization(
        &self,
        variables: crate::graphql::application_with_authorization::Variables,
    ) -> Result<crate::graphql::application_with_authorization::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ApplicationWithAuthorization>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn authorized_applications(
        &self,
        variables: crate::graphql::authorized_applications::Variables,
    ) -> Result<crate::graphql::authorized_applications::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AuthorizedApplications>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn workspace_authorized_applications(
        &self,
        variables: crate::graphql::workspace_authorized_applications::Variables,
    ) -> Result<crate::graphql::workspace_authorized_applications::ResponseData, reqwest::Error>
    {
        let response_body = self
            .post_graphql::<crate::graphql::WorkspaceAuthorizedApplications>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn attachments(
        &self,
        variables: crate::graphql::attachments::Variables,
    ) -> Result<crate::graphql::attachments::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Attachments>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn attachment(
        &self,
        variables: crate::graphql::attachment::Variables,
    ) -> Result<crate::graphql::attachment::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Attachment>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn attachments_for_url(
        &self,
        variables: crate::graphql::attachments_for_url::Variables,
    ) -> Result<crate::graphql::attachments_for_url::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AttachmentsForUrl>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn attachment_issue(
        &self,
        variables: crate::graphql::attachment_issue::Variables,
    ) -> Result<crate::graphql::attachment_issue::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AttachmentIssue>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn audit_entry_types(
        &self,
        variables: crate::graphql::audit_entry_types::Variables,
    ) -> Result<crate::graphql::audit_entry_types::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AuditEntryTypes>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn audit_entries(
        &self,
        variables: crate::graphql::audit_entries::Variables,
    ) -> Result<crate::graphql::audit_entries::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AuditEntries>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn available_users(
        &self,
        variables: crate::graphql::available_users::Variables,
    ) -> Result<crate::graphql::available_users::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AvailableUsers>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn sso_url_from_email(
        &self,
        variables: crate::graphql::sso_url_from_email::Variables,
    ) -> Result<crate::graphql::sso_url_from_email::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::SsoUrlFromEmail>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn comments(
        &self,
        variables: crate::graphql::comments::Variables,
    ) -> Result<crate::graphql::comments::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Comments>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn comment(
        &self,
        variables: crate::graphql::comment::Variables,
    ) -> Result<crate::graphql::comment::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Comment>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn custom_views(
        &self,
        variables: crate::graphql::custom_views::Variables,
    ) -> Result<crate::graphql::custom_views::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::CustomViews>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn custom_view(
        &self,
        variables: crate::graphql::custom_view::Variables,
    ) -> Result<crate::graphql::custom_view::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::CustomView>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn cycles(
        &self,
        variables: crate::graphql::cycles::Variables,
    ) -> Result<crate::graphql::cycles::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Cycles>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn cycle(
        &self,
        variables: crate::graphql::cycle::Variables,
    ) -> Result<crate::graphql::cycle::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Cycle>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn documents(
        &self,
        variables: crate::graphql::documents::Variables,
    ) -> Result<crate::graphql::documents::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Documents>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn document(
        &self,
        variables: crate::graphql::document::Variables,
    ) -> Result<crate::graphql::document::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Document>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn emojis(
        &self,
        variables: crate::graphql::emojis::Variables,
    ) -> Result<crate::graphql::emojis::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Emojis>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn emoji(
        &self,
        variables: crate::graphql::emoji::Variables,
    ) -> Result<crate::graphql::emoji::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Emoji>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn favorites(
        &self,
        variables: crate::graphql::favorites::Variables,
    ) -> Result<crate::graphql::favorites::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Favorites>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn favorite(
        &self,
        variables: crate::graphql::favorite::Variables,
    ) -> Result<crate::graphql::favorite::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Favorite>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn figma_embed_info(
        &self,
        variables: crate::graphql::figma_embed_info::Variables,
    ) -> Result<crate::graphql::figma_embed_info::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::FigmaEmbedInfo>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn initiatives(
        &self,
        variables: crate::graphql::initiatives::Variables,
    ) -> Result<crate::graphql::initiatives::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Initiatives>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn initiative(
        &self,
        variables: crate::graphql::initiative::Variables,
    ) -> Result<crate::graphql::initiative::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Initiative>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integrations(
        &self,
        variables: crate::graphql::integrations::Variables,
    ) -> Result<crate::graphql::integrations::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Integrations>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integration(
        &self,
        variables: crate::graphql::integration::Variables,
    ) -> Result<crate::graphql::integration::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Integration>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integration_resources(
        &self,
        variables: crate::graphql::integration_resources::Variables,
    ) -> Result<crate::graphql::integration_resources::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IntegrationResources>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integration_resource(
        &self,
        variables: crate::graphql::integration_resource::Variables,
    ) -> Result<crate::graphql::integration_resource::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IntegrationResource>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_updates(
        &self,
        variables: crate::graphql::project_updates::Variables,
    ) -> Result<crate::graphql::project_updates::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectUpdates>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integrations_settings(
        &self,
        variables: crate::graphql::integrations_settings::Variables,
    ) -> Result<crate::graphql::integrations_settings::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IntegrationsSettings>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integration_templates(
        &self,
        variables: crate::graphql::integration_templates::Variables,
    ) -> Result<crate::graphql::integration_templates::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IntegrationTemplates>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn integration_template(
        &self,
        variables: crate::graphql::integration_template::Variables,
    ) -> Result<crate::graphql::integration_template::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IntegrationTemplate>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_import_finish_github_oauth(
        &self,
        variables: crate::graphql::issue_import_finish_github_oauth::Variables,
    ) -> Result<crate::graphql::issue_import_finish_github_oauth::ResponseData, reqwest::Error>
    {
        let response_body = self
            .post_graphql::<crate::graphql::IssueImportFinishGithubOauth>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_labels(
        &self,
        variables: crate::graphql::issue_labels::Variables,
    ) -> Result<crate::graphql::issue_labels::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueLabels>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_label(
        &self,
        variables: crate::graphql::issue_label::Variables,
    ) -> Result<crate::graphql::issue_label::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueLabel>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_relations(
        &self,
        variables: crate::graphql::issue_relations::Variables,
    ) -> Result<crate::graphql::issue_relations::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueRelations>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_relation(
        &self,
        variables: crate::graphql::issue_relation::Variables,
    ) -> Result<crate::graphql::issue_relation::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueRelation>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issues(
        &self,
        variables: crate::graphql::issues::Variables,
    ) -> Result<crate::graphql::issues::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Issues>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue(
        &self,
        variables: crate::graphql::issue::Variables,
    ) -> Result<crate::graphql::issue::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Issue>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_search(
        &self,
        variables: crate::graphql::issue_search::Variables,
    ) -> Result<crate::graphql::issue_search::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueSearch>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_vcs_branch_search(
        &self,
        variables: crate::graphql::issue_vcs_branch_search::Variables,
    ) -> Result<crate::graphql::issue_vcs_branch_search::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssueVcsBranchSearch>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn issue_priority_values(
        &self,
        variables: crate::graphql::issue_priority_values::Variables,
    ) -> Result<crate::graphql::issue_priority_values::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::IssuePriorityValues>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn milestones(
        &self,
        variables: crate::graphql::milestones::Variables,
    ) -> Result<crate::graphql::milestones::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Milestones>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn milestone(
        &self,
        variables: crate::graphql::milestone::Variables,
    ) -> Result<crate::graphql::milestone::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Milestone>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn notifications(
        &self,
        variables: crate::graphql::notifications::Variables,
    ) -> Result<crate::graphql::notifications::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Notifications>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn notification(
        &self,
        variables: crate::graphql::notification::Variables,
    ) -> Result<crate::graphql::notification::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Notification>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn notification_subscriptions(
        &self,
        variables: crate::graphql::notification_subscriptions::Variables,
    ) -> Result<crate::graphql::notification_subscriptions::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::NotificationSubscriptions>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn notification_subscription(
        &self,
        variables: crate::graphql::notification_subscription::Variables,
    ) -> Result<crate::graphql::notification_subscription::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::NotificationSubscription>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization_domain_claim_request(
        &self,
        variables: crate::graphql::organization_domain_claim_request::Variables,
    ) -> Result<crate::graphql::organization_domain_claim_request::ResponseData, reqwest::Error>
    {
        let response_body = self
            .post_graphql::<crate::graphql::OrganizationDomainClaimRequest>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization_invites(
        &self,
        variables: crate::graphql::organization_invites::Variables,
    ) -> Result<crate::graphql::organization_invites::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::OrganizationInvites>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization_invite(
        &self,
        variables: crate::graphql::organization_invite::Variables,
    ) -> Result<crate::graphql::organization_invite::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::OrganizationInvite>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization_invite_details(
        &self,
        variables: crate::graphql::organization_invite_details::Variables,
    ) -> Result<crate::graphql::organization_invite_details::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::OrganizationInviteDetails>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization(
        &self,
        variables: crate::graphql::organization::Variables,
    ) -> Result<crate::graphql::organization::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Organization>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn organization_exists(
        &self,
        variables: crate::graphql::organization_exists::Variables,
    ) -> Result<crate::graphql::organization_exists::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::OrganizationExists>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_links(
        &self,
        variables: crate::graphql::project_links::Variables,
    ) -> Result<crate::graphql::project_links::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectLinks>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_link(
        &self,
        variables: crate::graphql::project_link::Variables,
    ) -> Result<crate::graphql::project_link::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectLink>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn projects(
        &self,
        variables: crate::graphql::projects::Variables,
    ) -> Result<crate::graphql::projects::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Projects>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project(
        &self,
        variables: crate::graphql::project::Variables,
    ) -> Result<crate::graphql::project::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Project>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_update_interactions(
        &self,
        variables: crate::graphql::project_update_interactions::Variables,
    ) -> Result<crate::graphql::project_update_interactions::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectUpdateInteractions>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_update_interaction(
        &self,
        variables: crate::graphql::project_update_interaction::Variables,
    ) -> Result<crate::graphql::project_update_interaction::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectUpdateInteraction>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn project_update(
        &self,
        variables: crate::graphql::project_update::Variables,
    ) -> Result<crate::graphql::project_update::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::ProjectUpdate>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn push_subscription_test(
        &self,
        variables: crate::graphql::push_subscription_test::Variables,
    ) -> Result<crate::graphql::push_subscription_test::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::PushSubscriptionTest>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn rate_limit_status(
        &self,
        variables: crate::graphql::rate_limit_status::Variables,
    ) -> Result<crate::graphql::rate_limit_status::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::RateLimitStatus>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn roadmaps(
        &self,
        variables: crate::graphql::roadmaps::Variables,
    ) -> Result<crate::graphql::roadmaps::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Roadmaps>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn roadmap(
        &self,
        variables: crate::graphql::roadmap::Variables,
    ) -> Result<crate::graphql::roadmap::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Roadmap>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn roadmap_to_projects(
        &self,
        variables: crate::graphql::roadmap_to_projects::Variables,
    ) -> Result<crate::graphql::roadmap_to_projects::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::RoadmapToProjects>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn roadmap_to_project(
        &self,
        variables: crate::graphql::roadmap_to_project::Variables,
    ) -> Result<crate::graphql::roadmap_to_project::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::RoadmapToProject>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn team_memberships(
        &self,
        variables: crate::graphql::team_memberships::Variables,
    ) -> Result<crate::graphql::team_memberships::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::TeamMemberships>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn team_membership(
        &self,
        variables: crate::graphql::team_membership::Variables,
    ) -> Result<crate::graphql::team_membership::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::TeamMembership>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn teams(
        &self,
        variables: crate::graphql::teams::Variables,
    ) -> Result<crate::graphql::teams::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Teams>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn administrable_teams(
        &self,
        variables: crate::graphql::administrable_teams::Variables,
    ) -> Result<crate::graphql::administrable_teams::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::AdministrableTeams>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn team(
        &self,
        variables: crate::graphql::team::Variables,
    ) -> Result<crate::graphql::team::ResponseData, reqwest::Error> {
        let response_body = self.post_graphql::<crate::graphql::Team>(variables).await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn templates(
        &self,
        variables: crate::graphql::templates::Variables,
    ) -> Result<crate::graphql::templates::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Templates>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn template(
        &self,
        variables: crate::graphql::template::Variables,
    ) -> Result<crate::graphql::template::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Template>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn users(
        &self,
        variables: crate::graphql::users::Variables,
    ) -> Result<crate::graphql::users::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Users>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn user(
        &self,
        variables: crate::graphql::user::Variables,
    ) -> Result<crate::graphql::user::ResponseData, reqwest::Error> {
        let response_body = self.post_graphql::<crate::graphql::User>(variables).await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn viewer(
        &self,
        variables: crate::graphql::viewer::Variables,
    ) -> Result<crate::graphql::viewer::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Viewer>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn user_settings(
        &self,
        variables: crate::graphql::user_settings::Variables,
    ) -> Result<crate::graphql::user_settings::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::UserSettings>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn webhooks(
        &self,
        variables: crate::graphql::webhooks::Variables,
    ) -> Result<crate::graphql::webhooks::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Webhooks>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn webhook(
        &self,
        variables: crate::graphql::webhook::Variables,
    ) -> Result<crate::graphql::webhook::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::Webhook>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn workflow_states(
        &self,
        variables: crate::graphql::workflow_states::Variables,
    ) -> Result<crate::graphql::workflow_states::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::WorkflowStates>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }

    pub async fn workflow_state(
        &self,
        variables: crate::graphql::workflow_state::Variables,
    ) -> Result<crate::graphql::workflow_state::ResponseData, reqwest::Error> {
        let response_body = self
            .post_graphql::<crate::graphql::WorkflowState>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }
}

'''
'''--- crates/linear_sdk/src/core.rs ---
mod types;

pub use types::*;

'''
'''--- crates/linear_sdk/src/core/types.rs ---
mod api_key;

pub use api_key::*;

'''
'''--- crates/linear_sdk/src/core/types/api_key.rs ---
use std::fmt::Display;

/// An API key to authenticate with the Linear API.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct ApiKey(String);

impl Display for ApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for ApiKey {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl From<&str> for ApiKey {
    fn from(value: &str) -> Self {
        Self(value.to_string())
    }
}

'''
'''--- crates/linear_sdk/src/graphql.rs ---
mod custom_scalars;
mod generated;

// Auto-generated:
pub use generated::administrable_teams::*;
pub use generated::api_keys::*;
pub use generated::application_info::*;
pub use generated::application_info_by_ids::*;
pub use generated::application_with_authorization::*;
pub use generated::archived_model_sync::*;
pub use generated::archived_models_sync::*;
pub use generated::attachment::*;
pub use generated::attachment_issue::*;
pub use generated::attachments::*;
pub use generated::attachments_for_url::*;
pub use generated::audit_entries::*;
pub use generated::audit_entry_types::*;
pub use generated::authorized_applications::*;
pub use generated::available_users::*;
pub use generated::comment::*;
pub use generated::comments::*;
pub use generated::custom_view::*;
pub use generated::custom_views::*;
pub use generated::cycle::*;
pub use generated::cycles::*;
pub use generated::dependent_model_sync::*;
pub use generated::document::*;
pub use generated::documents::*;
pub use generated::emoji::*;
pub use generated::emojis::*;
pub use generated::favorite::*;
pub use generated::favorites::*;
pub use generated::figma_embed_info::*;
pub use generated::initiative::*;
pub use generated::initiatives::*;
pub use generated::integration::*;
pub use generated::integration_resource::*;
pub use generated::integration_resources::*;
pub use generated::integration_template::*;
pub use generated::integration_templates::*;
pub use generated::integrations::*;
pub use generated::integrations_settings::*;
pub use generated::issue::*;
pub use generated::issue_import_finish_github_oauth::*;
pub use generated::issue_label::*;
pub use generated::issue_labels::*;
pub use generated::issue_priority_values::*;
pub use generated::issue_relation::*;
pub use generated::issue_relations::*;
pub use generated::issue_search::*;
pub use generated::issue_vcs_branch_search::*;
pub use generated::issues::*;
pub use generated::milestone::*;
pub use generated::milestones::*;
pub use generated::notification::*;
pub use generated::notification_subscription::*;
pub use generated::notification_subscriptions::*;
pub use generated::notifications::*;
pub use generated::organization::*;
pub use generated::organization_domain_claim_request::*;
pub use generated::organization_exists::*;
pub use generated::organization_invite::*;
pub use generated::organization_invite_details::*;
pub use generated::organization_invites::*;
pub use generated::project::*;
pub use generated::project_link::*;
pub use generated::project_links::*;
pub use generated::project_update::*;
pub use generated::project_update_interaction::*;
pub use generated::project_update_interactions::*;
pub use generated::project_updates::*;
pub use generated::projects::*;
pub use generated::push_subscription_test::*;
pub use generated::rate_limit_status::*;
pub use generated::roadmap::*;
pub use generated::roadmap_to_project::*;
pub use generated::roadmap_to_projects::*;
pub use generated::roadmaps::*;
pub use generated::sso_url_from_email::*;
pub use generated::sync_batch::*;
pub use generated::sync_bootstrap::*;
pub use generated::sync_entity_count::*;
pub use generated::team::*;
pub use generated::team_membership::*;
pub use generated::team_memberships::*;
pub use generated::teams::*;
pub use generated::template::*;
pub use generated::templates::*;
pub use generated::user::*;
pub use generated::user_settings::*;
pub use generated::users::*;
pub use generated::viewer::*;
pub use generated::webhook::*;
pub use generated::webhooks::*;
pub use generated::workflow_state::*;
pub use generated::workflow_states::*;
pub use generated::workspace_authorized_applications::*;

'''
'''--- crates/linear_sdk/src/graphql/custom_scalars.rs ---
pub type DateTime = String;

pub type TimelessDate = String;

pub type JSON = String;

pub type JSONObject = String;

'''
'''--- crates/linear_sdk/src/graphql/generated.rs ---
pub mod administrable_teams;
pub mod api_keys;
pub mod application_info;
pub mod application_info_by_ids;
pub mod application_with_authorization;
pub mod archived_model_sync;
pub mod archived_models_sync;
pub mod attachment;
pub mod attachment_issue;
pub mod attachments;
pub mod attachments_for_url;
pub mod audit_entries;
pub mod audit_entry_types;
pub mod authorized_applications;
pub mod available_users;
pub mod comment;
pub mod comments;
pub mod custom_view;
pub mod custom_views;
pub mod cycle;
pub mod cycles;
pub mod dependent_model_sync;
pub mod document;
pub mod documents;
pub mod emoji;
pub mod emojis;
pub mod favorite;
pub mod favorites;
pub mod figma_embed_info;
pub mod initiative;
pub mod initiatives;
pub mod integration;
pub mod integration_resource;
pub mod integration_resources;
pub mod integration_template;
pub mod integration_templates;
pub mod integrations;
pub mod integrations_settings;
pub mod issue;
pub mod issue_import_finish_github_oauth;
pub mod issue_label;
pub mod issue_labels;
pub mod issue_priority_values;
pub mod issue_relation;
pub mod issue_relations;
pub mod issue_search;
pub mod issue_vcs_branch_search;
pub mod issues;
pub mod milestone;
pub mod milestones;
pub mod notification;
pub mod notification_subscription;
pub mod notification_subscriptions;
pub mod notifications;
pub mod organization;
pub mod organization_domain_claim_request;
pub mod organization_exists;
pub mod organization_invite;
pub mod organization_invite_details;
pub mod organization_invites;
pub mod project;
pub mod project_link;
pub mod project_links;
pub mod project_update;
pub mod project_update_interaction;
pub mod project_update_interactions;
pub mod project_updates;
pub mod projects;
pub mod push_subscription_test;
pub mod rate_limit_status;
pub mod roadmap;
pub mod roadmap_to_project;
pub mod roadmap_to_projects;
pub mod roadmaps;
pub mod sso_url_from_email;
pub mod sync_batch;
pub mod sync_bootstrap;
pub mod sync_entity_count;
pub mod team;
pub mod team_membership;
pub mod team_memberships;
pub mod teams;
pub mod template;
pub mod templates;
pub mod user;
pub mod user_settings;
pub mod users;
pub mod viewer;
pub mod webhook;
pub mod webhooks;
pub mod workflow_state;
pub mod workflow_states;
pub mod workspace_authorized_applications;

'''
'''--- crates/linear_sdk/src/graphql/generated/administrable_teams.rs ---
#![allow(clippy::all, warnings)]
pub struct AdministrableTeams;
pub mod administrable_teams {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AdministrableTeams";
    pub const QUERY : & str = "query AdministrableTeams($filter: TeamFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    administrableTeams(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...TeamConnection\n    }\n}\n\nfragment TeamConnection on TeamConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<TeamFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum TeamConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "administrableTeams")]
        pub administrable_teams: AdministrableTeamsAdministrableTeams,
    }
    pub type AdministrableTeamsAdministrableTeams = TeamConnection;
}
impl graphql_client::GraphQLQuery for AdministrableTeams {
    type Variables = administrable_teams::Variables;
    type ResponseData = administrable_teams::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: administrable_teams::QUERY,
            operation_name: administrable_teams::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/api_keys.rs ---
#![allow(clippy::all, warnings)]
pub struct ApiKeys;
pub mod api_keys {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ApiKeys";
    pub const QUERY : & str = "query ApiKeys($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    apiKeys(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...ApiKeyConnection\n    }\n}\n\nfragment ApiKeyConnection on ApiKeyConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum ApiKeyConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "apiKeys")]
        pub api_keys: ApiKeysApiKeys,
    }
    pub type ApiKeysApiKeys = ApiKeyConnection;
}
impl graphql_client::GraphQLQuery for ApiKeys {
    type Variables = api_keys::Variables;
    type ResponseData = api_keys::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: api_keys::QUERY,
            operation_name: api_keys::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/application_info.rs ---
#![allow(clippy::all, warnings)]
pub struct ApplicationInfo;
pub mod application_info {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ApplicationInfo";
    pub const QUERY : & str = "query ApplicationInfo($client_id: String!) {\n    applicationInfo(clientId: $client_id) {\n        ...Application\n    }\n}\n\nfragment Application on Application {\n    __typename\n    id\n    clientId\n    name\n    description\n    developer\n    developerUrl\n    imageUrl\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub client_id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Application {
        pub id: String,
        #[serde(rename = "clientId")]
        pub client_id: String,
        pub name: String,
        pub description: Option<String>,
        pub developer: String,
        #[serde(rename = "developerUrl")]
        pub developer_url: String,
        #[serde(rename = "imageUrl")]
        pub image_url: Option<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "applicationInfo")]
        pub application_info: ApplicationInfoApplicationInfo,
    }
    pub type ApplicationInfoApplicationInfo = Application;
}
impl graphql_client::GraphQLQuery for ApplicationInfo {
    type Variables = application_info::Variables;
    type ResponseData = application_info::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: application_info::QUERY,
            operation_name: application_info::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/application_info_by_ids.rs ---
#![allow(clippy::all, warnings)]
pub struct ApplicationInfoByIds;
pub mod application_info_by_ids {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ApplicationInfoByIds";
    pub const QUERY : & str = "query ApplicationInfoByIds($ids: [String!]!) {\n    applicationInfoByIds(ids: $ids) {\n        ...Application\n    }\n}\n\nfragment Application on Application {\n    __typename\n    id\n    clientId\n    name\n    description\n    developer\n    developerUrl\n    imageUrl\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub ids: Vec<String>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Application {
        pub id: String,
        #[serde(rename = "clientId")]
        pub client_id: String,
        pub name: String,
        pub description: Option<String>,
        pub developer: String,
        #[serde(rename = "developerUrl")]
        pub developer_url: String,
        #[serde(rename = "imageUrl")]
        pub image_url: Option<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "applicationInfoByIds")]
        pub application_info_by_ids: Vec<ApplicationInfoByIdsApplicationInfoByIds>,
    }
    pub type ApplicationInfoByIdsApplicationInfoByIds = Application;
}
impl graphql_client::GraphQLQuery for ApplicationInfoByIds {
    type Variables = application_info_by_ids::Variables;
    type ResponseData = application_info_by_ids::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: application_info_by_ids::QUERY,
            operation_name: application_info_by_ids::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/application_with_authorization.rs ---
#![allow(clippy::all, warnings)]
pub struct ApplicationWithAuthorization;
pub mod application_with_authorization {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ApplicationWithAuthorization";
    pub const QUERY : & str = "query ApplicationWithAuthorization($actor: String, $redirect_uri: String, $scope: [String!]!, $client_id: String!) {\n    applicationWithAuthorization(actor: $actor, redirectUri: $redirect_uri, scope: $scope, clientId: $client_id) {\n        ...UserAuthorizedApplication\n    }\n}\n\nfragment UserAuthorizedApplication on UserAuthorizedApplication {\n    __typename\n    id\n    clientId\n    name\n    description\n    developer\n    developerUrl\n    imageUrl\n    isAuthorized\n    createdByLinear\n    webhooksEnabled\n    approvalErrorCode\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub actor: Option<String>,
        pub redirect_uri: Option<String>,
        pub scope: Vec<String>,
        pub client_id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct UserAuthorizedApplication {
        pub id: String,
        #[serde(rename = "clientId")]
        pub client_id: String,
        pub name: String,
        pub description: Option<String>,
        pub developer: String,
        #[serde(rename = "developerUrl")]
        pub developer_url: String,
        #[serde(rename = "imageUrl")]
        pub image_url: Option<String>,
        #[serde(rename = "isAuthorized")]
        pub is_authorized: Boolean,
        #[serde(rename = "createdByLinear")]
        pub created_by_linear: Boolean,
        #[serde(rename = "webhooksEnabled")]
        pub webhooks_enabled: Boolean,
        #[serde(rename = "approvalErrorCode")]
        pub approval_error_code: Option<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "applicationWithAuthorization")]
        pub application_with_authorization:
            ApplicationWithAuthorizationApplicationWithAuthorization,
    }
    pub type ApplicationWithAuthorizationApplicationWithAuthorization = UserAuthorizedApplication;
}
impl graphql_client::GraphQLQuery for ApplicationWithAuthorization {
    type Variables = application_with_authorization::Variables;
    type ResponseData = application_with_authorization::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: application_with_authorization::QUERY,
            operation_name: application_with_authorization::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/archived_model_sync.rs ---
#![allow(clippy::all, warnings)]
pub struct ArchivedModelSync;
pub mod archived_model_sync {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ArchivedModelSync";
    pub const QUERY : & str = "query ArchivedModelSync($identifier: String!, $model_class: String!) {\n    archivedModelSync(identifier: $identifier, modelClass: $model_class) {\n        ...ArchiveResponse\n    }\n}\n\nfragment ArchiveResponse on ArchiveResponse {\n    __typename\n    archive\n    totalCount\n    databaseVersion\n    includesDependencies\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub identifier: String,
        pub model_class: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct ArchiveResponse {
        pub archive: String,
        #[serde(rename = "totalCount")]
        pub total_count: Float,
        #[serde(rename = "databaseVersion")]
        pub database_version: Float,
        #[serde(rename = "includesDependencies")]
        pub includes_dependencies: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "archivedModelSync")]
        pub archived_model_sync: ArchivedModelSyncArchivedModelSync,
    }
    pub type ArchivedModelSyncArchivedModelSync = ArchiveResponse;
}
impl graphql_client::GraphQLQuery for ArchivedModelSync {
    type Variables = archived_model_sync::Variables;
    type ResponseData = archived_model_sync::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: archived_model_sync::QUERY,
            operation_name: archived_model_sync::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/archived_models_sync.rs ---
#![allow(clippy::all, warnings)]
pub struct ArchivedModelsSync;
pub mod archived_models_sync {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ArchivedModelsSync";
    pub const QUERY : & str = "query ArchivedModelsSync($model_class: String!, $team_id: String!, $trash_option: TrashOptionType, $before: DateTime, $before_id: String, $last: Int) {\n    archivedModelsSync(modelClass: $model_class, teamId: $team_id, trashOption: $trash_option, before: $before, beforeId: $before_id, last: $last) {\n        ...ArchiveResponse\n    }\n}\n\nfragment ArchiveResponse on ArchiveResponse {\n    __typename\n    archive\n    totalCount\n    databaseVersion\n    includesDependencies\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum TrashOptionType {
        includeTrash,
        excludeTrash,
        trashOnly,
        Other(String),
    }
    impl ::serde::Serialize for TrashOptionType {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                TrashOptionType::includeTrash => "includeTrash",
                TrashOptionType::excludeTrash => "excludeTrash",
                TrashOptionType::trashOnly => "trashOnly",
                TrashOptionType::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TrashOptionType {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "includeTrash" => Ok(TrashOptionType::includeTrash),
                "excludeTrash" => Ok(TrashOptionType::excludeTrash),
                "trashOnly" => Ok(TrashOptionType::trashOnly),
                _ => Ok(TrashOptionType::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub model_class: String,
        pub team_id: String,
        pub trash_option: Option<TrashOptionType>,
        pub before: Option<DateTime>,
        pub before_id: Option<String>,
        pub last: Option<Int>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct ArchiveResponse {
        pub archive: String,
        #[serde(rename = "totalCount")]
        pub total_count: Float,
        #[serde(rename = "databaseVersion")]
        pub database_version: Float,
        #[serde(rename = "includesDependencies")]
        pub includes_dependencies: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "archivedModelsSync")]
        pub archived_models_sync: ArchivedModelsSyncArchivedModelsSync,
    }
    pub type ArchivedModelsSyncArchivedModelsSync = ArchiveResponse;
}
impl graphql_client::GraphQLQuery for ArchivedModelsSync {
    type Variables = archived_models_sync::Variables;
    type ResponseData = archived_models_sync::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: archived_models_sync::QUERY,
            operation_name: archived_models_sync::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/attachment.rs ---
#![allow(clippy::all, warnings)]
pub struct Attachment;
pub mod attachment {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Attachment";
    pub const QUERY : & str = "query Attachment($id: String!) {\n    attachment(id: $id) {\n        ...Attachment\n    }\n}\n\nfragment Attachment on Attachment {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    title\n    subtitle\n    url\n    metadata\n    source\n    sourceType\n    groupBySource\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type JSONObject = crate::graphql::custom_scalars::JSONObject;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Attachment {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub title: String,
        pub subtitle: Option<String>,
        pub url: String,
        pub metadata: JSONObject,
        pub source: Option<JSONObject>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<JSONObject>,
        #[serde(rename = "groupBySource")]
        pub group_by_source: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub attachment: AttachmentAttachment,
    }
    pub type AttachmentAttachment = Attachment;
}
impl graphql_client::GraphQLQuery for Attachment {
    type Variables = attachment::Variables;
    type ResponseData = attachment::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: attachment::QUERY,
            operation_name: attachment::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/attachment_issue.rs ---
#![allow(clippy::all, warnings)]
pub struct AttachmentIssue;
pub mod attachment_issue {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AttachmentIssue";
    pub const QUERY : & str = "query AttachmentIssue($id: String!) {\n    attachmentIssue(id: $id) {\n        ...Issue\n    }\n}\n\nfragment Issue on Issue {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    number\n    title\n    description\n    priority\n    estimate\n    boardOrder\n    sortOrder\n    startedAt\n    completedAt\n    triagedAt\n    canceledAt\n    autoClosedAt\n    autoArchivedAt\n    dueDate\n    trashed\n    snoozedUntilAt\n    previousIdentifiers\n    subIssueSortOrder\n    priorityLabel\n    identifier\n    url\n    branchName\n    customerTicketCount\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Issue {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub number: Float,
        pub title: String,
        pub description: Option<String>,
        pub priority: Float,
        pub estimate: Option<Float>,
        #[serde(rename = "boardOrder")]
        #[deprecated(note = "Will be removed in near future, please use `sortOrder` instead")]
        pub board_order: Float,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        #[serde(rename = "startedAt")]
        pub started_at: Option<DateTime>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateTime>,
        #[serde(rename = "triagedAt")]
        pub triaged_at: Option<DateTime>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<DateTime>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<DateTime>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<DateTime>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<TimelessDate>,
        pub trashed: Option<Boolean>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<DateTime>,
        #[serde(rename = "previousIdentifiers")]
        pub previous_identifiers: Vec<String>,
        #[serde(rename = "subIssueSortOrder")]
        pub sub_issue_sort_order: Option<Float>,
        #[serde(rename = "priorityLabel")]
        pub priority_label: String,
        pub identifier: String,
        pub url: String,
        #[serde(rename = "branchName")]
        pub branch_name: String,
        #[serde(rename = "customerTicketCount")]
        pub customer_ticket_count: Int,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "attachmentIssue")]
        #[deprecated(
            note = "Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead."
        )]
        pub attachment_issue: AttachmentIssueAttachmentIssue,
    }
    pub type AttachmentIssueAttachmentIssue = Issue;
}
impl graphql_client::GraphQLQuery for AttachmentIssue {
    type Variables = attachment_issue::Variables;
    type ResponseData = attachment_issue::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: attachment_issue::QUERY,
            operation_name: attachment_issue::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/attachments.rs ---
#![allow(clippy::all, warnings)]
pub struct Attachments;
pub mod attachments {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Attachments";
    pub const QUERY : & str = "query Attachments($filter: AttachmentFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    attachments(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...AttachmentConnection\n    }\n}\n\nfragment AttachmentConnection on AttachmentConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<AttachmentFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum AttachmentConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub attachments: AttachmentsAttachments,
    }
    pub type AttachmentsAttachments = AttachmentConnection;
}
impl graphql_client::GraphQLQuery for Attachments {
    type Variables = attachments::Variables;
    type ResponseData = attachments::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: attachments::QUERY,
            operation_name: attachments::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/attachments_for_url.rs ---
#![allow(clippy::all, warnings)]
pub struct AttachmentsForUrl;
pub mod attachments_for_url {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AttachmentsForUrl";
    pub const QUERY : & str = "query AttachmentsForUrl($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy, $url: String!) {\n    attachmentsForURL(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by, url: $url) {\n        ...AttachmentConnection\n    }\n}\n\nfragment AttachmentConnection on AttachmentConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
        pub url: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum AttachmentConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "attachmentsForURL")]
        pub attachments_for_url: AttachmentsForUrlAttachmentsForUrl,
    }
    pub type AttachmentsForUrlAttachmentsForUrl = AttachmentConnection;
}
impl graphql_client::GraphQLQuery for AttachmentsForUrl {
    type Variables = attachments_for_url::Variables;
    type ResponseData = attachments_for_url::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: attachments_for_url::QUERY,
            operation_name: attachments_for_url::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/audit_entries.rs ---
#![allow(clippy::all, warnings)]
pub struct AuditEntries;
pub mod audit_entries {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AuditEntries";
    pub const QUERY : & str = "query AuditEntries($filter: AuditEntryFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    auditEntries(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...AuditEntryConnection\n    }\n}\n\nfragment AuditEntryConnection on AuditEntryConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct AuditEntryFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub ip: Option<StringComparator>,
        #[serde(rename = "countryCode")]
        pub country_code: Option<StringComparator>,
        pub actor: Box<Option<NullableUserFilter>>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<AuditEntryFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum AuditEntryConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "auditEntries")]
        pub audit_entries: AuditEntriesAuditEntries,
    }
    pub type AuditEntriesAuditEntries = AuditEntryConnection;
}
impl graphql_client::GraphQLQuery for AuditEntries {
    type Variables = audit_entries::Variables;
    type ResponseData = audit_entries::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: audit_entries::QUERY,
            operation_name: audit_entries::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/audit_entry_types.rs ---
#![allow(clippy::all, warnings)]
pub struct AuditEntryTypes;
pub mod audit_entry_types {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AuditEntryTypes";
    pub const QUERY : & str = "query AuditEntryTypes {\n    auditEntryTypes {\n        ...AuditEntryType\n    }\n}\n\nfragment AuditEntryType on AuditEntryType {\n    __typename\n    type\n    description\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct AuditEntryType {
        #[serde(rename = "type")]
        pub type_: String,
        pub description: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "auditEntryTypes")]
        pub audit_entry_types: Vec<AuditEntryTypesAuditEntryTypes>,
    }
    pub type AuditEntryTypesAuditEntryTypes = AuditEntryType;
}
impl graphql_client::GraphQLQuery for AuditEntryTypes {
    type Variables = audit_entry_types::Variables;
    type ResponseData = audit_entry_types::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: audit_entry_types::QUERY,
            operation_name: audit_entry_types::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/authorized_applications.rs ---
#![allow(clippy::all, warnings)]
pub struct AuthorizedApplications;
pub mod authorized_applications {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AuthorizedApplications";
    pub const QUERY : & str = "query AuthorizedApplications {\n    authorizedApplications {\n        ...AuthorizedApplication\n    }\n}\n\nfragment AuthorizedApplication on AuthorizedApplication {\n    __typename\n    name\n    imageUrl\n    scope\n    appId\n    clientId\n    webhooksEnabled\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct AuthorizedApplication {
        pub name: String,
        #[serde(rename = "imageUrl")]
        pub image_url: Option<String>,
        pub scope: Vec<String>,
        #[serde(rename = "appId")]
        pub app_id: String,
        #[serde(rename = "clientId")]
        pub client_id: String,
        #[serde(rename = "webhooksEnabled")]
        pub webhooks_enabled: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "authorizedApplications")]
        pub authorized_applications: Vec<AuthorizedApplicationsAuthorizedApplications>,
    }
    pub type AuthorizedApplicationsAuthorizedApplications = AuthorizedApplication;
}
impl graphql_client::GraphQLQuery for AuthorizedApplications {
    type Variables = authorized_applications::Variables;
    type ResponseData = authorized_applications::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: authorized_applications::QUERY,
            operation_name: authorized_applications::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/available_users.rs ---
#![allow(clippy::all, warnings)]
pub struct AvailableUsers;
pub mod available_users {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "AvailableUsers";
    pub const QUERY : & str = "query AvailableUsers {\n    availableUsers {\n        ...AuthResolverResponse\n    }\n}\n\nfragment AuthResolverResponse on AuthResolverResponse {\n    __typename\n    id\n    token\n    email\n    allowDomainAccess\n    lastUsedOrganizationId\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct AuthResolverResponse {
        pub id: String,
        pub token: Option<String>,
        pub email: Option<String>,
        #[serde(rename = "allowDomainAccess")]
        pub allow_domain_access: Option<Boolean>,
        #[serde(rename = "lastUsedOrganizationId")]
        pub last_used_organization_id: Option<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "availableUsers")]
        pub available_users: AvailableUsersAvailableUsers,
    }
    pub type AvailableUsersAvailableUsers = AuthResolverResponse;
}
impl graphql_client::GraphQLQuery for AvailableUsers {
    type Variables = available_users::Variables;
    type ResponseData = available_users::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: available_users::QUERY,
            operation_name: available_users::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/comment.rs ---
#![allow(clippy::all, warnings)]
pub struct Comment;
pub mod comment {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Comment";
    pub const QUERY : & str = "query Comment($id: String!) {\n    comment(id: $id) {\n        ...Comment\n    }\n}\n\nfragment Comment on Comment {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    body\n    editedAt\n    bodyData\n    url\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Comment {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub body: String,
        #[serde(rename = "editedAt")]
        pub edited_at: Option<DateTime>,
        #[serde(rename = "bodyData")]
        pub body_data: String,
        pub url: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub comment: CommentComment,
    }
    pub type CommentComment = Comment;
}
impl graphql_client::GraphQLQuery for Comment {
    type Variables = comment::Variables;
    type ResponseData = comment::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: comment::QUERY,
            operation_name: comment::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/comments.rs ---
#![allow(clippy::all, warnings)]
pub struct Comments;
pub mod comments {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Comments";
    pub const QUERY : & str = "query Comments($filter: CommentFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    comments(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...CommentConnection\n    }\n}\n\nfragment CommentConnection on CommentConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<CommentFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum CommentConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub comments: CommentsComments,
    }
    pub type CommentsComments = CommentConnection;
}
impl graphql_client::GraphQLQuery for Comments {
    type Variables = comments::Variables;
    type ResponseData = comments::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: comments::QUERY,
            operation_name: comments::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/custom_view.rs ---
#![allow(clippy::all, warnings)]
pub struct CustomView;
pub mod custom_view {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "CustomView";
    pub const QUERY : & str = "query CustomView($id: String!) {\n    customView(id: $id) {\n        ...CustomView\n    }\n}\n\nfragment CustomView on CustomView {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    description\n    icon\n    color\n    filters\n    filterData\n    shared\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type JSONObject = crate::graphql::custom_scalars::JSONObject;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct CustomView {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub description: Option<String>,
        pub icon: Option<String>,
        pub color: Option<String>,
        #[deprecated(note = "Will be replaced by `filterData` in a future update")]
        pub filters: JSONObject,
        #[serde(rename = "filterData")]
        pub filter_data: JSONObject,
        pub shared: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "customView")]
        pub custom_view: CustomViewCustomView,
    }
    pub type CustomViewCustomView = CustomView;
}
impl graphql_client::GraphQLQuery for CustomView {
    type Variables = custom_view::Variables;
    type ResponseData = custom_view::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: custom_view::QUERY,
            operation_name: custom_view::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/custom_views.rs ---
#![allow(clippy::all, warnings)]
pub struct CustomViews;
pub mod custom_views {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "CustomViews";
    pub const QUERY : & str = "query CustomViews($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    customViews(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...CustomViewConnection\n    }\n}\n\nfragment CustomViewConnection on CustomViewConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum CustomViewConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "customViews")]
        pub custom_views: CustomViewsCustomViews,
    }
    pub type CustomViewsCustomViews = CustomViewConnection;
}
impl graphql_client::GraphQLQuery for CustomViews {
    type Variables = custom_views::Variables;
    type ResponseData = custom_views::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: custom_views::QUERY,
            operation_name: custom_views::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/cycle.rs ---
#![allow(clippy::all, warnings)]
pub struct Cycle;
pub mod cycle {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Cycle";
    pub const QUERY : & str = "query Cycle($id: String!) {\n    cycle(id: $id) {\n        ...Cycle\n    }\n}\n\nfragment Cycle on Cycle {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    number\n    name\n    description\n    startsAt\n    endsAt\n    completedAt\n    autoArchivedAt\n    issueCountHistory\n    completedIssueCountHistory\n    scopeHistory\n    completedScopeHistory\n    inProgressScopeHistory\n    progress\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Cycle {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub number: Float,
        pub name: Option<String>,
        pub description: Option<String>,
        #[serde(rename = "startsAt")]
        pub starts_at: DateTime,
        #[serde(rename = "endsAt")]
        pub ends_at: DateTime,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateTime>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<DateTime>,
        #[serde(rename = "issueCountHistory")]
        pub issue_count_history: Vec<Float>,
        #[serde(rename = "completedIssueCountHistory")]
        pub completed_issue_count_history: Vec<Float>,
        #[serde(rename = "scopeHistory")]
        pub scope_history: Vec<Float>,
        #[serde(rename = "completedScopeHistory")]
        pub completed_scope_history: Vec<Float>,
        #[serde(rename = "inProgressScopeHistory")]
        pub in_progress_scope_history: Vec<Float>,
        pub progress: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub cycle: CycleCycle,
    }
    pub type CycleCycle = Cycle;
}
impl graphql_client::GraphQLQuery for Cycle {
    type Variables = cycle::Variables;
    type ResponseData = cycle::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: cycle::QUERY,
            operation_name: cycle::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/cycles.rs ---
#![allow(clippy::all, warnings)]
pub struct Cycles;
pub mod cycles {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Cycles";
    pub const QUERY : & str = "query Cycles($filter: CycleFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    cycles(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...CycleConnection\n    }\n}\n\nfragment CycleConnection on CycleConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct CycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Option<Vec<CycleFilter>>,
        pub or: Option<Vec<CycleFilter>>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<CycleFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum CycleConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub cycles: CyclesCycles,
    }
    pub type CyclesCycles = CycleConnection;
}
impl graphql_client::GraphQLQuery for Cycles {
    type Variables = cycles::Variables;
    type ResponseData = cycles::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: cycles::QUERY,
            operation_name: cycles::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/dependent_model_sync.rs ---
#![allow(clippy::all, warnings)]
pub struct DependentModelSync;
pub mod dependent_model_sync {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "DependentModelSync";
    pub const QUERY : & str = "query DependentModelSync($include_dependent: Boolean, $identifier: String!, $model_class: String!) {\n    dependentModelSync(includeDependent: $include_dependent, identifier: $identifier, modelClass: $model_class) {\n        ...DependencyResponse\n    }\n}\n\nfragment DependencyResponse on DependencyResponse {\n    __typename\n    dependencies\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub include_dependent: Option<Boolean>,
        pub identifier: String,
        pub model_class: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct DependencyResponse {
        pub dependencies: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "dependentModelSync")]
        pub dependent_model_sync: DependentModelSyncDependentModelSync,
    }
    pub type DependentModelSyncDependentModelSync = DependencyResponse;
}
impl graphql_client::GraphQLQuery for DependentModelSync {
    type Variables = dependent_model_sync::Variables;
    type ResponseData = dependent_model_sync::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: dependent_model_sync::QUERY,
            operation_name: dependent_model_sync::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/document.rs ---
#![allow(clippy::all, warnings)]
pub struct Document;
pub mod document {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Document";
    pub const QUERY : & str = "query Document($id: String!) {\n    document(id: $id) {\n        ...Document\n    }\n}\n\nfragment Document on Document {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    title\n    content\n    contentData\n    icon\n    color\n    slugId\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type JSONObject = crate::graphql::custom_scalars::JSONObject;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Document {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub title: String,
        pub content: Option<String>,
        #[serde(rename = "contentData")]
        pub content_data: Option<JSONObject>,
        pub icon: Option<String>,
        pub color: Option<String>,
        #[serde(rename = "slugId")]
        pub slug_id: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub document: DocumentDocument,
    }
    pub type DocumentDocument = Document;
}
impl graphql_client::GraphQLQuery for Document {
    type Variables = document::Variables;
    type ResponseData = document::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: document::QUERY,
            operation_name: document::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/documents.rs ---
#![allow(clippy::all, warnings)]
pub struct Documents;
pub mod documents {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Documents";
    pub const QUERY : & str = "query Documents($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    documents(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...DocumentConnection\n    }\n}\n\nfragment DocumentConnection on DocumentConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum DocumentConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub documents: DocumentsDocuments,
    }
    pub type DocumentsDocuments = DocumentConnection;
}
impl graphql_client::GraphQLQuery for Documents {
    type Variables = documents::Variables;
    type ResponseData = documents::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: documents::QUERY,
            operation_name: documents::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/emoji.rs ---
#![allow(clippy::all, warnings)]
pub struct Emoji;
pub mod emoji {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Emoji";
    pub const QUERY : & str = "query Emoji($id: String!) {\n    emoji(id: $id) {\n        ...Emoji\n    }\n}\n\nfragment Emoji on Emoji {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    url\n    source\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Emoji {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub url: String,
        pub source: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub emoji: EmojiEmoji,
    }
    pub type EmojiEmoji = Emoji;
}
impl graphql_client::GraphQLQuery for Emoji {
    type Variables = emoji::Variables;
    type ResponseData = emoji::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: emoji::QUERY,
            operation_name: emoji::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/emojis.rs ---
#![allow(clippy::all, warnings)]
pub struct Emojis;
pub mod emojis {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Emojis";
    pub const QUERY : & str = "query Emojis($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    emojis(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...EmojiConnection\n    }\n}\n\nfragment EmojiConnection on EmojiConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum EmojiConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub emojis: EmojisEmojis,
    }
    pub type EmojisEmojis = EmojiConnection;
}
impl graphql_client::GraphQLQuery for Emojis {
    type Variables = emojis::Variables;
    type ResponseData = emojis::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: emojis::QUERY,
            operation_name: emojis::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/favorite.rs ---
#![allow(clippy::all, warnings)]
pub struct Favorite;
pub mod favorite {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Favorite";
    pub const QUERY : & str = "query Favorite($id: String!) {\n    favorite(id: $id) {\n        ...Favorite\n    }\n}\n\nfragment Favorite on Favorite {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n    folderName\n    predefinedViewType\n    sortOrder\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Favorite {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "folderName")]
        pub folder_name: Option<String>,
        #[serde(rename = "predefinedViewType")]
        pub predefined_view_type: Option<String>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub favorite: FavoriteFavorite,
    }
    pub type FavoriteFavorite = Favorite;
}
impl graphql_client::GraphQLQuery for Favorite {
    type Variables = favorite::Variables;
    type ResponseData = favorite::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: favorite::QUERY,
            operation_name: favorite::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/favorites.rs ---
#![allow(clippy::all, warnings)]
pub struct Favorites;
pub mod favorites {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Favorites";
    pub const QUERY : & str = "query Favorites($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    favorites(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...FavoriteConnection\n    }\n}\n\nfragment FavoriteConnection on FavoriteConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum FavoriteConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub favorites: FavoritesFavorites,
    }
    pub type FavoritesFavorites = FavoriteConnection;
}
impl graphql_client::GraphQLQuery for Favorites {
    type Variables = favorites::Variables;
    type ResponseData = favorites::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: favorites::QUERY,
            operation_name: favorites::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/figma_embed_info.rs ---
#![allow(clippy::all, warnings)]
pub struct FigmaEmbedInfo;
pub mod figma_embed_info {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "FigmaEmbedInfo";
    pub const QUERY : & str = "query FigmaEmbedInfo($node_id: String, $file_id: String!) {\n    figmaEmbedInfo(nodeId: $node_id, fileId: $file_id) {\n        ...FigmaEmbedPayload\n    }\n}\n\nfragment FigmaEmbedPayload on FigmaEmbedPayload {\n    __typename\n    success\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub node_id: Option<String>,
        pub file_id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct FigmaEmbedPayload {
        pub success: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "figmaEmbedInfo")]
        pub figma_embed_info: FigmaEmbedInfoFigmaEmbedInfo,
    }
    pub type FigmaEmbedInfoFigmaEmbedInfo = FigmaEmbedPayload;
}
impl graphql_client::GraphQLQuery for FigmaEmbedInfo {
    type Variables = figma_embed_info::Variables;
    type ResponseData = figma_embed_info::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: figma_embed_info::QUERY,
            operation_name: figma_embed_info::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/initiative.rs ---
#![allow(clippy::all, warnings)]
pub struct Initiative;
pub mod initiative {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Initiative";
    pub const QUERY : & str = "query Initiative($id: String!) {\n    initiative(id: $id) {\n        ...Initiative\n    }\n}\n\nfragment Initiative on Initiative {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    sortOrder\n    description\n    targetDate\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Initiative {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        pub description: Option<String>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<TimelessDate>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub initiative: InitiativeInitiative,
    }
    pub type InitiativeInitiative = Initiative;
}
impl graphql_client::GraphQLQuery for Initiative {
    type Variables = initiative::Variables;
    type ResponseData = initiative::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: initiative::QUERY,
            operation_name: initiative::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/initiatives.rs ---
#![allow(clippy::all, warnings)]
pub struct Initiatives;
pub mod initiatives {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Initiatives";
    pub const QUERY : & str = "query Initiatives($filter: InitiativeFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    initiatives(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...InitiativeConnection\n    }\n}\n\nfragment InitiativeConnection on InitiativeConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct InitiativeFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub and: Option<Vec<InitiativeFilter>>,
        pub or: Option<Vec<InitiativeFilter>>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<InitiativeFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum InitiativeConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub initiatives: InitiativesInitiatives,
    }
    pub type InitiativesInitiatives = InitiativeConnection;
}
impl graphql_client::GraphQLQuery for Initiatives {
    type Variables = initiatives::Variables;
    type ResponseData = initiatives::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: initiatives::QUERY,
            operation_name: initiatives::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integration.rs ---
#![allow(clippy::all, warnings)]
pub struct Integration;
pub mod integration {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Integration";
    pub const QUERY : & str = "query Integration($id: String!) {\n    integration(id: $id) {\n        ...Integration\n    }\n}\n\nfragment Integration on Integration {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    service\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Integration {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub service: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub integration: IntegrationIntegration,
    }
    pub type IntegrationIntegration = Integration;
}
impl graphql_client::GraphQLQuery for Integration {
    type Variables = integration::Variables;
    type ResponseData = integration::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integration::QUERY,
            operation_name: integration::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integration_resource.rs ---
#![allow(clippy::all, warnings)]
pub struct IntegrationResource;
pub mod integration_resource {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IntegrationResource";
    pub const QUERY : & str = "query IntegrationResource($id: String!) {\n    integrationResource(id: $id) {\n        ...IntegrationResource\n    }\n}\n\nfragment IntegrationResource on IntegrationResource {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    resourceType\n    resourceId\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct IntegrationResource {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "resourceType")]
        pub resource_type: String,
        #[serde(rename = "resourceId")]
        pub resource_id: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "integrationResource")]
        #[deprecated(note = "This query will soon be deprecated, please use `attachment` instead")]
        pub integration_resource: IntegrationResourceIntegrationResource,
    }
    pub type IntegrationResourceIntegrationResource = IntegrationResource;
}
impl graphql_client::GraphQLQuery for IntegrationResource {
    type Variables = integration_resource::Variables;
    type ResponseData = integration_resource::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integration_resource::QUERY,
            operation_name: integration_resource::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integration_resources.rs ---
#![allow(clippy::all, warnings)]
pub struct IntegrationResources;
pub mod integration_resources {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IntegrationResources";
    pub const QUERY : & str = "query IntegrationResources($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    integrationResources(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IntegrationResourceConnection\n    }\n}\n\nfragment IntegrationResourceConnection on IntegrationResourceConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IntegrationResourceConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "integrationResources")]
        #[deprecated(
            note = "This query will soon be deprecated, please use `attachments` instead"
        )]
        pub integration_resources: IntegrationResourcesIntegrationResources,
    }
    pub type IntegrationResourcesIntegrationResources = IntegrationResourceConnection;
}
impl graphql_client::GraphQLQuery for IntegrationResources {
    type Variables = integration_resources::Variables;
    type ResponseData = integration_resources::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integration_resources::QUERY,
            operation_name: integration_resources::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integration_template.rs ---
#![allow(clippy::all, warnings)]
pub struct IntegrationTemplate;
pub mod integration_template {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IntegrationTemplate";
    pub const QUERY : & str = "query IntegrationTemplate($id: String!) {\n    integrationTemplate(id: $id) {\n        ...IntegrationTemplate\n    }\n}\n\nfragment IntegrationTemplate on IntegrationTemplate {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct IntegrationTemplate {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "integrationTemplate")]
        pub integration_template: IntegrationTemplateIntegrationTemplate,
    }
    pub type IntegrationTemplateIntegrationTemplate = IntegrationTemplate;
}
impl graphql_client::GraphQLQuery for IntegrationTemplate {
    type Variables = integration_template::Variables;
    type ResponseData = integration_template::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integration_template::QUERY,
            operation_name: integration_template::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integration_templates.rs ---
#![allow(clippy::all, warnings)]
pub struct IntegrationTemplates;
pub mod integration_templates {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IntegrationTemplates";
    pub const QUERY : & str = "query IntegrationTemplates($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    integrationTemplates(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IntegrationTemplateConnection\n    }\n}\n\nfragment IntegrationTemplateConnection on IntegrationTemplateConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IntegrationTemplateConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "integrationTemplates")]
        pub integration_templates: IntegrationTemplatesIntegrationTemplates,
    }
    pub type IntegrationTemplatesIntegrationTemplates = IntegrationTemplateConnection;
}
impl graphql_client::GraphQLQuery for IntegrationTemplates {
    type Variables = integration_templates::Variables;
    type ResponseData = integration_templates::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integration_templates::QUERY,
            operation_name: integration_templates::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integrations.rs ---
#![allow(clippy::all, warnings)]
pub struct Integrations;
pub mod integrations {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Integrations";
    pub const QUERY : & str = "query Integrations($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    integrations(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IntegrationConnection\n    }\n}\n\nfragment IntegrationConnection on IntegrationConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IntegrationConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub integrations: IntegrationsIntegrations,
    }
    pub type IntegrationsIntegrations = IntegrationConnection;
}
impl graphql_client::GraphQLQuery for Integrations {
    type Variables = integrations::Variables;
    type ResponseData = integrations::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integrations::QUERY,
            operation_name: integrations::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/integrations_settings.rs ---
#![allow(clippy::all, warnings)]
pub struct IntegrationsSettings;
pub mod integrations_settings {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IntegrationsSettings";
    pub const QUERY : & str = "query IntegrationsSettings($id: String!) {\n    integrationsSettings(id: $id) {\n        ...IntegrationsSettings\n    }\n}\n\nfragment IntegrationsSettings on IntegrationsSettings {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    slackIssueCreated\n    slackIssueNewComment\n    slackIssueStatusChangedDone\n    slackIssueStatusChangedAll\n    slackProjectUpdateCreated\n    slackProjectUpdateCreatedToTeam\n    slackProjectUpdateCreatedToMilestone\n    slackProjectUpdateCreatedToWorkspace\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct IntegrationsSettings {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "slackIssueCreated")]
        pub slack_issue_created: Option<Boolean>,
        #[serde(rename = "slackIssueNewComment")]
        pub slack_issue_new_comment: Option<Boolean>,
        #[serde(rename = "slackIssueStatusChangedDone")]
        pub slack_issue_status_changed_done: Option<Boolean>,
        #[serde(rename = "slackIssueStatusChangedAll")]
        pub slack_issue_status_changed_all: Option<Boolean>,
        #[serde(rename = "slackProjectUpdateCreated")]
        pub slack_project_update_created: Option<Boolean>,
        #[serde(rename = "slackProjectUpdateCreatedToTeam")]
        pub slack_project_update_created_to_team: Option<Boolean>,
        #[serde(rename = "slackProjectUpdateCreatedToMilestone")]
        pub slack_project_update_created_to_milestone: Option<Boolean>,
        #[serde(rename = "slackProjectUpdateCreatedToWorkspace")]
        pub slack_project_update_created_to_workspace: Option<Boolean>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "integrationsSettings")]
        pub integrations_settings: IntegrationsSettingsIntegrationsSettings,
    }
    pub type IntegrationsSettingsIntegrationsSettings = IntegrationsSettings;
}
impl graphql_client::GraphQLQuery for IntegrationsSettings {
    type Variables = integrations_settings::Variables;
    type ResponseData = integrations_settings::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: integrations_settings::QUERY,
            operation_name: integrations_settings::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue.rs ---
#![allow(clippy::all, warnings)]
pub struct Issue;
pub mod issue {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Issue";
    pub const QUERY : & str = "query Issue($id: String!) {\n    issue(id: $id) {\n        ...Issue\n    }\n}\n\nfragment Issue on Issue {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    number\n    title\n    description\n    priority\n    estimate\n    boardOrder\n    sortOrder\n    startedAt\n    completedAt\n    triagedAt\n    canceledAt\n    autoClosedAt\n    autoArchivedAt\n    dueDate\n    trashed\n    snoozedUntilAt\n    previousIdentifiers\n    subIssueSortOrder\n    priorityLabel\n    identifier\n    url\n    branchName\n    customerTicketCount\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Issue {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub number: Float,
        pub title: String,
        pub description: Option<String>,
        pub priority: Float,
        pub estimate: Option<Float>,
        #[serde(rename = "boardOrder")]
        #[deprecated(note = "Will be removed in near future, please use `sortOrder` instead")]
        pub board_order: Float,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        #[serde(rename = "startedAt")]
        pub started_at: Option<DateTime>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateTime>,
        #[serde(rename = "triagedAt")]
        pub triaged_at: Option<DateTime>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<DateTime>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<DateTime>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<DateTime>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<TimelessDate>,
        pub trashed: Option<Boolean>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<DateTime>,
        #[serde(rename = "previousIdentifiers")]
        pub previous_identifiers: Vec<String>,
        #[serde(rename = "subIssueSortOrder")]
        pub sub_issue_sort_order: Option<Float>,
        #[serde(rename = "priorityLabel")]
        pub priority_label: String,
        pub identifier: String,
        pub url: String,
        #[serde(rename = "branchName")]
        pub branch_name: String,
        #[serde(rename = "customerTicketCount")]
        pub customer_ticket_count: Int,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub issue: IssueIssue,
    }
    pub type IssueIssue = Issue;
}
impl graphql_client::GraphQLQuery for Issue {
    type Variables = issue::Variables;
    type ResponseData = issue::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue::QUERY,
            operation_name: issue::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_import_finish_github_oauth.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueImportFinishGithubOauth;
pub mod issue_import_finish_github_oauth {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueImportFinishGithubOauth";
    pub const QUERY : & str = "query IssueImportFinishGithubOauth($code: String!) {\n    issueImportFinishGithubOAuth(code: $code) {\n        ...GithubOAuthTokenPayload\n    }\n}\n\nfragment GithubOAuthTokenPayload on GithubOAuthTokenPayload {\n    __typename\n    token\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub code: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct GithubOAuthTokenPayload {
        pub token: Option<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueImportFinishGithubOAuth")]
        pub issue_import_finish_github_o_auth:
            IssueImportFinishGithubOauthIssueImportFinishGithubOAuth,
    }
    pub type IssueImportFinishGithubOauthIssueImportFinishGithubOAuth = GithubOAuthTokenPayload;
}
impl graphql_client::GraphQLQuery for IssueImportFinishGithubOauth {
    type Variables = issue_import_finish_github_oauth::Variables;
    type ResponseData = issue_import_finish_github_oauth::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_import_finish_github_oauth::QUERY,
            operation_name: issue_import_finish_github_oauth::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_label.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueLabel;
pub mod issue_label {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueLabel";
    pub const QUERY : & str = "query IssueLabel($id: String!) {\n    issueLabel(id: $id) {\n        ...IssueLabel\n    }\n}\n\nfragment IssueLabel on IssueLabel {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    description\n    color\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct IssueLabel {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub description: Option<String>,
        pub color: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueLabel")]
        pub issue_label: IssueLabelIssueLabel,
    }
    pub type IssueLabelIssueLabel = IssueLabel;
}
impl graphql_client::GraphQLQuery for IssueLabel {
    type Variables = issue_label::Variables;
    type ResponseData = issue_label::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_label::QUERY,
            operation_name: issue_label::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_labels.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueLabels;
pub mod issue_labels {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueLabels";
    pub const QUERY : & str = "query IssueLabels($filter: IssueLabelFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    issueLabels(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IssueLabelConnection\n    }\n}\n\nfragment IssueLabelConnection on IssueLabelConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<IssueLabelFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IssueLabelConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueLabels")]
        pub issue_labels: IssueLabelsIssueLabels,
    }
    pub type IssueLabelsIssueLabels = IssueLabelConnection;
}
impl graphql_client::GraphQLQuery for IssueLabels {
    type Variables = issue_labels::Variables;
    type ResponseData = issue_labels::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_labels::QUERY,
            operation_name: issue_labels::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_priority_values.rs ---
#![allow(clippy::all, warnings)]
pub struct IssuePriorityValues;
pub mod issue_priority_values {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssuePriorityValues";
    pub const QUERY : & str = "query IssuePriorityValues {\n    issuePriorityValues {\n        ...IssuePriorityValue\n    }\n}\n\nfragment IssuePriorityValue on IssuePriorityValue {\n    __typename\n    priority\n    label\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct IssuePriorityValue {
        pub priority: Int,
        pub label: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issuePriorityValues")]
        pub issue_priority_values: Vec<IssuePriorityValuesIssuePriorityValues>,
    }
    pub type IssuePriorityValuesIssuePriorityValues = IssuePriorityValue;
}
impl graphql_client::GraphQLQuery for IssuePriorityValues {
    type Variables = issue_priority_values::Variables;
    type ResponseData = issue_priority_values::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_priority_values::QUERY,
            operation_name: issue_priority_values::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_relation.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueRelation;
pub mod issue_relation {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueRelation";
    pub const QUERY : & str = "query IssueRelation($id: String!) {\n    issueRelation(id: $id) {\n        ...IssueRelation\n    }\n}\n\nfragment IssueRelation on IssueRelation {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct IssueRelation {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueRelation")]
        pub issue_relation: IssueRelationIssueRelation,
    }
    pub type IssueRelationIssueRelation = IssueRelation;
}
impl graphql_client::GraphQLQuery for IssueRelation {
    type Variables = issue_relation::Variables;
    type ResponseData = issue_relation::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_relation::QUERY,
            operation_name: issue_relation::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_relations.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueRelations;
pub mod issue_relations {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueRelations";
    pub const QUERY : & str = "query IssueRelations($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    issueRelations(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IssueRelationConnection\n    }\n}\n\nfragment IssueRelationConnection on IssueRelationConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IssueRelationConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueRelations")]
        pub issue_relations: IssueRelationsIssueRelations,
    }
    pub type IssueRelationsIssueRelations = IssueRelationConnection;
}
impl graphql_client::GraphQLQuery for IssueRelations {
    type Variables = issue_relations::Variables;
    type ResponseData = issue_relations::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_relations::QUERY,
            operation_name: issue_relations::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_search.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueSearch;
pub mod issue_search {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueSearch";
    pub const QUERY : & str = "query IssueSearch($filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy, $query: String!) {\n    issueSearch(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by, query: $query) {\n        ...IssueConnection\n    }\n}\n\nfragment IssueConnection on IssueConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<IssueFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
        pub query: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IssueConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueSearch")]
        pub issue_search: IssueSearchIssueSearch,
    }
    pub type IssueSearchIssueSearch = IssueConnection;
}
impl graphql_client::GraphQLQuery for IssueSearch {
    type Variables = issue_search::Variables;
    type ResponseData = issue_search::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_search::QUERY,
            operation_name: issue_search::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issue_vcs_branch_search.rs ---
#![allow(clippy::all, warnings)]
pub struct IssueVcsBranchSearch;
pub mod issue_vcs_branch_search {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "IssueVcsBranchSearch";
    pub const QUERY : & str = "query IssueVcsBranchSearch($branch_name: String!) {\n    issueVcsBranchSearch(branchName: $branch_name) {\n        ...Issue\n    }\n}\n\nfragment Issue on Issue {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    number\n    title\n    description\n    priority\n    estimate\n    boardOrder\n    sortOrder\n    startedAt\n    completedAt\n    triagedAt\n    canceledAt\n    autoClosedAt\n    autoArchivedAt\n    dueDate\n    trashed\n    snoozedUntilAt\n    previousIdentifiers\n    subIssueSortOrder\n    priorityLabel\n    identifier\n    url\n    branchName\n    customerTicketCount\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub branch_name: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Issue {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub number: Float,
        pub title: String,
        pub description: Option<String>,
        pub priority: Float,
        pub estimate: Option<Float>,
        #[serde(rename = "boardOrder")]
        #[deprecated(note = "Will be removed in near future, please use `sortOrder` instead")]
        pub board_order: Float,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        #[serde(rename = "startedAt")]
        pub started_at: Option<DateTime>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateTime>,
        #[serde(rename = "triagedAt")]
        pub triaged_at: Option<DateTime>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<DateTime>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<DateTime>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<DateTime>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<TimelessDate>,
        pub trashed: Option<Boolean>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<DateTime>,
        #[serde(rename = "previousIdentifiers")]
        pub previous_identifiers: Vec<String>,
        #[serde(rename = "subIssueSortOrder")]
        pub sub_issue_sort_order: Option<Float>,
        #[serde(rename = "priorityLabel")]
        pub priority_label: String,
        pub identifier: String,
        pub url: String,
        #[serde(rename = "branchName")]
        pub branch_name: String,
        #[serde(rename = "customerTicketCount")]
        pub customer_ticket_count: Int,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "issueVcsBranchSearch")]
        pub issue_vcs_branch_search: Option<IssueVcsBranchSearchIssueVcsBranchSearch>,
    }
    pub type IssueVcsBranchSearchIssueVcsBranchSearch = Issue;
}
impl graphql_client::GraphQLQuery for IssueVcsBranchSearch {
    type Variables = issue_vcs_branch_search::Variables;
    type ResponseData = issue_vcs_branch_search::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issue_vcs_branch_search::QUERY,
            operation_name: issue_vcs_branch_search::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/issues.rs ---
#![allow(clippy::all, warnings)]
pub struct Issues;
pub mod issues {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Issues";
    pub const QUERY : & str = "query Issues($filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    issues(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...IssueConnection\n    }\n}\n\nfragment IssueConnection on IssueConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<IssueFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum IssueConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub issues: IssuesIssues,
    }
    pub type IssuesIssues = IssueConnection;
}
impl graphql_client::GraphQLQuery for Issues {
    type Variables = issues::Variables;
    type ResponseData = issues::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: issues::QUERY,
            operation_name: issues::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/milestone.rs ---
#![allow(clippy::all, warnings)]
pub struct Milestone;
pub mod milestone {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Milestone";
    pub const QUERY : & str = "query Milestone($id: String!) {\n    milestone(id: $id) {\n        ...Milestone\n    }\n}\n\nfragment Milestone on Milestone {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    sortOrder\n    description\n    targetDate\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Milestone {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        pub description: Option<String>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<TimelessDate>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[deprecated(note = "Milestones will be removed. Use roadmaps instead.")]
        pub milestone: MilestoneMilestone,
    }
    pub type MilestoneMilestone = Milestone;
}
impl graphql_client::GraphQLQuery for Milestone {
    type Variables = milestone::Variables;
    type ResponseData = milestone::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: milestone::QUERY,
            operation_name: milestone::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/milestones.rs ---
#![allow(clippy::all, warnings)]
pub struct Milestones;
pub mod milestones {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Milestones";
    pub const QUERY : & str = "query Milestones($filter: MilestoneFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    milestones(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...MilestoneConnection\n    }\n}\n\nfragment MilestoneConnection on MilestoneConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct MilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub and: Option<Vec<MilestoneFilter>>,
        pub or: Option<Vec<MilestoneFilter>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<MilestoneFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum MilestoneConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[deprecated(note = "Milestones will be removed. Use roadmaps instead.")]
        pub milestones: MilestonesMilestones,
    }
    pub type MilestonesMilestones = MilestoneConnection;
}
impl graphql_client::GraphQLQuery for Milestones {
    type Variables = milestones::Variables;
    type ResponseData = milestones::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: milestones::QUERY,
            operation_name: milestones::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/notification.rs ---
#![allow(clippy::all, warnings)]
pub struct Notification;
pub mod notification {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Notification";
    pub const QUERY : & str = "query Notification($id: String!) {\n    notification(id: $id) {\n        ...Notification\n    }\n}\n\nfragment Notification on Notification {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n    readAt\n    emailedAt\n    snoozedUntilAt\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Notification {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "readAt")]
        pub read_at: Option<DateTime>,
        #[serde(rename = "emailedAt")]
        pub emailed_at: Option<DateTime>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<DateTime>,
        #[serde(flatten)]
        pub on: NotificationOn,
    }
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum NotificationOn {
        IssueNotification,
        ProjectNotification,
        OauthClientApprovalNotification,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub notification: NotificationNotification,
    }
    pub type NotificationNotification = Notification;
}
impl graphql_client::GraphQLQuery for Notification {
    type Variables = notification::Variables;
    type ResponseData = notification::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: notification::QUERY,
            operation_name: notification::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/notification_subscription.rs ---
#![allow(clippy::all, warnings)]
pub struct NotificationSubscription;
pub mod notification_subscription {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "NotificationSubscription";
    pub const QUERY : & str = "query NotificationSubscription($id: String!) {\n    notificationSubscription(id: $id) {\n        ...NotificationSubscription\n    }\n}\n\nfragment NotificationSubscription on NotificationSubscription {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct NotificationSubscription {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(flatten)]
        pub on: NotificationSubscriptionOn,
    }
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum NotificationSubscriptionOn {
        ProjectNotificationSubscription,
        TeamNotificationSubscription,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "notificationSubscription")]
        pub notification_subscription: NotificationSubscriptionNotificationSubscription,
    }
    pub type NotificationSubscriptionNotificationSubscription = NotificationSubscription;
}
impl graphql_client::GraphQLQuery for NotificationSubscription {
    type Variables = notification_subscription::Variables;
    type ResponseData = notification_subscription::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: notification_subscription::QUERY,
            operation_name: notification_subscription::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/notification_subscriptions.rs ---
#![allow(clippy::all, warnings)]
pub struct NotificationSubscriptions;
pub mod notification_subscriptions {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "NotificationSubscriptions";
    pub const QUERY : & str = "query NotificationSubscriptions($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    notificationSubscriptions(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...NotificationSubscriptionConnection\n    }\n}\n\nfragment NotificationSubscriptionConnection on NotificationSubscriptionConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum NotificationSubscriptionConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "notificationSubscriptions")]
        pub notification_subscriptions: NotificationSubscriptionsNotificationSubscriptions,
    }
    pub type NotificationSubscriptionsNotificationSubscriptions =
        NotificationSubscriptionConnection;
}
impl graphql_client::GraphQLQuery for NotificationSubscriptions {
    type Variables = notification_subscriptions::Variables;
    type ResponseData = notification_subscriptions::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: notification_subscriptions::QUERY,
            operation_name: notification_subscriptions::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/notifications.rs ---
#![allow(clippy::all, warnings)]
pub struct Notifications;
pub mod notifications {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Notifications";
    pub const QUERY : & str = "query Notifications($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    notifications(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...NotificationConnection\n    }\n}\n\nfragment NotificationConnection on NotificationConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum NotificationConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub notifications: NotificationsNotifications,
    }
    pub type NotificationsNotifications = NotificationConnection;
}
impl graphql_client::GraphQLQuery for Notifications {
    type Variables = notifications::Variables;
    type ResponseData = notifications::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: notifications::QUERY,
            operation_name: notifications::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization.rs ---
#![allow(clippy::all, warnings)]
pub struct Organization;
pub mod organization {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Organization";
    pub const QUERY : & str = "query Organization {\n    organization {\n        ...Organization\n    }\n}\n\nfragment Organization on Organization {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    urlKey\n    logoUrl\n    periodUploadVolume\n    gitBranchFormat\n    gitLinkbackMessagesEnabled\n    gitPublicLinkbackMessagesEnabled\n    roadmapEnabled\n    projectUpdateRemindersHour\n    samlEnabled\n    scimEnabled\n    allowedAuthServices\n    deletionRequestedAt\n    userCount\n    createdIssueCount\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct Organization {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        #[serde(rename = "urlKey")]
        pub url_key: String,
        #[serde(rename = "logoUrl")]
        pub logo_url: Option<String>,
        #[serde(rename = "periodUploadVolume")]
        pub period_upload_volume: Float,
        #[serde(rename = "gitBranchFormat")]
        pub git_branch_format: Option<String>,
        #[serde(rename = "gitLinkbackMessagesEnabled")]
        pub git_linkback_messages_enabled: Boolean,
        #[serde(rename = "gitPublicLinkbackMessagesEnabled")]
        pub git_public_linkback_messages_enabled: Boolean,
        #[serde(rename = "roadmapEnabled")]
        pub roadmap_enabled: Boolean,
        #[serde(rename = "projectUpdateRemindersHour")]
        pub project_update_reminders_hour: Float,
        #[serde(rename = "samlEnabled")]
        pub saml_enabled: Boolean,
        #[serde(rename = "scimEnabled")]
        pub scim_enabled: Boolean,
        #[serde(rename = "allowedAuthServices")]
        pub allowed_auth_services: Vec<String>,
        #[serde(rename = "deletionRequestedAt")]
        pub deletion_requested_at: Option<DateTime>,
        #[serde(rename = "userCount")]
        pub user_count: Int,
        #[serde(rename = "createdIssueCount")]
        pub created_issue_count: Int,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub organization: OrganizationOrganization,
    }
    pub type OrganizationOrganization = Organization;
}
impl graphql_client::GraphQLQuery for Organization {
    type Variables = organization::Variables;
    type ResponseData = organization::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization::QUERY,
            operation_name: organization::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization_domain_claim_request.rs ---
#![allow(clippy::all, warnings)]
pub struct OrganizationDomainClaimRequest;
pub mod organization_domain_claim_request {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "OrganizationDomainClaimRequest";
    pub const QUERY : & str = "query OrganizationDomainClaimRequest($id: String!) {\n    organizationDomainClaimRequest(id: $id) {\n        ...OrganizationDomainClaimPayload\n    }\n}\n\nfragment OrganizationDomainClaimPayload on OrganizationDomainClaimPayload {\n    __typename\n    verificationString\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct OrganizationDomainClaimPayload {
        #[serde(rename = "verificationString")]
        pub verification_string: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "organizationDomainClaimRequest")]
        pub organization_domain_claim_request:
            OrganizationDomainClaimRequestOrganizationDomainClaimRequest,
    }
    pub type OrganizationDomainClaimRequestOrganizationDomainClaimRequest =
        OrganizationDomainClaimPayload;
}
impl graphql_client::GraphQLQuery for OrganizationDomainClaimRequest {
    type Variables = organization_domain_claim_request::Variables;
    type ResponseData = organization_domain_claim_request::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization_domain_claim_request::QUERY,
            operation_name: organization_domain_claim_request::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization_exists.rs ---
#![allow(clippy::all, warnings)]
pub struct OrganizationExists;
pub mod organization_exists {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "OrganizationExists";
    pub const QUERY : & str = "query OrganizationExists($url_key: String!) {\n    organizationExists(urlKey: $url_key) {\n        ...OrganizationExistsPayload\n    }\n}\n\nfragment OrganizationExistsPayload on OrganizationExistsPayload {\n    __typename\n    success\n    exists\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub url_key: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct OrganizationExistsPayload {
        pub success: Boolean,
        pub exists: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "organizationExists")]
        pub organization_exists: OrganizationExistsOrganizationExists,
    }
    pub type OrganizationExistsOrganizationExists = OrganizationExistsPayload;
}
impl graphql_client::GraphQLQuery for OrganizationExists {
    type Variables = organization_exists::Variables;
    type ResponseData = organization_exists::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization_exists::QUERY,
            operation_name: organization_exists::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization_invite.rs ---
#![allow(clippy::all, warnings)]
pub struct OrganizationInvite;
pub mod organization_invite {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "OrganizationInvite";
    pub const QUERY : & str = "query OrganizationInvite($id: String!) {\n    organizationInvite(id: $id) {\n        ...OrganizationInvite\n    }\n}\n\nfragment OrganizationInvite on OrganizationInvite {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    email\n    external\n    acceptedAt\n    expiresAt\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct OrganizationInvite {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub email: String,
        pub external: Boolean,
        #[serde(rename = "acceptedAt")]
        pub accepted_at: Option<DateTime>,
        #[serde(rename = "expiresAt")]
        pub expires_at: Option<DateTime>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "organizationInvite")]
        pub organization_invite: OrganizationInviteOrganizationInvite,
    }
    pub type OrganizationInviteOrganizationInvite = OrganizationInvite;
}
impl graphql_client::GraphQLQuery for OrganizationInvite {
    type Variables = organization_invite::Variables;
    type ResponseData = organization_invite::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization_invite::QUERY,
            operation_name: organization_invite::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization_invite_details.rs ---
#![allow(clippy::all, warnings)]
pub struct OrganizationInviteDetails;
pub mod organization_invite_details {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "OrganizationInviteDetails";
    pub const QUERY : & str = "query OrganizationInviteDetails($id: String!) {\n    organizationInviteDetails(id: $id) {\n        ...OrganizationInviteDetailsPayload\n    }\n}\n\nfragment OrganizationInviteDetailsPayload on OrganizationInviteDetailsPayload {\n    __typename\n    inviter\n    email\n    createdAt\n    organizationName\n    organizationId\n    organizationLogoUrl\n    accepted\n    expired\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct OrganizationInviteDetailsPayload {
        pub inviter: String,
        pub email: String,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "organizationName")]
        pub organization_name: String,
        #[serde(rename = "organizationId")]
        pub organization_id: String,
        #[serde(rename = "organizationLogoUrl")]
        pub organization_logo_url: Option<String>,
        pub accepted: Boolean,
        pub expired: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "organizationInviteDetails")]
        pub organization_invite_details: OrganizationInviteDetailsOrganizationInviteDetails,
    }
    pub type OrganizationInviteDetailsOrganizationInviteDetails = OrganizationInviteDetailsPayload;
}
impl graphql_client::GraphQLQuery for OrganizationInviteDetails {
    type Variables = organization_invite_details::Variables;
    type ResponseData = organization_invite_details::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization_invite_details::QUERY,
            operation_name: organization_invite_details::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/organization_invites.rs ---
#![allow(clippy::all, warnings)]
pub struct OrganizationInvites;
pub mod organization_invites {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "OrganizationInvites";
    pub const QUERY : & str = "query OrganizationInvites($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    organizationInvites(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...OrganizationInviteConnection\n    }\n}\n\nfragment OrganizationInviteConnection on OrganizationInviteConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum OrganizationInviteConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "organizationInvites")]
        pub organization_invites: OrganizationInvitesOrganizationInvites,
    }
    pub type OrganizationInvitesOrganizationInvites = OrganizationInviteConnection;
}
impl graphql_client::GraphQLQuery for OrganizationInvites {
    type Variables = organization_invites::Variables;
    type ResponseData = organization_invites::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: organization_invites::QUERY,
            operation_name: organization_invites::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project.rs ---
#![allow(clippy::all, warnings)]
pub struct Project;
pub mod project {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Project";
    pub const QUERY : & str = "query Project($id: String!) {\n    project(id: $id) {\n        ...Project\n    }\n}\n\nfragment Project on Project {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    description\n    slugId\n    icon\n    color\n    state\n    projectUpdateRemindersPausedUntilAt\n    startDate\n    targetDate\n    startedAt\n    completedAt\n    canceledAt\n    autoArchivedAt\n    sortOrder\n    issueCountHistory\n    completedIssueCountHistory\n    scopeHistory\n    completedScopeHistory\n    inProgressScopeHistory\n    slackNewIssue\n    slackIssueComments\n    slackIssueStatuses\n    url\n    progress\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Project {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub description: String,
        #[serde(rename = "slugId")]
        pub slug_id: String,
        pub icon: Option<String>,
        pub color: String,
        pub state: String,
        #[serde(rename = "projectUpdateRemindersPausedUntilAt")]
        pub project_update_reminders_paused_until_at: Option<DateTime>,
        #[serde(rename = "startDate")]
        pub start_date: Option<TimelessDate>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<TimelessDate>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<DateTime>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateTime>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<DateTime>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<DateTime>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
        #[serde(rename = "issueCountHistory")]
        pub issue_count_history: Vec<Float>,
        #[serde(rename = "completedIssueCountHistory")]
        pub completed_issue_count_history: Vec<Float>,
        #[serde(rename = "scopeHistory")]
        pub scope_history: Vec<Float>,
        #[serde(rename = "completedScopeHistory")]
        pub completed_scope_history: Vec<Float>,
        #[serde(rename = "inProgressScopeHistory")]
        pub in_progress_scope_history: Vec<Float>,
        #[serde(rename = "slackNewIssue")]
        pub slack_new_issue: Boolean,
        #[serde(rename = "slackIssueComments")]
        pub slack_issue_comments: Boolean,
        #[serde(rename = "slackIssueStatuses")]
        pub slack_issue_statuses: Boolean,
        pub url: String,
        pub progress: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub project: ProjectProject,
    }
    pub type ProjectProject = Project;
}
impl graphql_client::GraphQLQuery for Project {
    type Variables = project::Variables;
    type ResponseData = project::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project::QUERY,
            operation_name: project::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_link.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectLink;
pub mod project_link {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectLink";
    pub const QUERY : & str = "query ProjectLink($id: String!) {\n    projectLink(id: $id) {\n        ...ProjectLink\n    }\n}\n\nfragment ProjectLink on ProjectLink {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    url\n    label\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct ProjectLink {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub url: String,
        pub label: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectLink")]
        pub project_link: ProjectLinkProjectLink,
    }
    pub type ProjectLinkProjectLink = ProjectLink;
}
impl graphql_client::GraphQLQuery for ProjectLink {
    type Variables = project_link::Variables;
    type ResponseData = project_link::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_link::QUERY,
            operation_name: project_link::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_links.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectLinks;
pub mod project_links {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectLinks";
    pub const QUERY : & str = "query ProjectLinks($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    projectLinks(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...ProjectLinkConnection\n    }\n}\n\nfragment ProjectLinkConnection on ProjectLinkConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum ProjectLinkConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectLinks")]
        pub project_links: ProjectLinksProjectLinks,
    }
    pub type ProjectLinksProjectLinks = ProjectLinkConnection;
}
impl graphql_client::GraphQLQuery for ProjectLinks {
    type Variables = project_links::Variables;
    type ResponseData = project_links::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_links::QUERY,
            operation_name: project_links::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_update.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectUpdate;
pub mod project_update {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectUpdate";
    pub const QUERY : & str = "query ProjectUpdate($id: String!) {\n    projectUpdate(id: $id) {\n        ...ProjectUpdate\n    }\n}\n\nfragment ProjectUpdate on ProjectUpdate {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    body\n    editedAt\n    url\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct ProjectUpdate {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub body: String,
        #[serde(rename = "editedAt")]
        pub edited_at: Option<DateTime>,
        pub url: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectUpdate")]
        pub project_update: ProjectUpdateProjectUpdate,
    }
    pub type ProjectUpdateProjectUpdate = ProjectUpdate;
}
impl graphql_client::GraphQLQuery for ProjectUpdate {
    type Variables = project_update::Variables;
    type ResponseData = project_update::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_update::QUERY,
            operation_name: project_update::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_update_interaction.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectUpdateInteraction;
pub mod project_update_interaction {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectUpdateInteraction";
    pub const QUERY : & str = "query ProjectUpdateInteraction($id: String!) {\n    projectUpdateInteraction(id: $id) {\n        ...ProjectUpdateInteraction\n    }\n}\n\nfragment ProjectUpdateInteraction on ProjectUpdateInteraction {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    readAt\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct ProjectUpdateInteraction {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "readAt")]
        pub read_at: DateTime,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectUpdateInteraction")]
        pub project_update_interaction: ProjectUpdateInteractionProjectUpdateInteraction,
    }
    pub type ProjectUpdateInteractionProjectUpdateInteraction = ProjectUpdateInteraction;
}
impl graphql_client::GraphQLQuery for ProjectUpdateInteraction {
    type Variables = project_update_interaction::Variables;
    type ResponseData = project_update_interaction::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_update_interaction::QUERY,
            operation_name: project_update_interaction::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_update_interactions.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectUpdateInteractions;
pub mod project_update_interactions {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectUpdateInteractions";
    pub const QUERY : & str = "query ProjectUpdateInteractions($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    projectUpdateInteractions(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...ProjectUpdateInteractionConnection\n    }\n}\n\nfragment ProjectUpdateInteractionConnection on ProjectUpdateInteractionConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum ProjectUpdateInteractionConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectUpdateInteractions")]
        pub project_update_interactions: ProjectUpdateInteractionsProjectUpdateInteractions,
    }
    pub type ProjectUpdateInteractionsProjectUpdateInteractions =
        ProjectUpdateInteractionConnection;
}
impl graphql_client::GraphQLQuery for ProjectUpdateInteractions {
    type Variables = project_update_interactions::Variables;
    type ResponseData = project_update_interactions::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_update_interactions::QUERY,
            operation_name: project_update_interactions::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/project_updates.rs ---
#![allow(clippy::all, warnings)]
pub struct ProjectUpdates;
pub mod project_updates {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "ProjectUpdates";
    pub const QUERY : & str = "query ProjectUpdates($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    projectUpdates(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...ProjectUpdateConnection\n    }\n}\n\nfragment ProjectUpdateConnection on ProjectUpdateConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum ProjectUpdateConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "projectUpdates")]
        pub project_updates: ProjectUpdatesProjectUpdates,
    }
    pub type ProjectUpdatesProjectUpdates = ProjectUpdateConnection;
}
impl graphql_client::GraphQLQuery for ProjectUpdates {
    type Variables = project_updates::Variables;
    type ResponseData = project_updates::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: project_updates::QUERY,
            operation_name: project_updates::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/projects.rs ---
#![allow(clippy::all, warnings)]
pub struct Projects;
pub mod projects {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Projects";
    pub const QUERY : & str = "query Projects($filter: ProjectFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    projects(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...ProjectConnection\n    }\n}\n\nfragment ProjectConnection on ProjectConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<ProjectFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum ProjectConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub projects: ProjectsProjects,
    }
    pub type ProjectsProjects = ProjectConnection;
}
impl graphql_client::GraphQLQuery for Projects {
    type Variables = projects::Variables;
    type ResponseData = projects::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: projects::QUERY,
            operation_name: projects::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/push_subscription_test.rs ---
#![allow(clippy::all, warnings)]
pub struct PushSubscriptionTest;
pub mod push_subscription_test {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "PushSubscriptionTest";
    pub const QUERY : & str = "query PushSubscriptionTest {\n    pushSubscriptionTest {\n        ...PushSubscriptionTestPayload\n    }\n}\n\nfragment PushSubscriptionTestPayload on PushSubscriptionTestPayload {\n    __typename\n    success\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct PushSubscriptionTestPayload {
        pub success: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "pushSubscriptionTest")]
        pub push_subscription_test: PushSubscriptionTestPushSubscriptionTest,
    }
    pub type PushSubscriptionTestPushSubscriptionTest = PushSubscriptionTestPayload;
}
impl graphql_client::GraphQLQuery for PushSubscriptionTest {
    type Variables = push_subscription_test::Variables;
    type ResponseData = push_subscription_test::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: push_subscription_test::QUERY,
            operation_name: push_subscription_test::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/rate_limit_status.rs ---
#![allow(clippy::all, warnings)]
pub struct RateLimitStatus;
pub mod rate_limit_status {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "RateLimitStatus";
    pub const QUERY : & str = "query RateLimitStatus {\n    rateLimitStatus {\n        ...RateLimitPayload\n    }\n}\n\nfragment RateLimitPayload on RateLimitPayload {\n    __typename\n    identifier\n    kind\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct RateLimitPayload {
        pub identifier: Option<String>,
        pub kind: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "rateLimitStatus")]
        pub rate_limit_status: RateLimitStatusRateLimitStatus,
    }
    pub type RateLimitStatusRateLimitStatus = RateLimitPayload;
}
impl graphql_client::GraphQLQuery for RateLimitStatus {
    type Variables = rate_limit_status::Variables;
    type ResponseData = rate_limit_status::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: rate_limit_status::QUERY,
            operation_name: rate_limit_status::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/roadmap.rs ---
#![allow(clippy::all, warnings)]
pub struct Roadmap;
pub mod roadmap {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Roadmap";
    pub const QUERY : & str = "query Roadmap($id: String!) {\n    roadmap(id: $id) {\n        ...Roadmap\n    }\n}\n\nfragment Roadmap on Roadmap {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    description\n    slugId\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Roadmap {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub description: Option<String>,
        #[serde(rename = "slugId")]
        pub slug_id: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub roadmap: RoadmapRoadmap,
    }
    pub type RoadmapRoadmap = Roadmap;
}
impl graphql_client::GraphQLQuery for Roadmap {
    type Variables = roadmap::Variables;
    type ResponseData = roadmap::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: roadmap::QUERY,
            operation_name: roadmap::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/roadmap_to_project.rs ---
#![allow(clippy::all, warnings)]
pub struct RoadmapToProject;
pub mod roadmap_to_project {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "RoadmapToProject";
    pub const QUERY : & str = "query RoadmapToProject($id: String!) {\n    roadmapToProject(id: $id) {\n        ...RoadmapToProject\n    }\n}\n\nfragment RoadmapToProject on RoadmapToProject {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    sortOrder\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct RoadmapToProject {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "sortOrder")]
        pub sort_order: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "roadmapToProject")]
        pub roadmap_to_project: RoadmapToProjectRoadmapToProject,
    }
    pub type RoadmapToProjectRoadmapToProject = RoadmapToProject;
}
impl graphql_client::GraphQLQuery for RoadmapToProject {
    type Variables = roadmap_to_project::Variables;
    type ResponseData = roadmap_to_project::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: roadmap_to_project::QUERY,
            operation_name: roadmap_to_project::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/roadmap_to_projects.rs ---
#![allow(clippy::all, warnings)]
pub struct RoadmapToProjects;
pub mod roadmap_to_projects {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "RoadmapToProjects";
    pub const QUERY : & str = "query RoadmapToProjects($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    roadmapToProjects(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...RoadmapToProjectConnection\n    }\n}\n\nfragment RoadmapToProjectConnection on RoadmapToProjectConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum RoadmapToProjectConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "roadmapToProjects")]
        pub roadmap_to_projects: RoadmapToProjectsRoadmapToProjects,
    }
    pub type RoadmapToProjectsRoadmapToProjects = RoadmapToProjectConnection;
}
impl graphql_client::GraphQLQuery for RoadmapToProjects {
    type Variables = roadmap_to_projects::Variables;
    type ResponseData = roadmap_to_projects::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: roadmap_to_projects::QUERY,
            operation_name: roadmap_to_projects::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/roadmaps.rs ---
#![allow(clippy::all, warnings)]
pub struct Roadmaps;
pub mod roadmaps {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Roadmaps";
    pub const QUERY : & str = "query Roadmaps($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    roadmaps(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...RoadmapConnection\n    }\n}\n\nfragment RoadmapConnection on RoadmapConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum RoadmapConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub roadmaps: RoadmapsRoadmaps,
    }
    pub type RoadmapsRoadmaps = RoadmapConnection;
}
impl graphql_client::GraphQLQuery for Roadmaps {
    type Variables = roadmaps::Variables;
    type ResponseData = roadmaps::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: roadmaps::QUERY,
            operation_name: roadmaps::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/sso_url_from_email.rs ---
#![allow(clippy::all, warnings)]
pub struct SsoUrlFromEmail;
pub mod sso_url_from_email {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "SsoUrlFromEmail";
    pub const QUERY : & str = "query SsoUrlFromEmail($is_desktop: Boolean, $email: String!) {\n    ssoUrlFromEmail(isDesktop: $is_desktop, email: $email) {\n        ...SsoUrlFromEmailResponse\n    }\n}\n\nfragment SsoUrlFromEmailResponse on SsoUrlFromEmailResponse {\n    __typename\n    success\n    samlSsoUrl\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub is_desktop: Option<Boolean>,
        pub email: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct SsoUrlFromEmailResponse {
        pub success: Boolean,
        #[serde(rename = "samlSsoUrl")]
        pub saml_sso_url: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "ssoUrlFromEmail")]
        pub sso_url_from_email: SsoUrlFromEmailSsoUrlFromEmail,
    }
    pub type SsoUrlFromEmailSsoUrlFromEmail = SsoUrlFromEmailResponse;
}
impl graphql_client::GraphQLQuery for SsoUrlFromEmail {
    type Variables = sso_url_from_email::Variables;
    type ResponseData = sso_url_from_email::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: sso_url_from_email::QUERY,
            operation_name: sso_url_from_email::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/sync_batch.rs ---
#![allow(clippy::all, warnings)]
pub struct SyncBatch;
pub mod sync_batch {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "SyncBatch";
    pub const QUERY : & str = "query SyncBatch($requests: [BatchRequest!]!) {\n    syncBatch(requests: $requests) {\n        ...SyncBatchResponse\n    }\n}\n\nfragment SyncBatchResponse on SyncBatchResponse {\n    __typename\n    models\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct BatchRequest {
        #[serde(rename = "modelClass")]
        pub model_class: String,
        #[serde(rename = "indexedKey")]
        pub indexed_key: String,
        #[serde(rename = "keyValue")]
        pub key_value: String,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub requests: Vec<BatchRequest>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct SyncBatchResponse {
        pub models: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "syncBatch")]
        pub sync_batch: SyncBatchSyncBatch,
    }
    pub type SyncBatchSyncBatch = SyncBatchResponse;
}
impl graphql_client::GraphQLQuery for SyncBatch {
    type Variables = sync_batch::Variables;
    type ResponseData = sync_batch::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: sync_batch::QUERY,
            operation_name: sync_batch::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/sync_bootstrap.rs ---
#![allow(clippy::all, warnings)]
pub struct SyncBootstrap;
pub mod sync_bootstrap {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "SyncBootstrap";
    pub const QUERY : & str = "query SyncBootstrap($only_models: [String!], $sync_groups: [String!]) {\n    syncBootstrap(onlyModels: $only_models, syncGroups: $sync_groups) {\n        ...SyncResponse\n    }\n}\n\nfragment SyncResponse on SyncResponse {\n    __typename\n    state\n    delta\n    subscribedSyncGroups\n    lastSyncId\n    databaseVersion\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables {
        pub only_models: Option<Vec<String>>,
        pub sync_groups: Option<Vec<String>>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct SyncResponse {
        pub state: Option<String>,
        pub delta: Option<String>,
        #[serde(rename = "subscribedSyncGroups")]
        pub subscribed_sync_groups: Vec<String>,
        #[serde(rename = "lastSyncId")]
        pub last_sync_id: Float,
        #[serde(rename = "databaseVersion")]
        pub database_version: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "syncBootstrap")]
        pub sync_bootstrap: SyncBootstrapSyncBootstrap,
    }
    pub type SyncBootstrapSyncBootstrap = SyncResponse;
}
impl graphql_client::GraphQLQuery for SyncBootstrap {
    type Variables = sync_bootstrap::Variables;
    type ResponseData = sync_bootstrap::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: sync_bootstrap::QUERY,
            operation_name: sync_bootstrap::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/sync_entity_count.rs ---
#![allow(clippy::all, warnings)]
pub struct SyncEntityCount;
pub mod sync_entity_count {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "SyncEntityCount";
    pub const QUERY : & str = "query SyncEntityCount {\n    syncEntityCount {\n        ...EntityCountResponse\n    }\n}\n\nfragment EntityCountResponse on EntityCountResponse {\n    __typename\n    counts\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type JSON = crate::graphql::custom_scalars::JSON;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct EntityCountResponse {
        pub counts: JSON,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "syncEntityCount")]
        pub sync_entity_count: SyncEntityCountSyncEntityCount,
    }
    pub type SyncEntityCountSyncEntityCount = EntityCountResponse;
}
impl graphql_client::GraphQLQuery for SyncEntityCount {
    type Variables = sync_entity_count::Variables;
    type ResponseData = sync_entity_count::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: sync_entity_count::QUERY,
            operation_name: sync_entity_count::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/team.rs ---
#![allow(clippy::all, warnings)]
pub struct Team;
pub mod team {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Team";
    pub const QUERY : & str = "query Team($id: String!) {\n    team(id: $id) {\n        ...Team\n    }\n}\n\nfragment Team on Team {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    key\n    description\n    icon\n    color\n    cyclesEnabled\n    cycleStartDay\n    cycleDuration\n    cycleCooldownTime\n    cycleIssueAutoAssignStarted\n    cycleIssueAutoAssignCompleted\n    cycleLockToActive\n    upcomingCycleCount\n    timezone\n    inviteHash\n    issueEstimationType\n    issueOrderingNoPriorityFirst\n    issueEstimationAllowZero\n    issueSortOrderDefaultToBottom\n    issueEstimationExtended\n    defaultIssueEstimate\n    triageEnabled\n    defaultTemplateForMembersId\n    defaultTemplateForNonMembersId\n    private\n    groupIssueHistory\n    slackNewIssue\n    slackIssueComments\n    slackIssueStatuses\n    autoClosePeriod\n    autoCloseStateId\n    autoArchivePeriod\n    cycleCalenderUrl\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Team {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub key: String,
        pub description: Option<String>,
        pub icon: Option<String>,
        pub color: Option<String>,
        #[serde(rename = "cyclesEnabled")]
        pub cycles_enabled: Boolean,
        #[serde(rename = "cycleStartDay")]
        pub cycle_start_day: Float,
        #[serde(rename = "cycleDuration")]
        pub cycle_duration: Float,
        #[serde(rename = "cycleCooldownTime")]
        pub cycle_cooldown_time: Float,
        #[serde(rename = "cycleIssueAutoAssignStarted")]
        pub cycle_issue_auto_assign_started: Boolean,
        #[serde(rename = "cycleIssueAutoAssignCompleted")]
        pub cycle_issue_auto_assign_completed: Boolean,
        #[serde(rename = "cycleLockToActive")]
        pub cycle_lock_to_active: Boolean,
        #[serde(rename = "upcomingCycleCount")]
        pub upcoming_cycle_count: Float,
        pub timezone: String,
        #[serde(rename = "inviteHash")]
        pub invite_hash: String,
        #[serde(rename = "issueEstimationType")]
        pub issue_estimation_type: String,
        #[serde(rename = "issueOrderingNoPriorityFirst")]
        pub issue_ordering_no_priority_first: Boolean,
        #[serde(rename = "issueEstimationAllowZero")]
        pub issue_estimation_allow_zero: Boolean,
        #[serde(rename = "issueSortOrderDefaultToBottom")]
        pub issue_sort_order_default_to_bottom: Boolean,
        #[serde(rename = "issueEstimationExtended")]
        pub issue_estimation_extended: Boolean,
        #[serde(rename = "defaultIssueEstimate")]
        pub default_issue_estimate: Float,
        #[serde(rename = "triageEnabled")]
        pub triage_enabled: Boolean,
        #[serde(rename = "defaultTemplateForMembersId")]
        #[deprecated(note = "Use defaultTemplateForMembers instead")]
        pub default_template_for_members_id: Option<String>,
        #[serde(rename = "defaultTemplateForNonMembersId")]
        #[deprecated(note = "Use defaultTemplateForNonMembers instead")]
        pub default_template_for_non_members_id: Option<String>,
        pub private: Boolean,
        #[serde(rename = "groupIssueHistory")]
        pub group_issue_history: Boolean,
        #[serde(rename = "slackNewIssue")]
        pub slack_new_issue: Boolean,
        #[serde(rename = "slackIssueComments")]
        pub slack_issue_comments: Boolean,
        #[serde(rename = "slackIssueStatuses")]
        pub slack_issue_statuses: Boolean,
        #[serde(rename = "autoClosePeriod")]
        pub auto_close_period: Option<Float>,
        #[serde(rename = "autoCloseStateId")]
        pub auto_close_state_id: Option<String>,
        #[serde(rename = "autoArchivePeriod")]
        pub auto_archive_period: Float,
        #[serde(rename = "cycleCalenderUrl")]
        pub cycle_calender_url: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub team: TeamTeam,
    }
    pub type TeamTeam = Team;
}
impl graphql_client::GraphQLQuery for Team {
    type Variables = team::Variables;
    type ResponseData = team::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: team::QUERY,
            operation_name: team::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/team_membership.rs ---
#![allow(clippy::all, warnings)]
pub struct TeamMembership;
pub mod team_membership {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "TeamMembership";
    pub const QUERY : & str = "query TeamMembership($id: String!) {\n    teamMembership(id: $id) {\n        ...TeamMembership\n    }\n}\n\nfragment TeamMembership on TeamMembership {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    owner\n    sortOrder\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct TeamMembership {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub owner: Option<Boolean>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "teamMembership")]
        pub team_membership: TeamMembershipTeamMembership,
    }
    pub type TeamMembershipTeamMembership = TeamMembership;
}
impl graphql_client::GraphQLQuery for TeamMembership {
    type Variables = team_membership::Variables;
    type ResponseData = team_membership::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: team_membership::QUERY,
            operation_name: team_membership::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/team_memberships.rs ---
#![allow(clippy::all, warnings)]
pub struct TeamMemberships;
pub mod team_memberships {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "TeamMemberships";
    pub const QUERY : & str = "query TeamMemberships($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    teamMemberships(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...TeamMembershipConnection\n    }\n}\n\nfragment TeamMembershipConnection on TeamMembershipConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum TeamMembershipConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "teamMemberships")]
        pub team_memberships: TeamMembershipsTeamMemberships,
    }
    pub type TeamMembershipsTeamMemberships = TeamMembershipConnection;
}
impl graphql_client::GraphQLQuery for TeamMemberships {
    type Variables = team_memberships::Variables;
    type ResponseData = team_memberships::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: team_memberships::QUERY,
            operation_name: team_memberships::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/teams.rs ---
#![allow(clippy::all, warnings)]
pub struct Teams;
pub mod teams {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Teams";
    pub const QUERY : & str = "query Teams($filter: TeamFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    teams(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...TeamConnection\n    }\n}\n\nfragment TeamConnection on TeamConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<TeamFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum TeamConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub teams: TeamsTeams,
    }
    pub type TeamsTeams = TeamConnection;
}
impl graphql_client::GraphQLQuery for Teams {
    type Variables = teams::Variables;
    type ResponseData = teams::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: teams::QUERY,
            operation_name: teams::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/template.rs ---
#![allow(clippy::all, warnings)]
pub struct Template;
pub mod template {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Template";
    pub const QUERY : & str = "query Template($id: String!) {\n    template(id: $id) {\n        ...Template\n    }\n}\n\nfragment Template on Template {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n    name\n    description\n    templateData\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type JSON = crate::graphql::custom_scalars::JSON;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Template {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
        pub name: String,
        pub description: Option<String>,
        #[serde(rename = "templateData")]
        pub template_data: JSON,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub template: TemplateTemplate,
    }
    pub type TemplateTemplate = Template;
}
impl graphql_client::GraphQLQuery for Template {
    type Variables = template::Variables;
    type ResponseData = template::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: template::QUERY,
            operation_name: template::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/templates.rs ---
#![allow(clippy::all, warnings)]
pub struct Templates;
pub mod templates {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Templates";
    pub const QUERY : & str = "query Templates {\n    templates {\n        ...Template\n    }\n}\n\nfragment Template on Template {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    type\n    name\n    description\n    templateData\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type JSON = crate::graphql::custom_scalars::JSON;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct Template {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "type")]
        pub type_: String,
        pub name: String,
        pub description: Option<String>,
        #[serde(rename = "templateData")]
        pub template_data: JSON,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub templates: Vec<TemplatesTemplates>,
    }
    pub type TemplatesTemplates = Template;
}
impl graphql_client::GraphQLQuery for Templates {
    type Variables = templates::Variables;
    type ResponseData = templates::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: templates::QUERY,
            operation_name: templates::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/user.rs ---
#![allow(clippy::all, warnings)]
pub struct User;
pub mod user {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "User";
    pub const QUERY : & str = "query User($id: String!) {\n    user(id: $id) {\n        ...User\n    }\n}\n\nfragment User on User {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    displayName\n    email\n    avatarUrl\n    disableReason\n    inviteHash\n    calendarHash\n    description\n    statusEmoji\n    statusLabel\n    statusUntilAt\n    timezone\n    lastSeen\n    guest\n    active\n    url\n    createdIssueCount\n    isMe\n    admin\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct User {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        pub email: String,
        #[serde(rename = "avatarUrl")]
        pub avatar_url: Option<String>,
        #[serde(rename = "disableReason")]
        pub disable_reason: Option<String>,
        #[serde(rename = "inviteHash")]
        pub invite_hash: String,
        #[serde(rename = "calendarHash")]
        pub calendar_hash: Option<String>,
        pub description: Option<String>,
        #[serde(rename = "statusEmoji")]
        pub status_emoji: Option<String>,
        #[serde(rename = "statusLabel")]
        pub status_label: Option<String>,
        #[serde(rename = "statusUntilAt")]
        pub status_until_at: Option<DateTime>,
        pub timezone: Option<String>,
        #[serde(rename = "lastSeen")]
        pub last_seen: Option<DateTime>,
        pub guest: Boolean,
        pub active: Boolean,
        pub url: String,
        #[serde(rename = "createdIssueCount")]
        pub created_issue_count: Int,
        #[serde(rename = "isMe")]
        pub is_me: Boolean,
        pub admin: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub user: UserUser,
    }
    pub type UserUser = User;
}
impl graphql_client::GraphQLQuery for User {
    type Variables = user::Variables;
    type ResponseData = user::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: user::QUERY,
            operation_name: user::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/user_settings.rs ---
#![allow(clippy::all, warnings)]
pub struct UserSettings;
pub mod user_settings {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "UserSettings";
    pub const QUERY : & str = "query UserSettings {\n    userSettings {\n        ...UserSettings\n    }\n}\n\nfragment UserSettings on UserSettings {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    notificationPreferences\n    unsubscribedFrom\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type JSONObject = crate::graphql::custom_scalars::JSONObject;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct UserSettings {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        #[serde(rename = "notificationPreferences")]
        pub notification_preferences: JSONObject,
        #[serde(rename = "unsubscribedFrom")]
        pub unsubscribed_from: Vec<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "userSettings")]
        pub user_settings: UserSettingsUserSettings,
    }
    pub type UserSettingsUserSettings = UserSettings;
}
impl graphql_client::GraphQLQuery for UserSettings {
    type Variables = user_settings::Variables;
    type ResponseData = user_settings::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: user_settings::QUERY,
            operation_name: user_settings::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/users.rs ---
#![allow(clippy::all, warnings)]
pub struct Users;
pub mod users {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Users";
    pub const QUERY : & str = "query Users($filter: UserFilter, $include_disabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    users(filter: $filter, includeDisabled: $include_disabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...UserConnection\n    }\n}\n\nfragment UserConnection on UserConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<UserFilter>,
        pub include_disabled: Option<Boolean>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum UserConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub users: UsersUsers,
    }
    pub type UsersUsers = UserConnection;
}
impl graphql_client::GraphQLQuery for Users {
    type Variables = users::Variables;
    type ResponseData = users::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: users::QUERY,
            operation_name: users::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/viewer.rs ---
#![allow(clippy::all, warnings)]
pub struct Viewer;
pub mod viewer {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Viewer";
    pub const QUERY : & str = "query Viewer {\n    viewer {\n        ...User\n    }\n}\n\nfragment User on User {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    displayName\n    email\n    avatarUrl\n    disableReason\n    inviteHash\n    calendarHash\n    description\n    statusEmoji\n    statusLabel\n    statusUntilAt\n    timezone\n    lastSeen\n    guest\n    active\n    url\n    createdIssueCount\n    isMe\n    admin\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct User {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        pub email: String,
        #[serde(rename = "avatarUrl")]
        pub avatar_url: Option<String>,
        #[serde(rename = "disableReason")]
        pub disable_reason: Option<String>,
        #[serde(rename = "inviteHash")]
        pub invite_hash: String,
        #[serde(rename = "calendarHash")]
        pub calendar_hash: Option<String>,
        pub description: Option<String>,
        #[serde(rename = "statusEmoji")]
        pub status_emoji: Option<String>,
        #[serde(rename = "statusLabel")]
        pub status_label: Option<String>,
        #[serde(rename = "statusUntilAt")]
        pub status_until_at: Option<DateTime>,
        pub timezone: Option<String>,
        #[serde(rename = "lastSeen")]
        pub last_seen: Option<DateTime>,
        pub guest: Boolean,
        pub active: Boolean,
        pub url: String,
        #[serde(rename = "createdIssueCount")]
        pub created_issue_count: Int,
        #[serde(rename = "isMe")]
        pub is_me: Boolean,
        pub admin: Boolean,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub viewer: ViewerViewer,
    }
    pub type ViewerViewer = User;
}
impl graphql_client::GraphQLQuery for Viewer {
    type Variables = viewer::Variables;
    type ResponseData = viewer::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: viewer::QUERY,
            operation_name: viewer::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/webhook.rs ---
#![allow(clippy::all, warnings)]
pub struct Webhook;
pub mod webhook {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Webhook";
    pub const QUERY : & str = "query Webhook($id: String!) {\n    webhook(id: $id) {\n        ...Webhook\n    }\n}\n\nfragment Webhook on Webhook {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    label\n    url\n    enabled\n    allPublicTeams\n    secret\n    resourceTypes\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct Webhook {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub label: Option<String>,
        pub url: Option<String>,
        pub enabled: Boolean,
        #[serde(rename = "allPublicTeams")]
        pub all_public_teams: Boolean,
        pub secret: Option<String>,
        #[serde(rename = "resourceTypes")]
        pub resource_types: Vec<String>,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub webhook: WebhookWebhook,
    }
    pub type WebhookWebhook = Webhook;
}
impl graphql_client::GraphQLQuery for Webhook {
    type Variables = webhook::Variables;
    type ResponseData = webhook::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: webhook::QUERY,
            operation_name: webhook::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/webhooks.rs ---
#![allow(clippy::all, warnings)]
pub struct Webhooks;
pub mod webhooks {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "Webhooks";
    pub const QUERY : & str = "query Webhooks($before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    webhooks(before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...WebhookConnection\n    }\n}\n\nfragment WebhookConnection on WebhookConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum WebhookConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        pub webhooks: WebhooksWebhooks,
    }
    pub type WebhooksWebhooks = WebhookConnection;
}
impl graphql_client::GraphQLQuery for Webhooks {
    type Variables = webhooks::Variables;
    type ResponseData = webhooks::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: webhooks::QUERY,
            operation_name: webhooks::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/workflow_state.rs ---
#![allow(clippy::all, warnings)]
pub struct WorkflowState;
pub mod workflow_state {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "WorkflowState";
    pub const QUERY : & str = "query WorkflowState($id: String!) {\n    workflowState(id: $id) {\n        ...WorkflowState\n    }\n}\n\nfragment WorkflowState on WorkflowState {\n    __typename\n    id\n    createdAt\n    updatedAt\n    archivedAt\n    name\n    color\n    description\n    position\n    type\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    #[derive(Serialize)]
    pub struct Variables {
        pub id: String,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    pub struct WorkflowState {
        pub id: ID,
        #[serde(rename = "createdAt")]
        pub created_at: DateTime,
        #[serde(rename = "updatedAt")]
        pub updated_at: DateTime,
        #[serde(rename = "archivedAt")]
        pub archived_at: Option<DateTime>,
        pub name: String,
        pub color: String,
        pub description: Option<String>,
        pub position: Float,
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "workflowState")]
        pub workflow_state: WorkflowStateWorkflowState,
    }
    pub type WorkflowStateWorkflowState = WorkflowState;
}
impl graphql_client::GraphQLQuery for WorkflowState {
    type Variables = workflow_state::Variables;
    type ResponseData = workflow_state::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: workflow_state::QUERY,
            operation_name: workflow_state::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/workflow_states.rs ---
#![allow(clippy::all, warnings)]
pub struct WorkflowStates;
pub mod workflow_states {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "WorkflowStates";
    pub const QUERY : & str = "query WorkflowStates($filter: WorkflowStateFilter, $before: String, $after: String, $first: Int, $last: Int, $include_archived: Boolean, $order_by: PaginationOrderBy) {\n    workflowStates(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $include_archived, orderBy: $order_by) {\n        ...WorkflowStateConnection\n    }\n}\n\nfragment WorkflowStateConnection on WorkflowStateConnection {\n    __typename\n    \n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    type DateTime = crate::graphql::custom_scalars::DateTime;
    type TimelessDate = crate::graphql::custom_scalars::TimelessDate;
    #[derive(Debug)]
    pub enum PaginationOrderBy {
        createdAt,
        updatedAt,
        Other(String),
    }
    impl ::serde::Serialize for PaginationOrderBy {
        fn serialize<S: serde::Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
            ser.serialize_str(match *self {
                PaginationOrderBy::createdAt => "createdAt",
                PaginationOrderBy::updatedAt => "updatedAt",
                PaginationOrderBy::Other(ref s) => &s,
            })
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PaginationOrderBy {
        fn deserialize<D: ::serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let s: String = ::serde::Deserialize::deserialize(deserializer)?;
            match s.as_str() {
                "createdAt" => Ok(PaginationOrderBy::createdAt),
                "updatedAt" => Ok(PaginationOrderBy::updatedAt),
                _ => Ok(PaginationOrderBy::Other(s)),
            }
        }
    }
    #[derive(Serialize)]
    pub struct BooleanComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct DateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct NullableDateComparator {
        pub eq: Option<DateTime>,
        pub neq: Option<DateTime>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<DateTime>>,
        pub nin: Option<Vec<DateTime>>,
        pub null: Option<Boolean>,
        pub lt: Option<DateTime>,
        pub lte: Option<DateTime>,
        pub gt: Option<DateTime>,
        pub gte: Option<DateTime>,
    }
    #[derive(Serialize)]
    pub struct IDComparator {
        pub eq: Option<ID>,
        pub neq: Option<ID>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<ID>>,
        pub nin: Option<Vec<ID>>,
    }
    #[derive(Serialize)]
    pub struct StringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct NullableStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        pub null: Option<Boolean>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct TeamFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub key: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<TeamFilter>>>,
        pub or: Box<Option<Vec<TeamFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct NullableNumberComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
    }
    #[derive(Serialize)]
    pub struct UserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserFilter>>>,
        pub or: Box<Option<Vec<UserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableUserFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableUserFilter>>>,
        pub or: Box<Option<Vec<NullableUserFilter>>>,
    }
    #[derive(Serialize)]
    pub struct UserCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "displayName")]
        pub display_name: Option<StringComparator>,
        pub email: Option<StringComparator>,
        pub active: Option<BooleanComparator>,
        #[serde(rename = "assignedIssues")]
        pub assigned_issues: Box<Option<IssueCollectionFilter>>,
        pub admin: Option<BooleanComparator>,
        #[serde(rename = "isMe")]
        pub is_me: Option<BooleanComparator>,
        pub and: Box<Option<Vec<UserCollectionFilter>>>,
        pub or: Box<Option<Vec<UserCollectionFilter>>>,
        pub some: Box<Option<UserFilter>>,
        pub every: Box<Option<UserFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelFilter>>>,
        pub or: Box<Option<Vec<IssueLabelFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueLabelCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub parent: Box<Option<IssueLabelFilter>>,
        pub and: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueLabelCollectionFilter>>>,
        pub some: Box<Option<IssueLabelFilter>>,
        pub every: Box<Option<IssueLabelFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct NullableTimelessDateComparator {
        pub eq: Option<TimelessDate>,
        pub neq: Option<TimelessDate>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<TimelessDate>>,
        pub nin: Option<Vec<TimelessDate>>,
        pub null: Option<Boolean>,
        pub lt: Option<TimelessDate>,
        pub lte: Option<TimelessDate>,
        pub gt: Option<TimelessDate>,
        pub gte: Option<TimelessDate>,
    }
    #[derive(Serialize)]
    pub struct NullableCycleFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "startsAt")]
        pub starts_at: Option<DateComparator>,
        #[serde(rename = "endsAt")]
        pub ends_at: Option<DateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<DateComparator>,
        #[serde(rename = "isActive")]
        pub is_active: Option<BooleanComparator>,
        #[serde(rename = "isNext")]
        pub is_next: Option<BooleanComparator>,
        #[serde(rename = "isPrevious")]
        pub is_previous: Option<BooleanComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableCycleFilter>>>,
        pub or: Box<Option<Vec<NullableCycleFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableMilestoneFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "sortOrder")]
        pub sort_order: Option<NumberComparator>,
        pub projects: Box<Option<ProjectCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableMilestoneFilter>>>,
        pub or: Box<Option<Vec<NullableMilestoneFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapFilter>>>,
        pub or: Box<Option<Vec<RoadmapFilter>>>,
    }
    #[derive(Serialize)]
    pub struct RoadmapCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub and: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub or: Box<Option<Vec<RoadmapCollectionFilter>>>,
        pub some: Box<Option<RoadmapFilter>>,
        pub every: Box<Option<RoadmapFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectFilter>>>,
        pub or: Box<Option<Vec<ProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NullableProjectFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableProjectFilter>>>,
        pub or: Box<Option<Vec<NullableProjectFilter>>>,
    }
    #[derive(Serialize)]
    pub struct ProjectCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        #[serde(rename = "slugId")]
        pub slug_id: Option<StringComparator>,
        pub state: Option<StringComparator>,
        #[serde(rename = "startDate")]
        pub start_date: Option<NullableDateComparator>,
        #[serde(rename = "targetDate")]
        pub target_date: Option<NullableDateComparator>,
        pub creator: Box<Option<UserFilter>>,
        pub lead: Box<Option<NullableUserFilter>>,
        pub members: Box<Option<UserFilter>>,
        pub milestone: Box<Option<NullableMilestoneFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub roadmaps: Box<Option<RoadmapCollectionFilter>>,
        pub and: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub or: Box<Option<Vec<ProjectCollectionFilter>>>,
        pub some: Box<Option<ProjectFilter>>,
        pub every: Box<Option<ProjectFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct WorkflowStateFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub name: Option<StringComparator>,
        pub description: Option<StringComparator>,
        pub position: Option<NumberComparator>,
        #[serde(rename = "type")]
        pub type_: Option<StringComparator>,
        pub team: Box<Option<TeamFilter>>,
        pub issues: Box<Option<IssueCollectionFilter>>,
        pub and: Box<Option<Vec<WorkflowStateFilter>>>,
        pub or: Box<Option<Vec<WorkflowStateFilter>>>,
    }
    #[derive(Serialize)]
    pub struct NestedStringComparator {
        pub eq: Option<String>,
        pub neq: Option<String>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<String>>,
        pub nin: Option<Vec<String>>,
        #[serde(rename = "eqIgnoreCase")]
        pub eq_ignore_case: Option<String>,
        #[serde(rename = "neqIgnoreCase")]
        pub neq_ignore_case: Option<String>,
        #[serde(rename = "startsWith")]
        pub starts_with: Option<String>,
        #[serde(rename = "notStartsWith")]
        pub not_starts_with: Option<String>,
        #[serde(rename = "endsWith")]
        pub ends_with: Option<String>,
        #[serde(rename = "notEndsWith")]
        pub not_ends_with: Option<String>,
        pub contains: Option<String>,
        #[serde(rename = "containsIgnoreCase")]
        pub contains_ignore_case: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
        #[serde(rename = "notContainsIgnoreCase")]
        pub not_contains_ignore_case: Option<String>,
    }
    #[derive(Serialize)]
    pub struct AttachmentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentFilter>>>,
        pub or: Box<Option<Vec<AttachmentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct AttachmentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub title: Option<StringComparator>,
        pub subtitle: Option<NullableStringComparator>,
        pub url: Option<StringComparator>,
        pub creator: Box<Option<NullableUserFilter>>,
        #[serde(rename = "sourceType")]
        pub source_type: Option<NestedStringComparator>,
        pub and: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub or: Box<Option<Vec<AttachmentCollectionFilter>>>,
        pub some: Box<Option<AttachmentFilter>>,
        pub every: Box<Option<AttachmentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct CommentFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentFilter>>>,
        pub or: Box<Option<Vec<CommentFilter>>>,
    }
    #[derive(Serialize)]
    pub struct CommentCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub body: Option<StringComparator>,
        pub user: Box<Option<UserFilter>>,
        pub issue: Box<Option<IssueFilter>>,
        pub and: Box<Option<Vec<CommentCollectionFilter>>>,
        pub or: Box<Option<Vec<CommentCollectionFilter>>>,
        pub some: Box<Option<CommentFilter>>,
        pub every: Box<Option<CommentFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct ContentComparator {
        pub contains: Option<String>,
        #[serde(rename = "notContains")]
        pub not_contains: Option<String>,
    }
    #[derive(Serialize)]
    pub struct EstimateComparator {
        pub eq: Option<Float>,
        pub neq: Option<Float>,
        #[serde(rename = "in")]
        pub in_: Option<Vec<Float>>,
        pub nin: Option<Vec<Float>>,
        pub null: Option<Boolean>,
        pub lt: Option<Float>,
        pub lte: Option<Float>,
        pub gt: Option<Float>,
        pub gte: Option<Float>,
        pub or: Option<Vec<NullableNumberComparator>>,
        pub and: Option<Vec<NullableNumberComparator>>,
    }
    #[derive(Serialize)]
    pub struct RelationExistsComparator {
        pub eq: Option<Boolean>,
        pub neq: Option<Boolean>,
    }
    #[derive(Serialize)]
    pub struct NullableIssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub null: Option<Boolean>,
        pub and: Box<Option<Vec<NullableIssueFilter>>>,
        pub or: Box<Option<Vec<NullableIssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueFilter>>>,
        pub or: Box<Option<Vec<IssueFilter>>>,
    }
    #[derive(Serialize)]
    pub struct IssueCollectionFilter {
        pub id: Option<IDComparator>,
        #[serde(rename = "createdAt")]
        pub created_at: Option<DateComparator>,
        #[serde(rename = "updatedAt")]
        pub updated_at: Option<DateComparator>,
        pub number: Option<NumberComparator>,
        pub title: Option<StringComparator>,
        pub description: Option<NullableStringComparator>,
        pub priority: Option<NullableNumberComparator>,
        pub estimate: Option<EstimateComparator>,
        #[serde(rename = "startedAt")]
        pub started_at: Option<NullableDateComparator>,
        #[serde(rename = "completedAt")]
        pub completed_at: Option<NullableDateComparator>,
        #[serde(rename = "canceledAt")]
        pub canceled_at: Option<NullableDateComparator>,
        #[serde(rename = "autoClosedAt")]
        pub auto_closed_at: Option<NullableDateComparator>,
        #[serde(rename = "autoArchivedAt")]
        pub auto_archived_at: Option<NullableDateComparator>,
        #[serde(rename = "dueDate")]
        pub due_date: Option<NullableTimelessDateComparator>,
        #[serde(rename = "snoozedUntilAt")]
        pub snoozed_until_at: Option<NullableDateComparator>,
        pub assignee: Box<Option<NullableUserFilter>>,
        pub creator: Box<Option<NullableUserFilter>>,
        pub parent: Box<Option<NullableIssueFilter>>,
        #[serde(rename = "snoozedBy")]
        pub snoozed_by: Box<Option<NullableUserFilter>>,
        pub labels: Box<Option<IssueLabelCollectionFilter>>,
        pub subscribers: Box<Option<UserCollectionFilter>>,
        pub team: Box<Option<TeamFilter>>,
        pub comments: Box<Option<CommentCollectionFilter>>,
        pub cycle: Box<Option<NullableCycleFilter>>,
        pub project: Box<Option<NullableProjectFilter>>,
        pub state: Box<Option<WorkflowStateFilter>>,
        pub children: Box<Option<IssueCollectionFilter>>,
        pub attachments: Box<Option<AttachmentCollectionFilter>>,
        #[serde(rename = "searchableContent")]
        pub searchable_content: Option<ContentComparator>,
        #[serde(rename = "hasRelatedRelations")]
        pub has_related_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasDuplicateRelations")]
        pub has_duplicate_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockedByRelations")]
        pub has_blocked_by_relations: Option<RelationExistsComparator>,
        #[serde(rename = "hasBlockingRelations")]
        pub has_blocking_relations: Option<RelationExistsComparator>,
        pub and: Box<Option<Vec<IssueCollectionFilter>>>,
        pub or: Box<Option<Vec<IssueCollectionFilter>>>,
        pub some: Box<Option<IssueFilter>>,
        pub every: Box<Option<IssueFilter>>,
        pub length: Option<NumberComparator>,
    }
    #[derive(Serialize)]
    pub struct Variables {
        pub filter: Option<WorkflowStateFilter>,
        pub before: Option<String>,
        pub after: Option<String>,
        pub first: Option<Int>,
        pub last: Option<Int>,
        pub include_archived: Option<Boolean>,
        pub order_by: Option<PaginationOrderBy>,
    }
    impl Variables {}
    #[derive(Deserialize, Debug)]
    #[serde(tag = "__typename")]
    pub enum WorkflowStateConnection {}
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "workflowStates")]
        pub workflow_states: WorkflowStatesWorkflowStates,
    }
    pub type WorkflowStatesWorkflowStates = WorkflowStateConnection;
}
impl graphql_client::GraphQLQuery for WorkflowStates {
    type Variables = workflow_states::Variables;
    type ResponseData = workflow_states::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: workflow_states::QUERY,
            operation_name: workflow_states::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/graphql/generated/workspace_authorized_applications.rs ---
#![allow(clippy::all, warnings)]
pub struct WorkspaceAuthorizedApplications;
pub mod workspace_authorized_applications {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "WorkspaceAuthorizedApplications";
    pub const QUERY : & str = "query WorkspaceAuthorizedApplications {\n    workspaceAuthorizedApplications {\n        ...WorkspaceAuthorizedApplication\n    }\n}\n\nfragment WorkspaceAuthorizedApplication on WorkspaceAuthorizedApplication {\n    __typename\n    name\n    imageUrl\n    scope\n    appId\n    clientId\n    webhooksEnabled\n    totalMembers\n}" ;
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize)]
    pub struct Variables;
    #[derive(Deserialize, Debug)]
    pub struct WorkspaceAuthorizedApplication {
        pub name: String,
        #[serde(rename = "imageUrl")]
        pub image_url: Option<String>,
        pub scope: Vec<String>,
        #[serde(rename = "appId")]
        pub app_id: String,
        #[serde(rename = "clientId")]
        pub client_id: String,
        #[serde(rename = "webhooksEnabled")]
        pub webhooks_enabled: Boolean,
        #[serde(rename = "totalMembers")]
        pub total_members: Float,
    }
    #[derive(Deserialize, Debug)]
    pub struct ResponseData {
        #[serde(rename = "workspaceAuthorizedApplications")]
        pub workspace_authorized_applications:
            Vec<WorkspaceAuthorizedApplicationsWorkspaceAuthorizedApplications>,
    }
    pub type WorkspaceAuthorizedApplicationsWorkspaceAuthorizedApplications =
        WorkspaceAuthorizedApplication;
}
impl graphql_client::GraphQLQuery for WorkspaceAuthorizedApplications {
    type Variables = workspace_authorized_applications::Variables;
    type ResponseData = workspace_authorized_applications::ResponseData;
    fn build_query(variables: Self::Variables) -> ::graphql_client::QueryBody<Self::Variables> {
        graphql_client::QueryBody {
            variables,
            query: workspace_authorized_applications::QUERY,
            operation_name: workspace_authorized_applications::OPERATION_NAME,
        }
    }
}

'''
'''--- crates/linear_sdk/src/lib.rs ---
mod client;
mod client_generated;
mod core;
pub mod graphql;

pub use crate::core::*;
pub use client::*;

'''
'''--- crates/linear_sdk_codegen/Cargo.toml ---
[package]
name = "linear_sdk_codegen"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
clap = { version = "4.0", features = ["derive"] }
heck = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

'''
'''--- crates/linear_sdk_codegen/src/introspection_schema.rs ---
//! The representation of the GraphQL introspection schema.
//!
//! This is based off of the following files used by `graphql-client`:
//!
//! - [`introspection_schema.graphql`](https://github.com/graphql-rust/graphql-client/blob/0776197ad7cfde2c658490e7c7e627a21ed622cb/graphql_client_cli/src/graphql/introspection_schema.graphql)
//! - [`introspection_query.graphql`](https://github.com/graphql-rust/graphql-client/blob/0776197ad7cfde2c658490e7c7e627a21ed622cb/graphql_client_cli/src/graphql/introspection_query.graphql)

use serde::Deserialize;

/// The response from the GraphQL introspection call.
#[derive(Debug, Deserialize)]
pub struct IntrospectionResponse {
    /// The introspection response data.
    pub data: IntrospectionQuery,
}

/// A GraphQL introspection query.
#[derive(Debug, Deserialize)]
pub struct IntrospectionQuery {
    /// The introspection schema.
    #[serde(rename = "__schema")]
    pub schema: IntrospectionSchema,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IntrospectionSchema {
    pub query_type: QueryType,
    pub mutation_type: Option<MutationType>,
    pub types: Vec<GraphQlFullType>,
}

#[derive(Debug, Deserialize)]
pub struct QueryType {
    pub name: String,
}

#[derive(Debug, Deserialize)]
pub struct MutationType {
    pub name: String,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "kind", rename_all = "SCREAMING_SNAKE_CASE")]
pub enum GraphQlFullType {
    Scalar(GraphQlScalarType),
    Object(GraphQlObjectType),
    Interface(GraphQlInterfaceType),
    Union,
    Enum(GraphQlEnumType),
    InputObject(GraphQlInputObjectType),
}

impl GraphQlFullType {
    pub fn name(&self) -> Option<String> {
        match self {
            Self::Scalar(scalar) => Some(scalar.name.clone()),
            Self::Object(object) => Some(object.name.clone()),
            Self::Interface(interface) => Some(interface.name.clone()),
            Self::Union => None,
            Self::Enum(r#enum) => Some(r#enum.name.clone()),
            Self::InputObject(input_object) => Some(input_object.name.clone()),
        }
    }
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphQlScalarType {
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphQlObjectType {
    pub name: String,
    pub description: Option<String>,
    pub fields: Vec<Field>,
    pub of_type: Option<GraphQlTypeRef>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphQlInterfaceType {
    pub name: String,
    pub description: Option<String>,
    pub fields: Vec<Field>,
    pub possible_types: Vec<GraphQlTypeRef>,
}

/// A GraphQL field.
#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Field {
    /// The name of the field.
    pub name: String,

    /// The description of the field.
    pub description: Option<String>,

    /// The type of the field.
    #[serde(rename = "type")]
    pub ty: GraphQlTypeRef,

    /// The arguments to the field.
    pub args: Vec<InputValue>,

    /// Whether the field is deprecated.
    pub is_deprecated: bool,

    /// The reason the field is deprecated.
    pub deprecation_reason: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphQlEnumType {
    pub name: String,
    pub description: Option<String>,
    pub enum_values: Vec<EnumValue>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EnumValue {
    pub name: String,
    pub description: Option<String>,
    pub is_deprecated: bool,
    pub deprecation_reason: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GraphQlInputObjectType {
    pub name: String,
    pub description: Option<String>,
    pub input_fields: Vec<InputValue>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct InputValue {
    pub name: String,
    pub description: Option<String>,

    #[serde(rename = "type")]
    pub ty: GraphQlTypeRef,

    pub default_value: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(tag = "kind", rename_all = "SCREAMING_SNAKE_CASE")]
pub enum GraphQlTypeRef {
    Scalar { name: String },
    Object { name: String },
    Interface { name: String },
    Union { name: String },
    Enum { name: String },
    InputObject { name: String },
    NonNull(Box<OfType>),
    List(Box<OfType>),
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OfType {
    pub of_type: GraphQlTypeRef,
}

'''
'''--- crates/linear_sdk_codegen/src/main.rs ---
mod introspection_schema;

use std::fs::File;
use std::io::{BufReader, Write};
use std::process::Command;

use heck::{ToPascalCase, ToSnakeCase};

use introspection_schema::{
    Field, GraphQlFullType, GraphQlTypeRef, IntrospectionResponse, IntrospectionSchema,
};

fn resolve_type_name(ty: &GraphQlTypeRef) -> &String {
    match ty {
        GraphQlTypeRef::Scalar { name }
        | GraphQlTypeRef::Object { name }
        | GraphQlTypeRef::Interface { name }
        | GraphQlTypeRef::Union { name }
        | GraphQlTypeRef::Enum { name }
        | GraphQlTypeRef::InputObject { name } => name,
        GraphQlTypeRef::NonNull(boxed) | GraphQlTypeRef::List(boxed) => {
            resolve_type_name(&boxed.of_type)
        }
    }
}

fn render_type_name(ty: &GraphQlTypeRef) -> String {
    match ty {
        GraphQlTypeRef::Scalar { name }
        | GraphQlTypeRef::Object { name }
        | GraphQlTypeRef::Interface { name }
        | GraphQlTypeRef::Union { name }
        | GraphQlTypeRef::Enum { name }
        | GraphQlTypeRef::InputObject { name } => name.to_owned(),
        GraphQlTypeRef::NonNull(boxed) => format!("{}!", render_type_name(&boxed.of_type)),
        GraphQlTypeRef::List(boxed) => format!("[{}]", render_type_name(&boxed.of_type)),
    }
}

fn sanitize_name(name: String) -> String {
    name.replace("OAuth", "Oauth")
}

#[derive(Debug)]
struct QueryType {
    fields: Vec<Field>,
}

impl QueryType {
    pub fn fields(&self) -> &[Field] {
        &self.fields
    }
}

impl TryFrom<&IntrospectionSchema> for QueryType {
    type Error = &'static str;

    fn try_from(schema: &IntrospectionSchema) -> Result<Self, Self::Error> {
        let query_name = &schema.query_type.name;

        let query_type = schema
            .types
            .iter()
            .find_map(|ty| match ty {
                GraphQlFullType::Object(object) if &object.name == query_name => Some(object),
                _ => None,
            })
            .ok_or("No Query type found")?;

        Ok(Self {
            fields: query_type.fields.to_vec(),
        })
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let schema_file = File::open("schema.json")?;
    let buf_reader = BufReader::new(schema_file);

    let schema_query: IntrospectionResponse = serde_json::from_reader(buf_reader)?;

    let schema = schema_query.data.schema;

    let query = QueryType::try_from(&schema)?;

    let mut emitted_graphql_modules: Vec<String> = Vec::new();
    let mut generated_client_impls: Vec<String> = Vec::new();

    for field in query.fields() {
        let field_type_name = resolve_type_name(&field.ty);

        let has_args = !field.args.is_empty();
        let args_list = field
            .args
            .iter()
            .map(|arg| {
                format!(
                    "${}: {}",
                    arg.name.to_snake_case(),
                    render_type_name(&arg.ty)
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let applied_args_list = field
            .args
            .iter()
            .map(|arg| format!("{}: ${}", arg.name, arg.name.to_snake_case()))
            .collect::<Vec<_>>()
            .join(", ");

        let field_type = schema
            .types
            .iter()
            .find(|ty| ty.name().as_ref() == Some(&field_type_name))
            .expect(&format!("No type found for field '{}'", field_type_name));

        let mut fragment_field_names = Vec::new();
        if let GraphQlFullType::Object(object) = &field_type {
            for sub_field in &object.fields {
                let sub_field_type_name = resolve_type_name(&sub_field.ty);

                let sub_field_type = schema
                    .types
                    .iter()
                    .find(|ty| ty.name().as_ref() == Some(&sub_field_type_name))
                    .expect(&format!(
                        "No type found for sub field '{}'",
                        sub_field_type_name
                    ));

                if let GraphQlFullType::Scalar(_) = sub_field_type {
                    fragment_field_names.push(sub_field.name.clone());
                }
            }
        }

        let contents = format!(
            r#"
query {query_name}{args_list} {{
    {field_name}{applied_args_list} {{
        ...{fragment_name}
    }}
}}

fragment {fragment_name} on {fragment_name} {{
    __typename
    {fragment_fields}
}}
            "#,
            query_name = sanitize_name(field.name.clone()).to_pascal_case(),
            args_list = if has_args {
                format!("({})", args_list)
            } else {
                String::new()
            },
            applied_args_list = if has_args {
                format!("({})", applied_args_list)
            } else {
                String::new()
            },
            field_name = field.name,
            fragment_name = field_type_name.to_pascal_case(),
            fragment_fields = fragment_field_names.join("\n    ")
        );

        let rust_module_name = sanitize_name(field.name.clone()).to_snake_case();

        let mut graphql_file = File::create(format!(
            "crates/linear_sdk/src/graphql/generated/{}.graphql",
            rust_module_name
        ))?;

        graphql_file.write_all(contents.trim().as_bytes())?;

        emitted_graphql_modules.push(rust_module_name.clone());

        let generated_client_impl = format!(
            r#"
    pub async fn {fn_name}(
        &self,
        variables: crate::graphql::{module_name}::Variables,
    ) -> Result<crate::graphql::{module_name}::ResponseData, reqwest::Error> {{
        let response_body = self
            .post_graphql::<crate::graphql::{operation_name}>(variables)
            .await?;

        Ok(response_body.data.expect("No data"))
    }}
            "#,
            fn_name = sanitize_name(field.name.clone()).to_snake_case(),
            module_name = rust_module_name,
            operation_name = sanitize_name(field.name.clone()).to_pascal_case()
        )
        .trim()
        .to_string();

        generated_client_impls.push(generated_client_impl);
    }

    emitted_graphql_modules.sort_unstable();

    for emitted_graphql_module in &emitted_graphql_modules {
        let mut generate_command = Command::new("graphql-client");

        generate_command
            .arg("generate")
            .arg("--schema-path=schema.json")
            .arg("--custom-scalars-module=crate::graphql::custom_scalars")
            .arg("--response-derives=Debug")
            .arg(format!(
                "crates/linear_sdk/src/graphql/generated/{}.graphql",
                emitted_graphql_module
            ));

        generate_command.status()?;
    }

    let mut generated_module_file = File::create("crates/linear_sdk/src/graphql/generated.rs")?;

    generated_module_file.write_all(
        (emitted_graphql_modules
            .iter()
            .map(|module_name| format!("pub mod {};", module_name))
            .collect::<Vec<_>>()
            .join("\n")
            + "\n")
            .as_bytes(),
    )?;

    let mut generated_graphql_module_file = File::create("crates/linear_sdk/src/graphql.rs")?;

    generated_graphql_module_file.write_all(
        format!(
            r#"
mod custom_scalars;
mod generated;

// Auto-generated:
{}
            "#,
            emitted_graphql_modules
                .iter()
                .map(|module_name| format!("pub use generated::{}::*;", module_name))
                .collect::<Vec<_>>()
                .join("\n")
        )
        .trim()
        .as_bytes(),
    )?;

    let mut generated_client_file = File::create("crates/linear_sdk/src/client_generated.rs")?;

    generated_client_file.write_all(
        format!(
            r#"
impl crate::LinearClient {{
    {impls}
}}
            "#,
            impls = generated_client_impls.join("\n\n")
        )
        .trim()
        .as_bytes(),
    )?;

    Command::new("cargo").arg("fmt").status()?;

    Ok(())
}

'''