*GitHub Repository "kuutamolabs/vss-server"*

'''--- .github/workflows/build-and-deploy.yml ---
name: Continuous Integration

on: [push, pull_request]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_DB: postgres
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: YOU_MUST_CHANGE_THIS_PASSWORD
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: 'corretto'
          java-version: '17'

      - name: Start Tomcat
        run: |
          docker run -d --network=host --name tomcat tomcat:latest

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2
        with:
          gradle-version: release-candidate

      - name: Create database table
        run: |
          psql -h localhost -U postgres -d postgres -f ./app/src/main/java/org/vss/impl/postgres/sql/v0_create_vss_db.sql
        env:
          PGPASSWORD: YOU_MUST_CHANGE_THIS_PASSWORD

      - name: Build and Deploy
        run: |
          # Print Info
          java -version
          gradle --version

          gradle wrapper --gradle-version 8.1.1
          ./gradlew --version
          ./gradlew build

          docker cp app/build/libs/app-1.0.war tomcat:/usr/local/tomcat/webapps/vss.war

      - name: Hit endpoint to verify service is up
        run: |
          # Wait for tomcat-startup
          sleep 5

          # Put request with store='storeId' and key=k1
          hex=0A0773746F726549641A150A026B3110FFFFFFFFFFFFFFFFFF011A046B317631
          curl --data-binary "$(echo "$hex" | xxd -r -p)" http://localhost:8080/vss/putObjects

          # Get request with store='storeId' and key=k1
          hex=0A0773746F7265496412026B31
          curl --data-binary "$(echo "$hex" | xxd -r -p)" http://localhost:8080/vss/getObject

      - name: Cleanup
        run: |
          docker stop tomcat && docker rm tomcat

'''
'''--- README.md ---
# Versioned Storage Service

### Introduction to VSS (Versioned Storage Service)
VSS, which stands for Versioned Storage Service, is an open-source project designed to offer a server-side cloud storage solution specifically tailored for non-custodial Lightning supporting mobile wallets. Its primary objective is to simplify the development process for Lightning wallets by providing a secure means to store and manage the essential state required for Lightning Network (LN) operations.

In a non-custodial Lightning wallet, it is crucial to securely store and manage various types of state data. This includes maintaining a list of open channels with other nodes in the network and updating the channel state for every payment made or received. Relying solely on user devices to store this information is not reliable, as data loss could lead to the loss of funds or even the entire wallet.

To address this challenge, the VSS project introduces a framework and a readily available service that can be hosted by anyone as a Versioned Storage Service. It offers two core functionalities:

* **Recovery**: In the event of a user losing their phone or access to their app's data, VSS allows for the restoration of the wallet state. This ensures that users can regain access to their funds, even in cases of device or data loss.
* **Multi-device Access**: VSS enables multiple devices with the same wallet app to securely access and share LN state. This seamless switching between devices ensures consistent access to funds for users.

<p align="center">
  <img src="http://www.plantuml.com/plantuml/png/VP2nJWCn44HxVyMKK4JqAQ8W8aGHA33GBxuXP-7p7lRUeVmzAz60X6YcsQTvezrtasRBL89bAyHBZBZBfn57hYmuY0bkYtw6SA-lkV30DITkTd1mY-l5HbRBIInhnIC_5dOBVjliVl9RT9ru8Ou_wJlhPGX5TSQRDhYddJ7BUV8cT8-hniIySlZJ-JmFOiJn0JUZrCg2Q6BybaRJ9YVwCjCff_zWUE7lZN59YRq7rY7iFVmhNm00" />
</p>

Clients can also use VSS for general metadata storage as well such as payment history, user metadata etc.
### Motivation

By providing a reusable component, VSS aims to lower the barriers for building high-quality LN wallets. Wallet developers have the flexibility to either host the VSS service in-house, enabling easy interaction with the component, or utilize reliable third-party VSS providers if available. 

VSS is designed to work with various applications that implement different levels of key-level versioning and data-integrity mechanisms. It even allows for the disabling of versioning altogether for single-device wallet usage, making it simple to get started.

The project's design decisions prioritize features such as multi-device access, user privacy through client-side encryption(e.g. using key derived from bitcoin wallet), authorization mechanisms, data and version number verifiability, and modularity for seamless integration with different backend technologies.

### Modularity
VSS can work out-of-box with minor configuration but is intended to be forked and customized based on the specific needs of wallet developers. This customization may include implementing custom authorization, encryption, or backend database integration with different cloud providers. As long as the API contract is implemented correctly, wallets can effortlessly switch between different instances of VSS.

VSS ships with a PostgreSQL implementation by default and can be hosted in your favorite infrastructure/cloud provider (AWS/GCP) and its backend storage can be switched with some other implementation for KeyValueStore if needed.

### Project Execution
To explore the detailed API contract of VSS, you can refer to the [VSS API contract](https://github.com/lightningdevkit/vss-server/blob/main/app/src/main/proto/vss.proto) and can track project progress [here](https://github.com/lightningdevkit/vss-server/issues/9). VSS execution is split into two phases, phase-I prioritizes recovery and single-device use, whereas phase-II covers multi-device use. The first phase is expected to be released in Q2 2023. The second phase will be subject to monitoring for demand from wallets and may slip to 2024. [[LDK-Roadmap](https://lightningdevkit.org/blog/ldk-roadmap/#vss)]

### Summary
In summary, VSS is an open-source project that offers a server-side cloud storage solution for non-custodial Lightning wallets. It provides multi-device access, recovery capabilities, and various features to ensure user privacy and data verifiability. By leveraging VSS, wallet developers can focus on building innovative Lightning wallets without the burden of implementing complex storage solutions from scratch.

'''
'''--- app/src/main/java/org/vss/KVStore.java ---
package org.vss;

public interface KVStore {

  String GLOBAL_VERSION_KEY = "vss_global_version";

  GetObjectResponse get(GetObjectRequest request);

  PutObjectResponse put(PutObjectRequest request);

  DeleteObjectResponse delete(DeleteObjectRequest request);

  ListKeyVersionsResponse listKeyVersions(ListKeyVersionsRequest request);
}

'''
'''--- app/src/main/java/org/vss/VSSApplication.java ---
package org.vss;

import com.google.inject.Guice;
import com.google.inject.Injector;
import jakarta.inject.Inject;
import jakarta.ws.rs.ApplicationPath;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.jersey.server.ResourceConfig;
import org.jvnet.hk2.guice.bridge.api.GuiceBridge;
import org.jvnet.hk2.guice.bridge.api.GuiceIntoHK2Bridge;
import org.vss.guice.BaseModule;

@ApplicationPath("/")
public class VSSApplication extends ResourceConfig {

  @Inject
  public VSSApplication(ServiceLocator serviceLocator) {
    packages("org.vss");
    Injector injector = Guice.createInjector(new BaseModule());
    initGuiceIntoHK2Bridge(serviceLocator, injector);
  }

  // By default, Jersey framework uses HK2 for dependency injection.
  // To use Guice as our dependency injection framework, we provide guice injector to hk2-bridge.
  // So that hk2 can query guice injector for creating/injecting objects.
  private void initGuiceIntoHK2Bridge(ServiceLocator serviceLocator, Injector injector) {
    GuiceBridge.getGuiceBridge().initializeGuiceBridge(serviceLocator);
    GuiceIntoHK2Bridge guiceBridge = serviceLocator.getService(GuiceIntoHK2Bridge.class);
    guiceBridge.bridgeGuiceInjector(injector);
  }
}

'''
'''--- app/src/main/java/org/vss/api/AbstractVssApi.java ---
package org.vss.api;

import com.google.protobuf.GeneratedMessageV3;
import com.google.protobuf.InvalidProtocolBufferException;
import jakarta.inject.Inject;
import jakarta.ws.rs.core.Response;
import org.vss.ErrorCode;
import org.vss.ErrorResponse;
import org.vss.KVStore;
import org.vss.exception.ConflictException;
import org.vss.exception.NoSuchKeyException;

public abstract class AbstractVssApi {
  final KVStore kvStore;

  @Inject
  public AbstractVssApi(KVStore kvStore) {
    this.kvStore = kvStore;
  }

  Response toResponse(GeneratedMessageV3 protoResponse) {

    return Response
        .status(Response.Status.OK)
        .entity(protoResponse.toByteArray())
        .build();
  }

  Response toErrorResponse(Exception e) {
    ErrorCode errorCode;
    if (e instanceof ConflictException) {
      errorCode = ErrorCode.CONFLICT_EXCEPTION;
    } else if (e instanceof IllegalArgumentException
        || e instanceof InvalidProtocolBufferException) {
      errorCode = ErrorCode.INVALID_REQUEST_EXCEPTION;
    } else if (e instanceof NoSuchKeyException) {
      errorCode = ErrorCode.NO_SUCH_KEY_EXCEPTION;
    } else {
      errorCode = ErrorCode.INTERNAL_SERVER_EXCEPTION;
    }

    ErrorResponse errorResponse = ErrorResponse.newBuilder()
        .setErrorCode(errorCode)
        .setMessage(e.getMessage())
        .build();

    return Response.status(errorCode.getNumber())
        .entity(errorResponse.toByteArray())
        .build();
  }
}

'''
'''--- app/src/main/java/org/vss/api/DeleteObjectApi.java ---
package org.vss.api;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import lombok.extern.slf4j.Slf4j;
import org.vss.DeleteObjectRequest;
import org.vss.DeleteObjectResponse;
import org.vss.KVStore;

@Path(VssApiEndpoint.DELETE_OBJECT)
@Slf4j
public class DeleteObjectApi extends AbstractVssApi {
  @Inject
  public DeleteObjectApi(KVStore kvstore) {
    super(kvstore);
  }

  @POST
  @Produces(MediaType.APPLICATION_OCTET_STREAM)
  public Response execute(byte[] payload) {
    try {
      DeleteObjectRequest request = DeleteObjectRequest.parseFrom(payload);
      DeleteObjectResponse response = kvStore.delete(request);
      return toResponse(response);
    } catch (Exception e) {
      log.error("Exception in DeleteObjectApi: ", e);
      return toErrorResponse(e);
    }
  }
}

'''
'''--- app/src/main/java/org/vss/api/GetObjectApi.java ---
package org.vss.api;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import lombok.extern.slf4j.Slf4j;
import org.vss.GetObjectRequest;
import org.vss.GetObjectResponse;
import org.vss.KVStore;

@Path(VssApiEndpoint.GET_OBJECT)
@Slf4j
public class GetObjectApi extends AbstractVssApi {

  @Inject
  public GetObjectApi(KVStore kvstore) {
    super(kvstore);
  }

  @POST
  @Produces(MediaType.APPLICATION_OCTET_STREAM)
  public Response execute(byte[] payload) {
    try {
      GetObjectRequest request = GetObjectRequest.parseFrom(payload);
      GetObjectResponse response = kvStore.get(request);
      return toResponse(response);
    } catch (Exception e) {
      log.error("Exception in GetObjectApi: ", e);
      return toErrorResponse(e);
    }
  }
}

'''
'''--- app/src/main/java/org/vss/api/ListKeyVersionsApi.java ---
package org.vss.api;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import lombok.extern.slf4j.Slf4j;
import org.vss.KVStore;
import org.vss.ListKeyVersionsRequest;
import org.vss.ListKeyVersionsResponse;

@Path(VssApiEndpoint.LIST_KEY_VERSIONS)
@Slf4j
public class ListKeyVersionsApi extends AbstractVssApi {

  @Inject
  public ListKeyVersionsApi(KVStore kvStore) {
    super(kvStore);
  }

  @POST
  @Produces(MediaType.APPLICATION_OCTET_STREAM)
  public Response execute(byte[] payload) {
    try {
      ListKeyVersionsRequest request = ListKeyVersionsRequest.parseFrom(payload);
      ListKeyVersionsResponse response = kvStore.listKeyVersions(request);
      return toResponse(response);
    } catch (Exception e) {
      log.error("Exception in ListKeyVersionsApi: ", e);
      return toErrorResponse(e);
    }
  }
}

'''
'''--- app/src/main/java/org/vss/api/PutObjectsApi.java ---
package org.vss.api;

import jakarta.inject.Inject;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import lombok.extern.slf4j.Slf4j;
import org.vss.KVStore;
import org.vss.PutObjectRequest;
import org.vss.PutObjectResponse;

@Path(VssApiEndpoint.PUT_OBJECTS)
@Slf4j
public class PutObjectsApi extends AbstractVssApi {

  @Inject
  public PutObjectsApi(KVStore kvStore) {
    super(kvStore);
  }

  @POST
  @Produces(MediaType.APPLICATION_OCTET_STREAM)
  public Response execute(byte[] payload) {
    try {
      PutObjectRequest putObjectRequest = PutObjectRequest.parseFrom(payload);
      PutObjectResponse response = kvStore.put(putObjectRequest);
      return toResponse(response);
    } catch (Exception e) {
      log.error("Exception in PutObjectsApi: ", e);
      return toErrorResponse(e);
    }
  }
}

'''
'''--- app/src/main/java/org/vss/api/VssApiEndpoint.java ---
package org.vss.api;

public class VssApiEndpoint {
  public static final String GET_OBJECT = "/getObject";
  public static final String PUT_OBJECTS = "/putObjects";
  public static final String DELETE_OBJECT = "/deleteObject";
  public static final String LIST_KEY_VERSIONS = "/listKeyVersions";
}

'''
'''--- app/src/main/java/org/vss/exception/ConflictException.java ---
package org.vss.exception;

public class ConflictException extends RuntimeException {
  public ConflictException(String message) {
    super(message);
  }
}

'''
'''--- app/src/main/java/org/vss/exception/NoSuchKeyException.java ---
package org.vss.exception;

public class NoSuchKeyException extends RuntimeException {
  public NoSuchKeyException(String message) {
    super(message);
  }
}

'''
'''--- app/src/main/java/org/vss/guice/BaseModule.java ---
package org.vss.guice;

import com.google.inject.AbstractModule;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.vss.KVStore;
import org.vss.impl.postgres.PostgresBackendImpl;

public class BaseModule extends AbstractModule {

  @Override
  protected void configure() {
    // Provide PostgresBackend as default implementation for KVStore.
    bind(KVStore.class).to(PostgresBackendImpl.class).in(Singleton.class);
  }

  @Provides
  @Singleton
  // Provide DSLContext which is to be used by PostgresBackend
  public DSLContext provideDSLContext() throws ClassNotFoundException {
    // Required to load postgres drivers in tomcat
    Class.forName("org.postgresql.Driver");
    return DSL.using(HikariCPDataSource.dataSource, SQLDialect.POSTGRES);
  }
}

// Provide Hikari Connection Pooling configuration for jdbc connection management.
// Hikari is high-performance connection pooling library which will maintain a set of connections
// to the database for us.
// When we provide `HikariCPDataSource` to DSLContext, jOOQ will internally `acquire` and `release`
// connections from pool.
// For HikariCP config, we provide some sane defaults, but they are meant to be changed and tuned.
// For specific parameter functionality, refer to HikariCP docs.
class HikariCPDataSource {

  private static HikariConfig config = new HikariConfig();
  public static HikariDataSource dataSource;

  static {
    try (InputStream input = HikariCPDataSource.class.getClassLoader()
        .getResourceAsStream("hikariJdbc.properties")) {
      Properties hikariJdbcProperties = new Properties();
      hikariJdbcProperties.load(input);

      config.setJdbcUrl(hikariJdbcProperties.getProperty("jdbc.url"));
      config.setUsername(hikariJdbcProperties.getProperty("jdbc.username"));
      config.setPassword(hikariJdbcProperties.getProperty("jdbc.password"));

      config.setMaximumPoolSize(
          Integer.parseInt(hikariJdbcProperties.getProperty("hikaricp.maxPoolSize")));
      config.setMinimumIdle(
          Integer.parseInt(hikariJdbcProperties.getProperty("hikaricp.minimumIdle")));
      config.setConnectionTimeout(
          Long.parseLong(hikariJdbcProperties.getProperty("hikaricp.connectionTimeout")));
      config.setIdleTimeout(
          Long.parseLong(hikariJdbcProperties.getProperty("hikaricp.idleTimeout")));
      config.setMaxLifetime(
          Long.parseLong(hikariJdbcProperties.getProperty("hikaricp.maxLifetime")));

      config.addDataSourceProperty("cachePrepStmts",
          hikariJdbcProperties.getProperty("hikaricp.cachePrepStmts"));
      config.addDataSourceProperty("prepStmtCacheSize",
          hikariJdbcProperties.getProperty("hikaricp.prepStmtCacheSize"));
      config.addDataSourceProperty("prepStmtCacheSqlLimit",
          hikariJdbcProperties.getProperty("hikaricp.prepStmtCacheSqlLimit"));

      dataSource = new HikariDataSource(config);
    } catch (IOException e) {
      throw new RuntimeException("Unable to read hikariJdbcProperties from resources");
    }
  }

  private HikariCPDataSource() {
  }
}

'''
'''--- app/src/main/java/org/vss/impl/postgres/PostgresBackendImpl.java ---
package org.vss.impl.postgres;

import com.google.inject.Inject;
import com.google.protobuf.ByteString;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Singleton;
import org.jooq.DSLContext;
import org.jooq.DeleteConditionStep;
import org.jooq.Insert;
import org.jooq.Query;
import org.jooq.Update;
import org.vss.DeleteObjectRequest;
import org.vss.DeleteObjectResponse;
import org.vss.GetObjectRequest;
import org.vss.GetObjectResponse;
import org.vss.KVStore;
import org.vss.KeyValue;
import org.vss.ListKeyVersionsRequest;
import org.vss.ListKeyVersionsResponse;
import org.vss.PutObjectRequest;
import org.vss.PutObjectResponse;
import org.vss.exception.ConflictException;
import org.vss.exception.NoSuchKeyException;
import org.vss.postgres.tables.records.VssDbRecord;

import static org.vss.postgres.tables.VssDb.VSS_DB;

@Singleton
public class PostgresBackendImpl implements KVStore {

  private static final int LIST_KEY_VERSIONS_MAX_PAGE_SIZE = 100;
  private static final KeyValue DEFAULT_GLOBAL_VERSION_KV = KeyValue.newBuilder()
      .setKey(GLOBAL_VERSION_KEY)
      .setValue(ByteString.EMPTY)
      .setVersion(0L)
      .build();
  private final DSLContext context;

  @Inject
  public PostgresBackendImpl(DSLContext context) {
    this.context = context;
  }

  @Override
  public GetObjectResponse get(GetObjectRequest request) {

    VssDbRecord vssDbRecord = context.selectFrom(VSS_DB)
        .where(VSS_DB.STORE_ID.eq(request.getStoreId())
            .and(VSS_DB.KEY.eq(request.getKey())))
        .fetchOne();

    final KeyValue keyValue;
    if (vssDbRecord == null) {
      if (GLOBAL_VERSION_KEY.equals(request.getKey())) {
        keyValue = DEFAULT_GLOBAL_VERSION_KV;
      } else {
        throw new NoSuchKeyException(
            "Specified key: " + request.getKey() + " in request does not exist.");
      }
    } else {
      keyValue = KeyValue.newBuilder()
          .setKey(vssDbRecord.getKey())
          .setValue(ByteString.copyFrom(vssDbRecord.getValue()))
          .setVersion(vssDbRecord.getVersion())
          .build();
    }

    return GetObjectResponse.newBuilder()
        .setValue(keyValue)
        .build();
  }

  @Override
  public PutObjectResponse put(PutObjectRequest request) {

    String storeId = request.getStoreId();

    List<VssDbRecord> vssPutRecords = new ArrayList<>(request.getTransactionItemsList().stream()
        .map(kv -> buildVssRecord(storeId, kv)).toList());

    List<VssDbRecord> vssDeleteRecords = new ArrayList<>(request.getDeleteItemsList().stream()
        .map(kv -> buildVssRecord(storeId, kv)).toList());

    if (request.hasGlobalVersion()) {
      VssDbRecord globalVersionRecord = buildVssRecord(storeId,
          KeyValue.newBuilder()
              .setKey(GLOBAL_VERSION_KEY)
              .setVersion(request.getGlobalVersion())
              .setValue(ByteString.EMPTY)
              .build());

      vssPutRecords.add(globalVersionRecord);
    }

    context.transaction((ctx) -> {
      DSLContext dsl = ctx.dsl();
      List<Query> batchQueries = new ArrayList<>();

      batchQueries.addAll(vssPutRecords.stream()
          .map(vssRecord -> buildPutObjectQuery(dsl, vssRecord)).toList());
      batchQueries.addAll(vssDeleteRecords.stream()
          .map(vssRecord -> buildDeleteObjectQuery(dsl, vssRecord)).toList());

      int[] batchResult = dsl.batch(batchQueries).execute();

      for (int numOfRowsUpdated : batchResult) {
        if (numOfRowsUpdated == 0) {
          throw new ConflictException(
              "Transaction could not be completed due to a possible conflict");
        }
      }
    });

    return PutObjectResponse.newBuilder().build();
  }

  private Query buildDeleteObjectQuery(DSLContext dsl, VssDbRecord vssRecord) {
    if (vssRecord.getVersion() == -1) {
      return buildNonConditionalDeleteQuery(dsl, vssRecord);
    } else {
      return buildConditionalDeleteQuery(dsl, vssRecord);
    }
  }

  private static DeleteConditionStep<VssDbRecord> buildNonConditionalDeleteQuery(DSLContext dsl,
      VssDbRecord vssRecord) {
    return dsl.deleteFrom(VSS_DB).where(VSS_DB.STORE_ID.eq(vssRecord.getStoreId())
        .and(VSS_DB.KEY.eq(vssRecord.getKey())));
  }

  private static DeleteConditionStep<VssDbRecord> buildConditionalDeleteQuery(DSLContext dsl,
      VssDbRecord vssRecord) {
    return dsl.deleteFrom(VSS_DB).where(VSS_DB.STORE_ID.eq(vssRecord.getStoreId())
        .and(VSS_DB.KEY.eq(vssRecord.getKey()))
        .and(VSS_DB.VERSION.eq(vssRecord.getVersion())));
  }

  private Query buildPutObjectQuery(DSLContext dsl, VssDbRecord vssRecord) {
    if (vssRecord.getVersion() == -1) {
      return buildNonConditionalUpsertRecordQuery(dsl, vssRecord);
    } else if (vssRecord.getVersion() == 0) {
      return buildConditionalInsertRecordQuery(dsl, vssRecord);
    } else {
      return buildConditionalUpdateRecordQuery(dsl, vssRecord);
    }
  }

  private Query buildNonConditionalUpsertRecordQuery(DSLContext dsl, VssDbRecord vssRecord) {
    return dsl.insertInto(VSS_DB)
        .values(vssRecord.getStoreId(), vssRecord.getKey(),
            vssRecord.getValue(), 1)
        .onConflict(VSS_DB.STORE_ID, VSS_DB.KEY)
        .doUpdate()
        .set(VSS_DB.VALUE, vssRecord.getValue())
        .set(VSS_DB.VERSION, 1L);
  }

  private Insert<VssDbRecord> buildConditionalInsertRecordQuery(DSLContext dsl,
      VssDbRecord vssRecord) {
    return dsl.insertInto(VSS_DB)
        .values(vssRecord.getStoreId(), vssRecord.getKey(),
            vssRecord.getValue(), 1)
        .onDuplicateKeyIgnore();
  }

  private Update<VssDbRecord> buildConditionalUpdateRecordQuery(DSLContext dsl, VssDbRecord vssRecord) {
    return dsl.update(VSS_DB)
        .set(Map.of(VSS_DB.VALUE, vssRecord.getValue(),
            VSS_DB.VERSION, vssRecord.getVersion() + 1))
        .where(VSS_DB.STORE_ID.eq(vssRecord.getStoreId())
            .and(VSS_DB.KEY.eq(vssRecord.getKey()))
            .and(VSS_DB.VERSION.eq(vssRecord.getVersion())));
  }

  private VssDbRecord buildVssRecord(String storeId, KeyValue kv) {
    return new VssDbRecord()
        .setStoreId(storeId)
        .setKey(kv.getKey())
        .setValue(kv.getValue().toByteArray())
        .setVersion(kv.getVersion());
  }

  @Override
  public DeleteObjectResponse delete(DeleteObjectRequest request) {
    String storeId = request.getStoreId();
    VssDbRecord vssDbRecord = buildVssRecord(storeId, request.getKeyValue());

    context.transaction((ctx) -> {
      DSLContext dsl = ctx.dsl();
      Query deleteObjectQuery = buildDeleteObjectQuery(dsl, vssDbRecord);
      dsl.execute(deleteObjectQuery);
    });

    return DeleteObjectResponse.newBuilder().build();
  }

  @Override
  public ListKeyVersionsResponse listKeyVersions(ListKeyVersionsRequest request) {
    String storeId = request.getStoreId();
    String keyPrefix = request.getKeyPrefix();
    String pageToken = request.getPageToken();
    int pageSize = request.hasPageSize() ? request.getPageSize() : Integer.MAX_VALUE;

    // Only fetch global_version for first page.
    // Fetch global_version before fetching any key_versions to ensure that,
    // all current key_versions were stored at global_version or later.
    Long globalVersion = null;
    if (!request.hasPageToken()) {
      GetObjectRequest getGlobalVersionRequest = GetObjectRequest.newBuilder()
          .setStoreId(storeId)
          .setKey(GLOBAL_VERSION_KEY)
          .build();
      globalVersion = get(getGlobalVersionRequest).getValue().getVersion();
    }

    List<VssDbRecord> vssDbRecords = context.select(VSS_DB.KEY, VSS_DB.VERSION).from(VSS_DB)
        .where(VSS_DB.STORE_ID.eq(storeId)
            .and(VSS_DB.KEY.startsWith(keyPrefix)))
        .orderBy(VSS_DB.KEY)
        .seek(pageToken)
        .limit(Math.min(pageSize, LIST_KEY_VERSIONS_MAX_PAGE_SIZE))
        .stream()
        .map(record -> record.into(VssDbRecord.class))
        .toList();

    List<KeyValue> keyVersions = vssDbRecords.stream()
        .filter(kv -> !GLOBAL_VERSION_KEY.equals(kv.getKey()))
        .map(kv -> KeyValue.newBuilder()
            .setKey(kv.getKey())
            .setVersion(kv.getVersion())
            .build())
        .toList();

    String nextPageToken = "";
    if (!keyVersions.isEmpty()) {
      nextPageToken = keyVersions.get(keyVersions.size() - 1).getKey();
    }

    ListKeyVersionsResponse.Builder responseBuilder = ListKeyVersionsResponse.newBuilder()
        .addAllKeyVersions(keyVersions)
        .setNextPageToken(nextPageToken);

    if (Objects.nonNull(globalVersion)) {
      responseBuilder.setGlobalVersion(globalVersion);
    }

    return responseBuilder.build();
  }
}

'''
'''--- app/src/main/java/org/vss/impl/postgres/sql/v0_create_vss_db.sql ---
CREATE TABLE vss_db (
    store_id character varying(120) NOT NULL CHECK (store_id <> ''),
    key character varying(600) NOT NULL,
    value bytea NULL,
    version bigint NOT NULL,
    PRIMARY KEY (store_id, key)
);

'''
'''--- app/src/test/java/org/vss/AbstractKVStoreIntegrationTest.java ---
package org.vss;

import com.google.protobuf.ByteString;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.junit.jupiter.api.Test;
import org.testcontainers.shaded.org.apache.commons.lang3.StringUtils;
import org.vss.exception.ConflictException;
import org.vss.exception.NoSuchKeyException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.lessThan;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;

public abstract class AbstractKVStoreIntegrationTest {

  private final String STORE_ID = "storeId";

  protected KVStore kvStore;

  @Test
  void putShouldSucceedWhenSingleObjectPutOperation() {
    // Conditional Put
    assertDoesNotThrow(() -> putObjects(0L, List.of(kv("k1", "k1v1", 0))));
    assertDoesNotThrow(() -> putObjects(1L, List.of(kv("k1", "k1v2", 1))));

    // NonConditional Put
    assertDoesNotThrow(() -> putObjects(2L, List.of(kv("k2", "k2v1", -1))));
    assertDoesNotThrow(() -> putObjects(3L, List.of(kv("k2", "k2v2", -1))));
    assertDoesNotThrow(() -> putObjects(4L, List.of(kv("k2", "k2v3", -1))));

    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k1v2"));

    response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k2v3"));

    assertThat(getObject(KVStore.GLOBAL_VERSION_KEY).getVersion(), is(5L));
  }

  @Test
  void putShouldSucceedWhenMultiObjectPutOperation() {
    final List<KeyValue> keyValues = List.of(kv("k1", "k1v1", 0),
        kv("k2", "k2v1", 0));

    assertDoesNotThrow(() -> putObjects(0L, keyValues));

    List<KeyValue> second_request = List.of(kv("k1", "k1v2", 1),
        kv("k2", "k2v2", 1));
    putObjects(1L, second_request);

    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k1v2"));

    response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k2v2"));

    assertThat(getObject(KVStore.GLOBAL_VERSION_KEY).getVersion(), is(2L));
  }

  @Test
  void putShouldFailWhenKeyVersionMismatched() {
    putObjects(0L, List.of(kv("k1", "k1v1", 0)));

    // global_version correctly changed but key-version conflict.
    assertThrows(ConflictException.class, () -> putObjects(1L, List.of(kv("k1", "k1v2", 0))));

    // Verify that values didn't change
    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k1v1"));

    assertThat(getObject(KVStore.GLOBAL_VERSION_KEY).getVersion(), is(1L));
  }

  @Test
  void putMultiObjectShouldFailWhenSingleKeyVersionMismatched() {
    final List<KeyValue> keyValues = List.of(kv("k1", "k1v1", 0),
        kv("k2", "k2v1", 0));

    assertDoesNotThrow(() -> putObjects(null, keyValues));

    List<KeyValue> second_request = List.of(kv("k1", "k1v2", 0),
        kv("k2", "k2v2", 1));

    assertThrows(ConflictException.class, () -> putObjects(null, second_request));

    // Verify that values didn't change
    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k1v1"));

    response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k2v1"));
  }

  @Test
  void putShouldFailWhenGlobalVersionMismatched() {
    putObjects(0L, List.of(kv("k1", "k1v1", 0)));

    // key-version correctly changed but global_version conflict.
    assertThrows(ConflictException.class, () -> putObjects(0L, List.of(kv("k1", "k1v2", 1))));

    //Verify that values didn't change
    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k1v1"));
  }

  @Test
  void putShouldSucceedWhenNoGlobalVersionIsGiven() {
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v1", 0))));
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v2", 1))));

    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k1v2"));

    assertThat(getObject(KVStore.GLOBAL_VERSION_KEY).getVersion(), is(0L));
  }

  @Test
  void putAndDeleteShouldSucceedAsAtomicTransaction() {
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v1", 0))));
    // Put and Delete succeeds
    assertDoesNotThrow(() -> putAndDeleteObjects(null, List.of(kv("k2", "k2v1", 0)), List.of(kv("k1", "", 1))));

    KeyValue response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k2v1"));

    assertThrows(NoSuchKeyException.class, () -> getObject("k1"));

    // Delete fails (and hence put as well) due to mismatched version for the deleted item.
    assertThrows(ConflictException.class, () -> putAndDeleteObjects(null, List.of(kv("k3", "k3v1", 0)), List.of(kv("k2", "", 3))));

    assertThrows(NoSuchKeyException.class, () -> getObject("k3"));
    assertDoesNotThrow(() -> getObject("k2"));

    // Put fails (and hence delete as well) due to mismatched version for the put item.
    assertThrows(ConflictException.class, () -> putAndDeleteObjects(null, List.of(kv("k3", "k3v1", 1)), List.of(kv("k2", "", 1))));

    assertThrows(NoSuchKeyException.class, () -> getObject("k3"));
    assertDoesNotThrow(() -> getObject("k2"));

    // Put and delete both fail due to mismatched global version.
    assertThrows(ConflictException.class, () -> putAndDeleteObjects(2L, List.of(kv("k3", "k3v1", 0)), List.of(kv("k2", "", 1))));

    assertThrows(NoSuchKeyException.class, () -> getObject("k3"));
    assertDoesNotThrow(() -> getObject("k2"));

    assertThat(getObject(KVStore.GLOBAL_VERSION_KEY).getVersion(), is(0L));
  }

  @Test
  void deleteShouldSucceedWhenItemExists() {
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v1", 0))));
    // Conditional Delete
    assertDoesNotThrow(() -> deleteObject(kv("k1", "", 1)));

    assertThrows(NoSuchKeyException.class, () -> getObject("k1"));

    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v1", 0))));
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v2", 1))));
    // NonConditional Delete
    assertDoesNotThrow(() -> deleteObject(kv("k1", "", -1)));

    assertThrows(NoSuchKeyException.class, () -> getObject("k1"));
  }

  @Test
  void deleteShouldSucceedWhenItemDoesNotExist() {
    assertDoesNotThrow(() -> deleteObject(kv("non_existent_key", "", 0)));
  }

  @Test
  void deleteShouldBeIdempotent() {
    assertDoesNotThrow(() -> putObjects(null, List.of(kv("k1", "k1v1", 0))));
    assertDoesNotThrow(() -> deleteObject(kv("k1", "", 1)));
    assertDoesNotThrow(() -> deleteObject(kv("k1", "", 1)));

    assertThrows(NoSuchKeyException.class, () -> getObject("k1"));
  }

  @Test
  void getShouldThrowNoSuchKeyExceptionWhenKeyDoesNotExist() {
    assertThrows(NoSuchKeyException.class, () -> getObject("non_existent_key"));
  }

  @Test
  void getShouldReturnCorrectValueWhenKeyExists() {

    putObjects(0L, List.of(kv("k1", "k1v1", 0)));

    KeyValue response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k1v1"));

    List<KeyValue> keyValues = List.of(kv("k1", "k1v2", 1),
        kv("k2", "k2v1", 0));
    putObjects(1L, keyValues);

    response = getObject("k1");
    assertThat(response.getKey(), is("k1"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k1v2"));

    response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k2v1"));

    keyValues = List.of(kv("k2", "k2v2", 1),
        kv("k3", "k3v1", 0));
    putObjects(2L, keyValues);

    response = getObject("k2");
    assertThat(response.getKey(), is("k2"));
    assertThat(response.getVersion(), is(2L));
    assertThat(response.getValue().toStringUtf8(), is("k2v2"));

    response = getObject("k3");
    assertThat(response.getKey(), is("k3"));
    assertThat(response.getVersion(), is(1L));
    assertThat(response.getValue().toStringUtf8(), is("k3v1"));
  }

  @Test
  void listShouldReturnPaginatedResponse() {

    int totalKvObjects = 1000;
    for (int i = 0; i < totalKvObjects; i++) {
      putObjects((long) i, List.of(kv("k" + i, "k1v1", 0)));
    }
    // Overwrite k1 once and k2 twice.
    putObjects(1000L, List.of(kv("k1", "k1v2", 1)));
    putObjects(1001L, List.of(kv("k2", "k2v2", 1)));
    putObjects(1002L, List.of(kv("k2", "k2v3", 2)));

    ListKeyVersionsResponse previousPage = null;
    List<KeyValue> allKeyVersions = new ArrayList<>();

    while (previousPage == null || !previousPage.getKeyVersionsList().isEmpty()) {
      ListKeyVersionsResponse currentPage;

      if (previousPage == null) {
        currentPage = list(null, null, null);

        // Ensure first page contains correct global version
        assertThat(currentPage.getGlobalVersion(), is(1003L));
      } else {
        String nextPageToken = previousPage.getNextPageToken();
        currentPage = list(nextPageToken, null, null);

        // Ensure pages after first page dont contain global version.
        assertThat(currentPage.hasGlobalVersion(), is(false));
      }

      allKeyVersions.addAll(currentPage.getKeyVersionsList());
      previousPage = currentPage;
    }

    // Ensure page results don't intersect/duplicate and return complete view.
    Set<String> uniqueKeys = allKeyVersions.stream().map(KeyValue::getKey).distinct()
        .collect(Collectors.toSet());
    assertThat(uniqueKeys.size(), is(totalKvObjects));

    // Ensure that we don't return "vss_global_version" as part of keys.
    assertFalse(uniqueKeys.contains(KVStore.GLOBAL_VERSION_KEY));

    // Ensure correct key version for k1
    KeyValue k1_response =
        allKeyVersions.stream().filter(kv -> "k1".equals(kv.getKey())).findFirst().get();
    assertThat(k1_response.getKey(), is("k1"));
    assertThat(k1_response.getVersion(), is(2L));
    assertThat(k1_response.getValue().toStringUtf8(), is(""));

    // Ensure correct key version for k2
    KeyValue k2_response =
        allKeyVersions.stream().filter(kv -> "k2".equals(kv.getKey())).findFirst().get();
    assertThat(k2_response.getKey(), is("k2"));
    assertThat(k2_response.getVersion(), is(3L));
    assertThat(k2_response.getValue().toStringUtf8(), is(""));
  }

  @Test
  void listShouldHonourPageSizeAndKeyPrefixIfProvided() {
    int totalKvObjects = 20;
    int pageSize = 5;
    for (int i = 0; i < totalKvObjects; i++) {
      putObjects((long) i, List.of(kv(i + "k", "k1v1", 0)));
    }

    ListKeyVersionsResponse previousPage = null;
    List<KeyValue> allKeyVersions = new ArrayList<>();
    String keyPrefix = "1";

    while (previousPage == null || !previousPage.getKeyVersionsList().isEmpty()) {
      ListKeyVersionsResponse currentPage;

      if (previousPage == null) {
        currentPage = list(null, pageSize, keyPrefix);
      } else {
        String nextPageToken = previousPage.getNextPageToken();
        currentPage = list(nextPageToken, pageSize, keyPrefix);
      }

      allKeyVersions.addAll(currentPage.getKeyVersionsList());

      // Each page.size() is less than or equal to pageSize in request.
      assertThat(currentPage.getKeyVersionsList().size(), lessThanOrEqualTo(pageSize));
      previousPage = currentPage;
    }

    Set<String> uniqueKeys =
        allKeyVersions.stream().map(KeyValue::getKey).collect(Collectors.toSet());

    // Returns keys only with provided keyPrefix
    assertThat(uniqueKeys.size(), is(11));
    assertThat(uniqueKeys,
        is(Set.of("1k", "10k", "11k", "12k", "13k", "14k", "15k", "16k", "17k", "18k", "19k")));
  }

  @Test
  void listShouldReturnZeroGlobalVersionWhenGlobalVersioningNotEnabled() {
    int totalKvObjects = 1000;
    for (int i = 0; i < totalKvObjects; i++) {
      putObjects(null, List.of(kv("k" + i, "k1v1", 0)));
    }

    ListKeyVersionsResponse previousPage = null;
    List<KeyValue> allKeyVersions = new ArrayList<>();

    while (previousPage == null || !previousPage.getKeyVersionsList().isEmpty()) {
      ListKeyVersionsResponse currentPage;

      if (previousPage == null) {
        currentPage = list(null, null, null);

        // Ensure first page returns global version as ZERO
        assertThat(currentPage.getGlobalVersion(), is(0L));
      } else {
        String nextPageToken = previousPage.getNextPageToken();
        currentPage = list(nextPageToken, null, null);

        // Ensure pages after first page do not contain global version.
        assertThat(currentPage.hasGlobalVersion(), is(false));
      }

      allKeyVersions.addAll(currentPage.getKeyVersionsList());
      previousPage = currentPage;
    }
    // Returns complete view.
    Set<String> uniqueKeys = allKeyVersions.stream().map(KeyValue::getKey).distinct()
        .collect(Collectors.toSet());
    assertThat(uniqueKeys.size(), is(totalKvObjects));

    // Ensure that we don't return "vss_global_version" as part of keys.
    assertFalse(uniqueKeys.contains(KVStore.GLOBAL_VERSION_KEY));
  }

  @Test
  void listShouldLimitMaxPageSize() {

    int totalKvObjects = 10000;

    // Each implementation is free to choose its own max_page_size but there should be a reasonable max
    // keeping scalability and performance in mind.
    // Revisit this test case if some implementation wants to support higher page size.
    int vssArbitraryPageSizeMax = 3000;

    for (int i = 0; i < totalKvObjects; i++) {
      putObjects((long) i, List.of(kv("k" + i, "k1v1", 0)));
    }

    ListKeyVersionsResponse previousPage = null;
    List<KeyValue> allKeyVersions = new ArrayList<>();

    while (previousPage == null || !previousPage.getKeyVersionsList().isEmpty()) {
      ListKeyVersionsResponse currentPage;

      if (previousPage == null) {
        currentPage = list(null, null, null);
      } else {
        String nextPageToken = previousPage.getNextPageToken();
        currentPage = list(nextPageToken, null, null);
      }

      allKeyVersions.addAll(currentPage.getKeyVersionsList());

      // Each page.size() is less than MAX_PAGE_SIZE
      assertThat(currentPage.getKeyVersionsList().size(), lessThan(vssArbitraryPageSizeMax));
      previousPage = currentPage;
    }

    assertThat(allKeyVersions.size(), is(totalKvObjects));
  }

  private KeyValue getObject(String key) {
    GetObjectRequest getRequest = GetObjectRequest.newBuilder()
        .setStoreId(STORE_ID)
        .setKey(key)
        .build();
    return this.kvStore.get(getRequest).getValue();
  }

  private void putObjects(@Nullable Long globalVersion, List<KeyValue> keyValues) {
    PutObjectRequest.Builder putObjectRequestBuilder = PutObjectRequest.newBuilder()
        .setStoreId(STORE_ID)
        .addAllTransactionItems(keyValues);

    if (Objects.nonNull(globalVersion)) {
      putObjectRequestBuilder.setGlobalVersion(globalVersion);
    }

    this.kvStore.put(putObjectRequestBuilder.build());
  }

  private void putAndDeleteObjects(@Nullable Long globalVersion, List<KeyValue> putKeyValues, List<KeyValue> deleteKeyValues) {
    PutObjectRequest.Builder putObjectRequestBuilder = PutObjectRequest.newBuilder()
        .setStoreId(STORE_ID)
        .addAllTransactionItems(putKeyValues)
        .addAllDeleteItems(deleteKeyValues);

    if (Objects.nonNull(globalVersion)) {
      putObjectRequestBuilder.setGlobalVersion(globalVersion);
    }

    this.kvStore.put(putObjectRequestBuilder.build());
  }

  private void deleteObject(KeyValue keyValue) {
    DeleteObjectRequest request = DeleteObjectRequest.newBuilder()
        .setStoreId(STORE_ID).setKeyValue(keyValue).build();
    this.kvStore.delete(request);
  }

  private ListKeyVersionsResponse list(@Nullable String nextPageToken, @Nullable Integer pageSize,
      @Nullable String keyPrefix) {
    ListKeyVersionsRequest.Builder listRequestBuilder = ListKeyVersionsRequest.newBuilder()
        .setStoreId(STORE_ID);

    if (StringUtils.isNotBlank(nextPageToken)) {
      listRequestBuilder.setPageToken(nextPageToken);
    }
    if (pageSize != null) {
      listRequestBuilder.setPageSize(pageSize);
    }
    if (StringUtils.isNotBlank(keyPrefix)) {
      listRequestBuilder.setKeyPrefix(keyPrefix);
    }

    return this.kvStore.listKeyVersions(listRequestBuilder.build());
  }

  private KeyValue kv(String key, String value, int version) {
    return KeyValue.newBuilder().setKey(key).setVersion(version).setValue(
        ByteString.copyFrom(value.getBytes(
            StandardCharsets.UTF_8))).build();
  }
}

'''
'''--- app/src/test/java/org/vss/api/DeleteObjectApiTest.java ---
package org.vss.api;

import com.google.protobuf.ByteString;
import jakarta.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.vss.DeleteObjectRequest;
import org.vss.DeleteObjectResponse;
import org.vss.ErrorCode;
import org.vss.ErrorResponse;
import org.vss.KVStore;
import org.vss.KeyValue;
import org.vss.exception.ConflictException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class DeleteObjectApiTest {
  private DeleteObjectApi deleteObjectApi;
  private KVStore mockKVStore;

  private static String TEST_STORE_ID = "storeId";
  private static String TEST_KEY = "key";
  private static KeyValue TEST_KV = KeyValue.newBuilder().setKey(TEST_KEY).setValue(
      ByteString.copyFrom("test_value", StandardCharsets.UTF_8)).build();

  @BeforeEach
  void setUp() {
    mockKVStore = mock(KVStore.class);
    deleteObjectApi = new DeleteObjectApi(mockKVStore);
  }

  @Test
  void execute_ValidPayload_ReturnsResponse() {
    DeleteObjectRequest expectedRequest =
        DeleteObjectRequest.newBuilder().setStoreId(TEST_STORE_ID).setKeyValue(
            KeyValue.newBuilder().setKey(TEST_KEY).setVersion(0)
        ).build();
    byte[] payload = expectedRequest.toByteArray();
    DeleteObjectResponse mockResponse = DeleteObjectResponse.newBuilder().build();
    when(mockKVStore.delete(expectedRequest)).thenReturn(mockResponse);

    Response actualResponse = deleteObjectApi.execute(payload);

    assertThat(actualResponse.getStatus(), is(Response.Status.OK.getStatusCode()));
    assertThat(actualResponse.getEntity(), is(mockResponse.toByteArray()));
    verify(mockKVStore).delete(expectedRequest);
  }

  @ParameterizedTest
  @MethodSource("provideErrorTestCases")
  void execute_InvalidPayload_ReturnsErrorResponse(Exception exception,
      ErrorCode errorCode) {
    DeleteObjectRequest expectedRequest =
        DeleteObjectRequest.newBuilder().setStoreId(TEST_STORE_ID).setKeyValue(
            KeyValue.newBuilder().setKey(TEST_KEY).setVersion(0)
        ).build();
    byte[] payload = expectedRequest.toByteArray();
    when(mockKVStore.delete(any())).thenThrow(exception);

    Response response = deleteObjectApi.execute(payload);

    ErrorResponse expectedErrorResponse = ErrorResponse.newBuilder()
        .setErrorCode(errorCode)
        .setMessage("")
        .build();
    assertThat(response.getEntity(), is(expectedErrorResponse.toByteArray()));
    assertThat(response.getStatus(), is(expectedErrorResponse.getErrorCode().getNumber()));
    verify(mockKVStore).delete(expectedRequest);
  }

  private static Stream<Arguments> provideErrorTestCases() {
    return Stream.of(
        Arguments.of(new ConflictException(""), ErrorCode.CONFLICT_EXCEPTION),
        Arguments.of(new IllegalArgumentException(""), ErrorCode.INVALID_REQUEST_EXCEPTION),
        Arguments.of(new RuntimeException(""), ErrorCode.INTERNAL_SERVER_EXCEPTION)
    );
  }
}

'''
'''--- app/src/test/java/org/vss/api/GetObjectApiTest.java ---
package org.vss.api;

import com.google.protobuf.ByteString;
import jakarta.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.vss.ErrorCode;
import org.vss.ErrorResponse;
import org.vss.GetObjectRequest;
import org.vss.GetObjectResponse;
import org.vss.KVStore;
import org.vss.KeyValue;
import org.vss.exception.ConflictException;
import org.vss.exception.NoSuchKeyException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class GetObjectApiTest {
  private GetObjectApi getObjectApi;
  private KVStore mockKVStore;

  private static String TEST_STORE_ID = "storeId";
  private static String TEST_KEY = "key";
  private static KeyValue TEST_KV = KeyValue.newBuilder().setKey(TEST_KEY).setValue(
      ByteString.copyFrom("test_value", StandardCharsets.UTF_8)).build();

  @BeforeEach
  void setUp() {
    mockKVStore = mock(KVStore.class);
    getObjectApi = new GetObjectApi(mockKVStore);
  }

  @Test
  void execute_ValidPayload_ReturnsResponse() {
    GetObjectRequest expectedRequest =
        GetObjectRequest.newBuilder().setStoreId(TEST_STORE_ID).setKey(TEST_KEY).build();
    byte[] payload = expectedRequest.toByteArray();
    GetObjectResponse mockResponse = GetObjectResponse.newBuilder().setValue(TEST_KV).build();
    when(mockKVStore.get(expectedRequest)).thenReturn(mockResponse);

    Response actualResponse = getObjectApi.execute(payload);

    assertThat(actualResponse.getStatus(), is(Response.Status.OK.getStatusCode()));
    assertThat(actualResponse.getEntity(), is(mockResponse.toByteArray()));
    verify(mockKVStore).get(expectedRequest);
  }

  @ParameterizedTest
  @MethodSource("provideErrorTestCases")
  void execute_InvalidPayload_ReturnsErrorResponse(Exception exception,
      ErrorCode errorCode) {
    GetObjectRequest expectedRequest = GetObjectRequest.newBuilder()
        .setStoreId(TEST_STORE_ID)
        .setKey(TEST_KEY)
        .build();
    byte[] payload = expectedRequest.toByteArray();
    when(mockKVStore.get(any())).thenThrow(exception);

    Response response = getObjectApi.execute(payload);

    ErrorResponse expectedErrorResponse = ErrorResponse.newBuilder()
        .setErrorCode(errorCode)
        .setMessage("")
        .build();
    assertThat(response.getEntity(), is(expectedErrorResponse.toByteArray()));
    assertThat(response.getStatus(), is(expectedErrorResponse.getErrorCode().getNumber()));
    verify(mockKVStore).get(expectedRequest);
  }

  private static Stream<Arguments> provideErrorTestCases() {
    return Stream.of(
        Arguments.of(new ConflictException(""), ErrorCode.CONFLICT_EXCEPTION),
        Arguments.of(new IllegalArgumentException(""), ErrorCode.INVALID_REQUEST_EXCEPTION),
        Arguments.of(new NoSuchKeyException(""), ErrorCode.NO_SUCH_KEY_EXCEPTION),
        Arguments.of(new RuntimeException(""), ErrorCode.INTERNAL_SERVER_EXCEPTION)
    );
  }
}

'''
'''--- app/src/test/java/org/vss/api/ListKeyVersionsApiTest.java ---
package org.vss.api;

import com.google.protobuf.ByteString;
import jakarta.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.vss.ErrorCode;
import org.vss.ErrorResponse;
import org.vss.KVStore;
import org.vss.KeyValue;
import org.vss.ListKeyVersionsRequest;
import org.vss.ListKeyVersionsResponse;
import org.vss.exception.ConflictException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class ListKeyVersionsApiTest {
  private ListKeyVersionsApi listKeyVersionsApi;
  private KVStore mockKVStore;

  private static String TEST_STORE_ID = "storeId";
  private static String TEST_KEY = "key";
  private static KeyValue TEST_KV = KeyValue.newBuilder().setKey(TEST_KEY).setValue(
      ByteString.copyFrom("test_value", StandardCharsets.UTF_8)).build();

  @BeforeEach
  void setUp() {
    mockKVStore = mock(KVStore.class);
    listKeyVersionsApi = new ListKeyVersionsApi(mockKVStore);
  }

  @Test
  void execute_ValidPayload_ReturnsResponse() {
    ListKeyVersionsRequest expectedRequest =
        ListKeyVersionsRequest.newBuilder()
            .setStoreId(TEST_STORE_ID)
            .setKeyPrefix(TEST_KEY)
            .build();
    byte[] payload = expectedRequest.toByteArray();
    ListKeyVersionsResponse mockResponse = ListKeyVersionsResponse.newBuilder().addAllKeyVersions(
        List.of(TEST_KV)).build();
    when(mockKVStore.listKeyVersions(expectedRequest)).thenReturn(mockResponse);

    Response actualResponse = listKeyVersionsApi.execute(payload);

    assertThat(actualResponse.getStatus(), is(Response.Status.OK.getStatusCode()));
    assertThat(actualResponse.getEntity(), is(mockResponse.toByteArray()));
    verify(mockKVStore).listKeyVersions(expectedRequest);
  }

  @ParameterizedTest
  @MethodSource("provideErrorTestCases")
  void execute_InvalidPayload_ReturnsErrorResponse(Exception exception,
      ErrorCode errorCode) {
    ListKeyVersionsRequest expectedRequest =
        ListKeyVersionsRequest.newBuilder()
            .setStoreId(TEST_STORE_ID)
            .setKeyPrefix(TEST_KEY)
            .build();
    byte[] payload = expectedRequest.toByteArray();
    when(mockKVStore.listKeyVersions(any())).thenThrow(exception);

    Response response = listKeyVersionsApi.execute(payload);

    ErrorResponse expectedErrorResponse = ErrorResponse.newBuilder()
        .setErrorCode(errorCode)
        .setMessage("")
        .build();
    assertThat(response.getEntity(), is(expectedErrorResponse.toByteArray()));
    assertThat(response.getStatus(), is(expectedErrorResponse.getErrorCode().getNumber()));
    verify(mockKVStore).listKeyVersions(expectedRequest);
  }

  private static Stream<Arguments> provideErrorTestCases() {
    return Stream.of(
        Arguments.of(new ConflictException(""), ErrorCode.CONFLICT_EXCEPTION),
        Arguments.of(new IllegalArgumentException(""), ErrorCode.INVALID_REQUEST_EXCEPTION),
        Arguments.of(new RuntimeException(""), ErrorCode.INTERNAL_SERVER_EXCEPTION)
    );
  }
}

'''
'''--- app/src/test/java/org/vss/api/PutObjectsApiTest.java ---
package org.vss.api;

import com.google.protobuf.ByteString;
import jakarta.ws.rs.core.Response;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.vss.ErrorCode;
import org.vss.ErrorResponse;
import org.vss.KVStore;
import org.vss.KeyValue;
import org.vss.PutObjectRequest;
import org.vss.PutObjectResponse;
import org.vss.exception.ConflictException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class PutObjectsApiTest {
  private PutObjectsApi putObjectsApi;
  private KVStore mockKVStore;

  private static String TEST_STORE_ID = "storeId";
  private static String TEST_KEY = "key";
  private static KeyValue TEST_KV = KeyValue.newBuilder().setKey(TEST_KEY).setValue(
      ByteString.copyFrom("test_value", StandardCharsets.UTF_8)).build();

  @BeforeEach
  void setUp() {
    mockKVStore = mock(KVStore.class);
    putObjectsApi = new PutObjectsApi(mockKVStore);
  }

  @Test
  void execute_ValidPayload_ReturnsResponse() {
    PutObjectRequest expectedRequest =
        PutObjectRequest.newBuilder()
            .setStoreId(TEST_STORE_ID)
            .addAllTransactionItems(List.of(TEST_KV))
            .build();
    byte[] payload = expectedRequest.toByteArray();
    PutObjectResponse mockResponse = PutObjectResponse.newBuilder().build();
    when(mockKVStore.put(expectedRequest)).thenReturn(mockResponse);

    Response actualResponse = putObjectsApi.execute(payload);

    assertThat(actualResponse.getStatus(), is(Response.Status.OK.getStatusCode()));
    assertThat(actualResponse.getEntity(), is(mockResponse.toByteArray()));
    verify(mockKVStore).put(expectedRequest);
  }

  @ParameterizedTest
  @MethodSource("provideErrorTestCases")
  void execute_InvalidPayload_ReturnsErrorResponse(Exception exception,
      ErrorCode errorCode) {
    PutObjectRequest expectedRequest =
        PutObjectRequest.newBuilder()
            .setStoreId(TEST_STORE_ID)
            .addAllTransactionItems(List.of(TEST_KV))
            .build();
    byte[] payload = expectedRequest.toByteArray();
    when(mockKVStore.put(any())).thenThrow(exception);

    Response response = putObjectsApi.execute(payload);

    ErrorResponse expectedErrorResponse = ErrorResponse.newBuilder()
        .setErrorCode(errorCode)
        .setMessage("")
        .build();
    assertThat(response.getEntity(), is(expectedErrorResponse.toByteArray()));
    assertThat(response.getStatus(), is(expectedErrorResponse.getErrorCode().getNumber()));
    verify(mockKVStore).put(expectedRequest);
  }

  private static Stream<Arguments> provideErrorTestCases() {
    return Stream.of(
        Arguments.of(new ConflictException(""), ErrorCode.CONFLICT_EXCEPTION),
        Arguments.of(new IllegalArgumentException(""), ErrorCode.INVALID_REQUEST_EXCEPTION),
        Arguments.of(new RuntimeException(""), ErrorCode.INTERNAL_SERVER_EXCEPTION)
    );
  }
}

'''
'''--- app/src/test/java/org/vss/impl/postgres/PostgresBackendImplIntegrationTest.java ---
package org.vss.impl.postgres;

import java.sql.Connection;
import java.sql.DriverManager;
import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.vss.AbstractKVStoreIntegrationTest;

@Testcontainers
public class PostgresBackendImplIntegrationTest extends AbstractKVStoreIntegrationTest {

  private final String POSTGRES_TEST_CONTAINER_DOCKER_IMAGE = "postgres:15";

  @Container
  private final PostgreSQLContainer postgreSQLContainer =
      new PostgreSQLContainer(POSTGRES_TEST_CONTAINER_DOCKER_IMAGE)
          .withDatabaseName("postgres")
          .withUsername("postgres")
          .withPassword("postgres");

  private Connection connection;

  @BeforeEach
  void initEach() throws Exception {

    // This is required to get postgres driver in classpath before we attempt to fetch a connection
    Class.forName("org.postgresql.Driver");
    this.connection = DriverManager.getConnection(postgreSQLContainer.getJdbcUrl(),
        postgreSQLContainer.getUsername(), postgreSQLContainer.getPassword());
    DSLContext dslContext = DSL.using(connection, SQLDialect.POSTGRES);

    this.kvStore = new PostgresBackendImpl(dslContext);

    createTable(dslContext);
  }

  @AfterEach
  void destroy() throws Exception {
    this.connection.close();
  }

  private void createTable(DSLContext dslContext) {
    dslContext.execute("CREATE TABLE vss_db ("
        + "store_id character varying(120) NOT NULL CHECK (store_id <> ''),"
        + "key character varying(120) NOT NULL,"
        + "value bytea NULL,"
        + "version bigint NOT NULL,"
        + "PRIMARY KEY (store_id, key)"
        + ");");
  }
}

'''