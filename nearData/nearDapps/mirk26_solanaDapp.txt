*GitHub Repository "mirk26/solanaDapp"*

'''--- README.md ---
# solanaDapp

## Figment Pages for Solana Dev Guide

/api/solana/XYZ.ts

* connect.ts - connection for JSON RPC nodes
* keypair.ts - generate account- pub key and priv key for creating account on solana chain
* fund.ts - get funds airdropped from dev net for starting account activities
* balance.ts -  get balance for public address 
* transfer.ts  - [connection,transaction,signers] transaction => fromPUB, toPUB, lamports
* checkProgram.ts - to check if program/contract is deployed - Input ProgramID
* greeter.ts - greeter account created for deployed program/contract 
* getGreetings.ts - read data from greeter account created for program
* callGreetings.ts -  write data greeter account for deployed contract/program

'''
'''--- pages/api/avalanche/account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { getAvalancheClient } from '@avalanche/lib'

type ReponseT = {
	secret: string
	address: string
}
export default function account(
	_req: NextApiRequest,
	res: NextApiResponse<ReponseT>
) {
	const client = getAvalancheClient();
	const chain = client.XChain(); 
	const keyChain = chain.keyChain(); 
	const keypair = keyChain.undefined; // There is a useful method to use here
	const secret = undefined;
	const address = undefined;
	res.status(200).json({
		secret, address
	})
}

'''
'''--- pages/api/avalanche/balance.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { getAvalancheClient } from '@avalanche/lib'

type TransactionT = {
    txID: string,
    outputIndex: number
}
type BalanceT = {
    balance: string,
    utxoIDs: TransactionT[]
}
export default async function balance(
	req: NextApiRequest,
	res: NextApiResponse<string>
) {
    try {
        const { address } = req.body;
        const client = getAvalancheClient();
        const chain = client.XChain(); 
        const balance = undefined; 
        res.status(200).json(balance.balance);
      } catch(error) {
        console.error(error)
        res.status(500).json('failed to get balance')
    } 
}

'''
'''--- pages/api/avalanche/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { getAvalancheClient } from "@avalanche/lib";

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const client = undefined;
    const info = undefined;
    const version = undefined;
    res.status(200).json(version);
  } catch (error) {
    console.log(error);
    res.status(500).json("Error connecting to Avalanche");
  }
}

'''
'''--- pages/api/avalanche/export.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { getAvalancheClient } from '@avalanche/lib'
import { BN } from "avalanche";

export default async function (
    req: NextApiRequest,
	res: NextApiResponse<string>
    ) {
    try {
        const { secret } = req.body;
        const client = getAvalancheClient();
    
        // Total amount we're transferring = 0.05 AVAX
        const amount = "50000000";
    
        // Taking inspiration for xChain do the same for cChain
        const [ xChain   , cChain    ] = [ client.XChain()            , undefined ];
        const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , undefined ];
        const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), undefined ];
        const [ xAddress , cAddress  ] = [ xKeypair.getAddressString(), undefined ];
    
        // Fetch UTXOs (unspent transaction outputs)
        const { utxos } = await xChain.getUTXOs(xAddress)
    
        // Get the real ID for the cChain
        const chainId = undefined;
    
        // Prepare the export transaction from X -> C chain
        const exportTx = await xChain.buildExportTx(undefined)
    
        // Sign and send the transaction
        const hash = await xChain.issueTx(exportTx.sign(xKeychain))
    
        res.status(200).json(hash)
        } catch(error) {
        console.error(error)
        res.status(500).json('Export to C chain failed')
    } 
}

'''
'''--- pages/api/avalanche/import.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { getAvalancheClient } from '@avalanche/lib'
import { BinTools } from "avalanche";
import { Address } from 'ethereumjs-util'

export default async function (
	req: NextApiRequest,
	res: NextApiResponse<string>
) {
    try {
        const { secret } = req.body;
        const client = getAvalancheClient();
    
        // Total amount we're transferring = 0.05 AVAX
        const amount = "50000000";
    
        // Taking inspiration for xChain do the same for cChain
        const [ xChain   , cChain    ] = [ client.XChain()            , undefined ];
        const [ xKeychain, cKeychain ] = [ xChain.keyChain()          , undefined ];
        const [ xKeypair , cKeypair  ] = [ xKeychain.importKey(secret), undefined ];
        const [ xAddress , cAddress  ] = [ xKeypair.getAddressString(), undefined ];
    
        // Fetch UTXOs (unspent transaction outputs)
        const { utxos } = await xChain.getUTXOs(xAddress)
    
        // Get the real ID for the cChain
        const chainId = undefined;
    
        // Prepare the export transaction from X -> C chain
        const exportTx = await xChain.buildExportTx(undefined)
    
        // Sign and send the transaction
        const hash = await xChain.issueTx(exportTx.sign(xKeychain))
    
        res.status(200).json(hash)
      } catch(error) {
        console.error(error)
        res.status(500).json('Import from X chain failed')
    } 
}

'''
'''--- pages/api/avalanche/transfer.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { getAvalancheClient } from '@avalanche/lib'
import { BinTools, BN } from "avalanche";

export default async function transfer(
	req: NextApiRequest,
	res: NextApiResponse<string>
) {
    try {
        const { secret, amount, recipient, address } = req.body
        const client = getAvalancheClient()
        const chain = client.XChain(); 
		const keychain = chain.keyChain()
		// Using keychain, load the private key to sign transactions
		undefined;

		// Fetch UTXOs (unspent transaction outputs)
		const { utxos } = undefined;

		// Determine the real asset ID from its symbol/alias
		const binTools = BinTools.getInstance();
		const assetInfo = await chain.getAssetDescription("AVAX");
		const assetID = binTools.cb58Encode(assetInfo.assetID);

		// Create a new transaction
		const transaction = await chain.buildBaseTx(undefined);

		// Sign the transaction and send it to the network
		undefined;
		undefined;

		res.status(200).json(hash);
	} catch(error) {
        console.error(error)
        res.status(500).json('failed to get balance')
    } 
}

'''
'''--- pages/api/celo/account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';

type ResponseT = {
    address: string
    secret: string
}
export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
    try {
        const url = getSafeUrl();
        const kit = newKit(url);
        const account = undefined;
        const address = undefined;
        const secret = undefined;
    
        res.status(200).json({
            address,
            secret
        })
    }  catch(error) {
        console.error(error)
        res.status(500).json('Account creation failed')
    }
}

'''
'''--- pages/api/celo/balance.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';

type ResponseT = {
    attoCELO: string
    attoUSD: string
}
export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
    try {
        const { address } = req.body;
        const url = getSafeUrl();
        const kit = newKit(url);
    
        const goldtoken = undefined;
        const celoBalance = undefined;
        
        const stabletoken = undefined;
        const cUSDBalance = undefined;
    
    
        res.status(200).json({ 
            attoCELO: celoBalance.toString(), 
            attoUSD: cUSDBalance.toString() 
        });
      } catch(error) {
        console.error(error)
        res.status(500).json('Querying of balance failed')
    }
}

'''
'''--- pages/api/celo/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { getSafeUrl } from "@ccelo/lib";
import { newKit } from "@celo/contractkit";

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = getSafeUrl();
    const kit = undefined;
    const version = undefined;
    res.status(200).json(version.slice(5, 11));
  }  catch (error) {
    console.error(error);
    res.status(500).json("connection to Celo failed");
  }
}

'''
'''--- pages/api/celo/deploy.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

type ResponseT = {
    address: string
    hash: string
}

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
    try {
        const { secret, address } = req.body;
        const url = getSafeUrl();
        const kit = newKit(url);
    
        kit.addAccount(secret);
    
        // TODO: Create a transaction to deploy the contract
    
        const receipt = await tx.waitReceipt();
    
        res.status(200).json({
            address: receipt?.contractAddress as string,
            hash: receipt.transactionHash
        });
      }catch(error) {
        console.error(error)
        res.status(500).json('Deployment of contract failed')
    }
}

'''
'''--- pages/api/celo/getter.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { contract } = req.body;
        const url = getSafeUrl();
        const kit = newKit(url);
        
        // Create a new contract instance with the HelloWorld contract info
        const instance = undefined;
        // Call the getName function of the on-chain contract
        const name = undefined;
    
        res.status(200).json(name);
      } catch(error) {
        console.error(error)
        res.status(500).json('read message from contract failed')
    }
}

'''
'''--- pages/api/celo/setter.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';
import HelloWorld from 'contracts/celo/HelloWorld.json';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { secret, newMessage, contract, address } = req.body;
        const url = getSafeUrl();
        const kit = newKit(url);
        kit.addAccount(secret);
    
        // Create a new contract instance with the HelloWorld contract info
        const instance = undefined;
        // Call the setName function of our contract
        const txObject = undefined;
        // Send a transaction Object to modify the state of our contract
        let tx = undefined;
    
        let receipt = await tx.waitReceipt();
    
        res.status(200).json(receipt.transactionHash);
      } catch(error) {
        console.error(error)
        res.status(500).json('Set message of contract failed')
    }
}

'''
'''--- pages/api/celo/swap.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';

type ResponseT = {
    celo: string
    hash: string
}
export default async function swap(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
    try {
        const { secret, address } = req.body
        const OneCUSD = '1000000000000000000';

        const url = getSafeUrl();
        const kit = newKit(url);
        kit.addAccount(secret);

        // Get contract wrappers
        // - StableTokenWrapper
        // - ExchangeWrapper
        const stableToken = undefined;
        const exchange = undefined;

        // Approve a user to transfer StableToken on behalf of another user.
        const approveTx = undefined;

        // Exchange cUSD for CELO
        const goldAmount = undefined;
        const sellTx = undefined;

        const sellReceipt = await sellTx.waitReceipt();
        res.status(200).json({
            celo: goldAmount.toString(), 
            hash: sellReceipt.transactionHash
        })
    } catch(error) {
        console.error(error)
        res.status(500).json('Token Exchange failed')
    }
}

'''
'''--- pages/api/celo/transfer.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@ccelo/lib';
import { newKit } from '@celo/contractkit';

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { secret, amount, recipient, address } = req.body;
        const url = getSafeUrl();
        const kit = newKit(url);
    
        // Restore account using your secret
        undefined
        // Access CELO contract wrapper
        const celoToken = undefined;
        // Build the transaction and send
        const celotx = undefined;
        // Wait for confirmation of the transaction
        const celoReceipt = await celotx.waitReceipt();
    
        res.status(200).json(celoReceipt.transactionHash);
      } catch(error) {
        console.error(error)
        res.status(500).json('Transfer of CELO failed')
    }
}

'''
'''--- pages/api/near/balance.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from '@near/lib'
import { connect } from "near-api-js";

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<string>
) { 
    try {
        const { network, accountId } = req.body;
        const config = configFromNetwork(network);       
        const client = await connect(config);
        const account = undefined;
        const balance = undefined;
        console.log(balance)
        return res.status(200).json(balance)
    } catch (error) {
        console.error(error)
        return res.status(500).json('Balance querying failed')
    } 
}
'''
'''--- pages/api/near/check-account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from "@near/lib";
import { connect } from "near-api-js";

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<boolean | string>
) {
    try {
        const { freeAccountId, network } = req.body
        const config = configFromNetwork(network);
        const near = await connect(config);
        // try to query the account info of the 
        const accountInfo = undefined
        try {
            undefined;
            return res.status(200).json(false)
        } catch (error) {
            return res.status(200).json(true)
        }
      } catch (error) {
        console.error(error)
        return res.status(500).json('Checking availability failed')
    } 
}

'''
'''--- pages/api/near/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { configFromNetwork} from "@near/lib";
import { connect } from "near-api-js";

export default async function connection(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  const { network } = req.body;
  try {
    const config = configFromNetwork(network);
    const near = undefined;
    const provider = undefined
    const status = undefined;
    return res.status(200).json(status.version.version);
  } catch (error) {
    console.error(error);
    return res.status(500).json("Error connection to NEAR");
  }
}

'''
'''--- pages/api/near/create-account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from "@near/lib";
import { connect } from "near-api-js";

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { freeAccountId, publicKey, network } = req.body
        const config = configFromNetwork(network);
        const near = await connect(config);
        undefined;
        return res.status(200).json(freeAccountId)
    } catch (error) {
        console.error(error)
        return res.status(500).json(`Account creation Failed`)
    } 
}

'''
'''--- pages/api/near/deploy.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from '@near/lib'
import { connect, KeyPair } from "near-api-js";
import fs from 'fs';

// The symbolic link /out/main.wasm points to /contracts/near/target/release/wasm32-unknown-unknown/release/greeter.wasm
const WASM_PATH = 'contracts/near/out/main.wasm'

export default async function (
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { network, accountId, secret } = req.body;
        const config = configFromNetwork(network);
        const keypair = KeyPair.fromString(secret);
    
        // Again you will need to set your keystore
        config.keyStore?.undefined;
    
        const near = await connect(config);
        const account = await near.account(accountId);
    
        // Time to deploy the Smart Contract
        const response = undefined;
        return res.status(200).json(response.transaction.hash)
      } catch (error) {
        console.error(error)
        return res.status(500).json("Contract deployment failed: " + error.message)
    } 
}

'''
'''--- pages/api/near/getter.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from '@near/lib'
import { connect } from "near-api-js";

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { network, accountId  } = req.body;
        const config = configFromNetwork(network);
        const near = await connect(config);
        const account = await near.account(accountId);
        // Using ViewFunction try to call the contract 
        const response = undefined;
        return res.status(200).json(response)
      } catch (error) {
        console.error(error)
        return res.status(500).json('Reading Message of Contract failed')
    } 
}

'''
'''--- pages/api/near/keypair.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { KeyPair } from "near-api-js";

export default function connection(
  _req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const keypair = undefined;
    const secret = undefined;
    return res.status(200).json(secret);
  } } catch (error) {
    console.error(error);
    return res.status(500).json("Keypair generation failed");
  }
}

'''
'''--- pages/api/near/setter.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from '@near/lib'
import { connect,KeyPair } from "near-api-js";

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const { network, accountId, secret, newMessage } = req.body;
        const config = configFromNetwork(network);
        const keypair = KeyPair.fromString(secret);
        config.keyStore?.setKey(network, accountId, keypair);        
    
        const near = await connect(config);
        const account = await near.account(accountId);
        // Look at functionCall and pass the rexpected agrs
        // ... fill here
        return res.status(200).json(response.transaction.hash)
      } catch (error) {
        console.error(error)
        return res.status(500).json('Setting Message of Contract failed')
    } 
}

'''
'''--- pages/api/near/transfer.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { configFromNetwork } from '@near/lib'
import { connect, KeyPair } from 'near-api-js'
import { parseNearAmount } from 'near-api-js/lib/utils/format'
import BN from 'bn.js'

export default async function(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    const {
        txSender,
        txAmount,
        txReceiver,
        network,
        secret,
      } = req.body
    
      try {
        const config = configFromNetwork(network)
    
        // recreate the keypair from secret
        const keypair = undefined
      
        // Set the keystore with the expected method and args
        config.keyStore?.undefined
    
        // Here we convert the NEAR into yoctoNEAR using utilities from NEAR lib
        const yoctoAmount = parseNearAmount(txAmount) as string
        const amount = new BN(yoctoAmount) 
    
        // Fill the Gap: connect, create an Account Object and send some money
        const near = undefined
        const account = undefined
        const transaction = undefined
    
        return res.status(200).json(transaction.transaction.hash)
      }  catch (error) {
        console.error(error)
        return res.status(500).json('')
    } 
}

'''
'''--- pages/api/polkadot/account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { PolkadotAccountResponse } from '@polka/types';

import { Keyring } from '@polkadot/api';
import { mnemonicGenerate, mnemonicValidate } from '@polkadot/util-crypto';

export default async function account(
	_req: NextApiRequest,
	res: NextApiResponse<PolkadotAccountResponse | string>
  ) {
    const keyring = new Keyring({ type: "sr25519" });

    // Create mnemonic string
    const mnemonic = undefined;

    const isValidMnemonic = mnemonicValidate(mnemonic);
    if (!isValidMnemonic) {
      throw Error('Invalid Mnemonic')
    }

    // Add an account derived from the mnemonic
    const account = undefined;
    const address = undefined;
    const jsonWallet = undefined;
    res.status(200).json({
      address,
      mnemonic,
      jsonWallet,
    });
  } catch (error) {
    res.status(500).json("Account creation failed")
  }
}

'''
'''--- pages/api/polkadot/balance.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'

import { ApiPromise } from "@polkadot/api"
import { WsProvider } from '@polkadot/rpc-provider';
import { getSafeUrl } from "@polka/lib"

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<number | string>
) {
  try {
    const { address } = req.body
    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const { data: balance } = undefined;
    const amount = undefined;
    res.status(200).json(amount)
  }  catch (error) {
    console.log(error)
    res.status(500).json("Connection to network failed")
  }
}

'''
'''--- pages/api/polkadot/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";

import { ApiPromise } from "@polkadot/api";
import { WsProvider } from "@polkadot/rpc-provider";
import { getSafeUrl } from "@polka/lib";

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = undefined;
    const rawVersion = undefined;
    const version = rawVersion.toHuman();
    res.status(200).json(version);
  } catch (error) {
    console.log(error);
    res.status(500).json("Connection to network failed");
  }
}

'''
'''--- pages/api/polkadot/deposit.ts ---
import type { NextApiRequest, NextApiResponse } from "next";

import { ApiPromise } from "@polkadot/api";
import { WsProvider } from "@polkadot/rpc-provider";
import { getSafeUrl } from "@polka/lib";

export default async function deposit(
  _req: NextApiRequest,
  res: NextApiResponse<number | string>
) {
  try {
    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider });
    const deposit = undefined;
    res.status(200).json(deposit);
  } catch (error) {
    console.log(error);
    res.status(500).json("Unable to get existential deposit");
  }
}

'''
'''--- pages/api/polkadot/estimate.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { ApiPromise } from "@polkadot/api"
import { WsProvider } from '@polkadot/rpc-provider';
import { getSafeUrl } from "@polka/lib"

export default async function estimate(
  req: NextApiRequest,
  res: NextApiResponse<number | string>
) {
  try {
    const { address } = req.body

    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider })
    
    // A generic address for recipient (//Alice) and amount to send
    const recipient = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'
    const gigaPlanck = '1000000000';

    // Transfer tokens
    const transfer =  undefined;
    const info = undefined;
    const fees = undefined;

    res.status(200).json(fees)
  } catch (error) {
    console.log(error)
    res.status(500).json("Connection to network failed")
  }
}

'''
'''--- pages/api/polkadot/restore.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { Keyring } from "@polkadot/api"

export default async function restore(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const { mnemonic } = req.body    
    const keyring = undefined;
    const account = undefined;
    const address = undefined;
    res.status(200).json(address);
  } catch (error) {
    console.log(error)
    res.status(500).json("Unable to restore account")
  }
}

'''
'''--- pages/api/polkadot/stacking.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { PolkadotAccountResponse } from '@polka/types';
import { Keyring } from "@polkadot/api"
import { mnemonicGenerate, mnemonicValidate } from '@polkadot/util-crypto';
import { ApiPromise } from "@polkadot/api"
import { WsProvider } from '@polkadot/rpc-provider';
import { getSafeUrl } from "@polka/lib"

const DECIMAL_OFFSET = 10**12;

export default async function staking(
  req: NextApiRequest,
  res: NextApiResponse<number | string>
) {
  try {
    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider })  
        
    const { mnemonic } = req.body

    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);
    const address = account.address;
    
    const proxyMnemonic = mnemonicGenerate();
    const isValidMnemonic = mnemonicValidate(proxyMnemonic);
    if (!isValidMnemonic) {
      throw Error('Invalid Mnemonic')
    }
    const proxyAccount = keyring.addFromUri(proxyMnemonic);
    const proxyAddress = proxyAccount.address;
    const [proxies] = await api.query.proxy.proxies(account.address);
    const proxyDepositBase = api.consts.proxy.proxyDepositBase.toNumber();
    const proxyDepositFactor = api.consts.proxy.proxyDepositFactor.toNumber();
    const requiredDeposit = proxyDepositBase + proxyDepositFactor * proxies.length;
    console.log(`Required deposit for creating proxy: ${requiredDeposit / DECIMAL_OFFSET}`);

    // Add a staking proxy
    const proxyType = 'Staking';
    const delay = 0;
    let txHash = await api.tx.proxy
        .addProxy(proxyAccount.address, proxyType, delay)
        .signAndSend(account);
    console.log(`.addProxy() tx: https://westend.subscan.io/extrinsic/${txHash}`);

    res.status(200).json(DECIMAL_OFFSET);
  } catch (error) {
    console.log(error)
    res.status(500).json("Connection to network failed")
  }
}

'''
'''--- pages/api/polkadot/transfer.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'

import { ApiPromise, Keyring } from "@polkadot/api"
import { WsProvider } from '@polkadot/rpc-provider';
import { getSafeUrl } from "@polka/lib"

export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<number | string>
) {
  try {
    const { mnemonic, txAmount } = req.body

    const url = getSafeUrl();
    const provider = new WsProvider(url);
    const api = await ApiPromise.create({ provider: provider })
    
    // Initialize account from the mnemonic
    const keyring = new Keyring({type: 'sr25519'});
    const account = keyring.addFromUri(mnemonic);
  
    // Initialize account from the mnemonic
    const recipient = keyring.addFromUri('//Alice');
    const recipientAddr = recipient.address

    // Transfer tokens
    const transfer = undefined;
    const hash = await transfer.signAndSend(account);
    
    res.status(200).json(hash.toString())
  } catch (error) {
    console.log(error)
    res.status(500).json("Connection to network failed")
  }
}

'''
'''--- pages/api/polygon/query.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { ethers } from 'ethers'

import { PolygonQueryResponse, PolygonQueryErrorResponse } from 'types/polygon-types'
import { CHAINS, POLYGON_NETWORKS, POLYGON_PROTOCOLS } from 'types/types'
import { getDatahubNodeURL } from 'utils/datahub-utils'

export default async function query(
  req: NextApiRequest,
  res: NextApiResponse<PolygonQueryResponse | PolygonQueryErrorResponse>
) {
    const url = getDatahubNodeURL(CHAINS.POLYGON, POLYGON_NETWORKS.TESTNET, POLYGON_PROTOCOLS.JSON_RPC)
    const provider = new ethers.providers.JsonRpcProvider(url, "any")

    try {
      const networkName = await provider.getNetwork().then(res => { return res.name })

      // TODO
      // Define those variables below
      const chainId = undefined
      const blockHeight = undefined
      const gasPriceAsGwei = undefined
      const blockInfo = undefined

      res
        .status(200)
        .json({
          networkName,
          chainId,
          blockHeight,
          gasPriceAsGwei,
          blockInfo
        });
    } catch(err) {
      res
        .status(500)
        .json({
          message: err.message
        });
    }
}

'''
'''--- pages/api/secret/account.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey } from 'secretjs';
import { Bip39, Random } from '@iov/crypto';

type ResponseT = {
    mnemonic: string
    address: string
}
export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
    try {
        const mnemonic = undefined;
        const signingPen = await undefined;
        const pubkey = undefined;
        const address = undefined;
        res.status(200).json({mnemonic, address})
      }catch(error) {
        console.log(error)
        res.status(500).json('Failed to connect to Secret')
    }
}

'''
'''--- pages/api/secret/balance.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from 'components/protocols/secret/lib';
import { CosmWasmClient } from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const url = await getSafeUrl()
        const { address }= req.body
        const client = new CosmWasmClient(url)
    
        // Query the Account object 
        const account = undefined;
        // Return the balance
        const balance = undefined;
    
        res.status(200).json(balance)
      }catch(error) {
        console.log(error)
        res.status(500).json('failed to connect to secret')
    }
}

'''
'''--- pages/api/secret/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { getSafeUrl } from "components/protocols/secret/lib";
import { CosmWasmClient } from "secretjs";

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = await getSafeUrl();
    const client = undefined
    const nodeInfo = undefined
    const version = undefined
    res.status(200).json(version);
  }catch (error) {
    console.log(error);
    res.status(500).json("Failed to connect to secret");
  }
}

'''
'''--- pages/api/secret/deploy.ts ---
import { EnigmaUtils, SigningCosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, } from 'secretjs';
import { getSafeUrl } from 'components/protocols/secret/lib';
import type { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';

const CONTRACT_PATH = './contracts/secret/contract.wasm';

const customFees = {
  upload: {
    amount: [{ amount: '2000000', denom: 'uscrt' }],
    gas: '2000000',
  },
  init: {
    amount: [{ amount: '500000', denom: 'uscrt' }],
    gas: '500000',
  }
};

type ResponseT = {
    contractAddress: string
    transactionHash: string
}
export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<ResponseT | string>
) {
  try {
    const url = await getSafeUrl()
    const { mnemonic }= req.body
    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    // 1. Initialise client
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
    const client = new SigningCosmWasmClient(
      url,
      address,
      (signBytes) => signingPen.sign(signBytes),
      txEncryptionSeed, customFees,
    );

    // Upload the contract wasm
    const wasm = fs.readFileSync(CONTRACT_PATH);
    const uploadReceipt = await client.undefined;
    if (!uploadReceipt) {
      throw new Error("uploadReceipt error");
    }
    // Get the code ID from the receipt
    const { codeId } = uploadReceipt;

    // Create an instance of the Counter contract, providing a starting count
    const initMsg = { count: 101 };
    const receipt = undefined;

    res.status(200).json({
      contractAddress: receipt.contractAddress,
      transactionHash: receipt.transactionHash
    })
  } catch(error) {
    console.log(error)
    res.status(500).json('contract deployement failed')
  }
}

'''
'''--- pages/api/secret/getter.ts ---
import { EnigmaUtils, SigningCosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, } from 'secretjs';
import { getSafeUrl } from 'components/protocols/secret/lib';
import type { NextApiRequest, NextApiResponse } from 'next';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = await getSafeUrl()
    const { mnemonic, contract }= req.body

    const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
    const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
    const address = pubkeyToAddress(pubkey, 'secret');

    const customFees = {
      send: {
        amount: [{ amount: '80000', denom: 'uscrt' }],
        gas: '80000',
      },
    };

    // Initialise client
    const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
    const client = new SigningCosmWasmClient(
      url,
      address,
      (signBytes) => signingPen.sign(signBytes),
      txEncryptionSeed, customFees,
    );

    // Get the stored value
    console.log('Querying contract for current count');
    let response = undefined.
    let count = response.count as number

    res.status(200).json(count.toString())
  } catch(error) {
    console.log(error)
    res.status(500).json('get counter value failed')
  }
}

'''
'''--- pages/api/secret/setter.ts ---
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from 'components/protocols/secret/lib';
import { EnigmaUtils, SigningCosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, } from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
      const url = await getSafeUrl()
      const { mnemonic, contract }= req.body
      const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
      const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
      const address = pubkeyToAddress(pubkey, 'secret');
      
      const customFees = {
        exec: {
          amount: [{ amount: '500000', denom: 'uscrt' }],
          gas: '500000',
        }
      };
      // Initialise client
      const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();
      const client = new SigningCosmWasmClient(
        url,
        address,
        (signBytes) => signingPen.sign(signBytes),
        txEncryptionSeed, customFees,
      );

      // Increment the counter
      const handleMsg = { increment: {} };
      const response = undefined;

      res.status(200).json(response.transactionHash)
    } catch(error) {
      console.log(error)
      res.status(500).json('set counter value failed')
    }
}

'''
'''--- pages/api/secret/transfer.ts ---

import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from 'components/protocols/secret/lib';
import { EnigmaUtils, SigningCosmWasmClient, Secp256k1Pen, pubkeyToAddress, encodeSecp256k1Pubkey, } from 'secretjs';

export default async function connect(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
    try {
        const url = await getSafeUrl()
        const { mnemonic, txAmount }= req.body
        console.log(url)
        console.log(mnemonic)

        const signingPen = await Secp256k1Pen.fromMnemonic(mnemonic)
        const pubkey = encodeSecp256k1Pubkey(signingPen.pubkey);
        const address = pubkeyToAddress(pubkey, 'secret');

        // 0. A very specific Secret features (allowing to made the transaction encrypted)
        const txEncryptionSeed = EnigmaUtils.GenerateNewSeed();

        // 1. The fees you'll need to pay to complete the transaction
        const fees = {
          send: {
            amount: [{ amount: '80000', denom: 'uscrt' }],
            gas: '80000',
          },
        };

        // 2. Initialize a secure Secret client
        const client = new SigningCosmWasmClient(undefined);

        // 3. Send tokens
        const memo = 'sendTokens example'; // Optional memo to identify the transaction
        const sent = await client.sendTokens(undefined);
      
        // 4. Query the tx result
        const query = { id: sent.transactionHash };
        const transaction = await client.searchTx(query);
        console.log('Transaction: ', transaction);
        const hash = transaction[0].hash;

        res.status(200).json(hash)
    } catch(error) {
        console.log(error)
        res.status(500).json('transfert failed')
    }
}

'''
'''--- pages/api/solana/balance.ts ---
import { Connection, PublicKey  } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getSafeUrl } from '@solana/lib';

export default async function balance(
  req: NextApiRequest,
  res: NextApiResponse<string | number>
) {
  try {
    const address = req.body.address as PublicKey;
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");
    const publicKey = new PublicKey(address);
    const balance = await connection.getBalance(publicKey);
    res.status(200).json(balance);
  } catch(error) {
    console.error(error);
    res.status(500).json('Get balance failed');
  }
}

'''
'''--- pages/api/solana/callGreetings.ts ---
import { Connection, PublicKey, Keypair, TransactionInstruction, Transaction, sendAndConfirmTransaction } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getSafeUrl } from '@solana/lib';

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

export default async function setGreetings(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const { greeter, secret, programId } = req.body;
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");

    const greeterPublicKey = new PublicKey(greeter);
    const programKey = new PublicKey(programId);

    const payerSecretKey = new Uint8Array(JSON.parse(secret));
    const payerKeypair = Keypair.fromSecretKey(payerSecretKey);

    const instruction = new TransactionInstruction({ 
      keys: [{pubkey: greeterPublicKey as PublicKey, isSigner: false, isWritable: true}], 
      programId: programKey, 
      data: Buffer.alloc(0), // All instructions are hellos 
    }); 
  
    // this your turn to figure out 
    // how to create this transaction 
    const hash = await sendAndConfirmTransaction(
	    connection,
	    new Transaction().add(instruction),
	    [payerKeypair]
    );
  
    res.status(200).json(hash);
  } catch(error) {
    console.error(error);
    res.status(500).json('Get balance failed');
  }
}

'''
'''--- pages/api/solana/checkProgram.ts ---
import { Connection, PublicKey  } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getSafeUrl } from '@solana/lib';
import path from 'path';
import fs from 'mz/fs';

const PROGRAM_PATH = path.resolve('dist/solana/program');
const PROGRAM_SO_PATH = path.join(PROGRAM_PATH, 'helloworld.so');

export default async function checkProgram(
  req: NextApiRequest,
  res: NextApiResponse<string | boolean>
) {
  try {
    const programId = req.body.programId as PublicKey;
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");
    const publicKey = new PublicKey(programId as string);
    const programInfo = await connection.getAccountInfo(publicKey);

    if (programInfo === null) {
        if (fs.existsSync(PROGRAM_SO_PATH)) {
            throw new Error(
              'Program needs to be deployed with `solana program deploy`',
            );
        } else {
          throw new Error('Program needs to be built and deployed');
        }
    } else if (!programInfo.executable) {
      throw new Error(`Program is not executable`);
    }

    res.status(200).json(true);
  } catch(error) {
    console.log(error);
    res.status(500).json(error);
  }
}

'''
'''--- pages/api/solana/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { getSafeUrl } from "@solana/lib";
import { Connection } from "@solana/web3.js";

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = getSafeUrl();
    const connection = new Connection(url,"Confirmed");
    const version = await connection.getVersion();
    res.status(200).json(version?.["solana-core"]);
  } catch (error) {
    console.log(error);
    res.status(500).json(error);
  }
}

'''
'''--- pages/api/solana/fund.ts ---
import { Connection, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next'
import { getSafeUrl } from '@solana/lib';

export default async function fund(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed")
    const address = req.body.address as PublicKey;
    const publicKey = new PublicKey(address);  
    const hash = await connection.requestAirdrop(publicKey, LAMPORTS_PER_SOL);
    await connection.confirmTransaction(hash);
    res.status(200).json(hash)
  } catch(error) {
    console.error(error)
    res.status(500).json('airdrop failed')
  }
}

'''
'''--- pages/api/solana/getGreetings.ts ---
import { Connection, PublicKey  } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getSafeUrl } from '@solana/lib';
import * as borsh from 'borsh';

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

export default async function getGreetings(
  req: NextApiRequest,
  res: NextApiResponse<string | number>
) {
  try {
    const { greeter } = req.body;
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");
    const greeterPublicKey = new PublicKey(greeter);

    const accountInfo = await connection.getAccountInfo(greeterPublicKey);

    if (accountInfo === null) {
      throw new Error('Error: cannot find the greeted account');
    }

    // Find the expected parameters.
    const greeting = borsh.deserialize(
	    GreetingSchema,
	    GreetingAccount,
	    accountInfo.data,
    );

    // A short helper
    console.log(greeting)

    // Pass down the counter
    res.status(200).json(greeting.counter);
  } catch(error) {
    console.error(error);
    res.status(500).json('Get Greeting failed');
  }
}

'''
'''--- pages/api/solana/greeter.ts ---
import { Connection, PublicKey, Keypair, SystemProgram, Transaction, sendAndConfirmTransaction } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getSafeUrl } from '@solana/lib';
import * as borsh from 'borsh';

// The state of a greeting account managed by the hello world program
class GreetingAccount {
  counter = 0;
  constructor(fields: {counter: number} | undefined = undefined) {
    if (fields) {
      this.counter = fields.counter;
    }
  }
}

// Borsh schema definition for greeting accounts
const GreetingSchema = new Map([
  [GreetingAccount, {kind: 'struct', fields: [['counter', 'u32']]}],
]);

// The expected size of each greeting account.
const GREETING_SIZE = borsh.serialize(
  GreetingSchema,
  new GreetingAccount(),
).length;

type ResponseT = {
    hash: string
    greeter: string
}
export default async function greeter(
  req: NextApiRequest,
  res: NextApiResponse<string | ResponseT>
) {
  try {
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");

    const programId = new PublicKey(req.body.programId as string);
    const payer = Keypair.fromSecretKey(new Uint8Array(JSON.parse(req.body.secret as string)));

    const GREETING_SEED = 'hello';

    // Is there any methods from PublicKey allowing to derive a pub's key from a seed ?
    const greetedPubkey = await PublicKey.createWithSeed(payer.publicKey,GREETING_SEED,programId,);  

    // This function allow to calculate how many fees one have to pay to keep the newly 
    // created account alive on the blockchain.
    const lamports = await connection.getMinimumBalanceForRentExemption(GREETING_SIZE);

    // Find which method are expected and fill with the required arguements.
    const transaction = new Transaction().add(
        SystemProgram.createAccountWithSeed({
		basePubkey: payer.publicKey,
		fromPubkey: payer.publicKey,
		lamports: lamports,
		newAccountPubkey: greetedPubkey,
		programId: programId,
		seed: GREETING_SEED,
		space: GREETING_SIZE,
	}),
    );
    
    // complete with the expected arguments 
    const hash = await sendAndConfirmTransaction(connection,transaction,[payer])
    res.status(200).json({
        hash: hash, 
        greeter: greetedPubkey.toBase58()
    });
  } catch(error) {
    console.error(error);
    res.status(500).json('Get balance failed');
  }
}

'''
'''--- pages/api/solana/keypair.ts ---
import { Keypair } from '@solana/web3.js';
import type { NextApiRequest, NextApiResponse } from 'next';

type ResponseT = {
    secret: string
    address: string
}
export default async function keypair(
  _req: NextApiRequest,
  res: NextApiResponse<string | ResponseT>
) {
  try {
    const keypair = Keypair.generate();
    const address = keypair?.publicKey.toString();
    const secret = JSON.stringify(Array.from(keypair?.secretKey))

    res.status(200).json({
        secret,
        address,
    });
  } catch(error) {
    console.error(error);
    res.status(500).json('Get balance failed');
  }
}

'''
'''--- pages/api/solana/transfer.ts ---
import { Connection, PublicKey, SystemProgram, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import type { NextApiRequest, NextApiResponse } from "next";
import { getSafeUrl } from "@solana/lib";

type ParamT = {
    address: string
    secret: string
    recipient: string
    lamports: number
}
export default async function transfer(
  req: NextApiRequest,
  res: NextApiResponse<string>
) {
  try {
    const { address, secret, recipient, lamports } = req.body as ParamT
    const url = getSafeUrl();
    const connection = new Connection(url, "confirmed");

    const fromPubkey = new PublicKey(address as string);
    const toPubkey = new PublicKey(recipient as string);
    //... let's skip the beginning as it's should be familiar for you now.
    // The secret key is stored in our state as a stingified array
    const secretKey = Uint8Array.from(JSON.parse(secret as string));

    // Find the parameter to pass  
    const instructions = SystemProgram.transfer({
    fromPubkey,
    toPubkey,
    lamports,
    });

    // How could you construct a signer array's
    const signers = [{
    publicKey: fromPubkey,
    secretKey
    }
    ];

    // Maybe adding someting to a Transaction could be interesting ?
    const transaction = new Transaction().add(instructions)

    const hash = await sendAndConfirmTransaction(
    connection,
    transaction,
    signers);// You should now what is expected here.
    res.status(200).json(hash);
  } catch (error) {
    console.log(error);
    res.status(500).json(error);
  }
}

'''
'''--- pages/api/tezos/account.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { importKey } from '@taquito/signer';
import { getTezosUrl } from "@tezos/lib";

export default async function account(
  req: NextApiRequest, 
  res: NextApiResponse<string>
) {
  try {
    const { mnemonic, email, password, secret } = req.body
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);

    // call the importKey method
    undefined;

    res.status(200).json('Activation of the account ok');
  } catch (error) {
    console.log('error', error)
    res.status(500).json('Activation of the account failed');
  }
}

'''
'''--- pages/api/tezos/balance.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { getTezosUrl } from "@tezos/lib";

export default async function balance(
  req: NextApiRequest, 
  res: NextApiResponse<string>
) {
  try {
    const { address } = req.body
    const url = getTezosUrl();
    const toolkit = new TezosToolkit(url);
    const balance = undefined;
    res.status(200).json(balance.toString());
  } catch (error) {
    console.log(error)
    res.status(500).json('Balance retrieving failed');
  }
}

'''
'''--- pages/api/tezos/connect.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { validateChain } from "@taquito/utils";
import { getTezosUrl } from "@tezos/lib";

export default async function connect(
  _req: NextApiRequest,
  res: NextApiResponse<string | boolean>
) {
  try {
    const url = getTezosUrl();
    const toolkit = undefined;
    const chainId = undefined;
    if (validateChain(chainId) != 3) {
      throw Error("invalid chain Id");
    }
    res.status(200).json(chainId);
  }  catch (error) {
    console.log(error);
    res.status(500).json("Connection to florencenet failed");
  }
}

'''
'''--- pages/api/tezos/deploy.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { getTezosUrl } from "@tezos/lib";
import { importKey } from '@taquito/signer';
import { CONTRACT_JSON } from 'contracts/tezos/counter.js';

type ResponseT = {
  contractAddress: string
  hash: string
}
export default async function deploy(
  req: NextApiRequest, 
  res: NextApiResponse<ResponseT | string>
) {
  try {
    const { mnemonic, email, password, secret, amount } = req.body
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);

    await importKey(
      tezos,
      email,
      password,
      mnemonic,
      secret
    )

    const operation = await tezos.contract.originate({
      code: CONTRACT_JSON,
      storage: 0
    })

    const contract = await operation.contract()
 
    res.status(200).json({
      contractAddress: contract.address,
      hash: operation.hash
    });
  } catch (error) {
    console.log(error)
    res.status(500).json('Balance retrieving failed');
  }
}

'''
'''--- pages/api/tezos/getter.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { getTezosUrl } from "@tezos/lib";
import { importKey } from '@taquito/signer';

export default async function getter(
  req: NextApiRequest, 
  res: NextApiResponse<string>
) {
  try {
    const { mnemonic, email, password, secret, contract } = req.body
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);

    await importKey(
      tezos,
      email,
      password,
      mnemonic,
      secret
    )

    // use the contract module to get the storage
    const counter = undefined;

    // @ts-ignore
    res.status(200).json(counter.toString());
  } catch (error) {
    console.log(error)
    res.status(500).json("Fetching of contract's storage failed");
  }
}

'''
'''--- pages/api/tezos/setter.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { getTezosUrl } from "@tezos/lib";
import { importKey } from '@taquito/signer';
import { CONTRACT_JSON } from 'contracts/tezos/counter.js';

export default async function setter(
  req: NextApiRequest, 
  res: NextApiResponse<string>
) {
  try {
    const { mnemonic, email, password, secret, contract } = req.body
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);
    await importKey(
      tezos,
      email,
      password,
      mnemonic,
      secret
    )
    
    const n = 1;
    // load the interface of the contract
    const counterContract = undefined;
    // call the increment function of the contract
    const transaction = await counterContract.methods.increment(n).send()

    // await for confirmation
    await transaction.confirmation(3)

    res.status(200).json(transaction.hash);
  }catch (error) {
    console.log(error)
    res.status(500).json("Setting of contract's storage failed");
  }
}

'''
'''--- pages/api/tezos/transfer.ts ---
import type { NextApiRequest, NextApiResponse } from "next";
import { TezosToolkit } from "@taquito/taquito";
import { getTezosUrl } from "@tezos/lib";
import { importKey } from '@taquito/signer';

export default async function transfer(
  req: NextApiRequest, 
  res: NextApiResponse<string>
) {
  try {
    const { mnemonic, email, password, secret, amount, recipient } = req.body
    const url = getTezosUrl();
    const tezos = new TezosToolkit(url);

    await importKey(undefined);

    // call the transfer method

    // await for confirmation
    await operation.confirmation(1) 

    res.status(200).json(operation.hash);
  } catch (error) {
    console.log(error)
    res.status(500).json('Transfer failed');
  }
}

'''