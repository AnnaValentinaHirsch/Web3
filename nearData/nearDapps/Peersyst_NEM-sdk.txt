*GitHub Repository "Peersyst/NEM-sdk"*

'''--- README.md ---
# NEM-sdk
NEM Developer Kit for Node.js and the browser

---

#### Features:
- Easy integration
- Organised in namespaces
- Create wallets compatible with Nano Wallet client
- Simple transactions
- Mosaic transactions
- Encrypted, unencrypted and hex messaging
- Create and audit Apostilles
- Create and verify signatures
- Helpers and formatting functions
- 22 NIS API requests with promises
- Websockets for real time blockchain data
- Commented code and examples
- Browser examples ready to use out of the box

---

# Documentation

## Table of Contents
1. [Introduction](#1---introduction)
  - 1. [Installation](#11---installation)
  - 2. [Build](#12---build)
  - 3. [Organisation](#13---organisation)
2. [Objects](#2---objects)
  - 1. [Get objects](#21---get-objects)
  - 2. [Create objects](#22---create-objects)
  - 3. [More](#23---more)
3. [Transactions](#3---transactions)
  - 1. [Create and prepare transaction objects](#31---create-and-prepare-transaction-objects)
  - 2. [Sending prepared transactions](#32---sending-prepared-transactions)
  - 3. [Transfer transactions without mosaics](#33---transfer-transactions-without-mosaics)
  - 4. [Transfer transactions with mosaics](#34---transfer-transactions-with-mosaics)
4. [Communications](#4---communications)
  - 1. [Create endpoints](#41---create-endpoints)
  - 2. [API requests](#42---api-requests)
  - 3. [Usage](#43---usage)
  - 4. [More](#44---more)
  - 5. [Websockets](#45---websockets)
  - 6. [Usage](#46---usage)
  - 7. [More](#47---more)
5. [Helpers and Format](#5---helpers-and-format)
  - 1. [Helpers](#51---helpers)
  - 2. [Format](#52---format)
6. [Private Keys](#6---private-keys)
  - 1. [Create private keys](#61---create-private-keys)
  - 2. [Create key pairs](#62---create-key-pairs)
  - 3. [Sign with key pair](#63---sign-with-key-pair)
  - 4. [Extract public key from key pair](#64---extract-public-key-from-key-pair)
  - 5. [Verify a signature](#65---verify-a-signature)
7. [Addresses](#7---addresses)
  - 1. [Convert public key to an address](#71---convert-public-key-to-an-address)
  - 2. [Verify address validity](#72---verify-address-validity)
  - 3. [Verify if address is from given network](#73---verify-if-address-is-from-given-network)
  - 4. [More](#74---more)
8. [Crypto Helpers](#8---crypto-helpers)
9. [Wallets](#9---wallets)
  - 1. [Create simple wallets](#91---create-simple-wallets)
  - 2. [Create brain wallets](#92---create-brain-wallets)
  - 3. [Create private key wallets](#93---create-private-key-wallets)
  - 4. [Create wallet files](#94---create-wallet-files)
  - 5. [Decrypt account in wallet](#95---decrypt-account-in-wallet)
10. [Apostille](#10---apostille)
  - 1. [Create an Apostille](#101---create-an-apostille)
  - 2. [Verify an Apostille](#102---verify-an-apostille)
  - 3. [More](#103---more)

---

## 1 - Introduction

### 1.1 - Installation

#### For the browser:

Download the library source, open the `dist/` folder and put `nem-sdk.js` into your project.

Library include the `require()` function so you can `require()` the module directly

```html
<script src="nem-sdk.js"></script>
<script>
  // Include the library
  var nem = require("nem-sdk").default;
  console.log(nem)
</script>
```

#### For Node:

##### Using npm:

`npm install nem-sdk`

```javascript
// Use require
var nem = require("nem-sdk").default;
```

```javascript
// ES6
import nem from 'nem-sdk';
```

##### Using `build/` folder:

```javascript
// Use the build/ folder
var nem = require("path/to/build/index.js").default;
``` 
### 1.2 - Build

#### Install dependencies:

```npm install```

#### Build:

```npm run build```

#### Build for the browser (after above build):

```npm run browserify```

### 1.3 - Organisation

The SDK is organised in namespaces and sub-namespaces. 

There is 4 main namespaces:

#### `nem.com`
- `requests`: Requests to NIS and the outside world
- `websockets`: Connection, subscription and requests to NIS websockets

#### `nem.crypto`
- `keyPair`: Functions to create keypair from hex and sign data with it
- `helpers`: Miscellaneous cryptographic functions, like encrypt private key, decrypt a wallet, derive a password...
- `nacl`: External cryptographic library modified for NEM
- `js`: Access to the crypto-js library

#### `nem.model`
- `address`: Functions regarding NEM addresses like base32 encoding / decoding, verify, convert public key to address...
- `objects`: Contains usesul objects models
- `fees`: Contains all the transaction fees and calculation functions
- `network`: Contains networks types and functions related
- `nodes`: Contains array of nodes for different networks, default nodes, search by hash nodes...
- `sinks`: Contains the sink addresses for namespaces and mosaics by network
- `transactions`: Contains functions to prepare and send transaction objects
- `transactionTypes`: Contains all the NEM transactions types
- `wallet`: Contains functions to create wallets

#### `nem.utils`
- `convert`: Contains convertion functions
- `helpers`: Contains miscellaneous helper functions
- `format`: Contains miscellaneous formatting functions
- `nty`: Contains functions to build nty data
- `Serialization`: Contains functions to serialize transactions

Consult the code directly for details, almost all functions are commented, with parameters, return values and types. 

## 2 - Objects

**Namespace**: `nem.model.objects`

This namespace allow to easily `get` or `create` objects to use in the SDK. Each object is accessible via a keyword.

**Public methods**:
- `get`
- `create`

**Keywords**:
- `common`: An object to hold password and private key
- `endpoint`: An object containing info about a remote node
- `mosaicAttachment`: An object containing mosaic data to join in a transfer transaction
- `mosaicDefinitionMetaDataPair`: An object of objects containing mosaics properties
- `invoice`: An invoice object working on NEM mobile clients
- `transferTransaction`: An un-prepared transfer transaction object
- `signatureTransaction`: An un-prepared signature transaction object

### 2.1 - Get objects

Return an empty object

#### Usage:

```javascript
// Get an empty object
var object = nem.model.objects.get("keyword");
```

#### Example:

```javascript
// Get an empty object
var transferTransaction = nem.model.objects.get("transferTransaction");
```
#### Return:

```json
{
    "amount": "",
    "recipient": "",
    "recipientPublicKey": "",
    "isMultisig": false,
    "multisigAccount" : "",
    "message": "",
    "isEncrypted" : false,
    "mosaics": []
}
```

### 2.2 - Create objects

Return an object with parameters.

Using the `create` method takes different parameters depending of the object.

#### Parameters

##### `common`
Name           | Type             | Description   |
---------------|------------------|---------------|
password       | string           | A password    |
privateKey     | string           | A private key |

##### `endpoint`
Name           | Type             | Description   |
---------------|------------------|---------------|
host           | string           | An NIS uri    | 
port           | string           | An NIS port   |

##### `mosaicAttachment`
Name           | Type             | Description               |
---------------|------------------|---------------------------|
namespaceId    | string           | A namespace name          | 
mosaicName     | string           | A mosaic name             | 
quantity       | long number      | A quantity in micro-units |

##### `transferTransaction`
Name           | Type             | Description               |
---------------|------------------|---------------------------|
recipient      | string           | A recipient address       | 
amount         | number           | An amount                 | 
message        | string           | A message to join         |

#### Usage:

```javascript
// Create an object with parameters
var object = nem.model.objects.create("keyword")(param1, param2, ...);
```

#### Example:

```javascript
// Create an object with parameters
var transferTransaction = nem.model.objects.create("transferTransaction")("TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S", 10, "Hello");
```

#### Return:

```json
{
    "amount": 10,
    "recipient": "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S",
    "recipientPublicKey": "",
    "isMultisig": false,
    "multisigAccount" : "",
    "message": "Hello",
    "isEncrypted" : false,
    "mosaics": []
}
```

### 2.3 - More

Consult `src/model/objects.js` for details about objects and creation parameters

## 3 - Transactions

**Namespace**: `nem.model.transactions`

**Public methods**:
- `prepare`
- `send`
- `prepareMessage`

**Keywords**:
- `transferTransaction`
- `mosaicTransferTransaction`
- `signatureTransaction`

This namespace is used to prepare and send transactions. 

For now only preparation of simple and mosaics transactions with encrypted, unencrypted and hex messages are implemented.

### 3.1 - Create and prepare transaction objects

In part 2 you can see in the examples how to build a transfer transaction object, with or without data.

Transaction objects you will create via `nem.model.objects` are un-prepared transaction objects. They only contain raw / incomplete data and need to be arranged before being signed and sent.

Using the `prepare` method takes different parameters depending of the transaction object.

#### Parameters

##### `transferTransaction`

Name           | Type             | Description                  |
---------------|------------------|------------------------------|
common         | object           | A common object              |
tx             | object           | A transferTransaction object |
network        | number           | A network id                 |

##### `mosaicTransferTransaction`

Name                          | Type             | Description                           |
------------------------------|------------------|---------------------------------------|
common                        | object           | A common object                       |
tx                            | object           | A transferTransaction object          |
mosaicDefinitionMetaDataPair  | object           | A mosaicDefinitionMetaDataPair object (see 3.4)|
network                       | number           | A network id                          |

#### Usage:

```javascript
// Prepare a transaction object
var preparedTransaction = nem.model.transactions.prepare("keyword")(param1, param2, ...);
```

#### Transfer transaction example:

```javascript
// Create an object with parameters
var transferTransaction = nem.model.objects.create("transferTransaction")("TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S", 10, "Hello");

// Prepare the above object
var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id)
```

#### Return:

```javascript
{
	type: 257,
  	version: -1744830463,
  	signer: '0257b05f601ff829fdff84956fb5e3c65470a62375a1cc285779edd5ca3b42f6',
  	timeStamp: 62995509,
  	deadline: 62999109,
  	recipient: 'TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S',
  	amount: 10000000,
  	fee: 2000000,
  	message: { type: 1, payload: '48656c6c6f' },
  	mosaics: null
}
```

You can easily see the difference between an un-prepared transaction object (2.2) and above prepared object.

#### Note:

Amounts are in the smallest unit possible in a prepared transaction object:

> 1000000 = 1 XEM

#### Signature transaction example:

```javascript
// Create an object with parameters (multisig account address and inner transaction hash)
var signatureTransaction = nem.model.objects.create("signatureTransaction")("TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S", "161d7f74ab9d332acd46f96650e74371d65b6e1a0f47b076bdd7ccea37903175");

// Prepare the above object
var transactionEntity = nem.model.transactions.prepare("signatureTransaction")(common, signatureTransaction, nem.model.network.data.testnet.id)
```

#### Return:

```javascript
{
  type: 4098,
  version: -1744830463,
  signer: '0257b05f601ff829fdff84956fb5e3c65470a62375a1cc285779edd5ca3b42f6',
  timeStamp: 62995509,
  deadline: 62999109,
  otherHash: {
    data: '161d7f74ab9d332acd46f96650e74371d65b6e1a0f47b076bdd7ccea37903175'
  },
  otherAccount: 'TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S',
  fee: 6000000
}
```

### 3.2 - Sending prepared transactions

Once your transaction is prepared simply use the `send` method of the namespace.

#### Parameters

Name           | Type             | Description                   |
---------------|------------------|-------------------------------|
common         | object           | A common object               |
entity         | object           | A prepared transaction object |
endpoint       | object           | An endpoint object            |

#### Example

```javascript
// Serialize transfer transaction and announce
nem.model.transactions.send(common, transactionEntity, endpoint).then(function(res) {....});

```

#### return

A `NemAnnounceResult` object (http://bob.nem.ninja/docs/#nemAnnounceResult)

### 3.3 - Transfer transactions without mosaics

The two provided example speaks for themselves:

- See `examples/node/transfer.js` for node
- See `examples/browser/transfer` for browser

The node version contains only the strict necessary while browser example needs to handle form and update fees.

### 3.4 - Transfer transactions with mosaics

- See `examples/node/mosaicTransfer.js` for node
- See `examples/browser/mosaicTransfer` for browser

Similar to transfer transaction, it use the same un-prepared `transferTransaction` object, but needs an array of `mosaicAttachment` objects.

Keyword of the preparation function is `mosaicTransferTransaction`.

Preparation of mosaic transfer transactions requires a `mosaicDefinitionMetaDataPair` object containing mosaic definitions of the mosaics you are joining to the transaction. 

Definitions are needed to know informations about the included mosaic(s) and calculate quantity and fee accordingly.

#### Two ways are possible to get mosaic definitions:

 1) You can take it from NIS API using http://bob.nem.ninja/docs/#retrieving-mosaic-definitions and put the definition into `model/objects.js`, in the `mosaicDefinitionMetaDataPair` object (like shown by the comments). If mosaics used in your application are fixed, it is the way to go.

 2) Query the network using the embedded API requests (`nem.com.requests.namespace.mosaicDefinitions`) as shown in the examples. If mosaics used in your application are not fixed, it is the way to go.

## 4 - Communications

### 4.1 - Create endpoints

To communicate with an NIS you need an `endpoint` object. The object contains the node host and port so it is easier to handle.

#### Examples

```javascript
// Custom endpoint
var endpoint = nem.model.objects.create("endpoint")("http://myNode", 7890);

// Using sdk data
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);
```

### 4.2 - API requests

**Namespace**: `nem.com.requests`

22 NIS API calls and a few other external requests are implemented and organised in namespaces:

#### `nem.com.requests.account`
- `data`: Gets account data
- `forwarded`: Gets the account data of the account for which the given account is the delegate account
- `harvesting.blocks`: Gets harvested blocks
- `harvesting.stop`: Stop delegated harvesting
- `harvesting.start`: Start delegated harvesting
- `namespaces.owned`: Gets namespaces that an account owns
- `mosaics.owned`: Gets mosaics that an account owns
- `mosaics.allDefinitions`: Gets all mosaic definitions that an account owns
- `mosaics.definitions`: Gets mosaic definitions that an account has created
- `transactions.incoming`: Gets incoming transactions
- `transactions.unconfirmed`: Gets unconfirmed transactions
- `transactions.all`: Gets all transactions
- `transactions.outgoing`: Gets outgoing transactions
- `unlockInfo`: Gets information about the maximum number of allowed harvesters and how many harvesters are already using the node

#### `nem.com.requests.apostille`
- `audit`: Audit an apostille

#### `nem.com.requests.chain`
- `height`: Gets the chain height
- `lastBlock`: Gets the last block
- `time`: Get network time

#### `nem.com.requests.endpoint`
- `heartbeat`: Gets the node status

#### `nem.com.requests.market`
- `xem`: Gets XEM price in BTC
- `btc`: Gets BTC price in $

#### `nem.com.requests.namespace`
- `roots`: Gets root namespaces
- `info`: Gets the namespace with given id
- `mosaicDefinitions`: Gets mosaic definitions of a namespace

#### `nem.com.requests.supernodes`
- `all`: Gets all supernodes info

#### `nem.com.requests.transaction`
- `byHash`: Gets a transaction by hash
- `announce`: Announce a transaction to the network

### 4.3 - Usage

Requests are wrapped in `Promises` which allow to use `then()` for callbacks

#### Examples:

``` javascript
// Gets chain height
nem.com.requests.chain.height(endpoint).then(function(res) {
	console.log(res)
}, function(err) {
	console.error(err)
})

// Gets account data
nem.com.requests.account.data(endpoint, "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S").then(...);
```

### 4.4 - More

Consult `src/com/requests` for details about requests parameters.

- See `examples/browser/monitor` for browser demonstration
- See `examples/node/requests` for all requests in node

### 4.5 - WebSockets

**Namespace**: `nem.com.websockets`

**Note**: For now webSockets use two versions of SockJS to work in Node (v1.1.4) and the browser (v0.3.4). Using only latest SockJS v1.1.4, gives an error when used in browser:

`XMLHttpRequest cannot load http://bob.nem.ninja:7778/w/messages/info?t=1429552020306. A wildcard '*' cannot be used in the 'Access-Control-Allow-Origin' header when the credentials flag is true. Origin 'null' is therefore not allowed access.`

If anyone has a solution to that, it is welcome.

#### `nem.com.websockets.connector`
- `create`: Create a connector object
- `close`: Close the websocket connection 

#### `nem.com.websockets.subscribe`
- `errors`: Subscribes to error channel

#### `nem.com.websockets.subscribe.account`
- `data`: Subscribes to account data channel
- `transactions.recent`: Subscribes to recent transactions channel
- `transactions.confirmed`: Subscribes to confirmed transactions channel
- `transactions.unconfirmed`: Subscribes to unconfirmed transactions channel

#### `nem.com.websockets.subscribe.chain`
- `height`: Subscribes to new chain height channel
- `blocks`: Subscribes to new blocks channel

#### `nem.com.websockets.requests.account`
- `data`: Requests account data from channel
- `transactions.recent`: Requests recent transactions from channel

### 4.6 - Usage

You first need to create a connector object pointing to the right endpoint then use this connector to open the connection.

If connection is a success, the `connector.connect` function will resolve a promise in a `.then()` function, in which you can request and subscribe to channels.

Subscription takes a connector and resolve in a simple callback function (`.then()` not supported), where your data will be received from the channel. It acts exactly like a `.on('something')`.

#### Parameters

##### `create`

Name           | Type             | Description                     |
---------------|------------------|---------------------------------|
endpoint       | object           | An endpoint object (using websocket port) | 
address        | string           | A NEM account address      |

##### All subscription methods

Name           | Type             | Description                     |
---------------|------------------|---------------------------------|
connector      | object           | An open connector object        |
callback       | function         | A callback function where data will be received | 
address        | string           | A NEM account address (optional, for custom account subscription)|

##### All request methods 

Name           | Type             | Description                     |
---------------|------------------|---------------------------------|
connector      | object           | An open connector object        |
address        | string           | A NEM account address (optional, for custom account request)|

#### Example:

``` javascript
// Create an endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.websocketPort);

// Address to subscribe
var address = "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S";

// Create a connector object
var connector = nem.com.websockets.connector.create(endpoint, address);

// Connect using connector
connector.connect().then(function() {
  // If we are here we are connected
  console.log("Connected");

  // Subscribe to new blocks channel
  nem.com.websockets.subscribe.chain.blocks(connector, function(res) {
    console.log(res);
  });

  // Subscribe to account data channel
  nem.com.websockets.subscribe.account.data(connector, function(res) {
    console.log(res);
  });

  // Request account data
  nem.com.websockets.requests.account.data(connector);

}, function (err) {
  // If we are here connection failed 10 times (1/s).
  console.log(err);
});
```

### 4.7 - More

Consult `src/com/websockets` for details.

- See `examples/browser/websockets` for browser demonstration
- See `examples/nodejs/websockets.js` for Node demonstration

## 5 - Helpers and Format

### 5.1 - Helpers

**Namespace**: `nem.utils.helpers`

**Public methods**:
- `needsSignature`
- `haveTx`
- `getTransactionIndex`
- `haveCosig`
- `createNEMTimeStamp`
- `fixPrivateKey`
- `isPrivateKeyValid`
- `isPublicKeyValid`
- `checkAndFormatUrl`
- `createTimeStamp`
- `getTimestampShort`
- `convertDateToString`
- `extendObj`
- `isHexadecimal`
- `searchMosaicDefinitionArray`
- `grep`
- `isTextAmountValid`
- `cleanTextAmount`
- `formatEndpoint`

### 5.2 - Format

**Namespace**: `nem.utils.format`

**Public methods**:
- `address`
- `hexMessage`
- `hexToUtf8`
- `importanceTransferMode`
- `levyFee`
- `nemDate`
- `nemImportanceScore`
- `nemValue`
- `pubToAddress`
- `splitHex`
- `supply`
- `supplyRaw`
- `mosaicIdToName`
- `txTypeToName`

#### Format address 

Add hyphens to unformatted address.

#### Parameters

Name           | Type             | Description                     |
---------------|------------------|---------------------------------|
address        | string           | An unformatted NEM address      | 

#### Example

```javascript
var address = "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S";

// Add hyphens to NEM address
var fmtAddress = nem.utils.format.address(address); //TBCI2A-67UQZA-KCR6NS-4JWAEI-CEIGEI-M72G3M-VW5S
```
#### Format a nem quantity

Change a NEM quantity into an array of values.

Quantity means the smallest unit (1.000000 XEM = 1'000'000)

#### Parameters

Name           | Type             | Description                       |
---------------|------------------|-----------------------------------|
data           | number           | A quantity (smallest unit)        | 

#### Example

```javascript
var xemQuantity = 10003002; // Smallest unit for XEM

// Format quantity
var fmt = nem.utils.format.nemValue(xemQuantity)

var fmtAmount = fmt[0] + "." + fmt[1]; // 10.003002
```

#### Format a message object

Format hexadecimal payload contained in message objects.

Message objects also contains type:

Type 1: Plain message. 
Type 2: Encrypted message.

#### Parameters

Name           | Type             | Description                       |
---------------|------------------|-----------------------------------|
msg            | object           | A message object                  | 

#### Example

```javascript
var msg = {
  "type": 1,
  "payload": "4e454d20697320617765736f6d652021"
}

// Format msg
var fmt = nem.utils.format.hexMessage(msg); // NEM is awesome !
```

## 6 - Private Keys

A private key is a 64 or 66 characters hex string, looking like this:

```
// 64 characters hexadecimal private key
712cb1b773066cf572b6f271cb10be49b3e71ed24dd7b6a2ac876af9f3ad84e7

// 66 characters hexadecimal private key (always start with 00 in that case)
00d32b7c09e8747908b1ed9dbc893ff33987b2275bb3401cd5199f45b1bbbc7d75
```

### 6.1 - Create private keys

To obtain a private key, 4 choices are possible:

1) You can type yourself a random 64 hexadecimal string

2) Use the included PRNG:
``` javascript
// Create random bytes from PRNG
var rBytes = nem.crypto.nacl.randomBytes(32);

// Convert the random bytes to hex
var privateKey = nem.utils.convert.ua2hex(rBytes);
```

3) Create a private key from a passphrase:
``` javascript
// Derive a passphrase to get a private key
var privateKey = nem.crypto.helpers.derivePassSha(passphrase, 6000).priv;
```

4) Use a private key from another source.

### 6.2 - Create key pairs

Key pairs are objects representing accounts keys (private, secret and public) and are used to sign data or transactions.

#### Parameters

Name           | Type             | Description                     |
---------------|------------------|---------------------------------|
hexData        | string           | 64 or 66 hexadecimal characters | 

#### Example

```javascript
// A funny but valid private key
var privateKey = "aaaaaaaaaaeeeeeeeeeebbbbbbbbbb5555555555dddddddddd1111111111aaee";

// Create a key pair
var keyPair = nem.crypto.keyPair.create(privateKey);
```

### 6.3 - Sign with key pair

To sign a transaction or any other data simply use the above `keyPair` object

#### Example

```javascript
var signature = keyPair.sign(data);
```

### 6.4 - Extract public key from key pair

You can extract the public key from the `keyPair` object very easily

#### Example

```javascript
var publicKey = keyPair.publicKey.toString();
```

### 6.5 - Verify a signature

To verify a signature you need the signer public key, the data that have been signed and the signature.

#### Parameters

Name           | Type             | Description               |
---------------|------------------|---------------------------|
publicKey      | string           | The signer public key     | 
data           | string           | The data that were signed | 
signature      | string           | The signature of the data |

#### Example

```javascript
var signer = "0257b05f601ff829fdff84956fb5e3c65470a62375a1cc285779edd5ca3b42f6"
var signature = "392511e5b1d78e0991d4cb2a10037cc8be775e56d76b8157a4da726ccb44042e9b419084c09128ffe2a78fe78e2a19beb0e2f57e14b66c962187e61457bd9e09"
var data = "NEM is awesome !";
// Verify
var result = nem.crypto.verifySignature(signer, data, signature);
```

- See `examples/nodejs/verifySignature.js` for node demonstration

## 7 - Addresses

**Namespace**: `nem.model.address`

**Public methods**:
- `b32encode`
- `b32decode`
- `toAddress`
- `isFromNetwork`
- `isValid`
- `clean`

Addresses are base32 string used to receive XEM. They look like this:

> NAMOAV-HFVPJ6-FP32YP-2GCM64-WSRMKX-A5KKYW-WHPY
> NAMOAVHFVPJ6FP32YP2GCM64WSRMKXA5KKYWWHPY

The version without hyphens ("-") is the one we'll use in our queries and lower level processing. The formatted version is only for visual purposes.

#### Beginning of the address depend of the network:

- **Mainnet (104)**: N

- **Testnet (-104)**: T

- **Mijin (96)**: M

### 7.1 - Convert public key to an address

```javascript
var address = nem.model.address.toAddress(publicKey, networkId)
```

### 7.2 - Verify address validity

```javascript
var isValid = nem.model.address.isValid(address);
```

### 7.3 - Verify if address is from given network

```javascript
var isFromNetwork = nem.model.address.isFromNetwork(address, networkId);
```

### 7.4 - More

Consult `src/model/address.js` for more details

## 8 - Crypto Helpers

**Namespace**: `nem.crypto.helpers`

**Public methods**:
- `toMobileKey`
- `derivePassSha`
- `passwordToPrivatekey`
- `checkAddress`
- `randomKey`
- `decrypt`
- `encrypt`
- `encodePrivKey`
- `encode`
- `decode`

## 9 - Wallets

**Namespace**: `nem.model.wallet`

**Public methods**:
- `createPRNG`
- `createBrain`
- `importPrivateKey`

The SDK allow to create wallets 100% compatible with the Nano Wallet client (as BIP32 not implemented yet the client will ask for an upgrade).

Wallet can contain multiple accounts in an object of objects. The first account is the primary account and is labelled like this by default. 

Every accounts objects but primary of brain wallets contains an encrypted private key. Brain wallets primary do not contains an encrypted private key because it is retrieved by the password / passphrase.

Each wallet has an `algo` property, it is needed to know how to decrypt the accounts.

Wallet files (.wlt) are just storing a wallet object as base 64 strings.

### 9.1 - Create simple wallets

`nem.model.wallet.createPRNG` create a wallet object with the primary account's private key generated from a PRNG

```javascript
// Set a wallet name
var walletName = "QuantumMechanicsPRNG";

// Set a password
var password = "Something";

// Create PRNG wallet
var wallet = nem.model.wallet.createPRNG(walletName, password, nem.model.network.data.testnet.id);
```

### 9.2 - Create brain wallets

`nem.model.wallet.createBrain` create a wallet object with primary account's private key derived from a password/passphrase

```javascript
// Set a wallet name
var walletName = "QuantumMechanicsBrain";

// Set a password/passphrase
var password = "Something another thing and something else";

// Create Brain wallet
var wallet = nem.model.wallet.createBrain(walletName, password, nem.model.network.data.testnet.id);
```

### 9.3 - Create private key wallets

`nem.model.wallet.importPrivateKey` create a wallet object with primary account's private key imported

```javascript
// Set a wallet name
var walletName = "QuantumMechanicsImported";

// Set a password
var password = "Something";

// Set private key
var privateKey = "Private key to import";

// Create a private key wallet
var wallet = nem.model.wallet.importPrivateKey(walletName, password, privateKey, nem.model.network.data.testnet.id);
``` 

### 9.4 - Create wallet files

Create an empty file, name it `walletName.wlt` and put the base 64 string given by below code

```javascript
// Convert stringified wallet object to word array
var wordArray = nem.crypto.js.enc.Utf8.parse(JSON.stringify(wallet));

// Word array to base64
var base64 = nem.crypto.js.enc.Base64.stringify(wordArray);
``` 

### 9.5 - Decrypt account in wallet

`nem.crypto.helpers.passwordToPrivatekey` is a function to decrypt an account into a wallet and return it's private key into the `common` object

```javascript
// Create a common object
var common = nem.model.objects.create("common")("walletPassword/passphrase", "");

// Get the wallet account to decrypt
var walletAccount = wallet.accounts[index];

// Decrypt account private key 
nem.crypto.helpers.passwordToPrivatekey(common, walletAccount, wallet.algo);

// The common object now has a private key
console.log(common)

``` 

## 10 - Apostille

**Namespace**: `nem.model.apostille`

**Public methods**:
- `create`
- `generateAccount`
- `hashing`
- `verify`

This namespace is used to create and verify Apostilles. For detailled informations about Apostille: https://www.nem.io/ApostilleWhitePaper.pdf

### 10.1 - Create an Apostille

`nem.model.apostille.create` create an apostille object containing information about the apostille, and the transaction ready to be sent via `nem.model.transactions.send`.

#### Example

```javascript
// Create a common object holding key
var common = nem.model.objects.create("common")("", "privateKey");

// Simulate the file content
var fileContent = nem.crypto.js.enc.Utf8.parse('Apostille is awesome !');

// Create the Apostille
var apostille = nem.model.apostille.create(common, "Test.txt", fileContent, "Test Apostille", nem.model.apostille.hashing["SHA256"], false, {}, true, nem.model.network.data.testnet.id);

// Serialize transfer transaction and announce
nem.model.transactions.send(common, apostille.transaction, endpoint).then(...)
```

- See `examples/node/apostille/create` for creation example in node

### 10.2 - Verify an Apostille

`nem.model.apostille.verify` verify an apostille from a file content (as Word Array) and an apostille transaction object.

```javascript
// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Simulate the file content
var fileContent = nem.crypto.js.enc.Utf8.parse('Apostille is awesome !');

// Transaction hash of the Apostille
var txHash = "9b2dc096fb55e610c97a870b1d385458ca3d60b6f656428a981069ab8edd9a28";

// Get the Apostille transaction from the chain
nem.com.requests.transaction.byHash(endpoint, txHash).then(function(res) {
  // Verify
  if (nem.model.apostille.verify(fileContent, res.transaction)) {
    console.log("Apostille is valid");
  } else {
    console.log("Apostille is invalid");
  }
}, function(err) {
  console.log("Apostille is invalid");
  console.log(err);
});
```

- See `examples/node/apostille/audit` for verification example in node

### 10.3 - More

Consult `src/model/apostille.js` for more details
'''
'''--- examples/browser/monitor/index.html ---
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

	<div class="jumbotron text-center">
	  <h1>Monitor</h1>
	</div>

	<div id="stream" style="width: 850px;height: 350px;margin: auto;border: 1px solid #444;padding: 20px;overflow: auto;"></div>

	<!-- Modal -->
	<div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
	  <div class="modal-dialog" role="document">
	    <div class="modal-content">
	      <div class="modal-header">
	        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
	        <h4 class="modal-title" id="myModalLabel">Transactions in block <span id="txsHeight"></span></h4>
	      </div>
	      <div id="txs" class="modal-body">
	        
	      </div>
	      <div class="modal-footer">
	        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
	      </div>
	    </div>
	  </div>
	</div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/monitor/script.js ---
// Load nem-browser library
var nem = require("nem-sdk").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultMainnet, nem.model.nodes.defaultPort);

// Set start date of the monitor
var startDate = new Date();

// Add event to the stream div
$('#stream').append('<p><b>'+ startDate.toLocaleString()+':</b> Starting monitor...</p>');

// For ease we store transactions in an object of objects, so we can use height as a key to find data
var transactions = {};

// Init last height
var lastHeight = 0;

// Check the chain every 10 seconds, we use a hacked setInterval to fire the function and not wait for 10 seconds the first time
setInterval(function loop() {
	// Query the chain using a nem.com.requests promise
	nem.com.requests.chain.lastBlock(endpoint).then(function(res) {
		// If response height is above the last height
		if(res.height > lastHeight) {
			// Set date of event
			var date = new Date();
			// Add event to the stream div
			$('#stream').prepend('<p><b>'+ date.toLocaleString()+':</b> New block found, height: ' + res.height +'</p>');
			// Update last height
			lastHeight = res.height;
			// If block has transactions
			if(res.transactions.length) {
				// Add event to the stream div
				$('#stream').prepend('<p><b>'+ date.toLocaleString()+':</b> This block contains transactions: <a onClick="showTransactions('+ res.height +')">See</a></p>');
				// Store block transactions
				transactions[res.height] = res.transactions;
			} else {
				// Add event to the stream div
				$('#stream').prepend('<p><b>'+ date.toLocaleString()+':</b> This block is empty</p>');
			}
		} else {
			// Set date of event
			var date = new Date();
			// Add event to the stream div
			$('#stream').prepend('<p><b>'+ date.toLocaleString()+':</b> No activity during the last 10 seconds</p>');
		}
	}, function(err) {
		// Set date of event
		var date = new Date();
		// Add event to the stream div
		$('#stream').prepend('<p><b>'+ date.toLocaleString()+':</b> '+ err.toString() +'</p>');
	});
	return loop;
}(), 10000)

/**
 * Function to open modal and set transaction data into it
 */
function showTransactions(height) {
	// Set the block height in modal title
	$('#txsHeight').html(height);
	// Get the transactions for that block
	var txs = transactions[height];
	// Reset the modal body
	$('#txs').html('');
	// Loop transactions
	for(var i = 0; i < txs.length; i++) {
		// Add stringified transaction object to the modal body
		$('#txs').append('<pre>'+JSON.stringify(txs[i])+'</pre>');
    }
    // Open modal
	$('#myModal').modal('show');
}
'''
'''--- examples/browser/mosaicTransfer/index.html ---
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

	<div class="jumbotron text-center">
	  <h1>Mosaic Transfer</h1>
	</div>

	<div class="col-md-12">
		<div id="transfer"  class="col-md-8" style="border: 1px solid #444;padding: 20px;overflow: auto;">
			<div class="col-md-6">
				<div class="form-group">
					<fieldset>
						<label>Recipient</label>
						<input class="form-control" type="text" id="recipient"/>
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<label>Amount</label>
						<input  class="form-control" type="text" id="amount" readOnly/>
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<label>Message</label>
						<textarea  class="form-control" rows="5" cols="25" id="message"></textarea>
					</fieldset>
				</div>
			</div>
			<div class="col-md-6">
				<div class="form-group">
					<fieldset>
						<label>Fee</label>
						<p class="form-control-static" type="text">
							<span id="fee">
							</span> <small><b>XEM</b></small>
						</p>
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<label>Namespace id of mosaic to add</label>
						<input  class="form-control" type="text" id="namespaceId" placeholder="nem"/>
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<label>Name of mosaic to add</label>
						<input  class="form-control" type="text" id="mosaicName" placeholder="xem"/>
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<label>Amount of mosaic</label>
						<input  class="form-control" type="text" id="mosaicAmount" />
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<button class="btn btn-success" style="width:100%;" id="attachMosaic">Attach mosaic</button>
					</fieldset>
				</div>
			</div>
			<div class="col-md-12">
				<div class="form-group">
					<fieldset>
						<label>Private key</label>
						<input  class="form-control" type="password" id="privateKey" />
					</fieldset>
				</div>
				<div class="form-group">
					<fieldset>
						<button class="btn btn-success" style="width:100%;" id="send">Send</button>
					</fieldset>
				</div>
			</div>
		</div>

		<div id="mosaicAttached" class="col-md-3" style="margin-left: 20px;border: 1px solid #444;padding: 20px;overflow: auto;">
			<label>Mosaic Attached</label>
			<ul id="mosaicList">
			</ul>
		</div>
	</div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/mosaicTransfer/script.js ---
$(document).ready(function () {

	// Load nem-browser library
	var nem = require("nem-sdk").default;

    // Create an NIS endpoint object
	var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

	// Create an empty un-prepared transfer transaction object
	var transferTransaction = nem.model.objects.get("transferTransaction");

	// Create an empty common object to hold pass and key
	var common = nem.model.objects.get("common");

	// Get a mosaicDefinitionMetaDataPair object with preloaded xem definition
	var mosaicDefinitionMetaDataPair = nem.model.objects.get("mosaicDefinitionMetaDataPair");

	// Set default amount. In case of mosaic transfer the XEM amount works as a multiplier. (2 XEM will multiply by 2 the quantity of the mosaics you send)
	$("#amount").val("1");

	/**
     * Function to update our fee in the view
     */
	function updateFee() {
		// Check for amount errors
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Set the message into transfer transaction object
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("mosaicTransferTransaction")(common, transferTransaction, mosaicDefinitionMetaDataPair, nem.model.network.data.testnet.id);

		// Format fee returned in prepared object
		var feeString = nem.utils.format.nemValue(transactionEntity.fee)[0] + "." + nem.utils.format.nemValue(transactionEntity.fee)[1];

		//Set fee in view
		$("#fee").html(feeString);
	}

	/**
     * Build transaction from form data and send
     */
	function send() {
		// Check form for errors
		if(!transferTransaction.mosaics.length) return alert('You must attach at least one mosaic !');
		if(!$("#privateKey").val() || !$("#recipient").val()) return alert('Missing parameter !');
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');
		if (!nem.model.address.isValid(nem.model.address.clean($("#recipient").val()))) return alert('Invalid recipent address !');

		// Set the private key in common object
		common.privateKey = $("#privateKey").val();

		// Check private key for errors
		if (common.privateKey.length !== 64 && common.privateKey.length !== 66) return alert('Invalid private key, length must be 64 or 66 characters !');
    	if (!nem.utils.helpers.isHexadecimal(common.privateKey)) return alert('Private key must be hexadecimal only !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Recipient address must be clean (no hypens: "-")
		transferTransaction.recipient = nem.model.address.clean($("#recipient").val());

		// Set message
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("mosaicTransferTransaction")(common, transferTransaction, mosaicDefinitionMetaDataPair, nem.model.network.data.testnet.id);

		// Serialize transfer transaction and announce
		nem.model.transactions.send(common, transactionEntity, endpoint).then(function(res){
			// If code >= 2, it's an error
			if (res.code >= 2) {
				alert(res.message);
			} else {
				alert(res.message);
			}
		}, function(err) {
			alert(err);
		});
	}

	/**
     * Function to attach a mosaic to the transferTransaction object
     */
	function attachMosaic() {
		// Check for form errors
		if(undefined === $("#mosaicAmount").val() || !nem.utils.helpers.isTextAmountValid($("#mosaicAmount").val())) return alert('Invalid amount !');
		if(!$("#namespaceId").val() || !$("#mosaicName").val()) return alert('Missing parameter !');

		// If not XEM, fetch the mosaic definition from network
		if($("#mosaicName").val() !== 'xem') {
			nem.com.requests.namespace.mosaicDefinitions(endpoint, $("#namespaceId").val()).then(function(res) {

				// Look for the mosaic definition(s) we want in the request response (Could use ["eur", "usd"] to return eur and usd mosaicDefinitionMetaDataPairs)
				var neededDefinition = nem.utils.helpers.searchMosaicDefinitionArray(res.data, [$("#mosaicName").val()]);

				// Get full name of mosaic to use as object key
				var fullMosaicName  = $("#namespaceId").val() + ':' + $("#mosaicName").val();

				// Check if the mosaic was found
				if(undefined === neededDefinition[fullMosaicName]) return alert("Mosaic not found !");
				
				// Set mosaic definition into mosaicDefinitionMetaDataPair
				mosaicDefinitionMetaDataPair[fullMosaicName] = {};
				mosaicDefinitionMetaDataPair[fullMosaicName].mosaicDefinition = neededDefinition[fullMosaicName];

				// Now we have the definition we can calculate quantity out of user input
				var quantity = nem.utils.helpers.cleanTextAmount($("#mosaicAmount").val()) * Math.pow(10, neededDefinition[fullMosaicName].properties[0].value);

				// Create a mosaic attachment
				var mosaicAttachment = nem.model.objects.create("mosaicAttachment")($("#namespaceId").val(), $("#mosaicName").val(), quantity);

				// Push attachment into transaction mosaics
				transferTransaction.mosaics.push(mosaicAttachment);

				// Calculate back the quantity to an amount to show in the view. It should be the same as user input but we double check to see if quantity is correct.
				var totalToShow = nem.utils.format.supply(quantity, {"namespaceId": $("#namespaceId").val(), "name": $("#mosaicName").val()}, mosaicDefinitionMetaDataPair)[0] + '.' + nem.utils.format.supply(quantity, {"namespaceId": $("#namespaceId").val(), "name": $("#mosaicName").val()}, mosaicDefinitionMetaDataPair)[1];

				// Push mosaic to the list in view
				$("#mosaicList").prepend('<li>'+ totalToShow +' <small><b>'+  $("#namespaceId").val() + ':' + $("#mosaicName").val() +'</b></small> </li>');

				// Update the transaction fees in view
				updateFee();
			}, 
			function(err) {
				alert(err);
			});
		} else {
			// Calculate quantity from user input, XEM divisibility is 6
			var quantity = nem.utils.helpers.cleanTextAmount($("#mosaicAmount").val()) * Math.pow(10, 6);

			// Create a mosaic attachment
			var mosaicAttachment = nem.model.objects.create("mosaicAttachment")($("#namespaceId").val(), $("#mosaicName").val(), quantity);

			// Push attachment into transaction mosaics
			transferTransaction.mosaics.push(mosaicAttachment);

			// Calculate back the quantity to an amount to show in the view. It should be the same as user input but we double check to see if quantity is correct.
			var totalToShow = nem.utils.format.supply(quantity, {"namespaceId": $("#namespaceId").val(), "name": $("#mosaicName").val()}, mosaicDefinitionMetaDataPair)[0] + '.' + nem.utils.format.supply(quantity, {"namespaceId": $("#namespaceId").val(), "name": $("#mosaicName").val()}, mosaicDefinitionMetaDataPair)[1];

			// Push mosaic to the list in view
			$("#mosaicList").prepend('<li>'+ totalToShow +' <small><b>'+  $("#namespaceId").val() + ':' + $("#mosaicName").val() +'</b></small> </li>');

			// Update the transaction fees in view
				updateFee();
		}
	}

	// On amount change we update fee in view
	$("#amount").on('change keyup paste', function() {
	    updateFee();
	});

	// On message change we update fee in view
	$("#message").on('change keyup paste', function() {
	    updateFee();
	});

	// Call send function when click on send button
	$("#send").click(function() {
	  send();
	});

	// Call attachMosaic function when click on attachMosaic button
	$("#attachMosaic").click(function() {
	  attachMosaic();
	});

	// Initialization of fees in view
	updateFee();

});

'''
'''--- examples/browser/offlineTransaction/broadcast/index.html ---
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

	<div class="jumbotron text-center">
	  <h1>Broadcast signed transaction</h1>
	  <p><i>Put internet back on and paste the signed transaction to release it to the network</i></p>
	</div>

	<div id="transfer" style="width: 850px;margin: auto;border: 1px solid #444;padding: 20px;overflow: auto;">
		<div class="col-md-12">
			<div class="form-group">
				<fieldset>
					<label>Signed transaction</label>
					<textarea  class="form-control" rows="5" cols="25" id="transaction"></textarea>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<button class="btn btn-success" style="width:100%;" id="send">Send</button>
				</fieldset>
			</div>
		</div>
	</div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/offlineTransaction/broadcast/script.js ---
$(document).ready(function () {

	// Load nem-browser library
	var nem = require("nem-sdk").default;

    // Create an NIS endpoint object
	var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

	/**
     * Send transaction
     */
	function send() {
		// Check form for errors
		if(!$("#transaction").val()) return alert('Missing parameter !');

		// Send
		nem.com.requests.transaction.announce(endpoint, $("#transaction").val()).then(function(res) {
			// If code >= 2, it's an error
			if (res.code >= 2) {
				alert(res.message);
			} else {
				alert(res.message);
			}
		}, function(err) {
			alert(err);
		})
	}

	// Call send function when click on send button
	$("#send").click(function() {
	  send();
	});

});
'''
'''--- examples/browser/offlineTransaction/create/index.html ---
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

	<div class="jumbotron text-center">
	  <h1>Create offline transaction</h1>
	  <p><i>Switch internet off and use below form to create a signed transaction</i></p>
	</div>

	<div id="transfer" style="width: 850px;margin: auto;border: 1px solid #444;padding: 20px;overflow: auto;">
		<div class="col-md-6">
			<div class="form-group">
				<fieldset>
					<label>Recipient</label>
					<input class="form-control" type="text" id="recipient"/>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Amount</label>
					<input  class="form-control" type="text" id="amount"/>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Message</label>
					<textarea  class="form-control" rows="5" cols="25" id="message"></textarea>
				</fieldset>
			</div>
		</div>
		<div class="col-md-6">
			<div class="form-group">
				<fieldset>
					<label>Fee</label>
					<p class="form-control-static" type="text">
						<span id="fee">
						</span> <small><b>XEM</b></small>
					</p>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Private key</label>
					<input  class="form-control" type="password" id="privateKey" />
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<button class="btn btn-success" style="width:100%;" id="create">Create</button>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Signed transaction</label>
					<textarea  class="form-control" rows="5" cols="25" id="result" readOnly></textarea>
				</fieldset>
			</div>
		</div>
	</div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/offlineTransaction/create/script.js ---
$(document).ready(function () {

	// Load nem-browser library
	var nem = require("nem-sdk").default;

	// Get an empty un-prepared transfer transaction object
	var transferTransaction = nem.model.objects.get("transferTransaction");

	// Get an empty common object to hold pass and key
	var common = nem.model.objects.get("common");

	// Set default amount in view. It is text input so we can handle dot and comma as decimal mark easily (need cleaning but provided by the library)
	$("#amount").val("0");

	/**
     * Function to update our fee in the view
     */
	function updateFee() {
		// Check for amount errors
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Set the message into transfer transaction object
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id);

		// Format fee returned in prepared object
		var feeString = nem.utils.format.nemValue(transactionEntity.fee)[0] + "." + nem.utils.format.nemValue(transactionEntity.fee)[1];

		//Set fee in view
		$("#fee").html(feeString);
	}

	/**
     * Build transaction from form data
     */
	function create() {
		// Check form for errors
		if(!$("#privateKey").val() || !$("#recipient").val()) return alert('Missing parameter !');
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');
		if (!nem.model.address.isValid(nem.model.address.clean($("#recipient").val()))) return alert('Invalid recipent address !');

		// Set the private key in common object
		common.privateKey = $("#privateKey").val();

		// Check private key for errors
		if (common.privateKey.length !== 64 && common.privateKey.length !== 66) return alert('Invalid private key, length must be 64 or 66 characters !');
    	if (!nem.utils.helpers.isHexadecimal(common.privateKey)) return alert('Private key must be hexadecimal only !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Recipient address must be clean (no hypens: "-")
		transferTransaction.recipient = nem.model.address.clean($("#recipient").val());

		// Set message
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id);

		// Create a key pair object from private key
		var kp = nem.crypto.keyPair.create(nem.utils.helpers.fixPrivateKey(common.privateKey));

		// Serialize the transaction
		var serialized = nem.utils.serialization.serializeTransaction(transactionEntity);

		// Sign the serialized transaction with keypair object
	    var signature = kp.sign(serialized);

	    // Build the object to send
	    var result = {
	        'data': nem.utils.convert.ua2hex(serialized),
	        'signature': signature.toString()
	    };

	    // Show the object to send in view
	    $("#result").val(JSON.stringify(result));
	}

	// On amount change we update fee in view
	$("#amount").on('change keyup paste', function() {
	    updateFee();
	});

	// On message change we update fee in view
	$("#message").on('change keyup paste', function() {
	    updateFee();
	});

	// Call send function when click on send button
	$("#create").click(function() {
	  create();
	});

	// Initialization of fees
	updateFee();

});
'''
'''--- examples/browser/transfer/index.html ---
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

	<div class="jumbotron text-center">
	  <h1>Transfer</h1>
	</div>

	<div id="transfer" style="width: 850px;margin: auto;border: 1px solid #444;padding: 20px;overflow: auto;">
		<div class="col-md-6">
			<div class="form-group">
				<fieldset>
					<label>Recipient</label>
					<input class="form-control" type="text" id="recipient"/>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Amount</label>
					<input  class="form-control" type="text" id="amount"/>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Message</label>
					<textarea  class="form-control" rows="5" cols="25" id="message"></textarea>
				</fieldset>
			</div>
		</div>
		<div class="col-md-6">
			<div class="form-group">
				<fieldset>
					<label>Fee</label>
					<p class="form-control-static" type="text">
						<span id="fee">
						</span> <small><b>XEM</b></small>
					</p>
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<label>Private key</label>
					<input  class="form-control" type="password" id="privateKey" />
				</fieldset>
			</div>
			<div class="form-group">
				<fieldset>
					<button class="btn btn-success" style="width:100%;" id="send">Send</button>
				</fieldset>
			</div>
		</div>
	</div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/transfer/script.js ---
$(document).ready(function () {

	// Load nem-browser library
	var nem = require("nem-sdk").default;

    // Create an NIS endpoint object
	var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

	// Get an empty un-prepared transfer transaction object
	var transferTransaction = nem.model.objects.get("transferTransaction");

	// Get an empty common object to hold pass and key
	var common = nem.model.objects.get("common");

	// Set default amount in view. It is text input so we can handle dot and comma as decimal mark easily (need cleaning but provided by the library)
	$("#amount").val("0");

	/**
     * Function to update our fee in the view
     */
	function updateFee() {
		// Check for amount errors
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Set the message into transfer transaction object
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id);

		// Format fee returned in prepared object
		var feeString = nem.utils.format.nemValue(transactionEntity.fee)[0] + "." + nem.utils.format.nemValue(transactionEntity.fee)[1];

		//Set fee in view
		$("#fee").html(feeString);
	}

	/**
     * Build transaction from form data and send
     */
	function send() {
		// Check form for errors
		if(!$("#privateKey").val() || !$("#recipient").val()) return alert('Missing parameter !');
		if(undefined === $("#amount").val() || !nem.utils.helpers.isTextAmountValid($("#amount").val())) return alert('Invalid amount !');
		if (!nem.model.address.isValid(nem.model.address.clean($("#recipient").val()))) return alert('Invalid recipent address !');

		// Set the private key in common object
		common.privateKey = $("#privateKey").val();

		// Check private key for errors
		if (common.privateKey.length !== 64 && common.privateKey.length !== 66) return alert('Invalid private key, length must be 64 or 66 characters !');
    	if (!nem.utils.helpers.isHexadecimal(common.privateKey)) return alert('Private key must be hexadecimal only !');

		// Set the cleaned amount into transfer transaction object
		transferTransaction.amount = nem.utils.helpers.cleanTextAmount($("#amount").val());

		// Recipient address must be clean (no hypens: "-")
		transferTransaction.recipient = nem.model.address.clean($("#recipient").val());

		// Set message
		transferTransaction.message = $("#message").val();

		// Prepare the updated transfer transaction object
		var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id);

		// Serialize transfer transaction and announce
		nem.model.transactions.send(common, transactionEntity, endpoint).then(function(res){
			// If code >= 2, it's an error
			if (res.code >= 2) {
				alert(res.message);
			} else {
				alert(res.message);
			}
		}, function(err) {
			alert(err);
		});
	}

	// On amount change we update fee in view
	$("#amount").on('change keyup paste', function() {
	    updateFee();
	});

	// On message change we update fee in view
	$("#message").on('change keyup paste', function() {
	    updateFee();
	});

	// Call send function when click on send button
	$("#send").click(function() {
	  send();
	});

	// Initialization of fees in view
	updateFee();

});
'''
'''--- examples/browser/websockets/index.html ---
<html>
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
</head>

<body>

    <div class="jumbotron text-center">
      <h1>WebSockets</h1>
    </div>

    <div id="stream" style="width: 850px;height: 350px;margin: auto;border: 1px solid #444;padding: 20px;overflow: auto;"></div>

    <!-- Modal -->
    <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title" id="myModalLabel">Transactions in block <span id="txsHeight"></span></h4>
          </div>
          <div id="txs" class="modal-body">
            
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

</body>

<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../../dist/nem-sdk.js"></script>
<script src="script.js"></script>

</html>
'''
'''--- examples/browser/websockets/script.js ---
// Load nem-browser library
var nem = require("nem-sdk").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.websocketPort);

// Address to subscribe
var address = "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S";

// Create a connector object
var connector = nem.com.websockets.connector.create(endpoint, address);

// Set start date of the monitor
var date = new Date();

// Add event to the stream div
$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Starting monitor...</p>');

// Try to establish a connection
connect(connector);

// Connect using connector
function connect(connector){
    return connector.connect().then(function() {
    	// Set time
    	date = new Date();

        // If we are here, we are connected
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Connected to: '+ connector.endpoint.host +'</p>');
    	
        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to errors</p>');

        // Subscribe to errors channel
        nem.com.websockets.subscribe.errors(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received error</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to new blocks</p>');

        // Subscribe to new blocks channel
        nem.com.websockets.subscribe.chain.blocks(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received a new block</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to recent transactions</p>');

        // Subscribe to recent transactions channel
        nem.com.websockets.subscribe.account.transactions.recent(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received recent transactions</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to account data of '+ connector.address +'</p>');

        // Subscribe to account data channel
        nem.com.websockets.subscribe.account.data(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received account data</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to unconfirmed transactions of '+ connector.address +'</p>');

        // Subscribe to unconfirmed transactions channel
        nem.com.websockets.subscribe.account.transactions.unconfirmed(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received unconfirmed transaction</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Subscribing to confirmed transactions of '+ connector.address +'</p>');

        // Subscribe to confirmed transactions channel
        nem.com.websockets.subscribe.account.transactions.confirmed(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Received confirmed transaction</p>');
            // Show data
            $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(res) +'</pre>');
        });
        
        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Requesting account data of '+ connector.address +'</p>');

        // Request account data
        nem.com.websockets.requests.account.data(connector);

        // Show event
    	$('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Requesting recent transactions of '+ connector.address +'</p>');
        
        // Request recent transactions
        nem.com.websockets.requests.account.transactions.recent(connector);

    }, function(err) {
        // Set time
        date = new Date();
        // Show event
        $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> An error occured</p>');
        // Show data
        $('#stream').append('<p><b>'+ date.toLocaleString()+': <pre>' + JSON.stringify(err) +'</pre>');
        // Try to reconnect
        reconnect();
    });
}

function reconnect() {
    // Replace endpoint object
    endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.testnet[1].uri, nem.model.nodes.websocketPort);
    // Replace connector
    connector = nem.com.websockets.connector.create(endpoint, address);
    // Set time
    date = new Date();
    // Show event
    $('#stream').append('<p><b>'+ date.toLocaleString()+':</b> Trying to connect to: '+ endpoint.host +'</p>');
    // Try to establish a connection
    connect(connector);
}
'''
'''--- examples/nodejs/apostille/audit.js ---
// Include the library
var nem = require("../../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Simulate the file content
var fileContent = nem.crypto.js.enc.Utf8.parse('Apostille is awesome !');

// Transaction hash of the Apostille
var txHash = "5e7c54e47372659b4ae27e500d48e4514e827d8f6e1b88f07bdbc8c53e471422";

// Get the Apostille transaction from the chain
nem.com.requests.transaction.byHash(endpoint, txHash).then(function(res) {
	// Verify
	if (nem.model.apostille.verify(fileContent, res.transaction)) {
		console.log("Apostille is valid");
	} else {
	    console.log("Apostille is invalid");
	}
}, function(err) {
	console.log("Apostille is invalid");
	console.log(err);
});
'''
'''--- examples/nodejs/apostille/create.js ---
// Include the library
var nem = require("../../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Create a common object holding key
var common = nem.model.objects.create("common")("", "privateKey");

// Simulate the file content
var fileContent = nem.crypto.js.enc.Utf8.parse('Apostille is awesome !');

// Create the apostille
var apostille = nem.model.apostille.create(common, "Test.txt", fileContent, "Test Apostille", nem.model.apostille.hashing["SHA256"], false, "", true, nem.model.network.data.testnet.id);

// Serialize transfer transaction and announce
nem.model.transactions.send(common, apostille.transaction, endpoint).then(function(res){
	// If code >= 2, it's an error
	if (res.code >= 2) {
		console.error(res.message);
	} else {
		console.log("\nTransaction: " + res.message);
		console.log("\nCreate a file with the fileContent text and name it:\n" + apostille.data.file.name.replace(/\.[^/.]+$/, "") + " -- Apostille TX " + res.transactionHash.data + " -- Date DD/MM/YYYY" + "." + apostille.data.file.name.split('.').pop());
		console.log("When transaction is confirmed the file should audit successfully in Nano");
		console.log("\nYou can also take the following hash: " + res.transactionHash.data + " and put it into the audit.js example");
	}
}, function(err) {
	console.error(err);
});
'''
'''--- examples/nodejs/createMosaic.js ---
// Include the library
var nem = require("../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Create a common object holding key 
var common = nem.model.objects.create("common")("", "Private key");

// Get a MosaicDefinitionCreationTransaction object
var tx = nem.model.objects.get("mosaicDefinitionTransaction");

// Define the mosaic
tx.mosaicName = "myMosaic";
tx.namespaceParent = {
	"fqn": "nano.example"
};
tx.mosaicDescription = "My mosaic";

// Set properties (see https://nemproject.github.io/#mosaicProperties)
tx.properties.initialSupply = 5000000;
tx.properties.divisibility = 2;
tx.properties.transferable = true;
tx.properties.supplyMutable = true;

// Prepare the transaction object
var transactionEntity = nem.model.transactions.prepare("mosaicDefinitionTransaction")(common, tx, nem.model.network.data.testnet.id);

// Serialize transaction and announce
nem.model.transactions.send(common, transactionEntity, endpoint)
'''
'''--- examples/nodejs/mosaicTransfer.js ---
// Include the library
var nem = require("../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Create a common object holding key 
var common = nem.model.objects.create("common")("", "Private key");

// Create variable to store our mosaic definitions, needed to calculate fees properly (already contains xem definition)
var mosaicDefinitionMetaDataPair = nem.model.objects.get("mosaicDefinitionMetaDataPair");

// Create an un-prepared mosaic transfer transaction object (use same object as transfer tansaction)
var transferTransaction = nem.model.objects.create("transferTransaction")("TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S", 1, "Hello");

/**
 * ATTACHING XEM MOSAIC
 *
 * No need to get mosaic definition because it is already known in the mosaicdefinitionMetaDatapair
 */

// Create a mosaic attachment object
var mosaicAttachment = nem.model.objects.create("mosaicAttachment")("nem", "xem", 1000000);

// Push attachment into transaction mosaics
transferTransaction.mosaics.push(mosaicAttachment);

/**
 * ATTACHING ANOTHER MOSAIC
 *
 * Need to get mosaic definition using com.requests
 */

// Create another mosaic attachment
var mosaicAttachment2 = nem.model.objects.create("mosaicAttachment")("nw.fiat", "eur", 10000); // 100 nw.fiat.eur (divisibility is 2 for this mosaic)

// Push attachment into transaction mosaics
transferTransaction.mosaics.push(mosaicAttachment2);

// Need mosaic definition of nw.fiat:eur to calculate adequate fees, so we get it from network.
// Otherwise you can simply take the mosaic definition from api manually (http://bob.nem.ninja/docs/#retrieving-mosaic-definitions) 
// and put it into mosaicDefinitionMetaDataPair model (objects.js) next to nem:xem (be careful to respect object structure)
nem.com.requests.namespace.mosaicDefinitions(endpoint, mosaicAttachment2.mosaicId.namespaceId).then(function(res) {

	// Look for the mosaic definition(s) we want in the request response (Could use ["eur", "usd"] to return eur and usd mosaicDefinitionMetaDataPairs)
	var neededDefinition = nem.utils.helpers.searchMosaicDefinitionArray(res.data, ["eur"]);
	
	// Get full name of mosaic to use as object key
	var fullMosaicName  = nem.utils.format.mosaicIdToName(mosaicAttachment2.mosaicId);

	// Check if the mosaic was found
	if(undefined === neededDefinition[fullMosaicName]) return console.error("Mosaic not found !");

	// Set eur mosaic definition into mosaicDefinitionMetaDataPair
	mosaicDefinitionMetaDataPair[fullMosaicName] = {};
	mosaicDefinitionMetaDataPair[fullMosaicName].mosaicDefinition = neededDefinition[fullMosaicName];

	// Prepare the transfer transaction object
	var transactionEntity = nem.model.transactions.prepare("mosaicTransferTransaction")(common, transferTransaction, mosaicDefinitionMetaDataPair, nem.model.network.data.testnet.id);

	// Serialize transfer transaction and announce
	nem.model.transactions.send(common, transactionEntity, endpoint)
}, 
function(err) {
	console.error(err);
});

'''
'''--- examples/nodejs/requests.js ---
var nem = require("../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Address we'll use in some queries
var address = "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S";

// Get chain height
nem.com.requests.chain.height(endpoint).then(function(res) {
	console.log("\nChain Height:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get account data
nem.com.requests.account.data(endpoint, address).then(function(res) {
	console.log("\nAccount data:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get harvested blocks
nem.com.requests.account.harvesting.blocks(endpoint, address).then(function(res) {
	console.log("\nHarvested blocks:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get namespace info
nem.com.requests.namespace.info(endpoint, "nw").then(function(res) {
	console.log("\nNamespace info:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get mosaic definitions of a namespace or sub-namespace
nem.com.requests.namespace.mosaicDefinitions(endpoint, "nw.fiat").then(function(res) {
	console.log("\nMosaic definitions:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get incoming transactions
nem.com.requests.account.transactions.incoming(endpoint, address).then(function(res) {
	console.log("\nIncoming transactions:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get unconfirmed transactions
nem.com.requests.account.transactions.unconfirmed(endpoint, address).then(function(res) {
	console.log("\nUnconfirmed transactions:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Audit an apostille
var data = "a7989d7da532230414a0bbbbcc3efa08c1655a91cb99b43971246342ea32ef57";
var publicKey = "0257b05f601ff829fdff84956fb5e3c65470a62375a1cc285779edd5ca3b42f6";
var signedData = "99e8a55a65cf6a7913ac4fcacd9be0dd91a06b556faadc6a2baddc5bf639eba6e96050e931be083f819b1fbdab67345d418537f7314b36eea64e3244b3213b0b";

nem.com.requests.apostille.audit(publicKey, data, signedData).then(function(res) {
	console.log("\nApostille audit result:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get unlock info
nem.com.requests.account.unlockInfo(endpoint).then(function(res) {
	console.log("\nUnlock info:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Start harvesting for an account
var privateKey = "05fb0e2f6e4e6b06fb13906ced18c11544dc61a1de0c585663ba6abd35a41d08";
nem.com.requests.account.harvesting.start(endpoint, privateKey).then(function(res) {
	console.log("\nUnlock account:");
	console.log(res);
}, function(err) {
	console.log("\nUnlock account:");
	console.error(err);
});

// Stop harvesting for an account
nem.com.requests.account.harvesting.stop(endpoint, privateKey).then(function(res) {
	console.log("\nLock account:");
	console.log(res);
}, function(err) {
	console.log("\nLock account:");
	console.error(err);
});

// Get BTC/XEM market information
nem.com.requests.market.xem().then(function(res) {
	console.log("\nXEM to BTC market info:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get BTC to USD market information
nem.com.requests.market.btc().then(function(res) {
	console.log("\nBTC to USD market info:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get endpoint heartbeat
nem.com.requests.endpoint.heartbeat(endpoint).then(function(res) {
	console.log("\nEndpoint heartbeat:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get a transaction by hash
var txHash = "161d7f74ab9d332acd46f96650e74371d65b6e1a0f47b076bdd7ccea37903175";
// Create another endpoint because this request need special nodes
var searchEnabledEndpoint = nem.model.objects.create("endpoint")(nem.model.nodes.searchOnTestnet[0].uri, nem.model.nodes.defaultPort);
nem.com.requests.transaction.byHash(searchEnabledEndpoint, txHash).then(function(res) {
	console.log("\nTransaction data:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get account for which the given account is the delegate account
var delegatedAccount = "TD6U6OTDK5ZRAZCSZ4653IT6OMOZ3KEIOZ2BNWJP";
nem.com.requests.account.forwarded(endpoint, delegatedAccount).then(function(res) {
	console.log("\nAccount forwarded:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get 100 firsts namespaces 
nem.com.requests.namespace.roots(endpoint).then(function(res) {
	console.log("\nNamespaces:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get namespaces owned by account
nem.com.requests.account.namespaces.owned(endpoint, address).then(function(res) {
	console.log("\nNamespaces of account:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get all transactions of account
nem.com.requests.account.transactions.all(endpoint, address).then(function(res) {
	console.log("\nAll transactions of the account:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get blockchain time
nem.com.requests.chain.time(endpoint).then(function(res) {
	console.log("\nNetwork time:");
	console.log(res);
}, function(err) {
	console.error(err);
});

// Get all supernodes
nem.com.requests.supernodes.all().then(function(res) {
	console.log("\nSupernodes:");
	console.log(res);
}, function(err) {
	console.error(err);
});
'''
'''--- examples/nodejs/transfer.js ---
// Include the library
var nem = require("../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.defaultPort);

// Create a common object holding key
var common = nem.model.objects.create("common")("", "Private key");

// Create an un-prepared transfer transaction object
var transferTransaction = nem.model.objects.create("transferTransaction")("TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S", 10, "Hello");

// Prepare the transfer transaction object
var transactionEntity = nem.model.transactions.prepare("transferTransaction")(common, transferTransaction, nem.model.network.data.testnet.id);

// Serialize transfer transaction and announce
nem.model.transactions.send(common, transactionEntity, endpoint);
'''
'''--- examples/nodejs/verifySignature.js ---
// Include the library
var nem = require("../../build/index.js").default;

// Create keypair
var kp = nem.crypto.keyPair.create("privateKey");

// Data to sign
var data = "NEM is awesome !"

// Sign data
var sig = kp.sign(data);

// Review
console.log("Public key: " + kp.publicKey.toString());
console.log("Original data: " + data);
console.log("Signature: " + sig.toString());

// Result
console.log("\nResult: ");
if(nem.crypto.verifySignature(kp.publicKey.toString(), data, sig.toString())) {
	console.log("Signature is valid");
} else {
	console.log("Signature is invalid");
}

'''
'''--- examples/nodejs/webSockets.js ---
// Load nem-browser library
var nem = require("../../build/index.js").default;

// Create an NIS endpoint object
var endpoint = nem.model.objects.create("endpoint")(nem.model.nodes.defaultTestnet, nem.model.nodes.websocketPort);

// Address to subscribe
var address = "TBCI2A67UQZAKCR6NS4JWAEICEIGEIM72G3MVW5S";

// Create a connector object
var connector = nem.com.websockets.connector.create(endpoint, address);

// Set start date of the monitor
var date = new Date();

// Show event
console.log(date.toLocaleString() +': Starting monitor...');

// Try to establish a connection
connect(connector);

// Connect using connector
function connect(connector){
    return connector.connect().then(function() {
    	// Set time
    	date = new Date();

        // If we are here, we are connected
    	console.log(date.toLocaleString()+': Connected to: '+ connector.endpoint.host);
    	
        // Show event
    	console.log( date.toLocaleString()+': Subscribing to errors');

        // Subscribe to errors channel
        nem.com.websockets.subscribe.errors(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received error');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res));
        });

        // Show event
    	console.log(date.toLocaleString()+': Subscribing to new blocks');

        // Subscribe to new blocks channel
        nem.com.websockets.subscribe.chain.blocks(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received a new block');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res) +'');
        });

        // Show event
    	console.log(date.toLocaleString()+': Subscribing to recent transactions');

        // Subscribe to recent transactions channel
        nem.com.websockets.subscribe.account.transactions.recent(connector, function(res){
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received recent transactions');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res));
        });

        // Show event
    	console.log(date.toLocaleString()+': Subscribing to account data of '+ connector.address);

        // Subscribe to account data channel
        nem.com.websockets.subscribe.account.data(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received account data');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res));
        });

        // Show event
    	console.log(date.toLocaleString()+': Subscribing to unconfirmed transactions of '+ connector.address);

        // Subscribe to unconfirmed transactions channel
        nem.com.websockets.subscribe.account.transactions.unconfirmed(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received unconfirmed transaction');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res));
        });

        // Show event
    	console.log(date.toLocaleString()+': Subscribing to confirmed transactions of '+ connector.address);

        // Subscribe to confirmed transactions channel
        nem.com.websockets.subscribe.account.transactions.confirmed(connector, function(res) {
            // Set time
            date = new Date();
            // Show event
            console.log(date.toLocaleString()+': Received confirmed transaction');
            // Show data
            console.log(date.toLocaleString()+': ' + JSON.stringify(res));
        });
        
        // Show event
    	console.log(date.toLocaleString()+': Requesting account data of '+ connector.address);

        // Request account data
        nem.com.websockets.requests.account.data(connector);

        // Show event
    	console.log(date.toLocaleString()+': Requesting recent transactions of '+ connector.address);

        // Request recent transactions
        nem.com.websockets.requests.account.transactions.recent(connector);

    }, function(err) {
        // Set time
        date = new Date();
        // Show event
        console.log(date.toLocaleString()+': An error occured');
        // Show data
        console.log(date.toLocaleString()+': ' + JSON.stringify(err));
        // Try to reconnect
        reconnect();
    });
}

function reconnect() {
    // Replace endpoint object
    endpoint = nem.model.objects.create("endpoint")("http://bob.nem.ninja", 7778);
    // Replace connector
    connector = nem.com.websockets.connector.create(endpoint, address);
    // Set time
    date = new Date();
    // Show event
    console.log(date.toLocaleString()+': Trying to connect to: '+ endpoint.host);
    // Try to establish a connection
    connect(connector);
}
'''
'''--- package.json ---
{
  "name": "nem-sdk",
  "version": "1.6.8",
  "description": "NEM Developer Kit for Node.js and the browser",
  "main": "build/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/QuantumMechanics/NEM-sdk.git"
  },
  "scripts": {
    "test": "mocha --compilers js:babel-core/register -- recursive",
    "build": "babel src --presets babel-preset-es2015 --out-dir build --source-maps",
    "browserify": "mkdir -p dist && browserify -r through -r duplexer -r ./build/index.js:nem-sdk > dist/nem-sdk.js",
    "minify": "uglifyjs dist/nem-sdk.js > dist/nem-sdk.min.js",
    "version": "npm run build && npm run browserify && npm run minify && git add -A dist/",
    "postversion": "git push origin master && git push --tags",
    "postinstall": "npm run build"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "babel-cli": "^6.6.5",
    "babel-preset-es2015": "^6.6.0",
    "babel-core": "^6.7.2",
    "babel-plugin-transform-inline-environment-variables": "^6.8.0",
    "crypto-js": "3.1.9-1",
    "jquery": "3.0.0",
    "request": "2.81.0",
    "sockjs-client": "1.1.4"
  },
  "devDependencies": {
    "browserify": "14.1.0",
    "chai": "^3.5.0",
    "mocha": "^2.4.5",
    "through": "2.3.8",
    "duplexer": "0.1.1",
    "uglify-js": "~2.6.0"
  }
}

'''
'''--- src/com/requests/account.js ---
import Helpers from '../../utils/helpers';
import Headers from './headers';
import Send from './send';

/**
 * Gets the AccountMetaDataPair of an account.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {object} - An [AccountMetaDataPair]{@link http://bob.nem.ninja/docs/#accountMetaDataPair} object
 */
let data = function(endpoint, address) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/get',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'address': address}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the AccountMetaDataPair of an account with a public Key.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} publicKey - An account public key
 *
 * @return {object} - An [AccountMetaDataPair]{@link http://bob.nem.ninja/docs/#accountMetaDataPair} object
 */
let dataFromPublicKey = function(endpoint, publicKey) {
	// Configure the public key request
	const options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/get/from-public-key',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'publicKey': publicKey}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets an array of harvest info objects for an account.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {array} - An array of [HarvestInfo]{@link http://bob.nem.ninja/docs/#harvestInfo} objects
 */
let harvestedBlocks = function(endpoint, address){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/harvests',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'address': address}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets an array of TransactionMetaDataPair objects where the recipient has the address given as parameter to the request.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {string} txHash - The 256 bit sha3 hash of the transaction up to which transactions are returned. (optional)
 * @param {string} txId - The transaction id up to which transactions are returned. (optional)
 *
 * @return {array} - An array of [TransactionMetaDataPair]{@link http://bob.nem.ninja/docs/#transactionMetaDataPair} objects
 */
let incomingTransactions = function(endpoint, address, txHash, txId){
	// Arrange
	let params = {'address': address};
	if (txHash) params['hash'] = txHash;
	if (txId) params['id'] = txId;

	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/transfers/incoming',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: params
	}
	// Send the request
	return Send(options);
}

/**
 * Gets an array of TransactionMetaDataPair objects where the sender has the address given as parameter to the request.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {string} txHash - The 256 bit sha3 hash of the transaction up to which transactions are returned. (optional)
 * @param {string} txId - The transaction id up to which transactions are returned. (optional)
 *
 * @return {array} - An array of [TransactionMetaDataPair]{@link http://bob.nem.ninja/docs/#transactionMetaDataPair} objects
 */
let outgoingTransactions = function(endpoint, address, txHash, txId){
	// Arrange
	let params = {'address': address};
	if (txHash) params['hash'] = txHash;
	if (txId) params['id'] = txId;

	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/transfers/outgoing',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: params
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the array of transactions for which an account is the sender or receiver and which have not yet been included in a block.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {array} - An array of [UnconfirmedTransactionMetaDataPair]{@link http://bob.nem.ninja/docs/#unconfirmedTransactionMetaDataPair} objects
 */
let unconfirmedTransactions = function(endpoint, address){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/unconfirmedTransactions',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'address': address}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets information about the maximum number of allowed harvesters and how many harvesters are already using the node
 *
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {object} - An [UnlockInfo]{@link http://bob.nem.ninja/docs/#retrieving-the-unlock-info} object
 */
let unlockInfo = function(endpoint) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/unlocked/info',
	    method: 'POST',
	    headers: Headers.urlEncoded
	}
	// Send the request
	return Send(options);
};

/**
 * Unlocks an account (starts harvesting).
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} privateKey - A delegated account private key
 *
 * @return - Nothing
 */
let startHarvesting = function(endpoint, privateKey){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/unlock',
	    method: 'POST',
	    json: true,
		body: {'value': privateKey}
	}
	// Send the request
	return Send(options);
};

 /**
 * Locks an account (stops harvesting).
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} privateKey - A delegated account private key
 *
 * @return - Nothing
 */
let stopHarvesting = function(endpoint, privateKey){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/lock',
	    method: 'POST',
	    json: true,
		body: {'value': privateKey}
	}
	// Send the request
	return Send(options);
};

/**
 * Gets the AccountMetaDataPair of the account for which the given account is the delegate account
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {object} - An [AccountMetaDataPair]{@link http://bob.nem.ninja/docs/#accountMetaDataPair} object
 */
let forwarded = function(endpoint, address) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/get/forwarded',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'address': address}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets namespaces that an account owns
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {string} parent - The namespace parent (optional)
 *
 * @return {object} - An array of [NamespaceMetaDataPair]{@link http://bob.nem.ninja/docs/#namespaceMetaDataPair} objects
 */
let namespacesOwned = function(endpoint, address, parent){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/namespace/page',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: { 'address': address, 'parent': parent || ""}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets mosaic definitions that an account has created
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {string} parent - The namespace parent (optional)
 *
 * @return {object} - An array of [MosaicDefinition]{@link http://bob.nem.ninja/docs/#mosaicDefinition} objects
 */
let mosaicDefinitionsCreated = function(endpoint, address, parent){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/mosaic/definition/page',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: { 'address': address, 'parent': parent || ""}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets mosaic definitions that an account owns
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {array} - An array of [MosaicDefinition]{@link http://bob.nem.ninja/docs/#mosaicDefinition} objects
 */
let mosaicDefinitions = function(endpoint, address){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/mosaic/owned/definition',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: { 'address': address }
	}
	// Send the request
	return Send(options);
}

/**
 * Gets mosaics that an account owns
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {array} - An array of [Mosaic]{@link http://bob.nem.ninja/docs/#mosaic} objects
 */
let mosaicsOwned = function(endpoint, address){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/mosaic/owned',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: { 'address': address }
	}
	// Send the request
	return Send(options);
}

/**
 * Gets all transactions of an account
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {string} txHash - The 256 bit sha3 hash of the transaction up to which transactions are returned. (optional)
 * @param {string} txId - The transaction id up to which transactions are returned. (optional)
 *
 * @return {array} - An array of [TransactionMetaDataPair]{@link http://bob.nem.ninja/docs/#transactionMetaDataPair} objects
 */
let allTransactions = function(endpoint, address, txHash, txId){
	// Arrange
	let params = {'address': address};
	if (txHash) params['hash'] = txHash;
	if (txId) params['id'] = txId;

	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/transfers/all',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: params
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the AccountMetaDataPair of an array of accounts.
 *
 * @param {string} endpoint - An NIS endpoint object
 * @param {array} addresses - An array of account addresses
 *
 * @return {object} - An object that contains an array of [AccountMetaDataPair]{@link http://bob.nem.ninja/docs/#accountMetaDataPair} objects
 */
let getBatchAccountData = function(endpoint, addresses){
	let obj = {
        'data':[]
    };
    for(var i = 0; i < addresses.length; i++){
        obj.data.push({'account':addresses[i]});
	}
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/get/batch',
	    method: 'POST',
	    json: true,
		body: obj
	}
	// Send the request
	return Send(options);
};

/**
 * Gets the AccountMetaDataPair of an array of accounts from an historical height.
 *
 * @param {string} endpoint - An NIS endpoint object
 * @param {array} addresses - An array of account addresses
 * @param {integer} block - The block height
 *
 * @return {object} - Account information for all the accounts on the given block
 */
let getBatchHistoricalAccountData = function(endpoint, addresses, block){
	let obj = {
        'accounts':[],
        'startHeight': block,
        'endHeight': block,
        'incrementBy': 1
    };
    for(var i = 0; i < addresses.length; i++){
        obj.accounts.push({'account':addresses[i]});
	}
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/historical/get/batch',
	    method: 'POST',
	    json: true,
		body: obj
	}
	// Send the request
	return Send(options);
};

/**
 * Gets the AccountMetaDataPair of an account from a certain block.
 *
 * @param {string} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 * @param {integer} block - the block height
 *
 * @return {object} - An [AccountMetaDataPair]{@link http://bob.nem.ninja/docs/#accountMetaDataPair} object
 */
let getHistoricalAccountData = function(endpoint, address, block) {
	let obj = {
        'params': {
            'address': address,
            'startHeight': block,
            'endHeight': block,
            'increment': 1
        }
	};
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/account/historical/get',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: obj
	}
	// Send the request
	return Send(options);
}

module.exports = {
	data,
	dataFromPublicKey,
	batchData: getBatchAccountData,
	historical: {
		data: getHistoricalAccountData,
		batchData: getBatchHistoricalAccountData
	},
	unlockInfo,
	forwarded,
	mosaics: {
		owned: mosaicsOwned,
		definitions: mosaicDefinitionsCreated,
		allDefinitions: mosaicDefinitions
	},
	namespaces: {
		owned: namespacesOwned
	},
	harvesting: {
		blocks: harvestedBlocks,
		start: startHarvesting,
		stop: stopHarvesting
	},
	transactions: {
		incoming: incomingTransactions,
		outgoing: outgoingTransactions,
		unconfirmed: unconfirmedTransactions,
		all: allTransactions
	}
}
'''
'''--- src/com/requests/apostille.js ---
import Send from './send';
import Headers from './headers';
import Nodes from '../../model/nodes';

/**
 * Audit an apostille file
 *
 * @param {string} publicKey - The signer public key
 * @param {string} data - The file data of audited file
 * @param {string} signedData - The signed data into the apostille transaction message
 *
 * @return {boolean} - True if valid, false otherwise
 */
let audit = function(publicKey, data, signedData) {
	// Configure the request
	var options = {
	    url: Nodes.apostilleAuditServer,
	    method: 'POST',
	    headers: Headers.urlEncoded,
	    qs: {'publicKey': publicKey, 'data': data,'signedData': signedData}
	}
	// Send the request
	return Send(options);
}

module.exports = {
	audit
}
'''
'''--- src/com/requests/chain.js ---
import Send from './send';
import Helpers from '../../utils/helpers';

/**
 * Gets the current height of the block chain.
 *
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {object} - A [BlockHeight]{@link http://bob.nem.ninja/docs/#block-chain-height} object
 */
let height = function (endpoint) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/chain/height',
	    method: 'GET'
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the current last block of the chain.
 *
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {object} -
 */
let lastBlock = function(endpoint){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/chain/last-block',
	    method: 'GET'
	}
	// Send the request
	return Send(options);
}

/**
 * Gets network time (in ms)
 *
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {object} - A [communicationTimeStamps]{@link http://bob.nem.ninja/docs/#communicationTimeStamps} object
 */
let time = function (endpoint) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/time-sync/network-time',
	    method: 'GET'
	}
	// Send the request
	return Send(options);
}

/**
 * Gets a block by its height
 *
 * @param {string} endpoint - An NIS endpoint object
 * @param {integer} height - The height of the block
 *
 * @return {object} - A block object
 */
let blockByHeight = function(endpoint, height){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/block/at/public',
	    method: 'POST',
	    json: true,
		body: {'height': height}
	}
	// Send the request
	return Send(options);
};

module.exports = {
	height,
	lastBlock,
	time,
	blockByHeight
}
'''
'''--- src/com/requests/endpoint.js ---
import Send from './send';
import Helpers from '../../utils/helpers';

/**
 * Determines if NIS is up and responsive.
 *
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {object} - A [NemRequestResult]{@link http://bob.nem.ninja/docs/#nemRequestResult} object
 */
let heartbeat = function(endpoint) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/heartbeat',
	    method: 'GET'
	}
	// Send the request
	return Send(options);
};

module.exports = {
	heartbeat
}
'''
'''--- src/com/requests/headers.js ---
/**
 * An url encoded header
 *
 * @type {object}
 */
const urlEncoded = {
	'Content-Type': 'application/x-www-form-urlencoded'
}

/**
 * Create an application/json header
 *
 * @param {data} - A json string
 *
 * @return {object} - An application/json header with content length
 */
let json = function(data) {
	return {
		"Content-Type": "application/json",
	    "Content-Length": Buffer.from(data).byteLength
	}
}

module.exports = {
	urlEncoded,
	json
}
'''
'''--- src/com/requests/index.js ---
import account from './account';
import apostille from './apostille';
import chain from './chain';
import endpoint from './endpoint';
import market from './market';
import mosaic from './mosaic';
import namespace from './namespace';
import supernodes from './supernodes';
import transaction from './transaction';

export default {
	account: account,
	apostille: apostille,
	chain: chain,
	endpoint: endpoint,
	market: market,
	mosaic: mosaic,
	namespace: namespace,
	supernodes: supernodes,
	transaction: transaction
}
'''
'''--- src/com/requests/market.js ---
import Send from './send';
import Headers from './headers';
import Nodes from '../../model/nodes';

/**
 * Gets market information from Poloniex api
 *
 * @return {object} - A MarketInfo object
 */
let xem = function(){
	// Configure the request
	var options = {
	    url: Nodes.marketInfo,
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'command': 'returnTicker'}
	}
	// Send the request
	return Send(options);
};

/**
 * Gets BTC price from blockchain.info API
 *
 * @return {object} - A MarketInfo object
 */
let btc = function(){
	// Configure the request
	var options = {
	    url: Nodes.btcPrice,
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'cors': true}
	}
	// Send the request
	return Send(options);
};

module.exports = {
	xem,
	btc
}
'''
'''--- src/com/requests/mosaic.js ---
import Send from './send';
import Headers from './headers';
import Helpers from '../../utils/helpers';

/**
 * Gets the current supply of a mosaic
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} id - A mosaic id
 *
 * @return {object} - A mosaicSupplyInfo object
 */
let supply = function(endpoint, id) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/mosaic/supply',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'mosaicId': id}
	}
	// Send the request
	return Send(options);
}

module.exports = {
	supply
}
'''
'''--- src/com/requests/namespace.js ---
import Send from './send';
import Headers from './headers';
import Helpers from '../../utils/helpers';

/**
 * Gets root namespaces.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {number} id - The namespace id up to which root namespaces are returned (optional)
 *
 * @return {object} - An array of [NamespaceMetaDataPair]{@link http://bob.nem.ninja/docs/#namespaceMetaDataPair} objects
 */
let roots = function(endpoint, id){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/namespace/root/page',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: undefined === id ? {'pageSize': 100} : { 'id': id, 'pageSize':100}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets mosaic definitions of a namespace
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} id - A namespace id
 *
 * @return {object} - An array of [MosaicDefinition]{@link http://bob.nem.ninja/docs/#mosaicDefinition} objects
 */
let mosaicDefinitions = function(endpoint, id){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/namespace/mosaic/definition/page',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'namespace': id}
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the namespace with given id.
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} id - A namespace id
 *
 * @return {object} - A [NamespaceInfo]{@link http://bob.nem.ninja/docs/#namespace} object
 */
let info = function(endpoint, id) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/namespace',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'namespace': id}
	}
	// Send the request
	return Send(options);
}

module.exports = {
	roots,
	mosaicDefinitions,
	info
}
'''
'''--- src/com/requests/send.js ---
import Helpers from '../../utils/helpers';
import Request from 'request';

/**
 * Send a request
 *
 * @param {object} options - The options of the request
 *
 * @return {Promise} - A resolved promise with the requested data or a rejection with error data
 */
let send = function(options) {
	return new Promise((resolve, reject) => {
		Request(options, function (error, response, body) {
			let data;
			if(Helpers.isJSON(body)) {
			    data = JSON.parse(body);
			} else {
			    data = body;
			}
		    if (!error && response.statusCode == 200) {
		        resolve(data);
		    } else {
		    	if(!error) {
		    		reject({"code": 0, "data": data});
		    	} else {
		    		reject({"code": -1, "data": error});
		    	}
		    }
		});
	});
}

export default send;
'''
'''--- src/com/requests/supernodes.js ---
import Send from './send';
import Nodes from '../../model/nodes';

/**
 * Gets all nodes of the node reward program
 *
 * @return {array} - An array of SuperNodeInfo objects
 */
let all = function(){
	// Configure the request
	var options = {
	    url: Nodes.supernodes,
	    method: 'GET'
	}
	// Send the request
	return Send(options);
};

/**
 * Gets the nearest supernodes
 *
 * @param {object} coords - A coordinates object: https://www.w3schools.com/html/html5_geolocation.asp
 *
 * @return {array} - An array of supernodeInfo objects
 */
let nearest = function(coords) {
    let obj = {
       "latitude": coords.latitude,
       "longitude": coords.longitude,
       "numNodes": 5
    }
    // Configure the request
	var options = {
	    url: 'http://199.217.113.179:7782/nodes/nearest',
	    method: 'POST',
	    json: true,
	    body: obj
	}
	// Send the request
	return Send(options);
}

/**
 * Gets the all supernodes by status
 *
 * @param {number} status - 0 for all nodes, 1 for active nodes, 2 for inactive nodes
 *
 * @return {array} - An array of supernodeInfo objects
 */
let get = function(status) {
    let obj = {
        "status": undefined === status ? 1 : status
    }
    // Configure the request
	var options = {
	    url: 'http://199.217.113.179:7782/nodes',
	    method: 'POST',
	    json: true,
	    body: obj
	}
	// Send the request
	return Send(options);
}

module.exports = {
	all,
	nearest,
	get
}
'''
'''--- src/com/requests/transaction.js ---
import Send from './send';
import Headers from './headers';
import Helpers from '../../utils/helpers';

/**
 * Broadcast a transaction to the NEM network
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {object} obj - A RequestAnnounce object
 *
 * @return {object} - A [NemAnnounceResult]{@link http://bob.nem.ninja/docs/#nemAnnounceResult} object
 */
let announce = function(endpoint, serializedTransaction) {
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/transaction/announce',
	    method: 'POST',
	    headers: Headers.json(serializedTransaction),
	    json: JSON.parse(serializedTransaction)
	}
	// Send the request
	return Send(options);
}

/**
 * Gets a TransactionMetaDataPair object from the chain using it's hash
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} txHash - A transaction hash
 *
 * @return {object} - A [TransactionMetaDataPair]{@link http://bob.nem.ninja/docs/#transactionMetaDataPair} object
 */
let byHash = function(endpoint, txHash){
	// Configure the request
	var options = {
	    url: Helpers.formatEndpoint(endpoint) + '/transaction/get',
	    method: 'GET',
	    headers: Headers.urlEncoded,
	    qs: {'hash': txHash}
	}
	// Send the request
	return Send(options);
}

module.exports = {
	announce,
	byHash
}
'''
'''--- src/com/websockets/account.js ---
import { SockJS as SockJSBrowser } from '../../external/sockjs-0.3.4';
import SockJSNode from 'sockjs-client';

/**
 * Check if socket is open
 *
 * @param {object} connector - A connector object
 *
 * @return {boolean} - True if open, false otherwise
 */
let checkReadyState = function(connector) {
    var self = connector;
    if (SockJSBrowser ? self.socket.readyState !== SockJSBrowser.OPEN : self.socket.readyState !== SockJSNode.OPEN) {
        return false;
    } 
    return true;
}

/**
 * Request the account data of the address in the given connector
 * You can optionally use an address directly to request data for a specific account
 *
 * @param {object} connector - A connector object
 * @param {string} address - A NEM account address (optional)
 *
 * @return the response in the subscription callback
 */
let requestAccountData = function(connector, address) {
    var self = connector;
    // If not ready, wait a bit more...
    if (!checkReadyState(connector)) {
        self.timeoutHandle = setTimeout(function() {
            requestAccountData(connector, address);
        }, 100);
    } else {
        // Use address if provided
        let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
        self.stompClient.send("/w/api/account/get", {}, "{'account':'" + _address + "'}");
    }
}

/**
 * Request the recent transactions of the address in the given connector
 * You can optionally use an address directly to request data for a specific account
 *
 * @param {object} connector - A connector object
 * @param {string} address - A NEM account address (optional)
 *
 * @return the response in the subscription callback
 */
let requestRecentTransactions = function(connector, address) {
	 var self = connector;
    // If not ready, wait a bit more...
    if (!checkReadyState(connector)) {
        self.timeoutHandle = setTimeout(function() {
            requestRecentTransactions(connector, address);
        }, 100);
    } else {
        // Use address if provided
        let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
        self.stompClient.send("/w/api/account/transfers/all", {}, "{'account':'" + _address + "'}");
    }
}

/**
 * Request the owned mosaic definitions of the address in the given connector
 * You can optionally use an address directly to request data for a specific account
 *
 * @param {object} connector - A connector object
 * @param {string} address - A NEM account address (optional)
 *
 * @return the response in the subscription callback
 */
let requestMosaicDefinitions = function(connector, address) {
     var self = connector;
    // If not ready, wait a bit more...
    if (!checkReadyState(connector)) {
        self.timeoutHandle = setTimeout(function() {
            requestMosaicDefinitions(connector, address);
        }, 100);
    } else {
        // Use address if provided
        let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
        self.stompClient.send("/w/api/account/mosaic/owned/definition", {}, "{'account':'" + _address + "'}");
    }
}

/**
 * Request the owned mosaics of the address in the given connector
 * You can optionally use an address directly to request data for a specific account
 *
 * @param {object} connector - A connector object
 * @param {string} address - A NEM account address (optional)
 *
 * @return the response in the subscription callback
 */
let requestMosaics = function(connector, address) {
     var self = connector;
    // If not ready, wait a bit more...
    if (!checkReadyState(connector)) {
        self.timeoutHandle = setTimeout(function() {
            requestMosaics(connector, address);
        }, 100);
    } else {
        // Use address if provided
        let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
        self.stompClient.send("/w/api/account/mosaic/owned", {}, "{'account':'" + _address + "'}");
    }
}

/**
 * Request the owned namespaces of the address in the given connector
 * You can optionally use an address directly to request data for a specific account
 *
 * @param {object} connector - A connector object
 * @param {string} address - A NEM account address (optional)
 *
 * @return the response in the subscription callback
 */
let requestNamespaces = function(connector, address) {
     var self = connector;
    // If not ready, wait a bit more...
    if (!checkReadyState(connector)) {
        self.timeoutHandle = setTimeout(function() {
            requestNamespaces(connector, address);
        }, 100);
    } else {
        // Use address if provided
        let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
        self.stompClient.send("/w/api/account/namespace/owned", {}, "{'account':'" + _address + "'}");
    }
}

/**
 * Subscribe to the account data channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeAccountData = function(connector, callback, address) {
	var self = connector;
	if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
	self.stompClient.subscribe('/account/' + _address, function(data) {
        callback(JSON.parse(data.body));
    });
}

/**
 * Subscribe to the recent transactions channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeRecentTransactions = function(connector, callback, address) {
	var self = connector;
	if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
	self.stompClient.subscribe('/recenttransactions/' + _address, function(data) {
        callback(JSON.parse(data.body));
    }); 
}

/**
 * Subscribe to the unconfirmed transactions channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeUnconfirmedTransactions = function(connector, callback, address) {
    var self = connector;
    if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
    self.stompClient.subscribe('/unconfirmed/' + _address, function(data) {
        callback(JSON.parse(data.body));
    });
}

/**
 * Subscribe to the confirmed transactions channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeConfirmedTransactions = function(connector, callback, address) {
    var self = connector;
    if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
    self.stompClient.subscribe('/transactions/' + _address, function(data) {
        callback(JSON.parse(data.body));
    });
}

/**
 * Subscribe to the mosaic definitions channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeMosaicDefinitions = function(connector, callback, address) {
    var self = connector;
    if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
    self.stompClient.subscribe('/account/mosaic/owned/definition/' + _address, function(data) {
        callback(JSON.parse(data.body));
    });
}

/**
 * Subscribe to the owned mosaics channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeMosaics = function(connector, callback, address) {
    var self = connector;
    if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
    self.stompClient.subscribe('/account/mosaic/owned/' + _address, function(data) {
        callback(JSON.parse(data.body), _address);
    });
}

/**
 * Subscribe to the owned namespaces channel for the address in the given connector 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 * @param {string} address - A NEM account address (optional)
 *
 * @return the received data in the callback
 */
let subscribeNamespaces = function(connector, callback, address) {
    var self = connector;
    if (!checkReadyState(connector)) {
        return false;
    }
    // Use address if provided
    let _address = undefined !== address ? address.replace(/-/g, "").toUpperCase() : self.address;
    self.stompClient.subscribe('/account/namespace/owned/' + _address, function(data) {
        callback(JSON.parse(data.body), _address);
    });
}

module.exports = {
	requests: {
		data: requestAccountData,
		transactions: {
			recent: requestRecentTransactions
		},
        mosaics: {
            owned: requestMosaics,
            definitions: requestMosaicDefinitions
        },
        namespaces: {
            owned: requestNamespaces
        }
	},
	subscribe: {
		data: subscribeAccountData,
		transactions: {
			recent: subscribeRecentTransactions,
            confirmed: subscribeConfirmedTransactions,
			unconfirmed: subscribeUnconfirmedTransactions
		},
        mosaics: {
            owned: subscribeMosaics,
            definitions: subscribeMosaicDefinitions
        },
        namespaces: {
            owned: subscribeNamespaces
        } 
	}
}
'''
'''--- src/com/websockets/chain.js ---
import { SockJS as SockJSBrowser } from '../../external/sockjs-0.3.4';
import SockJSNode from 'sockjs-client';

/**
 * Check if socket is open
 *
 * @param {object} connector - A connector object
 *
 * @return {boolean} - True if open, false otherwise
 */
let checkReadyState = function(connector) {
	var self = connector;
	if (SockJSBrowser ? self.socket.readyState !== SockJSBrowser.OPEN : self.socket.readyState !== SockJSNode.OPEN) {
        return false;
    } 
    return true;
}

/**
 * Subscribe to the new blocks channel 
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 *
 * @return the received data in the callback
 */
let subscribeNewBlocks = function(connector, callback) {
	var self = connector;
	if (!checkReadyState(connector)) {
        return false;
    }
	self.stompClient.subscribe('/blocks', function(data) {
        callback(JSON.parse(data.body));
    });
}

/**
 * Subscribe to the new height channel
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 *
 * @return the received data in the callback
 */
let subscribeNewHeight = function(connector, callback) {
	var self = connector;
	if (!checkReadyState(connector)) {
        return false;
    }
	self.stompClient.subscribe('/blocks/new', function(data) {
        callback(JSON.parse(data.body));
	});
}

module.exports = {
	requests: {
		
	},
	subscribe: {
		height: subscribeNewHeight,
		blocks: subscribeNewBlocks
	}	
}
'''
'''--- src/com/websockets/connector.js ---
import { SockJS as SockJSBrowser } from '../../external/sockjs-0.3.4';
import SockJSNode from 'sockjs-client';
import { Stomp } from '../../external/stomp';

/**
 * Create a connector object
 *
 * @param {object} endpoint - An NIS endpoint object
 * @param {string} address - An account address
 *
 * @return {object} - A connector object
 */
let create = function(endpoint, address) {
	return {
		endpoint: endpoint,
		address: address.replace(/-/g, "").toUpperCase(),
		socket: undefined,
        stompClient: undefined,
        connect: connect,
        close: close
	}
}

/**
 * Tries to establish a connection. 
 *
 * @return {promise} - A resolved or rejected promise
 */
let connect = function() {
	return new Promise((resolve, reject) => {
		var self = this;
		if (!SockJSBrowser) self.socket = new SockJSNode(self.endpoint.host + ':' + self.endpoint.port + '/w/messages');
		else self.socket = new SockJSBrowser(self.endpoint.host + ':' + self.endpoint.port + '/w/messages');
	    self.stompClient = Stomp.over(self.socket);
	    self.stompClient.debug = false;
	    self.stompClient.connect({}, function(frame) {
		    resolve(true);
	    }, (err) => {
		    reject("Connection failed!");
		});        	
	});
}

/**
 * Close a connection
 */
let close = function() {
    var self = this;
    console.log("Connection to "+ self.endpoint.host +" must be closed now.");
    self.socket.close();
    self.socket.onclose = function(e) {
        console.log(e);
    };
}

module.exports = {
	create
}
'''
'''--- src/com/websockets/errors.js ---
import { SockJS as SockJSBrowser } from '../../external/sockjs-0.3.4';
import SockJSNode from 'sockjs-client';

/**
 * Check if socket is open
 *
 * @param {object} connector - A connector object
 *
 * @return {boolean} - True if open, false otherwise
 */
let checkReadyState = function(connector) {
	var self = connector;
	if (SockJSBrowser ? self.socket.readyState !== SockJSBrowser.OPEN : self.socket.readyState !== SockJSNode.OPEN) {
        return false;
    } 
    return true;
}

/**
 * Subscribe to errors channel
 *
 * @param {object} connector - A connector object
 * @param {function} callback - A callback function where data will be received
 *
 * @return the received data in the callback
 */
let subscribe = function(connector, callback) {
	var self = connector;
	if (!checkReadyState(connector)) {
        return false;
    }
	self.stompClient.subscribe('/errors', function(data) {
        callback(JSON.parse(data.body));
    });
}

module.exports = {
	subscribe: subscribe
}
'''
'''--- src/com/websockets/index.js ---
import connector from './connector';
import account from './account';
import chain from './chain';
import errors from './errors';

export default {
	connector: connector,
	requests: {
		account: account.requests,
		chain: chain.requests
	},
	subscribe: {
		account: account.subscribe,
		chain: chain.subscribe,
		errors: errors.subscribe
	}
}
'''
'''--- src/crypto/cryptoHelpers.js ---
import KeyPair from './keyPair';
import convert from '../utils/convert';
import Address from '../model/address';
import nacl from '../external/nacl-fast';
import Network from '../model/network';
import CryptoJS from 'crypto-js';
import Helpers from '../utils/helpers';

/**
 * Encrypt a private key for mobile apps (AES_PBKF2)
 *
 * @param {string} password - A wallet password
 * @param {string} privateKey - An account private key
 *
 * @return {object} - The encrypted data
 */
let toMobileKey = function(password, privateKey) {
    // Errors
    if (!password || !privateKey) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(privateKey)) throw new Error('Private key is not valid !');
    // Processing
    let salt = CryptoJS.lib.WordArray.random(256 / 8);
    let key = CryptoJS.PBKDF2(password, salt, {
        keySize: 256 / 32,
        iterations: 2000
    });
    let iv = nacl.randomBytes(16)
    let encIv = {
        iv: convert.ua2words(iv, 16)
    };
    let encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Hex.parse(privateKey), key, encIv);
    // Result
    return {
        encrypted: convert.ua2hex(iv) + encrypted.ciphertext,
        salt:  salt.toString()
    }
};

/**
 * Derive a private key from a password using count iterations of SHA3-256
 *
 * @param {string} password - A wallet password
 * @param {number} count - A number of iterations above 0
 *
 * @return {object} - The derived private key
 */
let derivePassSha = function(password, count) {
    // Errors
    if(!password) throw new Error('Missing argument !');
    if(!count || count <= 0) throw new Error('Please provide a count number above 0');
    // Processing
    let data = password;
    console.time('sha3^n generation time');
    for (let i = 0; i < count; ++i) {
        data = CryptoJS.SHA3(data, {
            outputLength: 256
        });
    }
    console.timeEnd('sha3^n generation time');
    // Result
    return {
        'priv': CryptoJS.enc.Hex.stringify(data)
    };
};

/**
 * Reveal the private key of an account or derive it from the wallet password
 *
 * @param {object} common- An object containing password and privateKey field
 * @param {object} walletAccount - A wallet account object
 * @param {string} algo - A wallet algorithm
 *
 * @return {object|boolean} - The account private key in and object or false
 */
let passwordToPrivatekey = function(common, walletAccount, algo) {
    // Errors
    if(!common || !walletAccount || !algo) throw new Error('Missing argument !');

    let r = undefined;

    if (algo === "trezor" || algo === "ledger") { // HW wallet
        r = { 'priv': '' };
        common.isHW = true;
    } else if (!common.password) {
        throw new Error('Missing argument !');
    }

    // Processing
    if (algo === "pass:6k") { // Brain wallets
        if (!walletAccount.encrypted && !walletAccount.iv) {
            // Account private key is generated simply using a passphrase so it has no encrypted and iv
            r = derivePassSha(common.password, 6000);
        } else if (!walletAccount.encrypted || !walletAccount.iv) {
            // Else if one is missing there is a problem
            //console.log("Account might be compromised, missing encrypted or iv");
            return false;
        } else {
            // Else child accounts have encrypted and iv so we decrypt
            let pass = derivePassSha(common.password, 20);
            let obj = {
                ciphertext: CryptoJS.enc.Hex.parse(walletAccount.encrypted),
                iv: convert.hex2ua(walletAccount.iv),
                key: convert.hex2ua(pass.priv)
            };
            let d = decrypt(obj);
            r = { 'priv': d };
        }
    } else if (algo === "pass:bip32") { // Wallets from PRNG
        let pass = derivePassSha(common.password, 20);
        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(walletAccount.encrypted),
            iv: convert.hex2ua(walletAccount.iv),
            key: convert.hex2ua(pass.priv)
        };
        let d = decrypt(obj);
        r = { 'priv': d };
    } else if (algo === "pass:enc") { // Private Key wallets
        let pass = derivePassSha(common.password, 20);
        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(walletAccount.encrypted),
            iv: convert.hex2ua(walletAccount.iv),
            key: convert.hex2ua(pass.priv)
        };
        let d = decrypt(obj);
        r = { 'priv': d };
    } else if (!r) {
        //console.log("Unknown wallet encryption method");
        return false;
    }
    // Result
    common.privateKey = r.priv;
    return true;
}

/**
 * Check if a private key correspond to an account address
 *
 * @param {string} priv - An account private key
 * @param {number} network - A network id
 * @param {string} _expectedAddress - The expected NEM address
 *
 * @return {boolean} - True if valid, false otherwise
 */
let checkAddress = function(priv, network, _expectedAddress) {
    // Errors
    if (!priv || !network || !_expectedAddress) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(priv)) throw new Error('Private key is not valid !');
    //Processing
    let expectedAddress = _expectedAddress.toUpperCase().replace(/-/g, '');
    let kp = KeyPair.create(priv);
    let address = Address.toAddress(kp.publicKey.toString(), network);
    // Result
    return address === expectedAddress;
};

function hashfunc(dest, data, dataLength) {
    let convertedData = convert.ua2words(data, dataLength);
    let hash = CryptoJS.SHA3(convertedData, {
        outputLength: 512
    });
    convert.words2ua(dest, hash);
}

function key_derive(shared, salt, sk, pk) {
    nacl.lowlevel.crypto_shared_key_hash(shared, pk, sk, hashfunc);
    for (let i = 0; i < salt.length; i++) {
        shared[i] ^= salt[i];
    }
    let hash = CryptoJS.SHA3(convert.ua2words(shared, 32), {
        outputLength: 256
    });
    return hash;
}

/**
 * Generate a random key
 *
 * @return {Uint8Array} - A random key
 */
let randomKey = function() {
    let rkey = nacl.randomBytes(32)
    return rkey;
};

/**
 * Encrypt hex data using a key
 *
 * @param {string} data - An hex string
 * @param {Uint8Array} key - An Uint8Array key
 *
 * @return {object} - The encrypted data
 */
let encrypt = function(data, key) {
    // Errors
    if (!data || !key) throw new Error('Missing argument !');
    // Processing
    let iv = nacl.randomBytes(16)
    let encKey = convert.ua2words(key, 32);
    let encIv = {
        iv: convert.ua2words(iv, 16)
    };
    let encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Hex.parse(data), encKey, encIv);
    // Result
    return {
        ciphertext: encrypted.ciphertext,
        iv: iv,
        key: key
    };
};

/**
 * Decrypt data
 *
 * @param {object} data - An encrypted data object
 *
 * @return {string} - The decrypted hex string
 */
let decrypt = function(data) {
    // Errors
    if (!data) throw new Error('Missing argument !');
    // Processing
    let encKey = convert.ua2words(data.key, 32);
    let encIv = {
        iv: convert.ua2words(data.iv, 16)
    };
    // Result
    return CryptoJS.enc.Hex.stringify(CryptoJS.AES.decrypt(data, encKey, encIv));
};

/**
 * Encode a private key using a password
 *
 * @param {string} privateKey - An hex private key
 * @param {string} password - A password
 *
 * @return {object} - The encoded data
 */
let encodePrivKey = function(privateKey, password) {
    // Errors
    if (!privateKey || !password) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(privateKey)) throw new Error('Private key is not valid !');
    // Processing
    let pass = derivePassSha(password, 20);
    let r = encrypt(privateKey, convert.hex2ua(pass.priv));
    // Result
    return {
        ciphertext: CryptoJS.enc.Hex.stringify(r.ciphertext),
        iv: convert.ua2hex(r.iv)
    };
};

/***
 * Encode a message, separated from encode() to help testing
 *
 * @param {string} senderPriv - A sender private key
 * @param {string} recipientPub - A recipient public key
 * @param {string} msg - A text message
 * @param {Uint8Array} iv - An initialization vector
 * @param {Uint8Array} salt - A salt
 *
 * @return {string} - The encoded message
 */
let _encode = function(senderPriv, recipientPub, msg, iv, salt) {
    // Errors
    if (!senderPriv || !recipientPub || !msg || !iv || !salt) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(senderPriv)) throw new Error('Private key is not valid !');
    if (!Helpers.isPublicKeyValid(recipientPub)) throw new Error('Public key is not valid !');
    // Processing
    let sk = convert.hex2ua_reversed(senderPriv);
    let pk = convert.hex2ua(recipientPub);
    let shared = new Uint8Array(32);
    let r = key_derive(shared, salt, sk, pk);
    let encKey = r;
    let encIv = {
        iv: convert.ua2words(iv, 16)
    };
    let encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Hex.parse(convert.utf8ToHex(msg)), encKey, encIv);
    // Result
    let result = convert.ua2hex(salt) + convert.ua2hex(iv) + CryptoJS.enc.Hex.stringify(encrypted.ciphertext);
    return result;
};

/**
 * Encode a message
 *
 * @param {string} senderPriv - A sender private key
 * @param {string} recipientPub - A recipient public key
 * @param {string} msg - A text message
 *
 * @return {string} - The encoded message
 */
let encode = function(senderPriv, recipientPub, msg) {
    // Errors
    if (!senderPriv || !recipientPub || !msg) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(senderPriv)) throw new Error('Private key is not valid !');
    if (!Helpers.isPublicKeyValid(recipientPub)) throw new Error('Public key is not valid !');
    // Processing
    let iv = nacl.randomBytes(16)
    //console.log("IV:", convert.ua2hex(iv));
    let salt = nacl.randomBytes(32)
    let encoded = _encode(senderPriv, recipientPub, msg, iv, salt);
    // Result
    return encoded;
};

/**
 * Decode an encrypted message payload
 *
 * @param {string} recipientPrivate - A recipient private key
 * @param {string} senderPublic - A sender public key
 * @param {string} _payload - An encrypted message payload
 *
 * @return {string} - The decoded payload as hex
 */
let decode = function(recipientPrivate, senderPublic, _payload) {
    // Errors
    if(!recipientPrivate || !senderPublic || !_payload) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(recipientPrivate)) throw new Error('Private key is not valid !');
    if (!Helpers.isPublicKeyValid(senderPublic)) throw new Error('Public key is not valid !');
    // Processing
    let binPayload = convert.hex2ua(_payload);
    let salt = new Uint8Array(binPayload.buffer, 0, 32);
    let iv = new Uint8Array(binPayload.buffer, 32, 16);
    let payload = new Uint8Array(binPayload.buffer, 48);
    let sk = convert.hex2ua_reversed(recipientPrivate);
    let pk = convert.hex2ua(senderPublic);
    let shared = new Uint8Array(32);
    let r = key_derive(shared, salt, sk, pk);
    let encKey = r;
    let encIv = {
        iv: convert.ua2words(iv, 16)
    };
    let encrypted = {
        'ciphertext': convert.ua2words(payload, payload.length)
    };
    let plain = CryptoJS.AES.decrypt(encrypted, encKey, encIv);
    // Result
    let hexplain = CryptoJS.enc.Hex.stringify(plain);
    return hexplain;
};

module.exports = {
    toMobileKey,
    derivePassSha,
    passwordToPrivatekey,
    checkAddress,
    randomKey,
    decrypt,
    encrypt,
    encodePrivKey,
    _encode,
    encode,
    decode
}

'''
'''--- src/crypto/keyPair.js ---
import nacl from '../external/nacl-fast';
import convert from '../utils/convert';
import Helpers from '../utils/helpers';
import CryptoJS from 'crypto-js';

/***
* Create a BinaryKey object
*
* @param {Uint8Array} keyData - A key data
*/
let BinaryKey = function(keyData) {
    this.data = keyData;
    this.toString = function() {
        return convert.ua2hex(this.data);
    }
}

let hashfunc = function(dest, data, dataLength) {
    let convertedData = convert.ua2words(data, dataLength);
    let hash = CryptoJS.SHA3(convertedData, {
        outputLength: 512
    });
    convert.words2ua(dest, hash);
}

/***
* Create an hasher object
*/
let hashobj = function() {
    this.sha3 = CryptoJS.algo.SHA3.create({
        outputLength: 512
    });
    this.reset = function() {
        this.sha3 = CryptoJS.algo.SHA3.create({
            outputLength: 512
        });
    }

    this.update = function(data) {
        if (data instanceof BinaryKey) {
            let converted = convert.ua2words(data.data, data.data.length);
            let result = CryptoJS.enc.Hex.stringify(converted);
            this.sha3.update(converted);

        } else if (data instanceof Uint8Array) {
            let converted = convert.ua2words(data, data.length);
            this.sha3.update(converted);

        } else if (typeof data === "string") {
            let converted = CryptoJS.enc.Hex.parse(data);
            this.sha3.update(converted);

        } else {
            throw new Error("unhandled argument");
        }
    }

    this.finalize = function(result) {
        let hash = this.sha3.finalize();
        convert.words2ua(result, hash);
    };
}

/***
* Create a KeyPair Object 
*
* @param {string} privkey - An hex private key
*/
let KeyPair = function(privkey) {
    this.publicKey = new BinaryKey(new Uint8Array(nacl.lowlevel.crypto_sign_PUBLICKEYBYTES));
    this.secretKey = convert.hex2ua_reversed(privkey);
    nacl.lowlevel.crypto_sign_keypair_hash(this.publicKey.data, this.secretKey, hashfunc);

    // Signature
    this.sign = (data) => {
        let sig = new Uint8Array(64);
        let hasher = new hashobj();
        let r = nacl.lowlevel.crypto_sign_hash(sig, this, data, hasher);
        if (!r) {
            alert("Couldn't sign the tx, generated invalid signature");
            throw new Error("Couldn't sign the tx, generated invalid signature");
        }
        return new BinaryKey(sig);
    }
}

/**
* Create a NEM KeyPair
*
* @param {string} hexdata - An hex private key
*
* @return {object} - The NEM KeyPair object
*/
let create = function(hexdata) {
    // Errors
    if(!hexdata) throw new Error('Missing argument !');
    if (!Helpers.isPrivateKeyValid(hexdata)) throw new Error('Private key is not valid !');
    // Processing
    let r = new KeyPair(hexdata);
    // Result
    return r;
}

/**
 * Verify a signature.
 *
 * @param {string} publicKey - The public key to use for verification.
 * @param {string} data - The data to verify.
 * @param {string} signature - The signature to verify.
 *
 * @return {boolean}  - True if the signature is valid, false otherwise.
 */
let verifySignature = function(publicKey, data, signature) {
    // Errors
    if(!publicKey || !data || !signature) throw new Error('Missing argument !');
    if (!Helpers.isPublicKeyValid(publicKey)) throw new Error('Public key is not valid !');
    
    if (!Helpers.isHexadecimal(signature)) {
        //console.error('Signature must be hexadecimal only !');
        return false;
    }
    if (signature.length !== 128) {
        //console.error('Signature length is incorrect !') 
        return false;
    }

    // Create an hasher object
    let hasher = new hashobj();
    // Convert public key to Uint8Array
    let _pk = convert.hex2ua(publicKey);
    // Convert signature to Uint8Array
    let _signature = convert.hex2ua(signature);

    const c = nacl;
    const p = [c.gf(), c.gf(), c.gf(), c.gf()];
    const q = [c.gf(), c.gf(), c.gf(), c.gf()];

    if (c.unpackneg(q, _pk)) return false;

    const h = new Uint8Array(64);
    hasher.reset();
    hasher.update(_signature.subarray(0, 64/2));
    hasher.update(_pk);
    hasher.update(data);
    hasher.finalize(h);

    c.reduce(h);
    c.scalarmult(p, q, h);

    const t = new Uint8Array(64);
    c.scalarbase(q, _signature.subarray(64/2));
    c.add(p, q);
    c.pack(t, p);

    return 0 === nacl.lowlevel.crypto_verify_32(_signature, 0, t, 0);
}

module.exports = {
    create,
    verifySignature
}

'''
'''--- src/external/nacl-fast.js ---
(function(nacl) {
'use strict';

// polyfill for TypedArray.prototype.slice()
Uint8Array.prototype.slice = function(start, end) {
	var len = this.length;
	var relativeStart = start;
	var k = (relativeStart < 0) ? max(len + relativeStart, 0) : Math.min(relativeStart, len);
	var relativeEnd = (end === undefined) ? len : end;
	var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
	var count = final - k;
	var c = this.constructor;
	var a = new c(count);
	var n = 0;
	while (k < final) {
	    a[n] = JSON.parse(JSON.stringify(this[k]));
	    k++;
	    n++;
	}
	return a;
}

Float64Array.prototype.slice = function(start, end) {
	var len = this.length;
	var relativeStart = start;
	var k = (relativeStart < 0) ? max(len + relativeStart, 0) : Math.min(relativeStart, len);
	var relativeEnd = (end === undefined) ? len : end;
	var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
	var count = final - k;
	var c = this.constructor;
	var a = new c(count);
	var n = 0;
	while (k < final) {
	    a[n] = JSON.parse(JSON.stringify(this[k]));
	    k++;
	    n++;
	}
	return a;
}

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair_hash(pk, sk, hashfunc) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  hashfunc(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

function crypto_shared_key_hash(shared, pk, sk, hashfunc) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];

  hashfunc(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var q = [gf(), gf(), gf(), gf()];
  unpack(q, pk);
  scalarmult(p, q, d);
  pack(shared, p);
}

function crypto_sign_hash(sm, keypair, data, hasher) {
  var privHash = new Uint8Array(64);
  var seededHash = new Uint8Array(64);
  var result = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  hasher.update(keypair.secretKey);
  hasher.finalize(privHash);

  privHash[0] &= 248;
  privHash[31] &= 127;
  privHash[31] |= 64;

  hasher.reset();
  hasher.update(privHash.slice(32));
  hasher.update(data);
  hasher.finalize(seededHash);

  reduce(seededHash);
  scalarbase(p, seededHash);
  pack(sm, p);
  
  hasher.reset();
  hasher.update(sm.slice(0, 32));
  hasher.update(keypair.publicKey)
  hasher.update(data);
  hasher.finalize(result);

  reduce(result);
  

  // muladd - this is from original tweetnacl-js
  var x = new Float64Array(64);
  for (var i = 0; i < 64; i++) x[i] = 0;
  for (var i = 0; i < 32; i++) x[i] = seededHash[i];
  for (var i = 0; i < 32; i++) {
    for (var j = 0; j < 32; j++) {
      x[i+j] += result[i] * privHash[j];
    }
  }
  modL(sm.subarray(32), x);

  // check if zero
  var isZero = 0;
  for (var i = 0; i < 32; i++)
  {
	  isZero |= sm[32+i] ^ 0;
	  result[i] = sm[32+i];
  }

  if (isZero == 0)
	  return false;

  reduce(result);

  // check if canonical
  isZero = 0;
  for (var i = 0; i < 32; i++)
  {
	  isZero |= sm[32+i] ^ result[i];
  }
  return isZero == 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);

  // num = u = y^2 - 1
  // den = v = d * y^2 + 1
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  // r[0] = x = sqrt(u / v)
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    M(r[0], r[0], I);
  }

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    return -1;
  }

  if (par25519(r[0]) === (p[31]>>7)) {
    Z(r[0], gf0, r[0]);
  }

  M(r[3], r[0], r[1]);
  return 0;
}

function unpack(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);

  // num = u = y^2 - 1
  // den = v = d * y^2 + 1
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  // r[0] = x = sqrt(u / v)
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    M(r[0], r[0], I);
  }

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    console.log("not a valid Ed25519EncodedGroupElement.");
    return -1;
  }

  if (par25519(r[0]) !== (p[31]>>7)) {
    Z(r[0], gf0, r[0]);
  }

  M(r[3], r[0], r[1]);
  return 0;
}
var 
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  mlen = -1;
  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  mlen = n;
  return mlen;
};

nacl.lowlevel = {
  crypto_verify_32: crypto_verify_32,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_sign_keypair_hash: crypto_sign_keypair_hash,
  crypto_shared_key_hash: crypto_shared_key_hash,
  crypto_sign_hash: crypto_sign_hash,

  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

/*/////////////////////////////////////////////// High-level API ///////////////////////////////////////// */

function checkArrayTypes() {
  var t, i;
  for (i = 0; i < arguments.length; i++) {
     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

// For signature verification in KeyPair.js
nacl.gf = gf;
nacl.unpackneg = unpackneg;
nacl.reduce = reduce;
nacl.scalarmult = scalarmult;
nacl.scalarbase = scalarbase;
nacl.add = add;
nacl.pack = pack;

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto;
  if (typeof window !== 'undefined') {
    // Browser.
    if (window.crypto && window.crypto.getRandomValues) {
      crypto = window.crypto; // Standard
    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
      crypto = window.msCrypto; // Internet Explorer 11+
    }
    if (crypto) {
      nacl.setPRNG(function(x, n) {
        var i, v = new Uint8Array(n);
        crypto.getRandomValues(v);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.exports ? module.exports : (window.nacl = window.nacl || {}));

'''
'''--- src/external/sockjs-0.3.4.js ---
/* SockJS client, version 0.3.4, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()

//     [*] Including lib/index.js
// Public object
var SockJS = (function(){
            if(typeof document === "undefined" || typeof window === "undefined") {
                return null;
            }
              var _document = document;
              var _window = window;
              var utils = {};

//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js

//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js

//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    var that = this;
    that._events = events || [];
    that._listeners = {};
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    that._verifyType(type);
    if (that._nuked) return;

    var args = Array.prototype.slice.call(arguments, 1);
    if (that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (type in that._listeners) {
        for(var i = 0; i < that._listeners[type].length; i++) {
            that._listeners[type][i].apply(that, args);
        }
    }
};

EventEmitter.prototype.on = function(type, callback) {
    var that = this;
    that._verifyType(type);
    if (that._nuked) return;

    if (!(type in that._listeners)) {
        that._listeners[type] = [];
    }
    that._listeners[type].push(callback);
};

EventEmitter.prototype._verifyType = function(type) {
    var that = this;
    if (utils.arrIndexOf(that._events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that._events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function() {
    var that = this;
    that._nuked = true;
    for(var i=0; i<that._events.length; i++) {
        delete that[that._events[i]];
    }
    that._listeners = {};
};
//         [*] End of lib/eventemitter.js

//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};

// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js

//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};

utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};

var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};

utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js

//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) status = 204;

                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                var status = x.status;
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) status = 204;

                that.emit('finish', status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js

//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === _window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.4";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js

//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js

//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {
            that.send_stop = null;
            if (success === false) {
                that.ri._didClose(1006, 'Sending error ' + abort_reason);
            } else {
                that.send_schedule_wait();
            }
        });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        // It is not possible to detect if the iframe succeeded or
        // failed to submit our form.
        callback(true);
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status === 200 || status === 204,
                     'http status ' + status);
        };
        return function(abort_reason) {
            callback(false, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js

//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            // Unfortunately, you can't really abort script loading of
            // the script.
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js

//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;

JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};

// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);

    // Unfortunately it is not possible to abort loading of the
    // script. We need to keep track of frake close frames.
    var aborting = 0;

    // Callback will be called exactly once.
    var callback = function(frame) {
        switch(aborting) {
        case 0:
            // Normal behaviour - delete hook _and_ emit message.
            delete _window[WPrefix][id];
            user_callback(frame);
            break;
        case 1:
            // Fake close frame - emit but don't delete hook.
            user_callback(frame);
            aborting = 2;
            break;
        case 2:
            // Got frame after connection was closed, delete hook, don't emit.
            delete _window[WPrefix][id];
            break;
        }
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            aborting = 1;
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js

//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax

// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js

//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js

//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js

//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);

var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        // XHRLocalObject -> no_credentials=true
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};

var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js

//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource

// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js

//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr

// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js

//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile

// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js

//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js

//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js

//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};

var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js

//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js

//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                
                return SockJS;
                
          })();

if (typeof window !== 'undefined' && '_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

if (typeof exports !== "undefined" && exports !== null) {
    exports.SockJS = SockJS;
  }
//     [*] End of lib/index.js

// [*] End of lib/all.js

'''
'''--- src/external/stomp.js ---
// Generated by CoffeeScript 1.7.1

/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */

(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = (function() {
    var unmarshallSingle;

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, skipContentLength, value, _ref;
      lines = [this.command];
      skipContentLength = this.headers['content-length'] === false ? true : false;
      if (skipContentLength) {
        delete this.headers['content-length'];
      }
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body && !skipContentLength) {
        lines.push("content-length:" + (Frame.sizeOfUTF8(this.body)));
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame.sizeOfUTF8 = function(s) {
      if (s) {
        return encodeURI(s).match(/%..|./g).length;
      } else {
        return 0;
      }
    };

    unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      _ref = headerLines.reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var frame, frames, last_frame, r;
      frames = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
      r = {
        frames: [],
        partial: ''
      };
      r.frames = (function() {
        var _i, _len, _ref, _results;
        _ref = frames.slice(0, -1);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          frame = _ref[_i];
          _results.push(unmarshallSingle(frame));
        }
        return _results;
      })();
      last_frame = frames.slice(-1)[0];
      if (last_frame === Byte.LF || (last_frame.search(RegExp("" + Byte.NULL + Byte.LF + "*$"))) !== -1) {
        r.frames.push(unmarshallSingle(last_frame));
      } else {
        r.partial = last_frame;
      }
      return r;
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {
    var now;

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.maxWebSocketFrameSize = 16 * 1024;
      this.subscriptions = {};
      this.partialData = '';
    }

    Client.prototype.debug = function(message) {
      var _ref;
      return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
    };

    now = function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf;
      }
    };

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      while (true) {
        if (out.length > this.maxWebSocketFrameSize) {
          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
          out = out.substring(this.maxWebSocketFrameSize);
          if (typeof this.debug === "function") {
            this.debug("remaining = " + out.length);
          }
        } else {
          return this.ws.send(out);
        }
      }
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            _this.ws.send(Byte.LF);
            return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
          };
        })(this));
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = Stomp.setInterval(ttl, (function(_this) {
          return function() {
            var delta;
            delta = now() - _this.serverActivity;
            if (delta > ttl * 2) {
              if (typeof _this.debug === "function") {
                _this.debug("did not receive server activity for the last " + delta + "ms");
              }
              return _this.ws.close();
            }
          };
        })(this));
      }
    };

    Client.prototype._parseConnect = function() {
      var args, connectCallback, errorCallback, headers;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      headers = {};
      switch (args.length) {
        case 2:
          headers = args[0], connectCallback = args[1];
          break;
        case 3:
          if (args[1] instanceof Function) {
            headers = args[0], connectCallback = args[1], errorCallback = args[2];
          } else {
            headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
          }
          break;
        case 4:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
          break;
        default:
          headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
      }
      return [headers, connectCallback, errorCallback];
    };

    Client.prototype.connect = function() {
      var args, errorCallback, headers, out;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      out = this._parseConnect.apply(this, args);
      headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = (function(_this) {
        return function(evt) {
          var arr, c, client, data, frame, messageID, onreceive, subscription, unmarshalledData, _i, _len, _ref, _results;
          data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              c = arr[_i];
              _results.push(String.fromCharCode(c));
            }
            return _results;
          })()).join('')) : evt.data;
          _this.serverActivity = now();
          if (data === Byte.LF) {
            if (typeof _this.debug === "function") {
              _this.debug("<<< PONG");
            }
            return;
          }
          if (typeof _this.debug === "function") {
            _this.debug("<<< " + data);
          }
          unmarshalledData = Frame.unmarshall(_this.partialData + data);
          _this.partialData = unmarshalledData.partial;
          _ref = unmarshalledData.frames;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            frame = _ref[_i];
            switch (frame.command) {
              case "CONNECTED":
                if (typeof _this.debug === "function") {
                  _this.debug("connected to server " + frame.headers.server);
                }
                _this.connected = true;
                _this._setupHeartbeat(frame.headers);
                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                break;
              case "MESSAGE":
                subscription = frame.headers.subscription;
                onreceive = _this.subscriptions[subscription] || _this.onreceive;
                if (onreceive) {
                  client = _this;
                  messageID = frame.headers["message-id"];
                  frame.ack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.ack(messageID, subscription, headers);
                  };
                  frame.nack = function(headers) {
                    if (headers == null) {
                      headers = {};
                    }
                    return client.nack(messageID, subscription, headers);
                  };
                  _results.push(onreceive(frame));
                } else {
                  _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                }
                break;
              case "RECEIPT":
                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                break;
              case "ERROR":
                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                break;
              default:
                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
            }
          }
          return _results;
        };
      })(this);
      this.ws.onclose = (function(_this) {
        return function() {
          var msg;
          msg = "Whoops! Lost connection to " + _this.ws.url;
          if (typeof _this.debug === "function") {
            _this.debug(msg);
          }
          _this._cleanUp();
          return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
        };
      })(this);
      return this.ws.onopen = (function(_this) {
        return function() {
          if (typeof _this.debug === "function") {
            _this.debug('Web Socket Opened...');
          }
          headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
          headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
          return _this._transmit("CONNECT", headers);
        };
      })(this);
    };

    Client.prototype.disconnect = function(disconnectCallback, headers) {
      if (headers == null) {
        headers = {};
      }
      this._transmit("DISCONNECT", headers);
      this.ws.onclose = null;
      this.ws.close();
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.connected = false;
      if (this.pinger) {
        Stomp.clearInterval(this.pinger);
      }
      if (this.ponger) {
        return Stomp.clearInterval(this.ponger);
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      var client;
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      client = this;
      return {
        id: headers.id,
        unsubscribe: function() {
          return client.unsubscribe(headers.id);
        }
      };
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      var client, txid;
      txid = transaction || "tx-" + this.counter++;
      this._transmit("BEGIN", {
        transaction: txid
      });
      client = this;
      return {
        id: txid,
        commit: function() {
          return client.commit(txid);
        },
        abort: function() {
          return client.abort(txid);
        }
      };
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;

  })();

  Stomp = {
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return '1.1,1.0';
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Stomp = Stomp;
  }

  if (typeof window !== "undefined" && window !== null) {
    Stomp.setInterval = function(interval, f) {
      return window.setInterval(f, interval);
    };
    Stomp.clearInterval = function(id) {
      return window.clearInterval(id);
    };
    window.Stomp = Stomp;
  } else if (!exports) {
    self.Stomp = Stomp;
  }

}).call(this);

'''
'''--- src/index.js ---
import { create as createKeyPair } from './crypto/keyPair';
import { verifySignature } from './crypto/keyPair';
import address from './model/address';
import convert from './utils/convert';
import format from './utils/format';
import nacl from './external/nacl-fast';
import network from './model/network';
import cryptoHelpers from './crypto/cryptoHelpers';
import helpers from './utils/helpers';
import nty from './utils/nty';
import serialization from './utils/serialization';
import transactionTypes from './model/transactionTypes';
import nodes from './model/nodes';
import sinks from './model/sinks';
import wallet from './model/wallet';
import transactions from './model/transactions';
import objects from './model/objects';
import requests from './com/requests';
import fees from './model/fees';
import CryptoJS from 'crypto-js';
import websockets from './com/websockets';
import apostille from './model/apostille';

export default {
	crypto: {
		keyPair: {
			create: createKeyPair
		},
		helpers: cryptoHelpers,
		nacl,
		js: CryptoJS,
		verifySignature: verifySignature
	},
	model: {
		address,
		network,
		nodes,
		transactionTypes,
		sinks,
		wallet,
		transactions,
		objects,
		fees,
		apostille
	},
	utils: {
		convert,
		helpers,
		nty,
		serialization,
		format
	},
	com: {
		requests,
		websockets
	}
};

'''
'''--- src/model/address.js ---
import convert from '../utils/convert';
import Network from './network';
import CryptoJS from 'crypto-js';

const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

/**
* Encode a string to base32
*
* @param {string} s - A string
*
* @return {string} - The encoded string
*/
let b32encode = function(s) {
    let parts = [];
    let quanta = Math.floor((s.length / 5));
    let leftover = s.length % 5;

    if (leftover != 0) {
        for (let i = 0; i < (5 - leftover); i++) {
            s += '\x00';
        }
        quanta += 1;
    }

    for (let i = 0; i < quanta; i++) {
        parts.push(alphabet.charAt(s.charCodeAt(i * 5) >> 3));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5) & 0x07) << 2) | (s.charCodeAt(i * 5 + 1) >> 6)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 1) & 0x3F) >> 1)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 1) & 0x01) << 4) | (s.charCodeAt(i * 5 + 2) >> 4)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 2) & 0x0F) << 1) | (s.charCodeAt(i * 5 + 3) >> 7)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 3) & 0x7F) >> 2)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 3) & 0x03) << 3) | (s.charCodeAt(i * 5 + 4) >> 5)));
        parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 4) & 0x1F))));
    }

    let replace = 0;
    if (leftover == 1) replace = 6;
    else if (leftover == 2) replace = 4;
    else if (leftover == 3) replace = 3;
    else if (leftover == 4) replace = 1;

    for (let i = 0; i < replace; i++) parts.pop();
    for (let i = 0; i < replace; i++) parts.push("=");

    return parts.join("");
}

/**
* Decode a base32 string.
* This is made specifically for our use, deals only with proper strings
*
* @param {string} s - A base32 string
*
* @return {Uint8Array} - The decoded string
*/
let b32decode = function(s) {
    let r = new ArrayBuffer(s.length * 5 / 8);
    let b = new Uint8Array(r);
    for (let j = 0; j < s.length / 8; j++) {
        let v = [0, 0, 0, 0, 0, 0, 0, 0];
        for (let i = 0; i < 8; ++i) {
            v[i] = alphabet.indexOf(s[j * 8 + i]);
        }
        let i = 0;
        b[j * 5 + 0] = (v[i + 0] << 3) | (v[i + 1] >> 2);
        b[j * 5 + 1] = ((v[i + 1] & 0x3) << 6) | (v[i + 2] << 1) | (v[i + 3] >> 4);
        b[j * 5 + 2] = ((v[i + 3] & 0xf) << 4) | (v[i + 4] >> 1);
        b[j * 5 + 3] = ((v[i + 4] & 0x1) << 7) | (v[i + 5] << 2) | (v[i + 6] >> 3);
        b[j * 5 + 4] = ((v[i + 6] & 0x7) << 5) | (v[i + 7]);
    }
    return b;
}

/**
* Convert a public key to a NEM address
*
* @param {string} publicKey - A public key
* @param {number} networkId - A network id
*
* @return {string} - The NEM address
*/
let toAddress = function(publicKey, networkId) {
    let binPubKey = CryptoJS.enc.Hex.parse(publicKey);
    let hash = CryptoJS.SHA3(binPubKey, {
        outputLength: 256
    });
    let hash2 = CryptoJS.RIPEMD160(hash);
    // 98 is for testnet
    let networkPrefix = Network.id2Prefix(networkId);
    let versionPrefixedRipemd160Hash = networkPrefix + CryptoJS.enc.Hex.stringify(hash2);
    let tempHash = CryptoJS.SHA3(CryptoJS.enc.Hex.parse(versionPrefixedRipemd160Hash), {
        outputLength: 256
    });
    let stepThreeChecksum = CryptoJS.enc.Hex.stringify(tempHash).substr(0, 8);
    let concatStepThreeAndStepSix = convert.hex2a(versionPrefixedRipemd160Hash + stepThreeChecksum);
    let ret = b32encode(concatStepThreeAndStepSix);
    return ret;
};

/**
* Check if an address is from a specified network
*
* @param {string} _address - An address
* @param {number} networkId - A network id
*
* @return {boolean} - True if address is from network, false otherwise
*/
let isFromNetwork = function(_address, networkId) {
    let address = _address.toString().toUpperCase().replace(/-/g, '');
    let a = address[0];
    return Network.id2Char(networkId) === a;
};

/**
* Check if an address is valid
*
* @param {string} _address - An address
*
* @return {boolean} - True if address is valid, false otherwise
*/
let isValid = function(_address) {
    let address = _address.toString().toUpperCase().replace(/-/g, '');
    if (!address || address.length !== 40) {
        return false;
    }
    let decoded = convert.ua2hex(b32decode(address));
    let versionPrefixedRipemd160Hash = CryptoJS.enc.Hex.parse(decoded.slice(0, 42));
    let tempHash = CryptoJS.SHA3(versionPrefixedRipemd160Hash, {
        outputLength: 256
    });
    let stepThreeChecksum = CryptoJS.enc.Hex.stringify(tempHash).substr(0, 8);

    return stepThreeChecksum === decoded.slice(42);
};

/**
* Remove hyphens from an address
*
* @param {string} _address - An address
*
* @return {string} - A clean address
*/
let clean = function(_address) {
    return _address.toUpperCase().replace(/-|\s/g,"");
};

module.exports = {
    b32encode,
    b32decode,
    toAddress,
    isFromNetwork,
    isValid,
    clean
}
'''
'''--- src/model/apostille.js ---
import CryptoJS from 'crypto-js';
import Helpers from '../utils/helpers';
import Convert from '../utils/convert';
import KeyPair from '../crypto/keyPair';
import Address from '../model/address';
import Sinks from '../model/sinks';
import modelObjects from '../model/objects';
import Transactions from '../model/transactions';

/**
 * Apostille hashing methods with version bytes
 *
 * @type {object}
 */
const hashing = {
	"MD5": {
	    name: "MD5",
	    signedVersion: "81",
	    version: "01"
	},
	"SHA1": {
	    name: "SHA1",
	    signedVersion: "82",
	    version: "02"
	},
	"SHA256" : {
	    name: "SHA256",
	    signedVersion: "83",
	    version: "03"
	},
	"SHA3-256": {
	    name: "SHA3-256",
	    signedVersion: "88",
	    version: "08"
	},
	"SHA3-512": {
	    name: "SHA3-512",
	    signedVersion: "89",
	    version: "09"
	}
}

/**
 * Hash the file content depending of hashing
 *
 * @param {wordArray} data - File content
 * @param {object} hashing - The chosen hashing object
 * @param {boolean} isPrivate - True if apostille is private, false otherwise
 *
 * @return {string} - The file hash with checksum
 */
let hashFileData = function(data, hashing, isPrivate) {
    // Full checksum is 0xFE (added automatically if hex txes) + 0x4E + 0x54 + 0x59 + hashing version byte
    let checksum;
    // Append byte to checksum
    if (isPrivate) {
        checksum = "4e5459" + hashing.signedVersion;
    } else {
        checksum = "4e5459" + hashing.version;
    }
    // Build the apostille hash
    if (hashing.name === "MD5") {
        return checksum + CryptoJS.MD5(data);
    } else if (hashing.name === "SHA1") {
        return checksum + CryptoJS.SHA1(data);
    } else if (hashing.name === "SHA256") {
        return checksum + CryptoJS.SHA256(data);
    } else if (hashing.name === "SHA3-256") {
        return checksum + CryptoJS.SHA3(data, {
            outputLength: 256
        });
    } else {
        return checksum + CryptoJS.SHA3(data, {
            outputLength: 512
        });
    }
};

/**
 * Create an apostille object
 *
 * @param {object} common - A common object
 * @param {string} fileName - The file name (with extension)
 * @param {wordArray} fileContent - The file content
 * @param {string} tags - The apostille tags
 * @param {object} hashing - An hashing object
 * @param {boolean} isMultisig - True if transaction is multisig, false otherwise
 * @param {object} multisigAccount - An [AccountInfo]{@link https://bob.nem.ninja/docs/#accountInfo} object
 * @param {boolean} isPrivate - True if apostille is private / transferable / updateable, false if public
 * @param {number} network - A network id
 *
 * @return {object} - An apostille object containing apostille data and the prepared transaction ready to be sent
 */
let create = function(common, fileName, fileContent, tags, hashing, isMultisig, multisigAccount, isPrivate, network) {
	let dedicatedAccount = {};
	let apostilleHash;
	//
	if (isPrivate) {
        // Create user keypair
        let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
        // Create the dedicated account
        dedicatedAccount = generateAccount(common, fileName, network);
        // Create hash from file content and selected hashing
        let hash = hashFileData(fileContent, hashing, isPrivate);
        // Get checksum
        let checksum = hash.substring(0, 8);
        // Get hash without checksum
        let dataHash = hash.substring(8);
        // Set checksum + signed hash as message
        apostilleHash = checksum + kp.sign(dataHash).toString();
    } else {
        // Use sink account
        dedicatedAccount.address = Sinks.apostille[network].toUpperCase().replace(/-/g, '');
        // Set recipient private key
        dedicatedAccount.privateKey = "None (public sink)";
        // No signing we just put the hash in message
        apostilleHash = hashFileData(fileContent, hashing, isPrivate);
	}

	// Create transfer transaction object
	let transaction = modelObjects.create("transferTransaction")(dedicatedAccount.address, 0, apostilleHash);
    // Multisig
    transaction.isMultisig = isMultisig;
    transaction.multisigAccount = multisigAccount;
    // Set message type to hexadecimal
    transaction.messageType = 0;
	// Prepare the transfer transaction object
	let transactionEntity = Transactions.prepare("transferTransaction")(common, transaction, network);

	return {
		"data": {
			"file": {
				"name": fileName,
				"hash": apostilleHash.substring(8),
				"content": fileContent
			},
			"hash": "fe" + apostilleHash,
			"checksum": "fe" + apostilleHash.substring(0, 8),
			"dedicatedAccount": {
				"address": dedicatedAccount.address,
				"privateKey": dedicatedAccount.privateKey
			},
			"tags": tags
		},
		"transaction": transactionEntity
	}
}

/**
 * Verify an apostille
 *
 * @param {wordArray} fileContent - The file content
 * @param {object} apostilleTransaction - The transaction object for the apostille
 *
 * @return {boolean} - True if valid, false otherwise
 */
let verify = function(fileContent, apostilleTransaction) {
    let apostilleHash;
    if(apostilleTransaction.type === 4100) {
        apostilleHash = apostilleTransaction.otherTrans.message.payload;
    } else {
        apostilleHash = apostilleTransaction.message.payload;
    }
	// Get the checksum
	let checksum = apostilleHash.substring(0, 10);
	// Get the hashing byte
	let hashingByte = checksum.substring(8);
	// Retrieve the hashing method using the checksum in message and hash the file accordingly
	let fileHash = retrieveHash(apostilleHash, fileContent);
	// Check if apostille is signed
	if(isSigned(hashingByte)) {
		// Verify signature
		return KeyPair.verifySignature(apostilleTransaction.signer, fileHash, apostilleHash.substring(10));
	} else {
		// Check if hashed file match hash in transaction (without checksum)
		return fileHash === apostilleHash.substring(10);
	}
}

/**
 * Hash a file according to version byte in checksum
 *
 * @param {string} apostilleHash - The hash contained in the apostille transaction
 * @param {wordArray} fileContent - The file content
 *
 * @return {string} - The file content hashed with correct hashing method
 */
let retrieveHash = function(apostilleHash, fileContent) {
	// Get checksum
	let checksum = apostilleHash.substring(0, 10)
    // Get the version byte
    let hashingVersionBytes = checksum.substring(8);
    // Hash depending of version byte
    if (hashingVersionBytes === "01" || hashingVersionBytes === "81") {
        return CryptoJS.MD5(fileContent).toString(CryptoJS.enc.Hex);
    } else if (hashingVersionBytes === "02" || hashingVersionBytes === "82") {
        return CryptoJS.SHA1(fileContent).toString(CryptoJS.enc.Hex);
    } else if (hashingVersionBytes === "03" || hashingVersionBytes === "83") {
		return CryptoJS.SHA256(fileContent).toString(CryptoJS.enc.Hex);
    } else if (hashingVersionBytes === "08" || hashingVersionBytes === "88") {
        return CryptoJS.SHA3(fileContent, { outputLength: 256 }).toString(CryptoJS.enc.Hex);
    } else {
        return CryptoJS.SHA3(fileContent, { outputLength: 512 }).toString(CryptoJS.enc.Hex);
    }
}

/**
 * Check if an apostille is signed
 *
 * @param {string} hashingByte - An hashing version byte
 *
 * @return {boolean} - True if signed, false otherwise
 */
let isSigned = function(hashingByte) {
	let array = Object.keys(hashing);
    for (let i = 0; array.length > i; i++) {
        if (hashing[array[i]].signedVersion === hashingByte) {
            return true;
        }
    }
    return false;
};

/**
 * Generate the dedicated account for a file. It will always generate the same private key for a given file name and private key
 *
 * @param {object} common - A common object
 * @param {string} fileName - The file name (with extension)
 * @param {number} network - A network id
 *
 * @return {object} - An object containing address and private key of the dedicated account
 */
let generateAccount = function(common, fileName, network) {
	// Create user keypair
	let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    // Create recipient account from signed sha256 hash of new filename
    let signedFilename = kp.sign(CryptoJS.SHA256(fileName).toString(CryptoJS.enc.Hex)).toString();
    // Truncate signed file name to get a 32 bytes private key
    let dedicatedAccountPrivateKey = Helpers.fixPrivateKey(signedFilename);
    // Create dedicated account key pair
    let dedicatedAccountKeyPair = KeyPair.create(dedicatedAccountPrivateKey);
    return {
    	"address":  Address.toAddress(dedicatedAccountKeyPair.publicKey.toString(), network),
    	"privateKey": dedicatedAccountPrivateKey
    }
}

module.exports = {
    create,
    generateAccount,
    hashing,
    verify,
    isSigned
}

'''
'''--- src/model/fees.js ---
import Helpers from '../utils/helpers';
import Format from '../utils/format';

/**
 * The Fee structure's base fee
 *
 * @type {number}
 */
const baseTransactionFee = 3;

/**
 * The Fee structure's Fee factor
 *
 * @type {number}
 */
const currentFeeFactor = 0.05;

/**
 * The multisignature transaction fee
 *
 * @type {number}
 */
const multisigTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);

/**
 * The provision namespace transaction rental fee for root namespace
 *
 * @type {number}
 */
const rootProvisionNamespaceTransaction = 100 * 1000000;

/**
 * The provision namespace transaction rental fee for sub-namespace
 *
 * @type {number}
 */
const subProvisionNamespaceTransaction = 10 * 1000000;

/**
 * The mosaic definition transaction fee
 *
 * @type {number}
 */
const mosaicDefinitionTransaction = 10 * 1000000;

/**
 * The common transaction fee for namespaces and mosaics
 *
 * @type {number}
 */
const namespaceAndMosaicCommon = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);

/**
 * The cosignature transaction fee
 *
 * @type {number}
 */
const signatureTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);

/**
 * The importance transfer transaction fee
 *
 * @type {number}
 */
const importanceTransferTransaction = Math.floor((baseTransactionFee * currentFeeFactor) * 1000000);

/**
 * The multisignature aggregate modification transaction fee
 *
 * @type {number}
 */
const multisigAggregateModificationTransaction = Math.floor((10 * currentFeeFactor) * 1000000);

/**
 * Calculate message fee. 0.05 XEM per commenced 32 bytes
 *
 * If the message is empty, the fee will be 0
 *
 * @param {object} message - An message object
 * @param {boolean} isHW - True if hardware wallet, false otherwise
 *
 * @return {number} - The message fee
 */
let calculateMessage = function(message, isHW) {

    if (!message.payload || !message.payload.length)
        return 0.00;

    let length = message.payload.length / 2;

    // Add salt and IV and round up to AES block size
    if (isHW && message.type == 2)
        length = 32 + 16 + Math.ceil(length / 16) * 16;

    return currentFeeFactor * (Math.floor(length / 32) + 1);
}

/**
 * Calculate fees for mosaics included in a transfer transaction
 *
 * @param {number} multiplier - A quantity multiplier
 * @param {object} mosaics - A mosaicDefinitionMetaDataPair object
 * @param {array} attachedMosaics - An array of mosaics to send
 *
 * @return {number} - The fee amount for the mosaics in the transaction
 */
let calculateMosaics = function(multiplier, mosaics, attachedMosaics) {
    let totalFee = 0;
    let fee = 0;
    let supplyRelatedAdjustment = 0;
    for (let i = 0; i < attachedMosaics.length; i++) {
        let m = attachedMosaics[i];
        let mosaicName = Format.mosaicIdToName(m.mosaicId);
        if (!(mosaicName in mosaics)) {
            return ['unknown mosaic divisibility']; //
        }
        let mosaicDefinitionMetaDataPair = mosaics[mosaicName];
        let divisibilityProperties = Helpers.grep(mosaicDefinitionMetaDataPair.mosaicDefinition.properties, function(w) {
            return w.name === "divisibility";
        });
        let divisibility = divisibilityProperties.length === 1 ? ~~(divisibilityProperties[0].value) : 0;
        let supply = mosaicDefinitionMetaDataPair.supply; //
        let quantity = m.quantity;
        if (supply <= 10000 && divisibility === 0) {
            // Small business mosaic fee
            fee = currentFeeFactor;
        } else {
            let maxMosaicQuantity = 9000000000000000;
            let totalMosaicQuantity = supply * Math.pow(10, divisibility)
            supplyRelatedAdjustment = Math.floor(0.8 * Math.log(Math.floor(maxMosaicQuantity / totalMosaicQuantity)));
            let numNem = calculateXemEquivalent(multiplier, quantity, supply, divisibility);
            // Using Math.ceil below because xem equivalent returned is sometimes a bit lower than it should
            // Ex: 150'000 of nem:xem gives 149999.99999999997
            fee = calculateMinimum(Math.ceil(numNem));
        }
        totalFee += currentFeeFactor * Math.max(1, fee - supplyRelatedAdjustment);
    }
    return totalFee;
}

/**
 * Calculate fees from an amount of XEM
 *
 * @param {number} numNem - An amount of XEM
 *
 * @return {number} - The minimum fee
 */
let calculateMinimum = function(numNem) {
    let fee = Math.floor(Math.max(1, numNem / 10000));
    return fee > 25 ? 25 : fee;
}

/**
 * Calculate mosaic quantity equivalent in XEM
 *
 * @param {number} multiplier - A mosaic multiplier
 * @param {number} q - A mosaic quantity
 * @param {number} sup - A mosaic supply
 * @param {number} divisibility - A mosaic divisibility
 *
 * @return {number} - The XEM equivalent of a mosaic quantity
 */
let calculateXemEquivalent = function(multiplier, q, sup, divisibility) {
    if (sup === 0) {
        return 0;
    }
    // TODO: can this go out of JS (2^54) bounds? (possible BUG)
    return 8999999999 * q * multiplier / sup / Math.pow(10, divisibility + 6);
}

module.exports = {
    multisigTransaction,
    rootProvisionNamespaceTransaction,
    subProvisionNamespaceTransaction,
    mosaicDefinitionTransaction,
    namespaceAndMosaicCommon,
    signatureTransaction,
    calculateMosaics,
    calculateMinimum,
    calculateMessage,
    calculateXemEquivalent,
    currentFeeFactor,
    importanceTransferTransaction,
    multisigAggregateModificationTransaction
}

'''
'''--- src/model/network.js ---
/**
* Networks info data
*
* @type {object}
*/
const data = {
    "mainnet": {
        "id": 104,
        "prefix": "68",
        "char": "N"
    },
    "testnet": {
        "id": -104,
        "prefix": "98",
        "char": "T"
    },
    "mijin": {
        "id": 96,
        "prefix": "60",
        "char": "M"
    }
}

/**
 * Gets a network prefix from network id
 *
 * @param {number} id - A network id
 *
 * @return {string} - The network prefix
 */
let id2Prefix = function(id) {
    if (id === 104) {
        return "68";
    } else if (id === -104) {
        return "98";
    } else {
        return "60";
    }
}

/**
 * Gets the starting char of the addresses of a network id
 *
 * @param {number} id - A network id
 *
 * @return {string} - The starting char of addresses
 */
let id2Char = function(id) {
    if (id === 104) {
        return "N";
    } else if (id === -104) {
        return "T";
    } else {
        return "M";
    }
}

/**
 * Gets the network id from the starting char of an address
 *
 * @param {string} startChar - A starting char from an address
 *
 * @return {number} - The network id
 */
let char2Id = function(startChar) {
    if (startChar === "N") {
        return 104;
    } else if (startChar === "T") {
        return -104;
    } else {
        return 96;
    }
}

/**
 * Gets the network version
 *
 * @param {number} val - A version number (1 or 2)
 * @param {number} network - A network id
 *
 * @return {number} - A network version
 */
let getVersion = function(val, network) {
    if (network === data.mainnet.id) {
        return 0x68000000 | val;
    } else if (network === data.testnet.id) {
        return 0x98000000 | val;
    }
    return 0x60000000 | val;
}

module.exports = {
    data,
    id2Prefix,
    id2Char,
    char2Id,
    getVersion
}
'''
'''--- src/model/nodes.js ---
/**
 * The default testnet node
 *
 * @type {string}
 */
let defaultTestnet = 'http://23.228.67.85';

/**
 * The default mainnet node
 *
 * @type {string}
 */
let defaultMainnet = 'http://hugealice3.nem.ninja';

/**
 * The default mijin node
 *
 * @type {string}
 */
let defaultMijin = '';

/**
 * The default mainnet block explorer
 *
 * @type {string}
 */
let mainnetExplorer = 'http://chain.nem.ninja/#/transfer/';

/**
 * The default testnet block explorer
 *
 * @type {string}
 */
let testnetExplorer = 'http://bob.nem.ninja:8765/#/transfer/';

/**
 * The default mijin block explorer
 *
 * @type {string}
 */
let mijinExplorer = '';

/**
 * The nodes allowing search by transaction hash on testnet
 *
 * @type {array}
 */
let searchOnTestnet = [
	{
	    'uri': 'http://bigalice2.nem.ninja',
	    'location': 'America / New_York'
	},
	{
	    'uri': 'http://192.3.61.243',
	    'location': 'America / Los_Angeles'
	},
	{
	    'uri': 'http://23.228.67.85',
	    'location': 'America / Los_Angeles'
	}
];

/**
 * The nodes allowing search by transaction hash on mainnet
 *
 * @type {array}
 */
let searchOnMainnet = [
	{
	    'uri': 'http://62.75.171.41',
	    'location': 'Germany'
	}, {
	    'uri': 'http://104.251.212.131',
	    'location': 'USA'
	}, {
	    'uri': 'http://45.124.65.125',
	    'location': 'Hong Kong'
	}, {
	    'uri': 'http://185.53.131.101',
	    'location': 'Netherlands'
	}, {
	    'uri': 'http://sz.nemchina.com',
	    'location': 'China'
	}
];

/**
 * The nodes allowing search by transaction hash on mijin
 *
 * @type {array}
 */
let searchOnMijin = [
	{
	    'uri': '',
	    'location': ''
	}
];

/**
 * The testnet nodes
 *
 * @type {array}
 */
let testnet = [
	{
	        uri: 'http://104.128.226.60'
	}, {
	        uri: 'http://23.228.67.85'
	}, {
	        uri: 'http://192.3.61.243'
	}, {
	        uri: 'http://50.3.87.123'
	}, {
	    uri: 'http://localhost'
	}
];

/**
 * The mainnet nodes
 *
 * @type {array}
 */
let mainnet = [
    {
        uri: 'http://hugealice.nem.ninja'
    }, {
        uri: 'http://hugealice2.nem.ninja'
    }, {
        uri: 'http://hugealice3.nem.ninja'
    }, {
        uri: 'http://hugealice4.nem.ninja'
    }, {
        uri: 'http://62.75.171.41'
    }, {
        uri: 'http://san.nem.ninja'
    }, {
        uri: 'http://go.nem.ninja'
    }, {
        uri: 'http://hachi.nem.ninja'
    }, {
        uri: 'http://jusan.nem.ninja'
    }, {
        uri: 'http://nijuichi.nem.ninja'
    }, {
        uri: 'http://alice2.nem.ninja'
    }, {
        uri: 'http://alice3.nem.ninja'
    }, {
        uri: 'http://alice4.nem.ninja'
    }, {
        uri: 'http://alice5.nem.ninja'
    }, {
        uri: 'http://alice6.nem.ninja'
    }, {
        uri: 'http://alice7.nem.ninja'
    }, {
        uri: 'http://localhost'
    }
];

/**
 * The mijin nodes
 *
 * @type {array}
 */
let mijin = [
	{
	    uri: ''
	}
];

/**
 * The server verifying signed apostilles
 *
 * @type {string}
 */
let apostilleAuditServer = 'http://185.117.22.58:4567/verify';

/**
 * The API to get all supernodes
 *
 * @type {string}
 */
let supernodes = 'https://supernodes.nem.io/nodes';

/**
 * The API to get XEM/BTC market data
 *
 * @type {string}
 */
let marketInfo = 'https://poloniex.com/public';

/**
 * The API to get BTC/USD market data
 *
 * @type {string}
 */
let btcPrice = 'https://blockchain.info/ticker';

/**
 * The default endpoint port
 *
 * @type {number}
 */
let defaultPort = 7890;

/**
 * The Mijin endpoint port
 *
 * @type {number}
 */
let mijinPort = 7895;

/**
 * The websocket port
 *
 * @type {number}
 */
let websocketPort = 7778;

module.exports = {
    defaultTestnet,
    defaultMainnet,
    defaultMijin,
    mainnetExplorer,
    testnetExplorer,
    mijinExplorer,
    searchOnTestnet,
    searchOnMainnet,
    searchOnMijin,
    testnet,
    mainnet,
    mijin,
    apostilleAuditServer,
    supernodes,
    defaultPort,
    mijinPort,
    websocketPort,
    marketInfo,
    btcPrice
}
'''
'''--- src/model/objects.js ---
import Account from './objects/account';
import Miscellaneous from './objects/miscellaneous';
import Mosaic from './objects/mosaic';
import Transactions from './objects/transactions';
import QR from './objects/qr';
import Wallet from './objects/wallet';

/**
 * Get an empty object 
 *
 * @param {string} objectName - The name of the object
 *
 * @return {object} - The desired object
 */
let get = function(objectName) {
    return _fetch(0, objectName);
}

/**
 * Create an object
 *
 * @param {string} objectName - The name of the object
 *
 * @return {function} - The object creation function corresponding to the object name
 */
let create = function(objectName) {
    return _fetch(1, objectName);
}

/**
 * Fetch objects
 *
 * @param {number} type - 0 for get, 1 for creation
 * @param {string} objectName - The name of the object
 *
 * @return {function|object} - The object creation function corresponding to the object name, or the object
 */
let _fetch = function(type, objectName) {
    switch(objectName) {
        case "account":
            return !type ? Account() : Account;
            break;
        case "accountInfoQR":
            return !type ? QR.accountInfo(): QR.accountInfo;
            break;
        case "common":
            return !type ? Miscellaneous.common() : Miscellaneous.common;
            break;
        case "commonTransactionPart":
            return !type ? Transactions.commonPart() : Transactions.commonPart;
            break;
        case "endpoint":
            return !type ? Miscellaneous.endpoint() : Miscellaneous.endpoint;
            break;
        case "mosaicAttachment":
            return !type ? Mosaic.attachment() : Mosaic.attachment;
            break;
        case "mosaicDefinitionMetaDataPair":
            return Mosaic.definitionMetaDataPair();
            break;
        case "mosaicDefinitionTransaction":
            return !type ? Transactions.mosaicDefinition() : Transactions.mosaicDefinition;
            break;
        case "invoice":
            return !type ? QR.invoice() : QR.invoice;
            break;
        case "transferTransaction":
            return !type ? Transactions.transfer() : Transactions.transfer;
            break;
        case "signatureTransaction":
            return !type ? Transactions.signature() : Transactions.signature;
            break;
        case "messageTypes":
            return Miscellaneous.messageTypes();
            break;
        case "mosaicSupplyChangeTransaction":
            return !type ? Transactions.mosaicSupplyChange() : Transactions.mosaicSupplyChange;
            break;
        case "multisigAggregateModification":
            return !type ? Transactions.multisigAggregateModification() : Transactions.multisigAggregateModification;
            break;
        case "multisigCosignatoryModification":
            return !type ? Miscellaneous.multisigCosignatoryModification() : Miscellaneous.multisigCosignatoryModification;
            break;
        case "namespaceProvisionTransaction":
            return !type ? Transactions.namespaceProvision() : Transactions.namespaceProvision;
            break;
        case "importanceTransferTransaction":
            return !type ? Transactions.importanceTransfer() : Transactions.importanceTransfer;
            break;
        case "wallet":
            return !type ? Wallet() : Wallet;
            break;
        case "walletQR":
            return !type ? QR.wallet() : QR.wallet;
            break;
        default:
            return {};
    }
}

module.exports = {
    get,
    create
}
'''
'''--- src/model/objects/account.js ---
/**
 * An account object
 *
 * @param {string} address - A NEM account address
 * @param {string} label - An account label
 * @param {string} child - A child public key (remote account)
 * @param {string} encrypted - An encrypted private key
 * @param {string} iv - IV of the encrypted private key
 *
 * @return {object} - An account object
 */
export default function(address, label, child, encrypted, iv) {
    return {
        "address": address || "",
        "label": label || "",
        "child": child || "",
        "encrypted": encrypted || "",
        "iv": iv || ""
    }
}
'''
'''--- src/model/objects/miscellaneous.js ---
/**
 * An endpoint object
 *
 * @param {string} host - A NIS uri
 * @param {number} port - A port
 *
 * @return {object}
 */
let endpoint = function(host, port) {
    return {
        "host": host || "",
        "port": port || ""
    }
};

/**
 * A common object
 *
 * @param {string} password - A password
 * @param {string} privateKey - A privateKey
 * @param {boolean} isHW - True if hardware wallet, false otherwise
 *
 * @return {object}
 */
let common = function(password, privateKey, isHW) {
	return {
        "password": password || "",
	    "privateKey": privateKey || "",
        "isHW": isHW || false
    }
};

/**
 * Contains message types with name
 *
 * @return {array}
 */
let messageTypes = function() {
    return [{
        "value": 0,
        "name": "Hexadecimal"
    }, {
        "value": 1,
        "name": "Unencrypted"
    }, {
        "value": 2,
        "name": "Encrypted"
    }];
}

/**
 * A multisig cosignatory modification object
 *
 * @param {number} type - 1 if an addition, 2 if deletion
 * @param {string} publicKey - An account public key
 *
 * @return {object}
 */
let multisigCosignatoryModification = function(type, publicKey) {
    return {
        "modificationType": type || 1,
        "cosignatoryAccount": publicKey
    }
}

module.exports = {
    endpoint,
    common,
    messageTypes,
    multisigCosignatoryModification
}
'''
'''--- src/model/objects/mosaic.js ---
/**
 * A mosaic attachment object
 *
 * @param {string} namespaceId - A namespace name
 * @param {string} mosaicName - A mosaic name
 * @param {number} quantity - A mosaic quantity (in uXEM)
 *
 * @return {object}
 */
let attachment = function(namespaceId, mosaicName, quantity) {
    return {
        "mosaicId": {
        	"namespaceId": namespaceId || "",
        	"name": mosaicName || ""
        },
        "quantity": quantity || 0
    }
};

let definitionMetaDataPair = function() {
    return {
        "nem:xem": {
            "mosaicDefinition" : {
                "creator": "3e82e1c1e4a75adaa3cba8c101c3cd31d9817a2eb966eb3b511fb2ed45b8e262",
                "description": "reserved xem mosaic",
                "id": {
                    "namespaceId": "nem",
                    "name": "xem"
                },
                "properties": [{
                    "name": "divisibility",
                    "value": "6"
                }, {
                    "name": "initialSupply",
                    "value": "8999999999"
                }, {
                    "name": "supplyMutable",
                    "value": "false"
                }, {
                    "name": "transferable",
                    "value": "true"
                }],
                "levy": {}
            }
        }/*,
        "another.namespace:mosaic": {
            "mosaicDefinition": {
                Add mosaic definitions in this model to simplify transactions for a particular mosaic
            }
        } ,
        "another.namespace.again:mosaic": {
            "mosaicDefinition": {
                ...
            }
        } */
    }
}

module.exports = {
    attachment,
    definitionMetaDataPair
}
'''
'''--- src/model/objects/qr.js ---
/**
 * An account info object for mobile QR
 *
 * @param {number} version - A version number
 * @param {number} type - A type number
 * @param {string} address - A NEM address
 * @param {string} name - An account name
 *
 * @return {object} - An account info object
 */
let accountInfo = function(version, type, address, name) {
    return {
        "v": version || "",
        "type": 1 || "",
        "data": {
            "addr": address || "",
            "name": name || ""
        }
    }
}

/**
 * A wallet object for mobile QR
 *
 * @param {number} version - A version number
 * @param {number} type - An type number
 * @param {string} name - A wallet name
 * @param {string} encrypted - An encrypted primary private key
 * @param {string} salt - Salt of the encrypted private key
 *
 * @return {object} - A wallet object
 */
let wallet = function(version, type, name, encrypted, salt) {
    return {
        "v": version || "",
        "type": type || "",
        "data": {
            "name": name || "",
            "priv_key": encrypted || "",
            "salt": salt || ""
        }
    }
}

let invoice = function() {
    return  {
        "v": "v = 1 for testnet, v = 2 for mainnet",
        "type": 2,
        "data": {
            "addr": "",
            "amount": 0,
            "msg": "",
            "name": ""
        }
    }
}

module.exports = {
    accountInfo,
    wallet,
    invoice
}
'''
'''--- src/model/objects/transactions.js ---
/**
 * An un-prepared transfer transaction object
 *
 * @param {string} recipient - A NEM account address
 * @param {number} amount - A number of XEM
 * @param {string} message - A message
 *
 * @return {object}
 */
let transfer = function(recipient, amount, message) {
    return {
        "amount": amount || 0,
        "recipient": recipient || "",
        "recipientPublicKey": "",
        "isMultisig": false,
        "multisigAccount" : "",
        "message": message || "",
        "messageType" : 1,
        "mosaics": []
    }
}

/**
 * An un-prepared signature transaction object
 *
 * @param  {string} multisigAccount - The multisig account address
 * @param  {string} txHash - The multisig transaction hash
 *
 * @return {object}
 */
let signature = function(multisigAccount, txHash) {
    let compressedAccount = "";
    if (typeof multisigAccount != "undefined" && multisigAccount.length) {
        compressedAccount = multisigAccount.toUpperCase().replace(/-/g, "");
    }

    return {
        "otherHash": {
            "data": txHash || ""
        },
        "otherAccount": compressedAccount
    }
}

/**
 * An un-prepared mosaic definition transaction object
 *
 * @return {object}
 */
let mosaicDefinition = function() {
    return {
        "mosaicName": "",
        "namespaceParent": "",
        "mosaicDescription": "",
        "properties": {
            "initialSupply": 0,
            "divisibility": 0,
            "transferable": true,
            "supplyMutable": true
        },
        "levy": {
            "mosaic": null,
            "address": "",
            "feeType": 1,
            "fee": 5
        },
        "isMultisig": false,
        "multisigAccount" : ""
    }
}

/**
 * An un-prepared mosaic supply change transaction object
 *
 * @return {object}
 */
let mosaicSupplyChange = function() {
    return {
        "mosaic": "",
        "supplyType": 1,
        "delta": 0,
        "isMultisig": false,
        "multisigAccount" : ""
    }
}

/**
 * An un-prepared multisig aggregate modification transaction object
 *
 * @return {object}
 */
let multisigAggregateModification = function() {
    return {
        "modifications": [],
        "relativeChange": null,
        "isMultisig": false,
        "multisigAccount" : ""
    }
}

/**
 * An un-prepared namespace provision transaction object
 *
 * @param {string} namespaceName - A namespace name
 * @param {string} namespaceParent - A namespace name
 *
 * @return {object}
 */
let namespaceProvision = function(namespaceName, namespaceParent) {
    return {
        "namespaceName": namespaceName || "",
        "namespaceParent": namespaceParent || null,
        "isMultisig": false,
        "multisigAccount" : ""
    }
}

/**
 * An un-prepared importance transfer transaction object
 *
 * @param {string} remoteAccount - A remote public key
 * @param {number} mode - 1 for activating, 2 for deactivating
 *
 * @return {object}
 */
let importanceTransfer = function(remoteAccount, mode) {
    return {
        "remoteAccount": remoteAccount || "",
        "mode": mode || "",
        "isMultisig": false,
        "multisigAccount" : ""
    }
}

/**
 * The common part of transactions
 *
 * @param {number} txType - A type of transaction
 * @param {string} senderPublicKey - A sender public key
 * @param {number} timeStamp - A timestamp for the transation
 * @param {number} due - A deadline in minutes
 * @param {number} version - A network version
 * @param {number} network - A network id
 *
 * @return {object} - A common transaction object
 */
let commonPart = function(txtype, senderPublicKey, timeStamp, due, version, network) {
    return {
        'type': txtype || "",
        'version': version || "",
        'signer': senderPublicKey || "",
        'timeStamp': timeStamp || "",
        'deadline': timeStamp + due * 60 || ""
    };
}

module.exports = {
    multisigAggregateModification,
    transfer,
    signature,
    mosaicDefinition,
    mosaicSupplyChange,
    namespaceProvision,
    importanceTransfer,
    commonPart
}
'''
'''--- src/model/objects/wallet.js ---
/**
 * A wallet object
 *
 * @param {string} walletName - A wallet name
 * @param {string} addr - A primary account address
 * @param {boolean} brain - Is brain or not
 * @param {string} algo - A wallet algorithm
 * @param {object} encrypted - An encrypted private key object
 * @param {number} network - A network id
 *
 * @return {object} - A wallet object
 */
export default function(walletName, addr, brain, algo, encrypted, network) {
    return {
        "name": walletName,
        "accounts": {
            "0": {
                "brain": brain,
                "algo": algo,
                "encrypted": encrypted.ciphertext || "",
                "iv": encrypted.iv || "",
                "address": addr.toUpperCase().replace(/-/g, ''),
                "label": 'Primary',
                "network": network,
            }
        }
    };
}
'''
'''--- src/model/sinks.js ---
/**
 * The namespace, mosaic and apostille sink accounts
 *
 * @type {object}
 */
module.exports = {
    namespace: {
        '-104': 'TAMESP-ACEWH4-MKFMBC-VFERDP-OOP4FK-7MTDJE-YP35',
        '104': 'NAMESP-ACEWH4-MKFMBC-VFERDP-OOP4FK-7MTBXD-PZZA',
        '96': 'MAMESP-ACEWH4-MKFMBC-VFERDP-OOP4FK-7MTCZT-G5E7'
    },
    mosaic: {
        '-104': 'TBMOSA-ICOD4F-54EE5C-DMR23C-CBGOAM-2XSJBR-5OLC',
        '104': 'NBMOSA-ICOD4F-54EE5C-DMR23C-CBGOAM-2XSIUX-6TRS',
        '96': 'MBMOSA-ICOD4F-54EE5C-DMR23C-CBGOAM-2XSKYH-TOJD'
    },
    apostille: {
        '-104': 'TC7MCY-5AGJQX-ZQ4BN3-BOPNXU-VIGDJC-OHBPGU-M2GE',
        '104': 'NCZSJH-LTIMES-ERVBVK-OW6US6-4YDZG2-PFGQCS-V23J',
        '96': 'MCGDK2-J46BOD-GGKMPI-KCBGTB-BIWL6A-L5ZKLK-Q56A'
    }
};
'''
'''--- src/model/transactionTypes.js ---
/**
 * The transfer transaction type
 *
 * @type {string}
 *
 * @default
 */
let transfer = 0x101; // 257

/**
 * The importance transfer type
 *
 * @type {string}
 *
 * @default
 */
let importanceTransfer = 0x801; // 2049

/**
 * The aggregate modification transaction type
 *
 * @type {string}
 *
 * @default
 */
let multisigModification = 0x1001; // 4097

/**
 * The multisignature signature transaction type
 *
 * @type {string}
 *
 * @default
 */
let multisigSignature = 0x1002; // 4098

/**
 * The multisignature transaction type
 *
 * @type {string}
 *
 * @default
 */
let multisigTransaction = 0x1004; // 4100

/**
 * The provision namespace transaction type
 *
 * @type {string}
 *
 * @default
 */
let provisionNamespace = 0x2001; // 8193

/**
 * The mosaic definition transaction type
 *
 * @type {string}
 *
 * @default
 */
let mosaicDefinition = 0x4001; // 16385

/**
 * The mosaic supply change transaction type
 *
 * @type {string}
 *
 * @default
 */
let mosaicSupply = 0x4002; // 16386

module.exports = {
    transfer,
    importanceTransfer,
    multisigModification,
    multisigSignature,
    multisigTransaction,
    provisionNamespace,
    mosaicDefinition,
    mosaicSupply
}
'''
'''--- src/model/transactions.js ---
import TransferTransaction from './transactions/transferTransaction';
import SignatureTransaction from './transactions/signatureTransaction';
import MosaicDefinitionTransaction from './transactions/mosaicDefinitionTransaction';
import MosaicSupplyChangeTransaction from './transactions/mosaicSupplyChange';
import MultisigAggregateModification from './transactions/multisigAggregateModificationTransaction';
import NamespaceProvisionTransaction from './transactions/namespaceProvisionTransaction';
import ImportanceTransferTransaction from './transactions/importanceTransferTransaction';
import Send from './transactions/send';
import Message from './transactions/message';

/**
 * Prepare a transaction object 
 *
 * @param {string} objectName - The name of the object to prepare
 *
 * @retrun {function} - The prepare function corresponding to the object name
 */
let prepare = function(objectName) {
    switch(objectName) {
        case "transferTransaction":
            return TransferTransaction.prepare;
            break;
        case "mosaicTransferTransaction":
            return TransferTransaction.prepareMosaic;
            break;
        case "mosaicDefinitionTransaction":
            return MosaicDefinitionTransaction.prepare;
            break;
        case "multisigAggregateModificationTransaction":
            return MultisigAggregateModification.prepare;
            break;
        case "namespaceProvisionTransaction":
            return NamespaceProvisionTransaction.prepare;
            break;
        case "signatureTransaction":
            return SignatureTransaction.prepare;
            break;
        case "mosaicSupplyChangeTransaction":
            return MosaicSupplyChangeTransaction.prepare;
            break;
        case "importanceTransferTransaction":
            return ImportanceTransferTransaction.prepare;
            break;
        default:
            return {};
    }
}

module.exports = {
    prepare,
    send: Send,
    prepareMessage: Message.prepare
}
'''
'''--- src/model/transactions/importanceTransferTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';
import MultisigWrapper from './multisigWrapper';

/**
 * Prepare an importance transfer transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared importanceTransferTransaction object
 * @param {number} network - A network id
 *
 * @return {object} - An [ImportanceTransferTransaction]{@link https://bob.nem.ninja/docs/#importanceTransferTransaction} object ready for serialization
 */
let prepare = function (common, tx, network) {
    if (!common || !tx || !network) throw new Error('Missing parameter !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let entity = _construct(actualSender, tx.remoteAccount, tx.mode, due, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/***
 * Create an importance transfer transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {string} remotePublicKey - The remote account public key
 * @param {number} mode - 1 for activating, 2 for deactivating
 * @param {number} due - The deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - An [ImportanceTransferTransaction]{@link https://bob.nem.ninja/docs/#importanceTransferTransaction} object
 */
let _construct = function(senderPublicKey, remotePublicKey, mode, due, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.importanceTransfer, senderPublicKey, timeStamp, due, version);
    let fee = Fees.importanceTransferTransaction;
    let custom = {
        'remoteAccount': remotePublicKey,
        'mode': mode,
        'fee': fee
    };
    let entity = Helpers.extendObj(data, custom);
    return entity;
}

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/message.js ---
import CryptoHelpers from '../../crypto/cryptoHelpers';
import Convert from '../../utils/convert';
import Helpers from '../../utils/helpers';

/**
 * Prepare a message object
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared transferTransaction object
 *
 * @return {object} - A prepared message object
 */
let prepare = function(common, tx) {
    if (tx.messageType === 2 && common.privateKey) {
        return {
            'type': 2,
            'payload': CryptoHelpers.encode(common.privateKey, tx.recipientPublicKey, tx.message.toString())
        };
    } else if (tx.messageType === 2 && common.isHW) {
        return {
            'type': 2,
            'payload': Convert.utf8ToHex(tx.message.toString()),
            'publicKey': tx.recipientPublicKey
        };
    } else if(tx.messageType === 0 && Helpers.isHexadecimal(tx.message.toString())) {
        return {
            'type': 1,
            'payload': 'fe' + tx.message.toString()
        };
    } else {
        return {
            'type': 1,
            'payload': Convert.utf8ToHex(tx.message.toString())
        };
    }
}

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/mosaicDefinitionTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';
import Sinks from '../sinks';
import MultisigWrapper from './multisigWrapper';

/**
 * Prepare a mosaic definition transaction
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared mosaicDefinitionTransaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [MosaicDefinitionCreationTransaction]{@link http://bob.nem.ninja/docs/#mosaicDefinitionCreationTransaction} object ready for serialization
 */
let prepare = function(common, tx, network){
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let rentalFeeSink = Sinks.mosaic[network].toUpperCase().replace(/-/g, '');
    let rentalFee = Fees.mosaicDefinitionTransaction;
    let namespaceParent = tx.namespaceParent.fqn;
    let mosaicName = tx.mosaicName.toString();
    let mosaicDescription = tx.mosaicDescription.toString();
    let mosaicProperties = tx.properties;
    let levy = tx.levy.mosaic ? tx.levy : null;
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let entity = _construct(actualSender, rentalFeeSink, rentalFee, namespaceParent, mosaicName, mosaicDescription, mosaicProperties, levy, due, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/***
 * Create a mosaic definition transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {string} rentalFeeSink - The rental sink account
 * @param {number} rentalFee - The rental fee
 * @param {string} namespaceParent - The parent namespace
 * @param {string} mosaicName - The mosaic name
 * @param {string} mosaicDescription - The mosaic description
 * @param {object} mosaicProperties - The mosaic properties object
 * @param {object} levy - The levy object
 * @param {number} due - The deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - A [MosaicDefinitionCreationTransaction]{@link http://bob.nem.ninja/docs/#mosaicDefinitionCreationTransaction} object
 */
let _construct = function(senderPublicKey, rentalFeeSink, rentalFee, namespaceParent, mosaicName, mosaicDescription, mosaicProperties, levy, due, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.mosaicDefinition, senderPublicKey, timeStamp, due, version);
    let fee = Fees.namespaceAndMosaicCommon;
    let levyData = levy ? {
        'type': levy.feeType,
        'recipient': levy.address.toUpperCase().replace(/-/g, ''),
        'mosaicId': levy.mosaic,
        'fee': levy.fee,
    } : null;
    let custom = {
        'creationFeeSink': rentalFeeSink.replace(/-/g, ''),
        'creationFee': rentalFee,
        'mosaicDefinition': {
            'creator': senderPublicKey,
            'id': {
                'namespaceId': namespaceParent,
                'name': mosaicName,
            },
            'description': mosaicDescription,
            'properties': Object.keys(mosaicProperties).map((key, index) => {
                return { "name": key, "value": mosaicProperties[key].toString() };
            }),
            'levy': levyData
        },
        'fee': fee
    };
    var entity = Helpers.extendObj(data, custom);
    return entity;
}

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/mosaicSupplyChange.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';
import MultisigWrapper from './multisigWrapper';

/**
 * Prepare a mosaic supply change transaction
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared mosaicSupplyChangeTransaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [MosaicSupplyChangeTransaction]{@link http://bob.nem.ninja/docs/#mosaicSupplyChangeTransaction} object ready for serialization
 */
let prepare = function(common, tx, network) {
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let entity = _construct(actualSender, tx.mosaic, tx.supplyType, tx.delta, due, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/***
 * Create a mosaic supply change transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {object} mosaicId - The mosaic id
 * @param {number} supplyType - The type of change
 * @param {number} delta - The amount involved in the change
 * @param {number} due - The deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - A [MosaicSupplyChangeTransaction]{@link http://bob.nem.ninja/docs/#mosaicSupplyChangeTransaction} object
 */
let _construct = function(senderPublicKey, mosaicId, supplyType, delta, due, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.mosaicSupply, senderPublicKey, timeStamp, due, version);
    let fee = Fees.namespaceAndMosaicCommon;
    let custom = {
        'mosaicId': mosaicId,
        'supplyType': supplyType,
        'delta': delta,
        'fee': fee
    };
    let entity = Helpers.extendObj(data, custom);
    return entity;
};

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/multisigAggregateModificationTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import KeyPair from '../../crypto/keyPair';
import Fees from '../fees';
import Objects from '../objects';
import Address from '../address';
import MultisigWrapper from './multisigWrapper';

/**
 * Prepare a multisig aggregate modification transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared multisigAggregateModificationTransaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [MultisigAggregateModificationTransaction]{@link http://bob.nem.ninja/docs/#multisigAggregateModificationTransaction} object ready for serialization
 */
let prepare = function(common, tx, network) {
    if (!common || !tx || !network) throw new Error('Missing parameter !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let entity = _construct(actualSender, tx.modifications, tx.relativeChange, tx.isMultisig, due, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/**
 * Create a multisignature aggregate modification transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {array} modifications - An array of [MultisigCosignatoryModification]{@link http://bob.nem.ninja/docs/#multisigCosignatoryModification} objects  
 * @param {number} relativeChange - The number of signature to add or remove (ex: 1 to add +1 or -1 to remove one)
 * @param {boolean} isMultisig - True if transaction is multisig, false otherwise
 * @param {number} due - The deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - A [MultisigAggregateModificationTransaction]{@link http://bob.nem.ninja/docs/#multisigAggregateModificationTransaction} object
 */
let _construct = function(senderPublicKey, modifications, relativeChange, isMultisig, due, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let hasNoRelativeChange = relativeChange === null || relativeChange === 0;
    let version = hasNoRelativeChange ? Network.getVersion(1, network) : Network.getVersion(2, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.multisigModification, senderPublicKey, timeStamp, due, version);
    let totalFee = Fees.multisigAggregateModificationTransaction;
    let custom = {
        'fee': totalFee,
        'modifications': modifications,
        'minCosignatories': {
            'relativeChange': 0
        }
    }
    // If multisig, it is a modification of an existing contract, otherwise it is a creation
    if(isMultisig) {
        // If no relative change, no minCosignatories property
        if (hasNoRelativeChange) delete custom.minCosignatories;
        else custom.minCosignatories.relativeChange = relativeChange;

        // Sort modification array
        if (custom.modifications.length > 1) {
            custom.modifications.sort((a, b) => {
                return a.modificationType - b.modificationType || Address.toAddress(a.cosignatoryAccount, network).localeCompare(Address.toAddress(b.cosignatoryAccount, network));
            });
        }
    } else {
        custom.minCosignatories.relativeChange = relativeChange;

        // Sort modification array by addresses
        if (custom.modifications.length > 1) {
            custom.modifications.sort((a, b) => {
                if (Address.toAddress(a.cosignatoryAccount, network) < Address.toAddress(b.cosignatoryAccount, network)) return -1;
                if (Address.toAddress(a.cosignatoryAccount, network) > Address.toAddress(b.cosignatoryAccount, network)) return 1;
                return 0;
            });
        }
    }

    let entity = Helpers.extendObj(data, custom);
    return entity;
}

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/multisigWrapper.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import Objects from '../objects';

/**
 * Wrap a transaction in a multisignature transaction
 *
 * @param {string} senderPublicKey - The sender public key
 * @param {object} innerEntity - The transaction entity to wrap
 * @param {number} due - The transaction deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - A [MultisigTransaction]{@link http://bob.nem.ninja/docs/#multisigTransaction} object
 */
let multisigWrapper = function(senderPublicKey, innerEntity, due, network) {
	let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.multisigTransaction, senderPublicKey, timeStamp, due, version, network);
    let custom = {
        'fee': Fees.multisigTransaction,
        'otherTrans': innerEntity
    };
    let entity = Helpers.extendObj(data, custom);
    return entity;
}

export default multisigWrapper;
'''
'''--- src/model/transactions/namespaceProvisionTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';
import Sinks from '../sinks';
import MultisigWrapper from './multisigWrapper';

/**
 * Prepare a namespace provision transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - An un-prepared namespaceProvisionTransaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [ProvisionNamespaceTransaction]{@link http://bob.nem.ninja/docs/#provisionNamespaceTransaction} object ready for serialization
 */
let prepare = function (common, tx, network) {
    if (!common || !tx || !network) throw new Error('Missing parameter !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let rentalFeeSink = Sinks.namespace[network].toUpperCase().replace(/-/g, '');
    let rentalFee;
    // Set fee depending if namespace or sub
    if (tx.namespaceParent) {
        rentalFee = Fees.subProvisionNamespaceTransaction;
    } else {
        rentalFee = Fees.rootProvisionNamespaceTransaction;
    }
    let namespaceParent = tx.namespaceParent ? tx.namespaceParent.fqn : null;
    let namespaceName = tx.namespaceName.toString();
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let entity = _construct(actualSender, rentalFeeSink, rentalFee, namespaceParent, namespaceName, due, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/***
 * Create a namespace provision transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {string} rentalFeeSink - The rental sink account
 * @param {number} rentalFee - The rental fee
 * @param {string} namespaceParent - The parent namespace
 * @param {string} namespaceName  - The namespace name
 * @param {number} due - The deadline in minutes
 * @param {number} network - A network id
 *
 * @return {object} - A [ProvisionNamespaceTransaction]{@link http://bob.nem.ninja/docs/#provisionNamespaceTransaction} object
 */
let _construct = function(senderPublicKey, rentalFeeSink, rentalFee, namespaceParent, namespaceName, due, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.provisionNamespace, senderPublicKey, timeStamp, due, version);
    let fee = Fees.namespaceAndMosaicCommon;
    let custom = {
        'rentalFeeSink': rentalFeeSink.toUpperCase().replace(/-/g, ''),
        'rentalFee': rentalFee,
        'parent': namespaceParent,
        'newPart': namespaceName,
        'fee': fee
    };
    let entity = Helpers.extendObj(data, custom);
    return entity;
}

module.exports = {
    prepare
}
'''
'''--- src/model/transactions/send.js ---
import Helpers from '../../utils/helpers';
import Convert from '../../utils/convert';
import Serialization from '../../utils/serialization';
import KeyPair from '../../crypto/keyPair';
import Requests from '../../com/requests';

/**
 * Serialize a transaction and broadcast it to the network
 *
 * @param {object} common - A common object
 * @param {object} entity - A prepared transaction object
 * @param {object} endpoint - An NIS endpoint object
 *
 * @return {promise} - An announce transaction promise of the com.requests service
 */
let send = function(common, entity, endpoint) {
    if(!endpoint || !entity || !common) throw new Error('Missing parameter !');
    if (common.privateKey.length !== 64 && common.privateKey.length !== 66) throw new Error('Invalid private key, length must be 64 or 66 characters !');
    if (!Helpers.isHexadecimal(common.privateKey)) throw new Error('Private key must be hexadecimal only !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let result = Serialization.serializeTransaction(entity);
    let signature = kp.sign(result);
    let obj = {
        'data': Convert.ua2hex(result),
        'signature': signature.toString()
    };
    return Requests.transaction.announce(endpoint, JSON.stringify(obj));
}

export default send;
'''
'''--- src/model/transactions/signatureTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';

/**
 * Prepare a signature transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - The un-prepared signature transaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [MultisigSignatureTransaction]{@link http://bob.nem.ninja/docs/#multisigSignatureTransaction} object ready for serialization
 */
let prepare = function(common, tx, network) {
    if (!common || !tx || !network) throw new Error('Missing parameter !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;

    let senderPublicKey = kp.publicKey.toString();
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.multisigSignature, senderPublicKey, timeStamp, due, version);
    let fee = Fees.signatureTransaction;

    let custom = {
        'fee': fee
    };
    let entity = Helpers.extendObj(tx, data, custom);
    return entity;
}

module.exports = {
    prepare
}

'''
'''--- src/model/transactions/transferTransaction.js ---
import Network from '../network';
import Helpers from '../../utils/helpers';
import TransactionTypes from '../transactionTypes';
import Fees from '../fees';
import KeyPair from '../../crypto/keyPair';
import Objects from '../objects';
import MultisigWrapper from './multisigWrapper';
import Message from './message';

/**
 * Prepare a transfer transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - The un-prepared transfer transaction object
 * @param {number} network - A network id
 *
 * @return {object} - A [TransferTransaction]{@link http://bob.nem.ninja/docs/#transferTransaction} object ready for serialization
 */
let prepare = function(common, tx, network){
    if (!common || !tx || !network) throw new Error('Missing parameter !');
	let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let recipientCompressedKey = tx.recipient.toString();
    let amount = Math.round(tx.amount * 1000000);
    let message = Message.prepare(common, tx);
    let msgFee = Fees.calculateMessage(message, common.isHW);
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let mosaics = null;
    let mosaicsFee = null
    let entity = _construct(actualSender, recipientCompressedKey, amount, message, msgFee, due, mosaics, mosaicsFee, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/**
 * Prepare a mosaic transfer transaction object
 *
 * @param {object} common - A common object
 * @param {object} tx - The un-prepared transfer transaction object
 * @param {object} mosaicDefinitionMetaDataPair - The mosaicDefinitionMetaDataPair object with properties of mosaics to send
 * @param {number} network - A network id
 *
 * @return {object} - A [TransferTransaction]{@link http://bob.nem.ninja/docs/#transferTransaction} object ready for serialization
 */
let prepareMosaic = function(common, tx, mosaicDefinitionMetaDataPair, network){
    if (!common || !tx || !mosaicDefinitionMetaDataPair || tx.mosaics === null || !network) throw new Error('Missing parameter !');
    let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));
    let actualSender = tx.isMultisig ? tx.multisigAccount.publicKey : kp.publicKey.toString();
    let recipientCompressedKey = tx.recipient.toString();
    let amount = Math.round(tx.amount * 1000000);
    let message = Message.prepare(common, tx);
    let msgFee = Fees.calculateMessage(message, common.isHW);
    let due = network === Network.data.testnet.id ? 60 : 24 * 60;
    let mosaics = tx.mosaics;
    let mosaicsFee = Fees.calculateMosaics(amount, mosaicDefinitionMetaDataPair, mosaics);
    let entity = _construct(actualSender, recipientCompressedKey, amount, message, msgFee, due, mosaics, mosaicsFee, network);
    if (tx.isMultisig) {
        entity = MultisigWrapper(kp.publicKey.toString(), entity, due, network);
    }
    return entity;
}

/***
 * Create a transfer transaction object
 *
 * @param {string} senderPublicKey - The sender account public key
 * @param {string} recipientCompressedKey - The recipient account public key
 * @param {number} amount - The amount to send in micro XEM
 * @param {object} message - The message object
 * @param {number} due - The deadline in minutes
 * @param {array} mosaics - The array of mosaics to send
 * @param {number} mosaicFee - The fees for mosaics included in the transaction
 * @param {number} network - A network id
 *
 * @return {object} - A [TransferTransaction]{@link http://bob.nem.ninja/docs/#transferTransaction} object
 */
let _construct = function(senderPublicKey, recipientCompressedKey, amount, message, msgFee, due, mosaics, mosaicsFee, network) {
    let timeStamp = Helpers.createNEMTimeStamp();
    let version = mosaics ? Network.getVersion(2, network) : Network.getVersion(1, network);
    let data = Objects.create("commonTransactionPart")(TransactionTypes.transfer, senderPublicKey, timeStamp, due, version);
    let fee = mosaics ? mosaicsFee : Fees.currentFeeFactor * Fees.calculateMinimum(amount / 1000000);
    let totalFee = Math.floor((msgFee + fee) * 1000000);
    let custom = {
        'recipient': recipientCompressedKey.toUpperCase().replace(/-/g, ''),
        'amount': amount,
        'fee': totalFee,
        'message': message,
        'mosaics': mosaics
    };
    let entity = Helpers.extendObj(data, custom);
    return entity;
}

module.exports = {
    prepare,
    prepareMosaic
}
'''
'''--- src/model/wallet.js ---
import nacl from '../external/nacl-fast';
import convert from '../utils/convert';
import Helpers from '../utils/helpers';
import KeyPair from '../crypto/keyPair';
import CryptoHelpers from '../crypto/cryptoHelpers';
import Address from '../model/address';
import Objects from './objects';

/**
 * Create a wallet containing a private key generated using a Pseudo Random Number Generator
 *
 * @param {string} walletName - The wallet name
 * @param {string} password - The wallet password
 * @param {number} network - The network id
 *
 * @return {object} - A PRNG wallet object
 */
let createPRNG = function (walletName, password, network) {
    if (!walletName.length || !password.length || !network) throw new Error('A parameter is missing !');
    // Generate keypair from random private key
    var privateKey = convert.ua2hex(nacl.randomBytes(32));
    var kp = KeyPair.create(privateKey);
    // Create address from public key
    let addr = Address.toAddress(kp.publicKey.toString(), network);
    // Encrypt private key using password
    let encrypted = CryptoHelpers.encodePrivKey(privateKey, password);
    return Objects.create("wallet")(walletName, addr, true, "pass:bip32", encrypted, network);
}

/**
 * Create a wallet containing a private key generated using a derived passphrase
 *
 * @param {string} walletName - The wallet name
 * @param {string} passphrase - The wallet passphrase
 * @param {number} network - The network id
 *
 * @return {object} - A Brain wallet object
 */
let createBrain = function (walletName, passphrase, network) {
    if (!walletName.length || !passphrase.length || !network) throw new Error('A parameter is missing !');
    var privateKey = CryptoHelpers.derivePassSha(passphrase, 6000).priv;
    var kp = KeyPair.create(privateKey);
    // Create address from public key
    let addr = Address.toAddress(kp.publicKey.toString(), network);
    return Objects.create("wallet")(walletName, addr, true, "pass:6k", "", network);
}

/**
 * Create a wallet containing any private key
 *
 * @param {string} walletName - The wallet name
 * @param {string} password - The wallet passphrase
 * @param {string} privateKey - The private key to import
 * @param {number} network - The network id
 *
 * @return {object} - A private key wallet object
 */
let importPrivateKey = function (walletName, password, privateKey, network) {
    if (!walletName.length || !password.length || !network || !privateKey) throw new Error('A parameter is missing !');
    if (!Helpers.isPrivateKeyValid(privateKey)) throw new Error('Private key is not valid !');
    // Create address from private key
    let kp = KeyPair.create(privateKey);
    let addr = Address.toAddress(kp.publicKey.toString(), network);
    // Encrypt private key using password
    let encrypted = CryptoHelpers.encodePrivKey(privateKey, password);
    return Objects.create("wallet")(walletName, addr, false, "pass:enc", encrypted, network);
}

module.exports = {
    createPRNG,
    createBrain,
    importPrivateKey
}
'''
'''--- src/utils/convert.js ---
import CryptoJS from 'crypto-js';

const _hexEncodeArray = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

/**
* Reversed convertion of hex to Uint8Array
*
* @param {string} hexx - An hex string
*
* @return {Uint8Array}
*/
let hex2ua_reversed = function(hexx) {
    let hex = hexx.toString(); //force conversion
    let ua = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        ua[ua.length - 1 - (i / 2)] = parseInt(hex.substr(i, 2), 16);
    }
    return ua;
};

/**
* Convert hex to Uint8Array
*
* @param {string} hexx - An hex string
*
* @return {Uint8Array}
*/
let hex2ua = function(hexx) {
    let hex = hexx.toString(); //force conversion
    let ua = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        ua[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return ua;
};

/**
* Convert an Uint8Array to hex
*
* @param {Uint8Array} ua - An Uint8Array
*
* @return {string}
*/
let ua2hex = function(ua) {
    let s = '';
    for (let i = 0; i < ua.length; i++) {
        let code = ua[i];
        s += _hexEncodeArray[code >>> 4];
        s += _hexEncodeArray[code & 0x0F];
    }
    return s;
};

/**
* Convert hex to string
*
* @param {string} hexx - An hex string
*
* @return {string}
*/
let hex2a = function(hexx) {
    let hex = hexx.toString();
    let str = '';
    for (let i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
};

/**
* Convert UTF-8 to hex
*
* @param {string} str - An UTF-8 string
*
* @return {string}
*/
let utf8ToHex = function(str) {
    let rawString = rstr2utf8(str);
    let hex = "";
    for (var i = 0; i < rawString.length; i++) {
        hex += strlpad(rawString.charCodeAt(i).toString(16), "0", 2)
    }
    return hex;
};

// Padding helper for above function
let strlpad = function(str, pad, len) {
    while (str.length < len) {
        str = pad + str;
    }
    return str;
}

/**
* Convert an Uint8Array to WordArray
*
* @param {Uint8Array} ua - An Uint8Array
* @param {number} uaLength - The Uint8Array length
*
* @return {WordArray}
*/
let ua2words = function(ua, uaLength) {
    let temp = [];
    for (let i = 0; i < uaLength; i += 4) {
        let x = ua[i] * 0x1000000 + (ua[i + 1] || 0) * 0x10000 + (ua[i + 2] || 0) * 0x100 + (ua[i + 3] || 0);
        temp.push((x > 0x7fffffff) ? x - 0x100000000 : x);
    }
    return CryptoJS.lib.WordArray.create(temp, uaLength);
}

/**
* Convert a wordArray to Uint8Array
*
* @param {Uint8Array} destUa - A destination Uint8Array
* @param {WordArray} cryptowords - A wordArray
*
* @return {Uint8Array}
*/
let words2ua = function(destUa, cryptowords) {
    for (let i = 0; i < destUa.length; i += 4) {
        let v = cryptowords.words[i / 4];
        if (v < 0) v += 0x100000000;
        destUa[i] = (v >>> 24);
        destUa[i + 1] = (v >>> 16) & 0xff;
        destUa[i + 2] = (v >>> 8) & 0xff;
        destUa[i + 3] = v & 0xff;
    }
    return destUa;
}

/**
* Converts a raw javascript string into a string of single byte characters using utf8 encoding.
* This makes it easier to perform other encoding operations on the string.
*
* @param {string} input - A raw string
*
* @return {string} - UTF-8 string
*/
let rstr2utf8 = function (input) {
    let output = "";

    for (let n = 0; n < input.length; n++) {
        let c = input.charCodeAt(n);

        if (c < 128) {
            output += String.fromCharCode(c);
        } else if ((c > 127) && (c < 2048)) {
            output += String.fromCharCode((c >> 6) | 192);
            output += String.fromCharCode((c & 63) | 128);
        } else {
            output += String.fromCharCode((c >> 12) | 224);
            output += String.fromCharCode(((c >> 6) & 63) | 128);
            output += String.fromCharCode((c & 63) | 128);
        }
    }

    return output;
}

// Does the reverse of rstr2utf8.
let utf82rstr = function (input) {
    let output = "", i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;

    while (i < input.length) {
        c = input.charCodeAt(i);

        if (c < 128) {
            output += String.fromCharCode(c);
            i++;
        } else if ((c > 191) && (c < 224)) {
            c2 = input.charCodeAt(i + 1);
            output += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = input.charCodeAt(i + 1);
            c3 = input.charCodeAt(i + 2);
            output += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }

    return output;
}

module.exports = {
    hex2ua_reversed,
    hex2ua,
    ua2hex,
    hex2a,
    utf8ToHex,
    ua2words,
    words2ua,
    rstr2utf8,
    utf82rstr
}

'''
'''--- src/utils/format.js ---
import convert from './convert';
import Address from '../model/address';
import TransactionTypes from '../model/transactionTypes';

/**
* Convert a public key to NEM address
*
* @param {string} input - The account public key
* @param {number} networkId - The current network id
*
* @return {string} - A clean NEM address
*/
let pubToAddress = function(input, networkId) {
    return input && Address.toAddress(input, networkId);
}

/**
* Add hyphens to a clean address
*
* @param {string} input - A NEM address
*
* @return {string} - A formatted NEM address
*/
let address = function(input) {
    return input && input.toUpperCase().replace(/-/g, '').match(/.{1,6}/g).join('-');
}

/**
* Format a timestamp to NEM date
*
* @param {number} data - A timestamp
*
* @return {string} - A date string
*/
let nemDate = function(data) {
    let nemesis = Date.UTC(2015, 2, 29, 0, 6, 25);
    if (data === undefined) return data;
    let o = data;
    let t = (new Date(nemesis + o * 1000));
    return t.toUTCString();
}

let supply = function(data, mosaicId, mosaics) {
    if (data === undefined) return data;
    let mosaicName = mosaicIdToName(mosaicId);
    if (!(mosaicName in mosaics)) {
        return ['unknown mosaic divisibility', data];
    }
    let mosaicDefinitionMetaDataPair = mosaics[mosaicName];
    let divisibilityProperties = $.grep(mosaicDefinitionMetaDataPair.mosaicDefinition.properties, function(w) {
        return w.name === "divisibility";
    });
    let divisibility = divisibilityProperties.length === 1 ? ~~(divisibilityProperties[0].value) : 0;
    let o = parseInt(data, 10);
    if (!o) {
        if (divisibility === 0) {
            return ["0", ''];
        } else {
            return ["0", o.toFixed(divisibility).split('.')[1]];
        }
    }
    o = o / Math.pow(10, divisibility);
    let b = o.toFixed(divisibility).split('.');
    let r = b[0].split(/(?=(?:...)*$)/).join(" ");
    return [r, b[1] || ""];
}

let supplyRaw = function(data, _divisibility) {
    let divisibility = ~~_divisibility;
    let o = parseInt(data, 10);
    if (!o) {
        if (divisibility === 0) {
            return ["0", ''];
        } else {
            return ["0", o.toFixed(divisibility).split('.')[1]];
        }
    }
    o = o / Math.pow(10, divisibility);
    let b = o.toFixed(divisibility).split('.');
    let r = b[0].split(/(?=(?:...)*$)/).join(" ");
    return [r, b[1] || ""];
}

let levyFee = function(mosaic, multiplier, levy, mosaics) {
        if (mosaic === undefined || mosaics === undefined) return mosaic;
        if (levy === undefined || levy.type === undefined) return undefined;
        let levyValue;
        if (levy.type === 1) {
            levyValue = levy.fee;
        } else {
            // Note, multiplier is in micro NEM
            levyValue = (multiplier / 1000000) * mosaic.quantity * levy.fee / 10000;
        }
        let r = supply(levyValue, levy.mosaicId, mosaics);
        return r[0] + "." + r[1];
    };

/**
* Format a NEM importance score
*
* @param {number} data -  The importance score
*
* @return {array} - A formatted importance score at 10^-4
*/
let nemImportanceScore = function(data) {
    if (data === undefined) return data;
    let o = data;
    if (o) {
        o *= 10000;
        o = o.toFixed(4).split('.');
        return [o[0], o[1]];
    }
    return [o, 0];
}

/**
* Format a value to NEM value
*
* @param {number} data - An amount of XEM
*
* @return {array} - An array with values before and after decimal point
*/
let nemValue = function(data) {
    if (data === undefined) return data;
        let o = data;
        if (!o) {
            return ["0", '000000'];
        } else {
            o = o / 1000000;
            let b = o.toFixed(6).split('.');
            let r = b[0].split(/(?=(?:...)*$)/).join(" ");
            return [r, b[1]];
    }
}

/**
* Return name of an importance transfer mode
*
* @return {string} - An importance transfer mode name
*/
let importanceTransferMode = function(data) {
    if (data === undefined) return data;
    let o = data;
    if (o === 1) return "Activation";
    else if (o === 2) return "Deactivation";
    else return "Unknown";
}

/**
* Convert hex to utf8
*
* @param {string} data - Hex data
*
* @return {string} result - Utf8 string
*/
let hexToUtf8 = function(data) {
    if (data === undefined) return data;
    let o = data;
    if (o && o.length > 2 && o[0] === 'f' && o[1] === 'e') {
        return "HEX: " + o.slice(2);
    }
    let result;
    try {
        result = decodeURIComponent(escape(convert.hex2a(o)))
    } catch (e) {
        //result = "Error, message not properly encoded !";
        result = convert.hex2a(o);
        console.log('invalid text input: ' + data);
    }
    //console.log(decodeURIComponent(escape( convert.hex2a(o) )));*/
    //result = convert.hex2a(o);
    return result;
}

/**
* Verify if message is not encrypted and return utf8
*
* @param {object} msg - A message object
*
* @return {string} result - Utf8 string
*/
let hexMessage = function(msg) {
    if (msg === undefined) return msg;
    if (msg.type === 1) {
        return hexToUtf8(msg.payload);
    } else {
        return '';
    }
};

/**
* Split hex string into 64 characters segments
*
* @param {string} data - An hex string
*
* @return {array} - A segmented hex string
*/
let splitHex = function(data) {
    if (data === undefined) return data;
    let parts = data.match(/[\s\S]{1,64}/g) || [];
    let r = parts.join("\n");
    return r;
}

/**
 * Return mosaic name from mosaicId object
 *
 * @param {object} mosaicId - A mosaicId object
 *
 * @return {string} - The mosaic name
 */
let mosaicIdToName = function(mosaicId) {
    if (!mosaicId) return mosaicId;
    return mosaicId.namespaceId + ":" + mosaicId.name;
}

/**
 * Return the name of a transaction type id
 *
 * @param {number} id - A transaction type id
 *
 * @return {string} - The transaction type name
 */
let txTypeToName = function(id) {
    switch (id) {
        case TransactionTypes.transfer:
            return 'Transfer';
        case TransactionTypes.importanceTransfer:
            return 'ImportanceTransfer';
        case TransactionTypes.multisigModification:
            return 'MultisigModification';
        case TransactionTypes.provisionNamespace:
            return 'ProvisionNamespace';
        case TransactionTypes.mosaicDefinition:
            return 'MosaicDefinition';
        case TransactionTypes.mosaicSupply:
            return 'MosaicSupply';
        default:
            return 'Unknown_' + id;
    }
}

module.exports = {
    splitHex,
    hexMessage,
    hexToUtf8,
    importanceTransferMode,
    nemValue,
    nemImportanceScore,
    levyFee,
    supplyRaw,
    supply,
    nemDate,
    pubToAddress,
    address,
    mosaicIdToName,
    txTypeToName
}
'''
'''--- src/utils/helpers.js ---
import convert from './convert';
import Format from './format';

/**
 * Check if a multisig transaction needs signature
 *
 * @param {object} multisigTransaction - A multisig transaction
 * @param {object} data - An account data
 *
 * @return {boolean} - True if it needs signature, false otherwise
 */
let needsSignature = function(multisigTransaction, data) {
    if (multisigTransaction.transaction.signer === data.account.publicKey) {
        return false;
    }
    if (multisigTransaction.transaction.otherTrans.signer === data.account.publicKey) {
        return false;
    }
    // Check if we're already on list of signatures
    for (let i = 0; i < multisigTransaction.transaction.signatures.length; i++) {
        if (multisigTransaction.transaction.signatures[i].signer === data.account.publicKey) {
            return false;
        }
    }

    if (!data.meta.cosignatoryOf.length) {
        return false;
    } else {
        for (let k = 0; k < data.meta.cosignatoryOf.length; k++) {
            if (data.meta.cosignatoryOf[k].publicKey === multisigTransaction.transaction.otherTrans.signer) {
                return true;
            } else if (k === data.meta.cosignatoryOf.length - 1) {
                return false;
            }
        }
    }
    return true;
}

/**
 * Check if a transaction is already present in an array of transactions
 *
 * @param {string} hash - A transaction hash
 * @param {array} array - An array of transactions
 *
 * @return {boolean} - True if present, false otherwise
 */
let haveTx = function(hash, array) {
    let i = null;
    for (i = 0; array.length > i; i++) {
        if (array[i].meta.hash.data === hash) {
            return true;
        }
    }
    return false;
};

/**
 * Gets the index of a transaction in an array of transactions.
 * It must be present in the array.
 *
 * @param {string} hash - A transaction hash
 * @param {array} array - An array of transactions
 *
 * @return {number} - The index of the transaction
 */
let getTransactionIndex = function(hash, array) {
    let i = null;
    for (i = 0; array.length > i; i++) {
        if (array[i].meta.hash.data === hash) {
            return i;
        }
    }
    return 0;
};

/**
 * Check if a cosignatory is already present in modifications array
 *
 * @param {string} pubKey - A cosignatory public key
 * @param {array} array - A modifications array
 *
 * @return {boolean} - True if present, false otherwise
 */
let haveCosig = function(pubKey, array) {
    let i = null;
    for (i = 0; array.length > i; i++) {
        if (array[i].cosignatoryAccount === pubKey) {
            return true;
        }
    }
    return false;
};

/***
 * NEM epoch time
 *
 * @type {number}
 */
let NEM_EPOCH = Date.UTC(2015, 2, 29, 0, 6, 25, 0);

/**
 * Create a time stamp for a NEM transaction
 *
 * @return {number} - The NEM transaction time stamp in milliseconds
 */
let createNEMTimeStamp = function() {
    return Math.floor((Date.now() / 1000) - (NEM_EPOCH / 1000));
}

/**
 * Fix a private key
 *
 * @param {string} privatekey - An hex private key
 *
 * @return {string} - The fixed hex private key
 */
let fixPrivateKey = function(privateKey) {
    return ("0000000000000000000000000000000000000000000000000000000000000000" + privateKey.replace(/^00/, '')).slice(-64);
}

/**
 * Check if a private key is valid
 *
 * @param {string} privatekey - A private key
 *
 * @return {boolean} - True if valid, false otherwise
 */
let isPrivateKeyValid = function(privateKey) {
    if (privateKey.length !== 64 && privateKey.length !== 66) {
        console.error('Private key length must be 64 or 66 characters !');
        return false;
    } else if (!isHexadecimal(privateKey)) {
        console.error('Private key must be hexadecimal only !');
        return false;
    } else {
        return true;
    }
}

/**
 * Check if a public key is valid
 *
 * @param {string} publicKey - A public key
 *
 * @return {boolean} - True if valid, false otherwise
 */
let isPublicKeyValid = function(publicKey) {
    if (publicKey.length !== 64) {
        console.error('Public key length must be 64 or 66 characters !');
        return false;
    } else if (!isHexadecimal(publicKey)) {
        console.error('Public key must be hexadecimal only !');
        return false;
    } else {
        return true;
    }
}
 
/**
 * Create a time stamp
 *
 * @return {object} - A date object
 */
let createTimeStamp = function() {
    return new Date();
}

/**
 * Date object to YYYY-MM-DD format
 *
 * @param {object} date - A date object
 *
 * @return {string} - The short date
 */
let getTimestampShort = function(date) {
    let dd = date.getDate();
    let mm = date.getMonth() + 1; //January is 0!
    let yyyy = date.getFullYear();

    if (dd < 10) {
        dd = '0' + dd
    }

    if (mm < 10) {
        mm = '0' + mm
    }

    return yyyy + '-' + mm + '-' + dd;
};

/**
 * Date object to date string
 *
 * @param {object} date - A date object
 *
 * @return {string} - The date string
 */
let convertDateToString = function(date) {
    return date.toDateString();
};

/**
 * Mimics jQuery's extend function
 *
 * http://stackoverflow.com/a/11197343
 */
let extendObj = function(){
    for(var i=1; i<arguments.length; i++) {
        for(var key in arguments[i]) {
            if(arguments[i].hasOwnProperty(key)) {
                arguments[0][key] = arguments[i][key];
            }
        }
    }
    return arguments[0];
}

/**
 * Test if a string is hexadecimal
 *
 * @param {string} str - A string to test
 *
 * @return {boolean} - True if correct, false otherwise
 */
let isHexadecimal = function(str) {
    return str.match('^(0x|0X)?[a-fA-F0-9]+$') !== null;
}

/**
 * Search for mosaic definition(s) into an array of mosaicDefinition objects
 *
 * @param {array} mosaicDefinitionArray - An array of mosaicDefinition objects
 * @param {array} keys - Array of strings with names of the mosaics to find (['eur', 'usd',...])
 *
 * @return {object} - An object of mosaicDefinition objects
 */
let searchMosaicDefinitionArray = function(mosaicDefinitionArray, keys) {
    let result = {}
    for (let i = 0; i < keys.length; i++) {
        for(let k = 0; k < mosaicDefinitionArray.length; k++) {
            if(mosaicDefinitionArray[k].mosaic.id.name === keys[i]) {
                result[Format.mosaicIdToName(mosaicDefinitionArray[k].mosaic.id)] = mosaicDefinitionArray[k].mosaic;
            }
        }
    }
    return result;
}

/**
 * Mimics jQuery's grep function
 */
let grep = function(items, callback) {
    var filtered = [],
        len = items.length,
        i = 0;
    for (i; i < len; i++) {
        var item = items[i];
        var cond = callback(item);
        if (cond) {
            filtered.push(item);
        }
    }

    return filtered;
};

/**
 * Check if a text input amount is valid
 *
 * @param {string} n - The number as a string
 *
 * @return {boolean} - True if valid, false otherwise
 */
let isTextAmountValid = function(n) {
    // Force n as a string and replace decimal comma by a dot if any
    var nn = Number(n.toString().replace(/,/g, '.'));
    return !Number.isNaN(nn) && Number.isFinite(nn) && nn >= 0;
}

/**
 * Clean a text input amount and return it as number
 *
 * @param {string} n - The number as a string
 *
 * @return {number} - The clean amount
 */
let cleanTextAmount = function(n) {
    return Number(n.toString().replace(/,/g, '.'));
}

/**
 * Convert an endpoint object to an endpoint url
 *
 * @param {object} endpoint - An endpoint object
 *
 * @return {String} - An endpoint url
 */
let formatEndpoint = function(endpoint) {
    return endpoint.host + ':' + endpoint.port;
}

/**
 * Check if data is JSON
 *
 * @param {anything} data - Data to test
 *
 * @return {boolean} - True if JSON, false otherwise
 */
let isJSON = function(data) {
    try {
        JSON.parse(data);
        return true;
    } catch (e) {
        return false;
    }
}

module.exports = {
    needsSignature,
    haveTx,
    getTransactionIndex,
    haveCosig,
    createNEMTimeStamp,
    fixPrivateKey,
    isPrivateKeyValid,
    isPublicKeyValid,
    createTimeStamp,
    getTimestampShort,
    convertDateToString,
    extendObj,
    isHexadecimal,
    searchMosaicDefinitionArray,
    grep,
    isTextAmountValid,
    cleanTextAmount,
    formatEndpoint,
    isJSON
}
'''
'''--- src/utils/nty.js ---
/**
 * Create notary data
 *
 * @param {string} filename - A file name
 * @param {string} tags - File tags
 * @param {string} fileHash - File hash
 * @param {string} txHash - Transaction hash
 * @param {string} txMultisigHash - Multisignature transaction hash
 * @param {string} owner - Account address
 * @param {string} fromMultisig - Multisig account address
 * @param {string} dedicatedAccount - HD account of the file
 * @param {string} dedicatedPrivateKey - Private key of the HD account
 *
 * @return {array} - The notary data
 */
let createNotaryData = function(filename, tags, fileHash, txHash, txMultisigHash, owner, fromMultisig, dedicatedAccount, dedicatedPrivateKey) {
        let d = new Date();
        return { 
            "data": [{
                "filename": filename,
                "tags": tags,
                "fileHash": fileHash,
                "owner": owner,
                "fromMultisig": fromMultisig,
                "dedicatedAccount": dedicatedAccount,
                "dedicatedPrivateKey": dedicatedPrivateKey,
                "txHash": txHash,
                "txMultisigHash": txMultisigHash,
                "timeStamp": d.toUTCString()
            }]
        };
}

/**
 * Update notary data
 *
 * @param {array} ntyData - The notary data array
 * @param {object} newNtyData - A notary data object
 *
 * @return {array} - The updated notary data array
 */
let updateNotaryData = function(ntyData, newNtyData) {
        ntyData.data.push(newNtyData.data[0]);
        return ntyData;
}

module.exports = {
    createNotaryData,
    updateNotaryData
}
'''
'''--- src/utils/serialization.js ---
import convert from './convert';
import Format from './format';
import TransactionTypes from '../model/transactionTypes';

/***
 * NOTE, related to serialization: Unfortunately we need to create few objects
 * and do a bit of copying, as Uint32Array does not allow random offsets
 */

/* safe string - each char is 8 bit */
let _serializeSafeString = function(str) {
    var r = new ArrayBuffer(132);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);

    var e = 4;
    if (str === null) {
        d[0] = 0xffffffff;

    } else {
        d[0] = str.length;
        for (var j = 0; j < str.length; ++j) {
            b[e++] = str.charCodeAt(j);
        }
    }
    return new Uint8Array(r, 0, e);
};

let _serializeUaString = function(str) {
    var r = new ArrayBuffer(516);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);

    var e = 4;
    if (str === null) {
        d[0] = 0xffffffff;

    } else {
        d[0] = str.length;
        for (var j = 0; j < str.length; ++j) {
            b[e++] = str[j];
        }
    }
    return new Uint8Array(r, 0, e);
};

let _serializeLong = function(value) {
    var r = new ArrayBuffer(8);
    var d = new Uint32Array(r);
    d[0] = value;
    d[1] = Math.floor((value / 0x100000000));
    return new Uint8Array(r, 0, 8);
};

let _serializeMosaicId = function(mosaicId) {
    var r = new ArrayBuffer(264);
    var serializedNamespaceId = _serializeSafeString(mosaicId.namespaceId);
    var serializedName = _serializeSafeString(mosaicId.name);

    var b = new Uint8Array(r);
    var d = new Uint32Array(r);
    d[0] = serializedNamespaceId.length + serializedName.length;
    var e = 4;
    for (var j = 0; j < serializedNamespaceId.length; ++j) {
        b[e++] = serializedNamespaceId[j];
    }
    for (var j = 0; j < serializedName.length; ++j) {
        b[e++] = serializedName[j];
    }
    return new Uint8Array(r, 0, e);
};

let _serializeMosaicAndQuantity = function(mosaic) {
    var r = new ArrayBuffer(4 + 264 + 8);
    var serializedMosaicId = _serializeMosaicId(mosaic.mosaicId);
    var serializedQuantity = _serializeLong(mosaic.quantity);

    //$log.info(convert.ua2hex(serializedQuantity), serializedMosaicId, serializedQuantity);

    var b = new Uint8Array(r);
    var d = new Uint32Array(r);
    d[0] = serializedMosaicId.length + serializedQuantity.length;
    var e = 4;
    for (var j = 0; j < serializedMosaicId.length; ++j) {
        b[e++] = serializedMosaicId[j];
    }
    for (var j = 0; j < serializedQuantity.length; ++j) {
        b[e++] = serializedQuantity[j];
    }
    return new Uint8Array(r, 0, e);
};
let _serializeMosaics = function(entity) {
    var r = new ArrayBuffer(276 * 10 + 4);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);

    var i = 0;
    var e = 0;

    d[i++] = entity.length;
    e += 4;

    var temporary = [];
    for (var j = 0; j < entity.length; ++j) {
        temporary.push({
            'entity': entity[j],
            'value': Format.mosaicIdToName(entity[j].mosaicId) + " : " + entity[j].quantity
        })
    }
    temporary.sort(function(a, b) {
        return a.value < b.value ? -1 : a.value > b.value;
    });

    for (var j = 0; j < temporary.length; ++j) {
        var entity = temporary[j].entity;
        var serializedMosaic = _serializeMosaicAndQuantity(entity);
        for (var k = 0; k < serializedMosaic.length; ++k) {
            b[e++] = serializedMosaic[k];
        }
    }

    return new Uint8Array(r, 0, e);
};

let _serializeProperty = function(entity) {
    var r = new ArrayBuffer(1024);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);
    var serializedName = _serializeSafeString(entity['name']);
    var serializedValue = _serializeSafeString(entity['value']);
    d[0] = serializedName.length + serializedValue.length;
    var e = 4;
    for (var j = 0; j < serializedName.length; ++j) {
        b[e++] = serializedName[j];
    }
    for (var j = 0; j < serializedValue.length; ++j) {
        b[e++] = serializedValue[j];
    }
    return new Uint8Array(r, 0, e);
};

let _serializeProperties = function(entity) {
    var r = new ArrayBuffer(1024);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);

    var i = 0;
    var e = 0;

    d[i++] = entity.length;
    e += 4;

    var temporary = entity;

    var temporary = [];
    for (var j = 0; j < entity.length; ++j) {
        temporary.push(entity[j]);
    }

    var helper = {
        'divisibility': 1,
        'initialSupply': 2,
        'supplyMutable': 3,
        'transferable': 4
    };
    temporary.sort(function(a, b) {
        return helper[a.name] < helper[b.name] ? -1 : helper[a.name] > helper[b.name];
    });

    for (var j = 0; j < temporary.length; ++j) {
        var entity = temporary[j];
        var serializedProperty = _serializeProperty(entity);
        for (var k = 0; k < serializedProperty.length; ++k) {
            b[e++] = serializedProperty[k];
        }
    }
    return new Uint8Array(r, 0, e);
};

let _serializeLevy = function(entity) {
    var r = new ArrayBuffer(1024);
    var d = new Uint32Array(r);

    if (entity === null) {
        d[0] = 0;
        return new Uint8Array(r, 0, 4);
    }

    var b = new Uint8Array(r);
    d[1] = entity['type'];

    var e = 8;
    var temp = _serializeSafeString(entity['recipient']);
    for (var j = 0; j < temp.length; ++j) {
        b[e++] = temp[j];
    }

    var serializedMosaicId = _serializeMosaicId(entity['mosaicId']);
    for (var j = 0; j < serializedMosaicId.length; ++j) {
        b[e++] = serializedMosaicId[j];
    }

    var serializedFee = _serializeLong(entity['fee']);
    for (var j = 0; j < serializedFee.length; ++j) {
        b[e++] = serializedFee[j];
    }

    d[0] = 4 + temp.length + serializedMosaicId.length + 8;

    return new Uint8Array(r, 0, e);
};

let _serializeMosaicDefinition = function(entity) {
    var r = new ArrayBuffer(40 + 264 + 516 + 1024 + 1024);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);

    var temp = convert.hex2ua(entity['creator']);
    d[0] = temp.length;
    var e = 4;
    for (var j = 0; j < temp.length; ++j) {
        b[e++] = temp[j];
    }

    var serializedMosaicId = _serializeMosaicId(entity.id);
    for (var j = 0; j < serializedMosaicId.length; ++j) {
        b[e++] = serializedMosaicId[j];
    }

    var utf8ToUa = convert.hex2ua(convert.utf8ToHex(entity['description']));
    var temp = _serializeUaString(utf8ToUa);
    for (var j = 0; j < temp.length; ++j) {
        b[e++] = temp[j];
    }

    var temp = _serializeProperties(entity['properties']);
    for (var j = 0; j < temp.length; ++j) {
        b[e++] = temp[j];
    }

    var levy = _serializeLevy(entity['levy']);
    for (var j = 0; j < levy.length; ++j) {
        b[e++] = levy[j];
    }
    return new Uint8Array(r, 0, e);
};

/**
 * Serialize a transaction object
 *
 * @param {object} entity - A transaction object
 *
 * @return {Uint8Array} - The serialized transaction
 */
let serializeTransaction = function(entity) {
    var r = new ArrayBuffer(512 + 2764);
    var d = new Uint32Array(r);
    var b = new Uint8Array(r);
    d[0] = entity['type'];
    d[1] = entity['version'];
    d[2] = entity['timeStamp'];

    var temp = convert.hex2ua(entity['signer']);
    d[3] = temp.length;
    var e = 16;
    for (var j = 0; j < temp.length; ++j) {
        b[e++] = temp[j];
    }

    // Transaction
    var i = e / 4;
    d[i++] = entity['fee'];
    d[i++] = Math.floor((entity['fee'] / 0x100000000));
    d[i++] = entity['deadline'];
    e += 12;

    // TransferTransaction
    if (d[0] === TransactionTypes.transfer) {
        d[i++] = entity['recipient'].length;
        e += 4;
        // TODO: check that entity['recipient'].length is always 40 bytes
        for (var j = 0; j < entity['recipient'].length; ++j) {
            b[e++] = entity['recipient'].charCodeAt(j);
        }
        i = e / 4;
        d[i++] = entity['amount'];
        d[i++] = Math.floor((entity['amount'] / 0x100000000));
        e += 8;

        if (entity['message']['type'] === 1 || entity['message']['type'] === 2) {
            var temp = convert.hex2ua(entity['message']['payload']);
            if (temp.length === 0) {
                d[i++] = 0;
                e += 4;
            } else {
                // length of a message object
                d[i++] = 8 + temp.length;
                // object itself
                d[i++] = entity['message']['type'];
                d[i++] = temp.length;
                e += 12;
                for (var j = 0; j < temp.length; ++j) {
                    b[e++] = temp[j];
                }
            }
        }

        var entityVersion = d[1] & 0xffffff;
        if (entityVersion >= 2) {
            var temp = _serializeMosaics(entity['mosaics']);
            for (var j = 0; j < temp.length; ++j) {
                b[e++] = temp[j];
            }
        }

        // Provision Namespace transaction
    } else if (d[0] === TransactionTypes.provisionNamespace) {
        d[i++] = entity['rentalFeeSink'].length;
        e += 4;
        // TODO: check that entity['rentalFeeSink'].length is always 40 bytes
        for (var j = 0; j < entity['rentalFeeSink'].length; ++j) {
            b[e++] = entity['rentalFeeSink'].charCodeAt(j);
        }
        i = e / 4;
        d[i++] = entity['rentalFee'];
        d[i++] = Math.floor((entity['rentalFee'] / 0x100000000));
        e += 8;

        var temp = _serializeSafeString(entity['newPart']);
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        var temp = _serializeSafeString(entity['parent']);
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        // Mosaic Definition Creation transaction
    } else if (d[0] === TransactionTypes.mosaicDefinition) {
        var temp = _serializeMosaicDefinition(entity['mosaicDefinition']);
        d[i++] = temp.length;
        e += 4;
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        temp = _serializeSafeString(entity['creationFeeSink']);
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        temp = _serializeLong(entity['creationFee']);
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        // Mosaic Supply Change transaction
    } else if (d[0] === TransactionTypes.mosaicSupply) {
        var serializedMosaicId = _serializeMosaicId(entity['mosaicId']);
        for (var j = 0; j < serializedMosaicId.length; ++j) {
            b[e++] = serializedMosaicId[j];
        }

        var temp = new ArrayBuffer(4);
        d = new Uint32Array(temp);
        d[0] = entity['supplyType'];
        var serializeSupplyType = new Uint8Array(temp);
        for (var j = 0; j < serializeSupplyType.length; ++j) {
            b[e++] = serializeSupplyType[j];
        }

        var serializedDelta = _serializeLong(entity['delta']);
        for (var j = 0; j < serializedDelta.length; ++j) {
            b[e++] = serializedDelta[j];
        }

        // Signature transaction
    } else if (d[0] === TransactionTypes.multisigSignature) {
        var temp = convert.hex2ua(entity['otherHash']['data']);
        // length of a hash object....
        d[i++] = 4 + temp.length;
        // object itself
        d[i++] = temp.length;
        e += 8;
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }
        i = e / 4;

        temp = entity['otherAccount'];
        d[i++] = temp.length;
        e += 4;
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp.charCodeAt(j);
        }

        // Multisig wrapped transaction
    } else if (d[0] === TransactionTypes.multisigTransaction) {
        var temp = serializeTransaction(entity['otherTrans']);
        d[i++] = temp.length;
        e += 4;
        for (var j = 0; j < temp.length; ++j) {
            b[e++] = temp[j];
        }

        // Aggregate Modification transaction
    } else if (d[0] === TransactionTypes.multisigModification) {
        // Number of modifications
        var temp = entity['modifications'];
        d[i++] = temp.length;
        e += 4;

        for (var j = 0; j < temp.length; ++j) {
            // Length of modification structure
            d[i++] = 0x28;
            e += 4;
            // Modification type
            if (temp[j]['modificationType'] == 1) {
                d[i++] = 0x01;
            } else {
                d[i++] = 0x02;
            }
            e += 4;
            // Length of public key
            d[i++] = 0x20;
            e += 4;

            var key2bytes = convert.hex2ua(entity['modifications'][j]['cosignatoryAccount']);

            // Key to Bytes
            for (var k = 0; k < key2bytes.length; ++k) {
                b[e++] = key2bytes[k];
            }
            i = e / 4;
        }

        var entityVersion = d[1] & 0xffffff;
        if (entityVersion >= 2) {
            d[i++] = 0x04;
            e += 4;
            // Relative change
            d[i++] = entity['minCosignatories']['relativeChange'].toString(16);
            e += 4;
        } else {
            // Version 1 has no modifications
        }

    } else if (d[0] === TransactionTypes.importanceTransfer) {
        d[i++] = entity['mode'];
        e += 4;
        d[i++] = 0x20;
        e += 4;
        var key2bytes = convert.hex2ua(entity['remoteAccount']);

        //Key to Bytes
        for (var k = 0; k < key2bytes.length; ++k) {
            b[e++] = key2bytes[k];
        }
    } 

    return new Uint8Array(r, 0, e);
};

module.exports = {
    _serializeSafeString,
    _serializeUaString,
    _serializeLong,
    _serializeMosaicId,
    _serializeMosaicAndQuantity,
    _serializeMosaics,
    _serializeProperty,
    _serializeProperties,
    _serializeLevy,
    _serializeMosaicDefinition,
    serializeTransaction
}
'''
'''--- test/crypto/cryptoHelpers_spec.js ---
import { expect } from 'chai';
import convert from '../../src/utils/convert';
import Format from '../../src/utils/format';
import Network from '../../src/model/network';
import KeyPair from '../../src/crypto/keyPair';
import CryptoHelpers from '../../src/crypto/cryptoHelpers';
import CryptoJS from 'crypto-js';

describe('nem.crypto.helpers tests', function() {

    it("Can check address", function() {
        // Arrange:
        let privatekey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let address = "NCRCWIADNM3UQQTRRFKXBAVHDPZMGVBBXA4J4RE5";

        // Act:
        let result = CryptoHelpers.checkAddress(privatekey, Network.data.mainnet.id, address);

        // Assert:
        expect(result).equal(true);
    });

    it("Can derive a key from password and count", function() {
        // Arrange:
        let password = "TestTest";
        let count = 20;
        let expectedKey = "8cd87bc513857a7079d182a6e19b370e907107d97bd3f81a85bcebcc4b5bd3b5"

        // Act:
        let result = CryptoHelpers.derivePassSha(password, count);

        // Assert:
        expect(result.priv).equal(expectedKey);
    });

    it("Can encrypt a private key", function() {
        // Arrange:
        let password = "TestTest";
        let privateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let expectedKey = "8cd87bc513857a7079d182a6e19b370e907107d97bd3f81a85bcebcc4b5bd3b5";

        // Act:
        let result = CryptoHelpers.encodePrivKey(privateKey, password);
        let pass = CryptoHelpers.derivePassSha(password, 20);
        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(result.ciphertext),
            iv: convert.hex2ua(result.iv),
            key: convert.hex2ua(pass.priv)
        }

        // Assert:
        expect(pass.priv).equal(expectedKey);
        expect(result.iv.length).equal(16 * 2);
        expect(result.ciphertext.length).equal(48 * 2);
    });

    it("Can decrypt a private key", function() {
        // Arrange:
        let password = "TestTest";
        let expectedPrivateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let key = "8cd87bc513857a7079d182a6e19b370e907107d97bd3f81a85bcebcc4b5bd3b5";
        let encrypted = "c09ef3ed0cadd6ca6d3638b5dd854ac871a0afaec6b7fed791166b571a64d57f564376dc0180c851b0a1120b5896e6a0";
        let iv = "0329814121c7a4bb11418084dbe40560";
        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(encrypted),
            iv: convert.hex2ua(iv),
            key: convert.hex2ua(key)
        }

        // Act:
        let decrypted = CryptoHelpers.decrypt(obj);

        // Assert:
        expect(decrypted).equal(expectedPrivateKey);
    });

    it("Can encrypt and decrypt private Key", function() {
        // Arrange:
        let password = "TestTest";
        let privateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";

        // Act:
        let result = CryptoHelpers.encodePrivKey(privateKey, password);
        let pass = CryptoHelpers.derivePassSha(password, 20);
        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(result.ciphertext),
            iv: convert.hex2ua(result.iv),
            key: convert.hex2ua(pass.priv)
        }
        let decrypted = CryptoHelpers.decrypt(obj);

        // Assert:
        expect(privateKey).equal(decrypted);
    });

    describe('Encrypt private key edge-cases', function() {

        it("Encryption throw error if no password", function() {
            // Arrange:
            let password = "";
            let privateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";

            // Act:
            let result = CryptoHelpers.encodePrivKey.bind(null, privateKey, password);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

        it("Encryption throw error if no private key", function() {
            // Arrange:
            let password = "TestTest";
            let privateKey = "";

            // Act
            let result = CryptoHelpers.encodePrivKey.bind(null, privateKey, password);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

    });

    it("Can decrypt private key of pass:enc wallets", function() {
        // Arrange:
        let common = {
            'password': 'TestTest',
            'privateKey': ''
        }
        let walletAccount = {
            "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
            "iv": "dccffaa4883cda85d6b06714aabe6ec6",
        }
        let mainAlgo = "pass:enc";
        let expectedPrivateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";

        // Act:
        let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

        // Assert:
        expect(result).equal(true);
        expect(common.privateKey).equal(expectedPrivateKey);
    });

    it("Can decrypt private key of pass:bip32 wallets", function() {
        // Arrange:
        let common = {
            'password': 'TestTest',
            'privateKey': ''
        }
        let walletAccount = {
            "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
            "iv": "dccffaa4883cda85d6b06714aabe6ec6",
        }
        let mainAlgo = "pass:bip32";
        let expectedPrivateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";

        // Act:
        let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

        // Assert:
        expect(result).equal(true);
        expect(common.privateKey).equal(expectedPrivateKey);
    });

    it("Can decrypt private key of pass:6k wallets", function() {
        // Arrange:
        let common = {
            'password': 'TestTest',
            'privateKey': ''
        }
        let walletAccount = {
            "encrypted": "",
            "iv": ""
        }
        let mainAlgo = "pass:6k";
        let expectedPrivateKey = "8fac70ea9aca3ae3418e25c0d31d9a0723e0a1790ae8fa97747c00dc0037472e";

        // Act:
        let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

        // Assert:
        expect(result).equal(true);
        expect(common.privateKey).equal(expectedPrivateKey);
    });

    it("Can decrypt private key of pass:6k wallets childs", function() {
        // Arrange:
        let common = {
            'password': 'TestTest',
            'privateKey': ''
        }
        let walletAccount = {
            "encrypted": "5c3a7ebbefb391e5175a29ec5a22cb162cd590bb2e0b09416273f86bdc39fa83c04c4bb53b9c64fd1e6eaba5dba149bd",
            "iv": "f131d9a4dfb1b0b696e05ccae9412e8f"
        }
        let mainAlgo = "pass:6k";
        let expectedPrivateKey = "4f27ca43521bbc394a6f6dde65b533e0768f954fa47ce320b0e9f4b5fe450f9d";

        // Act:
        let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

        // Assert:
        expect(result).equal(true);
        expect(common.privateKey).equal(expectedPrivateKey);
    });

    describe('Decrypt private key edge-cases', function() {

        it("Private key decryption throw error if no algo", function() {
            // Arrange:
            let common = {
                'password': 'TestTest',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
                "iv": "dccffaa4883cda85d6b06714aabe6ec6",
            }
            let mainAlgo = "";
            let expectedPrivateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey.bind(null, common, walletAccount, mainAlgo);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

        it("Decryption of pass:enc wallets thow error if no password", function() {
            // Arrange:
            let common = {
                'password': '',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
                "iv": "dccffaa4883cda85d6b06714aabe6ec6",
            }
            let mainAlgo = "pass:enc";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey.bind(null, common, walletAccount, mainAlgo);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

        it("Decryption of pass:bip32 wallets throw error if no password", function() {
            // Arrange:
            let common = {
                'password': '',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
                "iv": "dccffaa4883cda85d6b06714aabe6ec6",
            }
            let mainAlgo = "pass:bip32";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey.bind(null, common, walletAccount, mainAlgo);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

        it("Decryption of pass:6k wallets throw error if no password", function() {
            // Arrange:
            let common = {
                'password': '',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
                "iv": "dccffaa4883cda85d6b06714aabe6ec6",
            }
            let mainAlgo = "pass:6k";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey.bind(null, common, walletAccount, mainAlgo);

            // Assert:
            expect(result).to.throw('Missing argument !');
        });

        it("Decryption of pass:6k wallets generate a private key if no encrypted and iv in wallet account", function() {
            // Arrange:
            let common = {
                'password': 'TestTest',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "",
                "iv": "",
            }
            let mainAlgo = "pass:6k";
            let expectedPrivateKey = "8fac70ea9aca3ae3418e25c0d31d9a0723e0a1790ae8fa97747c00dc0037472e";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

            // Assert:
            expect(result).equal(true);
            expect(common.privateKey).equal(expectedPrivateKey);
        });

        it("Decryption of pass:6k wallets return false if encrypted data but no iv", function() {
            // Arrange:
            let common = {
                'password': 'TestTest',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "2e1717f245b7e1138b0dfe99dfce65b16b1c9d8ca03a9f90b86b43677b6337ce56ec474c64f73244790eb2490ad14752",
                "iv": "",
            }
            let mainAlgo = "pass:6k";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

            // Assert:
            expect(result).equal(false);
            expect(common.privateKey).equal("");
        });

        it("Decryption of pass:6k wallets return false if no encrypted data but iv", function() {
            // Arrange:
            let common = {
                'password': 'TestTest',
                'privateKey': ''
            }
            let walletAccount = {
                "encrypted": "",
                "iv": "dccffaa4883cda85d6b06714aabe6ec6",
            }
            let mainAlgo = "pass:6k";

            // Act:
            let result = CryptoHelpers.passwordToPrivatekey(common, walletAccount, mainAlgo);

            // Assert:
            expect(result).equal(false);
            expect(common.privateKey).equal("");
        });

    });

    it("Can encode message with sender private key", function() {
        // Arrange:
        let senderPriv = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let recipientPublic = "5aae0b521c59cfc8c2114dc74d2f652359a68e377657c3f6bd6091f16f72e1ec";
        let message = "NEM is awesome !";
        let iv = "f396cf605ee7cb0e7618df82aa48c684";
        let salt = "5f8d37e8116b6dc9171ffeb7617b0988bfd8abe0e611c2c34cc127b637d8192a";
        let expectedHex = "5f8d37e8116b6dc9171ffeb7617b0988bfd8abe0e611c2c34cc127b637d8192af396cf605ee7cb0e7618df82aa48c684eb60d26923a2672758f7df7b1430a026e88fea1f4bb3171ab213a5679b9fb9d9";

        // Act:
        let encryptedHex = CryptoHelpers._encode(senderPriv, recipientPublic, message, convert.hex2ua(iv), convert.hex2ua(salt));

        // Assert:
        expect(encryptedHex).equal(expectedHex);
    });

    it("Can decode message with recipient private key", function() {
        // Arrange:
        let senderPublic = "9291abb3c52134be9d20ef21a796743497df7776d2661237bda9cadade34e44c";
        let recipientPriv = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
        let expectedMessage = "NEM is awesome !";
        let encryptedMessage = "dd31d6b4111c1023bae6533399e74f73a29c6e6b48ab550f8a7bea127e27dddb4fd3fe4fad3c835307c0da52d9c268f56237d1810e07912e6a6568cba09d9a9176ee6b1ade9569c2e1e273e9675bd4ff";

        // Act:
        let decrypted = {
            'type': 1,
            'payload': CryptoHelpers.decode(recipientPriv, senderPublic, encryptedMessage)
        };
        let decryptedMessage = Format.hexMessage(decrypted);

        // Assert:
        expect(decryptedMessage).equal(expectedMessage);
    });

    it("Roundtrip decode encode", function() {
        // Arrange:
        let senderPriv = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let sender = KeyPair.create(senderPriv);
        let recipientPriv = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
        let recipient = KeyPair.create(recipientPriv);
        let message = "NEM is awesome !";
        let encryptedMessage = "dd31d6b4111c1023bae6533399e74f73a29c6e6b48ab550f8a7bea127e27dddb4fd3fe4fad3c835307c0da52d9c268f56237d1810e07912e6a6568cba09d9a9176ee6b1ade9569c2e1e273e9675bd4ff";

        // Act:
        let decrypted = {
            'type': 1,
            'payload': CryptoHelpers.decode(recipientPriv, sender.publicKey.toString(), encryptedMessage)
        };
        let decryptedMessage = Format.hexMessage(decrypted);

        let encrypted = CryptoHelpers.encode(recipientPriv, sender.publicKey.toString(), decryptedMessage);

        // Assert:
        expect(decryptedMessage).equal(message);
        expect(encrypted.length).equal(80 * 2);
    });

    it("Roundtrip encode decode", function() {
        // Arrange:
        let senderPriv = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let sender = KeyPair.create(senderPriv);
        let recipientPriv = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
        let recipient = KeyPair.create(recipientPriv);
        let message = "NEM is awesome !";

        // Act:
        let encrypted = CryptoHelpers.encode(senderPriv, recipient.publicKey.toString(), message);
        let decrypted = {
            'type': 1,
            'payload': CryptoHelpers.decode(recipientPriv, sender.publicKey.toString(), encrypted)
        };
        let decryptedMessage = Format.hexMessage(decrypted);

        // Assert:
        expect(decryptedMessage).equal(message);
    });

    describe('Encode & decode message edge-cases', function() {

        it("Message encoding throw error if no sender private key", function() {
            // Arrange:
            let senderPriv = "";
            let recipientPublic = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
            let message = "NEM is awesome !";

            // Act:
            let result = CryptoHelpers.encode.bind(null, senderPriv, recipientPublic, message);

            // Assert:
            expect(result).to.throw();
        });

        it("Message encoding throw error if no recipient public key", function() {
            // Arrange:
            let senderPriv = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
            let recipientPublic = "";
            let message = "NEM is awesome !";

            // Act:
            let result = CryptoHelpers.encode.bind(null, senderPriv, recipientPublic, message);

            // Assert:
            expect(result).to.throw();
        });

        it("Message encoding throw error if no message", function() {
            // Arrange:
            let senderPriv = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
            let recipientPublic = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
            let message = "";

            // Act:
            let result = CryptoHelpers.encode.bind(null, senderPriv, recipientPublic, message);

            // Assert:
            expect(result).to.throw();
        });

        it("Message decoding throw error if no recipient private key", function() {
            // Arrange:
            let senderPublic = "9291abb3c52134be9d20ef21a796743497df7776d2661237bda9cadade34e44c";
            let recipientPriv = "";
            let message = "NEM is awesome !";
            let encryptedMessage = "dd31d6b4111c1023bae6533399e74f73a29c6e6b48ab550f8a7bea127e27dddb4fd3fe4fad3c835307c0da52d9c268f56237d1810e07912e6a6568cba09d9a9176ee6b1ade9569c2e1e273e9675bd4ff";

            // Act:
            let result = CryptoHelpers.decode.bind(null, recipientPriv, senderPublic, encryptedMessage);

            // Assert:
            expect(result).to.throw();
        });

        it("Message decoding throw error if no sender public key", function() {
            // Arrange:
            let senderPublic = "";
            let recipientPriv = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
            let message = "NEM is awesome !";
            let encryptedMessage = "dd31d6b4111c1023bae6533399e74f73a29c6e6b48ab550f8a7bea127e27dddb4fd3fe4fad3c835307c0da52d9c268f56237d1810e07912e6a6568cba09d9a9176ee6b1ade9569c2e1e273e9675bd4ff";

            // Act:
            let result = CryptoHelpers.decode.bind(null, recipientPriv, senderPublic, encryptedMessage);

            // Assert:
            expect(result).to.throw();
        });

        it("Message decoding throw error if no payload", function() {
            // Arrange:
            let senderPublic = "9291abb3c52134be9d20ef21a796743497df7776d2661237bda9cadade34e44c";
            let recipientPriv = "2618090794e9c9682f2ac6504369a2f4fb9fe7ee7746f9560aca228d355b1cb9";
            let message = "NEM is awesome !";
            let encryptedMessage = "";

            // Act:
            let result = CryptoHelpers.decode.bind(null, recipientPriv, senderPublic, encryptedMessage)

            // Assert:
            expect(result).to.throw();
        });

    });

    it("Can encrypt and decrypt private key for mobile", function() {
        // Arrange:
        let privateKey = "2a91e1d5c110a8d0105aad4683f962c2a56663a3cad46666b16d243174673d90";
        let password = "TestTest";

        // Act:
        let result = CryptoHelpers.toMobileKey(password, privateKey);
        let encrypted = result.encrypted;
        let salt = CryptoJS.enc.Hex.parse(result.salt);

        let key = CryptoJS.PBKDF2(password, salt, {
            keySize: 256 / 32,
            iterations: 2000
        });
        
        let iv = encrypted.substring(0, 32);
        let encryptedPrvKey = encrypted.substring(32, 128);

        let obj = {
            ciphertext: CryptoJS.enc.Hex.parse(encryptedPrvKey),
            iv: convert.hex2ua(iv),
            key: convert.hex2ua(key.toString())
        }

        let decrypted = CryptoHelpers.decrypt(obj);
        
        // Assert:
        expect(encrypted.length).equal(128);
        expect(salt.toString().length).equal(32 * 2);
        expect(decrypted).equal(privateKey);
    });
});
'''
'''--- test/crypto/keyPair_spec.js ---
import { expect } from 'chai';
import KeyPair from '../../src/crypto/keyPair';

describe('nem.crypto.keyPair tests', function() {

    it("Can create keypair from hex private key", function() {
        // Arrange:
        let privateKey = "c9fb7f16b738b783be5192697a684cba4a36adb3d9c22c0808f30ae1d85d384f";
        let expectedPublicKey = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";

        // Act:
        let kp = KeyPair.create(privateKey);

        // Assert:
        expect(kp.publicKey.toString()).equal(expectedPublicKey);
    });

    it("Can sign data with private key", function() {
        // Arrange:
        let privateKey = "abf4cf55a2b3f742d7543d9cc17f50447b969e6e06f5ea9195d428ab12b7318d";
        let expectedPublicKey = "8a558c728c21c126181e5e654b404a45b4f0137ce88177435a69978cc6bec1f4";
        let expectedSignature = "d9cec0cc0e3465fab229f8e1d6db68ab9cc99a18cb0435f70deb6100948576cd5c0aa1feb550bdd8693ef81eb10a556a622db1f9301986827b96716a7134230c";

        // Act:
        let kp = KeyPair.create(privateKey);
        let signature = kp.sign("8ce03cd60514233b86789729102ea09e867fc6d964dea8c2018ef7d0a2e0e24bf7e348e917116690b9").toString();

        // Assert:
        expect(kp.publicKey.toString()).equal(expectedPublicKey);
        expect(signature).equal(expectedSignature);
    });

    describe('Signature verification', function() {
        it("Can verify a signature", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "NEM is awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1ca602";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(true);
        });

        it("Return false if signature has invalid length", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "NEM is awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(false);
        });

        it("Return false if signature is not strictly hexadecimal", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "NEM is awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1wwwww";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(false);
        });

        it("Return false if wrong public key provided", function() {
            // Arrange:
            let signer = "0257b05f601ff829fdff84956fb5e3c65470a62375a1cc285779edd5ca3b42f6";
            let data = "NEM is awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1ca602";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(false);
        });

        it("Return false if data is not corresponding to signature provided", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "NEM is really awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(false);
        });

        it("Return false if signature is not corresponding to data provided", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "NEM is awesome !";
            let signature = "f67e5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1eeacb";

            // Act & Assert:
            expect(KeyPair.verifySignature(signer, data, signature)).equal(false);
        });

        it("Throw error if signature verification is missing a parameter", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3db030";
            let data = "";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1wwwww";

            // Act & Assert:
            expect(function() { KeyPair.verifySignature(signer, data, signature) }).to.throw('Missing argument !');
        });

        it("Throw error if signature verification get an invalid sender public key", function() {
            // Arrange:
            let signer = "ed9bf729c0d93f238bc4af468b952c35071d9fe1219b27c30dfe108c2e3aedem";
            let data = "NEM is awesome !";
            let signature = "f72d5abbf48a53e3c7c9c402bcb1b0a855821d5ef970dd5357b9899034d0c8dc177cef8e5924607ca325041b57db33628bd2f010c2474ff18fff7b509a1wwwww";

            // Act & Assert:
            expect(function() { KeyPair.verifySignature(signer, data, signature) }).to.throw('Public key is not valid !');
        });
    });

});

'''