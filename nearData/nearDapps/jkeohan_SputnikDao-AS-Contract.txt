*GitHub Repository "jkeohan/SputnikDao-AS-Contract"*

'''--- README.md ---
Sputnik Dao Contracts (in AssemblyScript)
==========================================

A [smart contract] written in [AssemblyScript] for an app initialized with [create-near-app].  One of the NEAR Protocol contracts and part of the series covering [NEAR Contracts written in AssemblyScript](https://vitalpoint.ai/course/sputnikdao-contract/) 

Quick Start
===========

Before you compile this code, you will need to install [Node.js] ≥ 12

Exploring The Code
==================

1. The main smart contract code lives in `assembly/index.ts`. You can compile
   it with the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard AssemblyScript tests using [as-pect].
'''
'''--- sputnikdao-as-factory/README.md ---
sputnikdao-factory Smart Contract
==================

A [smart contract] written in [AssemblyScript] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install [Node.js] ≥ 12

Exploring The Code
==================

1. The main smart contract code lives in `assembly/index.ts`. You can compile
   it with the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard AssemblyScript tests using [as-pect].

  [smart contract]: https://docs.near.org/docs/roles/developer/contracts/intro
  [AssemblyScript]: https://www.assemblyscript.org/
  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [as-pect]: https://www.npmjs.com/package/@as-pect/cli

'''
'''--- sputnikdao-as-factory/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- sputnikdao-as-factory/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- sputnikdao-as-factory/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- sputnikdao-as-factory/assembly/__tests__/main.spec.ts ---
import { setGreeting } from '../..';
import { storage, Context } from "near-sdk-as";

describe("Greeting ", () => {
    it("should be set and read", () => {
        setGreeting("hello world");
        const greeting = storage.get<string>(Context.sender);
    });
});

'''
'''--- sputnikdao-as-factory/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- sputnikdao-as-factory/assembly/index.ts ---
import { ContractPromiseBatch, PersistentSet, Context, base58, u128, env } from 'near-sdk-as'
import { AccountId } from './types'
import { SputnikDAOFactory } from './models'

const CODE = includeBytes('../../sputnikdao-as/out/sputnikdao-as.wasm')

/// This gas spent on the call & account creation, the rest goes to the `new` call.
const CREATE_CALL_GAS: u64 = 40000000000000

let contract: SputnikDAOFactory

export function init(): void {
  contract.daos = new PersistentSet<AccountId>('d')
}

export function getDaoList(): Array<AccountId> {
  return contract.daos.values()
}

export function create(
  name: AccountId,
  args: Uint8Array, // base64 vector
  public_key: string = '', //base58 publickey string
): void {
  let accountId = name + '.' + Context.contractName
  assert(!contract.daos.has(accountId), 'Dao name already exists')
  contract.daos.add(accountId)
  let promise = ContractPromiseBatch.create(accountId)
    .create_account()
    .deploy_contract(Uint8Array.wrap(changetype<ArrayBuffer>(CODE)))
    .transfer(Context.attachedDeposit)
    if(public_key) {
      promise = promise.add_full_access_key(base58.decode(public_key))
    }
  promise.function_call(
    'init',
    args,
    u128.Zero,
    env.prepaid_gas() - CREATE_CALL_GAS
  )
}
'''
'''--- sputnikdao-as-factory/assembly/models.ts ---
import { PersistentSet } from "near-sdk-as";
import { AccountId } from './types'

@nearBindgen
export class SputnikDAOFactory {
    daos: PersistentSet<AccountId>;

    constructor(
        daos: PersistentSet<AccountId>,
    ) {
        daos = this.daos
    }
}
'''
'''--- sputnikdao-as-factory/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- sputnikdao-as-factory/assembly/types.ts ---
export type AccountId = string
'''
'''--- sputnikdao-as-factory/compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  //const linkDir = `${calledFromDir}/out`
  //const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./out/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  //sh.mkdir('-p', linkDir)
  //sh.rm('-f', link)
  //const linkPath = path.relative(linkDir, outFile)
  //sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- sputnikdao-as-factory/package.json ---
{
  "name": "sputnikdao-as-factory",
  "version": "0.0.1",
  "authors": [
    "Illia Polosukhin <illia.polosukhin@gmail.com>",
    "Translated to AssemblyScript by Aaron Luhning <a.luhning@vitalpoint.ai>"
  ],
  "license": "UNLICENSED",
  "private": true,
  "scripts": {
    "build": "asb",
    "build:debug": "asb --target debug",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "2.2.4"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''
'''--- sputnikdao-as/README.md ---
sputnikdao-factory Smart Contract
==================

A [smart contract] written in [AssemblyScript] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install [Node.js] ≥ 12

Exploring The Code
==================

1. The main smart contract code lives in `assembly/index.ts`. You can compile
   it with the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard AssemblyScript tests using [as-pect].

  [smart contract]: https://docs.near.org/docs/roles/developer/contracts/intro
  [AssemblyScript]: https://www.assemblyscript.org/
  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [as-pect]: https://www.npmjs.com/package/@as-pect/cli

'''
'''--- sputnikdao-as/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- sputnikdao-as/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- sputnikdao-as/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- sputnikdao-as/assembly/__tests__/main.spec.ts ---
import { setGreeting } from '..';
import { storage, Context } from "near-sdk-as";

describe("Greeting ", () => {
    it("should be set and read", () => {
        setGreeting("hello world");
        const greeting = storage.get<string>(Context.sender);
    });
});

'''
'''--- sputnikdao-as/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- sputnikdao-as/assembly/index.ts ---
import { ContractPromiseBatch, PersistentSet, Context, base58, u128, env, PersistentVector, PersistentMap, logging } from 'near-sdk-as'
import { AccountId, Balance, Duration } from './types'
import { Vote, NumOrRatio, SputnikDao, Proposal, ProposalInput, PolicyItem, ProposalStatus, ProposalKind } from './models'

const MAX_DESCRIPTION_LENGTH: u32 = 280

let dao: SputnikDao

export function init(
  purpose: string,
  bond: Balance,
  council: Array<AccountId>,
  vote_period: Duration,
  grace_period: Duration
): SputnikDao {
  let councilSet = new PersistentSet<AccountId>('c')
  let i: i32 = 0
  while (i < council.length) {
    councilSet.add(council[i])
    i++
  }

  let proposalVec = new PersistentVector<Proposal>('p')

  let policyIt = new PolicyItem(u128.Zero, NumOrRatio.Ratio, 0, 1, 2)
  let policyVec = new PersistentVector<PolicyItem>('i')
  policyVec.push(policyIt)

  dao = new SputnikDao (
    purpose,
    bond,
    vote_period,
    grace_period,
    policyVec,
    councilSet,
    proposalVec
  )
  return dao
}

export function add_proposal(
  proposal: ProposalInput,
  policy: Array<PolicyItem>,
  payout: Balance, 
  vote_period: Duration, 
  bond: Balance,
  description: string ): u64 {
  // TODO: add also extra storage cost for the proposal itself.
  assert(u128.ge(Context.attachedDeposit, dao.bond), 'Not enough deposit')
  assert(<u32>(proposal.description.length) < MAX_DESCRIPTION_LENGTH, 'Description length is too long')

  //Input verification.
  switch(proposal.kind) {
    case ProposalKind.ChangePolicy: 
      assert(policy.length != 0, 'Policy should not be empty')
      let i: i32 = 0
      while (i < policy.length) {
        assert(u128.gt(policy[i].max_amount, policy[i-1].max_amount), 'Policy must be sorted, item' + i.toString() + 'is wrong')
      i++
      }
      let last_ratio_numerator = policy[policy.length - 1].numerator
      let last_ratio_denominator = policy[policy.length -1].denominator
      assert(last_ratio_numerator > 0, 'Last item in policy must have a numerator for the ratio')
      assert(last_ratio_denominator > 0, 'Last item in policy must have a denominator not equal to zero')
      assert(last_ratio_numerator * 2 / last_ratio_denominator >= 1, 'Last item in policy must be equal or above 1/2 ratio')
    break
  }

  let p = new Proposal (
    ProposalStatus.Vote,
    Context.predecessor,
    proposal.target,
    proposal.description,
    proposal.kind,
    u128.Zero,
    u128.add(u128.from(Context.blockTimestamp), dao.vote_period),
    0,
    0,
    new PersistentMap<string, Vote>('v'),
    policy[policy.length - 1],
    u128.Zero,
    u128.Zero,
    ''
  )
  dao.proposals.push(p)
  return dao.proposals.length - 1
}

export function is_finalized(proposal: Proposal): bool {
  return (proposal.status != ProposalStatus.Vote && proposal.status != ProposalStatus.Delay)
}

export function vote(id: i32, vote: Vote): void {
  assert(dao.council.has(Context.predecessor), 'Only council can vote')
  assert(!isNull(dao.proposals[id]), 'No proposal with such id')
  let proposal = dao.proposals[id]
  assert(proposal.status == ProposalStatus.Vote, 'Proposal already finalized')
  if(u128.lt(proposal.vote_period_end, u128.from(Context.blockTimestamp))){
    logging.log('Voting period expired, finalizing the proposal')
    finalize(id)
    return
  }
  assert(!proposal.votes.contains(Context.predecessor), 'Already voted')
  switch(vote) {
    case Vote.Yes:
      proposal.vote_yes += 1
      break
    case Vote.No:
      proposal.vote_no +=1
      break
    default:
      break
  }
  proposal.votes.set(Context.predecessor, vote)
  let post_status = vote_status(proposal, dao.policy, dao.council.size)
  // If just changed from vote to Delay, adjust the expiration date to grace period.
  if (!(post_status == ProposalStatus.Vote || post_status == ProposalStatus.Delay) && post_status != proposal.status) {
    proposal.vote_period_end = u128.add(u128.from(Context.blockTimestamp), dao.grace_period)
    proposal.status = post_status
  }
  dao.proposals.replace(id, proposal)
  //Finalize if this vote is done.
  if (post_status == ProposalStatus.Vote || post_status == ProposalStatus.Delay){
    finalize(id)
  }
}

export function vote_requirement(policy: PolicyItem, num_council: u64, amount: Balance): u64 {
  if(amount){
      //ToDo: replace with binary search.
      if (u128.gt(policy.max_amount, amount)) {
          return policy.get_num_votes(num_council)
      }
  }
  return policy.get_num_votes(num_council)
}

 /// Compute new vote status given council size and current timestamp.
 export function vote_status(proposal: Proposal, policy: PersistentVector<PolicyItem> , num_council: u64): ProposalStatus{
  let amount = proposal.get_amount()
  let votes_required = vote_requirement(policy[policy.length -1], num_council, amount)
  let max_votes = policy[policy.length -1].get_num_votes(num_council)
  if ((proposal.vote_yes >= votes_required) && proposal.vote_no == 0){
    if (u128.gt(u128.from(Context.blockTimestamp), proposal.vote_period_end)) {
      return ProposalStatus.Success
    } else {
      return ProposalStatus.Delay
    }
  } else if (proposal.vote_no >= max_votes) {
    return ProposalStatus.Reject
  } else if (u128.gt(u128.from(Context.blockTimestamp), proposal.vote_period_end) || proposal.vote_yes + proposal.vote_no == num_council) {
    return ProposalStatus.Fail
  } else {
    return ProposalStatus.Vote
  }
}

export function finalize(id: i32): void {
  assert(!isNull(dao.proposals[id]), 'No proposal with such id')
  let proposal = dao.proposals[id]
  assert(!is_finalized(proposal), 'Proposal already finalized')
  proposal.status = vote_status(proposal, dao.policy, dao.council.size)
  switch(proposal.status) {
    case ProposalStatus.Success:
      logging.log('Vote succeeded')
      let target = proposal.target
      let promise = ContractPromiseBatch.create(proposal.proposer).transfer(dao.bond)
        switch(proposal.kind){
          case ProposalKind.NewCouncil:
            dao.council.add(proposal.target)
            break
          case ProposalKind.RemoveCouncil:
            dao.council.delete(proposal.target)
            break
          case ProposalKind.Payout:
            let promise = ContractPromiseBatch.create(proposal.target).transfer(proposal.get_amount())
            break
          case ProposalKind.ChangeVotePeriod:
            if(proposal.vote_period != u128.Zero) {
              dao.vote_period = proposal.vote_period
            }
            break
          case ProposalKind.ChangeBond:
            if(proposal.bond != u128.Zero) {
              dao.bond = proposal.bond
            }
            break
          case ProposalKind.ChangePolicy:
            dao.policy.push(proposal.policy)
            break
          case ProposalKind.ChangePurpose:
            if(proposal.purpose != '') { 
              dao.purpose = proposal.purpose
            }
            break
        }
      break
    case ProposalStatus.Reject:
      logging.log('Proposal rejected')
      break
    case ProposalStatus.Vote || ProposalStatus.Delay:
      logging.log('voting period has not expired and no majority vote yet')
      env.panic()
      break
  }
  dao.proposals.replace(id, proposal)
}

/******************/
/* View Functions */
/******************/

export function get_vote_period(): Duration {
  return dao.vote_period
}

export function get_bond(): Balance {
  return dao.bond
}

export function get_council(): Array<AccountId> {
  return dao.council.values()
}

export function get_num_proposals(): u64 {
  return dao.proposals.length as u64
}

export function get_proposals(from_index: i32, limit: i32): Array<Proposal> {
  let i = from_index
  let propArray = new Array<Proposal>()
  while (i < min(limit, dao.proposals.length)){
    propArray.push(dao.proposals[i])
    i++
  }
  return propArray
}

export function get_proposals_by_status(
  status: ProposalStatus,
  from_index: i32,
  limit: i32,
): Array<Proposal> {
  let filtered_proposal_ids = new Array<Proposal>()
  let i: i32 = from_index
  while (i < min(i + limit, dao.proposals.length)){
    if(dao.proposals[i].status == status){
      filtered_proposal_ids.push(dao.proposals[i])
    }
    i++
  }
  return filtered_proposal_ids
}

export function get_proposals_by_statuses(
  statuses: Array<ProposalStatus>,
  from_index: i32,
  limit: i32
): Array<Proposal> {
  let filtered_proposal_ids = new Array<Proposal>()
  let i: i32 = from_index
  while (i < min(i + limit, dao.proposals.length)){
    if(statuses.includes(dao.proposals[i].status)){
      filtered_proposal_ids.push(dao.proposals[i])
    }
    i++
  }
  return filtered_proposal_ids
}

export function get_proposal(id: i32): Proposal {
  assert(!isNull(dao.proposals[id]), 'Proposal not found')
  return dao.proposals[id]
}

export function get_purpose(): string {
  return dao.purpose
}
'''
'''--- sputnikdao-as/assembly/models.ts ---
import { PersistentSet, PersistentVector, PersistentMap, u128 } from "near-sdk-as";
import { AccountId, Balance, Duration } from './types'

export enum Vote {
    Yes,
    No
}

export enum ProposalStatus {
     /// Proposal is in active voting stage.
     Vote,
     /// Proposal has successfully passed.
     Success,
     /// Proposal was rejected by the vote.
     Reject,
     /// Vote for proposal has failed due (not enuough votes).
     Fail,
     /// Given voting policy, the uncontested minimum of votes was acquired.
     /// Delaying the finalization of the proposal to check that there is no contenders (who would vote against).
     Delay,
}

export enum ProposalKind {
    NewCouncil,
    RemoveCouncil,
    Payout,
    ChangeVotePeriod,
    ChangeBond,
    ChangePolicy,
    ChangePurpose
}

@nearBindgen
export class Proposal {
    status: ProposalStatus;
    proposer: AccountId;
    target: AccountId;
    description: string;
    kind: ProposalKind;
    payout: Balance;
    vote_period_end: Duration;
    vote_yes: u64;
    vote_no: u64;
    votes: PersistentMap<AccountId, Vote>;
    policy: PolicyItem;
    vote_period: Duration;
    bond: Balance;
    purpose: string;

    constructor(
        status: ProposalStatus,
        proposer: AccountId,
        target: AccountId,
        description: string,
        kind: ProposalKind,
        payout: Balance,
        vote_period_end: Duration,
        vote_yes: u64,
        vote_no: u64,
        votes: PersistentMap<AccountId, Vote>,
        policy: PolicyItem,
        vote_period: Duration = u128.Zero,
        bond: Balance = u128.Zero,
        purpose: string = ''
    ) {
        status = this.status;
        proposer = this.proposer;
        target = this.target;
        description = this.description;
        kind = this.kind;
        payout = this.payout;
        vote_period_end = this.vote_period_end;
        vote_yes = this.vote_yes;
        vote_no = this.vote_no;
        votes = this.votes;
        policy = this.policy;
        vote_period = this.vote_period;
        bond = this.bond;
        purpose = this.purpose;
    }

    get_amount(): Balance {
        return this.payout
    }
  
}

@nearBindgen
export class ProposalInput {
    target: AccountId;
    description: string;
    kind: ProposalKind;

    constructor(
        target: AccountId,
        description: string,
        kind: ProposalKind
    ) {
        target = this.target;
        description = this.description;
        kind = this.kind;
    }
}

@nearBindgen
export class SputnikDao {
    purpose: string;
    bond: Balance;
    vote_period: Duration;
    grace_period: Duration;
    policy: PersistentVector<PolicyItem>;
    council: PersistentSet<AccountId>;
    proposals: PersistentVector<Proposal>

    constructor(
        purpose: string,
        bond: Balance,
        vote_period: Duration,
        grace_period: Duration,
        policy: PersistentVector<PolicyItem>,
        council: PersistentSet<AccountId>,
        proposals: PersistentVector<Proposal>
    ) {
        purpose = this.purpose;
        bond = this.bond;
        vote_period = this.vote_period;
        grace_period = this.grace_period;
        policy = this.policy;
        council = this.council;
        proposals = this.proposals;
    }

}

export enum NumOrRatio {
    Number,
    Ratio
}

@nearBindgen
export class PolicyItem {
    max_amount: Balance;
    votes: NumOrRatio;
    num_votes: u64;
    numerator: u64;
    denominator: u64;

    constructor(
        max_amount: Balance,
        votes: NumOrRatio,
        num_votes: u64,
        numerator: u64,
        denominator: u64
    ) {
        max_amount = this.max_amount;
        votes = this.votes;
        num_votes = this.num_votes;
        numerator = this.numerator;
        denominator = this.denominator;
    }

    get_num_votes(num_council: u64): u64 {
        switch(this.votes) {
            case NumOrRatio.Number: // Number
                return this.num_votes
                break
            case NumOrRatio.Ratio:
                return (min(num_council * this.numerator / this.denominator + 1, num_council))
                break
            default:
                break
        }
        return this.num_votes
    }
}

'''
'''--- sputnikdao-as/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- sputnikdao-as/assembly/types.ts ---
import { u128 } from 'near-sdk-as'

export type AccountId = string
export type Balance = u128
export type Duration = u128
'''
'''--- sputnikdao-as/compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
 // const linkDir = `${calledFromDir}/out`
 // const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./out/${debug ? 'debug' : 'release'}/${packageName}.wasm`
 // sh.mkdir('-p', linkDir)
 // sh.rm('-f', link)
 // const linkPath = path.relative(linkDir, outFile)
 // sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- sputnikdao-as/package.json ---
{
  "name": "sputnikdao-as",
  "version": "0.0.1",
  "authors": [
    "Illia Polosukhin <illia.polosukhin@gmail.com>",
    "Translated to AssemblyScript by Aaron Luhning <a.luhning@vitalpoint.ai>"
  ],
  "license": "UNLICENSED",
  "private": true,
  "scripts": {
    "build": "asb",
    "build:debug": "asb --target debug",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "2.2.4"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''