*GitHub Repository "globalmoneyio/LQuiD.LiQpaiD"*

'''--- README.md ---
## How-to

### Prerequisites

You need at least v12 of Node and yarn v1.x.

### Install

After cloning the repo, execute `yarn` inside the root folder.

### Build

`yarn build` will compile the frontend and backend.

### Start frontend

`yarn start-frontend` will start the frontend on the local machine and open it in a browser.

'''
'''--- package.json ---
{
  "name": "liquity",
  "private": true,
  "workspaces": {
    "packages": [
      "packages/*"
    ],
    "nohoist": [
      "**/mocha",
      "**/ts-node",
      "**/typescript",
      "**/eslint*",
      "**/@typescript-eslint/*",
      "**/jest*",
      "**/@babel/*",
      "**/babel*"
    ]
  },
  "scripts": {
    "build": "run-s build:*",
    "build:frontend": "yarn workspace @liquity/frontend build",
    "build:backend": "yarn workspace liq build:contract",
    "deploy": "yarn workspace liq deploy:contract",
    "prepare": "run-s prepare:*",
    "prepare:decimal": "yarn workspace @liquity/decimal prepare",
    "prepare:lib-base": "yarn workspace @liquity/lib-base prepare",
    "prepare:lib-near": "yarn workspace @liquity/lib-near prepare",
    "rebuild": "run-s prepare build",
    "start-frontend": "yarn workspace @liquity/frontend start"
  },
  "devDependencies": {
    "npm-run-all": "^4.1.5"
  }
}

'''
'''--- packages/backend/.env ---
CONTRACT_NAME=globalmoney.testnet

'''
'''--- packages/backend/README.md ---
liq
==================

This app was initialized with [create-near-app]

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Build contracts and frontend: `yarn build`
4. Run the local development frontend: `yarn run start-frontend` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

Exploring The Code
==================

1. The "backend" code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" – [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. The smart contract code gets tested with [asp], and the frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `liq.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `liq.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account liq.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'liq.YOUR-NAME.testnet'

Step 3: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [React]: https://reactjs.org
  [smart contract docs]: https://docs.near.org/docs/roles/developer/contracts/intro
  [asp]: https://www.npmjs.com/package/@as-pect/cli
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- packages/backend/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- packages/backend/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- packages/backend/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- packages/backend/assembly/__tests__/main.spec.ts ---
import { setGreeting } from '../main';
import { storage, Context } from "near-sdk-as";

describe("Greeting ", () => {
    it("should be set and read", () => {
        setGreeting("hello world");
        const greeting = storage.get<string>(Context.sender);
    });
});

'''
'''--- packages/backend/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- packages/backend/assembly/errors.ts ---

export const ERR_WITHDRAW_TOO_MUCH = "Amount must be less than or equal to Stability Pool deposit"
export const ERR_USER_EXISTS = "CDP already exists for this user, use adjustLoan"
export const ERR_CDP_INACTIVE = "Trove does not exist or is closed"
export const ERR_IN_RECOVERY = "Operation not permitted during Recovery Mode"
export const ERR_ICR_BELOW_MCR = "An operation that would result in ICR < MCR is not permitted"
export const ERR_CCR_BELOW_TCR = "An operation that would result in TCR < CCR is not permitted"
export const ERR_NEW_TCR_WORSE = "This loan issuance would result in a worse TCR than without it"
export const ERR_OVERDRAW_NEAR = "Insufficient balance for ETH withdrawal"
export const ERR_AMT_BELOW_ZERO = "Amount must be larger than 0"
export const ERR_REPAY_OVER = "Amount repaid must not be larger than the CDP's debt"
export const ERR_REDEEM_OVER = "Amount redeemed cannot be more than the what is redeemable"
export const ERR_TROVE_STATUS = "Inappropriate Trove status provided"
export const ERR_ZERO_DEBT = "Can't open a Trove with zero debt"
export const ERR_NEW_ICR_UNDER_TCR = "Can't open Trove in recovery mode with ICR below TCR"

'''
'''--- packages/backend/assembly/events.ts ---

import { Context, u128, PersistentDeque, logging } from "near-sdk-as";
import { AccountId } from "./model";

@nearBindgen
export class TroveCreatedEvent {
    _usr: string;
    arrayIndex: i32;
    date: u64;
}

@nearBindgen
export class TroveUpdatedEvent {
    _usr: string;
    _debt: u128;
    _coll: u128;
    _stake: u128;
    date: u64;
}

@nearBindgen
export class TroveLiquidatedEvent {
    _usr: string;
    _debt: u128;
    _collat: u128;
    _mode: string;
    date: u64;
}

export const createdEvents = new PersistentDeque<TroveCreatedEvent>("created");
export const updatedEvents = new PersistentDeque<TroveUpdatedEvent>("updated");
export const liquidatedEvents = new PersistentDeque<TroveLiquidatedEvent>("liquidated");

export function emitTroveCreatedEvent(_usr: string, arrayIndex: i32): void {
    logging.log("[call] TroveCreatedEvent(" + _usr + ")");
    const created = new TroveCreatedEvent();
    created._usr = _usr;
    created.arrayIndex = arrayIndex;
    created.date = <u64>Context.blockIndex;
    createdEvents.pushFront(created);
}

export function emitSPdepositUpdated(_usr: AccountId, _debtChange: u128): void {
    // TODO
}

export function emitTroveUpdatedEvent(_usr: string, _debt: u128, _collat: u128, _stake: u128): void {
    logging.log(
        "[call] CDPupdatedEvent(" 
        + _usr + ", "
        + _debt.toString() + ", " 
        + _collat.toString() + ", " 
        + _stake.toString() + ")"
    ); 
    const updated = new TroveUpdatedEvent();
    updated._usr = _usr;
    updated._debt = _debt;
    updated._coll = _collat;
    updated._stake = _stake;
    updated.date = <u64>Context.blockIndex;
    updatedEvents.pushFront(updated);
}

export function emitTroveLiquidatedEvent(_usr: string, _debt: u128, _collat: u128, _mode: string): void {
    logging.log(
        "[call] CDPliquidatedEvent(" 
        + _usr + ", " 
        + _debt.toString() + ", " 
        + _collat.toString() + ", " 
        + _mode + ")"
    );
    const liquidated = new TroveLiquidatedEvent();
    liquidated._usr = _usr;
    liquidated._debt = _debt;
    liquidated._collat = _collat;
    liquidated._mode = _mode;
    liquidated.date = <u64>Context.blockIndex;
    liquidatedEvents.pushFront(liquidated);
}

'''
'''--- packages/backend/assembly/main.ts ---

/*
 * Flow of NEAR:
 * Lives in three Pools: the ActivePool, the DefaultPool and the StabilityPool. 
 * When an operation is made, NEAR is transferred in one of three ways:
  * From a user to a Pool
  * From a Pool to a user
  * From one Pool to another Pool
 * 
 * NEAR is recorded on an individual level, but stored in aggregate in a Pool.  
 * An active trove with collateral and debt has a struct in the CDPManager that
 * stores its collateral value in a u128, but its actual NEAR is in the balance
 * the contract. 
 * 
 * Likewise, a StabilityPool depositor who has earned some collateral gain from
 * their deposit will have a computed NEAR gain based on a variable in the poolMgr. 
 * But their actual withdrawable NEAR is in the balance of the StabilityPool contract.
 */

import { Context, u128, storage, math, context } from "near-sdk-as";
import { 
  PCT, MCR, CCR, LOGIC_CONTRACT,
  _computeICR, min, Trove, Troves, 
  TroveOwners, AccountId, Amount, Status, 
  TroveMgr, PoolMgr, LiquidationValues
} from "./model";
import {
  emitTroveLiquidatedEvent,
  emitTroveCreatedEvent,
  emitTroveUpdatedEvent
} from './events'
import { 
  ERR_NEW_ICR_UNDER_TCR,
  ERR_AMT_BELOW_ZERO,
  ERR_ICR_BELOW_MCR,
  ERR_CCR_BELOW_TCR,
  ERR_NEW_TCR_WORSE,
  ERR_OVERDRAW_NEAR,
  ERR_CDP_INACTIVE,
  ERR_IN_RECOVERY,
  ERR_REPAY_OVER,
  ERR_REDEEM_OVER,  
} from "./errors";

let troveMgr: TroveMgr;
let poolMgr: PoolMgr;

export function init(): void {
  troveMgr = new TroveMgr();
  poolMgr = new PoolMgr();
}

// ----------------------------------------------------------------------------
// Getters for UI
// ----------------------------------------------------------------------------

export function getTotalFees(): Amount {
  return troveMgr.getTotalFees();
}
export function getPrice(): u128 {
  if (storage.contains("price"))
    return storage.getSome<u128>("price");
  else
    return u128.One;
}
export function setPrice( newPrice: u128 ): void {  
  storage.set<u128>("price", newPrice);
}
export function getTroves(): Map<AccountId, Trove> {
  let map: Map<AccountId, Trove> = new Map<AccountId, Trove>();
  for ( let i = 0; i < TroveOwners.length; i++ ) {
    let owner: AccountId = TroveOwners[i];
    map.set( owner, Troves.getSome(owner) );
  }
  return map;
}
export function getCDP( owner_id: AccountId ): Trove {
  return troveMgr.getTrove(owner_id);
}
export function getSPdebt(): Amount {
  return poolMgr.getStableLQD();
}
export function getSPdep( owner: AccountId ): Amount {
  return poolMgr.getStabilityPoolDeposit(owner);
}
// get a user’s pending NEAR gain in stability deposit?
export function getSPgains( owner: AccountId ): Amount {
  return poolMgr.getStabilityPoolNEARgain(owner);
}
export function getTotalCollat(): Amount {
  return poolMgr.getActiveLQD();
}
export function getTotalDebt(): Amount {
  return poolMgr.getActiveNEAR();
}

// ----------------------------------------------------------------------------
// Contract actions
// ----------------------------------------------------------------------------

export function openTrove( _LQDAmt: Amount ): void { // payable
  // Context.contractName is the currently running contract
  let val = Context.attachedDeposit;
  let price = getPrice();
  let ICR = _computeICR( val, _LQDAmt, price );  
  _requireNonZeroAmt(_LQDAmt);
  _requireICRisAboveMCR(ICR);
  if (!_checkRecoveryMode())
    _requireNewTCRisAboveCCR( price, val, 1, _LQDAmt, 1 ); 
  else
    _requireNewICRisAboveTCR(ICR);
  let fee = _calculateFee(_LQDAmt);
  // signer, who started the promise chain
  // who came before you in the promise chain 
  let usr = Context.predecessor; 
  troveMgr.setStatus( usr, 1 ); // creates Trove
  troveMgr.increaseCollat( usr, val );
  troveMgr.mintDebt( usr, _LQDAmt, fee );

  let arrayIndex = troveMgr.addOwnerToArray(usr);
  // Tell PM to move the NEAR to the Active Pool, and mint LQD to the borrower
  poolMgr.addCollat(val);
  poolMgr.withdrawLQD( usr, _LQDAmt );
  emitTroveCreatedEvent( usr, arrayIndex );
  emitTroveUpdatedEvent( usr, _LQDAmt, val, 
  troveMgr.updateStakes( usr, poolMgr.getTotalNEAR() ) );
}

export function closeTrove(): void {
  let usr = Context.predecessor; 
  let status = troveMgr.getStatus(usr);
  _requireTroveActive(status);
  _requireNotInRecoveryMode();
  
  let debt  = troveMgr.getDebt(usr);
  let collat = troveMgr.getCollat(usr);

  troveMgr.close(usr);
  // Tell PM to burn the debt from the user's balance, and send the collateral back to the user
  poolMgr.repayLQD( usr, debt );
  poolMgr.withdrawCollat( usr, collat );
  emitTroveUpdatedEvent( usr, u128.Zero, u128.Zero, u128.Zero );
}

/* 
 * If NEAR is sent, the operation is considered 
 * as an increase in collateral, and the first parameter 
 * _collWithdrawal is ignored  
*/
export function adjustLoan( _collatWithdrawal: Amount, _debtChange: Amount, _isDebtIncrease: i32 ): void { // payable
  let usr = Context.predecessor;
  let val = Context.attachedDeposit;
  let price = getPrice();
  var collatChange = _collatWithdrawal;
  var isCollatIncrease = 0;
  if (val != u128.Zero) {
    collatChange = val;
    isCollatIncrease = 1;
  } else if (_isDebtIncrease) {
    _requireNotInRecoveryMode();
  }
  _requireTroveActive(troveMgr.getStatus(usr));
  let debt = troveMgr.getDebt(usr);
  let collat = troveMgr.getCollat(usr);
  let newICR = _getNewICRFromTroveChange(
    collat, debt, price, 
    collatChange, isCollatIncrease, 
    _debtChange, _isDebtIncrease
  );
  // --- Checks --- 
  if (_checkRecoveryMode())
    _requireNewICRisAboveTCR(newICR);
  else
    _requireICRisAboveMCR(newICR);  
  //  --- Effects --- 
  let newColl = _updateTroveColl( usr, collatChange, isCollatIncrease );
  let newDebt = _updateTroveDebt( usr, _debtChange, _isDebtIncrease );
  let stake = troveMgr.updateStakes( usr, poolMgr.getTotalNEAR() );
  // Close a CDP if it is empty, otherwise
  if ( newDebt == u128.Zero && newColl == u128.Zero ) {
    troveMgr.close(usr);
  } 
  _moveTokensFromAdjustment(
    usr, collatChange, isCollatIncrease, 
    _debtChange, _isDebtIncrease
  );   
  emitTroveUpdatedEvent( usr, newDebt, newColl, stake ); 
}

export function addCollat( _usr: AccountId ): void { // payable
  var isFirstCollDeposit = false;
  let val = Context.attachedDeposit;
  let status = troveMgr.getStatus(_usr);
  // If non-existent or closed, open a new Trove
  if ( status == Status.nonExistent || status == Status.closed ) {
      isFirstCollDeposit = true; 
      troveMgr.setStatus( _usr, 1 );
  }  
  // Update the Trove's collateral and stake, add to ActivePool
  let newCollat = troveMgr.increaseCollat( _usr, val );
  let stake = troveMgr.updateStakes( _usr, poolMgr.getTotalNEAR() );
  poolMgr.addCollat(val);
  var debt = u128.Zero;
  if (isFirstCollDeposit) {     
      let arrayIndex = troveMgr.addOwnerToArray(_usr);
      emitTroveCreatedEvent( _usr, arrayIndex );
  } 
  else debt = troveMgr.getDebt(_usr);
  emitTroveUpdatedEvent( _usr, debt, newCollat, stake );
}
// Withdraw collateral from a CDP
export function withdrawCollat( _amt: Amount ): void {
  _requireNonZeroAmt(_amt);
  let usr = Context.predecessor; 
  let status = troveMgr.getStatus(usr);
  _requireTroveActive(status);
  let price = getPrice();
  let debt = troveMgr.getDebt(usr);
  let collat = troveMgr.getCollat(usr);
  let newICR = _getNewICRFromTroveChange( 
    collat, debt, price, _amt, 0, u128.Zero, 0 
  ); 
  if (_checkRecoveryMode())
    _requireNewICRisAboveTCR(newICR);
  else
    _requireICRisAboveMCR(newICR);  
  // Update the CDP's coll and stake
  let newColl = troveMgr.decreaseCollat( usr, _amt );
  let stake = troveMgr.updateStakes( usr, poolMgr.getTotalNEAR() );
  // Remove _amount NEAR from ActivePool and send it to the user
  poolMgr.withdrawCollat( usr, _amt );
  emitTroveUpdatedEvent( usr, debt, newColl, stake); 
}

// Withdraw LQD tokens from a CDP: mint new LQD 
// to the owner, and increase debt accordingly
export function withdrawLQD( _LQDAmt: Amount ): void {
  _requireNonZeroAmt(_LQDAmt); 
  let usr = Context.predecessor; 
  let status = troveMgr.getStatus(usr);
  _requireTroveActive(status);

  let price = getPrice();
  let debt = troveMgr.getDebt(usr);
  let collat = troveMgr.getCollat(usr);
  let newICR: u128 = _getNewICRFromTroveChange(
    collat, debt, price, u128.Zero, 0, _LQDAmt, 1 
  );
  if ( _checkRecoveryMode() )
    _requireNewICRisAboveTCR(newICR);
  else {
    _requireICRisAboveMCR(newICR);  
    _requireNewTCRisAboveCCR( price, u128.Zero, 0, _LQDAmt, 1 ); 
  }
  let fee = _calculateFee(_LQDAmt);
  // Increase the CDP's debt
  troveMgr.mintDebt( usr, _LQDAmt, fee ); 
  // Mint the given amount of LQD to the owner's address and add them to the ActivePool
  poolMgr.withdrawLQD( usr, _LQDAmt );
  emitTroveUpdatedEvent( usr, troveMgr.getDebt(usr), collat, troveMgr.getStake(usr) ); 
}
// Repay LQD tokens to a CDP: Burn the repaid LQD tokens, and reduce the debt accordingly
export function repayLQD( _LQDAmt: Amount ): void {
  let usr = Context.predecessor; 
  let status = troveMgr.getStatus(usr);
  _requireTroveActive(status);
  let debt = troveMgr.getDebt(usr);
  _requireLQDRepaymentAllowed( debt, _LQDAmt );
  // Update the CDP's debt
  troveMgr.burnDebt(usr, _LQDAmt);
  // Burn the received amount of LQD from the user's balance, and remove it from the ActivePool
  poolMgr.repayLQD( usr, _LQDAmt );
  emitTroveUpdatedEvent( usr, troveMgr.getDebt(usr), 
  troveMgr.getCollat(usr), troveMgr.getStake(usr) ); 
}

// deposit stablecoins to Stability Pool
export function provideToSP( _amount: Amount ): void {
  let usr: AccountId = Context.predecessor;
  poolMgr.depositStableLQD( usr, _amount );
  // TODO
  // emit UserDepositChanged(user, newDeposit); 
}
// withdraws the user's accumulated collateral and debt gains from the Stability Pool to their address
// should allow withdrawal of ETH gain without touching the deposit
export function withdrawFromSP( _amount: Amount ): void {
  let usr = Context.predecessor;
  poolMgr.withdrawStableLQD( usr, _amount );
  
  // TODO
  // emit GainsWithdrawn(user, gain, loss);
  // emit UserDepositChanged(user, remainder);
}

export function redeemCollateral( _LQDamt: Amount ): void {
  let price = getPrice();
  var currentUser: AccountId;
  var remainingLQD = _LQDamt;
  
  for ( let i = 0; i < TroveOwners.length; i++ ) {
    if ( remainingLQD == u128.Zero )
      break;
    if ( troveMgr.getCurrentICR( currentUser, price ) < MCR ) 
      continue;
    
    currentUser = TroveOwners[i];
    
    let redeemed: string[] = troveMgr.redeemCollateralFrom( currentUser, 
      poolMgr.getActiveNEAR(), poolMgr.getActiveLQD(), 
      remainingLQD, price ).split(",");

    let redeemedDebt = u128.fromString(redeemed[0]);
    let redeemedColl = u128.fromString(redeemed[1]);
    
    remainingLQD = u128.sub( remainingLQD, redeemedDebt );  
    poolMgr.redeemCollateral( currentUser, redeemedDebt, redeemedColl );
  }
  assert( remainingLQD == u128.Zero, ERR_REDEEM_OVER );
} 

export function liquidate( _user: AccountId ): void {
  _requireTroveActive( troveMgr.getStatus(_user) );

  let price = getPrice();
  let stableLQD: Amount = poolMgr.getStableLQD();
  let recoveryMode: bool = _checkRecoveryMode();
  
  let ICR = troveMgr.getCurrentICR( _user, price );
  var V: LiquidationValues;

  if ( recoveryMode == 0 ) {
    V = _liquidateNormalMode( _user, ICR, price, stableLQD );
  } else {
    V = _liquidateRecoveryMode( _user, ICR, price, stableLQD );
  }  
  poolMgr.offset( V.debtToOffset, V.collatToSendToSP );

  _redistributeDebtAndColl( V.debtToRedistribute, V.collatToRedistribute );
}

// ----------------------------------------------------------------------------
// Assertion functions
// ----------------------------------------------------------------------------

function _requireNewICRisAboveTCR( ICR: u128 ): void {
  assert( ICR > _getTCR(), ERR_NEW_ICR_UNDER_TCR );
}
function _requireNewTCRisAboveCCR( _price: u128,
  _collChange: Amount, _isCollIncrease: i32, 
  _debtChange: Amount, _isDebtIncrease: i32 ): void {
  let newTCR = _getNewTCRFromTroveChange(
    _collChange, _isCollIncrease, 
    _debtChange, _isDebtIncrease, _price );
  assert( newTCR >= CCR, ERR_CCR_BELOW_TCR );
}
function _requireLQDRepaymentAllowed( _currentDebt: Amount, _debtRepayment: Amount ): void {
  assert( _debtRepayment <= _currentDebt, ERR_REPAY_OVER );
}
function _requireNonZeroAmt( _amt: Amount ): void {
  assert( _amt > u128.Zero, ERR_AMT_BELOW_ZERO );
}
function _requireTroveActive( status: Status ): void {
  assert( status == Status.active, ERR_CDP_INACTIVE );
}
function _requireNotInRecoveryMode(): void {
  assert( !_checkRecoveryMode(), ERR_IN_RECOVERY );
}
function _requireICRisAboveMCR( _newICR: u128 ): void {
  assert( _newICR >= MCR, ERR_ICR_BELOW_MCR );
}
// function _getUSDValue(_coll: u128, _price: u128): u128 {
//   var usdValue = u128.mul(_coll, _price);
//   return u128.div(usdValue, PCT);
// }
// function _requireCollatAmtWithdrawable( _currentColl: u128, _collatWithdrawal: u128, _price: u128 ): void {
//   if ( _collWithdrawal > u128.Zero ) {
//       assert( _collWithdrawal <= _currentColl, ERR_OVERDRAW_NEAR );
//       let newColl = u128.sub(_currentColl, _collWithdrawal);
//       assert(_getUSDValue(newColl, _price) > u128.Zero, "Can't leave Trove empty");
//   }
// }
// function _requireNewTCRisAboveOldTCR(
//   _collChange: Amount, _isCollIncrease: i32, 
//   _debtChange: Amount, _isDebtIncrease: i32, _price: u128): void {
//   let oldTCR = _getTCR();
//   let newTCR = _getNewTCRFromTroveChange(
//     _collChange, _isCollIncrease, 
//     _debtChange, _isDebtIncrease, _price );
//   assert( newTCR >= oldTCR, ERR_NEW_TCR_WORSE );
// }

// ----------------------------------------------------------------------------
// Helper functions
// ----------------------------------------------------------------------------

function _getLiquidationVals( _debt: Amount, _coll: Amount, _stableLQD: Amount ): LiquidationValues {
  var V: LiquidationValues;
  // Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
  if ( _stableLQD > u128.Zero ) {
    /* 
     * If the debt is larger than the deposited CLV, offset an 
     * amount of debt equal to the latter, and send collateral
     * in proportion to the cancelled debt 
    */
    V.debtToOffset = min( _debt, _stableLQD );
    V.collatToSendToSP = u128.div( u128.mul( _coll, V.debtToOffset ), _debt );
    V.debtToRedistribute = u128.sub( _debt, V.debtToOffset );
    V.collatToRedistribute = u128.sub( _coll, V.collatToSendToSP );
  } 
  else {
    V.debtToOffset = u128.Zero;
    V.collatToSendToSP = u128.Zero;
    V.debtToRedistribute = _debt;
    V.collatToRedistribute = _coll;
  }
  return V;
}

function _liquidateNormalMode( _usr: AccountId, _ICR: u128, _price: u128, _stableLQD: Amount ): LiquidationValues {
  var V: LiquidationValues;
  
  // If ICR >= MCR, or is last trove, don't liquidate 
  if ( _ICR >= MCR || TroveOwners.length <= 1 ) return V;
  
  var debt = troveMgr.getDebt(_usr);
  var collat = troveMgr.getCollat(_usr);
  
  troveMgr.removeStake(_usr); 
  V = _getLiquidationVals( debt, collat, _stableLQD );  
  troveMgr.close(_usr);

  emitTroveLiquidatedEvent( _usr, debt, collat, "NormalMode" );
  return V;
}

function _liquidateRecoveryMode( _usr: AccountId, _ICR: u128, _price: u128, _stableLQD: Amount ): LiquidationValues {
  var V: LiquidationValues;
  var partial: string = ''; // false if the trove was fully liquidated

  // Never liquidate last trove
  if ( TroveOwners.length <= 1 ) return V;
  
  let debt = troveMgr.getDebt(_usr);
  var collat = troveMgr.getCollat(_usr);

  if ( _ICR <= PCT ) {
    troveMgr.removeStake(_usr); 

    V.debtToOffset = u128.Zero;
    V.collatToSendToSP = u128.Zero;
    
    V.debtToRedistribute = debt;
    V.collatToRedistribute = collat;
    
    troveMgr.close(_usr);
  } 
  // if 100% < ICR < MCR, offset maximumally, redistribute remainder
  else if (( _ICR > PCT ) && ( _ICR < MCR )) {
    troveMgr.removeStake(_usr); 

    V = _getLiquidationVals( debt, collat, _stableLQD );

    troveMgr.close(_usr);
  }
  /* If 110% <= ICR < 150% and there is CLV in the Stability Pool, 
     only offset it as much as possible (no redistribution) */
  else if (( _ICR >= MCR ) && ( _ICR < CCR )) {
    if (!_stableLQD) return V;
    else partial = 'partial';
    // TODO
    // _applyPendingRewards(_user);
    troveMgr.removeStake(_usr); 
    if ( debt > _stableLQD ) {
      V.debtToOffset = _stableLQD;
      let frac = u128.div(
        u128.mul( V.debtToOffset, collat ), debt
      );
      V.collatToSendToSP = frac;
      V.collatToRedistribute = u128.Zero;
      V.debtToRedistribute = u128.Zero;

      //partial new debt and coll
      debt = u128.sub( debt, _stableLQD );
      debt = u128.sub( collat, frac );

      troveMgr.burnDebt( _usr, _stableLQD );
      troveMgr.decreaseCollat( _usr, frac );
      
      // TODO
      //updateStakeAndTotalStakes(_user);  
    } 
    else if ( debt <= _stableLQD ) {
      V.debtToOffset = debt;
      V.collatToSendToSP = collat;
      V.debtToRedistribute = u128.Zero;
      V.collatToRedistribute = u128.Zero;
    }
    troveMgr.close(_usr);
  }
  emitTroveLiquidatedEvent(_usr, debt, collat, "RecoveryMode");

  return V;
}

function _redistributeDebtAndColl( _debt: Amount, _coll: Amount ): void { 
  if (!_debt) { return; }

  let LQDInPool: Amount = poolMgr.getStableLQD();
  let debtRemainder: Amount;
  let collRemainder: Amount;
  
  // Offset as much debt & collateral as possible against the Stability Pool
  if ( LQDInPool > u128.Zero ) { 
    // Transfer the debt & coll from the Active Pool to the Default Pool
    poolMgr.stablePool.increaseLQD(_debt);
    poolMgr.stablePool.receiveNEAR(_coll);
    poolMgr.activePool.decreaseLQD(_debt);
    poolMgr.activePool.recapNEAR(_coll);
    let debtToOffset = min(_debt, LQDInPool);  
    
    // Collateral to be added in proportion to the debt that is cancelled 
    var collToAdd = u128.mul(_coll, debtToOffset);
    collToAdd = u128.div(collToAdd, _debt);

    // Cancel the liquidated LQD debt with the LQD in the stability pool
    poolMgr.stablePool.decreaseLQD(debtToOffset); 
    poolMgr.repayLQD(LOGIC_CONTRACT, debtToOffset); 
   
    // Send NEAR from Active Pool to Stability Pool
    poolMgr.activePool.recapNEAR(collToAdd);  
    poolMgr.stablePool.receiveNEAR(collToAdd);  

    debtRemainder = u128.sub(_debt, debtToOffset);
    collRemainder = u128.sub(_coll, collToAdd);
  } else {
    debtRemainder = _debt;
    collRemainder = _coll;
  }
  // Transfer the debt & coll from the Active Pool to the Default Pool
  poolMgr.activePool.decreaseLQD(debtRemainder);
  poolMgr.activePool.recapNEAR(collRemainder);
  
  // TODO assign to everyone
  // As we are redistributing all the debt, 
  // but not all the collateral (0.5% goes to liquidator), 
  // the TCR slightly decreases
}

function _calculateFee( _amt: Amount ): Amount {
  let totalLQD = poolMgr.getTotalLQD();
  if ( totalLQD > u128.One ) {
    return u128.mul( _amt, // TODO better fee formula
      u128.div( _amt, poolMgr.getTotalLQD() )
    );
  } 
  return u128.Zero;
}

// Update trove's coll and debt based on whether they increase or decrease
function _updateTroveColl( _usr: AccountId, _collatChange: Amount, _isCollatIncrease: i32 ): Amount {
  if (_isCollatIncrease)
    return troveMgr.increaseCollat( _usr, _collatChange );
  return troveMgr.decreaseCollat( _usr, _collatChange );
}

// Update trove's coll and debt based on whether they increase or decrease
function _updateTroveDebt( _usr: AccountId, _debtChange: Amount, _isDebtIncrease: i32 ): Amount {
  if (_isDebtIncrease) {
    var fee: Amount = u128.Zero;
    if (poolMgr.getTotalLQD() > u128.One)
      fee = u128.mul( _debtChange, u128.div(
                      _debtChange, poolMgr.getTotalLQD()
            )); 
    troveMgr.mintDebt( _usr, _debtChange, fee );
  } else
    troveMgr.burnDebt( _usr, _debtChange );
  return troveMgr.getDebt(_usr);
}

function _moveTokensFromAdjustment( _usr: AccountId, 
  _collatChange: Amount, _isCollatIncrease: i32,
  _debtChange: Amount, _isDebtIncrease: i32 ): void {
  if ( !_isDebtIncrease )
    poolMgr.repayLQD(_usr, _debtChange);
  else
    poolMgr.withdrawLQD(_usr, _debtChange);
  if ( !_isCollatIncrease )
    poolMgr.withdrawCollat( _usr, _collatChange );
  else
    poolMgr.addCollat(_collatChange);
}

// Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
function _getNewICRFromTroveChange(
  _collat: Amount, _debt: Amount, _price: u128,
  _collatChange: Amount, _isCollatIncrease: i32,
  _debtChange: Amount, _isDebtIncrease: i32 ): u128 {
    let newCollat: Amount;
    let newDebt: Amount;
    if (!_isCollatIncrease)
      newCollat = u128.sub( _collat, _collatChange );  
    else
      newCollat = u128.add( _collat, _collatChange );
    if (!_isDebtIncrease)
      newDebt = u128.sub( _debt, _debtChange );
    else
      newDebt = u128.add( _debt, _debtChange );
    return _computeICR( newCollat, newDebt, _price );
}

function _getNewTCRFromTroveChange(
  _collChange: Amount, _isCollIncrease: i32, 
  _debtChange: Amount, _isDebtIncrease: i32, _price: u128 ): u128 {
  
  var totalColl = poolMgr.getTotalNEAR();
  var totalDebt = poolMgr.getTotalLQD();
 
  if (!_isCollIncrease) {
    totalColl = u128.sub(totalColl, _collChange);
  } else {
    totalColl = u128.add(totalColl, _collChange);
  }
  if (!_isDebtIncrease) {
    totalDebt = u128.sub(totalDebt, _debtChange);
  } else {
    totalDebt = u128.add(totalDebt, _debtChange);
  }
  return _computeICR(totalColl, totalDebt, _price);
}

// Return the total collateral ratio (TCR) of the system, based on the most recent oracle price
function _getTCR(): u128 {
  let price = getPrice();

  let activeColl = poolMgr.getActiveNEAR();
  let activeDebt = poolMgr.getActiveLQD();
  
  return _computeICR(activeColl, activeDebt, price); 
}

function _checkRecoveryMode(): bool {
  let price = getPrice();

  let activeColl = poolMgr.getActiveNEAR();
  let activeDebt = poolMgr.getActiveLQD();
  
  let TCR = _computeICR(activeColl, activeDebt, price); 
  
  return TCR < CCR;
}

'''
'''--- packages/backend/assembly/model.ts ---

import { 
  u128, PersistentVector, PersistentMap, storage,
  ContractPromiseBatch, ContractPromise 
} from "near-sdk-as";
import { 
  ERR_WITHDRAW_TOO_MUCH, ERR_REPAY_OVER, ERR_TROVE_STATUS
} from './errors'

export const SCALING_FACTOR = u128.from(1000000); // Collateral is 24 digits, so we need to
                                                  // divide by 10^6 to scale it down to 18
export const MCR = u128.from(1100000000000000000); // Minimal Collateral Ratio, 110%
// If the total system collateral (TCR) falls below the CCR, Recovery Mode is triggered.
export const CCR = u128.from(1500000000000000000); // Critical Collateral Ratio, 150% 
export const PCT = u128.from(1000000000000000000); // 100% 1e18

const LINK_CONTRACT = "link.globalmoney.testnet";
const TOKEN_CONTRACT = "lqd.globalmoney.testnet";
export const LOGIC_CONTRACT = "quid.globalmoney.testnet";

export enum Status { nonExistent, active, closed }
export type AccountId = string
export type Amount = u128

@nearBindgen
export class Trove {
  debt: Amount;
  collat: Amount;
  stake: u128;
  status: Status;
  arrayIndex: i32;
  constructor() {
    this.debt = u128.Zero;
    this.collat = u128.Zero;
    this.stake = u128.Zero;
    this.status = Status.nonExistent;
  }
}
@nearBindgen
export class LiquidationValues {
  debtToOffset: Amount;
  collatToSendToSP: Amount;
  debtToRedistribute: Amount;
  collatToRedistribute: Amount;
}
@nearBindgen
class MintBurnArgs {
  user: AccountId;
  tokens: Amount;
}
@nearBindgen
export class TokenApi {
  mint(user: AccountId, tokens: Amount): ContractPromise {
    let args: MintBurnArgs = { user, tokens };
    let promise = ContractPromise.create(
      TOKEN_CONTRACT, "mint", args.encode(), 100000000000000
    );
    return promise;
  }
  burn(user: AccountId, tokens: Amount): ContractPromise {
    let args: MintBurnArgs = { user, tokens };
    let promise = ContractPromise.create(
      TOKEN_CONTRACT, "burn", args.encode(), 100000000000000
    );
    return promise;
  }
}
export const stableLQDeposits = new PersistentMap<AccountId, Amount>("deposits");
export const Troves = new PersistentMap<AccountId, Trove>("troves");
export const TroveOwners = new PersistentVector<AccountId>("owners");

@nearBindgen
export class TroveMgr { 
  // private feePct: u128; // fee percentage points
  // issuanceFee(amount) = c * baseRate * amount
  // redemptionFee(amount) = d * baseRate * amount
  constructor() {}

  getTotalFees(): Amount {
    if (storage.contains("fees"))
      return storage.getSome<u128>("fees");
    else
      return u128.Zero;
  }

  getTotalStakes(): u128 {
    if (storage.contains("stakes"))
      return storage.getSome<u128>("stakes");
    else 
      return u128.Zero;
  }

  payFee( _usr: AccountId, _fee: Amount ): void {
    let trove = Troves.getSome(_usr);
    
    let totalFees = this.getTotalFees();
    storage.set<u128>( "fees",  u128.add( totalFees, _fee ) );
    
    trove.debt = u128.add( trove.debt, _fee );
    Troves.set( _usr, trove );
  }

  addOwnerToArray( _usr: AccountId ): i32 {
    let index = TroveOwners.length;
    let trove = Troves.getSome(_usr);
    TroveOwners.push(_usr);
    trove.arrayIndex = index;
    Troves.set( _usr, trove );
    return index;
  }

  getStatus( _usr: AccountId ): Status {
    let trove: Trove;
    if( Troves.contains(_usr) ) {
      trove = Troves.getSome(_usr);
      return trove.status;
    }
    return Status.nonExistent;
  }
  
  setStatus( _usr: AccountId, _num: u8 ): void {
    let trove = this.getTrove(_usr);
    
    if ( _num == 1 ) trove.status = Status.active;
    else if ( _num == 2 ) trove.status = Status.closed;
    else assert( true, ERR_TROVE_STATUS );

    Troves.set( _usr, trove );
  }

  increaseCollat( _user: AccountId, _collatIncrease: Amount ): Amount  {
    let trove = Troves.getSome(_user);
    trove.collat = u128.add( trove.collat, _collatIncrease );
    Troves.set( _user, trove );
    return trove.collat;
  }
  
  decreaseCollat( _usr: AccountId, _collatDecrease: Amount ): Amount {
    let trove = Troves.getSome( _usr );
    trove.collat = u128.sub( trove.collat, _collatDecrease );
    Troves.set( _usr, trove );
    if ( trove.collat == u128.Zero ) {
      this.close(_usr); 
      return u128.Zero; 
    }
    return trove.collat;
  }
  
  mintDebt( _user: AccountId, _debtIncrease: Amount, _fee: Amount ): void {
    let debtPlusFee = u128.add( _debtIncrease, _fee );
    
    let totalFees = this.getTotalFees();
    storage.set<u128>( "fees", u128.add( totalFees, _fee ) );

    let trove = Troves.getSome(_user);
    trove.debt = u128.add( trove.debt, debtPlusFee );
    Troves.set( _user, trove );
    /*
     * We don't mint the issuance fee amount
     * because the user must obtain that by 
     * selling some collateral or other means
     * to close her debt against the system
    */ 
    let token = new TokenApi();
    let promise = token.mint( _user, _debtIncrease );
    promise.returnAsResult();
  } 
  
  burnDebt( _user: AccountId, _debtDecrease: Amount ): void {
    let trove = Troves.getSome(_user);
    assert( _debtDecrease < trove.debt, ERR_REPAY_OVER );
  
    trove.debt = u128.sub( trove.debt, _debtDecrease );
    Troves.set( _user, trove );
    
    let token = new TokenApi();
    let promise = token.burn( _user, _debtDecrease );
    promise.returnAsResult();
  }

  updateStakes( _user: AccountId, _totalCollateral: Amount ): u128 { // TODO wtf does it do
    let trove = Troves.getSome(_user);
    let oldStake = trove.stake;
    
    let totalStakes = this.getTotalStakes();
    if ( _totalCollateral > u128.Zero ) {
      trove.stake = u128.mul( trove.collat, totalStakes );
      trove.stake = u128.div( trove.stake, _totalCollateral );
    }    
    storage.set<u128>( "stakes", u128.add(trove.stake, u128.sub(
      totalStakes, oldStake)
    ));
    return trove.stake;
  }

  close( _user: AccountId ): void {
    let trove = Troves.getSome(_user);
    trove.status = Status.closed;
    trove.collat = u128.Zero;
    trove.debt = u128.Zero;
    
    let totalStakes = this.getTotalStakes();
    storage.set<u128>( "stakes", u128.sub(
      totalStakes, trove.stake
    ));
    trove.stake = u128.Zero;
    Troves.set( _user, trove );
    TroveOwners.swap_remove(trove.arrayIndex);
  }
  
  // Redeem as much collateral as possible from _user's 
  // Trove in exchange for LQD up to _maxLQDamount
  redeemCollateralFrom( _user: AccountId,
    _totalCollat: Amount, _totalDebt: Amount, 
    _maxLQD: Amount, _price: u128 ): string {
    // Determine the remaining amount (lot) to be redeemed, 
    // capped by the entire debt of the Trove
    let trove = Troves.getSome(_user);
    let TCRwith = _computeICR( _totalCollat, _totalDebt, _price );
    
    let totalCollatWithout: Amount = u128.sub( _totalCollat, trove.collat );
    let totalDebtWithout: Amount = u128.sub( _totalDebt, trove.debt );
    let TCRwithout = _computeICR(
      totalCollatWithout,
      totalDebtWithout,
      _price
    );
    let TCRdelta = u128.sub( TCRwithout, TCRwith );
    let TCRshare = u128.div( TCRdelta, TCRwith );
    let debtToRedeem = min( u128.mul( _maxLQD, TCRshare ), trove.debt );
    let debtShare = u128.div( debtToRedeem, trove.debt );
    let collatToRedeem = u128.mul( debtShare, trove.collat );
    trove.debt = u128.sub( trove.debt, debtToRedeem );
    trove.collat = u128.sub( trove.collat, collatToRedeem );
    if ( trove.debt == u128.Zero && trove.collat == u128.Zero )
      this.close(_user);
    else
      Troves.set(_user, trove);

    return trove.debt.toString() + "," + trove.collat.toString();
  }
  
  // Remove use's stake from the totalStakes sum, and set their stake to 0
  removeStake( _usr: AccountId ): void {
    let trove = Troves.getSome(_usr);
    let totalStakes = this.getTotalStakes();
    storage.set<u128>( "stakes", u128.add( 
      totalStakes, u128.sub( totalStakes, 
                            trove.stake )
    )); 
    trove.stake = u128.Zero;
    Troves.set(_usr, trove);
  }
  
  // Return the current collateral ratio (ICR) of a given CDP
  getCurrentICR( _usr: AccountId, _price: u128 ): u128 {  
    return _computeICR(
      this.getCollat(_usr), this.getDebt(_usr), _price
    );      
  }
  getCollat( _usr: AccountId ): Amount {
    return this.getTrove(_usr).collat;
  }
  getStake( _usr: AccountId ): Amount {
    return this.getTrove(_usr).stake;
  }
  getDebt( _usr: AccountId ): Amount {
    return this.getTrove(_usr).debt;
  }
  getTrove( _usr: AccountId ): Trove {
    return Troves.get( _usr, new Trove() ) as Trove;
  }
}

@nearBindgen
class Pool { // TODO storage for amounts
  // TODO storage
  private NEAR: Amount;  // deposited collateral tracker
  private LQD: Amount;  // total outstanding CDP debt
  
  constructor() {
    this.NEAR = u128.Zero;
    this.LQD = u128.Zero;
  }
  
  receiveNEAR( _amount: Amount ): void {
    this.NEAR = u128.add(this.NEAR, _amount);
  }
  recapNEAR( _amount: Amount ): void {
    this.NEAR = u128.sub(this.NEAR, _amount);
  }
  sendNEAR( _account: AccountId, _amount: Amount ): void {
    this.NEAR = u128.sub(this.NEAR, _amount);
    ContractPromiseBatch.create(_account).transfer(_amount);
  }
  increaseLQD( _amount: Amount ): void {
    this.LQD = u128.add(this.LQD, _amount);
  }
  decreaseLQD( _amount: Amount ): void {
    this.LQD = u128.sub(this.LQD, _amount);
  }
  getNEAR(): Amount {
    return this.NEAR;
  }
  getLQD(): Amount {
    return this.LQD;
  }
}

@nearBindgen
export class PoolMgr {
  activePool: Pool;
  stablePool: Pool;

  constructor() {
    this.activePool = new Pool();
    this.stablePool = new Pool();
  }
  getStableLQD(): Amount {
    return this.stablePool.getLQD();
  }
  getActiveLQD(): Amount {
    return this.activePool.getLQD();
  }
  getTotalLQD(): Amount {
    return u128.add( this.getActiveLQD(), this.getStableLQD() );
  }
  getStableNEAR(): Amount {
    return this.stablePool.getNEAR();
  }
  getActiveNEAR(): Amount {
    return this.activePool.getNEAR();
  }
  getTotalNEAR(): Amount {
    return u128.add(this.activePool.getNEAR(), this.getActiveNEAR());
  }
  getDebtPenaltyPerUnitStaked(_debtToOffset: Amount, stableLQD: Amount): Amount {
    return u128.div(u128.mul(_debtToOffset, PCT), stableLQD);
  }
  getCollateralRewardPerUnitStaked(_collatToAdd: Amount, stableLQD: Amount): Amount {
    return u128.div(u128.mul(_collatToAdd, PCT), stableLQD); 
  }
  getStabilityPoolDeposit(_account: AccountId): Amount {  
    if (stableLQDeposits.contains(_account)) {
      return stableLQDeposits.getSome(_account);
    } return u128.Zero;
  }
  getStabilityPoolNEARgain(_account: AccountId): Amount {  
    // TODO
    let stake = u128.div(this.getStabilityPoolDeposit(_account), this.getStableLQD());

    return u128.Zero;
  }
  depositStableLQD(_account: AccountId, _LQD: Amount): void {
    this.stablePool.increaseLQD(_LQD);
    var deposit: Amount;
    if (stableLQDeposits.contains(_account)) {
      deposit = stableLQDeposits.getSome(_account);
      deposit = u128.add(deposit, _LQD);
    } else deposit = _LQD;

    stableLQDeposits.set(_account, deposit);

    //TODO updateTotalStakes

    let token = new TokenApi();
    let promise = token.burn(_account, _LQD);
    promise.returnAsResult();
  }
  withdrawStableLQD(_account: AccountId, _LQD: Amount): void {
    this.stablePool.decreaseLQD(_LQD);

    var deposit = stableLQDeposits.getSome(_account);
    assert(deposit >= _LQD, ERR_WITHDRAW_TOO_MUCH);
    deposit = u128.sub(deposit, _LQD);
    stableLQDeposits.set(_account, deposit);

    let token = new TokenApi();
    let promise = token.mint(_account, _LQD);
    promise.returnAsResult();
  }
  withdrawLQD(_account: AccountId, _LQD: Amount): void {
    this.activePool.increaseLQD(_LQD);  
    let token = new TokenApi();
    let promise = token.mint(_account, _LQD);
    promise.returnAsResult();
  }
  repayLQD(_account: AccountId, _LQD: Amount): void {
    this.activePool.decreaseLQD(_LQD);
    let token = new TokenApi();
    let promise = token.burn(_account, _LQD);
    promise.returnAsResult();
  }
  addCollat(_amount: Amount): void {
    this.activePool.receiveNEAR(_amount);
  }
  // Transfer the specified amount of NEAR to _account
  withdrawCollat(_account: AccountId, _NEAR: Amount): void { // s
    this.activePool.sendNEAR(_account, _NEAR);
  }
  // Burn the calculated lot of LQD and send the corresponding NEAR to to _account
  redeemCollateral(_account: AccountId, _LQD: Amount, _NEAR: Amount): void {
    // Update Active Pool LQD, and send NEAR to account
    this.activePool.decreaseLQD(_LQD);  
    this.activePool.sendNEAR(_account, _NEAR); 

    this.activePool.decreaseLQD(_LQD);
    let token = new TokenApi();
    let promise = token.burn(_account, _LQD);
    promise.returnAsResult();
  }
  moveTroveRepoToActivePool(debtPenalty: Amount, collateralReward: Amount): void {
    this.stablePool.decreaseLQD(debtPenalty);
    this.activePool.increaseLQD(debtPenalty);
    this.stablePool.recapNEAR(collateralReward);
    this.activePool.receiveNEAR(collateralReward);
  }
  /* Cancel out the specified _debt against the CLV contained in the Stability Pool (as far as possible)  
    and transfers the CDP's NEAR collateral from ActivePool to StabilityPool. 
    Only called from liquidation functions in CDPManager. */
  offset(_debtToOffset: Amount, _collatToAdd: Amount): void {
    let stableLQD = this.getStableLQD(); 
    if (!stableLQD || !_debtToOffset) return; 
    //TODO
    this.moveOffsetCollatAndDebt(_collatToAdd, _debtToOffset);
  } 
  moveOffsetCollatAndDebt(_collatToAdd: Amount, _debtToOffset: Amount): void {
     // Cancel the liquidated CLV debt with the CLV in the stability pool
     this.activePool.decreaseLQD(_debtToOffset);  
     this.stablePool.decreaseLQD(_debtToOffset); 
    
     // Send NEAR from Active Pool to Stability Pool
     this.activePool.recapNEAR(_collatToAdd);
     this.stablePool.receiveNEAR(_collatToAdd);
     
     let token = new TokenApi();
     let promise = token.burn(LOGIC_CONTRACT, _debtToOffset);
     promise.returnAsResult(); // Burn the debt that was successfully offset
  }
  // Update the Active Pool and the Default Pool when a CDP gets closed
  liquidate(_LQD: Amount, _NEAR: Amount): void {
    // Transfer the debt & collat from the Active Pool to the Default Pool
    this.activePool.decreaseLQD(_LQD);
    this.stablePool.increaseLQD(_LQD);
    this.activePool.recapNEAR( _NEAR);
    this.stablePool.receiveNEAR(_NEAR);
  }
} 

////////////////////////////     Utility Functions     //////////////////////////////

export function min( a: u128, b: u128 ): u128 {
  if ( b > a ) return a;
  else return b;
}

export function _computeICR( _collat: u128, _debt: u128, _price: u128 ): u128 {
  if ( _collat == u128.Zero && _debt == u128.Zero ) {
    return u128.One;
  }
  else if ( _debt > u128.Zero ) {
      let collatPerDebt: u128 = u128.div( _collat, _debt );
      let collatRatio24Decimals = u128.mul( collatPerDebt, _price );
      return u128.div( collatRatio24Decimals, SCALING_FACTOR );
  }
  // Return the maximal value for uint256 if the CDP has a debt of 0
  else if ( _debt == u128.Zero ) {
      return u128.Max; 
  }
  return u128.Zero;
}

'''
'''--- packages/backend/assembly/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true
  },
  "extends": "../asconfig.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- packages/backend/babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- packages/backend/package.json ---
{
  "name": "liq",
  "version": "0.1.0",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./.env parcel src/index.html --open",
    "dev": "nodemon --watch assembly -e ts --exec \"npm run start\"",
    "test": "npm run build:contract:debug && asp --nologo && jest test --runInBand"
  },
  "devDependencies": {
    "@babel/core": "^7.10.4",
    "@babel/preset-env": "^7.9.5",
    "@babel/preset-react": "^7.9.4",
    "babel-jest": "^26.0.0",
    "env-cmd": "^10.1.0",
    "gh-pages": "^3.0.0",
    "jest": "^26.0.1",
    "jest-environment-node": "^26.0.0",
    "near-cli": "^1.0.1",
    "near-sdk-as": "^2.0.0",
    "nodemon": "^2.0.3",
    "parcel-bundler": "^1.12.4",
    "react-test-renderer": "^16.13.1"
  },
  "dependencies": {
    "near-api-js": "^0.30.0",
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "regenerator-runtime": "^0.13.5"
  },
  "jest": {
    "moduleNameMapper": {
      "\\.(jpg|ico|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/src/__mocks__/fileMock.js",
      "\\.(css|less)$": "<rootDir>/src/__mocks__/fileMock.js"
    },
    "setupFiles": [
      "<rootDir>/src/jest.init.js"
    ],
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/assembly/",
      "<rootDir>/node_modules/"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- packages/backend/src/App.js ---
import 'regenerator-runtime/runtime'
import React from 'react'
import { login, logout } from './utils'
import './global.css'

import getConfig from './config'
const { networkId } = getConfig(process.env.NODE_ENV || 'development')

export default function App() {
  // use React Hooks to store greeting in component state
  const [greeting, setGreeting] = React.useState()

  // when the user has not yet interacted with the form, disable the button
  const [buttonDisabled, setButtonDisabled] = React.useState(true)

  // after submitting the form, we want to show Notification
  const [showNotification, setShowNotification] = React.useState(false)

  // The useEffect hook can be used to fire side-effects during render
  // Learn more: https://reactjs.org/docs/hooks-intro.html
  React.useEffect(
    () => {
      // in this case, we only care to query the contract when signed in
      if (window.walletConnection.isSignedIn()) {

        // window.contract is set by initContract in index.js
        window.contract.getGreeting({ accountId: window.accountId })
          .then(greetingFromContract => {
            setGreeting(greetingFromContract)
          })
      }
    },

    // The second argument to useEffect tells React when to re-run the effect
    // Use an empty array to specify "only run on first render"
    // This works because signing into NEAR Wallet reloads the page
    []
  )

  // if not signed in, return early with sign-in prompt
  if (!window.walletConnection.isSignedIn()) {
    return (
      <main>
        <h1>Welcome to NEAR!</h1>
        <p>
          To make use of the NEAR blockchain, you need to sign in. The button
          below will sign you in using NEAR Wallet.
        </p>
        <p>
          By default, when your app runs in "development" mode, it connects
          to a test network ("testnet") wallet. This works just like the main
          network ("mainnet") wallet, but the NEAR Tokens on testnet aren't
          convertible to other currencies – they're just for testing!
        </p>
        <p>
          Go ahead and click the button below to try it out:
        </p>
        <p style={{ textAlign: 'center', marginTop: '2.5em' }}>
          <button onClick={login}>Sign in</button>
        </p>
      </main>
    )
  }

  return (
    // use React Fragment, <>, to avoid wrapping elements in unnecessary divs
    <>
      <button className="link" style={{ float: 'right' }} onClick={logout}>
        Sign out
      </button>
      <main>
        <h1>
          <label
            htmlFor="greeting"
            style={{
              color: 'var(--secondary)',
              borderBottom: '2px solid var(--secondary)'
            }}
          >
            {greeting}
          </label>
          {' '/* React trims whitespace around tags; insert literal space character when needed */}
          {window.accountId}!
        </h1>
        <form onSubmit={async event => {
          event.preventDefault()

          // get elements from the form using their id attribute
          const { fieldset, greeting } = event.target.elements

          // hold onto new user-entered value from React's SynthenticEvent for use after `await` call
          const newGreeting = greeting.value

          // disable the form while the value gets updated on-chain
          fieldset.disabled = true

          try {
            // make an update call to the smart contract
            await window.contract.setGreeting({
              // pass the value that the user entered in the greeting field
              message: newGreeting
            })
          } catch (e) {
            alert(
              'Something went wrong! ' +
              'Maybe you need to sign out and back in? ' +
              'Check your browser console for more info.'
            )
            throw e
          } finally {
            // re-enable the form, whether the call succeeded or failed
            fieldset.disabled = false
          }

          // update local `greeting` variable to match persisted value
          setGreeting(newGreeting)

          // show Notification
          setShowNotification(true)

          // remove Notification again after css animation completes
          // this allows it to be shown again next time the form is submitted
          setTimeout(() => {
            setShowNotification(false)
          }, 11000)
        }}>
          <fieldset id="fieldset">
            <label
              htmlFor="greeting"
              style={{
                display: 'block',
                color: 'var(--gray)',
                marginBottom: '0.5em'
              }}
            >
              Change greeting
            </label>
            <div style={{ display: 'flex' }}>
              <input
                autoComplete="off"
                defaultValue={greeting}
                id="greeting"
                onChange={e => setButtonDisabled(e.target.value === greeting)}
                style={{ flex: 1 }}
              />
              <button
                disabled={buttonDisabled}
                style={{ borderRadius: '0 5px 5px 0' }}
              >
                Save
              </button>
            </div>
          </fieldset>
        </form>
        <p>
          Look at that! A Hello World app! This greeting is stored on the NEAR blockchain. Check it out:
        </p>
        <ol>
          <li>
            Look in <code>src/App.js</code> and <code>src/utils.js</code> – you'll see <code>getGreeting</code> and <code>setGreeting</code> being called on <code>contract</code>. What's this?
          </li>
          <li>
            Ultimately, this <code>contract</code> code is defined in <code>assembly/main.ts</code> – this is the source code for your <a target="_blank" rel="noreferrer" href="https://docs.near.org/docs/roles/developer/contracts/intro">smart contract</a>.</li>
          <li>
            When you run <code>yarn dev</code>, the code in <code>assembly/main.ts</code> gets deployed to the NEAR testnet. You can see how this happens by looking in <code>package.json</code> at the <code>scripts</code> section to find the <code>dev</code> command.</li>
        </ol>
        <hr />
        <p>
          To keep learning, check out <a target="_blank" rel="noreferrer" href="https://docs.near.org">the NEAR docs</a> or look through some <a target="_blank" rel="noreferrer" href="https://examples.near.org">example apps</a>.
        </p>
      </main>
      {showNotification && <Notification />}
    </>
  )
}

// this component gets rendered by App after the form is submitted
function Notification() {
  const urlPrefix = `https://explorer.${networkId}.near.org/accounts`
  return (
    <aside>
      <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.accountId}`}>
        {window.accountId}
      </a>
      {' '/* React trims whitespace around tags; insert literal space character when needed */}
      called method: 'setGreeting' in contract:
      {' '}
      <a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.contract.contractId}`}>
        {window.contract.contractId}
      </a>
      <footer>
        <div>✔ Succeeded</div>
        <div>Just now</div>
      </footer>
    </aside>
  )
}

'''
'''--- packages/backend/src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- packages/backend/src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- packages/backend/src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- packages/backend/src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'liq'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- packages/backend/src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 25em;
}

h1 {
  background-image: url(assets/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(assets/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- packages/backend/src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>Welcome to NEAR with React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- packages/backend/src/index.js ---
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import { initContract } from './utils'

window.nearInitPromise = initContract()
  .then(() => {
    ReactDOM.render(
      <App />,
      document.querySelector('#root')
    )
  })
  .catch(console.error)

'''
'''--- packages/backend/src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- packages/backend/src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getGreeting'],
    changeMethods: [],
    sender: window.accountId
  })

  window.walletConnection = {
    requestSignIn() {
    },
    signOut() {
    },
    isSignedIn() {
      return true
    },
    getAccountId() {
      return window.accountId
    }
  }
})

test('getGreeting', async () => {
  const message = await window.contract.getGreeting({ accountId: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- packages/backend/src/utils.js ---
import { connect, Contract, keyStores, WalletConnection } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['getGreeting'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['setGreeting'],
  })
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

'''
'''--- packages/backend/src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''
'''--- packages/decimal/.mocharc.yml ---
spec: "test/**/*.test.ts"

'''
'''--- packages/decimal/index.ts ---
export * from "./src/Decimal";

'''
'''--- packages/decimal/package.json ---
{
  "name": "@liquity/decimal",
  "version": "0.0.1",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "prepare": "tsc --project tsconfig.dist.json",
    "test": "mocha --require ts-node/register"
  },
  "devDependencies": {
    "@ethersproject/bignumber": "^5.0.1",
    "@types/chai": "^4.2.9",
    "@types/mocha": "^7.0.1",
    "chai": "^4.2.0",
    "mocha": "^8.0.1",
    "ts-node": "^8.9.0",
    "typescript": "^3.9.5"
  },
  "peerDependencies": {
    "@ethersproject/bignumber": "^5.0.1"
  }
}

'''
'''--- packages/decimal/src/Decimal.ts ---
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";

const MaxUint256 = BigNumber.from(
  "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
);

export type Decimalish = Decimal | number | string;

export class Decimal {
  static readonly INFINITY = new Decimal(MaxUint256);

  static readonly PRECISION = 18;
  static readonly DIGITS = Decimal.getDigits(Decimal.PRECISION);

  private static readonly stringRepresentationFormat = /^[0-9]*(\.[0-9]*)?$/;
  private static readonly trailingZeros = /0*$/;
  private static readonly magnitudes = ["", "K", "M", "B", "T"];

  readonly bigNumber: BigNumber;

  constructor(bigNumber: BigNumber) {
    if (bigNumber.lt(0)) {
      throw new Error("must not be negative");
    }
    this.bigNumber = bigNumber;
  }

  private static getDigits(numDigits: number) {
    return BigNumber.from(10).pow(numDigits);
  }

  private static fromString(representation: string) {
    if (!representation || !representation.match(Decimal.stringRepresentationFormat)) {
      throw new Error("bad decimal format");
    }

    if (representation.indexOf(".") < 0) {
      return new Decimal(BigNumber.from(representation).mul(Decimal.DIGITS));
    }

    let [characteristic, mantissa] = representation.split(".");
    if (mantissa.length < Decimal.PRECISION) {
      mantissa += "0".repeat(Decimal.PRECISION - mantissa.length);
    } else {
      mantissa = mantissa.substr(0, Decimal.PRECISION);
    }

    return new Decimal(
      BigNumber.from(characteristic || 0)
        .mul(Decimal.DIGITS)
        .add(mantissa)
    );
  }

  static from(decimalish: Decimalish) {
    switch (typeof decimalish) {
      case "object":
        return decimalish;
      case "string":
        return Decimal.fromString(decimalish);
      case "number":
        return Decimal.fromString(decimalish.toString());
    }
  }

  static bigNumberFrom(decimalish: Decimalish) {
    return Decimal.from(decimalish).bigNumber;
  }

  private toStringWithAutomaticPrecision() {
    const characteristic = this.bigNumber.div(Decimal.DIGITS);
    const mantissa = this.bigNumber.mod(Decimal.DIGITS);

    if (mantissa.isZero()) {
      return characteristic.toString();
    } else {
      const paddedMantissa = mantissa.toString().padStart(Decimal.PRECISION, "0");
      const trimmedMantissa = paddedMantissa.replace(Decimal.trailingZeros, "");
      return characteristic.toString() + "." + trimmedMantissa;
    }
  }

  private roundUp(precision: number) {
    const halfDigit = Decimal.getDigits(Decimal.PRECISION - 1 - precision).mul(5);
    return this.bigNumber.add(halfDigit);
  }

  private toStringWithPrecision(precision: number) {
    if (precision < 0) {
      throw new Error("precision must not be negative");
    }

    const value = precision < Decimal.PRECISION ? this.roundUp(precision) : this.bigNumber;
    const characteristic = value.div(Decimal.DIGITS);
    const mantissa = value.mod(Decimal.DIGITS);

    if (precision === 0) {
      return characteristic.toString();
    } else {
      const paddedMantissa = mantissa.toString().padStart(Decimal.PRECISION, "0");
      const trimmedMantissa = paddedMantissa.substr(0, precision);
      return characteristic.toString() + "." + trimmedMantissa;
    }
  }

  toString(precision?: number) {
    if (this.infinite) {
      return "∞";
    } else if (precision !== undefined) {
      return this.toStringWithPrecision(precision);
    } else {
      return this.toStringWithAutomaticPrecision();
    }
  }

  prettify(precision: number = 2) {
    const [characteristic, mantissa] = this.toString(precision).split(".");
    const prettyCharacteristic = characteristic.replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");

    return mantissa !== undefined ? prettyCharacteristic + "." + mantissa : prettyCharacteristic;
  }

  static prettify(bigNumberish: BigNumberish) {
    return new Decimal(BigNumber.from(bigNumberish).mul(Decimal.DIGITS)).prettify(0);
  }

  shorten() {
    const characteristicLength = this.toString(0).length;
    const magnitude = Math.min(
      Math.floor((characteristicLength - 1) / 3),
      Decimal.magnitudes.length - 1
    );

    const precision = Math.max(3 * (magnitude + 1) - characteristicLength, 0);
    const normalized = this.div(new Decimal(Decimal.getDigits(Decimal.PRECISION + 3 * magnitude)));

    return normalized.prettify(precision) + Decimal.magnitudes[magnitude];
  }

  static shorten(bigNumber: BigNumber) {
    return new Decimal(bigNumber.mul(Decimal.DIGITS)).shorten();
  }

  add(addend: Decimalish) {
    return new Decimal(this.bigNumber.add(Decimal.from(addend).bigNumber));
  }

  sub(subtrahend: Decimalish) {
    return new Decimal(this.bigNumber.sub(Decimal.from(subtrahend).bigNumber));
  }

  mul(multiplier: Decimalish) {
    return new Decimal(this.bigNumber.mul(Decimal.from(multiplier).bigNumber).div(Decimal.DIGITS));
  }

  div(divider: Decimalish) {
    divider = Decimal.from(divider);

    if (divider.isZero) {
      return Decimal.INFINITY;
    }

    return new Decimal(this.bigNumber.mul(Decimal.DIGITS).div(divider.bigNumber));
  }

  mulDiv(multiplier: Decimalish, divider: Decimalish) {
    multiplier = Decimal.from(multiplier);
    divider = Decimal.from(divider);

    if (divider.isZero) {
      return Decimal.INFINITY;
    }

    return new Decimal(this.bigNumber.mul(multiplier.bigNumber).div(divider.bigNumber));
  }

  get isZero() {
    return this.bigNumber.isZero();
  }

  get nonZero() {
    if (!this.isZero) {
      return this;
    }
  }

  get infinite() {
    if (this.eq(Decimal.INFINITY)) {
      return this;
    }
  }

  get finite() {
    if (!this.eq(Decimal.INFINITY)) {
      return this;
    }
  }

  get absoluteValue() {
    return this;
  }

  lt(that: Decimalish) {
    return this.bigNumber.lt(Decimal.from(that).bigNumber);
  }

  eq(that: Decimalish) {
    return this.bigNumber.eq(Decimal.from(that).bigNumber);
  }

  gt(that: Decimalish) {
    return this.bigNumber.gt(Decimal.from(that).bigNumber);
  }

  gte(that: Decimalish) {
    return this.bigNumber.gte(Decimal.from(that).bigNumber);
  }

  lte(that: Decimalish) {
    return this.bigNumber.lte(Decimal.from(that).bigNumber);
  }
}

type DifferenceRepresentation = { sign: "" | "+" | "-"; absoluteValue: Decimal };

export class Difference {
  private number?: DifferenceRepresentation;

  private constructor(number?: DifferenceRepresentation) {
    this.number = number;
  }

  static between(d1: Decimalish | undefined, d2: Decimalish | undefined) {
    if (!d1 || !d2) {
      return new Difference(undefined);
    }

    d1 = Decimal.from(d1);
    d2 = Decimal.from(d2);

    if (d1.infinite && d2.infinite) {
      return new Difference(undefined);
    } else if (d1.infinite) {
      return new Difference({ sign: "+", absoluteValue: d1 });
    } else if (d2.infinite) {
      return new Difference({ sign: "-", absoluteValue: d2 });
    } else if (d1.gt(d2)) {
      return new Difference({ sign: "+", absoluteValue: Decimal.from(d1).sub(d2) });
    } else if (d2.gt(d1)) {
      return new Difference({ sign: "-", absoluteValue: Decimal.from(d2).sub(d1) });
    } else {
      return new Difference({ sign: "", absoluteValue: Decimal.from(0) });
    }
  }

  toString(precision?: number) {
    if (!this.number) {
      return "N/A";
    }

    return this.number.sign + this.number.absoluteValue.toString(precision);
  }

  prettify(precision?: number) {
    if (!this.number) {
      return this.toString();
    }

    return this.number.sign + this.number.absoluteValue.prettify(precision);
  }

  mul(multiplier: Decimalish) {
    return new Difference(
      this.number && {
        sign: this.number.sign,
        absoluteValue: this.number.absoluteValue.mul(multiplier)
      }
    );
  }

  get bigNumber() {
    return this.number?.sign === "-"
      ? this.number.absoluteValue.bigNumber.mul(-1)
      : this.number?.absoluteValue.bigNumber;
  }

  get nonZero() {
    return this.number?.absoluteValue.nonZero && this;
  }

  get positive() {
    return this.number?.sign === "+" ? this : undefined;
  }

  get negative() {
    return this.number?.sign === "-" ? this : undefined;
  }

  get absoluteValue() {
    return this.number?.absoluteValue;
  }

  get infinite() {
    return this.number?.absoluteValue.infinite && this;
  }

  get finite() {
    return this.number?.absoluteValue.finite && this;
  }
}

export class Percent<
  T extends {
    infinite?: T | undefined;
    absoluteValue?: A | undefined;
    mul?(hundred: 100): T;
    toString(precision?: number): string;
  },
  A extends {
    gte(n: string): boolean;
  }
> {
  private percent: T;

  public constructor(ratio: T) {
    this.percent = ratio.infinite || (ratio.mul && ratio.mul(100)) || ratio;
  }

  nonZeroish(precision: number) {
    const zeroish = `0.${"0".repeat(precision)}5`;

    if (this.percent.absoluteValue?.gte(zeroish)) {
      return this;
    }
  }

  toString(precision: number) {
    return (
      this.percent.toString(precision) +
      (this.percent.absoluteValue && !this.percent.infinite ? "%" : "")
    );
  }

  prettify() {
    if (this.percent.absoluteValue?.gte("1000")) {
      return this.toString(0);
    } else if (this.percent.absoluteValue?.gte("10")) {
      return this.toString(1);
    } else {
      return this.toString(2);
    }
  }
}

'''
'''--- packages/decimal/test/Decimal.test.ts ---
import { describe, it } from "mocha";
import { expect } from "chai";
import { BigNumber } from "@ethersproject/bignumber";

import { Decimal } from "..";

describe("Decimal", () => {
  describe(".from()", () => {
    describe("when passing a string", () => {
      it("should throw if it's empty", () => {
        expect(() => Decimal.from("")).to.throw("bad decimal format");
      });

      it("should throw if it's non-numeric", () => {
        expect(() => Decimal.from("12O")).to.throw("bad decimal format");
      });

      it("should convert it if it has no decimal point", () => {
        expect(`${Decimal.from("123456789123456789123456789").bigNumber}`)
          //                                               |<----- 18 ----->|
          /********/ .to.equal("123456789123456789123456789000000000000000000");
      });

      it("should convert it if it has decimal point", () => {
        expect(`${Decimal.from("123456789123456789.123456789").bigNumber}`)
          //                                       |<----- 18 ----->|
          /*********/ .to.equal("123456789123456789123456789000000000");
      });

      it("should convert it if characteristic is missing", () => {
        expect(`${Decimal.from(".123456789").bigNumber}`)
          //                     |<----- 18 ----->|
          /*********/ .to.equal("123456789000000000");
      });

      it("should convert it if mantissa is missing", () => {
        expect(`${Decimal.from("123456789.").bigNumber}`)
          //                             |<----- 18 ----->|
          /********/ .to.equal("123456789000000000000000000");
      });

      it("should truncate if mantissa is too long", () => {
        expect(`${Decimal.from("1.123456789123456789123456789").bigNumber}`)
          //                      |<----- 18 ----->|
          /*********/ .to.equal("1123456789123456789");
      });
    });

    describe("when passing a number", () => {
      it("should preserve fractional part", () => {
        expect(`${Decimal.from(1.23456789).bigNumber}`)
          //                     |<----- 18 ----->|
          /********/ .to.equal("1234567890000000000");
      });
    });

    describe("when passing a Decimal", () => {
      it("should return the same Decimal", () => {
        const decimal = Decimal.from("123456789");
        expect(Decimal.from(decimal)).to.equal(decimal);
      });
    });
  });

  describe(".toString()", () => {
    describe("when not passing a parameter", () => {
      it("should not include '.' for integers", () => {
        expect(new Decimal(BigNumber.from("123456789000000000000000000")).toString())
          //                                      |<----- 18 ----->|
          /*****************/ .to.equal("123456789");
      });

      it("should include '.' for fractions", () => {
        expect(new Decimal(BigNumber.from("123456789000000000123456789")).toString())
          //                                      |<----- 18 ----->|
          /****************/ .to.equal("123456789.000000000123456789");
      });

      it("should trim trailing zeros from fractions", () => {
        expect(new Decimal(BigNumber.from("123456789123456789000000000")).toString())
          //                                      |<----- 18 ----->|
          /****************/ .to.equal("123456789.123456789");
      });
    });

    describe("when passing a precision parameter", () => {
      it("should round to the nearest decimal", () => {
        expect(new Decimal(BigNumber.from("123456789000499999999999999")).toString(3))
          //                                      |<----- 18 ----->|
          /****************/ .to.equal("123456789.000");

        expect(new Decimal(BigNumber.from("123456789000500000000000000")).toString(3))
          //                                      |<----- 18 ----->|
          /****************/ .to.equal("123456789.001");
      });

      it("should include '.' and decimal zeros for integers if precision is >0", () => {
        expect(new Decimal(BigNumber.from("123456789000000000000000000")).toString(2))
          //                                      |<----- 18 ----->|
          /****************/ .to.equal("123456789.00");
      });

      it("should not include '.' if precision is 0", () => {
        expect(new Decimal(BigNumber.from("123456789123456789123456789")).toString(0))
          //                                      |<----- 18 ----->|
          /*****************/ .to.equal("123456789");
      });
    });
  });

  describe(".shorten()", () => {
    const cases = [
      ["0.123", "0.12"],
      ["1.234", "1.23"],
      ["12.345", "12.3"],
      ["123.456", "123"],
      ["1234.567", "1.23K"],
      ["12345.678", "12.3K"],
      ["123456.789", "123K"],
      ["1234567.891", "1.23M"],
      ["12345678.912", "12.3M"],
      ["123456789.123", "123M"],
      ["1234567891.234", "1.23B"],
      ["12345678912.345", "12.3B"],
      ["123456789123.456", "123B"],
      ["1234567891234.567", "1.23T"],
      ["12345678912345.678", "12.3T"],
      ["123456789123456.789", "123T"],
      ["1234567891234567.891", "1,235T"],
      ["12345678912345678.912", "12,346T"],
      ["123456789123456789.123", "123,457T"],
      ["1234567891234567891.234", "1,234,568T"]
    ];

    for (const [input, expectedOutput] of cases) {
      it(`should turn '${input}' into '${expectedOutput}'`, () => {
        expect(Decimal.from(input).shorten()).to.equal(expectedOutput);
      });
    }
  });

  describe(".mul()", () => {
    it("should multiply", () => {
      expect(Decimal.from(2).mul(3).toString()).to.equal("6");
    });
  });

  describe(".div()", () => {
    it("should divide", () => {
      expect(Decimal.from(3).div(2).toString()).to.equal("1.5");
    });
  });

  describe(".mulDiv()", () => {
    it("should multiply then divide", () => {
      expect(Decimal.from(2).mulDiv(3, 2).toString()).to.equal("3");
    });
  });

  describe(".isZero", () => {
    it("should be true if Decimal is zero", () => {
      expect(Decimal.from("0.0").isZero).to.be.true;
    });

    it("should be false if Decimal is non-zero", () => {
      expect(Decimal.from("0.1").isZero).to.be.false;
    });
  });
});

'''
'''--- packages/decimal/tsconfig.dist.json ---
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "outDir": "dist"
  },
  "include": [
    "src"
  ],
  "files": [
    "./index.ts"
  ]
}

'''
'''--- packages/decimal/tsconfig.json ---
{
  "extends": "../../tsconfig.base.json",
  "include": ["src", "test"]
}

'''
'''--- packages/frontend/package.json ---
{
  "name": "@liquity/frontend",
  "version": "0.1.0",
  "private": true,
  "homepage": ".",
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^1.2.28",
    "@fortawesome/free-regular-svg-icons": "^5.13.0",
    "@fortawesome/free-solid-svg-icons": "^5.13.0",
    "@fortawesome/react-fontawesome": "^0.1.10",
    "@liquity/decimal": "^0.0.1",
    "@liquity/lib-base": "^0.0.1",
    "@liquity/lib-near": "^0.0.1",
    "@popperjs/core": "^2.4.2",
    "@testing-library/dom": "^6.12.2",
    "@testing-library/jest-dom": "^5.1.1",
    "@testing-library/react": "^9.4.0",
    "@testing-library/user-event": "^10.0.0",
    "@types/bn.js": "^4.11.6",
    "@types/jest": "^25.1.3",
    "@types/lru-cache": "^5.1.0",
    "@types/node": "^14.0.13",
    "@types/prop-types": "^15.7.3",
    "@types/react": "^16.9.36",
    "@types/react-copy-to-clipboard": "^4.3.0",
    "@types/react-dom": "^16.9.5",
    "@types/testing-library__jest-dom": "^5.0.1",
    "@types/testing-library__react": "^9.1.2",
    "@types/testing-library__user-event": "^4.1.1",
    "cross-env": "^7.0.2",
    "ethers": "^5.0.2",
    "near-api-js": "^0.30.0",
    "npm-run-all": "^4.1.5",
    "prop-types": "^15.7.2",
    "react": "^16.12.0",
    "react-circular-progressbar": "^2.0.3",
    "react-copy-to-clipboard": "^5.0.2",
    "react-dom": "^16.12.0",
    "react-is": "^16.12.0",
    "react-popper": "^2.2.3",
    "react-scripts": "^3.4.0",
    "source-map-explorer": "^2.4.2",
    "theme-ui": "^0.4.0-rc.1",
    "typescript": "^3.9.5"
  },
  "scripts": {
    "analyze": "source-map-explorer 'build/static/js/*.js'",
    "start": "react-scripts start",
    "build": "run-s build:*",
    "build:set-version": "node scripts/set-version.js",
    "build:react": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- packages/frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Developer UI for Liquity, the decentralized borrowing protocol"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo256.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Liquity Developer UI</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- packages/frontend/public/manifest.json ---
{
  "short_name": "Liquity Dev UI",
  "name": "Liquity Developer UI",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "32x32",
      "type": "image/png"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- packages/frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *

'''
'''--- packages/frontend/scripts/set-version.js ---
const { execSync } = require("child_process");
const { existsSync, readFileSync, writeFileSync } = require("fs");

const envVar = "REACT_APP_VERSION";
const envVarPattern = new RegExp(`^${envVar}=.*`);

const getCommitHash = () => {
  try {
    return execSync("git rev-parse HEAD", { encoding: "ascii" }).trim();
  } catch {
    return "unknown";
  }
};

const commitHash = getCommitHash();
let dotenv = [`${envVar}=${commitHash}`];

if (existsSync(".env")) {
  const originalDotenv = readFileSync(".env", { encoding: "ascii" }).split("\n");

  if (originalDotenv[originalDotenv.length - 1] === "") {
    originalDotenv.pop();
  }

  if (originalDotenv.some(line => line.match(envVarPattern))) {
    dotenv = originalDotenv.map(line => line.replace(envVarPattern, dotenv[0]));
  } else {
    dotenv = [...originalDotenv, ...dotenv];
  }
}

writeFileSync(".env", [...dotenv, ""].join("\n"));

'''
'''--- packages/frontend/src/@types/window.ethereum.d.ts ---
declare interface Window {
  ethereum?: {
    isMetaMask?: boolean;
  };
}

'''
'''--- packages/frontend/src/hooks/AccountBalance.ts ---
import { useCallback } from "react";
import { Provider } from "@ethersproject/abstract-provider";
import { BigNumber } from "@ethersproject/bignumber";

import { Decimal } from "@liquity/decimal";
import { useAsyncValue } from "./AsyncValue";

export const useAccountBalance = (provider: Provider, account: string) => {
  const getAccountBalance = useCallback(
    async () => new Decimal(await provider.getBalance(account)),
    [provider, account]
  );

  const watchAccountBalance = useCallback(
    (onAccountBalanceChanged: (value: Decimal) => void) => {
      const balanceChangedListener = (balance: BigNumber) => {
        const etherBalance = new Decimal(balance);
        console.log(`Update etherBalance to ${etherBalance}`);
        onAccountBalanceChanged(etherBalance);
      };

      provider.on(account, balanceChangedListener);

      return () => provider.removeListener(account, balanceChangedListener);
    },
    [provider, account]
  );

  return useAsyncValue(getAccountBalance, watchAccountBalance);
};

'''
'''--- packages/frontend/src/hooks/AsyncValue.ts ---
import { useState, useEffect } from "react";

export type AsyncValueState<T> = { loaded: false } | { loaded: true; value: T };

export function useAsyncValue<T>(
  getValue: () => Promise<T>,
  watchValue?: (onValueChanged: (value: T) => void) => () => void,
  reduceValues?: (previousValue: T, newValue: T) => T
) {
  const [callState, setCallState] = useState<AsyncValueState<T>>({ loaded: false });

  useEffect(() => {
    let previousValue: T | undefined = undefined;
    let mounted = true;
    let unwatch: (() => void) | undefined;

    const fetchValue = async () => {
      const value = await getValue();

      if (mounted && previousValue === undefined) {
        setCallState({ loaded: true, value });
        previousValue = value;
      }
    };

    const onValueChanged = (value: T) => {
      if (mounted) {
        if (previousValue !== undefined && reduceValues) {
          value = reduceValues(previousValue, value);
        }

        setCallState({ loaded: true, value });
        previousValue = value;
      }
    };

    setCallState({ loaded: false });
    fetchValue();

    if (watchValue) {
      unwatch = watchValue(onValueChanged);
    }

    return () => {
      mounted = false;
      if (unwatch) {
        unwatch();
      }
    };
  }, [getValue, watchValue, reduceValues]);

  return callState;
}

export type AsyncStore = {
  [property: string]: AsyncValueState<unknown>;
};

export type Values<T> = {
  [P in keyof T]: T[P] extends AsyncValueState<infer V> ? V : never;
};

type LoadedStore = {
  [property: string]: { loaded: true; value: unknown };
};

const allLoaded = (store: AsyncStore): store is LoadedStore => {
  for (const { loaded } of Object.values(store)) {
    if (!loaded) {
      return false;
    }
  }
  return true;
};

export const useAsyncStore = <T extends AsyncStore>(store: T): AsyncValueState<Values<T>> => {
  if (!allLoaded(store)) {
    return { loaded: false };
  }

  return {
    loaded: true,
    value: Object.fromEntries(
      Object.entries(store).map(([property, asyncValueState]) => [property, asyncValueState.value])
    ) as Values<T>
  };
};

'''
'''--- packages/frontend/src/hooks/EventDrivenLiquityStore.ts ---
import { useCallback } from "react";
import { Provider } from "@ethersproject/abstract-provider";

import { Decimal } from "@liquity/decimal";
import {
  ReadableLiquity,
  Trove,
  StabilityDeposit,
  TroveWithPendingRewards
} from "@liquity/lib-base";
import { useAsyncValue, useAsyncStore } from "./AsyncValue";
import { useAccountBalance } from "./AccountBalance";

export const useLiquityStore = (provider: Provider, account: string, liquity: ReadableLiquity) => {
  const getTotal = useCallback(() => liquity.getTotal(), [liquity]);
  const watchTotal = useCallback(
    (onTotalChanged: (total: Trove) => void) => {
      const logged = (total: Trove) => {
        console.log(`Update total to ${total}`);
        onTotalChanged(total);
      };
      return liquity.watchTotal(logged);
    },
    [liquity]
  );

  const getNumberOfTroves = useCallback(() => liquity.getNumberOfTroves(), [liquity]);
  const watchNumberOfTroves = useCallback(
    (onNumberOfTrovesChanged: (numberOfTroves: number) => void) => {
      const logged = (numberOfTroves: number) => {
        console.log(`Update numberOfTroves to ${numberOfTroves}`);
        onNumberOfTrovesChanged(numberOfTroves);
      };
      return liquity.watchNumberOfTroves(logged);
    },
    [liquity]
  );

  const getPrice = useCallback(() => liquity.getPrice(), [liquity]);
  const watchPrice = useCallback(
    (onPriceChanged: (price: Decimal) => void) => {
      const logged = (price: Decimal) => {
        console.log(`Update price to ${price}`);
        onPriceChanged(price);
      };
      return liquity.watchPrice(logged);
    },
    [liquity]
  );

  const getTroveWithoutRewards = useCallback(() => liquity.getTroveWithoutRewards(account), [
    liquity
  ]);
  const watchTroveWithoutRewards = useCallback(
    (onTroveChanged: (trove: TroveWithPendingRewards) => void) => {
      const logged = (trove: TroveWithPendingRewards) => {
        console.log(`Update troveWithoutRewards to ${trove}`);
        onTroveChanged(trove);
      };
      return liquity.watchTroveWithoutRewards(logged, account);
    },
    [liquity, account]
  );

  const getTotalRedistributed = useCallback(() => liquity.getTotalRedistributed(), [liquity]);
  const watchTotalRedistributed = useCallback(
    (onTotalRedistributedChanged: (totalRedistributed: Trove) => void) => {
      const logged = (totalRedistributed: Trove) => {
        console.log(`Update totalRedistributed to ${totalRedistributed}`);
        onTotalRedistributedChanged(totalRedistributed);
      };
      return liquity.watchTotalRedistributed(logged);
    },
    [liquity]
  );

  const getStabilityDeposit = useCallback(() => liquity.getStabilityDeposit(account), [liquity]);
  const watchStabilityDeposit = useCallback(
    (onStabilityDepositChanged: (deposit: StabilityDeposit) => void) => {
      const logged = (deposit: StabilityDeposit) => {
        console.log(`Update deposit to ${deposit}`);
        onStabilityDepositChanged(deposit);
      };
      return liquity.watchStabilityDeposit(logged, account);
    },
    [liquity, account]
  );

  const getQuiBalance = useCallback(() => liquity.getQuiBalance(account), [liquity]);
  const watchQuiBalance = useCallback(
    (onQuiBalanceChanged: (balance: Decimal) => void) => {
      const logged = (balance: Decimal) => {
        console.log(`Update quiBalance to ${balance}`);
        onQuiBalanceChanged(balance);
      };
      return liquity.watchQuiBalance(logged, account);
    },
    [liquity, account]
  );

  const getQuiInStabilityPool = useCallback(() => liquity.getQuiInStabilityPool(), [liquity]);
  const watchQuiInStabilityPool = useCallback(
    (onQuiInStabilityPoolChanged: (quiInStabilityPool: Decimal) => void) => {
      const logged = (quiInStabilityPool: Decimal) => {
        console.log(`Update quiInStabilityPool to ${quiInStabilityPool}`);
        onQuiInStabilityPoolChanged(quiInStabilityPool);
      };
      return liquity.watchQuiInStabilityPool(logged);
    },
    [liquity]
  );

  const storeState = useAsyncStore({
    etherBalance: useAccountBalance(provider, account),
    quiBalance: useAsyncValue(getQuiBalance, watchQuiBalance),
    price: useAsyncValue(getPrice, watchPrice),
    numberOfTroves: useAsyncValue(getNumberOfTroves, watchNumberOfTroves),
    troveWithoutRewards: useAsyncValue(getTroveWithoutRewards, watchTroveWithoutRewards),
    totalRedistributed: useAsyncValue(getTotalRedistributed, watchTotalRedistributed),
    deposit: useAsyncValue(getStabilityDeposit, watchStabilityDeposit),
    total: useAsyncValue(getTotal, watchTotal),
    quiInStabilityPool: useAsyncValue(getQuiInStabilityPool, watchQuiInStabilityPool)
  });

  if (!storeState.loaded) {
    return storeState;
  }

  const { loaded, value } = storeState;

  return {
    loaded,
    value: { trove: value.troveWithoutRewards.applyRewards(value.totalRedistributed), ...value }
  };
};

'''
'''--- packages/frontend/src/hooks/NearLiquityStore.ts ---
import { useCallback } from "react";
import { BigNumber } from "@ethersproject/bignumber";
import * as nearAPI from "near-api-js";

import { Decimal } from "@liquity/decimal";
import { Trove, StabilityDeposit } from "@liquity/lib-base";
import { ReadableLiquity } from "@liquity/lib-base";
import { useAsyncValue } from "./AsyncValue";

type Resolved<T> = T extends Promise<infer U> ? U : T;
type ResolvedValues<T> = { [P in keyof T]: Resolved<T[P]> };

const promiseAllValues = <T>(object: T): Promise<ResolvedValues<T>> => {
  const keys = Object.keys(object);
  return Promise.all(Object.values(object)).then(values =>
    Object.fromEntries(values.map((value, i) => [keys[i], value]))
  ) as Promise<ResolvedValues<T>>;
};

const decimalify = ({ amount }: { amount: string }) => new Decimal(BigNumber.from(amount));

export const useLiquityStore = (
  walletConnection: nearAPI.WalletConnection,
  account: string,
  liquity: ReadableLiquity
) => {
  const get = useCallback(async () => {
    const store = await promiseAllValues({
      etherBalance: walletConnection
        .account()
        .state()
        .then(amount => decimalify(amount).div(1000000)),
      quiBalance: liquity.getQuiBalance(account),
      price: liquity.getPrice(),
      numberOfTroves: liquity.getNumberOfTroves(),
      troveWithoutRewards: liquity.getTroveWithoutRewards(account),
      totalRedistributed: liquity.getTotalRedistributed(),
      deposit: liquity.getStabilityDeposit(account),
      total: liquity.getTotal(),
      quiInStabilityPool: liquity.getQuiInStabilityPool()
    });

    return {
      ...store,
      trove: store.troveWithoutRewards.applyRewards(store.totalRedistributed)
    };
  }, [walletConnection, account, liquity]);

  type Values = Resolved<ReturnType<typeof get>> & {
    [prop: string]: number | Decimal | Trove | StabilityDeposit | undefined;
  };

  const watch = useCallback(
    (updateValues: (values: Values) => void) => {
      const updater = setInterval(() => {
        get().then(updateValues);
      }, 4000);

      return () => clearInterval(updater);
    },
    [get]
  );

  const reduce = useCallback(
    (previous: Values, neuu: Values) =>
      Object.fromEntries(
        Object.keys(previous).map(key => {
          const previousValue = previous[key];
          const newValue = neuu[key];

          const equals =
            previousValue === newValue ||
            (previousValue instanceof Decimal && previousValue.eq(newValue as Decimal)) ||
            (previousValue instanceof Trove && previousValue.equals(newValue as Trove)) ||
            (previousValue instanceof StabilityDeposit &&
              previousValue.equals(newValue as StabilityDeposit));

          return [key, equals ? previousValue : newValue];
        })
      ) as Values,
    []
  );

  return useAsyncValue(get, watch, reduce);
};

'''
'''--- packages/frontend/src/hooks/usePrevious.ts ---
import { useRef } from "react";

export function usePrevious<T>(value: T) {
  const ref = useRef<T>(value);

  const previousValue = ref.current;
  ref.current = value;

  return previousValue;
}

'''
'''--- packages/frontend/src/images/MetaMaskIcon.svg ---
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.49025 3.49976L1.49216 0.499756L0.492432 3.49976L2.49189 11.9998L21.4867 11.4998L23.4861 3.49976L21.9866 0.499756L15.4883 3.49976H8.49025Z" fill="#763D16"/>
<path d="M6.99048 11.9998H17.9875V18.9998H6.99048V11.9998Z" fill="#333333"/>
<rect x="7.99023" y="16.9998" width="5.99836" height="3" fill="#333333"/>
<path d="M1.58124 10.6642C1.72755 10.8311 1.76935 11.0607 1.70665 11.2485L0.222731 15.8398C0.18093 15.9651 0.18093 16.0903 0.222731 16.1946L1.51854 20.6398C1.62304 20.9738 1.95745 21.1616 2.27095 21.0572L6.7227 19.8259C6.9108 19.7633 7.1198 19.8259 7.287 19.9511L8.06031 20.5772C8.08121 20.5981 8.08121 20.5981 8.10211 20.5981L10.0249 21.9338C10.1294 21.9964 10.2548 22.0381 10.3802 22.0381H13.5989C13.7243 22.0381 13.8497 21.9964 13.9542 21.9338L15.877 20.5981C15.8979 20.5981 15.8979 20.5772 15.9188 20.5772L16.6921 19.9511C16.8384 19.8259 17.0474 19.7842 17.2564 19.8259L21.7081 21.0572C22.0426 21.1407 22.377 20.9529 22.4606 20.6398L23.7564 16.1946C23.7982 16.0694 23.7982 15.9442 23.7564 15.8398L22.2725 11.2485C22.2098 11.0398 22.2516 10.8311 22.3979 10.6642L23.9863 3.54766C24.0072 3.44331 24.0072 3.33897 23.9654 3.23462L23.0249 0.417226C22.9204 0.0833133 22.5442 -0.0836433 22.2098 0.0415742L15.2709 2.6294C15.2082 2.65027 15.1246 2.67114 15.0619 2.67114H8.91722C8.83362 2.67114 8.77092 2.65027 8.70822 2.6294L1.76935 0.0415742C1.43494 -0.0836433 1.05874 0.0833133 0.954238 0.417226L0.0346286 3.23462C-0.00717182 3.3181 -0.00717182 3.44331 0.0137284 3.54766L1.58124 10.6642ZM13.996 14.2537L14.5185 13.1685C14.5812 13.0433 14.7484 12.9807 14.8738 13.0433L16.1278 13.6068C16.3577 13.7111 16.3368 14.0451 16.086 14.1285L14.3304 14.6503C14.1005 14.7129 13.8915 14.4833 13.996 14.2537ZM13.8915 6.71984C13.7661 6.61549 13.7661 6.40679 13.9124 6.32331L21.8126 0.918096C21.9381 0.834618 22.1262 0.876357 22.1889 1.04331L23.1712 3.73549C23.1921 3.77723 23.1921 3.81897 23.1712 3.88157L21.5618 10.0798C21.52 10.2051 21.3946 10.2677 21.2692 10.2259L16.922 9.05723C16.8802 9.05723 16.8593 9.03636 16.8384 9.01549L13.8915 6.71984ZM10.0667 19.5338L10.213 18.3233C10.213 18.2607 10.2548 18.1981 10.3175 18.1564L10.6101 17.9477C10.6519 17.9268 10.6937 17.9059 10.7355 17.9059H13.2018C13.2436 17.9059 13.3063 17.9268 13.3272 17.9477L13.6198 18.1564C13.6825 18.1981 13.7034 18.2607 13.7243 18.3233L13.8497 19.5338C13.8706 19.6798 13.7452 19.8051 13.6198 19.8051H10.2757C10.1712 19.8051 10.0667 19.6798 10.0667 19.5338ZM7.85131 13.6068L9.10532 13.0433C9.25162 12.9807 9.39792 13.0433 9.46062 13.1685L9.98313 14.2537C10.0876 14.4624 9.87863 14.692 9.64873 14.6294L7.87221 14.1077C7.64231 14.0451 7.62141 13.7111 7.85131 13.6068ZM0.807936 3.86071C0.787036 3.81897 0.807936 3.75636 0.807936 3.71462L1.79025 1.04331C1.85295 0.897226 2.04105 0.834618 2.16645 0.918096L10.0667 6.32331C10.213 6.42766 10.213 6.61549 10.0876 6.71984L7.1407 9.01549C7.1198 9.03636 7.078 9.05723 7.0571 9.05723L2.70986 10.2259C2.58445 10.2677 2.45905 10.2051 2.41725 10.0798L0.807936 3.86071Z" fill="#F36D34"/>
</svg>

'''
'''--- packages/frontend/src/nearConfig.ts ---
export default {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
  contractId: "quid.globalmoney.testnet",
  tokenId: "lqd.globalmoney.testnet"
};

'''
'''--- packages/frontend/src/react-app-env.d.ts ---
/// <reference types="react-scripts" />

'''
'''--- packages/frontend/src/serviceWorker.ts ---
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://bit.ly/CRA-PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
    )
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(
      process.env.PUBLIC_URL,
      window.location.href
    );
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://bit.ly/CRA-PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then(registration => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch(error => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' }
  })
    .then(response => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then(registration => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log(
        'No internet connection found. App is running in offline mode.'
      );
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready.then(registration => {
      registration.unregister();
    });
  }
}

'''
'''--- packages/frontend/src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import "@testing-library/jest-dom/extend-expect";

import { DisposableWalletProvider } from "./testUtils/DisposableWalletProvider";

const ethereum = new DisposableWalletProvider(
  "http://localhost:8545",
  "0x4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7"
);

// Let web3-react's InjectedConnector find our DisposableWalletProvider
Object.assign(window, { ethereum });

Object.fromEntries = <T = any>(
  entries: Iterable<readonly [PropertyKey, T]>
): { [k in PropertyKey]: T } =>
  Object.assign({}, ...Array.from(entries).map(([k, v]) => ({ [k]: v })));

'''
'''--- packages/frontend/src/testUtils/DisposableWalletProvider.ts ---
import { hexlify } from "@ethersproject/bytes";
import { Wallet } from "@ethersproject/wallet";
import { Decimal, Decimalish } from "@liquity/decimal";

export class DisposableWalletProvider {
  private readonly url: string;
  private id: number = 0;

  private readonly wallet: Wallet;
  private readonly funderWallet: Wallet;

  private readonly ethAmount: Decimal;
  private haveFunded = false;

  constructor(url: string, funderPrivateKey: string, ethAmount: Decimalish = 100) {
    this.url = url;
    this.wallet = Wallet.createRandom();
    this.funderWallet = new Wallet(funderPrivateKey);
    this.ethAmount = Decimal.from(ethAmount);
  }

  private findWallet(address: string) {
    const wallet = [this.wallet, this.funderWallet].find(
      wallet => wallet.address.toLowerCase() === address.toLowerCase()
    );

    if (!wallet) {
      throw new Error(`Unknow account ${address}`);
    }

    return wallet;
  }

  private async fund() {
    return this.send("eth_sendTransaction", [
      {
        from: this.funderWallet.address,
        to: this.wallet.address,
        value: hexlify(this.ethAmount.bigNumber),
        gas: hexlify(21000)
      }
    ]);

    // TODO maybe wait for tx to be mined (not a problem on devchains though)
  }

  async send(method: string, params: any[]): Promise<any> {
    if (!this.haveFunded) {
      this.haveFunded = true;
      await this.fund();
    }

    switch (method) {
      case "eth_accounts":
      case "eth_requestAccounts":
        return [this.wallet.address];

      case "eth_sendTransaction":
        return this.send(
          "eth_sendRawTransaction",
          await Promise.all(
            params.map(async ({ from, nonce, gas, ...rest }) => {
              if (nonce === undefined) {
                nonce = await this.send("eth_getTransactionCount", [from]);
              }

              return this.findWallet(from).signTransaction({
                from,
                nonce,
                ...(gas !== undefined ? { gasLimit: gas } : {}),
                ...rest
              });
            })
          )
        );
    }

    //console.log({ method, params });

    const response = await fetch(this.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        method: method,
        params: params,
        id: this.id++,
        jsonrpc: "2.0"
      })
    });

    const json = await response.json();

    //console.log(json);

    if (json.error) {
      const { message, ...rest } = json.error;
      const error = new Error(`${message} ${JSON.stringify(rest)}`);
      throw Object.assign(error, rest);
    }

    return json.result;
  }

  request({ method, params }: { method: string; params: any[] }) {
    return this.send(method, params);
  }
}

'''
'''--- packages/frontend/src/theme.ts ---
import { Theme, ThemeUIStyleObject } from "theme-ui";

const baseColors = {
  blue: "#1542cd",
  purple: "#745ddf",
  cyan: "#2eb6ea",
  green: "#28c081",
  yellow: "#fd9d28",
  red: "#dc2c10",
  lightRed: "#ff755f"
};

const colors = {
  primary: baseColors.blue,
  secondary: baseColors.purple,
  accent: baseColors.cyan,

  success: baseColors.green,
  warning: baseColors.yellow,
  danger: baseColors.red,
  dangerHover: baseColors.lightRed,
  info: baseColors.blue,
  invalid: "pink",

  text: "#293147",
  background: "white",
  muted: "#eaebed"
};

const buttonBase = {
  display: "flex",
  alignItems: "center",
  justifyContent: "center",

  ":enabled": { cursor: "pointer" }
} as const;

const button = {
  ...buttonBase,

  px: "32px",
  py: "12px",

  color: "white",

  fontWeight: "bold",

  ":disabled": {
    opacity: 0.5
  }
} as const;

const iconButton = {
  ...buttonBase,

  padding: 0,
  width: "40px",
  height: "40px",

  background: "none",

  ":disabled": {
    color: "text",
    opacity: 0.25
  }
} as const;

const cardHeadingFontSize = 18.7167;

const cardGapX = [0, 3, 4];
const cardGapY = [3, 3, 4];

const card: ThemeUIStyleObject = {
  position: "relative",
  mt: cardGapY,
  border: 1,
  boxShadow: [1, null, 2]
};

const infoCard = {
  ...card,

  padding: 3,

  borderColor: "rgba(122,199,240,0.4)",
  background: "linear-gradient(200deg, #d4d9fc, #cae9f9)",

  h2: {
    mb: 2,
    fontSize: cardHeadingFontSize
  }
} as const;

const formBase = {
  display: "block",
  width: "auto",
  flexShrink: 0,
  padding: 2,
  fontSize: 3
} as const;

const formCell: ThemeUIStyleObject = {
  ...formBase,

  bg: "background",
  border: 1,
  borderColor: "muted",
  borderRadius: 0,
  boxShadow: [1, 2]
};

const overlay = {
  position: "absolute",

  left: 0,
  top: 0,
  width: "100%",
  height: "100%",

  zIndex: 2
} as const;

const modalOverlay = {
  position: "fixed",

  left: 0,
  top: 0,
  width: "100vw",
  height: "100vh",

  zIndex: 4
} as const;

const theme: Theme = {
  breakpoints: ["48em", "52em", "64em"],

  space: [0, 4, 8, 16, 32, 64, 128, 256, 512],

  fonts: {
    body: [
      "system-ui",
      "-apple-system",
      "BlinkMacSystemFont",
      '"Segoe UI"',
      "Roboto",
      '"Helvetica Neue"',
      "sans-serif"
    ].join(", "),
    heading: "inherit",
    monospace: "Menlo, monospace"
  },

  fontSizes: [12, 14, 16, 20, 24, 32, 48, 64, 96],

  fontWeights: {
    body: 400,
    heading: 600,
    bold: 600
  },

  lineHeights: {
    body: 1.5,
    heading: 1.25
  },

  colors,

  borders: [0, "1px solid"],

  shadows: ["0", "0px 4px 8px rgba(41, 49, 71, 0.1)", "0px 8px 16px rgba(41, 49, 71, 0.1)"],

  text: {
    address: {
      fontFamily: "monospace",
      fontSize: 1
    }
  },

  buttons: {
    primary: {
      ...button,
      bg: "primary",
      ":enabled:hover": { bg: "secondary" }
    },

    danger: {
      ...button,
      bg: "danger",
      ":enabled:hover": { bg: "dangerHover" }
    },

    icon: {
      ...iconButton,
      color: "primary",
      ":enabled:hover": { color: "accent" }
    },

    dangerIcon: {
      ...iconButton,
      color: "danger",
      ":enabled:hover": { color: "dangerHover" }
    },

    titleIcon: {
      ...iconButton,
      color: "text",
      ":enabled:hover": { color: "success" }
    }
  },

  cards: {
    primary: {
      ...card,

      padding: 0,

      borderColor: "muted",
      bg: "background",

      "> h2": {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",

        height: "56px",

        pl: 3,
        py: 2,
        pr: 2,

        bg: "muted",

        fontSize: cardHeadingFontSize
      },

      "> :last-child": {
        padding: 2
      }
    },

    info: {
      ...infoCard,

      display: ["none", "block"]
    },

    infoPopup: {
      ...infoCard,

      position: "fixed",
      top: 0,
      right: 3,
      left: 3,
      mt: "72px"
    },

    tooltip: {
      padding: 2,

      border: 1,
      borderColor: "muted",
      borderRadius: "4px",
      bg: "background",
      boxShadow: 2,

      fontSize: 1,

      zIndex: 3
    }
  },

  forms: {
    label: {
      ...formBase
    },

    unit: {
      ...formCell,

      textAlign: "center",
      bg: "muted"
    },

    input: {
      ...formCell,

      flex: 1
    }
  },

  layout: {
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "stretch",

      position: ["fixed", "relative"],
      width: "100vw",
      top: 0,
      zIndex: 2,

      px: [2, "12px", "12px", 5],
      py: [2, "12px", "12px"],

      background: `linear-gradient(90deg, ${colors.background}, ${colors.muted})`,
      boxShadow: [1, "none"]
    },

    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",

      mt: cardGapY,
      px: 3,
      height: "72px",

      bg: "muted"
    },

    main: {
      width: "100%",
      maxWidth: "894px",
      mx: "auto",
      mt: ["40px", 0],
      px: cardGapX
    },

    columns: {
      display: "flex",
      flexWrap: "wrap",
      justifyItems: "center"
    },

    left: {
      pr: cardGapX,
      width: ["100%", "60%"]
    },

    right: {
      width: ["100%", "40%"]
    },

    actions: {
      mt: cardGapY,
      justifyContent: "center"
    },

    loadingOverlay: {
      ...overlay,

      bg: "rgba(255, 255, 255, 0.5)"
    },

    modalOverlay: {
      ...modalOverlay,

      bg: "rgba(0, 0, 0, 0.8)",

      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    },

    modal: {
      padding: 3,
      width: ["100%", "40em"]
    },

    infoOverlay: {
      ...modalOverlay,

      display: ["block", "none"],

      bg: "rgba(255, 255, 255, 0.8)"
    }
  },

  styles: {
    root: {
      fontFamily: "body",
      lineHeight: "body",
      fontWeight: "body"
    },

    a: {
      color: "primary",
      ":hover": { color: "accent" },
      textDecoration: "none",
      fontWeight: "bold"
    }
  }
};

export default theme;

'''
'''--- packages/frontend/src/utils/shortenAddress.ts ---
export const shortenAddress = (address: string) => address.substr(0, 6) + "..." + address.substr(-4);

'''
'''--- packages/frontend/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": [
    "src"
  ]
}

'''
'''--- packages/lib-base/index.ts ---
export * from "./src/Trove";
export * from "./src/StabilityDeposit";
export * from "./src/ReadableLiquity";
export * from "./src/TransactableLiquity";
export * from "./src/HintedLiquity";

'''
'''--- packages/lib-base/package.json ---
{
  "name": "@liquity/lib-base",
  "version": "0.0.1",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "prepare": "tsc --project tsconfig.dist.json"
  },
  "peerDependencies": {
    "@liquity/decimal": "^0.0.1"
  },
  "devDependencies": {
    "@ethersproject/bignumber": "^5.0.1",
    "@liquity/decimal": "^0.0.1",
    "typescript": "^3.9.5"
  }
}

'''
'''--- packages/lib-base/src/HintedLiquity.ts ---
import { Decimal, Decimalish } from "@liquity/decimal";

import { Trove, TroveChange } from "./Trove";
import { StabilityDeposit } from "./StabilityDeposit";
import { TransactableLiquity } from "./TransactableLiquity";

export type HintedTransactionOptionalParams = {
  price?: Decimal;
  numberOfTroves?: number;
};

export type TroveChangeOptionalParams = HintedTransactionOptionalParams & {
  trove?: Trove;
};

export type StabilityDepositTransferOptionalParams = TroveChangeOptionalParams & {
  deposit?: StabilityDeposit;
};

export interface HintedLiquity<TTransaction = unknown> extends TransactableLiquity<TTransaction> {
  openTrove(trove: Trove, optionalParams?: HintedTransactionOptionalParams): Promise<TTransaction>;

  depositEther(
    depositedEther: Decimalish,
    optionalParams?: TroveChangeOptionalParams
  ): Promise<TTransaction>;

  withdrawEther(
    withdrawnEther: Decimalish,
    optionalParams?: TroveChangeOptionalParams
  ): Promise<TTransaction>;

  borrowQui(
    borrowedQui: Decimalish,
    optionalParams?: TroveChangeOptionalParams
  ): Promise<TTransaction>;

  repayQui(repaidQui: Decimalish, optionalParams?: TroveChangeOptionalParams): Promise<TTransaction>;

  changeTrove(
    change: TroveChange,
    optionalParams?: TroveChangeOptionalParams
  ): Promise<TTransaction>;

  transferCollateralGainToTrove(
    optionalParams?: StabilityDepositTransferOptionalParams
  ): Promise<TTransaction>;

  redeemCollateral(
    exchangedQui: Decimalish,
    optionalParams?: HintedTransactionOptionalParams
  ): Promise<TTransaction>;
}

'''
'''--- packages/lib-base/src/ReadableLiquity.ts ---
import { Decimal } from "@liquity/decimal";

import { Trove, TroveWithPendingRewards } from "./Trove";
import { StabilityDeposit } from "./StabilityDeposit";

export interface ReadableLiquity {
  getTotalRedistributed(): Promise<Trove>;
  watchTotalRedistributed(
    onTotalRedistributedChanged: (totalRedistributed: Trove) => void
  ): () => void;

  getTroveWithoutRewards(address?: string): Promise<TroveWithPendingRewards>;
  watchTroveWithoutRewards(
    onTroveChanged: (trove: TroveWithPendingRewards) => void,
    address?: string
  ): () => void;

  getTrove(address?: string): Promise<Trove>;

  getNumberOfTroves(): Promise<number>;
  watchNumberOfTroves(onNumberOfTrovesChanged: (numberOfTroves: number) => void): () => void;

  getPrice(): Promise<Decimal>;
  watchPrice(onPriceChanged: (price: Decimal) => void): () => void;

  getTotal(): Promise<Trove>;
  watchTotal(onTotalChanged: (total: Trove) => void): () => void;

  getStabilityDeposit(address?: string): Promise<StabilityDeposit>;
  watchStabilityDeposit(
    onStabilityDepositChanged: (deposit: StabilityDeposit) => void,
    address?: string
  ): () => void;

  getQuiInStabilityPool(): Promise<Decimal>;
  watchQuiInStabilityPool(
    onQuiInStabilityPoolChanged: (quiInStabilityPool: Decimal) => void
  ): () => void;

  getQuiBalance(address?: string): Promise<Decimal>;
  watchQuiBalance(onQuiBalanceChanged: (balance: Decimal) => void, address?: string): () => void;

  getLastTroves(
    startIdx: number,
    numberOfTroves: number
  ): Promise<(readonly [string, TroveWithPendingRewards])[]>;

  getFirstTroves(
    startIdx: number,
    numberOfTroves: number
  ): Promise<(readonly [string, TroveWithPendingRewards])[]>;
}

'''
'''--- packages/lib-base/src/StabilityDeposit.ts ---
import { Decimal, Decimalish, Difference } from "@liquity/decimal";

// yeah, sounds stupid...
interface StabilityDepositish {
  readonly deposit?: Decimalish;
  readonly depositAfterLoss?: Decimalish;
  readonly pendingCollateralGain?: Decimalish;
}

export class StabilityDeposit {
  readonly deposit: Decimal;
  readonly depositAfterLoss: Decimal;
  readonly pendingCollateralGain: Decimal;

  get isEmpty() {
    return this.deposit.isZero && this.depositAfterLoss.isZero && this.pendingCollateralGain.isZero;
  }

  constructor({
    deposit = 0,
    depositAfterLoss = deposit,
    pendingCollateralGain = 0
  }: StabilityDepositish) {
    this.deposit = Decimal.from(deposit);
    this.depositAfterLoss = Decimal.from(depositAfterLoss);
    this.pendingCollateralGain = Decimal.from(pendingCollateralGain);
  }

  toString() {
    return (
      "{\n" +
      `  deposit: ${this.deposit},\n` +
      `  depositAfterLoss: ${this.depositAfterLoss},\n` +
      `  pendingCollateralGain: ${this.pendingCollateralGain}\n` +
      "}"
    );
  }

  equals(that: StabilityDeposit) {
    return (
      this.deposit.eq(that.deposit) &&
      this.depositAfterLoss.eq(that.depositAfterLoss) &&
      this.pendingCollateralGain.eq(that.pendingCollateralGain)
    );
  }

  calculateDifference(that: StabilityDeposit) {
    if (!that.depositAfterLoss.eq(this.depositAfterLoss)) {
      return Difference.between(that.depositAfterLoss, this.depositAfterLoss);
    }
  }

  apply(difference?: Difference) {
    if (difference?.positive) {
      return new StabilityDeposit({ deposit: this.depositAfterLoss.add(difference.absoluteValue!) });
    } else if (difference?.negative) {
      return new StabilityDeposit({
        deposit: difference.absoluteValue!.lt(this.depositAfterLoss)
          ? this.depositAfterLoss.sub(difference.absoluteValue!)
          : 0
      });
    } else {
      return this;
    }
  }
}

'''
'''--- packages/lib-base/src/TransactableLiquity.ts ---
import { Decimalish } from "@liquity/decimal";

import { Trove, TroveChange } from "./Trove";

export interface TransactableLiquity<TTransaction = unknown> {
  openTrove(trove: Trove): Promise<TTransaction>;
  closeTrove(): Promise<TTransaction>;

  depositEther(depositedEther: Decimalish): Promise<TTransaction>;
  withdrawEther(withdrawnEther: Decimalish): Promise<TTransaction>;
  borrowQui(borrowedQui: Decimalish): Promise<TTransaction>;
  repayQui(repaidQui: Decimalish): Promise<TTransaction>;
  changeTrove(change: TroveChange): Promise<TTransaction>;

  setPrice(price: Decimalish): Promise<TTransaction>;
  updatePrice(): Promise<TTransaction>;

  liquidate(address: string): Promise<TTransaction>;
  liquidateUpTo(maximumNumberOfTrovesToLiquidate: number): Promise<TTransaction>;

  depositQuiInStabilityPool(depositedQui: Decimalish): Promise<TTransaction>;
  withdrawQuiFromStabilityPool(withdrawnQui: Decimalish): Promise<TTransaction>;
  transferCollateralGainToTrove(): Promise<TTransaction>;

  sendQui(toAddress: string, amount: Decimalish): Promise<TTransaction>;

  redeemCollateral(exchangedQui: Decimalish): Promise<TTransaction>;
}

'''
'''--- packages/lib-base/src/Trove.ts ---
import { Decimal, Decimalish, Difference } from "@liquity/decimal";

interface Trovish {
  readonly collateral?: Decimalish;
  readonly debt?: Decimalish;
  readonly virtualDebt?: Decimalish;
}

export type TroveChange = {
  collateralDifference?: Difference;
  debtDifference?: Difference;
};

export class Trove {
  public static readonly CRITICAL_COLLATERAL_RATIO: Decimal = Decimal.from(1.5);
  public static readonly MINIMUM_COLLATERAL_RATIO: Decimal = Decimal.from(1.1);
  // public static readonly DEFAULT_VIRTUAL_DEBT: Decimal = Decimal.from(10);
  public static readonly DEFAULT_VIRTUAL_DEBT: Decimal = Decimal.from(0);

  readonly collateral: Decimal;
  readonly debt: Decimal;

  /**
   * Imaginary debt that doesn't need to be repaid, but counts towards collateral ratio (lowers it).
   *
   * When performing arithmetic on Troves (addition or subtraction of 2 Troves, multiplication by a
   * scalar), the virtual debt of the Trove on the left side of the operation will be copied to the
   * resulting Trove.
   */
  readonly virtualDebt: Decimal;

  constructor({ collateral = 0, debt = 0, virtualDebt = Trove.DEFAULT_VIRTUAL_DEBT }: Trovish = {}) {
    this.collateral = Decimal.from(collateral);
    this.debt = Decimal.from(debt);
    this.virtualDebt = Decimal.from(virtualDebt);
  }

  get isEmpty() {
    return this.collateral.isZero && this.debt.isZero;
  }

  get compositeDebt() {
    return this.debt.nonZero?.add(this.virtualDebt) ?? this.debt;
  }

  collateralRatio(price: Decimalish): Decimal {
    return this.collateral.mulDiv(price, this.compositeDebt);
  }

  collateralRatioIsBelowMinimum(price: Decimalish) {
    return this.collateralRatio(price).lt(Trove.MINIMUM_COLLATERAL_RATIO);
  }

  collateralRatioIsBelowCritical(price: Decimalish) {
    return this.collateralRatio(price).lt(Trove.CRITICAL_COLLATERAL_RATIO);
  }

  toString() {
    return (
      `{ collateral: ${this.collateral}` +
      `, debt: ${this.debt}` +
      (this.collateral.nonZero && this.virtualDebt.nonZero
        ? `, virtualDebt: ${this.virtualDebt}`
        : "") +
      " }"
    );
  }

  equals(that: Trove) {
    return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);
  }

  add({ collateral = 0, debt = 0 }: Trovish) {
    return new Trove({
      collateral: this.collateral.add(collateral),
      debt: this.debt.add(debt),
      virtualDebt: this.virtualDebt
    });
  }

  addCollateral(collateral: Decimalish) {
    return this.add({ collateral });
  }

  addDebt(debt: Decimalish) {
    return this.add({ debt });
  }

  subtract({ collateral = 0, debt = 0 }: Trovish) {
    return new Trove({
      collateral: this.collateral.sub(collateral),
      debt: this.debt.sub(debt),
      virtualDebt: this.virtualDebt
    });
  }

  subtractCollateral(collateral: Decimalish) {
    return this.subtract({ collateral });
  }

  subtractDebt(debt: Decimalish) {
    return this.subtract({ debt });
  }

  multiply(multiplier: Decimalish) {
    return new Trove({
      collateral: this.collateral.mul(multiplier),
      debt: this.debt.mul(multiplier),
      virtualDebt: this.virtualDebt
    });
  }

  setCollateral(collateral: Decimalish) {
    return new Trove({
      collateral,
      debt: this.debt,
      virtualDebt: this.virtualDebt
    });
  }

  setDebt(debt: Decimalish) {
    return new Trove({
      collateral: this.collateral,
      debt,
      virtualDebt: this.virtualDebt
    });
  }

  whatChanged({ collateral, debt }: Trove) {
    const change: TroveChange = {};

    if (!collateral.eq(this.collateral)) {
      change.collateralDifference = Difference.between(collateral, this.collateral);
    }

    if (!debt.eq(this.debt)) {
      change.debtDifference = Difference.between(debt, this.debt);
    }

    return change;
  }

  applyCollateralDifference(collateralDifference?: Difference) {
    if (collateralDifference?.positive) {
      return this.addCollateral(collateralDifference.absoluteValue!);
    } else if (collateralDifference?.negative) {
      if (collateralDifference.absoluteValue!.lt(this.collateral)) {
        return this.subtractCollateral(collateralDifference.absoluteValue!);
      } else {
        return this.setCollateral(0);
      }
    } else {
      return this;
    }
  }

  applyDebtDifference(debtDifference?: Difference) {
    if (debtDifference?.positive) {
      return this.addDebt(debtDifference.absoluteValue!);
    } else if (debtDifference?.negative) {
      if (debtDifference.absoluteValue!.lt(this.collateral)) {
        return this.subtractDebt(debtDifference.absoluteValue!);
      } else {
        return this.setDebt(0);
      }
    } else {
      return this;
    }
  }

  apply({ collateralDifference, debtDifference }: TroveChange) {
    return this.applyCollateralDifference(collateralDifference).applyDebtDifference(debtDifference);
  }
}

interface TrovishWithPendingRewards extends Trovish {
  readonly stake?: Decimalish;
  readonly snapshotOfTotalRedistributed?: Trovish;
}

export class TroveWithPendingRewards extends Trove {
  readonly stake: Decimal;
  readonly snapshotOfTotalRedistributed: Trove;

  constructor({
    collateral = 0,
    debt = 0,
    stake = 0,
    snapshotOfTotalRedistributed
  }: TrovishWithPendingRewards = {}) {
    super({ collateral, debt });

    this.stake = Decimal.from(stake);
    this.snapshotOfTotalRedistributed = new Trove({
      ...snapshotOfTotalRedistributed,
      virtualDebt: 0
    });
  }

  applyRewards(totalRedistributed: Trove) {
    return this.add(
      totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake)
    );
  }

  equals(that: TroveWithPendingRewards) {
    return (
      super.equals(that) &&
      this.stake.eq(that.stake) &&
      this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed)
    );
  }
}

'''
'''--- packages/lib-base/tsconfig.dist.json ---
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "outDir": "dist"
  },
  "include": ["src"],
  "files": ["./index.ts"]
}

'''
'''--- packages/lib-base/tsconfig.json ---
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"]
}

'''
'''--- packages/lib-near/index.ts ---
export * from "./src/NearLiquity";

'''
'''--- packages/lib-near/package.json ---
{
  "name": "@liquity/lib-near",
  "version": "0.0.1",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "prepare": "tsc --project tsconfig.dist.json"
  },
  "peerDependencies": {
    "@liquity/lib-base": "^0.0.1",
    "near-api-js": "^0.30.0"
  },
  "devDependencies": {
    "@ethersproject/bignumber": "^5.0.1",
    "@liquity/decimal": "^0.0.1",
    "@liquity/lib-base": "^0.0.1",
    "near-api-js": "^0.30.0",
    "typescript": "^3.9.5"
  }
}

'''
'''--- packages/lib-near/src/NearLiquity.ts ---
import * as nearAPI from "near-api-js";

import { BigNumber } from "@ethersproject/bignumber";

import { Decimal, Decimalish } from "@liquity/decimal";
import {
  ReadableLiquity,
  StabilityDeposit,
  TransactableLiquity,
  Trove,
  TroveChange,
  TroveWithPendingRewards
} from "@liquity/lib-base";

enum CDPStatus {
  nonExistent,
  active,
  closed
}

type BNLike = string | number;

interface LiquityViewMethods {
  getCDP(args: {
    owner_id: string;
  }): Promise<{
    debt: string;
    coll: string;
    stake: string;
    status: string;
    arrayIndex: string;
  }>;

  getPrice(): Promise<string>;

  getTotalColl(): Promise<string>;

  getTotalDebt(): Promise<string>;

  getSPdep(args: { owner: string }): Promise<string>;

  getSPdebt(): Promise<string>;

  getCDPs(): Promise<{
    [owner: string]: {
      debt: string;
      coll: string;
      stake: string;
      status: string;
      arrayIndex: string;
    };
  }>;
}

interface LiquityChangeMethods {
  openLoan(args: { _LQDAmount: BNLike }, gas: BNLike, amount: BNLike): Promise<void>;

  closeLoan(args: {}, gas: BNLike): Promise<void>;

  addColl(args: { _user: string }, gas: BNLike, amount: BNLike): Promise<void>;

  withdrawColl(args: { _amount: BNLike }, gas: BNLike): Promise<void>;

  withdrawLQD(args: { _amount: BNLike }, gas: BNLike): Promise<void>;

  repayLQD(args: { _amount: BNLike }, gas: BNLike): Promise<void>;

  adjustLoan(
    args: { _collWithdrawal: BNLike; _debtChange: BNLike; _isDebtIncrease: BNLike },
    gas: BNLike,
    amount: BNLike
  ): Promise<void>;

  setPrice(args: { newPrice: BNLike }, gas: BNLike): Promise<void>;

  liquidate(args: { _user: string }, gas: BNLike): Promise<void>;

  provideToSP(args: { _amount: BNLike }, gas: BNLike): Promise<void>;

  withdrawFromSP(args: { _amount: BNLike }, gas: BNLike): Promise<void>;

  redeemCollateral(args: { _LQDamount: BNLike }, gas: BNLike): Promise<void>;
}

type LiquityContract = nearAPI.Contract & LiquityViewMethods & LiquityChangeMethods;

const liquityMethods: {
  viewMethods: (keyof LiquityViewMethods)[];
  changeMethods: (keyof LiquityChangeMethods)[];
} = {
  viewMethods: [
    "getCDP",
    "getPrice",
    "getTotalColl",
    "getTotalDebt",
    "getSPdep",
    "getSPdebt",
    "getCDPs"
  ],

  changeMethods: [
    "openLoan",
    "closeLoan",
    "addColl",
    "withdrawColl",
    "withdrawLQD",
    "repayLQD",
    "adjustLoan",
    "setPrice",
    "liquidate",
    "provideToSP",
    "withdrawFromSP",
    "redeemCollateral"
  ]
};

interface TokenViewMethods {
  get_balance(args: { owner_id: string }): Promise<string>;
}

interface TokenChangeMethods {
  transfer(args: { new_owner_id: string; amount: BNLike }, gas: BNLike): Promise<void>;
}

type TokenContract = nearAPI.Contract & TokenViewMethods & TokenChangeMethods;

const tokenMethods: {
  viewMethods: (keyof TokenViewMethods)[];
  changeMethods: (keyof TokenChangeMethods)[];
} = {
  viewMethods: ["get_balance"],
  changeMethods: ["transfer"]
};

export class WrappedNearTransaction {
  private promise: Promise<void>;

  constructor(promise: Promise<void>) {
    this.promise = promise;
  }

  wait() {
    return this.promise;
  }
}

const AMPLE_GAS = "1000000000000";
const NEAR_SCALING_FACTOR = Decimal.from("1000000"); // Quick hack: NEAR uses 6 more decimals

const numberify = (numberString: string) => parseInt(numberString, 10);
const decimalify = (bigNumberString?: string | null) =>
  new Decimal(BigNumber.from(bigNumberString ?? 0));

export class NearLiquity implements ReadableLiquity, TransactableLiquity<WrappedNearTransaction> {
  private contract: LiquityContract;
  private token: TokenContract;
  private userAddress: string;

  constructor(
    account: nearAPI.Account,
    contractId = "quid.globalmoney.testnet",
    tokenId = "lqd.globalmoney.testnet"
  ) {
    this.contract = new nearAPI.Contract(account, contractId, liquityMethods) as LiquityContract;
    this.token = new nearAPI.Contract(account, tokenId, tokenMethods) as TokenContract;
    this.userAddress = account.accountId;
  }

  async openTrove(trove: Trove) {
    return new WrappedNearTransaction(
      this.contract.openLoan(
        { _LQDAmount: `${trove.debt.bigNumber}` },
        "10000000000000", // 5 Tgas needed, put 2x to be safe
        `${trove.collateral.mul(NEAR_SCALING_FACTOR).bigNumber}`
      )
    );
  }

  async closeTrove() {
    return new WrappedNearTransaction(this.contract.closeLoan({}, AMPLE_GAS));
  }

  async depositEther(depositedEther: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.addColl(
        { _user: this.userAddress },
        AMPLE_GAS,
        `${Decimal.from(depositedEther).mul(NEAR_SCALING_FACTOR).bigNumber}`
      )
    );
  }

  async withdrawEther(withdrawnEther: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.withdrawColl(
        { _amount: `${Decimal.from(withdrawnEther).mul(NEAR_SCALING_FACTOR).bigNumber}` },
        AMPLE_GAS
      )
    );
  }

  async borrowQui(borrowedQui: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.withdrawLQD({ _amount: `${Decimal.from(borrowedQui).bigNumber}` }, AMPLE_GAS)
    );
  }

  async repayQui(repaidQui: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.repayLQD({ _amount: `${Decimal.from(repaidQui).bigNumber}` }, AMPLE_GAS)
    );
  }

  async changeTrove(change: TroveChange) {
    return new WrappedNearTransaction(
      this.contract.adjustLoan(
        {
          _collWithdrawal: `${
            change.collateralDifference?.negative?.absoluteValue?.mul(NEAR_SCALING_FACTOR)
              .bigNumber || 0
          }`,
          _debtChange: `${change.debtDifference?.absoluteValue?.bigNumber || 0}`,
          _isDebtIncrease: change.debtDifference?.positive ? 1 : 0
        },
        AMPLE_GAS,
        `${
          change.collateralDifference?.positive?.absoluteValue?.mul(NEAR_SCALING_FACTOR).bigNumber ||
          0
        }`
      )
    );
  }

  async setPrice(price: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.setPrice({ newPrice: `${Decimal.from(price).bigNumber}` }, AMPLE_GAS)
    );
  }

  updatePrice(): Promise<WrappedNearTransaction> {
    throw new Error("Method not implemented.");
  }

  async liquidate(_user: string) {
    return new WrappedNearTransaction(this.contract.liquidate({ _user }, AMPLE_GAS));
  }

  liquidateUpTo(_n: number): Promise<WrappedNearTransaction> {
    throw new Error("Method not implemented.");
  }

  async depositQuiInStabilityPool(depositedQui: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.provideToSP({ _amount: `${Decimal.from(depositedQui).bigNumber}` }, AMPLE_GAS)
    );
  }

  async withdrawQuiFromStabilityPool(withdrawnQui: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.withdrawFromSP({ _amount: `${Decimal.from(withdrawnQui).bigNumber}` }, AMPLE_GAS)
    );
  }

  async transferCollateralGainToTrove(): Promise<WrappedNearTransaction> {
    throw new Error("Method not implemented.");
  }

  async sendQui(new_owner_id: string, amount: Decimalish) {
    return new WrappedNearTransaction(
      this.token.transfer({ new_owner_id, amount: `${Decimal.from(amount).bigNumber}` }, AMPLE_GAS)
    );
  }

  async redeemCollateral(exchangedQui: Decimalish) {
    return new WrappedNearTransaction(
      this.contract.redeemCollateral(
        { _LQDamount: `${Decimal.from(exchangedQui).bigNumber}` },
        AMPLE_GAS
      )
    );
  }

  async getTotalRedistributed() {
    return new Trove({ collateral: 0, debt: 0, virtualDebt: 0 });
  }

  watchTotalRedistributed(
    onTotalRedistributedChanged: (totalRedistributed: Trove) => void
  ): () => void {
    throw new Error("Method not implemented.");
  }

  async getTroveWithoutRewards(owner_id = this.userAddress) {
    const cdp = await this.contract.getCDP({ owner_id });

    if (numberify(cdp.status) === CDPStatus.active) {
      return new TroveWithPendingRewards({
        collateral: decimalify(cdp.coll).div(NEAR_SCALING_FACTOR),
        debt: decimalify(cdp.debt),
        stake: decimalify(cdp.stake),

        snapshotOfTotalRedistributed: {
          collateral: 0,
          debt: 0
        }
      });
    } else {
      return new TroveWithPendingRewards();
    }
  }

  watchTroveWithoutRewards(
    onTroveChanged: (trove: TroveWithPendingRewards) => void,
    address?: string
  ): () => void {
    throw new Error("Method not implemented.");
  }

  async getTrove(address = this.userAddress) {
    const [trove, totalRedistributed] = await Promise.all([
      this.getTroveWithoutRewards(address),
      this.getTotalRedistributed()
    ]);

    return trove.applyRewards(totalRedistributed);
  }

  async getNumberOfTroves() {
    // XXX shouldn't get every single CDP, but the backend has no function to return the number of CDPs
    const cdps = await this.contract.getCDPs();

    return Object.keys(cdps).length;
  }

  watchNumberOfTroves(onNumberOfTrovesChanged: (numberOfTroves: number) => void): () => void {
    throw new Error("Method not implemented.");
  }

  getPrice() {
    return this.contract.getPrice().then(decimalify);
  }

  watchPrice(onPriceChanged: (price: Decimal) => void): () => void {
    throw new Error("Method not implemented.");
  }

  async getTotal() {
    const [collateral, debt] = await Promise.all(
      [this.contract.getTotalColl(), this.contract.getTotalDebt()].map(getBigNumber =>
        getBigNumber.then(decimalify)
      )
    );

    return new Trove({
      collateral: collateral.div(NEAR_SCALING_FACTOR),
      debt,
      virtualDebt: 0
    });
  }

  watchTotal(onTotalChanged: (total: Trove) => void): () => void {
    throw new Error("Method not implemented.");
  }

  async getStabilityDeposit(owner = this.userAddress) {
    const deposit = Decimal.from(await this.contract.getSPdep({ owner }));

    return new StabilityDeposit({ deposit, depositAfterLoss: deposit, pendingCollateralGain: 0 });
  }

  watchStabilityDeposit(
    onStabilityDepositChanged: (deposit: StabilityDeposit) => void,
    address?: string
  ): () => void {
    throw new Error("Method not implemented.");
  }

  getQuiInStabilityPool() {
    return this.contract.getSPdebt().then(decimalify);
  }

  watchQuiInStabilityPool(
    onQuiInStabilityPoolChanged: (quiInStabilityPool: Decimal) => void
  ): () => void {
    throw new Error("Method not implemented.");
  }

  getQuiBalance(owner_id = this.userAddress) {
    return this.token.get_balance({ owner_id }).then(decimalify).catch(() => Decimal.from(0));
  }

  watchQuiBalance(onQuiBalanceChanged: (balance: Decimal) => void, address?: string): () => void {
    throw new Error("Method not implemented.");
  }

  async getLastTroves(startIdx: number, numberOfTroves: number) {
    // XXX shouldn't get every single CDP, but there's no way to get a slice from the backend
    const cdps = await this.contract.getCDPs();

    return mapCDPsToTroves(cdps)
      .sort(compareTrovesAscending)
      .slice(startIdx, startIdx + numberOfTroves);
  }

  async getFirstTroves(startIdx: number, numberOfTroves: number) {
    // XXX shouldn't get every single CDP, but there's no way to get a slice from the backend
    const cdps = await this.contract.getCDPs();

    return mapCDPsToTroves(cdps)
      .sort(compareTrovesDescending)
      .slice(startIdx, startIdx + numberOfTroves);
  }
}

type Resolved<T> = T extends Promise<infer U> ? U : T;
type CDPs = Resolved<ReturnType<LiquityViewMethods["getCDPs"]>>;

const mapCDPsToTroves = (cdps: CDPs) =>
  Object.entries(cdps).map(
    ([owner, { coll, debt, stake }]) =>
      [
        owner,

        new TroveWithPendingRewards({
          collateral: decimalify(coll).div(NEAR_SCALING_FACTOR),
          debt: decimalify(debt),
          stake: decimalify(stake),

          snapshotOfTotalRedistributed: {
            collateral: 0,
            debt: 0
          }
        })
      ] as const
  );

const compareTrovesAscending = (
  [, t1]: readonly [string, Trove],
  [, t2]: readonly [string, Trove]
) => {
  const r1 = t1.collateralRatio(1);
  const r2 = t2.collateralRatio(1);

  return r1.lt(r2) ? -1 : r1.gt(r2) ? 1 : 0;
};

const compareTrovesDescending = (
  [, t1]: readonly [string, Trove],
  [, t2]: readonly [string, Trove]
) => {
  const r1 = t1.collateralRatio(1);
  const r2 = t2.collateralRatio(1);

  return r1.lt(r2) ? 1 : r1.gt(r2) ? -1 : 0;
};

'''
'''--- packages/lib-near/tsconfig.dist.json ---
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "outDir": "dist"
  },
  "include": ["src"],
  "files": ["./index.ts"]
}

'''
'''--- packages/lib-near/tsconfig.json ---
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"]
}

'''
'''--- tsconfig.base.json ---
{
  "compilerOptions": {
    "target": "ES2019",
    "lib": ["ES2019", "DOM"],
    "module": "CommonJS",
    "strict": true,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  }
}

'''