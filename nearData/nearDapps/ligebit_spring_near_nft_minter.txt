*GitHub Repository "ligebit/spring_near_nft_minter"*

'''--- README.md ---
Challenge #3. NFT minter

https://ligebit.github.io/spring_near_nft_minter/

//don't use web3.storage token in frontend

'''
'''--- contracts/cargo.toml ---
[package]
name = "spring_near_nft_minter"
version = "1.0.0"
authors = ["@ligebit"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"
base64 = "0.13.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contracts/src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::json_types::ValidAccountId;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

use near_contract_standards::non_fungible_token::refund_deposit;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    TokensPerOwner { account_hash: Vec<u8> },
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "NEAR MONSTER".to_string(),
                symbol: "NM".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: ValidAccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> Token {
        let initial_storage_usage = env::storage_usage();

        if self.tokens.token_metadata_by_id.is_some() && token_metadata.is_none() {
            env::panic(b"Must provide metadata");
        }
        if self.tokens.owner_by_id.get(&token_id).is_some() {
            env::panic(b"token_id must be unique");
        }

        let owner_id: AccountId = receiver_id.into();

        // Core behavior: every token must have an owner
        self.tokens.owner_by_id.insert(&token_id, &owner_id);

        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.tokens.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata.as_ref().unwrap()));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        // Approval Management extension: return empty HashMap as part of Token
        let approved_account_ids =
            if self.tokens.approvals_by_id.is_some() { Some(HashMap::new()) } else { None };

        // Return any extra attached deposit not used for storage
        refund_deposit(env::storage_usage() - initial_storage_usage);

        Token { token_id, owner_id, metadata: token_metadata, approved_account_ids }
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- package.json ---
{
  "name": "spring_near_nft_minte",
  "version": "1.0.0",
  "scripts": {
    "build-run-client": "parcel src/index.html",
    "build-client": "parcel build src/index.html --public-url .",
    "build-contract": "cd contracts && cargo build --target wasm32-unknown-unknown --release",
    "deploy-contract": "npm run build-contract && near dev-deploy --wasmFile contracts/target/wasm32-unknown-unknown/release/spring_near_nft_minter.wasm",
    "contract": "npm run build-contract && rd /s /q neardev && near dev-deploy --wasmFile contracts/target/wasm32-unknown-unknown/release/spring_near_nft_minter.wasm"
  },
  "author": "@ligebit",
  "license": "ISC",
  "dependencies": {
    "ipfs-car": "^0.7.0",
    "near-api-js": "^0.44.2",
    "nft.storage": "^6.2.0",
    "parcel": "^2.4.1",
    "web3.storage": "^4.2.0"
  },
  "devDependencies": {
    "buffer": "^6.0.3",
    "process": "^0.11.10"
  },
  "main": "index.js",
  "description": ""
}

'''
'''--- src/component_config.js ---
module.exports = {
    body: {
        coords: {
            x: 200, y: 90
        },
        sprites: {
            body_blueA: require('./assets/body_blueA.png'),
            body_blueB: require('./assets/body_blueB.png'),
            body_blueC: require('./assets/body_blueC.png'),
            body_blueD: require('./assets/body_blueD.png')
        }
    },
    leg: {
        coords: {
            x: 140, y: 250
        },
        isDouble: true,
        sprites: {
            leg_blueA: require('./assets/leg_blueA.png'),
            leg_blueB: require('./assets/leg_blueB.png'),
            leg_blueC: require('./assets/leg_blueC.png'),
            leg_blueD: require('./assets/leg_blueD.png'),
        }
    },
    arm: {
        coords: {
            x: 100, y: 130
        },
        isDouble: true,
        sprites: {
            arm_blueA: require('./assets/arm_blueA.png'),
            arm_blueB: require('./assets/arm_blueB.png'),
            arm_blueC: require('./assets/arm_blueC.png'),
            arm_blueD: require('./assets/arm_blueD.png')
        }
    },
    eye: {
        coords: {
            x: 150, y: 130
        },
        isDouble: true,
        sprites: {
            eye_closed_feminine: require('./assets/eye_closed_feminine.png'),
            eye_angry_blue: require('./assets/eye_angry_blue.png'),
            eye_closed_happy: require('./assets/eye_closed_happy.png'),
            eye_human_red: require('./assets/eye_human_red.png')
        }
    },
}
'''
'''--- src/index.html ---
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
		<link href="./style.css" rel="stylesheet">
    </head>
    <body>

		<nav class="navbar p-2">
			<button id="sign-in" class="btn btn-primary signed-out ms-auto">
				Sign in
			</button>
		</nav>

		<div class="container-fluid d-flex align-items-center justify-content-center" >
 
			<div class="container">
				<div class="col justify-content-center text-center">
					
					<h1 id="header">Create NFT monster</h1>

					<div class="text-center position-relative" style="width: 450px; margin: auto;">
						
						<button id="sel_l_0" class="select_btn btn_0 select_btn_l btn btn-primary"><</button>
						<button id="sel_l_1" class="select_btn btn_1 select_btn_l btn btn-primary"><</button>
						<button id="sel_l_2" class="select_btn btn_2 select_btn_l btn btn-primary"><</button>
						<button id="sel_l_3" class="select_btn btn_3 select_btn_l btn btn-primary"><</button>

						<button id="sel_r_0" class="select_btn btn_0 select_btn_r btn btn-primary">></button>
						<button id="sel_r_1" class="select_btn btn_1 select_btn_r btn btn-primary">></button>
						<button id="sel_r_2" class="select_btn btn_2 select_btn_r btn btn-primary">></button>
						<button id="sel_r_3" class="select_btn btn_3 select_btn_r btn btn-primary">></button>

						<canvas id="monster" width="400" height="400"></canvas>
					</div>

					<div class="col-md-6 col-lg-5 mb-3 text-center p-5" style="margin: auto;">
						
						<button type="button" id="send_answer_button" class="btn btn-primary w-50" disabled>
							Not authorized
						</button>

					</div>
				</div>
			</div>
		</div>

		<nav class="navbar fixed-bottom navbar-expand-sm navbar-dark bg-dark p-2">
			<div class="container d-flex justify-content-center">
				<a class="navbar-brand" href="#">SOURCE</a>
				<a class="navbar-brand" href="https://kenney-assets.itch.io/monster-builder-pack">monster image</a>
				<a class="navbar-brand" href="https://nearspring.splashthat.com/">from nearspring</a>
			</div>
		</nav>

		<script src="./index.js" type="module"></script>
      	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    </body>
</html>
'''
'''--- src/index.js ---
const {connect, Contract, WalletAccount, keyStores, utils} = require('near-api-js');

import { Web3Storage } from 'web3.storage/dist/bundle.esm.min.js'

const MONSTER_CONSTRUCTOR = require("./monster_constructor");

const monster_constructoror = new MONSTER_CONSTRUCTOR();

function getNearConfig(networkId) {
    return {
        networkId: networkId,
        nodeUrl: `https://rpc.${networkId}.near.org`,
        contractName: `dev-1650561550422-61788933866863`,
        walletUrl: `https://wallet.${networkId}.near.org`,
        helperUrl: `https://helper.${networkId}.near.org`,
    }
}
window.nearConfig = getNearConfig('testnet');

async function initContract() {
    window.near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, window.nearConfig));
  
    window.walletAccount = new WalletAccount(window.near);
  
    window.accountId = window.walletAccount.getAccountId();
  
    window.contract = new Contract(
        window.walletAccount.account(),
        window.nearConfig.contractName, {
            viewMethods: ['nft_supply_for_owner', 'nft_tokens_for_owner', 'nft_metadata', 'nft_tokens_for_owner_set', 'nft_token'],
            changeMethods: ['nft_mint', 'new_default_meta'],
        }
    );

}

async function doWork() {
    if (!window.walletAccount.isSignedIn()) {
        signedOutFlow();
    } else {
        signedInFlow();
    }
}

function signedOutFlow() {
    Array.from(document.querySelectorAll('.hide-signed-out')).forEach(el => el.style.visibility = 'hidden');

    document.getElementById('sign-in').addEventListener('click', () => {
        window.walletAccount.requestSignIn(window.nearConfig.contractName);
    });
}
  

async function signedInFlow() {
    Array.from(document.querySelectorAll('.hide-signed-out')).forEach(el => el.style.visibility = 'visible');

    document.getElementById('sign-in').innerText = window.accountId;

    send_answer_button.innerHTML = 'Create';
    send_answer_button.disabled = false;

    document.getElementById('sign-in').addEventListener('click', e => {
        e.preventDefault();
        window.walletAccount.signOut();
        window.location.replace(window.location.origin + window.location.pathname);
    });

}

const send_answer_button = document.getElementById('send_answer_button');

send_answer_button.onclick = async () => {
    send_answer_button.innerHTML = '<span class="spinner-border spinner-border-sm mr-2" role="status" aria-hidden="true" style="margin-right: 5px"></span>Sending image to IPFS...';
    send_answer_button.disabled = true;

    monster_constructoror.canvas.toBlob(async (blob) => {

        const files = [
            new File([blob], `${window.accountId}.png`, { type: "image/png" })
        ]

        const client = new Web3Storage({ token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweDFGM0Y0NUVDNTNFRWUxOEQ3OGQzRDk5REJlNGVjMGUwYTg3NmQ4NkMiLCJpc3MiOiJ3ZWIzLXN0b3JhZ2UiLCJpYXQiOjE2NTA1NTY2ODExOTEsIm5hbWUiOiJzcHJpbmdfbmVhcl9uZnRfbWludGVyIn0.hHCyxm3rMvmqfH65sY9H37apdfnGyrETpXJMypFiqKc' })
        const cid = await client.put(files);

        const url = `https://${cid}.ipfs.dweb.link/${window.accountId}.png`;

        await window.contract.nft_mint({
            args: {
                token_id: window.accountId,
                receiver_id: window.accountId,
                token_metadata: {

                    media: url
                }
            }, 
            gas: "300000000000000",
            amount: utils.format.parseNearAmount("1")
        });
        
    }, 'image/png');

}

window.onload = async () => {
    await monster_constructoror.load();
    await initContract();
    doWork();

    const token = await window.contract.nft_token({
        token_id: window.accountId
    });

    if(token) {

        send_answer_button.innerHTML = 'Check in wallet';
        send_answer_button.onclick = () => {
            location.href = 'https://wallet.testnet.near.org/?tab=collectibles';
        }

        document.getElementById('header').innerHTML = `Load...`;

        monster_constructoror.setToken(token);
    } else {
        monster_constructoror.draw();
    }
}
'''
'''--- src/monster_constructor.js ---
const component_config = require('./component_config.js');

const sel_l_0 = document.getElementById('sel_l_0');
const sel_l_1 = document.getElementById('sel_l_1');
const sel_l_2 = document.getElementById('sel_l_2');
const sel_l_3 = document.getElementById('sel_l_3');

const sel_r_0 = document.getElementById('sel_r_0');
const sel_r_1 = document.getElementById('sel_r_1');
const sel_r_2 = document.getElementById('sel_r_2');
const sel_r_3 = document.getElementById('sel_r_3');

module.exports = class MONSTER_CONSTRUCTOR {

    constructor() {
        this.canvas = document.getElementById('monster');
        this.ctx = this.canvas.getContext('2d');

        this.sprites = {};

        this.robot = {}

        sel_l_0.onclick = () => {
            this.prev('eye');
            this.draw();
        }
        sel_l_1.onclick = () => {
            this.prev('arm');
            this.draw();
        }
        sel_l_2.onclick = () => {
            this.prev('body');
            this.draw();
        }
        sel_l_3.onclick = () => {
            this.prev('leg');
            this.draw();
        }

        sel_r_0.onclick = () => {
            this.next('eye');
            this.draw();
        }
        sel_r_1.onclick = () => {
            this.next('arm');
            this.draw();
        }
        sel_r_2.onclick = () => {
            this.next('body');
            this.draw();
        }
        sel_r_3.onclick = () => {
            this.next('leg');
            this.draw();
        }
    }

    async setToken(token) {
        sel_l_0.style.visibility = 'hidden';
        sel_l_1.style.visibility = 'hidden';
        sel_l_2.style.visibility = 'hidden';
        sel_l_3.style.visibility = 'hidden';

        sel_r_0.style.visibility = 'hidden';
        sel_r_1.style.visibility = 'hidden';
        sel_r_2.style.visibility = 'hidden';
        sel_r_3.style.visibility = 'hidden';

        const url = token.metadata.media;
        const image = await MONSTER_CONSTRUCTOR.addImageProcess(url);

        this.ctx.drawImage(image, 0, 0);

        
        document.getElementById('header').innerHTML = `Your NFT monster`;
    }

    next(name) {
        const length = Object.keys(this.sprites[name]).length;
        this.robot[name] += 1;
        if(this.robot[name] >= length ) {
            this.robot[name] = 0;
        }
    }
    prev(name) {
        const length = Object.keys(this.sprites[name]).length;
        this.robot[name] -= 1;
        if(this.robot[name] < 0 ) {
            this.robot[name] = length - 1;
        }
    }

    async load() {
        console.log(component_config);
        for (const key in component_config) {
            this.sprites[key] = {};

            this.robot[key] = 0;
            for (const spriteName in component_config[key].sprites) {
                this.sprites[key][spriteName] = await MONSTER_CONSTRUCTOR.addImageProcess(component_config[key].sprites[spriteName]);
            }
        }

        // const eyeImage = await ROBOT_CONSTRUCTOR.addImageProcess(require('./eye.png'));
        // this.robot = await ROBOT_CONSTRUCTOR.addImageProcess(require('./robot.png'));

        // this.rightEye = new EYE(this.ctx, 155, 80, eyeImage);
        // this.leftEye = new EYE(this.ctx, 210, 80, eyeImage);

        // this.isLoaded = true;

        // this.componentImage
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (const componentName in this.robot) {
            const nameSprite = Object.keys(this.sprites[componentName])[this.robot[componentName]];

            const image = this.sprites[componentName][nameSprite];

            const isDouble = component_config[componentName].isDouble;

            if(isDouble) {
                //this.ctx.drawImage(image, component_config[componentName].coords.x - image.width/2, component_config[componentName].coords.y);

                this.ctx.save();
                this.ctx.translate(component_config[componentName].coords.x + image.width/2, component_config[componentName].coords.y);
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(image, 0, 0);
                this.ctx.restore();

                this.ctx.drawImage(image, this.canvas.width - component_config[componentName].coords.x - image.width/2, component_config[componentName].coords.y);
            } else {
                this.ctx.drawImage(image, component_config[componentName].coords.x - image.width/2, component_config[componentName].coords.y);
            }

        }
    }

    static addImageProcess(src, width, height) {
        return new Promise((resolve, reject) => {
            let img = new Image(width, height);
            img.onload = () => resolve(img);
            img.onerror = (err) => reject(err);
            img.src = src;
        })
    }

}

'''
'''--- src/style.css ---
* {
    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    font-size: 20px;
    line-height: 1.3;
}

.message {
    margin: 60px 0px;

    border-radius: 5px;

    background: #AEDFE4;
    padding: 20px;
    text-align: center;

    position: relative;
}

.message .border_r {
    border-right: 2px black solid;
}

.message .border_animation {
    animation: border 1s infinite steps(2, end);
}

.select_btn {
    position: absolute;
    border: none;
}

.select_btn_r {
    right: 0px;
}
.select_btn_l {
    left: 0px;
}

.btn_0 {
    top: 50px;
}

.btn_1 {
    top: 150px;
}

.btn_2 {
    top: 250px;
}

.btn_3 {
    top: 350px;
}

@keyframes border {
    0%   {border-right: 2px black solid;}
}
'''