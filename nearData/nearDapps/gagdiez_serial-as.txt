*GitHub Repository "gagdiez/serial-as"*

'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Run tests
        run: yarn test
'''
'''--- README.md ---
# Serial-as

**serial-as** simplifies creating serialized encoders/decoders for the assemblyscript language. Furthermore, it readily implements a [JSON](./json), and a [Borsh](./borsh) (de)serializer.

## Installing and Testing
```bash
yarn install
yarn test
```

## What is a Serializer
A (de)Serialized is an object that encodes/decodes `objects` into a predefined type. For example, the JSON serializer encodes `objects` into `strings`, and decodes JSON-encoded `strings` into `objects`.

## How to create a Serializer
Extend the classes `Serializer` and `Deserealizer` exported by `serial-as` and implement their methods. Then, use your Serializer and Deserealizer to instantiate a `Serial` object. For example, to create a serializer that encodes/decodes objects into encoded `strings` you will write the following code.

```ts
import { Serializer, Deserializer } from "@serial-as/core";

class MySerializer extends Serializer<string>{
  /* implement methods to convert types into string */
}

class MyDeserializer extends Deserializer<string>{
  /* implement methods to parse a string into an object */
}

export class MySerial<string, MySerializer, MyDeserializer> { }
```

In order to implement `MyDeserializer` you will need to implement the abstract methods of the `Deserializer` class. Among others, you must implement 
- `decode_bool():bool`
- `abstract decode_map<K, V>():Map<K, V>`
- `decode_string():string`
- `decode_i32():i32`
- etc.

You can use as examples the [Borsh](./borsh) and [JSON](./json) serializers included in this repository. Simply copy one of the folders, and change the methods implemented on them.

## How to use your (De)Serializer
In order for an object to be serializable you need to decorate it with the `@serializable` tag. After this, the object can be used with any Serial object.

```ts
@serializable
class Pair{
  x: i32 = 0,
  y: i32 = 0
}

let pair:Pair = {x:1, y:2}

// Pair can also be used with your implemented serializer
const myserial:MySerial = new MySerial()

// serialize the object into a string
let serialized:string = myserial.serialize(object)  

// decoded must be the Pair = {x:1, y:2}
let decoded:Pair = myserial.deserialize<Pair>(serialized)
```

Once more, you can use the [Borsh](./borsh) and [JSON](./json) implementation included in this repository as a guide.

## Under the Hood
Under the hood, **serial-as** implements a [transform](https://www.assemblyscript.org/transforms.html) to visit `@serializable` objects and encode/decode their fields. To do so, the transform uses the methods implemented in the Serializer/Deserializer classes.

'''
'''--- as-pect.asconfig.json ---
{
  "targets": {
    "coverage": {
      "lib": ["@as-covers/assembly/index.ts"],
      "transform": ["@as-covers/transform", "@as-pect/transform"]
    },
    "noCoverage": {
      "transform": ["@as-pect/transform"]
    }
  },
  "options": {
    "exportMemory": true,
    "outFile": "output.wasm",
    "textFile": "output.wat",
    "bindings": "raw",
    "exportStart": "_start",
    "exportRuntime": true,
    "use": ["RTRACE=1"],
    "debug": true,
    "exportTable": true
  },
  "extends": "./asconfig.json",
  "entries": ["./node_modules/@as-pect/assembly/assembly/index.ts"]
}
'''
'''--- as-pect.config.js ---
export default {
  /**
   * A set of globs passed to the glob package that qualify typescript files for testing.
   */
  entries: ["./*/assembly/tests/**/*.spec.ts"],
  /**
   * A set of globs passed to the glob package that quality files to be added to each test.
   */
  // include: ["assembly/__tests__/**/*.include.ts"],
  /**
   * A set of regexp that will disclude source files from testing.
   */
  disclude: [/node_modules/],
  /**
   * Add your required AssemblyScript imports here.
   */
  async instantiate(memory, createImports, instantiate, binary) {
    let instance; // Imports can reference this
    const myImports = {
      env: { memory }
      // put your web assembly imports here, and return the module promise
    };
    instance = instantiate(binary, createImports(myImports));
    return instance;
  },
  /** Enable code coverage by uncommenting the following line. */
  // coverage: ["assembly/**/*.ts"],
  /**
   * Specify if the binary wasm file should be written to the file system.
   */
  outputBinary: false,
};

'''
'''--- asconfig.json ---
{
  "options": {
    "runtime": "stub",
    "transform": ["./transform"]
  }
}
'''
'''--- borsh/README.md ---
# Borsh-as

**borsh-as** is an assemblyscript implementation of the [borsh](https://borsh.io) serializer.

## How to use it

Install the package via `yarn add @serial-as/borsh` and add the `--transform @serial-as/transform` flag to your `asc` command.

```ts
import { BorshSerializer, BorshDeserializer } from '@serial-as/borsh'

@serializable
class Pair{
  x: i32 = 0,
  y: i32 = 0
}

let pair: Pair = {x:1, y:2}

// `serialized` is the u8 buffer [0, 0, 0, 1, 0, 0, 0, 2]
let serialized: ArrayBuffer = BorshSerializer.encode(object)  

// `decoded` is the Pair = {x:1, y:2}
let decoded: Pair = BorshDeserializer.decode<Pair>(serialized)  
```

## Limitations

Assemblyscript does not have Enums, nor allows to predefine the length of an array. Because of this, Borsh-as has the following limitations:

- Does **not** deserialize Enums.
- Does **not** deserialize fixed-size arrays.

'''
'''--- borsh/asconfig.json ---
{
  "extends": "@serial-as/core/asconfig.json"
}
'''
'''--- borsh/assembly/buffer.ts ---
export class EncodeBuffer {
  public offset: u32 = 0;
  public buffer_size: u32 = 0;
  public start: usize = heap.alloc(this.buffer_size);

  resize_if_necessary(needed_space: u32): void {
    if (this.buffer_size - this.offset < needed_space) {
      this.buffer_size = max(this.buffer_size * 2, this.buffer_size + needed_space)
      this.start = heap.realloc(this.start, this.buffer_size)
    }
  }

  store<T>(value: T): void {
    this.resize_if_necessary(sizeof<T>())
    store<T>(this.start + this.offset, value)
    this.offset += sizeof<T>()
  }

  get_used_buffer(): ArrayBuffer {
    return changetype<ArrayBuffer>(this.start).slice(0, this.offset)
  }

  store_bytes(src: usize, nBytes: u32): void {
    this.resize_if_necessary(nBytes)
    memory.copy(this.start + this.offset, src, nBytes)
    this.offset += nBytes
  }
}

export class DecodeBuffer {
  public offset: u32 = 0;
  public start: usize;

  constructor(public arrBuffer: ArrayBuffer) {
    this.start = changetype<usize>(arrBuffer)
  }

  consume<T>(): T {
    const off = this.offset
    this.offset += sizeof<T>()
    return load<T>(this.start + off)
  }

  consume_slice(length: u32): ArrayBuffer {
    const off = this.offset
    this.offset += length
    return changetype<ArrayBuffer>(this.start).slice(off, off + length)
  }

  consume_copy(dst: usize, length: u32): void {
    memory.copy(dst, this.start + this.offset, length);
    this.offset += length;
  }
}
'''
'''--- borsh/assembly/deserializer.ts ---
import { Deserializer, allocObj } from "@serial-as/core/assembly";
import { DecodeBuffer } from "./buffer";

export class BorshDeserializer extends Deserializer<ArrayBuffer>{
  private decoBuffer: DecodeBuffer;
  
  constructor(encoded_object: ArrayBuffer) {
    super(encoded_object)
    this.decoBuffer = new DecodeBuffer(encoded_object)
  }
  
  decode_field<T>(_name: string): T {
    return this.decode<T>()
  }
  
  // Bool --
  decode_bool(): bool {
    // little endian
    return this.decoBuffer.consume<bool>()
  }

  // String --
  decode_string(): string {
    const encoded_string = this.decode_arraybuffer();
    const decoded_string: string = String.UTF8.decode(encoded_string)

    // repr(decoded as Vec<u8>) 
    return decoded_string
  }

  // Array --
  decode_array<A extends ArrayLike<any>>(): A {
    // TODO: HANDLE NULL
    const length: u32 = this.decoBuffer.consume<u32>()

    let ret_array: A = instantiate<A>(length)

    //for el in x; repr(el as K)
    for (let i: u32 = 0; i < length; i++) {
      // @ts-ignore
      ret_array[i] = this.decode<valueof<A>>()
    }

    return ret_array
  }

  decode_arraybuffer(): ArrayBuffer {
    const length: u32 = this.decoBuffer.consume<u32>()
    return this.decoBuffer.consume_slice(length);
  }

  decode_arraybuffer_view<A extends ArrayBufferView>(): A {
    const length = this.decoBuffer.consume<u32>();
    let res:A = instantiate<A>(length)
    // @ts-ignore
    this.decoBuffer.consume_copy(res.dataStart, sizeof<valueof<A>>()*length)
    return res
  }

  decode_static_array<T>(): StaticArray<T> {
    const length = this.decoBuffer.consume<u32>();
    const res = new StaticArray<T>(length);
    this.decoBuffer.consume_copy(changetype<usize>(res), sizeof<T>()*length);
    return res;
  }

  // Null --
  decode_nullable<T>(): T | null {
    let option = this.decoBuffer.consume<u8>();
    if (option) {
      return this.decode<NonNullable<T>>()
    }
    return null;
  }

  // Set --
  decode_set<T>(): Set<T> {
    const length: u32 = this.decoBuffer.consume<u32>()

    let ret_set: Set<T> = new Set<T>()

    //for el in x.sorted(); repr(el as S)
    for (let i: u32 = 0; i < length; i++) {
      ret_set.add(this.decode<T>())
    }

    return ret_set
  }

  // Map --
  decode_map<K, V>(): Map<K, V> {
    // TODO: HANDLE NULL
    const length: u32 = this.decoBuffer.consume<u32>()

    let ret_map: Map<K, V> = new Map<K, V>()

    // repr(k as K)
    // repr(v as V)
    for (let i: u32 = 0; i < length; i++) {
      const key = this.decode<K>()
      const value = this.decode<V>()
      ret_map.set(key, value)
    }
    return ret_map
  }

  // Object --
  decode_object<C extends object>(): C {
    let object: C = allocObj<C>()
    object.decode(this)
    return object
  }

  decode_number<T>(): T {
    // little_endian(x)
    return this.decoBuffer.consume<T>()
  }

  // We override decode_number, for which we don't need these
  decode_u8(): u8 { return 0 }
  decode_i8(): i8 { return 0 }
  decode_u16(): u16 { return 0 }
  decode_i16(): i16 { return 0 }
  decode_u32(): u32 { return 0 }
  decode_i32(): i32 { return 0 }
  decode_u64(): u64 { return 0 }
  decode_i64(): i64 { return 0 }
  decode_f32(): f32 { return 0 }
  decode_f64(): f64 { return 0 }

  static decode<T>(a: ArrayBuffer): T {
    return (new BorshDeserializer(a)).decode<T>();
  }
}
'''
'''--- borsh/assembly/index.ts ---
import { Serial } from '@serial-as/core/assembly'

import { BorshSerializer } from './serializer'
import { BorshDeserializer } from './deserializer'

export class Borsh extends Serial<ArrayBuffer, BorshSerializer, BorshDeserializer>{}

export { BorshSerializer, BorshDeserializer };
'''
'''--- borsh/assembly/serializer.ts ---
import { Serializer, isNumber } from "@serial-as/core/assembly";
import { EncodeBuffer } from "./buffer";

export class BorshSerializer extends Serializer<ArrayBuffer> {
  public buffer: EncodeBuffer = new EncodeBuffer();

  get_encoded_object(): ArrayBuffer {
    return this.buffer.get_used_buffer();
  }

  encode_field<T>(name: string, value: T): void {
    this.encode<T>(value);
  }

  // Bool --
  encode_bool(value: bool): void {
    // little endian
    this.buffer.store<bool>(value);
  }

  // String --
  encode_string(value: string): void {
    const utf8 = String.UTF8.encode(value);
    this.buffer.store<u32>(utf8.byteLength);
    this.buffer.store_bytes(changetype<usize>(utf8), utf8.byteLength);
  }

  // Null -- "Option"
  encode_nullable<T>(t: T): void {
    /*if x.is_some() {
    repr(1 as u8)
    repr(x.unwrap() as ident)
  } else {
    repr(0 as u8)
  }  */
    if (t != null) {
      this.buffer.store<u8>(1);
      this.encode<NonNullable<T>>(<NonNullable<T>>t);
    } else {
      this.buffer.store<u8>(0);
    }
  }

  // Array --
  encode_array<T extends ArrayLike<any>>(value: T): void {
    // repr(value.len() as u32)
    this.buffer.store<u32>(value.length);

    //for el in x; repr(el as K)
    for (let i = 0; i < value.length; i++) {
      // @ts-ignore
      this.encode<valueof<T>>(value[i]);
    }
  }

  encode_arraybuffer(value: ArrayBuffer): void {
    this.buffer.store<u32>(value.byteLength)
    this.buffer.store_bytes(changetype<usize>(value), value.byteLength)
  }

  encode_arraybuffer_view<T extends ArrayBufferView>(value: T): void {
    //@ts-ignore
    this.buffer.store<u32>(value.byteLength / sizeof<valueof<T>>());
    this.buffer.store_bytes(value.dataStart, value.byteLength);
  }

  encode_static_array<T>(value: StaticArray<T>): void {
    if (isNumber<T>()) {
      this.buffer.store<u32>(value.length);
      this.buffer.store_bytes(
        changetype<usize>(value),
        value.length * sizeof<T>()
      );
    } else {
      this.encode_array(value);
    }
  }

  // Set --
  encode_set<T>(set: Set<T>): void {
    let values: Array<T> = set.values().sort();

    // repr(value.len() as u32)
    this.buffer.store<u32>(values.length);

    //for el in x.sorted(); repr(el as S)
    for (let i: i32 = 0; i < values.length; i++) {
      this.encode<T>(values[i]);
    }
  }

  // Map --
  encode_map<K, V>(map: Map<K, V>): void {
    let keys = map.keys().sort();

    // repr(keys.len() as u32)
    this.buffer.store<u32>(keys.length);

    // repr(k as K)
    // repr(v as V)
    for (let i = 0; i < keys.length; i++) {
      this.encode<K>(keys[i]);
      this.encode<V>(map.get(keys[i]));
    }
  }

  // Object --
  encode_object<C>(object: C): void {
    // @ts-ignore
    object.encode(this);
  }

  encode_number<T extends number>(value: T): void {
    if (isFloat<T>()) {
      assert(
        // Type information is passed nicely here
        !isNaN(value),
        "For portability reasons we do not allow f32s to be encoded as Nan"
      );
    }
    // little_endian(x)
    this.buffer.store<T>(value);
  }

  // We override encode_number, for which we don't need these
  encode_u8(value: u8): void { }
  encode_i8(value: i8): void { }
  encode_u16(value: u16): void { }
  encode_i16(value: i16): void { }
  encode_u32(value: u32): void { }
  encode_i32(value: i32): void { }
  encode_u64(value: u64): void { }
  encode_i64(value: i64): void { }
  encode_f32(value: f32): void { }
  encode_f64(value: f64): void { }

  // We override encode_array_like, for which we don't need these
  encode_u8array(value: Uint8Array): void { }
  encode_i8array(value: Int8Array): void { }
  encode_u16array(value: Uint16Array): void { }
  encode_i16array(value: Int16Array): void { }
  encode_u32array(value: Uint32Array): void { }
  encode_i32array(value: Int32Array): void { }
  encode_u64array(value: Uint64Array): void { }
  encode_i64array(value: Int64Array): void { }

  static encode<T>(a: T): ArrayBuffer {
    const encoder = new BorshSerializer();
    encoder.encode<T>(a);
    return encoder.get_encoded_object();
  }
}

'''
'''--- borsh/assembly/tests/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- borsh/assembly/tests/bencoded.spec.ts ---
import { BorshDeserializer, BorshSerializer } from '@serial-as/borsh/assembly'
import { BigObj, MapSet, MixtureOne, Numbers, aString, aBoolean, Arrays, ArrayViews, Nullables, MixtureTwo, Nested, Extends, MapNullValues, init_numbers, init_arrays } from '@serial-as/tests/assembly';
import { u128 } from 'as-bignum/assembly';

// @serializable
// class FooBar {
//   foo: i32 = 0;
//   bar: u32 = 1;
//   u64Val: u64 = 4294967297;
//   i64Val: i64 = -64;
//   flag: bool;
//   baz: string = "";
//   uint8array: Uint8Array = new Uint8Array(2);
//   arr: Array<Array<string>> = [];
//   u32Arr: u32[] = [];
//   i32Arr: i32[] = [];
//   u128Val: u128 = u128.Zero;
//   uint8arrays: Array<Uint8Array> = [];
//   u64Arr: u64[] = [];
// }

function initMixtureTwo(f: MixtureTwo): void {
  f.foo = 321;
  f.bar = 123;
  f.flag = true;
  f.baz = "testing";
  f.uint8array[0] = 1
  f.uint8array[1] = 2
  f.arr = [["testing"], ["testing"]];
  f.u32Arr = [42, 11]
  f.u128Val = u128.from(128);
  f.uint8arrays = [f.uint8array, f.uint8array]
  f.u64Arr = [10000000000, 100000000000];
}

function u8toArrayBuffer(arr: u8[]): ArrayBuffer {
  // Create expected array buffer
  const buffer: ArrayBuffer = new ArrayBuffer(arr.length)

  for (let i: i32 = 0; i < arr.length; i++) {
    store<u8>(changetype<usize>(buffer) + i * sizeof<u8>(), arr[i])
  }
  return buffer
}

function check_encode<T>(object: T, expected: ArrayBuffer): void {
  // Checks that encoding an object returns the expected encoding
  //const borsh:Borsh = new Borsh()
  let res: ArrayBuffer = BorshSerializer.encode(object)

  expect(res).toStrictEqual(expected)
}

function check_decode<T>(encoded: ArrayBuffer, original: T): void {
  // Checks that an encoding returns the expected object
  //const borsh:Borsh = new Borsh()
  let deco: T = BorshDeserializer.decode<T>(encoded)
  expect(deco).toStrictEqual(original)
}

function check_single_number<T = number>(N: T): void {
  let expected: ArrayBuffer = new ArrayBuffer(sizeof<T>())
  store<T>(changetype<usize>(expected), N)

  check_encode<T>(N, expected)
  check_decode<T>(expected, N)
}

describe("BorshEncoder Serializing Types", () => {
  it("should encode/decode single numbers", () => {
    check_single_number<u8>(100)
    check_single_number<u16>(101)
    check_single_number<u32>(102)
    check_single_number<u64>(103)
    check_single_number<i8>(-100)
    check_single_number<i16>(-101)
    check_single_number<i32>(-102)
    check_single_number<i64>(-103)
  });

  it("should encode/decode floats", () => {
    check_single_number<f64>(7.23)
    check_single_number<f64>(10e2)
    check_single_number<f64>(10E2)
  })

  it("should encode/decode floats", () => {
    let num: u128 = u128.from("200")
    let expected: ArrayBuffer = u8toArrayBuffer([200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    check_encode(num, expected)
    check_decode(expected, num)
  })

  it("should encode/decode just bools", () => {
    const nums: bool = true;
    const expected: ArrayBuffer = u8toArrayBuffer([1]);

    check_encode(nums, expected)
    check_decode(expected, nums)
  });

  it("should encode/decode just arrays", () => {
    const nums: bool[] = [true, false];
    const expected: ArrayBuffer = u8toArrayBuffer([2, 0, 0, 0, 1, 0])

    check_encode(nums, expected)
    check_decode(expected, nums)
  });

  it("should encode/decode just arraybuffers", () => {
    const arrbuff:ArrayBuffer = new ArrayBuffer(2)
    const expected: ArrayBuffer = u8toArrayBuffer([2, 0, 0, 0, 0, 0])

    check_encode(arrbuff, expected)
    check_decode(expected, arrbuff)
  });
})

describe("Borsh serialize objects", () => {
  it("should encode/decode numbers", () => {
    const nums: Numbers = new Numbers()
    init_numbers(nums)
    const expected: ArrayBuffer = u8toArrayBuffer([1, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 254, 255, 253, 255, 255, 255, 252, 255, 255, 255, 255, 255, 255, 255, 0, 0, 192, 64, 102, 102, 102, 102, 102, 102, 28, 64])

    check_encode<Numbers>(nums, expected)
    check_decode<Numbers>(expected, nums)
  });
  
  it("should encode/decode strings", () => {
    const str: aString = { str: "h\"i" }
    const expected: ArrayBuffer = u8toArrayBuffer([3, 0, 0, 0, 104, 34, 105])

    check_encode<aString>(str, expected)
    check_decode<aString>(expected, str)
  });

  it("should encode/decode booleans", () => {
    const bool: aBoolean = new aBoolean()
    const expected: ArrayBuffer = u8toArrayBuffer([1])

    check_encode<aBoolean>(bool, expected)
    check_decode<aBoolean>(expected, bool)
  });
  
  it("should encode Arrays", () => {
    const arrays: Arrays = new Arrays()
    init_arrays(arrays)
    const expected: ArrayBuffer = u8toArrayBuffer([2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 3, 0, 4, 0, 2, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 255, 254, 2, 0, 0, 0, 253, 255, 252, 255, 2, 0, 0, 0, 251, 255, 255, 255, 250, 255, 255, 255, 2, 0, 0, 0, 249, 255, 255, 255, 255, 255, 255, 255, 248, 255, 255, 255, 255, 255, 255, 255, 2, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 64, 2, 0, 0, 0, 205, 204, 204, 204, 204, 204, 8, 64, 205, 204, 204, 204, 204, 204, 16, 64, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0])

    check_encode<Arrays>(arrays, expected)
    check_decode<Arrays>(expected, arrays)
  });
  
  it("should encode ArrayViews", () => {
    const arrays: ArrayViews = new ArrayViews()

    const expected: ArrayBuffer = u8toArrayBuffer([2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    check_encode<ArrayViews>(arrays, expected)
    check_decode<ArrayViews>(expected, arrays)
  });
  
  it("should encode/decode empty Sets and Maps", () => {
    const map_set: MapSet = new MapSet()
    const expected: ArrayBuffer = u8toArrayBuffer([0, 0, 0, 0, 0, 0, 0, 0])

    check_encode<MapSet>(map_set, expected)
    check_decode<MapSet>(expected, map_set)
  });
  
  it("should encode/decode non-empty Sets and Maps", () => {
    const map_set: MapSet = new MapSet()
    map_set.map.set("testing", 0)
    map_set.set.add(0)
    map_set.set.add(1)

    // computed manually
    // map:Map<string, u32> = ('testing', 0) -> sizeof [1, 0, 0, 0] -> 'testing' [7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103] -> 0 = [0, 0, 0, 0] 
    // set:Set<u32> = {0, 1} -> sizeof [2, 0, 0, 0] + [0, 0, 0, 0] + [1, 0, 0, 0]
    const expected: ArrayBuffer = u8toArrayBuffer([1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0])

    check_encode<MapSet>(map_set, expected)
    check_decode<MapSet>(expected, map_set)
  });

  it("should encode/decode nullable", () => {
    const nullables: Nullables = new Nullables()
    const expected: ArrayBuffer = u8toArrayBuffer([0, 0, 0, 0, 0, 0])

    check_encode<Nullables>(nullables, expected)
    check_decode<Nullables>(expected, nullables)
  });

  it("should encode/decode defined nullable", () => {
    let nullables: Nullables = new Nullables()
    nullables.u32Arr_null = [1]
    const expected: ArrayBuffer = u8toArrayBuffer([1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])

    check_encode<Nullables>(nullables, expected)
    check_decode<Nullables>(expected, nullables)
  });

  it("should encode/decode simple Mixtures", () => {
    const mix: MixtureOne = new MixtureOne()

    // computed manually
    // i32 = 2 -> [2, 0, 0, 0]
    // str = testing -> [7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103]
    // arr = [0,1] -> [2, 0, 0, 0] + [0, 0, 0, 0] + [1, 0, 0, 0]
    // arpa = {[0, 1], [2, 3]} = [2, 0, 0, 0] + [0, 0, 0, 0, 1, 0, 0, 0] + [2, 0, 0, 0, 3, 0, 0, 0]
    // f32 = 0 -> [0, 0, 0, 0]
    const expected: ArrayBuffer = u8toArrayBuffer([2, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0])

    check_encode<MixtureOne>(mix, expected)
    check_decode<MixtureOne>(expected, mix)
  });

  it("should encode/decode complex Mixtures", () => {
    const mix: MixtureTwo = new MixtureTwo();
    initMixtureTwo(mix);

    // computed by hand                                   i32,          u32,                  u64val,                    u64,                                 i64val, B,                                        string,       Uint8Array,
    const expected: ArrayBuffer = u8toArrayBuffer([65, 1, 0, 0, 123, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 255, 255, 255, 255, 255, 255, 255, 1, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 1, 2,
      // Array<Array<string>>
      2, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103,
      //                            u32Arr,     i32Arr,                                             u128,
      2, 0, 0, 0, 42, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      // Array<Uint8Array>,                                                                                      // u64Arr
      2, 0, 0, 0, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 228, 11, 84, 2, 0, 0, 0, 0, 232, 118, 72, 23, 0, 0, 0])

    check_encode<MixtureTwo>(mix, expected)
    check_decode<MixtureTwo>(expected, mix)
  });

  it("should encode/decode nested JSONEncoder", () => {
    const nested: Nested = new Nested();
    initMixtureTwo(nested.f);

    // Same as previous test
    const expected: ArrayBuffer = u8toArrayBuffer([65, 1, 0, 0, 123, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 255, 255, 255, 255, 255, 255, 255, 1, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 42, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 228, 11, 84, 2, 0, 0, 0, 0, 232, 118, 72, 23, 0, 0, 0])

    check_encode<Nested>(nested, expected)
    check_decode<Nested>(expected, nested)
  });

  it("should encode/decode JSONEncoder with inheritence", () => {
    const ext: Extends = new Extends();
    initMixtureTwo(ext);

    // As previous test + [true] -> [1, 0, 0, 0, 1]
    const expected: ArrayBuffer = u8toArrayBuffer([65, 1, 0, 0, 123, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 255, 255, 255, 255, 255, 255, 255, 1, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 1, 0, 0, 0, 7, 0, 0, 0, 116, 101, 115, 116, 105, 110, 103, 2, 0, 0, 0, 42, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 228, 11, 84, 2, 0, 0, 0, 0, 232, 118, 72, 23, 0, 0, 0, 1, 0, 0, 0, 1])

    check_encode<Extends>(ext, expected)
    check_decode<Extends>(expected, ext)
  });

  it("should encode/decode Maps with null values", () => {
    const map: MapNullValues = new MapNullValues();
    map.inner.set(1, null)

    const expected: ArrayBuffer = u8toArrayBuffer([1, 0, 0, 0, 1, 0, 0, 0, 0])

    check_encode<MapNullValues>(map, expected)
    check_decode<MapNullValues>(expected, map)
  });
  
  it("should encode/decode Maps with non-null values", () => {
    const map: MapNullValues = new MapNullValues();
    map.inner.set(1, "h\"i")

    const expected: ArrayBuffer = u8toArrayBuffer([1, 0, 0, 0, 1, 0, 0, 0, 1, 3, 0, 0, 0, 104, 34, 105])

    check_encode<MapNullValues>(map, expected)
    check_decode<MapNullValues>(expected, map)
  });

  it("should handle big objects", () => {
    const bigObj = new BigObj();
    let expected: u8[] = []

    for (let i: i32 = 0; i < 16; i++) { expected.push(<u8>255) }
    expected = expected.concat([232, 3, 0, 0])
    for (let i: i32 = 0; i < 1000; i++) { expected.push(<u8>i * 2) }

    let expected_arr: ArrayBuffer = u8toArrayBuffer(expected)

    check_encode<BigObj>(bigObj, expected_arr)
    check_decode<BigObj>(expected_arr, bigObj)
  })
});
'''
'''--- borsh/package.json ---
{
  "name": "@serial-as/borsh",
  "version": "2.0.0",
  "description": "Borsh Serializer for Assemblyscript",
  "main": "index.js",
  "types": "assembly/index.ts",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": "borsh"
  },
  "author": "Guillermo Gallardo and Willem Wyndham",
  "license": "MIT",
  "private": false,
  "dependencies": {
    "@serial-as/core": "^2.0.0"
  },
  "devDependencies": {
    "@serial-as/tests": "^2.0.0"
  }
}

'''
'''--- core/asconfig.json ---
{
  "options": {
    "runtime": "stub"
  }
}
'''
'''--- core/assembly/as_types.d.ts ---
interface Encoder<T> { }
interface Decoder<T> { }
interface Object {
  encode<T>(encoder: Encoder<T>): T;
  decode<From>(decoder: Decoder<From>): this;
}

/**
 * 
 * Macro to add `encode` method to class
 */
declare function serializable(a: any): any;
'''
'''--- core/assembly/deserializer.ts ---
import { u128 } from "as-bignum/assembly";

@global
export abstract class Deserializer<I> {

  constructor(protected encoded_object: I) { }

  init(encoded_object: I): this {
    this.encoded_object = encoded_object;
    return this;
  }

  // Decode Field
  abstract decode_field<T>(name: string): T

  // Boolean
  abstract decode_bool(): bool

  // Map --
  abstract decode_map<K, V>(): Map<K, V>

  // Null --
  abstract decode_nullable<T>(): T | null

  // Object
  abstract decode_object<C extends object>(): C

  // String --
  abstract decode_string(): string

  // Set --
  abstract decode_set<T>(): Set<T>

  // Array --
  abstract decode_array<A extends ArrayLike<any>>(): A;
  abstract decode_arraybuffer(): ArrayBuffer
  abstract decode_arraybuffer_view<A extends ArrayBufferView>(): A
  abstract decode_static_array<T>(): StaticArray<T>

  // Number --
  abstract decode_u8(): u8
  abstract decode_i8(): i8
  abstract decode_u16(): u16
  abstract decode_i16(): i16
  abstract decode_u32(): u32
  abstract decode_i32(): i32
  abstract decode_u64(): u64
  abstract decode_i64(): i64
  abstract decode_f32(): f32
  abstract decode_f64(): f64

  decode_number<N = number>(): N {
    let test: N

    // @ts-ignore
    if (test instanceof u8) { return this.decode_u8(); }
    // @ts-ignore
    if (test instanceof i8) { return this.decode_i8(); }
    // @ts-ignore
    if (test instanceof u16) { return this.decode_u16(); }
    // @ts-ignore
    if (test instanceof i16) { return this.decode_i16(); }
    // @ts-ignore
    if (test instanceof u32) { return this.decode_u32(); }
    // @ts-ignore
    if (test instanceof i32) { return this.decode_i32(); }
    // @ts-ignore
    if (test instanceof u64) { return this.decode_u64(); }
    // @ts-ignore
    if (test instanceof i64) { return this.decode_i64(); }
    // @ts-ignore
    if (test instanceof f32) { return this.decode_f32(); }
    // @ts-ignore
    return this.decode_f64();
  }

  // decode --
  decode<T>(): T {

    // @ts-ignore
    if (isBoolean<T>()) { return this.decode_bool(); }

    // @ts-ignore
    if (isInteger<T>() || isFloat<T>()) { return this.decode_number<T>(); }

    if (isNullable<T>()) { return <T>this.decode_nullable<T>() }

    // @ts-ignore
    if (isString<T>()) { return this.decode_string(); }

    let value: T

    // @ts-ignore
    if (isDefined(value.decode)) { return this.decode_object<T>(); }

    // @ts-ignore
    if (value instanceof ArrayBuffer) { return this.decode_arraybuffer(); }    

    // @ts-ignore
    if (value instanceof ArrayBufferView) { return this.decode_arraybuffer_view<T>(); }

    // @ts-ignore
    if (value instanceof StaticArray) { return this.decode_static_array<valueof<T>>(); }
    
    // @ts-ignore
    if (isArrayLike<T>()) { return this.decode_array<T>(); }

    // @ts-ignore
    if (value instanceof Set) { return this.decode_set<indexof<T>>(); }

    // @ts-ignore
    if (value instanceof Map) { return this.decode_map<indexof<T>, valueof<T>>(); }

    // @ts-ignore
    return this.decode_object<T>();
  }

}
'''
'''--- core/assembly/index.ts ---
import { Serializer } from "./serializer";
import { Deserializer } from "./deserializer";

export * from "./utils"
export { Serializer, Deserializer }

export class Serial<__R, E extends Serializer<__R>, D extends Deserializer<__R>> {

  encode<O>(value: O): __R {
    let encoder: E = instantiate<E>();
    encoder.encode(value)
    return encoder.get_encoded_object();
  }

  decode<O>(t: __R): O {
    const decoder: D = instantiate<D>(t)
    return decoder.decode<O>()
  }
}
'''
'''--- core/assembly/serializer.ts ---
import { u128 } from "as-bignum/assembly";

@global
export abstract class Serializer<R>{

  abstract get_encoded_object(): R

  // Boolean
  abstract encode_bool(value: bool): void

  // Map --
  abstract encode_map<K, V>(value: Map<K, V>): void

  // Null --
  abstract encode_nullable<V>(value: V): void

  // Object --
  abstract encode_object<C extends object>(value: C): void
  abstract encode_field<T>(name: string, value: T): void

  // String --
  abstract encode_string(value: string): void

  // Set --
  abstract encode_set<T>(value: Set<T>): void

  // Arraylike --
  abstract encode_array<T extends ArrayLike<any>>(value: T): void;
  abstract encode_arraybuffer(value: ArrayBuffer): void
  abstract encode_arraybuffer_view<T extends ArrayBufferView>(value: T): void
  abstract encode_static_array<T>(value: StaticArray<T>): void

  // Number --
  abstract encode_u8(value: u8): void
  abstract encode_i8(value: i8): void
  abstract encode_u16(value: u16): void
  abstract encode_i16(value: i16): void
  abstract encode_u32(value: u32): void
  abstract encode_i32(value: i32): void
  abstract encode_u64(value: u64): void
  abstract encode_i64(value: i64): void
  abstract encode_f32(value: f32): void
  abstract encode_f64(value: f64): void

  encode_number<N extends number>(value: N): void {
    // @ts-ignore
    if (value instanceof u8) { this.encode_u8(value); return }
    // @ts-ignore
    if (value instanceof i8) { this.encode_i8(value); return }
    // @ts-ignore
    if (value instanceof u16) { this.encode_u16(value); return }
    // @ts-ignore
    if (value instanceof i16) { this.encode_i16(value); return }
    // @ts-ignore
    if (value instanceof u32) { this.encode_u32(value); return }
    // @ts-ignore
    if (value instanceof i32) { this.encode_i32(value); return }
    // @ts-ignore
    if (value instanceof u64) { this.encode_u64(value); return }
    // @ts-ignore
    if (value instanceof i64) { this.encode_i64(value); return }
    // @ts-ignore
    if (value instanceof f32) { this.encode_f32(value); return }
    // @ts-ignore
    if (value instanceof f64) { this.encode_f64(value); return }
  }

  // Encode --
  encode<V>(value: V): void {
    // @ts-ignore
    if (isBoolean<V>()) { this.encode_bool(value); return }

    // @ts-ignore
    if (isInteger<V>() || isFloat<V>()) { this.encode_number<V>(value); return }

    if (isNullable<V>()) { this.encode_nullable<V>(value); return }

    // @ts-ignore
    if (isString<V>()) { this.encode_string(value); return }

    // @ts-ignore
    if (isDefined(value.encode)){ this.encode_object(value); return }

    // @ts-ignore
    if (value instanceof ArrayBuffer) { this.encode_arraybuffer(value); return; }

    // @ts-ignore
    if (value instanceof ArrayBufferView) { this.encode_arraybuffer_view<V>(value); return; }

    // @ts-ignore
    if (value instanceof StaticArray) { this.encode_static_array<valueof<V>>(value); return; }

    // @ts-ignore
    if (isArrayLike<V>(value)) { this.encode_array<V>(value); return }

    // @ts-ignore
    if (value instanceof Set) { this.encode_set<indexof<V>>(value); return }

    // @ts-ignore
    if (value instanceof Map) { this.encode_map<indexof<V>, valueof<V>>(value); return }
    
    ERROR(`Failed to encode ${value} with type ${nameof<V>()}.
           Perhaps you're missing an 'encode' method on your class`);
  }
}
'''
'''--- core/assembly/utils.ts ---
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from "util/error";

//@ts-ignore
@inline
export function isNumber<V>(): boolean {
  return isInteger<V>() || isFloat<V>()
}

export function allocObj<T>(): T {
  return changetype<T>(__new(offsetof<T>(), idof<T>()));
}

// From:
// https://github.com/AssemblyScript/assemblyscript/blob/a7f7226dabd0d33df440ae9057fa229b6174eb7a/std/assembly/typedarray.ts#L1817
// @ts-ignore: decorator
@inline
export function WRAP<TArray extends ArrayBufferView, T>(
  buffer: ArrayBuffer,
  // size: u32,
  // align: i32,
  byteOffset: i32 = 0,
  length: i32 = -1
): TArray {
  var byteLength: i32;
  var bufferByteLength = buffer.byteLength;
  const mask: u32 = sizeof<T>() - 1;
  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {
    throw new RangeError(E_INDEXOUTOFRANGE);
  }
  if (length < 0) {
    if (length == -1) {
      if (bufferByteLength & mask) {
        throw new RangeError(E_INVALIDLENGTH);
      }
      byteLength = bufferByteLength - byteOffset;
    } else {
      throw new RangeError(E_INVALIDLENGTH);
    }
  } else {
    byteLength = length << alignof<T>();
    if (byteOffset + byteLength > bufferByteLength) {
      throw new RangeError(E_INVALIDLENGTH);
    }
  }
  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), changetype<usize>(buffer), false);
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>("dataStart"));
  return out;
}

//@ts-ignore
@inline
@global
export function defaultValue<T>(): T {
  //@ts-ignore
  if (isInteger<T>() || isFloat<T>()) return <T>0;
  //@ts-ignore
  if (isString<T>()) return "";
  return changetype<T>(0);
}

export function isNull<T>(t: T): boolean {
  if (!isNullable<T>()) return false;
  return changetype<usize>(t) == 0;
}
'''
'''--- core/package.json ---
{
  "name": "@serial-as/core",
  "version": "2.0.0",
  "description": "Serialization for Assemblyscript",
  "main": "dist/index.js",
  "types": "assembly/index.ts",
  "author": "Guillermo Gallardo and Willem Wyndham",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": "core"
  },
  "dependencies": {
    "@serial-as/transform": "^2.0.0",
    "as-bignum": "^0.2.17"
  }
}

'''
'''--- jest.config.js ---
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  testMatch: ["**/*.spec.ts"],
  testPathIgnorePatterns: ["/assembly/", "/node_modules/"],
};

'''
'''--- json/README.md ---
# JSON-as

**json-as** is an assemblyscript implementation of the [JSON](https://json.org) serializer.

## How to use it

Install the package via `yarn add @serial-as/json` and add the `--transform @serial-as/transform` flag to your `asc` command.

```ts
import { stringify, parse } from '@serial-as/json'

@serializable
class Pair{
  x: i32 = 0
  y: i32 = 0
}

let pair:Pair = {x:1, y:2}

// `serialized` is the string "{"x":1,"y":2}"
let serialized: string = stringify(object)  

// `decoded` is the Pair = {x:1, y:2}
let decoded: Pair = parse<Pair>(serialized)  
```

'''
'''--- json/asconfig.json ---
{
  "extends": "@serial-as/core/asconfig.json"
}
'''
'''--- json/assembly/deserializer.ts ---
import { Deserializer, allocObj, WRAP, defaultValue } from "@serial-as/core/assembly";
import { u128, u128Safe } from "as-bignum/assembly";
import * as base64 from "as-base64/assembly";
import { JSON } from "assemblyscript-json/assembly";

export class ValueDeserializer extends Deserializer<JSON.Value>{
  valStack: JSON.Value[] = [];

  constructor(val: JSON.Value) {
    super(val);
    this.pushVal(val);
  }

  pushVal(obj: JSON.Value): void { 
    this.valStack.push(obj);
  }

  popVal(): JSON.Value {
    return this.valStack.pop();
  }

  get currentVal(): JSON.Value {
    return this.valStack[this.valStack.length - 1];
  }

  get currentObj(): JSON.Obj {
    assert(this.currentVal.isObj, `Expected JSON.Obj but found ${this.currentVal.stringify()}`);
    return <JSON.Obj> this.currentVal;
  }

  get currentArr(): JSON.Arr {
    assert(this.currentVal.isArr, `Expected JSON.Arr but found ${this.currentVal.stringify()}`);
    return (<JSON.Arr>this.currentVal);
  }

  decode_field<T>(name: string): T {
    // "name":value,
    const obj = this.currentObj;
    if (!obj.has(name)) { return defaultValue<T>(); }
    this.pushVal(obj.get(name)!);
    const res = this.decode<T>();
    this.popVal();
    return res;
  }

  // Bool --
  decode_bool(): bool {
    assert(this.currentVal.isBool, `Expected JSON.Bool but found ${this.currentVal.stringify()}`);
    return (<JSON.Bool>this.currentVal).valueOf();
  }

  // String --
  decode_string(): string {
    assert(this.currentVal.isString, `Expected JSON.Str but found ${this.currentVal.stringify()}`);
    return (<JSON.Str>this.currentVal).valueOf();
  }

  // Array --
  decode_array<A extends ArrayLike<any>>(): A {
    const arr = this.currentArr.valueOf();
    let ret:A = instantiate<A>(arr.length);
    for(let i:i32 = 0; i < arr.length; i++){
      this.pushVal(arr[i]);
      // @ts-ignore
      ret[i] = this.decode<valueof<A>>();
      this.popVal();
    }
    return ret
  }

  decode_array_to_type<A>(): A {
    // @ts-ignore
    let decoded:Array<valueof<A>> = this.decode_array<Array<valueof<A>>>()

    let ret:A = instantiate<A>(decoded.length)

    for(let i:i32 = 0; i < decoded.length; i++){
      // @ts-ignore
      ret[i] = decoded[i]
    }

    return ret
  }

  decode_arraybuffer_view<A extends ArrayBufferView>(): A {
    let ret:A

    // @ts-ignore
    if (ret instanceof Uint8Array) {
      let u8arr = this.decode_string();
      return changetype<A>(base64.decode(u8arr))
    }
    // @ts-ignore
    return WRAP<A, valueof<A>>(this.decode_arraybuffer_view<Uint8Array>().buffer);
  }

  decode_static_array<T>():StaticArray<T>{
    return this.decode_array_to_type<StaticArray<T>>()
  }

  decode_arraybuffer(): ArrayBuffer{
    return this.decode_arraybuffer_view<Uint8Array>().buffer
  }

  // Null --
  decode_nullable<T>(): T | null {
    if (this.currentVal.isNull) {
      return null
    }
    return this.decode<NonNullable<T>>()
  }

  // Set --
  decode_set<T>(): Set<T> {
    const arr = this.decode_array<T[]>();
    const ret_set = new Set<T>();
    for (let i = 0; i < arr.length; i++) {
      ret_set.add(arr[i]);
    }
    return ret_set
  }

  // Map --
  decode_map<K, V>(): Map<K, V> {
    const obj = this.currentObj;
    const keys = obj.keys;
    const ret_map = new Map<K, V>();
    for (let i = 0; i < keys.length; i++) {
      const name = keys[i];
      const encodedName = isString<K>() ? `"${name}"` : name;
      const key = ValueDeserializer.decode<K>(encodedName);
      const val = obj.get(name) as JSON.Value;
      this.pushVal(val);
      // @ts-ignore
      ret_map.set(key, this.decode<V>());
      this.popVal();
    }
    
    return ret_map
  }

  // Object --
  decode_object<C extends object>(): C {
    let object: C;
    object = allocObj<C>();
    if (object instanceof u128 || object instanceof u128Safe) {
      const obj = u128.from(this.decode_string());
      object.lo = obj.lo;
      object.hi = obj.hi;
    } else {
      object.decode(this);
    }
    return object;
  }

  decode_int<T extends number>(): T {
    assert(this.currentVal.isInteger, `Expected JSON.Integer but found ${this.currentVal.stringify()}`);
    return <T>(<JSON.Integer>this.currentVal).valueOf();
  }

  decode_long<T extends number>(): T {
    let num: string = this.decode<string>()
    return <T>(isSigned<T>() ? I64.parseInt(num) : U64.parseInt(num));
  }

  decode_float<T extends number>(): T {
    assert(this.currentVal.isFloat, `Expected JSON.Float but found ${this.currentVal.stringify()}`);
    return <T>(<JSON.Float>this.currentVal).valueOf();
  }

  // We override decode_number, for which we don't need these
  decode_u8(): u8 {   return this.decode_int<u8>() }
  decode_i8(): i8 {   return this.decode_int<i8>() }
  decode_u16(): u16 { return this.decode_int<u16>() }
  decode_i16(): i16 { return this.decode_int<i16>() }
  decode_u32(): u32 { return this.decode_int<u32>() }
  decode_i32(): i32 { return this.decode_int<i32>() }
  decode_u64(): u64 { return this.decode_long<u64>() }
  decode_i64(): i64 { return this.decode_long<i64>() }
  decode_f32(): f32 { return this.decode_float<f32>() }
  decode_f64(): f64 { return this.decode_float<f64>() }

  /**
   * 
   * @param s string or JSON.Value
   * @returns T
   */
  static decode<T, From = string>(s: From): T {
    let val: JSON.Value = JSON.Value.Null();
    if (s instanceof JSON.Value) {
      val = s;
    } else if (isString<From>()) {
      val = JSON.parse(s);
    } else {
      ERROR("ValueDeserializer can only decode `string` and `JSON` Values.")
    }

    const decoder = new ValueDeserializer(val);
    return decoder.decode<T>();
  }
}
'''
'''--- json/assembly/index.ts ---
import { Serial } from '@serial-as/core/assembly';
import { ValueSerializer } from './serializer'
import { ValueDeserializer } from './deserializer'

import { JSON } from "assemblyscript-json/assembly";

/*
 * @param s string or JSON.Value
 * @returns 
 */
export function parse<T, From = string>(s: From): T {
    return ValueDeserializer.decode<T, From>(s);
  }

export function stringify<T>(s: T): string {
    return ValueSerializer.encode(s).stringify();
  }

export class JSONValueSerializer extends Serial <JSON.Value, ValueSerializer, ValueDeserializer> {}
'''
'''--- json/assembly/serializer.ts ---
import { Serializer } from "@serial-as/core/assembly"
import { u128, u128Safe } from "as-bignum/assembly";
import * as base64 from "as-base64/assembly";
import { JSON } from "assemblyscript-json/assembly";

function isNull<T>(t: T): boolean {
  if (!isNullable<T>()) return false;
  return changetype<usize>(t) == 0;
}

export class ValueSerializer extends Serializer<JSON.Value> {
  valueStack: JSON.Value[] = [];
  public starting_object: bool = true;
  public inner_encode: string[] = [];

  peek(): JSON.Value {
    return this.valueStack[this.valueStack.length - 1];
  }

  push(v: JSON.Value): void { this.valueStack.push(v); }

  encodeAndPop<T>(t: T): JSON.Value {
    this.encode<T>(t);
    return this.valueStack.pop();
  }

  get_encoded_object(): JSON.Value {
    assert(this.valueStack.length == 1);
    return this.valueStack.pop();
  }

  encode_field<K>(name: string, value: K): void {
    const obj = this.peek() as JSON.Obj;
    obj.set(name, this.encodeAndPop<K>(value));
  }

  // Bool --
  encode_bool(value: bool): void {
    this.push(JSON.Value.Bool(value));
  }

  // String --
  encode_string(value: string): void {
    this.push(JSON.Value.String(value));
  }

  // Array --
  encode_array<K extends ArrayLike<any>>(value: K): void {
    const arr = JSON.Value.Array();
    for (let i = 0; i < value.length; i++) {
      // @ts-ignore
      arr.push(this.encodeAndPop<valueof<K>>(value[i]));
    }
    this.push(arr);
  } 

  encode_arraybuffer(value:ArrayBuffer): void {
    this.encode_arraybuffer_view<Uint8Array>(Uint8Array.wrap(value))   
  }

  encode_arraybuffer_view<T extends ArrayBufferView>(value:T): void {
    let arr: Uint8Array;
    if (value instanceof Uint8Array) {
      arr = value;
    }else{
      arr = Uint8Array.wrap(value.buffer);
    }    
    this.encode_string(base64.encode(arr));
  }

  encode_static_array<T>(value:StaticArray<T>): void {
    this.encode_array<StaticArray<T>>(value);
  }

  // Null --
  encode_nullable<T>(t: T): void {
    if (isNull(t)) {
      this.push(JSON.Value.Null());
    } else {
      // @ts-ignore
      this.encode<NonNullable<T>>(<NonNullable<T>>t);
    }
  }

  // Set --
  encode_set<T>(value: Set<T>): void {
    let values = value.values();
    this.encode_array(values);
  }

  // Map --
  encode_map<K, V>(value: Map<K, V>): void {

    this.push(JSON.Value.Object());
    let keys = value.keys();
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = value.get(key);
      // @ts-ignore
      this.encode_field<V>(key.toString(), val);
    }
  }

  // Object --
  encode_object<C extends object>(value: C): void {
    if (value instanceof u128 || value instanceof u128Safe) {
      this.encode_string(value.toString());
      return;
    }
    this.push(JSON.Value.Object());
    value.encode(this);
  }

  encode_small_int<N extends number>(value: N): void { 
    this.push(JSON.Value.Integer(value));
  }

  encode_u8(value: u8): void { this.encode_small_int(value); }
  encode_i8(value: i8): void { this.encode_small_int(value); }
  encode_u16(value: u16): void { this.encode_small_int(value); }
  encode_i16(value: i16): void { this.encode_small_int(value); }
  encode_u32(value: u32): void { this.encode_small_int(value); }
  encode_i32(value: i32): void { this.encode_small_int(value); }
  encode_u64(value: u64): void { this.encode_string(value.toString()); }
  encode_i64(value: i64): void { this.encode_string(value.toString()); }
  encode_f32(value: f32): void { this.push(JSON.Value.Float(value)); }
  encode_f64(value: f64): void { this.push(JSON.Value.Float(value)); }

  static encode<T>(value: T): JSON.Value {
    const ser = new ValueSerializer();
    ser.encode(value);
    return ser.get_encoded_object();
  }
}
'''
'''--- json/assembly/tests/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- json/assembly/tests/jvalue.spec.ts ---
import { ValueSerializer } from "../serializer"
import { ValueDeserializer } from "../deserializer";
import { u128 } from "as-bignum/assembly";
import {
  Numbers,
  init_numbers,
  aString,
  aBoolean,
  Arrays,
  init_arrays,
  ArrayViews,
  MapSet,
  Nullables,
  MixtureOne,
  MixtureTwo,
  Nested,
  Extends,
  MapNullValues,
  BigObj,
  HasConstructorArgs,
} from "@serial-as/tests/assembly";
import { initMixtureTwo } from "./utils";

function roundTrip<T>(t:T): void { 
  const encoded = ValueSerializer.encode(t);
  const newT = (new ValueDeserializer(encoded)).decode<T>();
  expect(newT).toStrictEqual(t);
  const str = encoded.stringify();
  expect<T>(ValueDeserializer.decode<T>(str)).toStrictEqual(t, str);
}

function check_encode<T>(object: T, expected: string): void {
  // Checks that encoding an object returns the expected encoding
  let res: string = ValueSerializer.encode(object).stringify();

  expect(res).toBe(expected)
}

function check_decode<T>(encoded: string, original: T): void {
  // Checks that an encoding returns the expected object
  let deco: T = ValueDeserializer.decode<T>(encoded) as T;
  expect(deco).toStrictEqual(original)
}

describe("JSONSerializer Serializing Types - Two", () => {
  it("should encode/decode numbers", () => {
    roundTrip<u8>(100)
    roundTrip<u16>(101)
    roundTrip<u32>(102)
    roundTrip<u64>(103)
    roundTrip<i8>(-100)
    roundTrip<i16>(-101)
    roundTrip<i32>(-102)
    roundTrip<i64>(-103)
  });

  it("should encode/decode floats", () => {
    roundTrip<f64>(7.23)
    roundTrip<f64>(10e2)
    roundTrip<f64>(10E2)

    roundTrip<f64>(123456e-5)

    roundTrip<f64>(123456E-5)
    
    roundTrip<f64>(0.0)
    roundTrip<f64>(7.23)
  });

    it("should encode/decode u128", () => {
    let N: u128 = u128.from("100")
    roundTrip(N);
  });

  it("should encode/decode just bools", () => {
    const nums: bool = true;
    roundTrip(nums)
  });

  it("should encode/decode just strings", () => {
    let str: string = '"h"i"';

    roundTrip(str);
  });

  it("should encode/decode just arrays", () => {
    const nums: bool[] = [true, false];

    roundTrip(nums);
  });

  it("should encode/decode just map", () => {
    const map: Map<i32, string> = new Map()
    map.set(1, "hi")

    roundTrip(map);
  });
})

describe("JSONSerializer Serializing Objects", () => {
  it("should encode/decode numbers", () => {
    const nums: Numbers = new Numbers()
    init_numbers(nums)
    roundTrip(nums);
  });

  it("should encode/decode strings", () => {
    const str: aString = { str: "h\"i" }
    roundTrip(str);
  });

  it("should encode/decode booleans", () => {
    const bool: aBoolean = new aBoolean()
    roundTrip(bool);
  });

  it("should encode/decode Arrays", () => {
    const arrays: Arrays = new Arrays()
    init_arrays(arrays)
    roundTrip(arrays);
  });

  it("should encode ArrayViews", () => {
    const arrays: ArrayViews = new ArrayViews()
    roundTrip(arrays);
  });

  it("should encode/decode empty Sets and Maps", () => {
    const map_set: MapSet = new MapSet()
    roundTrip(map_set);
  });

  it("should encode/decode non-empty Sets and Maps", () => {
    const map_set: MapSet = new MapSet()
    map_set.map.set('hi', 1)
    map_set.set.add(256)
    map_set.set.add(4)
    roundTrip(map_set);
  });

  it("should handle sets with different types", () => {
    const strSet = new Set<string>();
    strSet.add("hello");
    roundTrip(strSet);
  })

  it("should encode nullable", () => {
    const nullables: Nullables = new Nullables()
    roundTrip(nullables);
  });

  it("should encode defined nullable", () => {
    let nullables: Nullables = new Nullables()
    nullables.u32Arr_null = [1]
    roundTrip(nullables);
  });

  it("should encode/decode simple Mixtures", () => {
    const mix: MixtureOne = new MixtureOne()
    roundTrip(mix);
  });

  it("should encode/decode complex Mixtures", () => {
    const mix: MixtureTwo = new MixtureTwo();
    initMixtureTwo(mix);
    roundTrip(mix);
  });

  it("should decode Mixtures with spaces", () => {
    const mix: MixtureTwo = new MixtureTwo();
    initMixtureTwo(mix);
    roundTrip(mix)
  });

  it("should encode/decode nested JSONSerializer", () => {
    const nested: Nested = new Nested();
    initMixtureTwo(nested.f);
    roundTrip(nested);
  });

  it("should encode/decode JSONSerializer with inheritence", () => {
    const ext: Extends = new Extends();
    initMixtureTwo(ext);
    roundTrip(ext);
  });

  it("should encode/decode Maps with null values", () => {
    const map: MapNullValues = new MapNullValues();
    map.inner.set(1, null)
    roundTrip(map);
  });

  it("should encode/decode Maps with non-null values", () => {
    const map: MapNullValues = new MapNullValues();
    map.inner.set(1, "h\"i")
    roundTrip(map);
  });

  it("should handle big objects", () => {
    const bigObj = new BigObj();
    roundTrip(bigObj);
  });

  it("should handle objects with constructors", () => {
    const num: u32 = 42;
    const str = "hello world";
    const obj = new HasConstructorArgs(num, str);
    roundTrip(obj);
  });

  it("should handle big objects", () => {
    const bigObj = new BigObj();

    // computed using rust
    let expected: string = '{"big_num":"340282366920938463463374607431768211455","typed_arr":"AAIEBggKDA4QEhQWGBocHiAiJCYoKiwuMDI0Njg6PD5AQkRGSEpMTlBSVFZYWlxeYGJkZmhqbG5wcnR2eHp8foCChIaIioyOkJKUlpianJ6goqSmqKqsrrCytLa4ury+wMLExsjKzM7Q0tTW2Nrc3uDi5Obo6uzu8PL09vj6/P4AAgQGCAoMDhASFBYYGhweICIkJigqLC4wMjQ2ODo8PkBCREZISkxOUFJUVlhaXF5gYmRmaGpsbnBydHZ4enx+gIKEhoiKjI6QkpSWmJqcnqCipKaoqqyusLK0tri6vL7AwsTGyMrMztDS1NbY2tze4OLk5ujq7O7w8vT2+Pr8/gACBAYICgwOEBIUFhgaHB4gIiQmKCosLjAyNDY4Ojw+QEJERkhKTE5QUlRWWFpcXmBiZGZoamxucHJ0dnh6fH6AgoSGiIqMjpCSlJaYmpyeoKKkpqiqrK6wsrS2uLq8vsDCxMbIyszO0NLU1tja3N7g4uTm6Ors7vDy9Pb4+vz+AAIEBggKDA4QEhQWGBocHiAiJCYoKiwuMDI0Njg6PD5AQkRGSEpMTlBSVFZYWlxeYGJkZmhqbG5wcnR2eHp8foCChIaIioyOkJKUlpianJ6goqSmqKqsrrCytLa4ury+wMLExsjKzM7Q0tTW2Nrc3uDi5Obo6uzu8PL09vj6/P4AAgQGCAoMDhASFBYYGhweICIkJigqLC4wMjQ2ODo8PkBCREZISkxOUFJUVlhaXF5gYmRmaGpsbnBydHZ4enx+gIKEhoiKjI6QkpSWmJqcnqCipKaoqqyusLK0tri6vL7AwsTGyMrMztDS1NbY2tze4OLk5ujq7O7w8vT2+Pr8/gACBAYICgwOEBIUFhgaHB4gIiQmKCosLjAyNDY4Ojw+QEJERkhKTE5QUlRWWFpcXmBiZGZoamxucHJ0dnh6fH6AgoSGiIqMjpCSlJaYmpyeoKKkpqiqrK6wsrS2uLq8vsDCxMbIyszO0NLU1tja3N7g4uTm6Ors7vDy9Pb4+vz+AAIEBggKDA4QEhQWGBocHiAiJCYoKiwuMDI0Njg6PD5AQkRGSEpMTlBSVFZYWlxeYGJkZmhqbG5wcnR2eHp8foCChIaIioyOkJKUlpianJ6goqSmqKqsrrCytLa4ury+wMLExsjKzM7Q0tTW2Nrc3uDi5Obo6uzu8PL09vj6/P4AAgQGCAoMDhASFBYYGhweICIkJigqLC4wMjQ2ODo8PkBCREZISkxOUFJUVlhaXF5gYmRmaGpsbnBydHZ4enx+gIKEhoiKjI6QkpSWmJqcnqCipKaoqqyusLK0tri6vL7AwsTGyMrMzg=="}'

    check_encode<BigObj>(bigObj, expected)
    check_decode<BigObj>(expected, bigObj)
  });
});
'''
'''--- json/assembly/tests/utils.ts ---
import { MixtureTwo } from "@serial-as/tests/assembly";
import * as base64 from "as-base64/assembly";
import { u128 } from "as-bignum/assembly";

export function initMixtureTwo(f: MixtureTwo): MixtureTwo {
  f.u32Arr = [42, 11];
  f.foo = 321;
  f.bar = 123;
  f.flag = true;
  f.baz = "foo";
  f.uint8array = base64.decode("aGVsbG8sIHdvcmxkIQ==");
  f.u128Val = new u128(128);
  f.arr = [["Hello"], ["World"]];
  f.uint8arrays = new Array<Uint8Array>(2);
  f.uint8arrays[0] = base64.decode("aGVsbG8sIHdvcmxkIQ==");
  f.uint8arrays[1] = base64.decode("aGVsbG8sIHdvcmxkIQ==");
  f.u64Arr = [10000000000, 100000000000];
  return f;
}
'''
'''--- json/package.json ---
{
  "name": "@serial-as/json",
  "version": "2.0.0",
  "description": "JSON Serializer for Assemblyscript",
  "main": "index.js",
  "types": "assembly/index.ts",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": "json"
  },
  "author": "Guillermo Gallardo and Willem Wyndham",
  "license": "MIT",
  "private": false,
  "dependencies": {
    "@serial-as/core": "^2.0.0",
    "as-base64": "^0.2.0",
    "assemblyscript-json": "^1.1.0"
  },
  "devDependencies": {
    "@serial-as/tests": "^2.0.0"
  }
}

'''
'''--- lerna.json ---
{
  "npmClient": "yarn",
  "useWorkspaces": true,
  "version": "2.0.0"
}

'''
'''--- package.json ---
{
  "name": "serial-as",
  "version": "2.0.0",
  "description": "A serializer template for the assemblyscript language",
  "main": "dist",
  "type": "module",
  "types": "dist",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": ""
  },
  "author": "Guillermo Gallardo & Willem Wyndham",
  "license": "MIT",
  "private": true,
  "scripts": {
    "test": "asp",
    "test:borsh": "asp -f bencode",
    "test:json": "asp -f jvalue",
    "build": "yarn workspace @serial-as/transform build",
    "publish": "lerna publish"
  },
  "peerDependencies": {
    "assemblyscript": "^0.19.2"
  },
  "devDependencies": {
    "@as-pect/cli": "^7.0.8",
    "@types/jest": "^29.0.3",
    "@types/node": "^18.7.18",
    "asbuild": "^0.2.0",
    "assemblyscript": "^0.21.3",
    "jest": "^29.0.3",
    "lerna": "^5.5.1",
    "prettier": "^2.7.1",
    "rimraf": "^3.0.2",
    "ts-jest": "^29.0.1",
    "ts-node": "^10.9.1",
    "typescript": "^4.8.3"
  },
  "workspaces": [
    "core",
    "json",
    "borsh",
    "transform",
    "tests"
  ],
  "dependencies": {
    "@assemblyscript/loader": "^0.21.3"
  }
}

'''
'''--- tests/README.md ---
# Tests for serial-as

This folder contains multiple objects covering a wide spectrum of cases in order to test (de)Serializers created with the **serial-as** package.
'''
'''--- tests/assembly/index.ts ---
import { u128 } from "as-bignum/assembly";

// Test
// Numbers
// Strings
// Bool
// Arrays
// ArrayViews
// Set
// Map
// Object
// Nullables

@serializable
export class Numbers {
  public u8: u8 = 0;
  public u16: u16 = 0;
  public u32: u32 = 0;
  public u64: u64 = 0;
  public u128: u128 = u128.Zero;

  public i8: i8 = 0;
  public i16: i16 = 0;
  public i32: i32 = 0;
  public i64: i64 = 0;

  public f32: f32 = 0;
  public f64: f64 = 0;
}

export function init_numbers(N:Numbers):void{
  N.u8 = 1;
  N.u16 = 2;
  N.u32 = 3;
  N.u64 = 4;
  N.u128 = u128.from(5);
  N.i8 = -1;
  N.i16 = -2;
  N.i32 = -3;
  N.i64 = -4;
  N.f32 = 6.0;
  N.f64 = 7.1;
}

@serializable
export class aString{
  str:String = "";
}

@serializable
export class aBoolean{
  bool:bool = true;
}

@serializable
export class Pair {
  public s1: i32;
  public s2: i32;
}

@serializable
export class Arrays {
  public u8Arr: u8[] = [1];
  public u16Arr: u16[] = [3];
  public u32Arr: u32[] = [5];
  public u64Arr: u64[] = [7];
  public u128Arr: u128[] = [u128.from(9)];

  public i8Arr: i8[] = [-1];
  public i16Arr: i16[] = [-3];
  public i32Arr: i32[] = [-5];
  public i64Arr: i64[] = [-7];

  public f32Arr: f32[] = [1];
  public f64Arr: f64[] = [3.1];

  public arrI32: Array<i32> = [0];
  public arrArr: Array<Array<string>> = [[]];
  public arrUint8: Array<Uint8Array> = [];
  public arrObj: Array<Pair> = [{s1:0, s2:1}];
  public statI32: StaticArray<i32> = [0, 0];
  public buff: ArrayBuffer = new ArrayBuffer(2);
}

export function init_arrays(A:Arrays):void{
  A.u8Arr.push(2);
  A.u16Arr.push(4);
  A.u32Arr.push(6);
  A.u64Arr.push(8);
  A.u128Arr.push(u128.from(10));

  A.i8Arr.push(-2);
  A.i16Arr.push(-4);
  A.i32Arr.push(-6);
  A.i64Arr.push(-8);

  A.f32Arr.push(2);
  A.f64Arr.push(4.2);

  A.arrI32.push(1);
  A.arrObj.push({s1:2, s2:3});

  A.statI32[1] = 1

  store<u8>(changetype<usize>(A.buff), 1)
}

@serializable
export class ArrayViews {
  public uint8array: Uint8Array = new Uint8Array(2);
  public uint16array: Uint16Array = new Uint16Array(2);
  public uint32array: Uint32Array = new Uint32Array(2);
  public uint64array: Uint64Array = new Uint64Array(2);

  public int8array: Int8Array = new Int8Array(2);
  public int16array: Int16Array = new Int16Array(2);
  public int32array: Int32Array = new Int32Array(2);
  public int64array: Int64Array = new Int64Array(2);
}

@serializable
export class MapSet {
  public map: Map<string, u32> = new Map<string, u32>();
  public set: Set<u32> = new Set<u32>();
}

@serializable
export class MixtureOne {
  public number: i32 = 2;
  public str: string = "testing";
  public arr: Array<i32> = [0, 1];
  public arpa: Array<Pair> = [
    { s1: 0, s2: 1 },
    { s1: 2, s2: 3 },
  ];
  public f32_zero: f32;
}

@serializable
export class MixtureTwo {
  foo: i32 = 0;
  bar: u32 = 1;
  u64Val: u64 = 4294967297;
  u64_zero: u64;
  i64Val: i64 = -64;
  flag: bool;
  baz: string = "";
  uint8array: Uint8Array = new Uint8Array(2);
  arr: Array<Array<string>> = [];
  u32Arr: u32[] = [];
  i32Arr: i32[] = [];
  u128Val: u128 = u128.from("128");
  uint8arrays: Array<Uint8Array> = [];
  u64Arr: u64[] = [];
}

@serializable
export class Nullables {
  u32Arr_null: u32[] | null;
  arr_null: string[] | null;
  u64_arr: Array<u64> | null;
  map_null: Map<string, string> | null;
  set_null: Set<string> | null;
  obj_null: Nested | null;
}

@serializable
export class Extends extends MixtureTwo {
  x: bool[] = [1];
}

@serializable
export class Nested {
  f: MixtureTwo = new MixtureTwo();
}

@serializable
export class MapNullValues {
  inner: Map<i32, string | null> = new Map();
}

@serializable
export class BigObj {
  big_num: u128 = u128.Max;
  typed_arr: Uint8Array = new Uint8Array(1000);

  constructor(){
    for (let i = 0; i < this.typed_arr.length; i++) {
      this.typed_arr[i] = i * 2;
    }
  }
}
@serializable
export class HasConstructorArgs {
  constructor(private U32: u32, private str: string){}

  get string(): string {
    return this.str;
  }

  get u32(): u32 { return this.U32; }
}

'''
'''--- tests/package.json ---
{
  "name": "@serial-as/tests",
  "version": "2.0.0",
  "description": "Tets for serializers in Assemblyscript",
  "main": "dist/index.js",
  "types": "assembly/index.ts",
  "author": "Guillermo Gallardo and Willem Wyndham",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": "test"
  },
  "private": true
}

'''
'''--- transform/dist/index.d.ts ---
import { ClassDeclaration, Parser } from "assemblyscript/dist/assemblyscript.js";
import { ASTTransformVisitor } from "visitor-as";
export default class Transformer extends ASTTransformVisitor {
    visitClassDeclaration(node: ClassDeclaration): void;
    afterParse(_: Parser): void;
}

'''
'''--- transform/dist/index.js ---
import { ASTTransformVisitor } from "visitor-as";
import { MethodInjector } from "./methodInjector.js";
export default class Transformer extends ASTTransformVisitor {
    visitClassDeclaration(node) {
        MethodInjector.visit(node);
    }
    afterParse(_) {
        _.sources.forEach(source => this.visit(source));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFnQyxtQkFBbUIsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUUvRSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFNbkQsTUFBTSxDQUFDLE9BQU8sT0FBTyxXQUFZLFNBQVEsbUJBQW1CO0lBQzFELHFCQUFxQixDQUFDLElBQXNCO1FBQ3hDLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELFVBQVUsQ0FBQyxDQUFTO1FBQ2xCLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FFRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsYXNzRGVjbGFyYXRpb24sIFBhcnNlciwgQ29tbW9uRmxhZ3MgfSBmcm9tIFwiYXNzZW1ibHlzY3JpcHQvZGlzdC9hc3NlbWJseXNjcmlwdC5qc1wiO1xyXG5pbXBvcnQgeyByZWdpc3RlckRlY29yYXRvciwgRGVjb3JhdG9yLCBBU1RUcmFuc2Zvcm1WaXNpdG9yIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcclxuXHJcbmltcG9ydCB7TWV0aG9kSW5qZWN0b3J9IGZyb20gXCIuL21ldGhvZEluamVjdG9yLmpzXCI7XHJcbmltcG9ydCB7IGdldE5hbWUsIGlzTGlicmFyeSwgbm90IH0gZnJvbSBcInZpc2l0b3ItYXMvZGlzdC91dGlscy5qc1wiO1xyXG5pbXBvcnQgeyBpc1N0ZGxpYiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybWVyIGV4dGVuZHMgQVNUVHJhbnNmb3JtVmlzaXRvciB7XHJcbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcclxuICAgICAgTWV0aG9kSW5qZWN0b3IudmlzaXQobm9kZSk7XHJcbiAgfVxyXG5cclxuICBhZnRlclBhcnNlKF86IFBhcnNlcik6IHZvaWQgeyBcclxuICAgIF8uc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB0aGlzLnZpc2l0KHNvdXJjZSkpO1xyXG4gIH1cclxuICBcclxufVxyXG4iXX0=
'''
'''--- transform/dist/methodInjector.d.ts ---
import { ClassDeclaration, Source, FieldDeclaration } from "assemblyscript/dist/assemblyscript.js";
import { BaseVisitor } from "visitor-as";
export declare class MethodInjector extends BaseVisitor {
    encodeStmts: string[];
    decodeStmts: string[];
    currentClass: ClassDeclaration;
    visitFieldDeclaration(node: FieldDeclaration): void;
    visitClassDeclaration(node: ClassDeclaration): void;
    static visit(node: ClassDeclaration | Source): void;
}

'''
'''--- transform/dist/methodInjector.js ---
import { SimpleParser, BaseVisitor } from "visitor-as";
import { toString, isMethodNamed, getName } from 'visitor-as/dist/utils.js';
import { isStdlib } from "./utils.js";
function isField(node) {
    return node.kind == 54 /* NodeKind.FIELDDECLARATION */;
}
function isInstanceField(node) {
    return isField(node) && node.is(262144 /* CommonFlags.INSTANCE */);
}
export class MethodInjector extends BaseVisitor {
    encodeStmts;
    decodeStmts;
    currentClass;
    visitFieldDeclaration(node) {
        const name = toString(node.name);
        if (!node.type) {
            throw new Error(`Field ${name} is missing a type declaration  for ${toString(this.currentClass)}`);
        }
        const _type = getName(node.type);
        this.encodeStmts.push(`encoder.encode_field<${_type}>("${name}", this.${name})`);
        this.decodeStmts.push(`this.${name} = decoder.decode_field<${_type}>("${name}")`);
    }
    visitClassDeclaration(node) {
        if (isStdlib(node)) {
            return;
        }
        const fields = node.members.filter(isInstanceField);
        if (!fields) {
            return;
        }
        this.currentClass = node;
        this.encodeStmts = [];
        this.decodeStmts = [];
        super.visit(fields);
        const encodeMethod = `
    encode<__T>(encoder: __T): void {
      ${node.extendsType != null ? "super.encode<__T>(encoder);" : ""}
      ${this.encodeStmts.join(";\n\t")};
    }
    `;
        const decodeMethod = `
    decode<__T>(decoder: __T): void {
      ${node.extendsType != null ? "super.decode(decoder);" : ""}
      ${this.decodeStmts.join(";\n\t")};
    }
    `;
        if (!node.members.some(isMethodNamed("encode"))) {
            const encodeMember = SimpleParser.parseClassMember(encodeMethod, node);
            node.members.push(encodeMember);
        }
        if (!node.members.some(isMethodNamed("decode"))) {
            const decodeMember = SimpleParser.parseClassMember(decodeMethod, node);
            node.members.push(decodeMember);
        }
    }
    static visit(node) {
        (new MethodInjector()).visit(node);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0aG9kSW5qZWN0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWV0aG9kSW5qZWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdkQsT0FBTyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUV0QyxTQUFTLE9BQU8sQ0FBQyxJQUEwQjtJQUN6QyxPQUFPLElBQUksQ0FBQyxJQUFJLHNDQUE2QixDQUFDO0FBQ2hELENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxJQUEwQjtJQUNqRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxtQ0FBc0IsQ0FBQztBQUN4RCxDQUFDO0FBRUQsTUFBTSxPQUFPLGNBQWUsU0FBUSxXQUFXO0lBQzdDLFdBQVcsQ0FBWTtJQUN2QixXQUFXLENBQVk7SUFDdkIsWUFBWSxDQUFvQjtJQUVoQyxxQkFBcUIsQ0FBQyxJQUFzQjtRQUMxQyxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLElBQUksdUNBQXVDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3BHO1FBRUQsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsS0FBSyxNQUFNLElBQUksV0FBVyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRWpGLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSwyQkFBMkIsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLENBQUM7SUFDcEYsQ0FBQztJQUVELHFCQUFxQixDQUFDLElBQXNCO1FBQzFDLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBRS9CLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUV6QixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXBCLE1BQU0sWUFBWSxHQUFHOztRQUVqQixJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDN0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDOztLQUVqQyxDQUFBO1FBQ0QsTUFBTSxZQUFZLEdBQUc7O1FBRWpCLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUN4RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7O0tBRWpDLENBQUE7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7WUFDL0MsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN2RSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNqQztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRTtZQUMvQyxNQUFNLFlBQVksR0FBRyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBK0I7UUFDMUMsQ0FBQyxJQUFJLGNBQWMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FFRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVOb2RlLCBDbGFzc0RlY2xhcmF0aW9uLCBTb3VyY2UsIEZpZWxkRGVjbGFyYXRpb24sIE5vZGVLaW5kLCBEZWNsYXJhdGlvblN0YXRlbWVudCwgQ29tbW9uRmxhZ3MgfSBmcm9tIFwiYXNzZW1ibHlzY3JpcHQvZGlzdC9hc3NlbWJseXNjcmlwdC5qc1wiO1xyXG5pbXBvcnQgeyBTaW1wbGVQYXJzZXIsIEJhc2VWaXNpdG9yIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcclxuaW1wb3J0IHsgdG9TdHJpbmcsIGlzTWV0aG9kTmFtZWQsIGdldE5hbWUgfSBmcm9tICd2aXNpdG9yLWFzL2Rpc3QvdXRpbHMuanMnO1xyXG5pbXBvcnQgeyBpc1N0ZGxpYiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcblxyXG5mdW5jdGlvbiBpc0ZpZWxkKG5vZGU6IERlY2xhcmF0aW9uU3RhdGVtZW50KTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIG5vZGUua2luZCA9PSBOb2RlS2luZC5GSUVMRERFQ0xBUkFUSU9OO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luc3RhbmNlRmllbGQobm9kZTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcclxuICByZXR1cm4gaXNGaWVsZChub2RlKSAmJiBub2RlLmlzKENvbW1vbkZsYWdzLklOU1RBTkNFKTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE1ldGhvZEluamVjdG9yIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xyXG4gIGVuY29kZVN0bXRzITogc3RyaW5nW107XHJcbiAgZGVjb2RlU3RtdHMhOiBzdHJpbmdbXTtcclxuICBjdXJyZW50Q2xhc3MhOiBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cclxuICB2aXNpdEZpZWxkRGVjbGFyYXRpb24obm9kZTogRmllbGREZWNsYXJhdGlvbik6IHZvaWQge1xyXG4gICAgY29uc3QgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XHJcbiAgICBpZiAoIW5vZGUudHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkICR7bmFtZX0gaXMgbWlzc2luZyBhIHR5cGUgZGVjbGFyYXRpb24gIGZvciAke3RvU3RyaW5nKHRoaXMuY3VycmVudENsYXNzKX1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgX3R5cGUgPSBnZXROYW1lKG5vZGUudHlwZSk7XHJcbiAgICBcclxuICAgIHRoaXMuZW5jb2RlU3RtdHMucHVzaChgZW5jb2Rlci5lbmNvZGVfZmllbGQ8JHtfdHlwZX0+KFwiJHtuYW1lfVwiLCB0aGlzLiR7bmFtZX0pYCk7XHJcbiAgICBcclxuICAgIHRoaXMuZGVjb2RlU3RtdHMucHVzaChgdGhpcy4ke25hbWV9ID0gZGVjb2Rlci5kZWNvZGVfZmllbGQ8JHtfdHlwZX0+KFwiJHtuYW1lfVwiKWApO1xyXG4gIH1cclxuXHJcbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcclxuICAgIGlmIChpc1N0ZGxpYihub2RlKSkgeyByZXR1cm47IH1cclxuXHJcbiAgICBjb25zdCBmaWVsZHMgPSBub2RlLm1lbWJlcnMuZmlsdGVyKGlzSW5zdGFuY2VGaWVsZCk7XHJcbiAgICBpZiAoIWZpZWxkcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IG5vZGU7XHJcblxyXG4gICAgdGhpcy5lbmNvZGVTdG10cyA9IFtdO1xyXG4gICAgdGhpcy5kZWNvZGVTdG10cyA9IFtdO1xyXG4gICAgc3VwZXIudmlzaXQoZmllbGRzKTtcclxuXHJcbiAgICBjb25zdCBlbmNvZGVNZXRob2QgPSBgXHJcbiAgICBlbmNvZGU8X19UPihlbmNvZGVyOiBfX1QpOiB2b2lkIHtcclxuICAgICAgJHtub2RlLmV4dGVuZHNUeXBlICE9IG51bGwgPyBcInN1cGVyLmVuY29kZTxfX1Q+KGVuY29kZXIpO1wiIDogXCJcIn1cclxuICAgICAgJHt0aGlzLmVuY29kZVN0bXRzLmpvaW4oXCI7XFxuXFx0XCIpfTtcclxuICAgIH1cclxuICAgIGBcclxuICAgIGNvbnN0IGRlY29kZU1ldGhvZCA9IGBcclxuICAgIGRlY29kZTxfX1Q+KGRlY29kZXI6IF9fVCk6IHZvaWQge1xyXG4gICAgICAke25vZGUuZXh0ZW5kc1R5cGUgIT0gbnVsbCA/IFwic3VwZXIuZGVjb2RlKGRlY29kZXIpO1wiIDogXCJcIn1cclxuICAgICAgJHt0aGlzLmRlY29kZVN0bXRzLmpvaW4oXCI7XFxuXFx0XCIpfTtcclxuICAgIH1cclxuICAgIGBcclxuICAgIGlmICghbm9kZS5tZW1iZXJzLnNvbWUoaXNNZXRob2ROYW1lZChcImVuY29kZVwiKSkpIHsgXHJcbiAgICAgIGNvbnN0IGVuY29kZU1lbWJlciA9IFNpbXBsZVBhcnNlci5wYXJzZUNsYXNzTWVtYmVyKGVuY29kZU1ldGhvZCwgbm9kZSk7XHJcbiAgICAgIG5vZGUubWVtYmVycy5wdXNoKGVuY29kZU1lbWJlcik7XHJcbiAgICB9XHJcbiAgICBpZiAoIW5vZGUubWVtYmVycy5zb21lKGlzTWV0aG9kTmFtZWQoXCJkZWNvZGVcIikpKSB7IFxyXG4gICAgICBjb25zdCBkZWNvZGVNZW1iZXIgPSBTaW1wbGVQYXJzZXIucGFyc2VDbGFzc01lbWJlcihkZWNvZGVNZXRob2QsIG5vZGUpO1xyXG4gICAgICBub2RlLm1lbWJlcnMucHVzaChkZWNvZGVNZW1iZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIHZpc2l0KG5vZGU6IENsYXNzRGVjbGFyYXRpb24gfCBTb3VyY2UpOiB2b2lkIHtcclxuICAgIChuZXcgTWV0aG9kSW5qZWN0b3IoKSkudmlzaXQobm9kZSk7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=
'''
'''--- transform/dist/utils.d.ts ---
export { isStdlib } from "visitor-as/dist/utils.js";

'''
'''--- transform/dist/utils.js ---
export { isStdlib } from "visitor-as/dist/utils.js";
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLDBCQUEwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICB7IGlzU3RkbGliIH0gZnJvbSBcInZpc2l0b3ItYXMvZGlzdC91dGlscy5qc1wiO1xyXG4iXX0=
'''
'''--- transform/package.json ---
{
  "name": "@serial-as/transform",
  "version": "2.0.0",
  "description": "Transform to enable serialization in Assemblyscript",
  "main": "dist/index.js",
  "type": "module",
  "types": "dist/index.d.ts",
  "author": "Guillermo Gallardo and Willem Wyndham",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gagdiez/serial-as.git",
    "directory": "test"
  },
  "dependencies": {
    "visitor-as": "^0.10.2"
  },
  "scripts": {
    "build": "rimraf dist/ && tsc"
  }
}

'''
'''--- transform/src/index.ts ---
import { ClassDeclaration, Parser, CommonFlags } from "assemblyscript/dist/assemblyscript.js";
import { registerDecorator, Decorator, ASTTransformVisitor } from "visitor-as";

import {MethodInjector} from "./methodInjector.js";
import { getName, isLibrary, not } from "visitor-as/dist/utils.js";
import { isStdlib } from "./utils.js";

export default class Transformer extends ASTTransformVisitor {
  visitClassDeclaration(node: ClassDeclaration): void {
      MethodInjector.visit(node);
  }

  afterParse(_: Parser): void { 
    _.sources.forEach(source => this.visit(source));
  }
  
}

'''
'''--- transform/src/methodInjector.ts ---
import { TypeNode, ClassDeclaration, Source, FieldDeclaration, NodeKind, DeclarationStatement, CommonFlags } from "assemblyscript/dist/assemblyscript.js";
import { SimpleParser, BaseVisitor } from "visitor-as";
import { toString, isMethodNamed, getName } from 'visitor-as/dist/utils.js';
import { isStdlib } from "./utils.js";

function isField(node: DeclarationStatement): boolean {
  return node.kind == NodeKind.FIELDDECLARATION;
}

function isInstanceField(node: DeclarationStatement): boolean {
  return isField(node) && node.is(CommonFlags.INSTANCE);
}

export class MethodInjector extends BaseVisitor {
  encodeStmts!: string[];
  decodeStmts!: string[];
  currentClass!: ClassDeclaration;

  visitFieldDeclaration(node: FieldDeclaration): void {
    const name = toString(node.name);
    if (!node.type) {
      throw new Error(`Field ${name} is missing a type declaration  for ${toString(this.currentClass)}`);
    }
    
    const _type = getName(node.type);
    
    this.encodeStmts.push(`encoder.encode_field<${_type}>("${name}", this.${name})`);
    
    this.decodeStmts.push(`this.${name} = decoder.decode_field<${_type}>("${name}")`);
  }

  visitClassDeclaration(node: ClassDeclaration): void {
    if (isStdlib(node)) { return; }

    const fields = node.members.filter(isInstanceField);
    if (!fields) {
      return;
    }
    this.currentClass = node;

    this.encodeStmts = [];
    this.decodeStmts = [];
    super.visit(fields);

    const encodeMethod = `
    encode<__T>(encoder: __T): void {
      ${node.extendsType != null ? "super.encode<__T>(encoder);" : ""}
      ${this.encodeStmts.join(";\n\t")};
    }
    `
    const decodeMethod = `
    decode<__T>(decoder: __T): void {
      ${node.extendsType != null ? "super.decode(decoder);" : ""}
      ${this.decodeStmts.join(";\n\t")};
    }
    `
    if (!node.members.some(isMethodNamed("encode"))) { 
      const encodeMember = SimpleParser.parseClassMember(encodeMethod, node);
      node.members.push(encodeMember);
    }
    if (!node.members.some(isMethodNamed("decode"))) { 
      const decodeMember = SimpleParser.parseClassMember(decodeMethod, node);
      node.members.push(decodeMember);
    }
  }

  static visit(node: ClassDeclaration | Source): void {
    (new MethodInjector()).visit(node);
  }

}

'''
'''--- transform/src/utils.ts ---
export  { isStdlib } from "visitor-as/dist/utils.js";

'''
'''--- transform/tsconfig.json ---
{
  "compilerOptions": {
    "outDir": "./dist",
    "inlineSourceMap": true,
    "inlineSources": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "downlevelIteration": true,
    "preserveConstEnums": true,
    "alwaysStrict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noEmitOnError": true,
    "allowJs": true,
    "strictNullChecks": true,
    "experimentalDecorators": true,
    "declaration": true
  },
  "include": ["src/**/*"]
}

'''
'''--- tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": ["*/assembly/**/*.ts"],
  "exclude": ["**/node_modules/**/*"]
}
'''