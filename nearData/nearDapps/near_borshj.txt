*GitHub Repository "near/borshj"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .travis.yml ---
language: java

jobs:
  include:
    - name: gradle
      script:
      - gradle jar

    - name: fossa     
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test

'''
'''--- CHANGES.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

'''
'''--- CREDITS.md ---
# Credits

'''
'''--- README.md ---
# BorshJ

[![Project license](https://img.shields.io/badge/license-Public%20Domain-blue.svg)](https://unlicense.org)
[![Discord](https://img.shields.io/discord/490367152054992913?label=discord)](https://discord.gg/Vyp7ETM)

**BorshJ** is an implementation of the [Borsh] binary serialization format for
Java (and Kotlin, Scala, Clojure, Groovy, Jython, JRuby, etc.) projects.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is
meant to be used in security-critical projects as it prioritizes consistency,
safety, speed, and comes with a strict specification.

## Features

- Implements [`BorshBuffer`] on top of Java's [`ByteBuffer`].

- Implements [`BorshReader`] on top of any Java [`InputStream`].

- Implements [`BorshWriter`] on top of any Java [`OutputStream`].

- Based on Java NIO, enabling high-performance, zero-copy interoperability
  with native code via JNI.

- GC friendly: avoids unnecessary copying wherever possible.

## Prerequisites

- [Java] 8+ (this library is compatible with Android)

- [Gradle] (when building from source code)

## Installation

We are working on building release binaries. They will be available here soon.

In the meantime, if you wish to try out BorshJ, you will need to build the JAR
file from source code yourself:

```bash
git clone https://github.com/near/borshj.git

cd borshj

gradle jar

ls -l build/libs/borshj-$(cat VERSION).jar
```

## Usage

To use the Borsh object serializer/deserializer, you need add just one import:

```java
import org.near.borshj.Borsh;
```

## Examples

The following code examples further below are all predicated on this simple
data class definition:

```java
public class Point2D implements Borsh {
  public float x;
  public float y;

  public Point2D() {}

  public Point2D(float x, float y) {
    this.x = x;
    this.y = y;
  }
}
```

### Serializing an object

To serialize a [POJO], use the `Borsh.serialize()` method:

```java
Point2D point = new Point2D(123.0, 456.0);

byte[] bytes = Borsh.serialize(point);
```

### Deserializing an object

To deserialize a [POJO], use the `Borsh.deserialize()` method:

```java
Point2D point = Borsh.deserialize(bytes, Point2D.class);
```

## Type Mappings

Borsh                 | Java           | TypeScript
--------------------- | -------------- | ----------
`u8` integer          | `byte`         | `number`
`u16` integer         | `short`        | `number`
`u32` integer         | `int`          | `number`
`u64` integer         | `long`         | `BN`
`u128` integer        | [`BigInteger`] | `BN`
`f32` float           | `float`        | N/A
`f64` float           | `double`       | N/A
fixed-size byte array | `byte[]`       | `Uint8Array`
UTF-8 string          | `String`       | `string`
option                | [`Optional`]   | `null` or type
map                   | [`Map`]        | N/A
set                   | [`Set`]        | N/A
structs               | `Object`       | `any`

## Frequently Asked Questions

### Q: Why does my class need a default constructor?

Classes used with `Borsh.deserialize()` must have a nullary default constructor
because instances of the class will be instantiated through Java's
[reflection API](https://www.baeldung.com/java-reflection).

[Borsh]:          https://borsh.io
[Gradle]:         https://gradle.org
[Java]:           https://java.com
[POJO]:           https://en.wikipedia.org/wiki/Plain_old_Java_object

[`BigInteger`]:   https://docs.oracle.com/javase/10/docs/api/java/math/BigInteger.html
[`BorshBuffer`]:  https://github.com/near/borshj/blob/master/src/main/java/org/near/borshj/BorshBuffer.java
[`BorshReader`]:  https://github.com/near/borshj/blob/master/src/main/java/org/near/borshj/BorshReader.java
[`BorshWriter`]:  https://github.com/near/borshj/blob/master/src/main/java/org/near/borshj/BorshWriter.java
[`ByteBuffer`]:   https://docs.oracle.com/javase/10/docs/api/java/nio/ByteBuffer.html
[`InputStream`]:  https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html
[`Map`]:          https://docs.oracle.com/javase/10/docs/api/java/util/Map.html
[`Optional`]:     https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html
[`OutputStream`]: https://docs.oracle.com/javase/10/docs/api/java/io/OutputStream.html
[`Set`]:          https://docs.oracle.com/javase/10/docs/api/java/util/Set.html

'''
'''--- TODO.md ---
# To-Dos

'''
'''--- src/main/java/org/near/borshj/Borsh.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import static java.util.Objects.requireNonNull;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Optional;

public interface Borsh {
  public static @NonNull byte[] serialize(final @NonNull Object object) {
    return BorshBuffer.allocate(4096).write(requireNonNull(object)).toByteArray();
  }

  public static @NonNull <T> T deserialize(final @NonNull byte[] bytes, final @NonNull Class klass) {
    return deserialize(BorshBuffer.wrap(requireNonNull(bytes)), klass);
  }

  public static @NonNull <T> T deserialize(final @NonNull BorshBuffer buffer, final @NonNull Class klass) {
    return buffer.read(requireNonNull(klass));
  }

  public static boolean isSerializable(final @Nullable Class klass) {
    if (klass == null) return false;
    return Arrays.stream(klass.getInterfaces()).anyMatch(iface -> iface == Borsh.class) ||
      isSerializable(klass.getSuperclass());
  }
}

'''
'''--- src/main/java/org/near/borshj/BorshBuffer.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import static java.util.Objects.requireNonNull;

import androidx.annotation.NonNull;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;

public class BorshBuffer implements BorshInput, BorshOutput<BorshBuffer> {
  protected final @NonNull ByteBuffer buffer;

  protected BorshBuffer(final @NonNull ByteBuffer buffer) {
    this.buffer = requireNonNull(buffer);
    this.buffer.order(ByteOrder.LITTLE_ENDIAN);
    this.buffer.mark();
  }

  protected byte[] array() {
    assert(this.buffer.hasArray());
    return this.buffer.array();
  }

  public static @NonNull BorshBuffer allocate(final int capacity) {
    return new BorshBuffer(ByteBuffer.allocate(capacity));
  }

  public static @NonNull BorshBuffer allocateDirect(final int capacity) {
    return new BorshBuffer(ByteBuffer.allocateDirect(capacity));
  }

  public static @NonNull BorshBuffer wrap(final byte[] array) {
    return new BorshBuffer(ByteBuffer.wrap(array));
  }

  public @NonNull byte[] toByteArray() {
    assert(this.buffer.hasArray());
    final int arrayOffset = this.buffer.arrayOffset();
    return Arrays.copyOfRange(this.buffer.array(),
      arrayOffset, arrayOffset + this.buffer.position());
  }

  public int capacity() {
    return this.buffer.capacity();
  }

  public @NonNull BorshBuffer reset() {
    this.buffer.reset();
    return this;
  }

  @Override
  public short readU16() {
    return this.buffer.getShort();
  }

  @Override
  public int readU32() {
    return this.buffer.getInt();
  }

  @Override
  public long readU64() {
    return this.buffer.getLong();
  }

  @Override
  public float readF32() {
    return this.buffer.getFloat();
  }

  @Override
  public double readF64() {
    return this.buffer.getDouble();
  }

  @Override
  public byte read() {
    return this.buffer.get();
  }

  @Override
  public void read(final @NonNull byte[] result, final int offset, final int length) {
    this.buffer.get(result, offset, length);
  }

  @Override
  public @NonNull BorshBuffer writeU16(final short value) {
    this.buffer.putShort(value);
    return this;
  }

  @Override
  public @NonNull BorshBuffer writeU32(final int value) {
    this.buffer.putInt(value);
    return this;
  }

  @Override
  public @NonNull BorshBuffer writeU64(final long value) {
    this.buffer.putLong(value);
    return this;
  }

  @Override
  public @NonNull BorshBuffer writeF32(final float value) {
    this.buffer.putFloat(value);
    return this;
  }

  @Override
  public @NonNull BorshBuffer writeF64(final double value) {
    this.buffer.putDouble(value);
    return this;
  }

  @Override
  public @NonNull BorshBuffer write(final @NonNull byte[] bytes) {
    this.buffer.put(bytes);
    return this;
  }

  @Override
  public @NonNull BorshBuffer write(final byte b) {
    this.buffer.put(b);
    return this;
  }
}

'''
'''--- src/main/java/org/near/borshj/BorshInput.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import androidx.annotation.NonNull;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

public interface BorshInput {
  default public <T> T read(final @NonNull Class klass) {
    if (klass == Byte.class || klass == byte.class) {
      return (T)Byte.valueOf(this.readU8());
    }
    else if (klass == Short.class || klass == short.class) {
      return (T)Short.valueOf(this.readU16());
    }
    else if (klass == Integer.class || klass == int.class) {
      return (T)Integer.valueOf(this.readU32());
    }
    else if (klass == Long.class || klass == long.class) {
      return (T)Long.valueOf(this.readU64());
    }
    else if (klass == BigInteger.class) {
      return (T)this.readU128();
    }
    else if (klass == Float.class || klass == float.class) {
      return (T)Float.valueOf(this.readF32());
    }
    else if (klass == Double.class || klass == double.class) {
      return (T)Double.valueOf(this.readF64());
    }
    else if (klass == String.class) {
      return (T)this.readString();
    }
    else if (klass == Boolean.class) {
      return (T)Boolean.valueOf(this.readBoolean());
    }
    else if (klass == Optional.class) {
      return (T)this.readOptional();
    }
    else if (Borsh.isSerializable(klass)) {
      return (T)this.readPOJO(klass);
    }
    throw new IllegalArgumentException();
  }

  default public <T> T readPOJO(final @NonNull Class klass) {
    try {
      final Object object = klass.getConstructor().newInstance();
      for (final Field field : klass.getDeclaredFields()) {
        field.setAccessible(true);
        final Class fieldClass = field.getType();
        if (fieldClass == Optional.class) {
          final Type fieldType = field.getGenericType();
          if (!(fieldType instanceof ParameterizedType)) {
            throw new AssertionError("unsupported Optional type");
          }
          final Type[] optionalArgs = ((ParameterizedType)fieldType).getActualTypeArguments();
          assert(optionalArgs.length == 1);
          final Class optionalClass = (Class)optionalArgs[0];
          field.set(object, this.readOptional(optionalClass));
        }
        else {
          field.set(object, this.read(field.getType()));
        }
      }
      return (T)object;
    }
    catch (NoSuchMethodException error) {
      throw new RuntimeException(error);
    }
    catch (InstantiationException error) {
      throw new RuntimeException(error);
    }
    catch (IllegalAccessException error) {
      throw new RuntimeException(error);
    }
    catch (InvocationTargetException error) {
      throw new RuntimeException(error);
    }
  }

  default public byte readU8() {
    return this.read();
  }

  default public short readU16() {
    return BorshBuffer.wrap(this.read(2)).readU16();
  }

  default public int readU32() {
    return BorshBuffer.wrap(this.read(4)).readU32();
  }

  default public long readU64() {
    return BorshBuffer.wrap(this.read(8)).readU64();
  }

  default public @NonNull BigInteger readU128() {
    final byte[] bytes = new byte[16];
    this.read(bytes);
    for (int i = 0; i < 8; i++) {
      final byte a = bytes[i];
      final byte b = bytes[15 - i];
      bytes[i] = b;
      bytes[15 - i] = a;
    }
    return new BigInteger(bytes);
  }

  default public float readF32() {
    return BorshBuffer.wrap(this.read(4)).readF32();
  }

  default public double readF64() {
    return BorshBuffer.wrap(this.read(8)).readF64();
  }

  default public @NonNull String readString() {
    final int length = this.readU32();
    final byte[] bytes = new byte[length];
    this.read(bytes);
    return new String(bytes, StandardCharsets.UTF_8);
  }

  default public @NonNull byte[] readFixedArray(final int length) {
    if (length < 0) {
      throw new IllegalArgumentException();
    }
    final byte[] bytes = new byte[length];
    this.read(bytes);
    return bytes;
  }

  default public @NonNull <T> T[] readArray(final @NonNull Class klass) {
    final int length = this.readU32();
    final T[] elements = (T[])Array.newInstance(klass, length);
    for (int i = 0; i < length; i++) {
      elements[i] = this.read(klass);
    }
    return elements;
  }

  default public boolean readBoolean() {
    return (this.readU8() != 0);
  }

  default public <T> @NonNull Optional<T> readOptional() {
    final boolean isPresent = (this.readU8() != 0);
    if (!isPresent) {
      return (Optional<T>)Optional.empty();
    }
    throw new AssertionError("Optional type has been erased and cannot be reconstructed");
  }

  default public <T> @NonNull Optional<T> readOptional(final @NonNull Class klass) {
    final boolean isPresent = (this.readU8() != 0);
    return isPresent ? Optional.of(this.read(klass)) : Optional.empty();
  }

  public byte read();

  default public byte[] read(final int length) {
    if (length < 0) {
      throw new IndexOutOfBoundsException();
    }
    final byte[] result = new byte[length];
    this.read(result);
    return result;
  }

  default public void read(final @NonNull byte[] result) {
    this.read(result, 0, result.length);
  }

  public void read(@NonNull byte[] result, int offset, int length);
}

'''
'''--- src/main/java/org/near/borshj/BorshOutput.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import static java.util.Objects.requireNonNull;

import androidx.annotation.NonNull;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Optional;

public interface BorshOutput<Self> {
  default public @NonNull Self write(final @NonNull Object object) {
    requireNonNull(object);
    if (object instanceof Byte) {
      return this.writeU8((byte)object);
    }
    else if (object instanceof Short) {
      return this.writeU16((short)object);
    }
    else if (object instanceof Integer) {
      return this.writeU32((int)object);
    }
    else if (object instanceof Long) {
      return this.writeU64((long)object);
    }
    else if (object instanceof Float) {
      return this.writeF32((float)object);
    }
    else if (object instanceof Double) {
      return this.writeF64((double)object);
    }
    else if (object instanceof BigInteger) {
      return this.writeU128((BigInteger)object);
    }
    else if (object instanceof String) {
      return this.writeString((String)object);
    }
    else if (object instanceof List) {
      return (Self)this.writeArray((List)object);
    }
    else if (object instanceof Boolean) {
      return (Self)this.writeBoolean((Boolean)object);
    }
    else if (object instanceof Optional) {
      return (Self)this.writeOptional((Optional)object);
    }
    else if (object instanceof Borsh) {
      return this.writePOJO(object);
    }
    throw new IllegalArgumentException();
  }

  default public @NonNull Self writePOJO(final @NonNull Object object) {
    try {
      for (final Field field : object.getClass().getDeclaredFields()) {
        field.setAccessible(true);
        this.write(field.get(object));
      }
    }
    catch (IllegalAccessException error) {
      throw new RuntimeException(error);
    }
    return (Self)this;
  }

  default public @NonNull Self writeU8(final int value) {
    return this.writeU8((byte)value);
  }

  default public @NonNull Self writeU8(final byte value) {
    return this.write(value);
  }

  default public @NonNull Self writeU16(final int value) {
    return this.writeU16((short)value);
  }

  default public @NonNull Self writeU16(final short value) {
    return this.writeBuffer(BorshBuffer.allocate(2).writeU16(value));
  }

  default public @NonNull Self writeU32(final int value) {
    return this.writeBuffer(BorshBuffer.allocate(4).writeU32(value));
  }

  default public @NonNull Self writeU64(final long value) {
    return this.writeBuffer(BorshBuffer.allocate(8).writeU64(value));
  }

  default public @NonNull Self writeU128(final long value) {
    return this.writeU128(BigInteger.valueOf(value));
  }

  default public @NonNull Self writeU128(final @NonNull BigInteger value) {
    if (value.signum() == -1) {
      throw new ArithmeticException("integer underflow");
    }
    if (value.bitLength() > 128) {
      throw new ArithmeticException("integer overflow");
    }
    final byte[] bytes = value.toByteArray();
    for (int i = bytes.length - 1; i >= 0; i--) {
      this.write(bytes[i]);
    }
    for (int i = 0; i < 16 - bytes.length; i++) {
      this.write((byte)0);
    }
    return (Self)this;
  }

  default public @NonNull Self writeF32(final float value) {
    return this.writeBuffer(BorshBuffer.allocate(4).writeF32(value));
  }

  default public @NonNull Self writeF64(final double value) {
    return this.writeBuffer(BorshBuffer.allocate(8).writeF64(value));
  }

  default public @NonNull Self writeString(final @NonNull String string) {
    final byte[] bytes = string.getBytes(StandardCharsets.UTF_8);
    this.writeU32(bytes.length);
    return this.write(bytes);
  }

  default public @NonNull Self writeFixedArray(final @NonNull byte[] array) {
    return this.write(array);
  }

  default public @NonNull <T> Self writeArray(final @NonNull T[] array) {
    this.writeU32(array.length);
    for (final T element : array) {
      this.write(element);
    }
    return (Self)this;
  }

  default public @NonNull <T> Self writeArray(final @NonNull List<T> list) {
    this.writeU32(list.size());
    for (final T element : list) {
      this.write(element);
    }
    return (Self)this;
  }

  default public @NonNull <T> Self writeBoolean(final boolean value) {
    return this.writeU8(value ? 1 : 0);
  }

  default public @NonNull <T> Self writeOptional(final @NonNull Optional<T> optional) {
    if (optional.isPresent()) {
      this.writeU8(1);
      return this.write(optional.get());
    }
    else {
      return this.writeU8(0);
    }
  }

  default public @NonNull Self writeBuffer(final @NonNull BorshBuffer buffer) {
    return this.write(buffer.toByteArray());  // TODO: optimize
  }

  public @NonNull Self write(final @NonNull byte[] bytes);

  public @NonNull Self write(final byte b);
}

'''
'''--- src/main/java/org/near/borshj/BorshReader.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import static java.util.Objects.requireNonNull;

import androidx.annotation.NonNull;
import java.io.Closeable;
import java.io.EOFException;
import java.io.InputStream;
import java.io.IOException;

public class BorshReader implements BorshInput, Closeable {
  private final InputStream stream;

  public BorshReader(final @NonNull InputStream stream) {
    this.stream = requireNonNull(stream);
  }

  @Override
  public void close() throws IOException {
    this.stream.close();
  }

  @Override
  public byte read() {
    try {
      final int result = this.stream.read();
      if (result == -1) {
        throw new EOFException();
      }
      return (byte)result;
    }
    catch (final IOException error) {
      throw new RuntimeException(error);
    }
  }

  @Override
  public void read(final @NonNull byte[] result, final int offset, final int length) {
    if (offset < 0 || length < 0 || length > result.length - offset) {
      throw new IndexOutOfBoundsException();
    }
    try {
      int n = 0;
      while (n < length) {
        final int count = this.stream.read(result, offset + n, length - n);
        if (count == -1) {
          throw new EOFException();
        }
        n += count;
      }
    }
    catch (final IOException error) {
      throw new RuntimeException(error);
    }
  }
}

'''
'''--- src/main/java/org/near/borshj/BorshWriter.java ---
/* This is free and unencumbered software released into the public domain. */

package org.near.borshj;

import static java.util.Objects.requireNonNull;

import androidx.annotation.NonNull;
import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.io.OutputStream;

public class BorshWriter implements BorshOutput<BorshWriter>, Closeable, Flushable {
  protected final OutputStream stream;

  public BorshWriter(final @NonNull OutputStream stream) {
    this.stream = requireNonNull(stream);
  }

  @Override
  public void close() throws IOException {
    this.stream.close();
  }

  @Override
  public void flush() throws IOException {
    this.stream.flush();
  }

  @Override
  public @NonNull BorshWriter write(final @NonNull byte[] array) {
    try {
      this.stream.write(array);
      return this;
    }
    catch (final IOException error) {
      throw new RuntimeException(error);
    }
  }

  @Override
  public @NonNull BorshWriter write(final byte b) {
    try {
      this.stream.write(b);
      return this;
    }
    catch (final IOException error) {
      throw new RuntimeException(error);
    }
  }
}

'''
'''--- src/test/java/BorshBufferTests.java ---
/* This is free and unencumbered software released into the public domain. */

import static org.junit.jupiter.api.Assertions.*;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.near.borshj.BorshBuffer;

public class BorshBufferTests {
  private BorshBuffer buffer;

  @BeforeEach
  void newBuffer() {
    buffer = BorshBuffer.allocate(256);
  }

  @Test
  void readU8() {
    buffer = BorshBuffer.wrap(new byte[] {0x42});
    assertEquals(0x42, buffer.readU8());
  }

  @Test
  void readU16() {
    buffer = BorshBuffer.wrap(new byte[] {0x11, 0x00});
    assertEquals(0x0011, buffer.readU16());
  }

  @Test
  void readU32() {
    buffer = BorshBuffer.wrap(new byte[] {0x33, 0x22, 0x11, 0x00});
    assertEquals(0x00112233, buffer.readU32());
  }

  @Test
  void readU64() {
    buffer = BorshBuffer.wrap(new byte[] {0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00});
    assertEquals(0x0011223344556677L, buffer.readU64());
  }

  @Test
  void readU128() {
    final byte[] input = new byte[] {
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    buffer = BorshBuffer.wrap(input);
    assertEquals(BigInteger.valueOf(0x0011223344556677L), buffer.readU128());
  }

  @Test
  void readF32() {
    assertEquals(0.0f, BorshBuffer.wrap(new byte[] {0, 0, 0, 0}).readF32());
    assertEquals(1.0f, BorshBuffer.wrap(new byte[] {0, 0, (byte)0x80, (byte)0x3f}).readF32());
  }

  @Test
  void readF64() {
    assertEquals(0.0, BorshBuffer.wrap(new byte[] {0, 0, 0, 0, 0, 0, 0, 0}).readF64());
    assertEquals(1.0, BorshBuffer.wrap(new byte[] {0, 0, 0, 0, 0, 0, (byte)0xf0, (byte)0x3f}).readF64());
  }

  @Test
  void readString() {
    final byte[] input = new byte[] {5, 0, 0, 0, 'B', 'o', 'r', 's', 'h'};
    buffer = BorshBuffer.wrap(input);
    assertEquals("Borsh", buffer.readString());
  }

  @Test
  void readFixedArray() {
    final byte[] input = new byte[]{1, 2, 3, 4, 5};
    buffer = BorshBuffer.wrap(input);
    assertEquals(0, buffer.reset().readFixedArray(0).length);
    assertEquals(1, buffer.reset().readFixedArray(1).length);
    assertEquals(5, buffer.reset().readFixedArray(5).length);
    assertArrayEquals(input, buffer.reset().readFixedArray(5));
  }

  @Test
  void readArray() {
    final byte[] input = new byte[]{3, 0, 0, 0, 1, 0, 2, 0, 3, 0};
    buffer = BorshBuffer.wrap(input);
    assertArrayEquals(new Short[]{1, 2, 3}, buffer.readArray(Short.class));
  }

  @Test
  void readBoolean() {
    assertEquals(false, BorshBuffer.wrap(new byte[]{0}).readBoolean());
    assertEquals(true, BorshBuffer.wrap(new byte[]{1}).readBoolean());
  }

  @Test
  void readOptional() {
    assertEquals(Optional.empty(), BorshBuffer.wrap(new byte[]{0}).readOptional());
    assertEquals(Optional.of(42), BorshBuffer.wrap(new byte[]{1, 42, 0, 0, 0}).readOptional(Integer.class));
  }

  @Test
  void writeU8() {
    final byte[] actual = buffer.writeU8(0x42).toByteArray();
    final byte[] expected = new byte[] {0x42};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeU16() {
    final byte[] actual = buffer.writeU16(0x0011).toByteArray();
    final byte[] expected = new byte[] {0x11, 0x00};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeU32() {
    final byte[] actual = buffer.writeU32(0x00112233).toByteArray();
    final byte[] expected = new byte[] {0x33, 0x22, 0x11, 0x00};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeU64() {
    final byte[] actual = buffer.writeU64(0x0011223344556677L).toByteArray();
    final byte[] expected = new byte[] {
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
    };
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeU128() {
    final byte[] actual = buffer.writeU128(0x0011223344556677L).toByteArray();
    final byte[] expected = new byte[] {
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeF32() {
    final byte[] actual = buffer.writeF32(1.0f).toByteArray();
    final byte[] expected = new byte[] {0, 0, (byte)0x80, (byte)0x3f};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeF64() {
    final byte[] actual = buffer.writeF64(1.0).toByteArray();
    final byte[] expected = new byte[] {0, 0, 0, 0, 0, 0, (byte)0xf0, (byte)0x3f};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeString() {
    final byte[] actual = buffer.writeString("Borsh").toByteArray();
    final byte[] expected = new byte[] {5, 0, 0, 0, 'B', 'o', 'r', 's', 'h'};
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeFixedArray() {
    buffer.writeFixedArray(new byte[]{1, 2, 3, 4, 5});
    final byte[] expected = new byte[]{1, 2, 3, 4, 5};
    final byte[] actual = buffer.toByteArray();
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeArray() {
    buffer.writeArray(new Short[]{1, 2, 3});
    final byte[] expected = new byte[]{3, 0, 0, 0, 1, 0, 2, 0, 3, 0};
    final byte[] actual = buffer.toByteArray();
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeArrayOfList() {
    buffer.writeArray(Arrays.asList(new Short[]{1, 2, 3}));
    final byte[] expected = new byte[]{3, 0, 0, 0, 1, 0, 2, 0, 3, 0};
    final byte[] actual = buffer.toByteArray();
    assertArrayEquals(expected, actual);
  }

  @Test
  void writeBoolean() {
    assertArrayEquals(new byte[] {0}, buffer.reset().writeBoolean(false).toByteArray());
    assertArrayEquals(new byte[] {1}, buffer.reset().writeBoolean(true).toByteArray());
  }

  @Test
  void writeOptional() {
    assertArrayEquals(new byte[]{0}, buffer.reset().writeOptional(Optional.empty()).toByteArray());
    assertArrayEquals(new byte[]{1, 42, 0, 0, 0}, buffer.reset().writeOptional(Optional.of(42)).toByteArray());
  }

  @Test
  void testF32() {
    final float value = 3.1415f;
    assertEquals(value, BorshBuffer.wrap(buffer.writeF32(value).toByteArray()).readF32());
  }

  @Test
  void testF64() {
    final double value = 3.1415;
    assertEquals(value, BorshBuffer.wrap(buffer.writeF64(value).toByteArray()).readF64());
  }
}

'''
'''--- src/test/java/BorshReaderTests.java ---
/* This is free and unencumbered software released into the public domain. */

import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayInputStream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.near.borshj.BorshReader;

public class BorshReaderTests {
  private ByteArrayInputStream input;
  private BorshReader reader;

  protected BorshReader newReader(final byte[] bytes) {
    input = new ByteArrayInputStream(bytes);
    reader = new BorshReader(input);
    return reader;
  }

  @Test
  void constructWithNull() {
    assertThrows(NullPointerException.class, () -> new BorshReader(null));
  }

  @Test
  void parseInput() {
    assertEquals("Borsh", newReader(new byte[] {5, 0, 0, 0, 'B', 'o', 'r', 's', 'h'}).readString());
  }
}

'''
'''--- src/test/java/BorshTests.java ---
/* This is free and unencumbered software released into the public domain. */

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.near.borshj.Borsh;

public class BorshTests {
  @Test
  void roundtripPoint2Df() {
    final Point2Df point = new Point2Df(123, 456);
    assertEquals(point, Borsh.deserialize(Borsh.serialize(point), Point2Df.class));
  }

  @Test
  void roundtripRect2Df() {
    final Point2Df topLeft = new Point2Df(-123, -456);
    final Point2Df bottomRight = new Point2Df(123, 456);
    final Rect2Df rect = new Rect2Df(topLeft, bottomRight);
    assertEquals(rect, Borsh.deserialize(Borsh.serialize(rect), Rect2Df.class));
  }

  static public class Point2Df implements Borsh {
    private float x;
    private float y;

    public Point2Df() {}

    public Point2Df(final float x, final float y) {
      this.x = x;
      this.y = y;
    }

    @Override
    public String toString() {
      return String.format("Point2Df(%f, %f)", this.x, this.y);
    }

    @Override
    public boolean equals(final Object object) {
      if (object == null || object.getClass() != this.getClass()) return false;
      final Point2Df other = (Point2Df)object;
      return this.x == other.x && this.y == other.y;
    }
  }

  static public class Rect2Df implements Borsh {
    private Point2Df topLeft;
    private Point2Df bottomRight;

    public Rect2Df() {}

    public Rect2Df(final Point2Df topLeft, final Point2Df bottomRight) {
      this.topLeft = topLeft;
      this.bottomRight = bottomRight;
    }

    @Override
    public String toString() {
      return String.format("Rect2Df(%s, %s)", this.topLeft.toString(), this.bottomRight.toString());
    }

    @Override
    public boolean equals(final Object object) {
      if (object == null || object.getClass() != this.getClass()) return false;
      final Rect2Df other = (Rect2Df)object;
      return this.topLeft.equals(other.topLeft) && this.bottomRight.equals(other.bottomRight);
    }
  }
}

'''
'''--- src/test/java/BorshWriterTests.java ---
/* This is free and unencumbered software released into the public domain. */

import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayOutputStream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.near.borshj.BorshWriter;

public class BorshWriterTests {
  private ByteArrayOutputStream output;
  private BorshWriter writer;

  @BeforeEach
  void newWriter() {
    output = new ByteArrayOutputStream();
    writer = new BorshWriter(output);
  }

  @Test
  void constructWithNull() {
    assertThrows(NullPointerException.class, () -> new BorshWriter(null));
  }

  @Test
  void captureOutput() {
    writer.writeString("Borsh");
    assertArrayEquals(new byte[] {5, 0, 0, 0, 'B', 'o', 'r', 's', 'h'}, output.toByteArray());
  }
}

'''
'''--- src/test/java/FuzzTests.java ---
/* This is free and unencumbered software released into the public domain. */

import static org.junit.jupiter.api.Assertions.*;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.util.Random;
import net.sf.cglib.beans.BeanGenerator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.Test;
import org.near.borshj.Borsh;

public class FuzzTests {
  static final int MAX_ITERATIONS = 1000;
  static final int MAX_RECURSION  = 2;
  static final int MAX_FIELDS     = 10;
  static final int MAX_STRING_LEN = 100;

  @Test
  void testBeanGenerator() throws Exception {
    final BeanGenerator beanGenerator = new BeanGenerator();
    beanGenerator.setSuperclass(Bean.class);
    beanGenerator.addProperty("name", String.class);
    beanGenerator.addProperty("email", String.class);
    beanGenerator.addProperty("age", Integer.class);
    beanGenerator.addProperty("twitter", Boolean.class);
    final Object bean = beanGenerator.create();
    bean.getClass().getMethod("setName", String.class).invoke(bean, "J. Random Hacker");
    bean.getClass().getMethod("setEmail", String.class).invoke(bean, "jhacker@example.org");
    bean.getClass().getMethod("setAge", Integer.class).invoke(bean, 42);
    bean.getClass().getMethod("setTwitter", Boolean.class).invoke(bean, true);
    assertEquals(bean, Borsh.deserialize(Borsh.serialize(bean), bean.getClass()));
  }

  @RepeatedTest(MAX_ITERATIONS)
  void testRandomBean(final RepetitionInfo test) throws Exception {
    final Random random = new Random(test.getCurrentRepetition());
    final Object bean = newRandomBean(random, 0);
    assertEquals(bean, Borsh.deserialize(Borsh.serialize(bean), bean.getClass()));
  }

  private Object newRandomBean(final Random random, final int level) throws Exception {
    final BeanGenerator beanGenerator = new BeanGenerator();
    beanGenerator.setSuperclass(Bean.class);
    final int fieldCount = random.nextInt(MAX_FIELDS);
    final Object[] fieldValues = new Object[fieldCount];
    for (int i = 0; i < fieldCount; i++) {
      final String fieldName = String.format("field%d", i);
      fieldValues[i] = newRandomValue(random, level);
      beanGenerator.addProperty(fieldName, fieldValues[i].getClass());
    }
    final Object bean = beanGenerator.create();
    for (int i = 0; i < fieldCount; i++) {
      final String setterName = String.format("setField%d", i);
      bean.getClass().getMethod(setterName, fieldValues[i].getClass()).invoke(bean, fieldValues[i]);
    }
    //System.err.println(bean.toString());  // DEBUG
    return bean;
  }

  private Object newRandomValue(final Random random, final int level) throws Exception {
    switch (Math.abs(random.nextInt()) % 10) {
      case 0: if (level < MAX_RECURSION) return newRandomBean(random, level + 1); else {/* fallthrough */}
      case 1: return random.nextBoolean();
      case 2: return (byte)random.nextInt(Byte.MAX_VALUE);
      case 3: return (short)random.nextInt(Short.MAX_VALUE);
      case 4: return random.nextInt();
      case 5: return random.nextLong();
      case 6: return BigInteger.valueOf(random.nextLong()).abs();
      case 7: return random.nextFloat();
      case 8: return random.nextDouble();
      case 9:
        return random.ints('a', 'z' + 1)
          .limit(random.nextInt(MAX_STRING_LEN))
          .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
          .toString();
      default: throw new AssertionError("unreachable");
    }
  }

  static public class Bean implements Borsh {
    @Override
    public String toString() {
      final StringBuilder buffer = new StringBuilder();
      buffer.append(this.getClass().getName());
      buffer.append('(');
      try {
        for (final Field field : this.getClass().getDeclaredFields()) {
          field.setAccessible(true);
          buffer.append(field.getName());
          buffer.append('=');
          buffer.append(field.get(this));
          buffer.append(',');
        }
      }
      catch (final IllegalAccessException e) {
        e.printStackTrace();
      }
      buffer.append(')');
      return buffer.toString();
    }

    @Override
    public boolean equals(final Object object) {
      if (object == null || object.getClass() != this.getClass()) return false;
      try {
        for (final Field field : this.getClass().getDeclaredFields()) {
          field.setAccessible(true);
          if (!field.get(this).equals(field.get(object))) {
            return false;
          }
        }
        return true;
      }
      catch (final IllegalAccessException e) {
        e.printStackTrace();
        return false;
      }
    }
  }
}

'''