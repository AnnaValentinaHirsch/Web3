*GitHub Repository "NearNet/nearapps-contracts"*

'''--- .cargo/config.toml ---
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]

# rustflags = [
#     # strip
#     "-C", "link-arg=-s", 
#     # lto
#     "-C", "linker-plugin-lto",
#     "-C", "linker=clang",
#     "-C", "link-arg=-fuse-ld=lld"
#     ]

'''
'''--- .github/workflows/build.yml ---
name: Build
on:
  push:
    branches:
      - main
    tags:
  pull_request:
env:
  CARGO_TERM_COLOR: always
jobs:
  # based on 
  # https://raw.githubusercontent.com/BurntSushi/ripgrep/master/.github/workflows/release.yml
  # in case a tag was set, a binary release will be made
  create-release-on-tags:
    name: Create a new release on tags
    runs-on: ubuntu-latest
    # env:
      # Set to force version number, e.g., when no tag exists.
      # RG_VERSION: TEST-0.0.0
    outputs:
      upload_url: ${{ steps.release.outputs.upload_url }}
      rg_version: ${{ env.RG_VERSION }}
    steps:
      - name: Get the release version from the tag
        shell: bash
        if: env.RG_VERSION == ''
        run: |
          # Apparently, this is the right way to get a tag name. Really?
          #
          # See: https://github.community/t5/GitHub-Actions/How-to-get-just-the-tag-name/m-p/32167/highlight/true#M1027
          echo "RG_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          echo "version is: ${{ env.RG_VERSION }}"
      - name: Create GitHub release
        if: startsWith(github.ref, 'refs/tags')
        id: release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.RG_VERSION }}
          release_name: ${{ env.RG_VERSION }}

  build:
    # in case this is a binary release, we make sure to wait
    # for any requirement
    needs: ['create-release-on-tags']
    runs-on: ubuntu-latest
    steps:
      # rust compiler for running tests
      - uses: actions/checkout@v2
      - name: Install latest stable (for linux-gnu)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: x86_64-unknown-linux-gnu
          components: rustfmt, clippy
          # override: true
      # rust compiler for creating binaries
      - name: Install latest stable (for wasm)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
          components: rustfmt, clippy
          # override: true
      # caching (cargo registry)
      - name: Cache cargo registry
        uses: actions/cache@v1
        with:
          path: ~/.cargo/registry
          key: ubuntu-latest-stable-cargo-registry-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo index)
      - name: Cache cargo index
        uses: actions/cache@v1
        with:
          path: ~/.cargo/git
          key: ubuntu-latest-stable-cargo-index-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo wasm artifacts)
      - name: Cache cargo wasm build (including docs)
        uses: actions/cache@v1
        with:
          path: target/wasm32-unknown-unknown
          key: ubuntu-latest-stable-cargo-release-target-${{ hashFiles('**/Cargo.toml') }}
      # caching (cargo testing artifacts)
      - name: Cache cargo linux-gnu build (for testing)
        uses: actions/cache@v1
        with:
          path: target/x86_64-unknown-linux-gnu
          key: ubuntu-latest-stable-cargo-release-target-${{ hashFiles('**/Cargo.toml') }}
      # build and strips the wasm binaries; copies them to ./res/
      - name: Build wasm binaries and the doc
        run: ./build.sh
      # run the tests (which depend on the binaries from ./res/)
      # TODO: activate
      # - name: Run native tests
      #   run: ./test.sh -- --nocapture
        
      # TODO: activate. Needs secrets.GITHUB_TOKEN to be configured.

      # based on 
      # https://raw.githubusercontent.com/BurntSushi/ripgrep/master/.github/workflows/release.yml
      # in case a tag was set, a binary release will be made.
      # creates a file archive containing the wasm binaries into ./contracts-(tags).tar.gz
      # - name: Build archive
      #   if: startsWith(github.ref, 'refs/tags')
      #   shell: bash
      #   run: |
      #     staging="contracts-${{ needs.create-release-on-tags.outputs.rg_version }}"
      #     mkdir -p "$staging"
      #     cp README.md "$staging/"
      #     cp res/*.wasm "$staging/"
      #     tar czf "$staging.tar.gz" "$staging"
      #     echo "ASSET=$staging.tar.gz" >> $GITHUB_ENV
      # - name: Upload release archive
      #   if: startsWith(github.ref, 'refs/tags')
      #   uses: actions/upload-release-asset@v1.0.1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     upload_url: ${{ needs.create-release-on-tags.outputs.upload_url }}
      #     asset_path: ${{ env.ASSET }}
      #     asset_name: ${{ env.ASSET }}
      #     asset_content_type: application/octet-stream
  
  # TODO: publish docs to github-pages?

'''
'''--- Cargo.toml ---
[workspace]
# include a member for each contract
members = [
  "app-exec",
  "app-wallet",
  "app-counter",
  "app-nft"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = true
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
# Nearapps Contracts

## Execute Contract

- `testnet`: `v0.naps.testnet` https://explorer.testnet.near.org/accounts/naps.testnet
- `mainnet`: `naps.near` https://explorer.mainnet.near.org/accounts/naps.near

### Interface

methods:

- `new`
- `execute`
- `add_owner`
- `remove_owner`
- `is_owner`
- `get_owners`
- `verify_msg`
- `verify_hashed_msg`

#### Initialization

method: `new`

###### Parameters

- `owner_id`: string - the account_id of who will own the contract

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

#### Execution of a Proxied Contract Call

method: `execute`

###### Parameters

- `context`: the call context.
    - `contract_call`: the contract call context.
        - `contract_id`: string - the contract's AccountId that is being called.
        - `method_name`: string - the name of the method being called.
        - `args`: string - the arguments for the method that is being called.
    - `tag_info`: the tags information.
        - `app_id`: string - app tag.
        - `action_id`: string - action number.
        - `user_id`: string - user account_id tag.
    <!-- - `public_key`: string - the public key, in base58 which an optional `{header}:` as prefix. Can be a `Ed25519` or a `Secp256k1` public key. Note: currently disabled as the message still needs to be specified. A placeholder value is being used. -->
    <!-- - `signature`: string - the signature, in base58. Can be a `Ed25519` or a `Secp256k1` signature. Note: currently disabled as the message still needs to be specified. A placeholder value is being used. -->

###### Returns

- `result` - the same return that `contract_id`'s method `method_name` with `args` would return.

###### Sample

<!-- TODO: update -->

```json
{
  "context": {
    "contract_call": {
      "contract_id": "nft.naps.testnet",
      "method_name": "nft_transfer_from",
      "args": "\"token_id\": \"1\", \"sender_id\": \"my-account.testnet\", \"receiver_id\": \"my-friend.testnet\", \"approval_id\": \"4711\""
    }
  }
}
```

#### Owners Management

methods:

- `add_owner`
- `remove_owner`
- `is_owner`
- `get_owners`

##### Add Owner

method: `add_owner`

###### Parameters

- `owner_id`: string - the account_id of who will also own the contract

###### Returns

- `added`: boolean - whether the account was newly added as an owner.

###### Sample

<!-- TODO: update -->

```json
{
}
```

##### Remove Owner

method: `remove_owner`

###### Parameters

- `owner_id`: string - the account_id of who will stop owning the contract

###### Returns

- `removed`: boolean - whether the account was just removed as an owner.

###### Sample

<!-- TODO: update -->

```json
{
}
```

##### Check Owner

method: `is_owner`

###### Parameters

- `owner_id`: string - the account_id which the owning status is being checked

###### Returns

- `is_owner`: boolean - whether the account is an owner.

###### Sample

<!-- TODO: update -->

```json
{
}
```

##### Get Owners

method: `get_owner`

###### Parameters

No parameters required.

###### Returns

- `owners`: string[] - list of account_ids of the owners.

###### Sample

<!-- TODO: update -->

```json
{
}
```

#### Verification of a Message

method: `verify_msg`

###### Parameters

- `sign`: string - the signature, in base58. Can be a `Ed25519` or a `Secp256k1` signature.
- `pubkey`: string - the public key, in base58 with an optional `{header}:` as prefix. Can be a `Ed25519` or
  a `Secp256k1` public key. On a missing prefix, `ed25519:` is assumed.
- `msg`: string - the message. It will be hashed internally by the contract.

###### Returns

- `is_match`: boolean - whether the sha256 hash of the `msg` matched the `pubkey` on the `sign`.

###### Sample

```json
{
  "sign": "26gFr4xth7W9K7HPWAxq3BLsua8oTy378mC1MYFiEXHBBpeBjP8WmJEJo8XTBowetvqbRshcQEtBUdwQcAqDyP8T",
  "pubkey": "ed25519:AYWv9RAN1hpSQA4p1DLhCNnpnNXwxhfH9qeHN8B4nJ59",
  "msg": "message"
}
```

#### Verification of a Prehashed Message

method: `verify_hashed_msg`

###### Parameters

- `sign`: string - the signature, in base58. Can be a `Ed25519` or a `Secp256k1` signature.
- `pubkey`: string - the public key, in base58 with an optional `{header}:` as prefix. Can be a `Ed25519` or
  a `Secp256k1` public key. On a missing prefix, `ed25519:` is assumed.
- `msg_hash`: number[] - the message hash, in a 32-sized array of bytes, resulted from a sha256 hash of them message.

###### Returns

- `is_match`: boolean - whether the `msg_hash` matched the `pubkey` on the `sign`.

###### Sample

```json
{
  "sign": "26gFr4xth7W9K7HPWAxq3BLsua8oTy378mC1MYFiEXHBBpeBjP8WmJEJo8XTBowetvqbRshcQEtBUdwQcAqDyP8T",
  "pubkey": "ed25519:AYWv9RAN1hpSQA4p1DLhCNnpnNXwxhfH9qeHN8B4nJ59",
  "msg_hash": [171, 83, 10, 19, 228, 89, 20, 152, 43, 121, 249, 183, 227, 251, 169, 148, 207, 209, 243, 251, 34, 247, 28, 234, 26, 251, 240, 43, 70, 12, 109, 29]
}
```

## Wallet Creation

<!-- TODO: update -->

- `testnet`: ``
- `mainnet`: ``

### Interface

methods:

- `new`
- `create_account`

<!-- - `create_subaccount` -->

#### Initialization

method: `new`

###### Parameters

- `owner_id`: string - owner account id that will be allowed to make other calls into this contract

<!-- - `defaults`: Object - the default parameters to be used during account creation.
    - `initial_amount`: string - the default initial amount to attach to created accounts, in yoctoNear.
    - `allowance`: string - the default allowance to attach to allowed calls on created accounts, in yoctoNear.
    - `allowed_calls`: Object[] - the default allowed calls that new accounts are able to make.
        - `allowance`: optional string - the user's allowance for when calling a contract. If missing, defaults to the `defaults.allowance`.
        - `receiver_id`: string - the contract address that the user is allowed to call into.
        - `method_names`: string[] - list of method names (eg. `["method_a", "method_b"]`) that the user is allowed to call on `receiver_id` contract. An empty list means all methods. -->

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

#### Account Creation

<!-- TODO: update -->

note: not tested.

method: `create_account`

###### Parameters

- `new_account_id`: string - the account_id that is being created
- `new_public_key`: optional string - the new account owner public key, in base58 with an optional `{header}:` as
  prefix. Can be a `Ed25519` or a `Secp256k1` public key. On a missing prefix, `ed25519:` is assumed. This value may be
  generated by the user. If missing, defaults to the transaction signer's public key.

<!-- - `config`: Object - account configuration for the user that is being created.
    - `account_id`: string - the sub-account that is being created. Expected to be a sub-account on `.testnet` or `.near`.
    - `user_public_key`: string - the user/sub-account public key, in base58 with an optional `{header}:` as prefix. Can be a `Ed25519` or a `Secp256k1` public key. On a missing prefix, `ed25519:` is assumed. This value may be generated by the user.
    - `initial_amount`: optional string - the initial  amount of deposit that the user should receive. If missing, defaults to `defaults.initial_amount`.
- `allowed_calls`: optional Object[] - call information that the user is allowed to make. If missing, defaults to `defaults.allowed_calls`. If is an empty list, the user will not be allowed to call any contract.
    - `allowance`: optional string - the user's allowance for when calling a contract. If missing, defaults to the `defaults.allowance`.
    - `receiver_id`: string - the contract address that the user is allowed to call into.
    - `method_names`: string[] - list of method names (eg. `["method_a", "method_b"]`) that the user is allowed to call on `receiver_id` contract. An empty list means all methods. -->

###### Returns

- `account_created`: boolean - whether the account was successfully created.

###### Sample

<!-- TODO: update -->

```json
{
}
```

<!-- 
#### Sub-Account Creation

note: not tested.

method: `create_subaccount`

###### Parameters

- `config`: Object - account configuration for the user that is being created.
    - `account_id`: string - the sub-account that is being created. It will be postfixed with the wallet's account automatically.
    - `user_public_key`: string - the user/sub-account public key, in base58 with an optional `{header}:` as prefix. Can be a `Ed25519` or a `Secp256k1` public key. On a missing prefix, `ed25519:` is assumed. This value may be generated by the user.
    - `initial_amount`: optional string - the initial  amount of deposit that the user should receive. If missing, defaults to `defaults.initial_amount`.
- `allowed_calls`: optional Object[] - call information that the user is allowed to make. If missing, defaults to `defaults.allowed_calls`. If is an empty list, the user will not be allowed to call any contract.
    - `allowance`: optional string - the user's allowance for when calling a contract. If missing, defaults to the `defaults.allowance`.
    - `receiver_id`: string - the contract address that the user is allowed to call into.
    - `method_names`: string[] - list of method names (eg. `["method_a", "method_b"]`) that the user is allowed to call on `receiver_id` contract. An empty list means all methods.

###### Returns

- `account_created`: boolean - whether the accoutn was successfully created.

###### Sample

```json
{
}
``` -->

## NFT

Contract Address:

- `testnet`: `nft.naps.testnet` https://explorer.testnet.near.org/accounts/nft.naps.testnet
- `mainnet`: `nft.naps.near` not yet deployed

### Interface

methods:

- `new`
- `new_default_meta`
- `nft_mint`
- `nft_transfer`
- `nft_transfer_call`
- `nft_token`
- `nft_approve`
- `nft_revoke`
- `nft_revoke_all`
- `nft_is_approved`
- `nft_total_supply`
- `nft_tokens`
- `nft_supply_for_owner`
- `nft_tokens_for_owner`
- `nft_metadata`
- `nft_series_create`
- `nft_series_mint`
- `nft_series_get`
- `nft_series_get_minted_tokens_vec`
- `nft_series_set_mintable`
- `nft_series_set_capacity`

#### Initialization

method: `new`

###### Parameters

- `owner_id`: string - the account_id of who will own the contract
- `metadata`: object - the standard nft metadata
    - `spec`: stirng - eg. "nft-1.0.0"
    - `name`: string - eg. "Mosaics"
    - `symbol`: string - eg. "MOSIAC"
    - `icon`: optional string - data URL
    - `base_uri`: optional string - centralized gateway known to have reliable access to decentralized storage assets
      referenced by `reference` or `media` URLs
    - `reference`: optional string - URL to a JSON file with more info
    - `reference_hash`: optional string - base64-encoded sha256 hash of JSON from reference field. Required
      if `reference` is included.

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

#### Initialization with a default Meta

method: `new_default_meta`

###### Parameters

- `owner_id`: string - the account_id of who will own the contract

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

#### NFT Minting

method: `nft_mint`

###### Parameters

- `token_id`: string - the name of the token. Cannot contain the series delimiter (`:`).
- `token_owner_id`: string - the account_id of who will receive the token.
- `token_metadata`: object - the standard nft token metadata.
    - `title`: optional string - the title of the token, eg. "Arch Nemesis: Mail Carrier" or "Parcel #5055".
    - `description`: optional string - free-form description.
    - `media`: optional string - URL to associated media, preferably to decentralized, content-addressed storage.
    - `media_hash`: optional stirng - Base64-encoded sha256 hash of content referenced by the `media` field. Required
      if `media` is included.
    - `copies`: optional string - number of copies of this set of metadata in existence when token was minted.
    - `issued_at`: optional string - ISO 8601 datetime when token was issued or minted.
    - `expires_at`: optional string - ISO 8601 datetime when token expires.
    - `starts_at`: optional string - ISO 8601 datetime when token starts being valid. -`updated_at`: optional string -
      ISO 8601 datetime when token was last updated.
    - `extra`: optional string - anything extra the NFT wants to store on-chain. Can be stringified JSON.
    - `reference`: optional string - URL to an off-chain JSON file with more info.
    - `reference_hash`: optional string - Base64-encoded sha256 hash of JSON from reference field. Required
      if `reference` is included.

###### Returns

- `token`: object - the standard nft token information.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

#### Standard NFT Operations

methods:

- `nft_transfer`
- `nft_transfer_call`
- `nft_token`
- `nft_resolve_transfer`
- `nft_approve`
- `nft_revoke`
- `nft_revoke_all`
- `nft_is_approved`
- `nft_total_supply`
- `nft_tokens`
- `nft_supply_for_owner`
- `nft_tokens_for_owner`
- `nft_metadata`

##### Transfer

method: `nft_transfer`

###### Parameters

- `token_id`: string - the token id to give allowance on.
- `receiver_id`: string - the account to allow token transfer.
- `approval_id`: optional number - the approval id from `nft_approve_from`.
- `memo`: optional string.

###### Sample

```json
{
  "token_id": "1",
  "receiver_id": "my-friend.testnet"
}
```

###### Returns

- `success`: bool - was the transfer successful or not

###### Nearapps API Sample

<!-- TODO: update -->

```bash
curl --location --request POST 'https://api.nearapps.net/testnet/v1/execute' \
--header 'x-api-key: <api key>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "message": "{\"contract_id\":\"nft.naps.testnet\",\"method_name\":\"nft_transfer_from\",\"args\": \"{\"token_id\":\"1\",\"sender_id\":\"my-account.testnet\", \"receiver_id\":\"my-friend.testnet\"}\",
    "signed": {
        "signature": "4FJecZiY22ReWiJHxCSjDw71Jyd8WVgkkeNfH1Zj21uhQEV1c7QQ4bQYc7QMgH3Tcz5LxYJMxPYuHoETN8i4sQNq",
        "publicKey": "ed25519:D5d84XpgHtTUHwg1hbvT3Ljy6LpeLnJhU34scBC1TNKp"
    }
}'
```

##### Transfer Call

method: `nft_transfer_call`

###### Parameters

- `token_id`: string - the token id to give allowance on
- `receiver_id`: string - the account to allow token transfer

###### Sample

```json
{
  "token_id": "1",
  "receiver_id": "my-friend.testnet"
}
```

###### Returns

- `success`: bool - was the transfer successful or not

###### Nearapps API Sample

<!-- TODO: update -->

```bash
curl --location --request POST 'https://api.nearapps.net/testnet/v1/execute' \
--header 'x-api-key: <api key>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "message": "{\"contract_id\":\"nft.naps.testnet\",\"method_name\":\"nft_transfer_from\",\"args\": \"{\"token_id\":\"1\",\"sender_id\":\"my-account.testnet\", \"receiver_id\":\"my-friend.testnet\"}\",
    "signed": {
        "signature": "4FJecZiY22ReWiJHxCSjDw71Jyd8WVgkkeNfH1Zj21uhQEV1c7QQ4bQYc7QMgH3Tcz5LxYJMxPYuHoETN8i4sQNq",
        "publicKey": "ed25519:D5d84XpgHtTUHwg1hbvT3Ljy6LpeLnJhU34scBC1TNKp"
    }
}'
```

##### Approval

method: `nft_approve`

###### Parameters

- `token_id`: string - the token id to give allowance on
- `account_id`: string - the account to allow token transfer
- `msg`: optional string.

###### Sample

```json
{
  "token_id": "1",
  "account_id": "my-friend.testnet"
}
```

###### Returns

- `approval_id`: the id of the approval

###### Nearapps API Sample

<!-- TODO: update -->

```bash
curl --location --request POST 'https://api.nearapps.net/testnet/v1/execute' \
--header 'x-api-key: <api key>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "message": "{\"contract_id\":\"nft.naps.testnet\",\"method_name\":\"nft_approve_from\",\"args\": \"{\"token_id\":\"1\",\"account_id\":\"my-friend.testnet\"}\"}",
    "sender": "my-account.testnet",
    "signed": {
        "signature": "4FJecZiY22ReWiJHxCSjDw71Jyd8WVgkkeNfH1Zj21uhQEV1c7QQ4bQYc7QMgH3Tcz5LxYJMxPYuHoETN8i4sQNq",
        "publicKey": "ed25519:D5d84XpgHtTUHwg1hbvT3Ljy6LpeLnJhU34scBC1TNKp"
    }
}'
```

##### Check Approval

method: `nft_is_approved`

###### Parameters

- `token_id`: string - the token id to check allowance on
- `approved_account_id`: string.
- `approval_id`: optional number.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Returns

- `is_approved`: boolean - whether it is approved.

###### Nearapps API Sample

<!-- TODO: update -->

```bash

```

##### Revoke

method: `nft_revoke`

###### Parameters

- `token_id`: string - the token id to revoke allowance on
- `account_id`: string - the account to disallow token transfer

###### Sample

```json
{
  "token_id": "1",
  "account_id": "my-friend.testnet"
}
```

###### Returns

Has no returns.

###### Nearapps API Sample

<!-- TODO: update -->

```bash
curl --location --request POST 'https://api.nearapps.net/testnet/v1/execute' \
--header 'x-api-key: <api key>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "message": "{\"contract_id\":\"nft.naps.testnet\",\"method_name\":\"nft_revoke_from\",\"args\": \"{\"token_id\":\"1\",\"account_id\":\"my-friend.testnet\"}\"}",
    "sender": "my-account.testnet",
    "signed": {
        "signature": "4FJecZiY22ReWiJHxCSjDw71Jyd8WVgkkeNfH1Zj21uhQEV1c7QQ4bQYc7QMgH3Tcz5LxYJMxPYuHoETN8i4sQNq",
        "publicKey": "ed25519:D5d84XpgHtTUHwg1hbvT3Ljy6LpeLnJhU34scBC1TNKp"
    }
}'
```

##### Revoke All

method: `nft_revoke`

###### Parameters

- `token_id`: string - the token id to revoke allowance on

###### Sample

```json
{
  "token_id": "1"
}
```

###### Returns

Has no return.

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

#### NFT Series Operations

methods:

- `nft_series_create`
- `nft_series_mint`
- `nft_series_get`
- `nft_series_get_minted_tokens_vec`
- `nft_series_set_mintable`
- `nft_series_set_capacity`

##### NFT Series Creation

method: `nft_series_create`

###### Parameters

- `name`: string - the name of the token series
- `capacity`: string - the maximum number of the of tokens that can be minted
- `creator`: string - the account_id of the creator, used for informing

###### Returns

- `series_id`: string - a number representing the id of the created series.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

##### NFT Series Token Minting

method: `nft_series_mint`

###### Parameters

- `series_id`: string - the series id number
- `token_owner_id`: string - the account_id of who will receive the token.
- `token_metadata`: optional object - the standard nft token metadata.

###### Returns

- `token`: object - the standard nft token information.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

##### NFT Series Query

method: `nft_series_get`

###### Parameters

- `series_id`: string - the series id number

###### Returns

- `series`: object - nft series information.
    - `id`: string - the series id number,
    - `name`: string
    - `creator`: string - the account_id of the creator
    - `len`: string - the number of minted tokens
    - `capacity`: string - the number of how many tokens can be minted
    - `is_mintable`: boolean - whether the series can be minted

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

##### NFT Series Token List

method: `nft_series_get_minted_tokens_vec`

###### Parameters

- `series_id`: string - the series id number

###### Returns

- `token_ids`: string[] - a list containing the token_id number that were minted under the series.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

##### NFT Series Set Mintable

method: `nft_series_set_mintable`

###### Parameters

- `series_id`: string - the series id number.
- `is_mintable`: boolean - choose whether it will be mintable or not.

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

##### NFT Series Set Capacity

method: `nft_series_set_capacity`

###### Parameters

- `series_id`: string - the series id number.
- `capacity`: string - choose the number of what the capacity will be.

###### Returns

Has no returns.

###### Sample

<!-- TODO: update -->

```json
{
}
```

###### Reference Metadata JSON Sample

<!-- TODO: update -->

```json
{
}
```

###### Nearapps API Sample

<!-- TODO: update -->

```bash
```

'''
'''--- app-counter/Cargo.toml ---
[package]
name = "nearapps-counter"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"

'''
'''--- app-counter/README.md ---
# Counter App

Based on [near-examples/rust-counter](https://github.com/near-examples/rust-counter), this is a dummy project to be used during tests.

Has an internal counter that can be incremented, decremented, and so on.
'''
'''--- app-counter/build.sh ---
#!/usr/bin/env bash

set -ex

cargo +stable build --target wasm32-unknown-unknown --release

cp ../target/wasm32-unknown-unknown/release/nearapps_counter.wasm ../res/

'''
'''--- app-counter/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, Gas, Promise, PromiseOrValue};

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    val: u8,
}

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

#[near_sdk::ext_contract(ext_self)]
pub trait ExtSelf {
    fn increment() -> u8;
    fn call_until(value: u8, target: u8) -> u8;
}

#[near_bindgen]
impl Counter {
    pub fn get(&self) -> u8 {
        self.val
    }

    pub fn increment(&mut self) -> u8 {
        self.val += 1;
        self.val
    }

    pub fn decrement(&mut self) -> u8 {
        self.val -= 1;
        self.val
    }

    pub fn reset(&mut self) {
        self.val = 0;
    }

    pub fn set(&mut self, val: u8) {
        self.val = val;
    }

    // return multiple values
    pub fn min_max() -> (u8, u8) {
        (u8::MIN, u8::MAX)
    }

    // returns promise
    /// Makes an `increment()` call into itself.
    #[allow(clippy::let_and_return)]
    pub fn call_increment() -> near_sdk::Promise {
        const GAS_CURRENT: Gas = Gas(5 * TERA);
        let gas = env::prepaid_gas() - env::used_gas() - GAS_CURRENT;

        let call = ext_self::increment(
            // calling into itself
            env::current_account_id(),
            // deposit
            0,
            // gas
            gas,
        );
        call
    }

    pub fn log(&self) -> u8 {
        env::log_str(&self.val.to_string());
        self.val
    }

    #[payable]
    pub fn deposit(&mut self, increment: bool) -> u8 {
        if increment {
            let attached = env::attached_deposit();
            assert!(attached <= u8::MAX as u128);
            self.val += attached as u8;
        }
        self.val
    }

    #[payable]
    #[allow(clippy::let_and_return)]
    pub fn withdraw(&mut self, qty: u8, decrement: bool) -> Promise {
        if decrement {
            self.val -= qty as u8;
        }
        let transfer = Promise::new(env::predecessor_account_id())
            //
            .transfer(qty as u128);
        transfer
    }

    /// Calls repeteadly into itself until `value`
    /// reaches `target`.
    pub fn call_until(value: u8, target: u8) -> near_sdk::PromiseOrValue<u8> {
        const GAS_CURRENT: Gas = Gas(5 * TERA);
        let gas = env::prepaid_gas() - env::used_gas() - GAS_CURRENT;

        if value >= target {
            PromiseOrValue::Value(value)
        } else {
            let call = ext_self::call_until(
                //
                value + 1,
                target,
                env::current_account_id(),
                0,
                gas,
            );
            PromiseOrValue::Promise(call)
        }
    }
}

'''
'''--- app-counter/tests/test_counter.rs ---
#![allow(clippy::ref_in_deref)]

pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk_sim::{call, deploy, init_simulator, view, ContractAccount, UserAccount};
use nearapps_counter::CounterContract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    COUNTER_WASM_BYTES => "../res/nearapps_counter.wasm",
}

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

fn init(root: &UserAccount) -> ContractAccount<CounterContract> {
    let counter: ContractAccount<CounterContract> = deploy!(
        contract: CounterContract,
        contract_id: "counter".to_string(),
        bytes: &COUNTER_WASM_BYTES,
        signer_account: root
    );

    counter
}

#[test]
fn simulate_increment() {
    let root = init_simulator(None);
    let counter = init(&root);

    let mut current_num: i8 = view!(counter.get()).unwrap_json();
    assert_eq!(&current_num, &0);

    call!(root, counter.increment()).assert_success();

    current_num = view!(counter.get()).unwrap_json();
    assert_eq!(&current_num, &1);
}

'''
'''--- app-exec/Cargo.toml ---
[package]
name = "nearapps-exec"
version = "0.1.0"
authors = ["Sebastian Gerske <13647606+H34D@users.noreply.github.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}
sha2 = "0.9.0"
digest = "0.9.0"
strum = "0.23"
strum_macros = "0.23"

[dependencies.k256]
# version = "0.10.0-pre.1"
version = "0.9.6"
default-features = false
features = ["arithmetic", "ecdsa"]
# features = ["arithmetic", "ecdsa", "pkcs8", "sha256"]
git = "https://github.com/nearcomponents/elliptic-curves"
rev = "c8cae83"
# branch = "0.9.6-no-rand"

[dependencies.ecdsa]
version = "0.12.1"
default-features = false
# features = ["der"]
git = "https://github.com/nearcomponents/signatures"
rev = "e054a2c"
# branch = "0.12.1-no-rand"

# [dependencies.elliptic-curve]
# version = "0.10.5"
# default-features = false
# features = ["hazmat"]
# git = "https://github.com/nearcomponents/traits"
# rev = "f6c1d86"
# # branch = "0.10.5-no-rand"

# crypto: eddsa on ed25519
[dependencies.ed25519-dalek]
version = "1.0.1"
default-features = false
features = ["u64_backend"]

# to de/serialize [u8; u64] arrays
[dependencies.serde-big-array]
version = "0.3.2"
default-features = false
features = ["const-generics"]

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"
nearapps-counter = { path = "../app-counter" }

# hash: sha256
[dev-dependencies.bitcoin_hashes]
version = "0.10.0"
default-features = false
features = ["std", "serde-std"]

# crypto: ecdsa on secp256k1
[dev-dependencies.secp256k1]
version = "0.20.3"
# path = "../rust-secp256k1/"
default-features = false
# features = ["std", "recovery", "serde", "lowmemory"]
features = ["alloc", "recovery", "serde"]

# [profile.release]
# codegen-units = 1
# # Tell `rustc` to optimize for small code size.
# opt-level = "z"
# lto = true
# debug = false
# panic = "abort"
# # Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
# overflow-checks = true

'''
'''--- app-exec/build.sh ---
#!/usr/bin/env bash

set -ex

cargo +stable build --target wasm32-unknown-unknown --release

cp ../target/wasm32-unknown-unknown/release/nearapps_exec.wasm ../res/

'''
'''--- app-exec/src/crypto.rs ---
use crate::Executor;
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

pub mod ecdsa_secp256k1;
pub mod eddsa_ed25519;

pub use ecdsa_secp256k1::types::PubKeyUncompressedNoHeader as EcdsaSecp256k1PublicKey;
pub use ecdsa_secp256k1::types::SignRecoverable as EcdsaSecp256k1Signature;

pub use eddsa_ed25519::types::PubKey as EddsaEd25519PublicKey;
pub use eddsa_ed25519::types::Sign as EddsaEd25519Signature;

#[near_bindgen]
impl Executor {
    // TODO: write comments
    //
    // signature verification that is compatible to Near
    pub fn verify_hashed_msg(
        sign: Bs58EncodedSignature,
        pubkey: NearEncodedPubkey,
        msg_hash: crate::hash::Sha256,
    ) -> bool {
        let pubkey = pubkey.parse();
        Self::verify_inner(sign, pubkey, msg_hash)
    }

    /// Verifies if `pubkey` matches `sign` with the `sha256` hash of
    /// the `msg`.
    ///
    /// Note: Internally the hashed msg is hashed again by the
    /// signature verification algorithm. This is compatible with
    /// Near's behavior.
    pub fn verify_msg(sign: Bs58EncodedSignature, pubkey: NearEncodedPubkey, msg: String) -> bool {
        let msg_hash = {
            use digest::Digest;
            let mut sha2_hash = sha2::Sha256::new();
            sha2_hash.update(msg.as_bytes());
            let sha2_hash = sha2_hash.finalize();

            let mut arr = [0; 32];
            arr.copy_from_slice(sha2_hash.as_slice());
            crate::hash::Sha256(arr)
        };
        let pubkey = pubkey.parse();
        Self::verify_inner(sign, pubkey, msg_hash)
    }
}

impl Executor {
    /// Note: Internally the hashed msg is hashed again by the
    /// signature verification algorithm. This is compatible with
    /// Near's behavior.
    pub fn verify_inner(
        sign: Bs58EncodedSignature,
        pubkey: near_sdk::PublicKey,
        msg_hash: crate::hash::Sha256,
    ) -> bool {
        use near_sdk::CurveType;
        let sign = sign.decode();
        match (pubkey.curve_type(), sign.len()) {
            (CurveType::ED25519, 64) => {
                let mut sign_raw = [0; 64];
                sign_raw.copy_from_slice(&sign[0..64]);
                let sign = EddsaEd25519Signature(sign_raw);

                let pubkey: EddsaEd25519PublicKey = pubkey.into();

                // note: msg_hash will be hashed again internally, this is
                // compatible with Near's behavior.
                Executor::eddsa_ed25519_verify(pubkey, sign, &msg_hash.0)
            }
            (CurveType::SECP256K1, 65) => {
                let mut sign_raw = [0; 65];
                sign_raw.copy_from_slice(&sign[0..65]);
                let sign = EcdsaSecp256k1Signature(sign_raw);
                let sign: ecdsa_secp256k1::types::SignCompact = sign.into();

                let pubkey: EcdsaSecp256k1PublicKey = pubkey.into();
                let pubkey: ecdsa_secp256k1::types::PubKeyUncompressed = pubkey.into();

                // note: msg_hash will be hashed again internally, this is
                // compatible with Near's behavior.
                Executor::ecdsa_secp256k1_verify_uncompressed_msg_bytes(pubkey, sign, &msg_hash.0)
            }
            (curve_type, sign_len) => panic!(
                "Wrong sign length of {} for the curve type {:?}",
                sign_len, curve_type
            ),
        }
    }
}

#[derive(
    near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug, Default,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct NearEncodedPubkey(pub String);

impl NearEncodedPubkey {
    pub fn parse(&self) -> near_sdk::PublicKey {
        self.0.parse().unwrap()
    }
}

impl From<String> for NearEncodedPubkey {
    fn from(s: String) -> Self {
        Self(s)
    }
}

#[derive(
    near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug, Default,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct Bs58EncodedSignature(pub String);

impl Bs58EncodedSignature {
    pub fn decode(&self) -> Vec<u8> {
        near_sdk::bs58::decode(&self.0).into_vec().unwrap()
    }
    pub fn encode(bytes: &[u8]) -> Self {
        Self(near_sdk::bs58::encode(bytes).into_string())
    }
}

impl From<String> for Bs58EncodedSignature {
    fn from(s: String) -> Self {
        Self(s)
    }
}

impl From<EddsaEd25519Signature> for Bs58EncodedSignature {
    fn from(sign: EddsaEd25519Signature) -> Self {
        Self::encode(&sign.0)
    }
}

'''
'''--- app-exec/src/crypto/ecdsa_secp256k1.rs ---
use crate::Executor;
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

pub mod sign;
pub mod types;
pub mod verify;

#[near_bindgen]
impl Executor {
    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    //
    /// Creates a Public Key serialized in compressed form.
    ///
    /// Has a total size of 33 bytes.
    pub fn secp256k1_pubkey_compressed(seckey: types::SecKey) -> types::PubKeyCompressed {
        let seckey = k256::SecretKey::from_bytes(&seckey.0).unwrap();
        let pubkey = seckey.public_key();
        pubkey.into()
    }

    /// Creates a Public Key serialized in uncompressed form.
    ///
    /// Has a total size of 65 bytes.
    pub fn secp256k1_pubkey_uncompressed(seckey: types::SecKey) -> types::PubKeyUncompressed {
        let seckey = k256::SecretKey::from_bytes(&seckey.0).unwrap();
        let pubkey = seckey.public_key();
        pubkey.into()
    }
}

'''
'''--- app-exec/src/crypto/ecdsa_secp256k1/sign.rs ---
use super::types;
use crate::Executor;
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

#[near_bindgen]
impl Executor {
    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    //
    /// Creates a `sha256` hash of the `msg` and signs it
    /// using `ecdsa` on `secp256k1`.
    ///
    /// Signing is deterministic and the "pseudo-random" value `k` depends
    /// only on the hash of the combination of `seckey` and the hash of
    /// `msg`.
    /// See [rfc6979](https://datatracker.ietf.org/doc/html/rfc6979) for more info.
    ///
    /// To avoid generating signatures that may have malleability issues,
    /// they are explicitly
    /// [normalized](k256::ecdsa::Signature::normalize_s()) to
    /// the lower-S form.
    ///
    /// Returns the signature in serialized compact form.
    /// Has a total size of 64-bytes.
    pub fn ecdsa_secp256k1_sign(seckey: types::SecKey, msg: String) -> types::SignCompact {
        let seckey = k256::SecretKey::from_bytes(&seckey.0).unwrap();
        let signing_key = k256::ecdsa::SigningKey::from(seckey);
        let mut sign: k256::ecdsa::Signature = {
            use k256::ecdsa::signature::DigestSigner;
            use sha2::Digest;
            let digest = digest::Digest::chain(sha2::Sha256::new(), msg);
            signing_key.try_sign_digest(digest).unwrap()
        };
        sign.normalize_s().unwrap();
        sign.into()
    }

    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    //
    /// Creates a `sha256` hash of the `msg` and signs it
    /// using `ecdsa` on `secp256k1`.  
    /// This creates a recoverable signature, ie. the PublicKey
    /// can be recovered from the signature and the original message.
    ///
    /// Signing is deterministic and the "pseudo-random" value `k` depends
    /// only on the hash of the combination of `seckey` and the hash of
    /// `msg`.
    /// See [rfc6979](https://datatracker.ietf.org/doc/html/rfc6979) for more info.
    ///
    /// TODO: re-check this:
    /// To avoid generating signatures that may have malleability issues,
    /// they are explicitly
    /// [normalized](k256::ecdsa::Signature::normalize_s()) to
    /// the lower-S form.
    ///
    /// TODO: re-check this:
    /// Returns the signature in serialized compact form.
    /// Has a total size of 64-bytes.
    pub fn ecdsa_secp256k1_sign_recoverable(
        seckey: types::SecKey,
        msg: String,
    ) -> types::SignRecoverable {
        let seckey = k256::SecretKey::from_bytes(&seckey.0).unwrap();
        let signing_key = k256::ecdsa::SigningKey::from(seckey);
        let sign: k256::ecdsa::recoverable::Signature = {
            use k256::ecdsa::signature::DigestSigner;
            use sha2::Digest;
            let digest = digest::Digest::chain(sha2::Sha256::new(), msg);
            signing_key.try_sign_digest(digest).unwrap()
        };

        // asserts it's in the lower-s form
        let mut without_recovery_id: k256::ecdsa::Signature = sign.into();
        let without_recovery_id_original = without_recovery_id;
        without_recovery_id.normalize_s().unwrap();
        if without_recovery_id != without_recovery_id_original {
            near_sdk::env::panic_str("ERR_ECDSA_SECP256K1_SIGN_NON_LOWER_S");
        }

        // TODO: check if nearcore/sdk only allows the recovery id
        // to be zero

        sign.into()
    }
}

'''
'''--- app-exec/src/crypto/ecdsa_secp256k1/types.rs ---
/// Private Key value.
///
/// Has a total size of 32 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct SecKey(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 32],
);

/// Public Key serialized in compressed form.  
/// Instead of having both `x` and `y` values, only `x` is present,
/// as `y` can be derived from that.
///
/// Has a total size of 33 bytes, containing:
///
/// - `header` (1-byte);
///   - If `y` was even, the `header` is `0x02`;
///   - If `y` was odd, the `header` is `0x03`.
/// - `x` (32-bytes).
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct PubKeyCompressed(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 33],
);

impl From<k256::PublicKey> for PubKeyCompressed {
    fn from(pubkey: k256::PublicKey) -> Self {
        use k256::elliptic_curve::group::GroupEncoding;
        let pubkey = pubkey.as_affine().to_bytes();
        assert_eq!(pubkey.as_slice().len(), 33);
        let mut res = [0; 33];
        res.copy_from_slice(&pubkey.as_slice()[0..33]);
        PubKeyCompressed(res)
    }
}

// TODO: check if the order is x,y or y,x
//
/// Public Key serialized in extended form.  
/// Contains both `x` and `y` values.
///
/// Has a total size of 65 bytes, containing:
///
/// - `header` (1-byte, with value `0x04`);
/// - `x` (32-bytes).
/// - `y` (32-bytes).
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct PubKeyUncompressed(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 65],
);

impl From<k256::PublicKey> for PubKeyUncompressed {
    fn from(pubkey: k256::PublicKey) -> Self {
        use k256::elliptic_curve::sec1::ToEncodedPoint;
        let affine = pubkey.as_affine();
        let compress = false;
        let pubkey = affine.to_encoded_point(compress);
        let pubkey = pubkey.as_bytes();
        assert_eq!(pubkey.len(), 65);
        let mut res = [0; 65];
        res.copy_from_slice(&pubkey[0..65]);
        PubKeyUncompressed(res)
    }
}

// TODO: check if the order is x,y or y,x
//
/// Public Key serialized in extended form.  
/// Contains both `x` and `y` values.
///
/// Has a total size of 64 bytes, containing:
///
/// - `x` (32-bytes).
/// - `y` (32-bytes).
///
/// This is similar to [`PubKeyUncompressed`] except that
/// there is no `header`.  
/// When re-adding the header, it is always assumed to be `0x04`, as
/// demonstrated in [nearcore](https://github.com/near/nearcore/blob/22e997b559a75a07ed8cd2781e9acc0758d16aaf/core/crypto/src/signature.rs#L751).
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct PubKeyUncompressedNoHeader(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 64],
);

impl From<k256::PublicKey> for PubKeyUncompressedNoHeader {
    fn from(pubkey: k256::PublicKey) -> Self {
        use k256::elliptic_curve::sec1::ToEncodedPoint;
        let affine = pubkey.as_affine();
        let compress = false;
        let pubkey = affine.to_encoded_point(compress);
        let pubkey = pubkey.as_bytes();
        assert_eq!(pubkey.len(), 65);

        let mut res = [0; 64];
        // skips the header (first byte)
        res.copy_from_slice(&pubkey[1..65]);
        PubKeyUncompressedNoHeader(res)
    }
}

impl From<near_sdk::PublicKey> for PubKeyUncompressedNoHeader {
    fn from(pubkey: near_sdk::PublicKey) -> Self {
        use near_sdk::CurveType;
        match pubkey.curve_type() {
            CurveType::ED25519 => panic!("wrong pubkey type"),
            CurveType::SECP256K1 => {
                let pubkey = pubkey.as_bytes();
                assert_eq!(pubkey.len(), 1 + 64);
                let mut res = [0; 64];
                res.copy_from_slice(&pubkey[1..]);
                Self(res)
            }
        }
    }
}

impl From<PubKeyUncompressedNoHeader> for PubKeyUncompressed {
    fn from(pubkey: PubKeyUncompressedNoHeader) -> Self {
        // re-insert the header (0x04) as the first byte
        let mut pubkey_raw = [0x04; 1 + 64];
        (&mut pubkey_raw[1..]).copy_from_slice(&pubkey.0);
        PubKeyUncompressed(pubkey_raw)
    }
}

/// Signature in serialized compact form.
///
/// Has a total size of 64 bytes, containing:
///
/// - `r` (32-bytes big-endian);
/// - `s` (32-bytes big-endian).
///
/// See also: [`k256::ecdsa::Signature`].
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct SignCompact(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 64],
);

impl From<k256::ecdsa::Signature> for SignCompact {
    fn from(sign: k256::ecdsa::Signature) -> Self {
        use k256::ecdsa::signature::Signature;
        let mut res = [0u8; 64];
        assert_eq!(sign.as_bytes().len(), 64);
        res.copy_from_slice(&sign.as_bytes()[0..64]);
        SignCompact(res)
    }
}

/// Recoverable signature in serialized form.
///
/// Has a total size of 65 bytes, containing:
///
/// - `r` (32-bytes big-endian);
/// - `s` (32-bytes big-endian).
/// - `recovery_id` (1-byte)
///
/// See also: [`k256::ecdsa::recoverable::Signature`].
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct SignRecoverable(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 65],
);

impl From<k256::ecdsa::recoverable::Signature> for SignRecoverable {
    fn from(sign: k256::ecdsa::recoverable::Signature) -> Self {
        use k256::ecdsa::signature::Signature;
        let mut res = [0u8; 65];
        assert_eq!(sign.as_bytes().len(), 65);
        res.copy_from_slice(&sign.as_bytes()[0..65]);
        SignRecoverable(res)
    }
}

impl From<SignRecoverable> for SignCompact {
    fn from(sign: SignRecoverable) -> Self {
        use ecdsa::signature::Signature;
        let sign = k256::ecdsa::recoverable::Signature::from_bytes(&sign.0).unwrap();
        let sign: k256::ecdsa::Signature = sign.into();
        sign.into()
    }
}

'''
'''--- app-exec/src/crypto/ecdsa_secp256k1/verify.rs ---
use super::types;
use crate::{hash, Executor};
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

#[near_bindgen]
impl Executor {
    /// Returns `true` if `pubkey` authenticates the
    /// `sign` of the `msg_hash`.  
    /// Returns `false` otherwise.
    ///
    /// The `msg` is hashed using `sha256` and that is used
    /// to verify the signature's authenticity.
    pub fn ecdsa_secp256k1_verify_compressed_msg(
        pubkey: types::PubKeyCompressed,
        sign: types::SignCompact,
        msg: String,
    ) -> bool {
        Self::ecdsa_secp256k1_verify(&pubkey.0, sign, msg.as_bytes())
    }

    pub fn ecdsa_secp256k1_verify_uncompressed_msg(
        pubkey: types::PubKeyUncompressed,
        sign: types::SignCompact,
        msg: String,
    ) -> bool {
        Self::ecdsa_secp256k1_verify(&pubkey.0, sign, msg.as_bytes())
    }

    /// Returns `true` if `pubkey` authenticates the
    /// `sign` of the `sha256` hash of the `msg`.  
    /// Returns `false` otherwise.
    ///
    /// The `msg_hash` must be the result of a `sha256` of the msg,
    /// and must have a total size of 32-bytes.
    pub fn ecdsa_secp256k1_verify_prehashed_compressed(
        pubkey: types::PubKeyCompressed,
        sign: types::SignCompact,
        hashed_msg: hash::Sha256,
    ) -> bool {
        Self::ecdsa_secp256k1_verify_prehashed(&pubkey.0, sign, hashed_msg)
    }

    /// Returns `true` if `pubkey` authenticates the
    /// `sign` of the `sha256` hash of the `msg`.  
    /// Returns `false` otherwise.
    ///
    /// The `msg_hash` must be the result of a `sha256` of the msg,
    /// and must have a total size of 32-bytes.
    pub fn ecdsa_secp256k1_verify_prehashed_uncompressed(
        pubkey: types::PubKeyUncompressed,
        sign: types::SignCompact,
        hashed_msg: hash::Sha256,
    ) -> bool {
        Self::ecdsa_secp256k1_verify_prehashed(&pubkey.0, sign, hashed_msg)
    }
}

impl Executor {
    /// Returns `true` if `pubkey` authenticates the
    /// `sign` of the `msg_hash`.  
    /// Returns `false` otherwise.
    ///
    /// The `msg` is hashed using `sha256` and that is used
    /// to verify the signature's authenticity.
    pub fn ecdsa_secp256k1_verify(
        pubkey: &[u8],
        sign: types::SignCompact,
        msg_bytes: &[u8],
    ) -> bool {
        // this is able to read both compressed and uncompressed pubkeys
        let pubkey = k256::PublicKey::from_sec1_bytes(pubkey).unwrap();

        let hashed_msg = {
            use ecdsa::hazmat::FromDigest;
            let hashed_msg = hash::Sha256::hash_bytes(msg_bytes);
            k256::Scalar::from_digest(hashed_msg)
        };

        let sign = {
            use k256::ecdsa::signature::Signature;
            k256::ecdsa::Signature::from_bytes(&sign.0).unwrap()
        };

        {
            use ecdsa::hazmat::VerifyPrimitive;
            pubkey
                .as_affine()
                .verify_prehashed(&hashed_msg, &sign)
                .is_ok()
        }
    }

    pub fn ecdsa_secp256k1_verify_compressed_msg_bytes(
        pubkey: types::PubKeyCompressed,
        sign: types::SignCompact,
        msg_bytes: &[u8],
    ) -> bool {
        Self::ecdsa_secp256k1_verify(&pubkey.0, sign, msg_bytes)
    }

    pub fn ecdsa_secp256k1_verify_uncompressed_msg_bytes(
        pubkey: types::PubKeyUncompressed,
        sign: types::SignCompact,
        msg_bytes: &[u8],
    ) -> bool {
        Self::ecdsa_secp256k1_verify(&pubkey.0, sign, msg_bytes)
    }

    /// Returns `true` if `pubkey` authenticates the
    /// `sign` of the `sha256` hash of the `msg`.  
    /// Returns `false` otherwise.
    ///
    /// The `msg_hash` must be the result of a `sha256` of the msg,
    /// and must have a total size of 32-bytes.
    pub fn ecdsa_secp256k1_verify_prehashed(
        pubkey: &[u8],
        sign: types::SignCompact,
        hashed_msg: hash::Sha256,
    ) -> bool {
        let pubkey = k256::PublicKey::from_sec1_bytes(pubkey).unwrap();

        let hashed_msg = {
            use ecdsa::hazmat::FromDigest;
            k256::Scalar::from_digest(hashed_msg)
        };

        let sign = {
            use k256::ecdsa::signature::Signature;
            k256::ecdsa::Signature::from_bytes(&sign.0).unwrap()
        };

        {
            use ecdsa::hazmat::VerifyPrimitive;
            pubkey
                .as_affine()
                .verify_prehashed(&hashed_msg, &sign)
                .is_ok()
        }
    }
}

'''
'''--- app-exec/src/crypto/eddsa_ed25519.rs ---
use crate::Executor;
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

pub mod sign;
pub mod types;
pub mod verify;

#[near_bindgen]
impl Executor {
    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    //
    pub fn ed25519_pubkey(seckey: types::SecKey) -> types::PubKey {
        let seckey = ed25519_dalek::SecretKey::from_bytes(&seckey.0).unwrap();
        let pubkey: ed25519_dalek::PublicKey = (&seckey).into();
        pubkey.into()
    }
}

'''
'''--- app-exec/src/crypto/eddsa_ed25519/sign.rs ---
use super::types;
use crate::{hash, Executor};
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

#[near_bindgen]
impl Executor {
    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    //
    pub fn eddsa_ed25519_sign(seckey: types::SecKey, msg: String) -> types::Sign {
        let seckey = ed25519_dalek::SecretKey::from_bytes(&seckey.0).unwrap();
        let pubkey: ed25519_dalek::PublicKey = (&seckey).into();
        let keypair = ed25519_dalek::Keypair {
            secret: seckey,
            public: pubkey,
        };
        let sign: ed25519_dalek::Signature = {
            use ed25519_dalek::Signer;
            keypair.sign(msg.as_bytes())
        };
        sign.into()
    }

    // TODO: hide behing a feature as this will not
    // be needed as a near app.
    pub fn eddsa_ed25519_sign_prehashed(
        seckey: types::SecKey,
        msg_hash: hash::Sha512,
        context: Option<String>,
    ) -> types::SignPrehashed {
        let seckey = ed25519_dalek::SecretKey::from_bytes(&seckey.0).unwrap();
        let pubkey: ed25519_dalek::PublicKey = (&seckey).into();
        let keypair = ed25519_dalek::Keypair {
            secret: seckey,
            public: pubkey,
        };
        let context = context.as_ref().map(|s| s.as_bytes());
        let sign: ed25519_dalek::Signature = keypair.sign_prehashed(msg_hash, context).unwrap();
        sign.into()
    }
}

'''
'''--- app-exec/src/crypto/eddsa_ed25519/types.rs ---
use std::convert::TryFrom;

// todo: replace this by an extended key, as this
// is what nearcore uses
//
/// Private Key value.
///
/// Has a total size of 32 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct SecKey(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; ed25519_dalek::SECRET_KEY_LENGTH],
);

/// Public Key value.  
///
/// Has a total size of 32 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct PubKey(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; ed25519_dalek::PUBLIC_KEY_LENGTH],
);

impl From<ed25519_dalek::PublicKey> for PubKey {
    fn from(pubkey: ed25519_dalek::PublicKey) -> Self {
        PubKey(pubkey.to_bytes())
    }
}

impl From<PubKey> for ed25519_dalek::PublicKey {
    fn from(val: PubKey) -> Self {
        ed25519_dalek::PublicKey::from_bytes(&val.0).unwrap()
    }
}

impl From<near_sdk::PublicKey> for PubKey {
    fn from(pubkey: near_sdk::PublicKey) -> Self {
        use near_sdk::CurveType;
        match pubkey.curve_type() {
            CurveType::ED25519 => {
                let pubkey = pubkey.as_bytes();
                assert_eq!(pubkey.len(), ed25519_dalek::PUBLIC_KEY_LENGTH + 1);
                let mut res = [0; ed25519_dalek::PUBLIC_KEY_LENGTH];
                res.copy_from_slice(&pubkey[1..]);
                PubKey(res)
            }
            CurveType::SECP256K1 => panic!("wrong pubkey type"),
        }
    }
}

impl std::convert::TryFrom<PubKey> for near_sdk::PublicKey {
    type Error = <near_sdk::PublicKey as TryFrom<Vec<u8>>>::Error;
    fn try_from(pubkey: PubKey) -> Result<Self, Self::Error> {
        let mut res = Vec::with_capacity(ed25519_dalek::PUBLIC_KEY_LENGTH + 1);
        res.push(near_sdk::CurveType::ED25519 as u8);
        res.extend_from_slice(&pubkey.0);
        near_sdk::PublicKey::try_from(res)
    }
}

/// Signature in serialized form.
///
/// Has a total size of 64 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct Sign(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 64],
);

impl From<ed25519_dalek::Signature> for Sign {
    fn from(sign: ed25519_dalek::Signature) -> Self {
        Sign(sign.to_bytes())
    }
}

/// Signature in serialized form, formed from a prehashed message.  
/// Note that this Signature itself is not "prehashed".
///
/// A [`Sign`] that is formed from a non-prehashed message _m_ will
/// use the `Ed25519` algorithm, while a [`SignPrehashed`] that is
/// formed from a prehashed _m_ will use the `Ed25519ph` algorithm.  
/// This results in different and incompatible signatures. The
/// verification also uses different algorithms, so `Ed25519` cannot
/// be used to verify a [`SignPrehashed`] and `Ed25519ph` cannot be
/// used to verify a [`Sign`].
///
/// Note that in case of `ecdsa-secp256k1`, the same algorithm is used
/// (ie. the hashing is "transparent") and the resulting signatures
/// _are_ the same.
///
/// Has a total size of 64 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct SignPrehashed(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 64],
);

impl From<ed25519_dalek::Signature> for SignPrehashed {
    fn from(sign: ed25519_dalek::Signature) -> Self {
        SignPrehashed(sign.to_bytes())
    }
}

'''
'''--- app-exec/src/crypto/eddsa_ed25519/verify.rs ---
use super::types;
use crate::{hash, Executor};
use near_sdk::near_bindgen;

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

#[near_bindgen]
impl Executor {
    pub fn eddsa_ed25519_verify_bytes(
        pubkey: types::PubKey,
        sign: types::Sign,
        msg_bytes: Vec<u8>,
    ) -> bool {
        Self::eddsa_ed25519_verify(pubkey, sign, &msg_bytes)
    }

    pub fn eddsa_ed25519_verify_msg(pubkey: types::PubKey, sign: types::Sign, msg: String) -> bool {
        Self::eddsa_ed25519_verify(pubkey, sign, &msg.as_bytes())
    }

    pub fn eddsa_ed25519_verify_prehashed(
        pubkey: types::PubKey,
        sign: types::SignPrehashed,
        msg_hash: hash::Sha512,
        context: Option<String>,
    ) -> bool {
        let pubkey = ed25519_dalek::PublicKey::from_bytes(&pubkey.0).unwrap();
        let sign = ed25519_dalek::Signature::from_bytes(&sign.0).unwrap();
        let context = context.as_ref().map(|s| s.as_bytes());
        pubkey.verify_prehashed(msg_hash, context, &sign).is_ok()
    }
}

impl Executor {
    pub fn eddsa_ed25519_verify(
        pubkey: types::PubKey,
        sign: types::Sign,
        msg_bytes: &[u8],
    ) -> bool {
        let pubkey = ed25519_dalek::PublicKey::from_bytes(&pubkey.0).unwrap();
        let sign = ed25519_dalek::Signature::from_bytes(&sign.0).unwrap();

        {
            use ed25519_dalek::Verifier;
            pubkey.verify(msg_bytes, &sign).is_ok()
        }
    }
}

'''
'''--- app-exec/src/error.rs ---
use strum_macros::Display;

/// User-facing errors.
///
/// This maps error variants into error messages.  
/// If a user makes use of some interface incorrectly,
/// this should be used with [`near_sdk::env::panic_str()`].
///
/// Otherwise, if some internal error occurred such that it would
/// indicate an internal bug, then `[panic!()]` should be used
/// as it prints line code information that would be useful for
/// debugging and fixing the problem.
#[derive(Debug, Display)]
pub enum Error {
    #[strum(serialize = "ERR_EXEC_ALREADY_INITIALIZED")]
    AlreadyInitialized,
    /// A call that was supposed to be made by the owner was made
    /// by a different predecessor.
    #[strum(serialize = "ERR_EXEC_NOT_OWNER")]
    NotOwner,
    /// Tried to make a call for this contract itself.
    ///
    /// It's safer to disallow this since this could
    /// bypass some private function protection.
    ///
    /// Otherwise if it's necessary to call a private function,
    /// a specific interface with the correct checking should be
    /// added instead.
    #[strum(serialize = "ERR_EXEC_CALL_CURRENT")]
    CallCurrentAccount,
}

impl Error {
    /// Calls [`near_sdk::env::panic_str()`] with this error's message.
    pub fn panic(&self) -> ! {
        near_sdk::env::panic_str(&self.to_string())
    }
}

pub trait OrPanicStr {
    type Target;
    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target;
}

impl<T, E> OrPanicStr for Result<T, E> {
    type Target = T;

    fn or_panic_str<Err: ToString>(self, error: Err) -> Self::Target {
        self.unwrap_or_else(|_| near_sdk::env::panic_str(&error.to_string()))
    }
}

impl<T> OrPanicStr for Option<T> {
    type Target = T;

    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target {
        self.unwrap_or_else(|| near_sdk::env::panic_str(&error.to_string()))
    }
}

pub fn ensure<E: ToString>(expr: bool, error: E) {
    match expr {
        true => (),
        false => near_sdk::env::panic_str(&error.to_string()),
    }
}

'''
'''--- app-exec/src/exec.rs ---
#![allow(clippy::let_and_return)]

use crate::error::{ensure, Error};
use crate::Executor;
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, ext_contract, near_bindgen, serde_json, AccountId, Promise, PromiseResult};

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

#[ext_contract(ext_self)]
pub trait ExtSelf {
    /// Executes an external contract's function, logging on the callback
    /// and forwarding the calls result back.
    ///
    /// Only forwards the first result.
    fn check_promise(tag_info: TagInfo) -> Vec<u8>;
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractCall {
    pub contract_id: AccountId,
    pub method_name: String,
    pub args: String,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CallContext {
    pub contract_call: ContractCall,
    //
    pub tag_info: TagInfo,
    //
    // pub public_key: near_sdk::PublicKey,
    // pub signature: crate::crypto::Bs58EncodedSignature,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TagInfo {
    pub app_id: String,
    pub action_id: U64,
    pub user_id: AccountId,
}

#[near_bindgen]
impl Executor {
    /// Executes an external contract's function, logging on the callback
    /// and forwarding the calls result back.
    ///
    /// Only forwards the first result.
    #[payable]
    pub fn execute(&mut self, context: CallContext) -> Promise {
        self.assert_owner();

        // makes sure it won't call an internal private function
        ensure(
            context.contract_call.contract_id != env::current_account_id(),
            Error::CallCurrentAccount,
        );

        Promise::new(context.contract_call.contract_id)
            .function_call(
                context.contract_call.method_name,
                context.contract_call.args.as_bytes().to_vec(),
                env::attached_deposit(),
                env::prepaid_gas() / 3,
            )
            .then(ext_self::check_promise(
                context.tag_info,
                env::current_account_id(),
                0,
                env::prepaid_gas() / 3,
            ))
    }

    /// Checks the first result of an external call that was made,
    /// forwarding the first promise result as the value result.
    ///
    /// Logs on successful promise.
    #[private]
    pub fn check_promise(tag_info: TagInfo) {
        let ret = match env::promise_result(0) {
            PromiseResult::Successful(val) => val,
            _ => env::panic_str("Promise with index 0 failed"),
        };
        env::log_str(&serde_json::to_string(&tag_info).unwrap());
        env::value_return(&ret);
    }
}

'''
'''--- app-exec/src/hash.rs ---
use crate::Executor;
use near_sdk::{env, near_bindgen};

#[cfg(not(target_arch = "wasm32"))]
use crate::ExecutorContract;

/// Sha256 value.
///
/// Has a total size of 32 bytes.
#[derive(
    near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug, Default,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct Sha256(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 32],
);

impl Sha256 {
    pub fn hash_bytes(msg_bytes: &[u8]) -> Self {
        // TODO: check if using `env` actually saves gas cost
        // (although it should save storage cost)
        let hash = near_sdk::env::sha256(msg_bytes);
        let hash = hash.as_slice();
        assert_eq!(hash.len(), 32);
        let mut res = [0u8; 32];
        res.copy_from_slice(hash);
        Sha256(res)
    }
}

// needed so this is a Digest
impl digest::BlockInput for Sha256 {
    type BlockSize = digest::consts::U64;
}

// needed so this is a Digest
// but this is not needed for sign verification
impl digest::Update for Sha256 {
    fn update(&mut self, _input: impl AsRef<[u8]>) {
        unimplemented!();
    }
}

// needed so this is a Digest
// but this is not needed for sign verification
impl digest::Reset for Sha256 {
    fn reset(&mut self) {
        unimplemented!();
    }
}

// needed so this is a Digest
// this is needed for sign verification
impl digest::FixedOutputDirty for Sha256 {
    type OutputSize = digest::consts::U32;

    fn finalize_into_dirty(&mut self, out: &mut digest::Output<Self>) {
        out.copy_from_slice(&self.0);
    }
}

/// Sha512 value.
///
/// Has a total size of 64 bytes.
#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
#[serde(transparent)]
pub struct Sha512(
    #[serde(with = "serde_big_array::BigArray")]
    //
    pub [u8; 64],
);

impl Sha512 {
    pub fn hash_bytes(msg_bytes: &[u8]) -> Self {
        use sha2::Digest;
        let mut hash = sha2::Sha512::new();
        hash.update(msg_bytes);
        let hash = hash.finalize();
        let mut res = [0u8; 64];
        res.copy_from_slice(hash.as_slice());
        Sha512(res)
    }
}

impl Default for Sha512 {
    fn default() -> Self {
        Sha512([0; 64])
    }
}

// needed so this is a Digest
impl digest::BlockInput for Sha512 {
    type BlockSize = digest::consts::U128;
}

// needed so this is a Digest
// but this is not needed for sign verification
impl digest::Update for Sha512 {
    fn update(&mut self, _input: impl AsRef<[u8]>) {
        unimplemented!();
    }
}

// needed so this is a Digest
// but this is not needed for sign verification
impl digest::Reset for Sha512 {
    fn reset(&mut self) {
        unimplemented!();
    }
}

// needed so this is a Digest
// this is not needed for sign verification
impl digest::FixedOutputDirty for Sha512 {
    type OutputSize = digest::consts::U64;

    fn finalize_into_dirty(&mut self, out: &mut digest::Output<Self>) {
        out.copy_from_slice(&self.0);
    }
}

#[near_bindgen]
impl Executor {
    /// Generates a `sha256` hash of the given bytes.
    ///
    /// The returned hash has a total size of 32-bytes.
    ///
    /// See also: [`Self::hash_sha256_msg`]
    pub fn hash_sha256(msg_bytes: Vec<u8>) -> Sha256 {
        let hash = env::sha256(&msg_bytes);
        let hash = hash.as_slice();
        assert_eq!(hash.len(), 32);
        let mut res = [0u8; 32];
        res.copy_from_slice(hash);
        Sha256(res)
    }

    /// Generates a `sha256` hash of the byte-repesentation of the
    /// given `msg`.
    ///
    /// The returned hash has a total size of 32-bytes.
    ///
    /// See also: [`Self::hash_sha256`]
    pub fn hash_sha256_msg(msg: String) -> Sha256 {
        let hash = env::sha256(msg.as_bytes());
        let hash = hash.as_slice();
        assert_eq!(hash.len(), 32);
        let mut res = [0u8; 32];
        res.copy_from_slice(hash);
        Sha256(res)
    }

    /// Generates a `sha512` hash of the given bytes.
    ///
    /// The returned hash has a total size of 64-bytes.
    ///
    /// See also: [`Self::hash_sha512_msg`]
    pub fn hash_sha512(msg_bytes: Vec<u8>) -> Sha512 {
        Sha512::hash_bytes(&msg_bytes)
    }

    /// Generates a `sha512` hash of the byte-repesentation of the
    /// given `msg`.
    ///
    /// The returned hash has a total size of 64-bytes.
    ///
    /// See also: [`Self::hash_sha512`]
    pub fn hash_sha512_msg(msg: String) -> Sha512 {
        Sha512::hash_bytes(msg.as_bytes())
    }
}

'''
'''--- app-exec/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault};

pub mod crypto;
pub mod error;
pub mod exec;
pub mod hash;

use error::{ensure, Error};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Executor {
    owner_ids: UnorderedSet<AccountId>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Owners,
}

#[near_bindgen]
impl Executor {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        ensure(!env::state_exists(), Error::AlreadyInitialized);
        let mut owner_ids = UnorderedSet::new(StorageKey::Owners);
        owner_ids.insert(&owner_id);
        Self { owner_ids }
    }
}

impl Executor {
    fn assert_owner(&self) {
        ensure(
            self.owner_ids.contains(&env::predecessor_account_id()),
            Error::NotOwner,
        )
    }
}

pub trait Owners {
    fn add_owner(&mut self, owner_id: AccountId) -> bool;

    /// Removes a owner.  
    ///
    /// Returns `true` if such owner was removed.  
    /// Returns `false` if the owner wasn't added in the first place.
    fn remove_owner(&mut self, owner_id: AccountId) -> bool;

    /// Checks if the given account is an owner.  
    ///
    /// Returns `true` if it is, and `false` otherwise.
    fn is_owner(&self, owner_id: AccountId) -> bool;

    /// Show owners.
    ///
    /// Returns a list of `AccountId`'s.
    fn get_owners(&self) -> Vec<AccountId>;
}

#[near_bindgen]
impl Owners for Executor {
    /// Adds a new owner.  
    ///
    /// Returns `true` if it's a newly added owner.  
    /// Returns `false` if the owner was already added.
    fn add_owner(&mut self, owner_id: AccountId) -> bool {
        self.assert_owner();
        self.owner_ids.insert(&owner_id)
    }

    /// Removes a owner.  
    ///
    /// Returns `true` if such owner was removed.  
    /// Returns `false` if the owner wasn't added in the first place.
    fn remove_owner(&mut self, owner_id: AccountId) -> bool {
        self.assert_owner();
        self.owner_ids.remove(&owner_id)
    }

    /// Checks if the given account is an owner.  
    ///
    /// Returns `true` if it is, and `false` otherwise.
    fn is_owner(&self, owner_id: AccountId) -> bool {
        self.owner_ids.contains(&owner_id)
    }

    /// Show owners.
    ///
    /// Returns a list of `AccountId`'s.
    fn get_owners(&self) -> Vec<AccountId> {
        self.owner_ids.iter().collect()
    }
}

'''
'''--- app-exec/tests/test_ecdsa_secp256k1.rs ---
#![allow(clippy::ref_in_deref)]

use crate::utils::{_secp256k1, setup_exec, TERA};
use near_sdk_sim::{call, init_simulator};

mod utils;

#[test]
fn test_ecdsa_secp256k1() {
    use nearapps_exec::{crypto::ecdsa_secp256k1 as ec, hash};

    let root = init_simulator(None);
    let contract = setup_exec(&root);

    let seckey = [
        59, 148, 11, 85, 134, 130, 61, 253, 2, 174, 59, 70, 27, 180, 51, 107, 94, 203, 174, 253,
        102, 39, 170, 146, 46, 252, 4, 143, 236, 12, 136, 28,
    ];

    let seckey = ec::types::SecKey(seckey);

    // generates the pubkey on the contract
    let pubkey_compressed: ec::types::PubKeyCompressed = {
        let res = call!(&root, contract.secp256k1_pubkey_compressed(seckey.clone()));
        assert!(res.gas_burnt().0 < 33 * TERA);
        res.unwrap_json()
    };
    let pubkey_compressed = &pubkey_compressed;
    let expected_pubkey = [
        2, 29, 21, 35, 7, 198, 183, 43, 14, 208, 65, 139, 14, 112, 205, 128, 231, 245, 41, 91, 141,
        134, 245, 114, 45, 63, 82, 19, 251, 210, 57, 79, 54,
    ];
    assert_eq!(pubkey_compressed.0, expected_pubkey);

    let pubkey_uncompressed: ec::types::PubKeyUncompressed = {
        let res = call!(
            &root,
            contract.secp256k1_pubkey_uncompressed(seckey.clone())
        );
        assert!(res.gas_burnt().0 < 33 * TERA);
        res.unwrap_json()
    };
    let pubkey_uncompressed = &pubkey_uncompressed;

    let msg = "This is some message";

    // sign the message on the contract
    let sign: ec::types::SignCompact = {
        let res = call!(
            &root,
            contract.ecdsa_secp256k1_sign(seckey.clone(), msg.to_string())
        );
        assert!(res.gas_burnt().0 < 45 * TERA);
        res.unwrap_json()
    };
    let sign = &sign;

    // copy and change the resulting signature
    // (so we have one that is wrong)
    let bad_sign = {
        let mut bad_sign = sign.clone();
        bad_sign.0[0] += 1;
        bad_sign
    };
    let bad_sign = &bad_sign;
    assert!(sign != bad_sign);

    // ok: verifies the msg's signature with the pubkey
    let verify1: bool = {
        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_compressed_msg(
                pubkey_compressed.clone(),
                sign.clone(),
                msg.to_string()
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(verify1);

    // fail: pass in the wrong signature
    let bad_verify1: bool = {
        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_compressed_msg(
                pubkey_compressed.clone(),
                bad_sign.clone(),
                msg.to_string()
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(!bad_verify1);

    // ok: verifies without sending the msg (only it's hash)
    let verify2: bool = {
        // ok: get the hash.
        // could be generated locally, without using the contract
        let res = call!(&root, contract.hash_sha256(msg.as_bytes().to_vec()));
        assert!(res.gas_burnt().0 < 3 * TERA);
        let msg_hash: hash::Sha256 = res.unwrap_json();

        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_prehashed_compressed(
                pubkey_compressed.clone(),
                sign.clone(),
                msg_hash
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(verify2);

    // fail: same, but pass in the wrong signature
    let bad_verify2: bool = {
        // ok: get the hash.
        // could be generated locally, without using the contract
        let res = call!(&root, contract.hash_sha256(msg.as_bytes().to_vec()));
        assert!(res.gas_burnt().0 < 3 * TERA);
        let msg_hash: hash::Sha256 = res.unwrap_json();

        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_prehashed_compressed(
                pubkey_compressed.clone(),
                bad_sign.clone(),
                msg_hash
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(!bad_verify2);

    // ok: verifies the msg's signature with the uncompressed pubkey
    let verify3: bool = {
        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_uncompressed_msg(
                pubkey_uncompressed.clone(),
                sign.clone(),
                msg.to_string()
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(verify3);

    // fail: same, but pass in the wrong signature
    let bad_verify3: bool = {
        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_uncompressed_msg(
                pubkey_uncompressed.clone(),
                bad_sign.clone(),
                msg.to_string()
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(!bad_verify3);

    // ok: verifies the msg's signature with the uncompressed pubkey
    // verifies without sending the msg (only it's hash)
    let verify4: bool = {
        // ok: get the hash.
        // could be generated locally, without using the contract
        let res = call!(&root, contract.hash_sha256(msg.as_bytes().to_vec()));
        assert!(res.gas_burnt().0 < 3 * TERA);
        let msg_hash: hash::Sha256 = res.unwrap_json();

        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_prehashed_uncompressed(
                pubkey_uncompressed.clone(),
                sign.clone(),
                msg_hash
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(verify4);

    // fail: same, but pass in the wrong signature
    let bad_verify4: bool = {
        // ok: get the hash.
        // could be generated locally, without using the contract
        let res = call!(&root, contract.hash_sha256(msg.as_bytes().to_vec()));
        assert!(res.gas_burnt().0 < 3 * TERA);
        let msg_hash: hash::Sha256 = res.unwrap_json();

        let res = call!(
            &root,
            contract.ecdsa_secp256k1_verify_prehashed_uncompressed(
                pubkey_uncompressed.clone(),
                bad_sign.clone(),
                msg_hash
            )
        );
        assert!(res.gas_burnt().0 < 65 * TERA);
        res.unwrap_json()
    };
    assert!(!bad_verify4);

    // ok: sanity assertions with rust-secp256k1
    // (this is linked to the same library that bitcoin uses)
    {
        use _secp256k1 as s;
        use nearapps_exec::hash::Sha256;

        // ok: pubkeys match
        let pubkey2 = s::gen_pubkey(seckey.clone());
        assert_eq!(pubkey_compressed.0, pubkey2.serialize());

        let msg_hash: Sha256 =
            call!(&root, contract.hash_sha256(msg.as_bytes().to_vec())).unwrap_json();

        // ok: sha256 match (using sha2 library)
        {
            use digest::Digest;
            let mut sha2_hash = sha2::Sha256::new();
            sha2_hash.update(msg.as_bytes());
            let sha2_hash = sha2_hash.finalize();
            assert_eq!(sha2_hash[..], msg_hash.0);
        }

        let msg_hash = bitcoin_hashes::Hash::from_inner(msg_hash.0);

        // ok: it's signing match
        let sign2 = s::ecdsa_secp256k1_sign_hashed(seckey, msg_hash);
        assert_eq!(sign, &sign2);
    }
}

'''
'''--- app-exec/tests/test_eddsa_ed25519.rs ---
#![allow(clippy::ref_in_deref)]

use crate::utils::{setup_exec, TERA};
use near_sdk_sim::{call, init_simulator};

mod utils;

#[allow(clippy::zero_prefixed_literal)]
#[test]
fn test_eddsa_ed25519() {
    use nearapps_exec::{crypto::eddsa_ed25519 as ed, hash};

    let root = init_simulator(None);
    let contract = setup_exec(&root);

    // the msg is an empty string
    let msg = "";
    let msg_bytes: &[u8] = msg.as_bytes();

    let seckey_bytes: [u8; 32] = [
        062, 070, 027, 163, 092, 182, 011, 003, 077, 234, 098, 004, 011, 127, 079, 228, 243, 187,
        150, 073, 201, 137, 076, 022, 085, 251, 152, 002, 241, 042, 072, 054,
    ];

    let expected_pubkey_bytes: [u8; 32] = [
        130, 039, 155, 015, 062, 076, 188, 063, 124, 122, 026, 251, 233, 253, 225, 220, 014, 041,
        166, 120, 108, 035, 254, 077, 160, 083, 172, 058, 219, 042, 086, 120,
    ];

    // Signature with the above keypair of a blank message.
    let expected_sign_bytes: [u8; 64] = [
        010, 126, 151, 143, 157, 064, 047, 001, 196, 140, 179, 058, 226, 152, 018, 102, 160, 123,
        080, 016, 210, 086, 196, 028, 053, 231, 012, 157, 169, 019, 158, 063, 045, 154, 238, 007,
        053, 185, 227, 229, 079, 108, 213, 080, 124, 252, 084, 167, 216, 085, 134, 144, 129, 149,
        041, 081, 063, 120, 126, 100, 092, 059, 050, 011,
    ];

    // ok: get the pub key using the contract
    let pubkey: ed::types::PubKey = {
        let seckey = ed::types::SecKey(seckey_bytes);
        let res = call!(&root, contract.ed25519_pubkey(seckey));
        assert!(res.gas_burnt().0 < 13 * TERA);
        res.unwrap_json()
    };
    assert_eq!(pubkey.0, expected_pubkey_bytes);

    // ok: sign the msg using the contract
    let sign: ed::types::Sign = {
        let seckey = ed::types::SecKey(seckey_bytes);
        let res = call!(&root, contract.eddsa_ed25519_sign(seckey, msg.to_string()));
        assert!(res.gas_burnt().0 < 23 * TERA);
        res.unwrap_json()
    };
    assert_eq!(sign.0, expected_sign_bytes);

    // ok: get the msg hash (to be used by prehashed calls)
    let msg_hash: hash::Sha512 = {
        let res = call!(&root, contract.hash_sha512(msg.as_bytes().to_vec()));
        assert!(res.gas_burnt().0 < 3 * TERA);
        res.unwrap_json()
    };
    // ok: confirms that it matches with directly using sha2 library
    {
        use digest::Digest;
        let mut sha2_hash = sha2::Sha512::new();
        sha2_hash.update(msg.as_bytes());
        let sha2_hash = sha2_hash.finalize();
        assert_eq!(&sha2_hash[..], &msg_hash.0);
    }

    // ok: sign the prehashed version
    // note: this results in a different signature from the normal sign!
    let prehashed_sign: ed::types::SignPrehashed = {
        let seckey = ed::types::SecKey(seckey_bytes);

        let res = call!(
            &root,
            contract.eddsa_ed25519_sign_prehashed(seckey, msg_hash.clone(), None)
        );
        assert!(res.gas_burnt().0 < 24 * TERA);
        res.unwrap_json()
    };

    // ok: creates a bad sign, to test failure cases
    let bad_sign = {
        let mut bad_sign = sign.clone();
        bad_sign.0[0] += 1;
        bad_sign
    };
    assert!(sign != bad_sign);

    // ok: checks signature
    let verify1: bool = {
        let res = call!(
            &root,
            contract.eddsa_ed25519_verify_msg(pubkey.clone(), sign.clone(), msg.to_string())
        );
        assert!(res.gas_burnt().0 < 35 * TERA);
        res.unwrap_json()
    };
    assert!(verify1);

    // fail: pass in wrong signature
    let bad_verify1: bool = {
        let res = call!(
            &root,
            contract.eddsa_ed25519_verify_msg(pubkey.clone(), bad_sign, msg.to_string())
        );
        assert!(res.gas_burnt().0 < 35 * TERA);
        res.unwrap_json()
    };
    assert!(!bad_verify1);

    // ok: checks prehashed signature
    let verify2: bool = {
        // ok: checks without using the contract
        let sha2_verify: bool = {
            use sha2::Digest;
            let pubkey = ed25519_dalek::PublicKey::from_bytes(&pubkey.0).unwrap();
            let prehashed_sign = ed25519_dalek::Signature::from_bytes(&prehashed_sign.0).unwrap();
            let mut digest = sha2::Sha512::new();
            digest.update(msg);
            pubkey
                .verify_prehashed(digest, None, &prehashed_sign)
                .is_ok()
        };
        assert!(sha2_verify);

        // ok: checks by using the contract
        let res = call!(
            &root,
            contract.eddsa_ed25519_verify_prehashed(pubkey, prehashed_sign, msg_hash, None)
        );
        assert!(res.gas_burnt().0 < 35 * TERA);
        res.unwrap_json()
    };
    assert!(verify2);

    // sanity assertions with ed25519-dalek (without using the contract)
    {
        use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature};

        let seckey: SecretKey = SecretKey::from_bytes(&seckey_bytes).unwrap();
        let pubkey: PublicKey = PublicKey::from_bytes(&expected_pubkey_bytes).unwrap();

        let keypair: Keypair = Keypair {
            secret: seckey,
            public: pubkey,
        };

        let sig1: Signature = Signature::from_bytes(&expected_sign_bytes).unwrap();
        let sig2: Signature = {
            use ed25519_dalek::Signer;
            keypair.sign(msg_bytes)
        };

        assert_eq!(sig1, sig2);
        assert_eq!(sig1.to_bytes(), expected_sign_bytes);
        assert_eq!(sig1.to_bytes(), sign.0);
        assert!(keypair.verify(msg_bytes, &sig2).is_ok());
    }
}

// test based on data from:
// https://github.com/near/near-api-js/blob/7ea21f330af1a00543b1ae655761a98820f6a368/test/key_pair.test.js#L5
#[allow(unused_variables)]
#[test]
fn test_near_verification() {
    let msg = "message";
    let pubkey = "ed25519:AYWv9RAN1hpSQA4p1DLhCNnpnNXwxhfH9qeHN8B4nJ59";
    let sign =
        "26gFr4xth7W9K7HPWAxq3BLsua8oTy378mC1MYFiEXHBBpeBjP8WmJEJo8XTBowetvqbRshcQEtBUdwQcAqDyP8T";

    // test using the contract / call!()
    {
        let root = init_simulator(None);
        let contract = setup_exec(&root);

        // ok: signature verified
        let res = call!(
            &root,
            contract.verify_msg(
                sign.to_string().into(),
                pubkey.to_string().into(),
                msg.to_string()
            )
        );
        res.assert_success();
        let verify: bool = res.unwrap_json();
        assert!(verify);

        // fail: different message
        let verify2: bool = call!(
            &root,
            contract.verify_msg(
                sign.to_string().into(),
                pubkey.to_string().into(),
                msg.to_string() + "0"
            )
        )
        .unwrap_json();
        assert!(!verify2);

        // fail: different signature
        let sign3 = "3".to_string() + &sign.chars().skip(1).collect::<String>();
        let verify3: bool = call!(
            &root,
            contract.verify_msg(sign3.into(), pubkey.to_string().into(), msg.to_string())
        )
        .unwrap_json();
        assert!(!verify3);

        // fail: different pubkey
        let pubkey4 = "ed25519:9m52dqbkTFJWDxb3oSZ5EuHav1YaR8PbCTux59q4xRwM";
        let verify4: bool = call!(
            &root,
            contract.verify_msg(
                sign.to_string().into(),
                pubkey4.to_string().into(),
                msg.to_string()
            )
        )
        .unwrap_json();
        assert!(!verify4);
    }

    // direct test (no contract / call!() involved)
    {
        // for the Ft.. part,
        // must skip the first byte as it's used to indicate the curve type
        let pubkey: near_sdk::PublicKey = pubkey.parse().unwrap();
        let pubkey = &pubkey.as_bytes()[1..];

        let mut sign_res = [0u8; 64];
        let _sign = near_sdk::bs58::decode(sign.as_bytes())
            .into(&mut sign_res)
            .unwrap();
        let sign = sign_res;

        let msg_hash = {
            use digest::Digest;
            let mut sha2_hash = sha2::Sha256::new();
            sha2_hash.update(msg.as_bytes());
            let sha2_hash = sha2_hash.finalize();
            sha2_hash.to_vec()
        };

        {
            use ed25519_dalek::{PublicKey, Signature};
            let pubkey = PublicKey::from_bytes(pubkey).unwrap();
            let sign = Signature::from_bytes(&sign).unwrap();

            use ecdsa::signature::Verifier;
            assert!(pubkey.verify(&msg_hash, &sign).is_ok());
        }
    }
}

// let msg = r#"{"contract_id":"testnet","method_name":"create_account","args":{"new_account_id":"dasasdasd.testnet","new_public_key":"ed25519:FtB84LCX12AmjovMjXxq86sA8pdbMnixk7aixudPNNuN"}}"#;
// let expected_hash = "7146bfc46487e635c5dbdc2976dc0cda1eac1c36fbdfe7481ff41c70196b9081";
// let pubkey = "ed25519:FtB84LCX12AmjovMjXxq86sA8pdbMnixk7aixudPNNuN";
// let sign = "679dbb85416ee137cdbb8327b630368dbd89fae811ccae47b39ca2082fd62a966ac72c9dabbd55f92d5c1e6a696a7e640e5d60ff10a6428741f04a92746a7e0a";

'''
'''--- app-exec/tests/test_exec.rs ---
#![allow(clippy::ref_in_deref)]
#![allow(clippy::needless_borrow)]

use crate::utils::{setup_counter, setup_exec};
use crypto::eddsa_ed25519 as ed;
use near_sdk_sim::{call, init_simulator};
use nearapps_exec::crypto;
use nearapps_exec::exec::{CallContext, ContractCall, TagInfo};

mod utils;

fn sign(ctx: &ContractCall) -> (near_sdk::PublicKey, crypto::Bs58EncodedSignature) {
    use std::convert::TryInto;

    use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature};
    let seckey_bytes: [u8; 32] = [
        62, 70, 27, 163, 92, 182, 11, 3, 77, 234, 98, 4, 11, 127, 79, 228, 243, 187, 150, 73, 201,
        137, 76, 22, 85, 251, 152, 2, 241, 42, 72, 54,
    ];

    let secret: SecretKey = SecretKey::from_bytes(&seckey_bytes).unwrap();
    let public: PublicKey = PublicKey::from(&secret);
    let keypair: Keypair = Keypair { secret, public };

    // TODO: confirm what information should be signed
    let msg_bytes = near_sdk::serde_json::to_string(&ctx).unwrap();

    let sign: Signature = {
        use ed25519_dalek::Signer;
        keypair.sign(msg_bytes.as_bytes())
    };

    let public: ed::types::PubKey = public.into();
    let sign: ed::types::Sign = sign.into();
    let sign: crypto::Bs58EncodedSignature = sign.into();

    (public.try_into().unwrap(), sign)
}

fn into_callctx(ctx: ContractCall) -> CallContext {
    // let (public_key, signature) = sign(&ctx);
    CallContext {
        contract_call: ctx,
        tag_info: TagInfo {
            app_id: "the_app_id".into(),
            action_id: 0.into(),
            user_id: "user.id".parse().unwrap(),
        },
        // public_key,
        // signature,
    }
}

#[test]
fn test_exec_basic() {
    let root = init_simulator(None);
    let exec = setup_exec(&root);
    let counter = setup_counter(&root);

    // ok: calls counter directly
    let res = call!(&root, counter.increment());
    let val: u8 = res.unwrap_json();
    assert_eq!(val, 1);

    // ok: calls counter through exec
    let ctx = ContractCall {
        contract_id: counter.account_id(),
        method_name: "increment".into(),
        args: "".into(),
    };
    let ctx = into_callctx(ctx);
    let res = call!(&root, exec.execute(ctx));
    let val: u8 = res.unwrap_json();
    assert_eq!(val, 2);
}

'''
'''--- app-exec/tests/utils/_secp256k1.rs ---
use nearapps_exec::crypto::ecdsa_secp256k1::types::{SecKey, SignCompact};
use secp256k1 as s;

pub fn secp256k1_init_all() -> s::Secp256k1<s::All> {
    s::Secp256k1::new()
}

pub fn secp256k1_init_sign_only() -> s::Secp256k1<s::SignOnly> {
    s::Secp256k1::signing_only()
}

pub fn secp256k1_init_verify_only() -> s::Secp256k1<s::VerifyOnly> {
    s::Secp256k1::verification_only()
}

pub fn gen_pubkey(seckey: SecKey) -> secp256k1::key::PublicKey {
    let secp = secp256k1_init_sign_only();
    secp256k1::key::PublicKey::from_secret_key(&secp, &s::SecretKey::from_slice(&seckey.0).unwrap())
}

// TODO: make sure that all signatures created already are in lower-S
// form.
// According to the link below, they are.
// This means that the explicit call to normalize is not needed.
// https://github.com/bitcoin-core/secp256k1/blob/fecf436d5327717801da84beb3066f5a9b80ea8e/src/ecdsa_impl.h#L305
//
/// Signs a msg's hash using [`ecdsa` on `secp256k1`](s::Secp256k1::sign()).
///
/// Signing is deterministic and the "pseudo-random" value `k` depends
/// only on the hash of the combination of `seckey` and `msg_hash`.
/// See [rfc6979](https://datatracker.ietf.org/doc/html/rfc6979) for more info.
///
/// To avoid generating signatures that may have malleability issues,
/// they explicitly [normalized](s::Signature::normalize_s()) to
/// a lower-S form.
/// See [bitcoin-core/secp256k1/ecdsa_signature_normalize()](https://github.com/bitcoin-core/secp256k1/blob/2e5e4b67dfb67950563c5f0ab2a62e25eb1f35c5/include/secp256k1.h#L551) for more info.
///
/// Returns the signature in serialized compact form.
pub fn ecdsa_secp256k1_sign_hashed(
    seckey: SecKey,
    msg_hash: bitcoin_hashes::sha256::Hash,
) -> SignCompact {
    use bitcoin_hashes::Hash;
    let msg_hash = bitcoin_hashes::sha256::Hash::from_slice(&msg_hash)
        .unwrap_or_else(|_| panic!("ERR_HASH_BAD_LEN"));
    let secp = secp256k1_init_sign_only();

    let mut sig = secp.sign(
        //
        &s::Message::from_slice(&msg_hash).unwrap(),
        &s::SecretKey::from_slice(&seckey.0).unwrap(),
    );
    sig.normalize_s();
    SignCompact(sig.serialize_compact())
}

'''
'''--- app-exec/tests/utils/mod.rs ---
#![allow(dead_code)]

pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk::AccountId;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{deploy, init_simulator, ContractAccount, ExecutionResult, UserAccount};
use nearapps_counter::CounterContract;
use nearapps_exec::ExecutorContract;

pub mod _secp256k1;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    EXEC_WASM_BYTES => "../res/nearapps_exec.wasm",
    COUNTER_WASM_BYTES => "../res/nearapps_counter.wasm",
}

pub type Contract = ContractAccount<ExecutorContract>;

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

pub trait AssertFailure {
    fn assert_failure<E: ToString>(&self, action: u32, err: E);
}

impl AssertFailure for ExecutionResult {
    fn assert_failure<E: ToString>(&self, action: u32, err: E) {
        let err = format!(
            "Action #{}: Smart contract panicked: {}",
            action,
            err.to_string()
        );
        match self.status() {
            ExecutionStatus::Failure(txerr_) => {
                assert_eq!(txerr_.to_string(), err)
            }
            ExecutionStatus::Unknown => panic!("Got Unknown. Should have failed with {}", err),
            ExecutionStatus::SuccessValue(_v) => {
                panic!("Got SuccessValue. Should have failed with {}", err)
            }
            ExecutionStatus::SuccessReceiptId(_id) => {
                panic!("Got SuccessReceiptId. Should have failed with {}", err)
            }
        }
    }
}

pub fn setup_exec(root: &UserAccount) -> Contract {
    let contract = deploy!(
        contract: ExecutorContract,
        contract_id: "executor".to_string(),
        bytes: &EXEC_WASM_BYTES,
        signer_account: root,
        deposit: 200 * YOTTA,
        init_method: new(root.account_id())
    );
    contract
}

pub fn setup_counter(root: &UserAccount) -> ContractAccount<CounterContract> {
    deploy!(
        contract: CounterContract,
        contract_id: "counter".to_string(),
        bytes: &COUNTER_WASM_BYTES,
        signer_account: root,
        deposit: 200 * YOTTA,
        // init_method: new()
    )
}

fn user(id: u32) -> AccountId {
    format!("user{}", id).parse().unwrap()
}

'''
'''--- app-nft/Cargo.toml ---
[package]
name = "nearapps-nft"
version = "0.1.0"
authors = ["Sebastian Gerske <13647606+H34D@users.noreply.github.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}
near-contract-standards = "4.0.0-pre.4"
sha2 = "0.9.0"
digest = "0.9.0"
strum = "0.23"
strum_macros = "0.23"

[dependencies.serde_with]
version = "1.11.0"
default-features = false
features = [ "macros" ]

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"

# [profile.release]
# codegen-units = 1
# # Tell `rustc` to optimize for small code size.
# opt-level = "z"
# lto = true
# debug = false
# panic = "abort"
# # Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
# overflow-checks = true

'''
'''--- app-nft/build.sh ---
#!/usr/bin/env bash

set -ex

cargo +stable build --target wasm32-unknown-unknown --release

cp ../target/wasm32-unknown-unknown/release/nearapps_nft.wasm ../res/

'''
'''--- app-nft/src/error.rs ---
use strum_macros::Display;

/// User-facing errors.
///
/// This maps error variants into error messages.  
/// If a user makes use of some interface incorrectly,
/// this should be used with [`near_sdk::env::panic_str()`].
///
/// Otherwise, if some internal error occurred such that it would
/// indicate an internal bug, then `[panic!()]` should be used
/// as it prints line code information that would be useful for
/// debugging and fixing the problem.
#[derive(Debug, Display)]
pub enum Error {
    /// A call that was supposed to be made by the owner was made
    /// by a different predecessor.
    #[strum(serialize = "ERR_NOT_OWNER")]
    NotOwner,
    /// A standard minting operation tried to use the
    /// token-series delimiter on the token's name, which
    /// must not be allowed.
    #[strum(serialize = "ERR_NFT_TOKEN_ID_WITH_DELIMITER")]
    TokenIdWithSeriesDelimiter,
    #[strum(serialize = "ERR_NFT_SERIES_MISSING")]
    MissingSeries,
    #[strum(serialize = "ERR_NFT_SERIES_MAX_CAPACITY")]
    SeriesMaxCapacity,
    #[strum(serialize = "ERR_NFT_SERIES_NOT_MINTABLE")]
    SeriesNotMintable,
    #[strum(serialize = "ERR_NFT_SERIES_NOT_ENOUGH_CAPACITY")]
    SeriesNotEnoughtCapacity,
}

impl Error {
    /// Calls [`near_sdk::env::panic_str()`] with this error's message.
    pub fn panic(&self) -> ! {
        near_sdk::env::panic_str(&self.to_string())
    }
}

pub trait OrPanicStr {
    type Target;
    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target;
}

impl<T, E> OrPanicStr for Result<T, E> {
    type Target = T;

    fn or_panic_str<Err: ToString>(self, error: Err) -> Self::Target {
        self.unwrap_or_else(|_| near_sdk::env::panic_str(&error.to_string()))
    }
}

impl<T> OrPanicStr for Option<T> {
    type Target = T;

    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target {
        self.unwrap_or_else(|| near_sdk::env::panic_str(&error.to_string()))
    }
}

pub fn ensure<E: ToString>(expr: bool, error: E) {
    match expr {
        true => (),
        false => near_sdk::env::panic_str(&error.to_string()),
    }
}

'''
'''--- app-nft/src/lib.rs ---
use near_contract_standards::non_fungible_token as nft;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap, UnorderedSet};
use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault};
use nft::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};

pub mod error;
pub mod series;
pub mod utils;

use error::{ensure, Error};
pub use series::SERIES_DELIMETER;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Nft {
    tokens: nft::NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    series: UnorderedMap<series::SeriesId, series::Series>,
    next_series_id: series::SeriesId,
    series_minted_tokens: UnorderedMap<series::SeriesId, UnorderedSet<series::SeriesTokenIndex>>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    Series,
    TokensBySeries,
    TokensBySeriesInner { series_id: series::SeriesId },
}

#[near_bindgen]
impl Nft {
    /// Adapted from the standard example.
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: nft::NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            series: UnorderedMap::new(StorageKey::Series),
            next_series_id: series::SeriesId(0),
            series_minted_tokens: UnorderedMap::new(StorageKey::TokensBySeries),
        }
    }

    /// Identical to the standard example.
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    /// Adapted from the standard example.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: nft::TokenId,
        token_owner_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> nft::Token {
        self.assert_owner();

        // token_id must not contain the series delimiter
        ensure(
            !token_id.contains(SERIES_DELIMETER),
            Error::TokenIdWithSeriesDelimiter,
        );

        // standard minting
        let token =
            self.tokens
                .internal_mint(token_id, token_owner_id.clone(), Some(token_metadata));

        // NEP171 (Non-Fungible Token Event) 1.0.0
        env::log_str(&format!("EVENT_JSON:{{\"standard\":\"nep171\",\"version\":\"1.0.0\",\"event\":\"nft_mint\",\"data\":[{{\"owner_id\":\"{}\",\"token_ids\":[\"{}\"]}}]}}", token_owner_id.as_str(), token.token_id.as_str()));

        token
    }

    /// Adapted from the standard example.
    #[payable]
    pub fn nft_series_mint(
        &mut self,
        series_id: series::SeriesId,
        token_owner_id: AccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> nft::Token {
        self.assert_owner();

        let mut series = self.nft_series_get(series_id);
        let mut minted_tokens = self.nft_series_get_minted_tokens(series_id);

        let token = series.next_token();

        // updates series
        self.series.insert(&series_id, &series);

        // updates minted_tokens
        let token_index = series.last_token_index().unwrap();
        minted_tokens.insert(&token_index);
        self.series_minted_tokens.insert(&series_id, &minted_tokens);

        let token_metadata = token_metadata.unwrap_or_else(|| TokenMetadata {
            title: Some(token.0.clone()),
            description: Some(format!(
                "Token #{} from series {}",
                token_index.0, series.name
            )),
            media: None,
            media_hash: None,
            copies: None,
            issued_at: Some(env::block_timestamp().to_string()),
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        });

        // standard minting
        let token =
            self.tokens
                .internal_mint(token.0, token_owner_id.clone(), Some(token_metadata));

        // NEP171 (Non-Fungible Token Event) 1.0.0
        env::log_str(&format!("EVENT_JSON:{{\"standard\":\"nep171\",\"version\":\"1.0.0\",\"event\":\"nft_mint\",\"data\":[{{\"owner_id\":\"{}\",\"token_ids\":[\"{}\"]}}]}}", token_owner_id.as_str(), token.token_id.as_str()));

        token
    }
}

pub mod std_impls {
    use super::nft::{Token, TokenId};
    use super::Nft;
    use near_contract_standards as ncs;
    use near_sdk::{near_bindgen, AccountId, Promise, PromiseOrValue};

    #[cfg(not(target_arch = "wasm32"))]
    use crate::NftContract;

    ncs::impl_non_fungible_token_core!(Nft, tokens);
    ncs::impl_non_fungible_token_approval!(Nft, tokens);
    ncs::impl_non_fungible_token_enumeration!(Nft, tokens);
}

/// standard implementation.
#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Nft {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

pub trait Owner {
    fn assert_owner(&self);
}

impl Owner for Nft {
    fn assert_owner(&self) {
        ensure(
            env::predecessor_account_id() == self.tokens.owner_id,
            Error::NotOwner,
        )
    }
}

/// Identical to the standard example.
const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

'''
'''--- app-nft/src/series.rs ---
use crate::error::{ensure, Error, OrPanicStr};
use crate::{Nft, Owner, StorageKey};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId};
use serde_with::{serde_as, FromInto};

pub const SERIES_DELIMETER: char = ':';

#[cfg(not(target_arch = "wasm32"))]
use crate::NftContract;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Series {
    pub id: SeriesId,
    pub name: String,
    pub creator: AccountId,
    pub len: SeriesTokenIndex,
    /// The maximum number of token units that this series can have minted.
    ///
    /// eg. `0` means that it will never mint any token.
    pub capacity: SeriesTokenIndex,
    pub is_mintable: bool,
}

#[serde_as]
#[derive(Serialize, Deserialize, BorshSerialize, BorshDeserialize, Clone, Copy)]
#[serde(transparent)]
#[serde(crate = "near_sdk::serde")]
pub struct SeriesId(
    #[serde_as(as = "FromInto<U64>")]
    //
    pub u64,
);

pub type SeriesName = String;

/// The index of a token inside a series.
/// eg. `0`, `1`, `2`.  
/// The maximum value for a token's index will be
/// `capacity - 1`.
///
/// Can also represent `len`, the quantity of tokens minted.  
/// eg. `0` means no tokens have been minted.  
/// eg. `1` means that a single token has been minted, which
/// will have the index of `0`.  
/// The maximum value for a serie's token `len` will be
/// `capacity`.
///
/// Can also represent the maximum `capacity` of a series.  
/// eg. `0` won't be able to have any tokens.  
/// eg. `1` will be able to have a single token,
/// which will have the index of `0`.
#[serde_as]
#[derive(
    Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, PartialOrd, Clone, Copy,
)]
#[serde(transparent)]
#[serde(crate = "near_sdk::serde")]
pub struct SeriesTokenIndex(
    #[serde_as(as = "FromInto<U64>")]
    //
    pub u64,
);

/// A token name produced from a series.
///
/// See [`TokenSeriesId::new()`] for more info.
pub struct TokenSeriesId(pub String);

impl TokenSeriesId {
    /// Creates a new [`nft::TokenId`] based on the series' name, the
    /// series' id, [`SERIES_DELIMETER`], and some `index`.
    pub fn new(name: SeriesName, series_id: SeriesId, token_index: SeriesTokenIndex) -> Self {
        Self(format!(
            "{}{}{}{}{}",
            //
            name,
            SERIES_DELIMETER,
            series_id.0,
            SERIES_DELIMETER,
            token_index.0
        ))
    }
}

impl Series {
    pub fn next_token(&mut self) -> TokenSeriesId {
        ensure(self.is_mintable, Error::SeriesNotMintable);
        ensure(self.len < self.capacity, Error::SeriesMaxCapacity);

        let token = TokenSeriesId::new(self.name.clone(), self.id, self.len);
        self.len.0 += 1;

        if self.len == self.capacity {
            self.is_mintable = false;
        }

        token
    }

    pub fn last_token_index(&self) -> Option<SeriesTokenIndex> {
        if self.len.0 > 0 {
            Some(SeriesTokenIndex(self.len.0 - 1))
        } else {
            None
        }
    }
}

#[near_bindgen]
impl Nft {
    pub fn nft_series_supply(&self) -> String {
        self.series.len().to_string()
    }

    pub fn nft_series_get(&self, series_id: SeriesId) -> Series {
        self.series
            .get(&series_id)
            .or_panic_str(Error::MissingSeries)
    }

    pub(crate) fn nft_series_get_minted_tokens(
        &self,
        series_id: SeriesId,
    ) -> UnorderedSet<SeriesTokenIndex> {
        self.series_minted_tokens
            .get(&series_id)
            .or_panic_str(Error::MissingSeries)
    }

    pub fn nft_series_get_minted_tokens_vec(&self, series_id: SeriesId) -> Vec<SeriesTokenIndex> {
        self.nft_series_get_minted_tokens(series_id)
            .iter()
            .collect()
    }

    pub fn nft_series_create(
        &mut self,
        name: SeriesName,
        capacity: SeriesTokenIndex,
        creator: AccountId,
    ) -> SeriesId {
        self.assert_owner();

        let id = self.next_series_id;
        self.next_series_id.0 += 1;

        let series = Series {
            id,
            name: name.clone(),
            creator: creator.clone(),
            len: SeriesTokenIndex(0),
            capacity,
            is_mintable: true,
        };

        self.series_minted_tokens.insert(
            &id,
            &UnorderedSet::new(StorageKey::TokensBySeriesInner { series_id: id }),
        );

        self.series.insert(&id, &series);

        // ~NEP171 (Non-Fungible Token Event) 1.0.0(?)
        // note: event:nft_series_create is not on the std 1.0.0
        env::log_str(&format!("EVENT_JSON:{{\"standard\":\"nep171\",\"version\":\"1.0.0\",\"event\":\"nft_series_create\",\"data\":[{{\"owner_id\":\"{}\",\"series\":[\"{}:{}\"]}}]}}", creator.as_str(), name, id.0));

        id
    }

    pub fn nft_series_set_mintable(&mut self, series_id: SeriesId, is_mintable: bool) {
        self.assert_owner();
        let mut series = self.nft_series_get(series_id);
        if series.is_mintable != is_mintable {
            series.is_mintable = is_mintable;
            self.series.insert(&series_id, &series);
        }
    }

    pub fn nft_series_set_capacity(&mut self, series_id: SeriesId, capacity: SeriesTokenIndex) {
        self.assert_owner();

        let mut series = self.nft_series_get(series_id);
        ensure(capacity >= series.len, Error::SeriesNotEnoughtCapacity);

        series.capacity = capacity;

        if capacity == series.len {
            series.is_mintable = false;
        }

        self.series.insert(&series_id, &series);
    }
}

'''
'''--- app-nft/src/utils.rs ---
#![allow(dead_code)]

use near_sdk::{env, require, AccountId, Balance, Promise};
use std::collections::HashMap;

/// Identical to [`nft::utils::bytes_for_approved_account_id()`].
pub fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + core::mem::size_of::<u64>() as u64
}

/// Identical to [`nft::utils::assert_at_least_one_yocto()`].
pub(crate) fn assert_at_least_one_yocto() {
    require!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR"
    )
}

/// Identical to [`nft::utils::refund_deposit()`].
pub fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    require!(
        required_cost <= attached_deposit,
        format!("Must attach {} yoctoNEAR to cover storage", required_cost)
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

/// Identical to [`nft::utils::refund_approved_account_ids_iter()`].
pub fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I,
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

/// Identical to [`nft::utils::refund_approved_account_ids()`].
pub fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

'''
'''--- app-nft/tests/test_nft.rs ---
#![allow(clippy::ref_in_deref)]

use near_contract_standards::non_fungible_token as nft;
pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk::serde_json;
use near_sdk_sim::{call, init_simulator};
use nearapps_nft::error::Error;
use nearapps_nft::series::{SeriesId, SeriesTokenIndex};

pub mod utils;

use crate::utils::{token_ids, user, AssertFailure, MEGA_TERA, YOTTA};

#[test]
fn test_nft() {
    const COMMON_ATTACHMENT: u128 = 6450 * MEGA_TERA;

    let root = init_simulator(None);
    let nft = utils::setup_nft(&root);

    let users: Vec<_> = (0..10)
        .into_iter()
        .map(|i| root.create_user(user(i), 100 * YOTTA))
        .collect();

    // ok: root mints a token for user0
    let metadata = utils::token_metadata();
    let token_id_01 = &"token-01".to_string();
    println!(
        "metadata: {}",
        serde_json::to_string_pretty(&metadata).unwrap()
    );
    let res = call!(
        &root,
        nft.nft_mint(token_id_01.clone(), user(0), metadata),
        deposit = 5630 * MEGA_TERA
    );
    res.assert_success();

    // fail: similar, but not enought storage deposit
    let token_id_02 = &"token-02".to_string();
    let res = call!(
        &root,
        nft.nft_mint(token_id_02.clone(), user(0), utils::token_metadata()),
        // not enought deposit
        deposit = 4_290 * MEGA_TERA - 1
    );
    res.assert_failure(
        0,
        "Must attach 4290000000000000000000 yoctoNEAR to cover storage",
    );

    // ok: user0 transfers it to user1
    let res = call!(
        users[0],
        nft.nft_transfer(user(1), token_id_01.clone(), None, None),
        deposit = 1
    );
    res.assert_success();

    // ok: root creates a series
    let series_01 = &"series-01".to_string();
    let res = call!(
        &root,
        nft.nft_series_create(series_01.clone(), SeriesTokenIndex(2), root.account_id())
    );
    let series_01_id: SeriesId = res.unwrap_json();
    let log = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_series_create","data":[{"owner_id":"root","series":["series-01:0"]}]}"#;
    assert!(res.logs().contains(&log.to_string()));

    // ok: root mints the series for user0
    let res = call!(
        &root,
        nft.nft_series_mint(series_01_id, user(0), None),
        deposit = COMMON_ATTACHMENT
    );
    let series_01_token_0: nft::Token = res.unwrap_json();
    let log = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"user0","token_ids":["series-01:0:0"]}]}"#;
    assert!(res.logs().contains(&log.to_string()));

    // ok: user0 transfers it to user1
    let res = call!(
        users[0],
        nft.nft_transfer(user(1), series_01_token_0.token_id, None, None),
        deposit = 1
    );
    res.assert_success();

    // ok: get user1 tokens
    let res = call!(
        //
        users[1],
        nft.nft_tokens_for_owner(user(1), None, None)
    );
    let tokens: Vec<nft::Token> = res.unwrap_json();
    let tokens = token_ids(&tokens);
    assert_eq!(tokens, vec!["series-01:0:0", "token-01"]);

    // ok: root mints the series for user2
    let res = call!(
        &root,
        nft.nft_series_mint(series_01_id, user(2), None),
        deposit = COMMON_ATTACHMENT
    );
    let _series_01_token_1: nft::Token = res.unwrap_json();
    let log = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"user2","token_ids":["series-01:0:1"]}]}"#;
    assert!(res.logs().contains(&log.to_string()));

    // ok: get user2 tokens
    let res = call!(
        //
        users[2],
        nft.nft_tokens_for_owner(user(2), None, None)
    );
    let tokens: Vec<nft::Token> = res.unwrap_json();
    let tokens = token_ids(&tokens);
    assert_eq!(tokens, vec!["series-01:0:1"]);

    // fail: root tries to mint on the same series again
    // (no more capacity)
    let res = call!(
        &root,
        nft.nft_series_mint(series_01_id, user(2), None),
        deposit = COMMON_ATTACHMENT
    );
    res.assert_failure(0, Error::SeriesNotMintable);
    let non_log = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"user2","token_ids":["series-01:0:2"]}]}"#;
    assert!(!res.logs().contains(&non_log.to_string()));
}

'''
'''--- app-nft/tests/test_nft.sh ---
!/usr/bin/env bash

set -x

rm -rf "neardev/"

# initial exec deploy and init
WASM="../../res/nearapps_exec.wasm"
near dev-deploy \
  --wasmFile $WASM
# load created acc's id as CONTRACT_NAME
source neardev/dev-account.env
EXEC="$CONTRACT_NAME"
# init exec
METHOD="new"
ARGS='{"owner_id": "'"$EXEC"'"}'
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC"

# contract creation, deploy and init
NFT_SERIES="nft-series.$EXEC"
near create-account \
    "$NFT_SERIES" \
    --masterAccount "$EXEC"
# deploy & init - owner (predecessor) is EXEC
WASM="../../res/nearapps_nft.wasm"
METHOD="new_default_meta"
ARGS='{"owner_id": "'"$EXEC"'"}'
near deploy \
  --wasmFile "$WASM" \
  --contractName "$NFT_SERIES" \
  --initFunction "$METHOD" \
  --initArgs "$ARGS"
# ''

# create user acc
USER0="user-0.$EXEC"
near create-account \
    "$USER0" \
    --masterAccount "$EXEC" \
    --initialBalance "1"

# exec creates a series for user0
METHOD="nft_series_create"
ARGS='{\"name\": \"my-series\", \"capacity\": \"5\", \"creator\": \"'"$USER0"'\"}'
ARGS='{"context": {"contract_call": {"contract_id": "'"$NFT_SERIES"'", "method_name": "'"$METHOD"'", "args": "'"$ARGS"'"}, "tag_info": {"app_id": "some-app", "action_id": "0", "user_id": "'"$USER0"'"}}}'
METHOD="execute"
eval SERIES_ID=`near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC" \
    --gas 300000000000000 | tail -n 1`
# 0
#
# note: this value result has already stripped the single quotes 
# '' from it - otherwise it would have single quotes, like '0'

# exec mints a token from a series for user0
METHOD="nft_series_mint"
# note: for series id, we are using a value that's already a 
# number (without single quotes).
ARGS='{\"series_id\": \"'"$SERIES_ID"'\", \"token_owner_id\": \"'"$USER0"'\", \"token_metadata\": {\"title\": \"default-title\", \"description\": null, \"media\": null, \"media_hash\": null, \"copies\": null, \"issued_at\": null, \"expires_at\": null, \"starts_at\": null, \"updated_at\": null, \"extra\": null, \"reference\": null, \"reference_hash\": null}}'
ARGS='{"context": {"contract_call": {"contract_id": "'"$NFT_SERIES"'", "method_name": "'"$METHOD"'", "args": "'"$ARGS"'"}, "tag_info": {"app_id": "some-app", "action_id": "1", "user_id": "'"$USER0"'"}}}'
METHOD="execute"
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC" \
    --depositYocto 6560000000000000000000 \
    --gas 300000000000000

# verify that the token has been minted
METHOD=nft_tokens_for_owner
ARGS='{"account_id": "'"$USER0"'"}'
near view \
    "$NFT_SERIES" \
    "$METHOD" \
    "$ARGS"

'''
'''--- app-nft/tests/utils/mod.rs ---
#![allow(dead_code)]

use near_contract_standards::non_fungible_token as nft;
pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk::AccountId;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{deploy, init_simulator, ContractAccount, ExecutionResult, UserAccount};
use nft::metadata::TokenMetadata;

use nearapps_nft::NftContract;

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    EXEC_WASM_BYTES => "../res/nearapps_exec.wasm",
    NFT_WASM_BYTES => "../res/nearapps_nft.wasm",
}

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const MEGA_TERA: u128 = MEGA as u128 * TERA as u128;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

pub trait AssertFailure {
    fn assert_failure<E: ToString>(&self, action: u32, err: E);
}

impl AssertFailure for ExecutionResult {
    fn assert_failure<E: ToString>(&self, action: u32, err: E) {
        let err = format!(
            "Action #{}: Smart contract panicked: {}",
            action,
            err.to_string()
        );
        match self.status() {
            ExecutionStatus::Failure(txerr_) => {
                assert_eq!(txerr_.to_string(), err)
            }
            ExecutionStatus::Unknown => panic!("Got Unknown. Should have failed with {}", err),
            ExecutionStatus::SuccessValue(_v) => {
                panic!("Got SuccessValue. Should have failed with {}", err)
            }
            ExecutionStatus::SuccessReceiptId(_id) => {
                panic!("Got SuccessReceiptId. Should have failed with {}", err)
            }
        }
    }
}

pub fn setup_nft(root: &UserAccount) -> ContractAccount<NftContract> {
    deploy!(
        contract: NftContract,
        contract_id: "nft".to_string(),
        bytes: &NFT_WASM_BYTES,
        signer_account: root,
        deposit: 200 * YOTTA,
        init_method: new_default_meta(root.account_id())
    )
}

pub fn user(id: u32) -> AccountId {
    format!("user{}", id).parse().unwrap()
}

pub fn token_metadata() -> TokenMetadata {
    TokenMetadata {
        title: Some("default-title".to_string()),
        description: None,
        media: None,
        media_hash: None,
        copies: None,
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    }
}

pub fn token_ids(tokens: &[nft::Token]) -> Vec<nft::TokenId> {
    let mut tokens: Vec<_> = tokens.iter().map(|t| t.token_id.clone()).collect();
    tokens.sort();
    tokens
}

'''
'''--- app-wallet/Cargo.toml ---
[package]
name = "nearapps-wallet"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}
strum = "0.23"
strum_macros = "0.23"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.4"

[dev-dependencies.ed25519-dalek]
version = "1.0.1"
default-features = false
features = ["u64_backend"]

[dev-dependencies.nearapps-exec]
path = "../app-exec/"
# version = "1.0.1"
# default-features = false
# features = ["u64_backend"]
'''
'''--- app-wallet/README.md ---
# Wallet App

Creates near accounts, logging on success.

'''
'''--- app-wallet/build.sh ---
#!/usr/bin/env bash

set -ex

cargo +stable build --target wasm32-unknown-unknown --release

cp ../target/wasm32-unknown-unknown/release/nearapps_wallet.wasm ../res/

'''
'''--- app-wallet/src/error.rs ---
use strum_macros::Display;

/// User-facing errors.
///
/// This maps error variants into error messages.  
/// If a user makes use of some interface incorrectly,
/// this should be used with [`near_sdk::env::panic_str()`].
///
/// Otherwise, if some internal error occurred such that it would
/// indicate an internal bug, then `[panic!()]` should be used
/// as it prints line code information that would be useful for
/// debugging and fixing the problem.
#[derive(Debug, Display)]
pub enum Error {
    #[strum(serialize = "ERR_WALLET_NOT_OWNER")]
    NotOwner,
    #[strum(serialize = "ERR_WALLET_CALLBACK_RESULTS")]
    BadCallbackResults,
    #[strum(serialize = "ERR_WALLET_ALREADY_QUEUED")]
    AccountAlreadyQueued,
    #[strum(serialize = "ERR_WALLET_LOW_DEPOSIT")]
    NotEnoughtDeposit,
}

impl Error {
    /// Calls [`near_sdk::env::panic_str()`] with this error's message.
    pub fn panic(&self) -> ! {
        near_sdk::env::panic_str(&self.to_string())
    }
}

pub trait OrPanicStr {
    type Target;
    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target;
}

impl<T, E> OrPanicStr for Result<T, E> {
    type Target = T;

    fn or_panic_str<Err: ToString>(self, error: Err) -> Self::Target {
        self.unwrap_or_else(|_| near_sdk::env::panic_str(&error.to_string()))
    }
}

impl<T> OrPanicStr for Option<T> {
    type Target = T;

    fn or_panic_str<E: ToString>(self, error: E) -> Self::Target {
        self.unwrap_or_else(|| near_sdk::env::panic_str(&error.to_string()))
    }
}

pub fn ensure<E: ToString>(expr: bool, error: E) {
    match expr {
        true => (),
        false => near_sdk::env::panic_str(&error.to_string()),
    }
}

'''
'''--- app-wallet/src/lib.rs ---
#![allow(clippy::let_and_return)]

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise, PublicKey,
};

pub mod error;

pub use error::{ensure, Error};

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

#[near_sdk::ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_subaccount_created(config: AccountConfig) -> bool;
    fn on_account_created(new_account_id: AccountId) -> bool;
}

#[near_sdk::ext_contract(ext_parent)]
pub trait ExtParent {
    fn create_account(new_account_id: AccountId, new_public_key: PublicKey) -> bool;
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountsQueue,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct AccountManager {
    /// Owner of this account.
    pub owner_id: AccountId,
    // Accounts that were successfuly created.
    pub accounts: UnorderedSet<AccountId>,
    /// Accounts that have been asked to be created.
    pub accounts_queue: UnorderedSet<AccountId>,
    // pub defaults: Defaults,
}

#[derive(
    near_sdk::serde::Serialize, near_sdk::serde::Deserialize, BorshDeserialize, BorshSerialize,
)]
#[serde(crate = "near_sdk::serde")]

pub struct Defaults {
    /// The default initial amount to attach to created accounts.
    pub initial_amount: U128,
    /// The default allowance to attach to allowed calls on created
    /// accounts.
    pub allowance: U128,
    /// The default allowed calls that new accounts are able to make.
    pub allowed_calls: Vec<AllowedCalls>,
}

#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountConfig {
    /// The sub-account that is being created.
    /// Expected to be a sub-account on `AccountManager`.
    pub account_id: AccountId,
    /// The PublicKey of the sub-account being created.
    /// Expected to be generated by the user.
    pub user_public_key: PublicKey,
    // /// The initial amount of deposit that the user should receive.
    // ///
    // /// If missing, the user will receive
    // /// [`Defaults::initial_amount`]
    // pub initial_amount: Option<U128>,
}

#[derive(
    near_sdk::serde::Serialize,
    near_sdk::serde::Deserialize,
    BorshDeserialize,
    BorshSerialize,
    Clone,
)]
#[serde(crate = "near_sdk::serde")]
pub struct AllowedCalls {
    /// How much, in total, the user can spend when calling the contract.
    ///
    /// For each call for the given contract, the allowance will be
    /// decreasing as deposits and gas gets used by the call.
    ///
    /// For replenishment or increase of the allowance, the access_key
    /// must be removed and then added again, with the new `allowance`
    /// value.
    ///
    /// If missing, the value [`Defaults::allowance`]
    /// is used.
    pub allowance: Option<U128>,
    /// The contract address that the user is allowed to call into.
    pub receiver_id: AccountId,
    /// List of method names (eg. `["method_a", "method_b"]`) that the user
    /// is allowed to call.  
    ///
    /// An empty list means all methods.
    pub method_names: Vec<String>,
}

#[near_bindgen]
impl AccountManager {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            accounts: UnorderedSet::new(StorageKey::Accounts),
            accounts_queue: UnorderedSet::new(StorageKey::AccountsQueue),
        }
    }

    /// Creates a new user account.
    ///
    /// By default [`env::signer_account_pk()`] will be the full owner
    /// of the new account, unless `user_manager_public_key` is present.
    ///
    /// The accounts, while being created, first enter a queue from which
    /// they are removed once the successfull creation has been
    /// confirmed.  
    /// The created account names are then tracked in [`Self::accounts`].
    #[payable]
    pub fn create_account(
        &mut self,
        new_account_id: AccountId,
        new_public_key: Option<PublicKey>,
    ) -> Promise {
        // simulation
        // const _GAS_CURRENT: Gas = Gas(21 * TERA);
        // const GAS_CREATE_ACC_CALL: Gas = Gas(4 * TERA);
        // const GAS_CALLBACK: Gas = Gas(500_000 * MEGA);

        // testnet
        const _GAS_CURRENT: Gas = Gas(13 * TERA);
        const GAS_CREATE_ACC_CALL: Gas = Gas(11 * TERA);
        const GAS_CALLBACK: Gas = Gas(8 * TERA);

        ensure(
            self.owner_id == env::predecessor_account_id(),
            Error::NotOwner,
        );

        let user_manager_public_key = new_public_key.unwrap_or_else(env::signer_account_pk);

        let is_new_account = self.accounts_queue.insert(&new_account_id);
        ensure(is_new_account, Error::AccountAlreadyQueued);

        let user_account_id_str = new_account_id.to_string();
        let (user, parent) = user_account_id_str.split_once('.').unwrap();
        let _sub_user: AccountId = user.parse().unwrap();
        let parent: AccountId = parent.parse().unwrap();

        let new_acc = ext_parent::create_account(
            new_account_id.clone(),
            user_manager_public_key,
            parent,
            env::attached_deposit(),
            GAS_CREATE_ACC_CALL,
        );
        let callback = ext_self::on_account_created(
            new_account_id,
            env::current_account_id(),
            0u128,
            GAS_CALLBACK,
        );

        new_acc.then(callback)
    }

    #[private]
    pub fn on_account_created(&mut self, user_account_id: AccountId) -> bool {
        ensure(env::promise_results_count() == 1, Error::BadCallbackResults);

        let success: Option<bool> = match env::promise_result(0) {
            near_sdk::PromiseResult::Successful(v) => {
                // did not encounter any panicking failure
                let res: bool = near_sdk::serde_json::from_slice(&v).unwrap();
                Some(res)
            }
            // encountered some panicking failure
            _ => None,
        };

        // TODO: test when the AccountManager doesn't have enough
        // funds, if it falls into this case
        //
        // TODO: could the call still be ongoing?
        // not sure if it can be removed from the queue here
        match success {
            Some(true) => {
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);

                let did_exist = !self.accounts.insert(&user_account_id);
                // sanity check
                assert!(!did_exist);

                env::log_str(&format!("account {} created.", user_account_id));
            }
            Some(false) => {
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);
            }
            None => {
                // some error occurred
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);
            }
        }

        success.unwrap_or_default()
    }
}

'''
'''--- app-wallet/tests/test_wallet.rs ---
#![allow(clippy::ref_in_deref)]
#![allow(clippy::identity_op)]

pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk_sim::{call, deploy, init_simulator, view, ContractAccount, UserAccount};

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

pub mod utils;

use crate::utils::{user, ExecutionExt, MEGA_TERA, TERA, YOTTA};
use nearapps_wallet::AccountConfig;

// #[ignore]
// #[test]
// fn test_wallet_subaccount() {
//     let root = init_simulator(None);
//     let wallet = utils::setup_wallet(&root);

//     let users: Vec<_> = (0..10)
//         .into_iter()
//         .map(|i| root.create_user(user(i), 100 * YOTTA))
//         .collect();

//     let created_01: &near_sdk::AccountId = &"created-01".parse().unwrap();

//     let config = AccountConfig {
//         account_id: created_01.clone(),
//         user_public_key: pubkey(),
//         initial_amount: Some(1.into()),
//     };

//     // errors: not within a catch_unsafe_unwind scope
//     let res = root.function_call(
//         //
//         wallet.contract.create_subaccount(config, None),
//         15 * TERA,
//         1 * YOTTA / 100, // 0.01 N
//     );
//     res.assert_success();
//     assert!(res.gas_burnt().0 < 4 * TERA);
// }

// ignored because the gas usage differs from the simulation to the testnet
#[ignore]
#[test]
fn test_wallet_account() {
    let root = init_simulator(None);
    let wallet = utils::setup_wallet(&root);

    // let created_01: &near_sdk::AccountId =
    //     &"0123456789012345678901234567890123456789012345678.root"
    //         .parse()
    //         .unwrap();

    let created_01: &near_sdk::AccountId = &"created-01.root".parse().unwrap();

    let res = root.function_call(
        //
        wallet.contract.create_account(created_01.clone(), None),
        26 * TERA,
        1 * YOTTA / 100, // 0.01 N
    );
    let success: bool = res.unwrap_json();
    assert!(success);
    assert!(res.total_gas_burnt().0 < 26 * TERA);
}

fn pubkey() -> near_sdk::PublicKey {
    use std::convert::TryInto;

    use ed25519_dalek::{PublicKey, SecretKey};
    let seckey_bytes: [u8; 32] = [
        62, 70, 27, 163, 92, 182, 11, 3, 77, 234, 98, 4, 11, 127, 79, 228, 243, 187, 150, 73, 201,
        137, 76, 22, 85, 251, 152, 2, 241, 42, 72, 54,
    ];

    let secret: SecretKey = SecretKey::from_bytes(&seckey_bytes).unwrap();
    let public: PublicKey = PublicKey::from(&secret);

    use nearapps_exec::crypto::eddsa_ed25519::types::PubKey;
    let public: PubKey = public.into();

    let public = public.try_into().unwrap();

    let pk = near_sdk::serde_json::to_string(&pubkey()).unwrap();
    assert_eq!(&pk, "ed25519:9m52dqbkTFJWDxb3oSZ5EuHav1YaR8PbCTux59q4xRwM");

    public
}

'''
'''--- app-wallet/tests/utils/mod.rs ---
#![allow(dead_code)]

pub use near_sdk::json_types::{Base64VecU8, U64};
use near_sdk::{AccountId, Gas};
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{deploy, init_simulator, ContractAccount, ExecutionResult, UserAccount};

use nearapps_wallet::{AccountManagerContract, AllowedCalls, Defaults};

pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    WALLET_WASM_BYTES => "../res/nearapps_wallet.wasm",
}

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const MEGA_TERA: u128 = MEGA as u128 * TERA as u128;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

pub trait ExecutionExt {
    fn assert_failure<E: ToString>(&self, action: u32, err: E);
    fn total_gas_burnt(&self) -> Gas;
}

impl ExecutionExt for ExecutionResult {
    fn assert_failure<E: ToString>(&self, action: u32, err: E) {
        let err = format!(
            "Action #{}: Smart contract panicked: {}",
            action,
            err.to_string()
        );
        match self.status() {
            ExecutionStatus::Failure(txerr_) => {
                assert_eq!(txerr_.to_string(), err)
            }
            ExecutionStatus::Unknown => panic!("Got Unknown. Should have failed with {}", err),
            ExecutionStatus::SuccessValue(_v) => {
                panic!("Got SuccessValue. Should have failed with {}", err)
            }
            ExecutionStatus::SuccessReceiptId(_id) => {
                panic!("Got SuccessReceiptId. Should have failed with {}", err)
            }
        }
    }
    fn total_gas_burnt(&self) -> Gas {
        self.get_receipt_results()
            .into_iter()
            .chain(self.promise_results())
            .flatten()
            .map(|o| o.gas_burnt().0)
            .sum::<u64>()
            .into()
    }
}

#[allow(clippy::identity_op)]
pub fn setup_wallet(root: &UserAccount) -> ContractAccount<AccountManagerContract> {
    deploy!(
        contract: AccountManagerContract,
        contract_id: "wallet".to_string(),
        bytes: &WALLET_WASM_BYTES,
        signer_account: root,
        deposit: 200 * YOTTA,
        init_method: new(root.account_id())
    )
}

// #[allow(clippy::identity_op)]
// pub fn setup_wallet(root: &UserAccount) -> ContractAccount<AccountManagerContract> {
//     let allowed_call = &AllowedCalls {
//         allowance: Some(300 * TERA as u128).map(Into::into),
//         receiver_id: "counter".parse().unwrap(),
//         method_names: vec!["increment".to_string()],
//     };
//     let defaults = Defaults {
//         initial_amount: (1 * YOTTA / 100).into(), // 0.01 N
//         allowance: (1 * MEGA_TERA).into(),
//         allowed_calls: vec![allowed_call.clone()],
//     };
//     deploy!(
//         contract: AccountManagerContract,
//         contract_id: "wallet".to_string(),
//         bytes: &WALLET_WASM_BYTES,
//         signer_account: root,
//         deposit: 200 * YOTTA,
//         init_method: new(root.account_id(), defaults)
//     )
// }

pub fn user(id: u32) -> AccountId {
    format!("user{}", id).parse().unwrap()
}

'''
'''--- build.sh ---
#!/bin/bash
set -ex

cargo +stable build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/nearapps_exec.wasm ./res/
cp target/wasm32-unknown-unknown/release/nearapps_counter.wasm ./res/
cp target/wasm32-unknown-unknown/release/nearapps_wallet.wasm ./res/
cp target/wasm32-unknown-unknown/release/nearapps_nft.wasm ./res/

'''
'''--- res/scripts/test_simultaneous_calls.sh ---
#!/usr/bin/env bash

set -x

rm -rf "neardev/"

# initial exec deploy and init
WASM="../nearapps_exec.wasm"
near dev-deploy \
  --wasmFile $WASM
# load created acc's id as CONTRACT_NAME
source neardev/dev-account.env
EXEC="$CONTRACT_NAME"
# init exec
METHOD="new"
ARGS='{"owner_id": "'"$EXEC"'"}'
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC"

# nft creation, deploy and init
NFT="nft.$EXEC"
near create-account \
    "$NFT" \
    --masterAccount "$EXEC"
# deploy & init - owner (predecessor) is EXEC
WASM="../nearapps_nft.wasm"
METHOD="new_default_meta"
ARGS='{"owner_id": "'"$EXEC"'"}'
near deploy \
  --wasmFile "$WASM" \
  --contractName "$NFT" \
  --initFunction "$METHOD" \
  --initArgs "$ARGS"
# ''

# create various accounts that will also be able to call EXEC
OWNER_LEN=5
COUNTER=0
while [ $COUNTER -lt $OWNER_LEN ]
do
OWNER_ACC="owner-$COUNTER.$EXEC"
# create acc
near create-account \
    "$OWNER_ACC" \
    --masterAccount "$EXEC" \
    --initialBalance "5"
# add acc as another owner
METHOD="add_owner"
ARGS='{"owner_id": "'"$OWNER_ACC"'"}'
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC"
((COUNTER++))
done

SERIES_LEN=10
# creates 10 series with a single account (EXEC), timing it
INIT_MILLI1=$(date +%s%3N)
INNER_METHOD="nft_series_create"
METHOD="execute"
COUNTER=0
while [ $COUNTER -lt $SERIES_LEN ]
do
OWNER_ACC="$EXEC"
USER_ACC="some-user-through-$OWNER_ACC"
INNER_ARGS='{\"name\": \"series of '"$USER_ACC"'\", \"capacity\": \"2\", \"creator\": \"'"$USER_ACC"'\"}'
ARGS='{"context": {"contract_call": {"contract_id": "'"$NFT"'", "method_name": "'"$INNER_METHOD"'", "args": "'"$INNER_ARGS"'"}, "tag_info": {"app_id": "nft-id", "action_id": "'"$COUNTER"'", "user_id": "'"$USER_ACC"'"}}}'
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$OWNER_ACC" \
    --gas 300000000000000
((COUNTER++))
done
END_MILLI1=$(date +%s%3N)
echo "took $(($END_MILLI1 - $INIT_MILLI1))ms"

# show how many series are created
METHOD="nft_series_supply"
ARGS='{}'
near call \
    "$NFT" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC"

# creates 10 series with multiple accounts, timing it
INIT_MILLI2=$(date +%s%3N)
INNER_METHOD="nft_series_create"
METHOD="execute"
COUNTER=0
while [ $COUNTER -lt $SERIES_LEN ]
do
OWNER_ACC="owner-$(($COUNTER % $OWNER_LEN)).$EXEC"
USER_ACC="some-user-through-$OWNER_ACC"
INNER_ARGS='{\"name\": \"series of '"$USER_ACC"'\", \"capacity\": \"2\", \"creator\": \"'"$USER_ACC"'\"}'
ARGS='{"context": {"contract_call": {"contract_id": "'"$NFT"'", "method_name": "'"$INNER_METHOD"'", "args": "'"$INNER_ARGS"'"}, "tag_info": {"app_id": "nft-id", "action_id": "'"$COUNTER"'", "user_id": "'"$USER_ACC"'"}}}'
# executes in the background
near call \
    "$EXEC" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$OWNER_ACC" \
    --gas 300000000000000 \
    &
PIDS[${i}]=$!
((COUNTER++))
done
# wait for all subprocesses 
for PID in ${PIDS[*]}; do
    wait $PID
done
END_MILLI2=$(date +%s%3N)
echo "took $(($END_MILLI2 - $INIT_MILLI2))ms"

# show how many series are created
METHOD="nft_series_supply"
ARGS='{}'
near call \
    "$NFT" \
    "$METHOD" \
    "$ARGS" \
    --accountId "$EXEC"

echo "serial took $(($END_MILLI1 - $INIT_MILLI1))ms"
echo "concurrent took $(($END_MILLI2 - $INIT_MILLI2))ms"
'''