*GitHub Repository "miohtama/advanced-fungible"*

'''--- .github/workflows/node.js.yml ---
# Uses some magical shared CI near chain

name: Build contracts and execute JS tests

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [12.x]

    steps:
    - uses: actions/checkout@v2
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - name: Yarn CI installation of NPM packages
      run: yarn install --frozen-lockfile
    - name: Use Rust with WASM toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        target: wasm32-unknown-unknown
    - name: Cargo build
      run: cd contract && cargo build --release --target wasm32-unknown-unknown
    - name: JS tests
      run: yarn jest

'''
'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
# Rainbow hackathon presention

## Name of Project

Advanced Fungible token standard

![logo](./logo.png)

### Project description

Advanced Fungible is a modern, secure and user-friendly token standard for NEAR protocol. It fixes some of the issues past token implementations, especially ERC-20 and NEP-21, have. It includes features like single-click trades, more useful metadata like icons and Rust compiler based security features. 

### Project Team

Mikko Ohtamaa - coding - https://github.com/miohtama/

Rachel Black - design and art advisor - https://github.com/RachBLondon

### 2 Minute Video

[![](http://img.youtube.com/vi/iOBxgXtoOJ8/0.jpg)](http://www.youtube.com/watch?v=iOBxgXtoOJ8 "Rainbow Hackathon presentation")

# README

**Advanced Fungible is a modern, secure and user-friendly token standard for NEAR protocol**

![badge](https://github.com/miohtama/advanced-fungible-token/workflows/Build%20contracts%20and%20execute%20JS%20tests/badge.svg)

![logo](./logo.png)

# Walkthrough

![1](./presentation/1.png)

![2](./presentation/2.png)

![3](./presentation/3.png)

![4](./presentation/4.png)

![5](./presentation/5.png)

![6](./presentation/6.png)

# Benefits

* Slick user and developer experience with single transaction `send()` vs. `approve()` and `transferFrom()`

* Security primitives to safely interact with tokens on the NEAR sharded blockchain and promises

* A lot of code examples

## How does it work

There are two main functions

- `Token.send()` for sending tokens to users and smart contracts

- `Receiver.on_received()` for receiving tokens on smart contracts and taking any action on an incoming transfer

Each cross-shard transaction in NEAR is a promise. When multiple smart contracts
interact with each other, promises are chained. The ledger
locks up any tokens that are "in transit" so that they cannot be double spent,
or subject to anything equal to Ethereum re-entrancy attack.
In the case the promise chain fails, any locked up transactions
are rolled back and balances restored to the point before the promise chain was started.

# Technology

* Smart contracts written in Rust

* Automated test suite using JavaScript, jest, near-js-api

* Continuous integration on [Github workflows](https://github.com/miohtama/advanced-fungible/actions) and NEAR testnet

## Development

Below is how to build and run tests.

```sh

# Install rust
brew install rustup
rustup update

# Build and execute contract unit tests
cd contracts
cargo build
cargo test

# Build and execute contract acceptance tests
cd ..
yarn install
yarn jest
```

### Running a single test

Example

```sh
npx jest src/token.test.js
```

## Visual Studio Code

Install Rust extension. Choose *Start Rust Server* from the command palette.

## Test cases

JavaScript test cases are written with Jest and a custom runner
that uses https://rpc.ci-testnet.near.org chain.

# Challenges

NEAR protocol is advertised developer-friendly, but currently the state of the matter is that this statement
is mostly inspirational. A lot of toolchain design mistakes, brokeness and lack of documentation held
back the development.

- The lack of notion that two contracts may be actually needed and they may interact through all the toolchain.
  Maybe this was simplification or oversight in the original design decisions, but means anything NEAR
  is not useful for any serious smart contract development.

- These is zero information how to set up repeatable local net for integration testing

- `create-near-app` is hardcoded for a single contract, both JavaScript codebase and Rust codebase.

- Rust unit tests cannot test contract interactions.

- Contracts are defined in Rust as libraries instead of binaries what they are,
  making dealing with multiple contracts even more difficult and semantically incorrect.

- A broken simulation tests suite exists, but is undocumented, way too difficult to use and
  does not support contract interactions.

- There is no concept of ABI files, all contract interfaces must be re-described in JavaScript by hand.

- near-js-api does not document how to interact with contracts https://near.github.io/near-api-js/modules/_contract_.html

- near-js-api test helpers are not reusable, a copy-paste test utility suite had to be created.

- Manually specifying gas amounts in contract calls is cumbersome https://github.com/near/core-contracts/blob/master/lockup/src/owner_callbacks.rs#L330

- Documentation (https://docs.near.org/docs/development/calling-smart-contracts) and code examples (near-js-api) are not cross referenced, making it very hard to navigate and figure out
  up-to-date documentation.

- Need an explorer for CI transactions

- Promise parameter serialisation to JSON is painful - amounts

# Further reading

Some other code examples:

https://docs.near.org/docs/development/calling-smart-contracts

https://github.com/near/near-sdk-rs/blob/master/examples/fungible-token/src/lib.rs

https://github.com/near/core-contracts/tree/master/lockup/src

https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html

https://github.com/near-examples/simulation-testing

https://github.com/near-examples/guest-book/tree/master

https://github.com/smartcontractkit/near-protocol-contracts

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- contract/Cargo.toml ---
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

# https://stackoverflow.com/q/64129432/315168
overflow-checks = true

[workspace]
members = [
    "token",
    "pool"
]

'''
'''--- contract/pool/Cargo.toml ---
[package]
name = "nep9000_pool"
version = "0.0.0"

# https://stackoverflow.com/a/53985748/315168
edition = "2018"

[dependencies]
near-sdk = "2.0.0"
# nep9000_token = { path = "../token" }

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- contract/pool/src/lib.rs ---
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]

use near_sdk::json_types::U128;
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize};
use near_sdk::{ env, near_bindgen, AccountId, Balance, Promise };

// use nep9000_token::receiver::{ Receiver };

// ##[global_allocator]
// static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

/*
 * A simple smart contract that can receive token transfers.
 *
 * It's called burner pool, because it is one way pool, so
 * mostly useful for testing.
 *
 */
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct BurnerPool {

    // Which token this escrow contract is for
    pub token_id: AccountId,

    // How many tokens the contract has received overall
    pub total_received: Balance,

}

impl Default for BurnerPool {

    fn default() -> Self {
        panic!("Contract should be initialized before usage")
    }
}

/*
 * Handle incoming token transfers.
 *
 */
#[near_bindgen]
impl BurnerPool {

    // This is called by the token contract to identify us as a compatible receiver
    pub fn is_receiver() -> bool {
        env::log(b"is_receover reached");
        return true;
    }

    pub fn on_token_received(&mut self, sender_id: AccountId, amount_received: U128, amount_total: U128, message: Vec<u8>) -> Option<String> {

        assert_eq!(
            self.token_id,
            env::predecessor_account_id(),
            "Pool can only receive the named token {}, got notifier from {}",
            self.token_id, env::predecessor_account_id()
        );
        let amount: u128 = amount_received.into();
        let uint_amount_total = amount_total.into();
        self.total_received += amount;

        env::log(format!("on_token_received, incoming balance {} total {}", amount, self.total_received).as_bytes());

        assert!(self.total_received == uint_amount_total, "Mismatch between token ledger and pool balances");

        // TODO: Add error codes and graceful error handling
        return None;
    }

}

#[near_bindgen]
impl BurnerPool {

    #[init]
    pub fn new(token_id: AccountId) -> Self {

        assert!(!env::state_exists(), "Already initialized");

        assert!(
            env::is_valid_account_id(token_id.as_bytes()),
            format!("{} account ID is invalid", token_id)
        );

        let pool = Self {
            token_id: token_id,
            total_received: 0,
        };

        return pool;
    }

    pub fn get_total_received(self) -> Balance {
        return self.total_received;
    }
}

'''
'''--- contract/token/Cargo.toml ---
[package]
name = "nep9000_token"
version = "0.1.0"
authors = ["Mikko Ohtama <mikko@capitalgram.com>"]
edition = "2018" # https://stackoverflow.com/a/53985748/315168

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

'''
'''--- contract/token/build.js ---
const shell = require('shelljs')

shell.fatal = true // same as "set -e"

shell.cd('contract')
// Note: see flags in ./cargo/config
shell.exec('cargo build --target wasm32-unknown-unknown --release')
shell.mkdir('-p', '../out')
shell.cp('./target/wasm32-unknown-unknown/release/nep9000.wasm', '../out/main.wasm')

'''
'''--- contract/token/src/lib.rs ---
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]

use near_sdk::wee_alloc;

pub mod token;
pub mod receiver;
pub mod utils;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

'''
'''--- contract/token/src/pool.rs ---
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize};
use near_sdk::wee_alloc;
use near_sdk::{ env, near_bindgen, AccountId, Balance, Promise };

use crate::receiver::{ Receiver };
use crate::token::{ Token };

/*
 * A simple smart contract that can receive token transfers.
 */
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct BurnerPool {

    // Which token this escrow contract is for
    pub token_id: AccountId,

    // How many tokens the contract has received overall
    pub total_received: Balance,

}

impl Default for BurnerPool {

    fn default() -> Self {
        panic!("Contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Receiver for BurnerPool {

    fn on_token_received(&mut self, sender_id: AccountId, amount: Balance, _message: Vec<u8>) -> bool{
        assert!(sender_id == self.token_id, "Pool can only receive the named token");
        env::log(format!("Received {} tokens from {}", amount, sender_id).as_bytes());
        self.total_received += amount;
        return false;
    }

}

#[near_bindgen]
impl BurnerPool {

    #[init]
    fn new(token_id: AccountId) -> Self {

        assert!(!env::state_exists(), "Already initialized");

        let pool = Self {
            token_id: token_id,
            total_received: 0,
        };

        return pool;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1_000_000_000_000_000_000_000_000_000u128,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn test_new() {

        let context = get_context(carol());
        testing_env!(context);
        let total_supply = 1_000_000_000_000_000u128;
        let token = Token::new(bob(), total_supply.into());

    }
}

'''
'''--- contract/token/src/receiver.rs ---
use near_sdk::{ AccountId, Balance, ext_contract };
use near_sdk::json_types::U128;

/* The smart contract interface for handing incoming token transfers of Advanced Fungible.
 *
 */
#[ext_contract(ext_token_receiver)]
pub trait Receiver {

    /// Interface check promise to check if the receiver contract is able to handle Advanced Fungible
    /// Always return true
    fn is_receiver(self) -> PromiseOrValue<bool>;

    /// Notified after the balance transfer is complete. Must return true to finalise the transaction.
    /// TODO: More advanced error code / return value needed
    fn on_token_received(&mut self, sender_id: AccountId, amount_received: U128, amount_total: U128, message: Vec<u8>) -> PromiseOrValue<bool>;
}
'''
'''--- contract/token/src/token.rs ---
/**
 * An advanced fungible token implementation.
 *
 */

use near_sdk::serde_json::{self, json};
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize};
use near_sdk::{ env, near_bindgen, ext_contract, AccountId, Balance, Promise, StorageUsage};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;

use crate::receiver::{ ext_token_receiver };
use crate::utils::{ is_promise_success };

// TODO: All gas stipends are more or less random - check througfully
const SINGLE_CALL_GAS: u64 = 200000000000000;

/**
 * A balance ledger that keeps track of rollbackable promise transactions.
 *
 * TODO: Currently we lock balance by account, but this is not very flexible.
 * What we really want to is lock balancy by a promise chain. However, this
 * would need to be able to identify the originating transaction in NEAR
 * and currently I am not sure if this information is exposed
 * on the smart contract level.
 *
 * https://stackoverflow.com/questions/64170363/tracking-promise-chains-in-near-smart-contract-protocol
 *
 */
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Ledger {

    // Total balances, including locked, for each user
    pub balances: LookupMap<AccountId, Balance>,

    /// Account has a pending promise chain in progress
    /// and balance locked is this chain cannot be withdawn.
    /// If a promise chain is succesful free the locked balance.
    /// If a promise chain fails, then the send() gets undoed
    pub locked_balances: LookupMap<AccountId, Balance>,

    /// Total supply of the token
    pub total_supply: Balance,

    /// Helper counter for testing to diagnose
    /// how many rollbacks have occured
    pub rollbacks: u64,
}

impl Ledger {

    /// Helper method to get the account details for `owner_id`.
    fn get_balance(&self, owner_id: &AccountId) -> u128 {
        match self.balances.get(owner_id) {
            Some(x) => return x,
            None => return 0,
        }
    }

    /// Helper method to set the account details for `owner_id` to the state.
    fn set_balance(&mut self, owner_id: &AccountId, balance: Balance) {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid");
        self.balances.insert(owner_id, &balance);
    }

    /// Helper method to get the account details for `owner_id`.
    fn get_locked_balance(&self, owner_id: &AccountId) -> Balance {
        match self.locked_balances.get(owner_id) {
            Some(x) => return x,
            None => return 0,
        }
    }

    /**
     * Send tokens to a new owner.
     *
     * message is an optional byte data that is passed to the receiving smart contract.
     * notify is a flag to tell if we are going to call a smart contract, because this cannot be currently resolved run-time
     * within NEAR smart contract.
     */
    pub fn send(&mut self, owner_id: AccountId, new_owner_id: AccountId, amount: Balance, message: Vec<u8>) {

        assert!(
            env::is_valid_account_id(new_owner_id.as_bytes()),
            "New owner's account ID is invalid"
        );
        let amount = amount.into();
        if amount == 0 {
            env::panic(b"Can't transfer 0 tokens");
        }
        assert_ne!(
            owner_id, new_owner_id,
            "The new owner should be different from the current owner"
        );
        // Retrieving the account from the state.
        let source_balance = self.get_balance(&owner_id);
        let source_lock = self.get_locked_balance(&owner_id);

        // Checking and updating unlocked balance
        if source_balance < amount {
            env::panic(format!("Not enough balance, need {}, has {}", amount, source_balance).as_bytes());
        }

        // Checking and updating unlocked balance
        if source_balance < amount + source_lock {
            env::panic(format!("Cannot send {} tokens, as account has {} and in tx lock {}", amount, source_balance, source_lock).as_bytes());
        }
        self.set_balance(&owner_id, source_balance - amount);

        // Deposit amount to the new owner and save the new account to the state.
        let target_balance = self.get_balance(&new_owner_id);
        let new_target_balance = target_balance + amount;
        self.set_balance(&new_owner_id, new_target_balance);

        // This much of user balance is lockedup in promise chains
        self.set_balance(&new_owner_id, new_target_balance);

        let target_lock = self.get_locked_balance(&new_owner_id);
        self.locked_balances.insert(&new_owner_id, &(target_lock +  amount));

        let promise0 = env::promise_create(
            new_owner_id.clone(),
            b"is_receiver",
            &[],
            0,
            SINGLE_CALL_GAS/3,
        );

        let promise1 = env::promise_then(
            promise0,
            env::current_account_id(),
            b"handle_receiver",
            json!({
                "old_owner_id": owner_id,
                "new_owner_id": new_owner_id,
                "amount_received": amount.to_string(),
                "amount_total": new_target_balance.to_string(),
                "message": message,
            }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS/3,
        );

        env::promise_return(promise1);
    }

    /// All promise chains have been successful, release balance from the lock
    /// and consider the promise chain final.
    pub fn finalise(&mut self, new_owner_id: AccountId, amount: Balance) {
        let target_lock = self.get_locked_balance(&new_owner_id);

        assert!(
            target_lock >= amount,
            "Locked balance cannot go to negative"
        );

        let new_amount = target_lock -  amount;

        self.locked_balances.insert(&new_owner_id, &new_amount);

    }

    /// Smart contract call failed. We need to roll back the balance update
    pub fn rollback(&mut self, old_owner_id: AccountId, new_owner_id: AccountId, amount: Balance) {
        let target_lock = self.get_locked_balance(&new_owner_id);
        let target_balance = self.get_balance(&new_owner_id);
        let source_balance = self.get_balance(&old_owner_id);

        env::log(format!("Rolling back back send of {}, from {} to {}, currently locked {}", amount, old_owner_id, new_owner_id, target_lock).as_bytes());
        env::log(format!("New owner balance {}, old owner balance {}", target_balance, source_balance).as_bytes());

        assert!(
            target_lock >= amount,
            "Locked balance cannot go to negative"
        );

        // Roll back lock
        let new_amount = target_lock - amount;
        self.locked_balances.insert(&new_owner_id, &new_amount);
        self.balances.insert(&new_owner_id, &new_amount);

        // Rollback new owner
        let new_target_balance = target_balance - amount;
        self.set_balance(&new_owner_id, new_target_balance);

        // Rollback old owner
        let new_source_balance = source_balance + amount;
        self.set_balance(&old_owner_id, new_source_balance);

        let target_balance = self.get_balance(&new_owner_id);
        let source_balance = self.get_balance(&old_owner_id);

        self.rollbacks += 1;
    }
}

/*
 * Information about the token.
 *
 * We hold the name, symbol and homepage readibly available on chain, but other information must be
 * from the JSON data. This way we do not bloat the chain size and also make upgrading the information
 * somewhat easier.
 *
 * All metadata fields are optional.
 */
#[derive(BorshDeserialize, BorshSerialize)]
 pub struct Metadata {

    // Name of the token
    pub name: String,

    // Symbol of the token
    pub symbol: String,

    // URL to the human readable page about the token
    pub web_link: String,

    // URL to the metadata file with more information about the token, like different icon sets
    pub metadata_link: String,
}

/**
 * Presents on token.
 */
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {

    pub ledger: Ledger,

    pub metadata: Metadata,
}

impl Default for Token {

    fn default() -> Self {
        panic!("Token should be initialized before usage")
    }
}

#[near_bindgen]
impl Token {

    /// Initializes the contract with the given total supply owned by the given `owner_id`.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: Balance) -> Self {

        assert!(!env::state_exists(), "Already initialized");

        let total_supply = total_supply.into();

        // Initialize the ledger with the initial total supply
        let ledger = Ledger {
            balances: LookupMap::new(b"bal".to_vec()),
            locked_balances: LookupMap::new(b"lck".to_vec()),
            total_supply,
            rollbacks: 0,
        };

        // Currently the constructor does not support passing of metadata.
        // Start with empty metadata, owner needs to initialize this
        // after the token has been created in another transaction
        let metadata = Metadata {
            name: String::from(""),
            symbol: String::from(""),
            web_link: String::from(""),
            metadata_link: String::from(""),
        };

        let mut token = Self {
            ledger,
            metadata
        };
        token.ledger.set_balance(&owner_id, total_supply);
        return token;
    }

    /// Returns total supply of tokens.
    pub fn get_total_supply(&self) -> Balance {
        self.ledger.total_supply.into()
    }

    /// Returns balance of the `owner_id` account.
    pub fn get_balance(&self, owner_id: AccountId) -> Balance {
        self.ledger.get_balance(&owner_id).into()
    }

    /// Returns balance lockedin pending transactions
    pub fn get_locked_balance(&self, owner_id: AccountId) -> Balance {
        self.ledger.get_locked_balance(&owner_id).into()
    }

    //// How many rollbacks we have had
    pub fn get_rollback_count(&self) -> u64 {
        self.ledger.rollbacks
    }

    /// Returns balance of the `owner_id` account.
    pub fn get_name(&self) -> &str {
        return &self.metadata.name;
    }

    /// Send owner's tokens to another person or a smart contract
    #[payable]
    pub fn send(&mut self, new_owner_id: AccountId, amount: Balance, message: Vec<u8>) {
        self.ledger.send(env::predecessor_account_id(), new_owner_id, amount, message);
    }

    /**
     * After trying to call receiving smart contract if it reports it can receive tokens.
     *
     * We gpt the interface test promise back. If the account was not smart contract, finalise the transaction.
     * Otherwise trigger the smart contract notifier.
     */
    pub fn handle_receiver(&mut self, old_owner_id: AccountId, new_owner_id: AccountId, amount_received: U128, amount_total: U128, message: Vec<u8>) {
        // Only callable by self
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        env::log(b"handle_receiver reached");

        let uint_amount_received: u128 = amount_received.into();
        let uint_amount_total: u128 = amount_total.into();

        if is_promise_success() {

            // The send() was destined to a compatible receiver smart contract.
            // Build another promise that notifies the smart contract
            // that is has received new tokens.

            env::log(b"Constructing smart contract notifier promise");

            let promise0 = env::promise_create(
                new_owner_id.clone(),
                b"on_token_received",
                json!({
                    "sender_id": old_owner_id,
                    "amount_received": amount_received,
                    "amount_total": amount_total,
                    "message": message,
                }).to_string().as_bytes(),
                0,
                SINGLE_CALL_GAS/10,
            );

            // Construct the promise that calls back the
            // token contract to finalise the transaction
            let promise1 = env::promise_then(
                promise0,
                env::current_account_id(),
                b"handle_token_received",
                json!({
                    "old_owner_id": old_owner_id,
                    "new_owner_id": new_owner_id,
                    "amount_received": amount_received,
                }).to_string().as_bytes(),
                0,
                SINGLE_CALL_GAS/10,
            );

            env::promise_return(promise1);
        } else {
            // Non-code account
            // Finalise transaction now.
            self.ledger.finalise(new_owner_id, uint_amount_received);
        }
    }

    /// Smart contract notify succeed, free up any locked balance
    /// TODO: Add functionality so that the smart contract that received tokens can trigger a new promise chain here
    pub fn handle_token_received(&mut self, old_owner_id: AccountId, new_owner_id: AccountId, amount_received: U128) {
        // Only callable by self
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        env::log(b"Checking for the need to rollback smart contract transaction");

        let amount_received: u128 = amount_received.into();

        // TODO: Have some nice error code logic here
        if is_promise_success() {
            self.ledger.finalise(new_owner_id, amount_received);
        } else {
            self.ledger.rollback(old_owner_id, new_owner_id, amount_received);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1_000_000_000_000_000_000_000_000_000u128,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn test_new() {
        let context = get_context(carol());
        testing_env!(context);
        let total_supply = 1_000_000_000_000_000u128;
        let contract = Token::new(bob(), total_supply.into());
        assert_eq!(contract.get_total_supply(), total_supply);
        assert_eq!(contract.get_balance(bob()), total_supply);
    }

}

'''
'''--- contract/token/src/utils.rs ---
use near_sdk::{env, PromiseResult};

pub fn assert_self() {
    assert_eq!(env::predecessor_account_id(), env::current_account_id());
}

pub fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}
'''
'''--- package.json ---
{
  "name": "nep-9000",
  "version": "0.1.0",
  "license": "MIT",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "( cd contract && cargo build --target wasm32-unknown-unknown --release )",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch assembly -e ts --exec \"npm run start\"",
    "jest": "jest test --runInBand",
    "build-and-test": "npm run build:contract && npm run jest"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.9.5",
    "@babel/preset-react": "^7.9.4",
    "babel-jest": "^26.0.0",
    "env-cmd": "^10.1.0",
    "gh-pages": "^3.0.0",
    "jest": "^26.0.1",
    "jest-environment-node": "^26.0.0",
    "near-cli": "^1.0.1",
    "nodemon": "^2.0.3",
    "parcel-bundler": "^1.12.4",
    "react-test-renderer": "^16.13.1",
    "shelljs": "^0.8.4"
  },
  "dependencies": {
    "near-api-js": "^0.29.0",
    "near-hello": "^0.5.1",
    "node-fetch": "^2.6.1",
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "regenerator-runtime": "^0.13.5"
  },
  "jest": {
    "moduleNameMapper": {
      "\\.(jpg|ico|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/src/__mocks__/fileMock.js",
      "\\.(css|less)$": "<rootDir>/src/__mocks__/fileMock.js"
    },
    "setupFiles": [
      "<rootDir>/src/jest.init.js"
    ],
    "testEnvironment": "<rootDir>/src/test-environment.js",
    "testPathIgnorePatterns": [
      "<rootDir>/assembly/",
      "<rootDir>/node_modules/"
    ],
    "testTimeout": 45000
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- src/abi.js ---
// Hand-written ABI methods for the contracts
export const abi = {
    pool: {
        viewMethods: ['get_total_received', 'is_receiver'],
        changeMethods: ['new', 'on_token_received']
    },

    token: {
        viewMethods: ['get_total_supply', 'get_balance', 'get_locked_balance', 'get_rollback_count'],
        changeMethods: ['new', 'send', 'process_bytes']
    }
};
'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'nep-9000'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/pool.test.js ---
import BN from 'bn.js';
import { abi } from './abi';
import { createAccount, setUpTestConnection, deployContract, generateUniqueString } from './test-utils';

const TRANSFER_GAS = new BN("300000000000000");

let near;

// Normal user accounts
let deployer, vitalik;

beforeAll(async function () {
    near = await setUpTestConnection();
    deployer = await createAccount(near);
    vitalik = await createAccount(near);
});

test('Deploy pool contract', async () => {
    const poolContract = await deployContract(deployer, generateUniqueString('cnt'), 'pool', abi.pool);

    let action = await deployer.functionCall(
        poolContract.contractId,
        "new",
        {
            // Can be any account in this test
            token_id: deployer.accountId,
        }
    );
    expect(action.status?.SuccessValue).toBe('');

    const received = await poolContract.get_total_received();
    expect(received).toEqual(0);

    const receiverIface = await poolContract.is_receiver();
    expect(receiverIface).toEqual(true);
});

test('Cannot initialize pool twice', async () => {
    const poolContract = await deployContract(deployer, generateUniqueString('cnt'), 'pool', abi.pool);
    await poolContract.new({ token_id: deployer.accountId });
    // second init
    try {
        await poolContract.new({ token_id: deployer.accountId });
        throw new Error('Not reachable');
    } catch(e) {
        expect(e.panic_msg).toMatch(/Already initialized/);
    }
});

test('Pool accounts received tokens', async () => {

    const tokenContract = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);
    await tokenContract.new({
        // Vitalik owns us
        owner_id: vitalik.accountId,
        total_supply: 10000,
    });

    const poolContract = await deployContract(deployer, generateUniqueString('cnt'), 'pool', abi.pool);
    await poolContract.new({ token_id: tokenContract.contractId });

    const result = await vitalik.functionCall(
        tokenContract.contractId,
        "send",
        {
            new_owner_id: poolContract.contractId,
            amount: 5000,
            message: []
        },
        TRANSFER_GAS
    );

    // Pool controls tokens now
    const balance = await tokenContract.get_balance({ owner_id: poolContract.contractId });
    expect(balance).toEqual(5000);

    const received = await poolContract.get_total_received();
    expect(received).toEqual(5000);

});

test('Send rolld back gracefully in the case of a promise error', async () => {

    const tokenContract = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);
    await tokenContract.new({
        // Vitalik owns us
        owner_id: vitalik.accountId,
        total_supply: 10000,
    });
    const tokenContract2 = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);

    const poolContract = await deployContract(deployer, generateUniqueString('cnt'), 'pool', abi.pool);

    // This pool does not support receiving tokens from the tokenContract
    await poolContract.new({ token_id: tokenContract2.contractId });

    const result = await vitalik.functionCall(
        tokenContract.contractId,
        "send",
        {
            new_owner_id: poolContract.contractId,
            amount: 5000,
            message: []
        },
        TRANSFER_GAS
    );

    const rollbacks = await tokenContract.get_rollback_count();
    expect(rollbacks).toEqual(1);

    // Check we rolled back the transaction data correctly
    const balance = await tokenContract.get_balance({ owner_id: poolContract.contractId });
    expect(balance).toEqual(0);

    const lockedBalance = await tokenContract.get_locked_balance({ owner_id: poolContract.contractId });
    expect(lockedBalance).toEqual(0);

    const received = await poolContract.get_total_received();
    expect(received).toEqual(0);

    const originalBalance = await tokenContract.get_balance({ owner_id: vitalik.accountId });
    expect(originalBalance).toEqual(10000);

});

'''
'''--- src/test-environment.js ---
const NodeEnvironment = require('jest-environment-node');
const nearAPI = require('near-api-js');
const fs = require('fs');

const { PROJECT_KEY_DIR } = require('../node_modules/near-cli/middleware/key-store');

const INITIAL_BALANCE = '500000000000000000000000000';
const testAccountName = 'test.near';

class LocalTestEnvironment extends NodeEnvironment {
    constructor(config) {
        super(config);
    }

    async setup() {

        this.global.nearlib = require('near-api-js');
        this.global.nearAPI = require('near-api-js');
        this.global.window = {};
        this.global.window.name = "nodejs"; // https://github.com/near/near-api-js/issues/415
        let config = require('./config')('ci');
        this.global.testSettings = this.global.nearConfig = config;
        const now = Date.now();
        // create random number with at least 7 digits
        const randomNumber = Math.floor(Math.random() * (9999999 - 1000000) + 1000000);
        config = Object.assign(config, {
            contractName: 'test-account-' + now + '-' + randomNumber,
            accountId: 'test-account-' + now + '-' + randomNumber
        });
        const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(PROJECT_KEY_DIR);
        config.deps = Object.assign(config.deps || {}, {
            storage:  this.createFakeStorage(),
            keyStore,
        });
        const near = await nearAPI.connect(config);

        // const masterAccount = await near.account(testAccountName);
        // const randomKey = await nearAPI.KeyPair.fromRandom('ed25519');
        // await config.deps.keyStore.setKey(config.networkId, config.contractName, randomKey);
        // await masterAccount.createAndDeployContract(config.contractName, randomKey.getPublicKey(), data, INITIAL_BALANCE);

        await super.setup();
    }

    async teardown() {
        await super.teardown();
    }

    runScript(script) {
        return super.runScript(script);
    }

    createFakeStorage() {
        let store = {};
        return {
            getItem: function(key) {
                return store[key];
            },
            setItem: function(key, value) {
                store[key] = value.toString();
            },
            clear: function() {
                store = {};
            },
            removeItem: function(key) {
                delete store[key];
            }
        };
    }
}

module.exports = LocalTestEnvironment;

'''
'''--- src/test-utils.js ---
const fs = require('fs').promises;
const BN = require('bn.js');
const nearApi = require('near-api-js');
const assert = require('assert');
const { resolve } = require("path");

const networkId = 'unittest';

// TODO: Cargo cult copying because I have not idea what should be there
// Some deployments take more gas. If the deployment fails just keep increasing this number.
const CONTRACT_BALANCE = new BN('50000000000000000000000000');

async function setUpTestConnection() {
    const keyStore = new nearApi.keyStores.InMemoryKeyStore();
    const config = Object.assign(require('./config')(process.env.NODE_ENV || 'test'), {
        networkId: networkId,
        deps: { keyStore },
    });

    // TODO: I have no clue what this is because it was commented in the original source code.
    if (config.masterAccount) {
        await keyStore.setKey(networkId, config.masterAccount, nearApi.utils.KeyPair.fromString('ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw'));
    }

    return nearApi.connect(config);
}

// Generate some unique string with a given prefix using the alice nonce.
function generateUniqueString(prefix) {
    return `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
}

async function createAccount(near) {
    assert(near);
    assert(near.connection);
    assert(near.connection.signer);
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await near.connection.signer.createKey(newAccountName, networkId);
    await near.createAccount(newAccountName, newPublicKey);
    const account = new nearApi.Account(near.connection, newAccountName);
    return account;
}

async function deployContract(workingAccount, contractId, contractName, abi) {
    const newPublicKey = await workingAccount.connection.signer.createKey(contractId, networkId);
    let path = `${__dirname}/../contract/target/wasm32-unknown-unknown/release/nep9000_${contractName}.wasm`;
    path = resolve(path);
    const data = [...(await fs.readFile(path))];

    assert(data.length < 200000, `That's one massive contract ${data.length} bytes`);

    await workingAccount.createAndDeployContract(contractId, newPublicKey, data, CONTRACT_BALANCE);
    const contract = new nearApi.Contract(workingAccount, contractId, abi);
    contract.contractId = contractId;
    return contract;
}

function sleep(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

async function ensureDir(dirpath) {
    try {
        await fs.mkdir(dirpath, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

module.exports = {
    setUpTestConnection,
    networkId,
    generateUniqueString,
    createAccount,
    deployContract,
    sleep,
    ensureDir
};

'''
'''--- src/token.test.js ---
import BN from 'bn.js';
import { abi } from './abi';
import { createAccount, setUpTestConnection, deployContract, generateUniqueString } from './test-utils';

const TRANSFER_GAS = new BN("300000000000000");

// NEAR connection
let near;

// Normal user accounts
let deployer, vitalik, gavin;

beforeAll(async function () {
    near = await setUpTestConnection();
    deployer = await createAccount(near);
    vitalik = await createAccount(near);
    gavin = await createAccount(near);
});

test('Deploy token contract', async () => {
    const tokenContract = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);

    await tokenContract.new({
        // Vitalik owns us
        owner_id: vitalik.accountId,
        total_supply: 10000,
    });

    const totalSupply = await tokenContract.get_total_supply();
    expect(totalSupply).toEqual(10000);

    // The initial owner has everything
    const balance = await tokenContract.get_balance({ owner_id: vitalik.accountId });
    expect(balance).toEqual(10000);

    const locked = await tokenContract.get_locked_balance({ owner_id: vitalik.accountId });
    expect(locked).toEqual(0);

    // No balance
    const balance2 = await tokenContract.get_balance({ owner_id: gavin.accountId });
    expect(balance2).toEqual(0);

    // No balance
    const balance3 = await tokenContract.get_balance({ owner_id: deployer.accountId });
    expect(balance3).toEqual(0);

});

test('Can send between accounts', async () => {

    const tokenContract = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);

    await tokenContract.new({
        // Vitalik owns us
        owner_id: vitalik.accountId,
        total_supply: 10000,
    });

    // Vitalik calls token.send()
    const result = await vitalik.functionCall(
        tokenContract.contractId,
        "send",
        {
            new_owner_id: gavin.accountId,
            amount: 800,
            message: [],
            notify: false
        },
        TRANSFER_GAS,
    )

    expect(result.status?.SuccessValue).toBe('');

    // The initial owner has everything
    const balance = await tokenContract.get_balance({ owner_id: vitalik.accountId });
    expect(balance).toEqual(9200);

    const balance2 = await tokenContract.get_balance({ owner_id: gavin.accountId });
    expect(balance2).toEqual(800);

    // No balance
    const balance3 = await tokenContract.get_balance({ owner_id: deployer.accountId });
    expect(balance3).toEqual(0);
});

test('Cannot send too much', async () => {

    const tokenContract = await deployContract(deployer, generateUniqueString('cnt'), 'token', abi.token);

    await tokenContract.new({
        // Vitalik owns us
        owner_id: vitalik.accountId,
        total_supply: 10000,
    });

    try {
        await vitalik.functionCall(
            tokenContract.contractId,
            "send",
            {
                new_owner_id: gavin.accountId,
                amount: 11000,
                message: [],
                notify: false
            }
        )
        throw new Error("Not reached");
    } catch(e) {
        expect(e.panic_msg).toMatch(/Not enough balance/);
    }
});
'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''