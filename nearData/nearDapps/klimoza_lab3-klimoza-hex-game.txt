*GitHub Repository "klimoza/lab3-klimoza-hex-game"*

'''--- Cargo.toml ---
[package]
name = "hex-game"
version = "0.1.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
The Game of Hex
===============
Hex is a two player abstract strategy board game in which players attempt to connect opposite sides of a rhombus-shaped board made of hexagonal cells. Hex was invented by mathematician and poet Piet Hein in 1942 and later rediscovered and popularized by John Nash. 

## Description
This contract implements hex-game backed by storage on NEAR blockchain.
Contract in `src/lib.rs` provides methods to create new game, make an allowed move in one of already existing games or view information about game by index.

The project is divided into separate files, each file contains one of the structures, that is used to keep information about the game, and tests for this structure.

## Interacting with contract

Deployed game contract in testnet: `hex-game.klimoza.testnet`

#### `create_game(first_player: AccountId, second_player: AccountId, field_size: usize) -> GameIndex`

Creates new game with given parameters and returns index of created game. For example:
```console
➜ near call hex-game.klimoza.testnet create_game '{"first_player": "crossword.klimoza.testnet", "second_player": "klimoza.testnet", "field_size": 2}' --accountId hex-game.klimoza.testnet --amount 2
Scheduling a call: hex-game.klimoza.testnet.create_game({"first_player": "crossword.klimoza.testnet", "second_player": "klimoza.testnet", "field_size": 2})
Doing account.functionCall()

	Log [hex-game.klimoza.testnet]: Created board:
	Log [hex-game.klimoza.testnet]: . .
	Log [hex-game.klimoza.testnet]:  . .

4
```

#### `make_move(index: GameIndex, move_type: MoveType, cell: Option<Cell>) -> Game`
Tries to make a move in the game at the given index and returns Game if move is correct(panics otherwise). Used structures:
```rust
pub type GameIndex = u64;

pub enum MoveType {
    PLACE,
    SWAP,
}

pub struct Cell {
    pub x: usize,
    pub y: usize,
}
```
You can omit the `cell` parameter if `move_type` is `SWAP`(i.e. applying swap rule on the current move). For example:
```console
➜ near call hex-game.klimoza.testnet make_move '{"index": 4, "move_type": "SWAP"}' --accountId klimoza.testnet
Scheduling a call: hex-game.klimoza.testnet.make_move({"index": 4, "move_type": "SWAP"})
Doing account.functionCall()

	Log [hex-game.klimoza.testnet]: Old board:
	Log [hex-game.klimoza.testnet]: . R
	Log [hex-game.klimoza.testnet]:  . .
	Log [hex-game.klimoza.testnet]: New board:
	Log [hex-game.klimoza.testnet]: . .
	Log [hex-game.klimoza.testnet]:  B .

{
  first_player: 'crossword.klimoza.testnet',
  second_player: 'klimoza.testnet',
  turn: 2,
  board: { size: 2, field: 'IA==' },
  current_block_height: 96244955,
  prev_block_height: 96244934,
  is_finished: false
}
```

#### `get_game(index: GameIndex) -> Option<Game>`
Returns the game at the given index(if there is one). For example:
```console
➜ near call hex-game.klimoza.testnet get_game '{"index": 4}' --accountId hex-game.klimoza.testnet
Scheduling a call: hex-game.klimoza.testnet.get_game({"index": 4})
Doing account.functionCall()

	Log [hex-game.klimoza.testnet]: Game board:
	Log [hex-game.klimoza.testnet]: R B
	Log [hex-game.klimoza.testnet]:  B .

{
  first_player: 'crossword.klimoza.testnet',
  second_player: 'klimoza.testnet',
  turn: 4,
  board: { size: 2, field: 'KQ==' },
  current_block_height: 96244985,
  prev_block_height: 96244971,
  is_finished: true
}
```

#### `check_premium_account(account_id: AccountId) -> bool`
Checks for a locked, expirable, active Roketo stream going from `account_id` to `hex_game_account`. Returns Promise. For example:
```console
➜ near call wrap.testnet ft_transfer_call '{"receiver_id": "streaming-r-v2.dcversus.testnet",  "amount": "2200000000000000000000000", "memo": "Roketo transfer", "msg": "{\"Create\":{\"request\":{\"balance\":\"2000000000000000000000000\", \"owner_id\": \"klimoza.testnet\",\"receiver_id\":\"hex-game.klimoza.testnet\",\"token_name\": \"wrap.testnet\", \"tokens_per_sec\":\"6666666666666666666667\", \"is_locked\": true, \"is_expirable\": true}}}"}' --accountId klimoza.testnet --depositYocto 1 --gas 200000000000000
Doing account.functionCall()

	Log [wrap.testnet]: Transfer 2200000000000000000000000 from klimoza.testnet to streaming-r-v2.dcversus.testnet
	Log [wrap.testnet]: Memo: Roketo transfer

	Log [wrap.testnet]: Transfer 2100000000000000000000000 from streaming-r-v2.dcversus.testnet to finance-r-v2.dcversus.testnet

'2200000000000000000000000'

➜ near call hex-game.klimoza.testnet check_premium_account '{"account_id": "klimoza.testnet"}' --accountId klimoza.testnet
Scheduling a call: hex-game.klimoza.testnet.check_premium_account({"account_id": "klimoza.testnet"})

true
```

## Testing
At the moment, the projects contains 33 tests, each of which lies in the file of the structure it is testing. You can run them all using following command:
```console
cargo test
```
Alternatively, you can specify test group you want to run, for example:
```console
cargo test cell_tests
```

## Demonstration

[![Video](https://img.youtube.com/vi/mwgUEafpeow/0.jpg)](https://youtu.be/mwgUEafpeow)
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/hex_game.wasm ./res/hex_game.wasm

'''
'''--- src/board.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, require};

use crate::cell::Cell;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Board {
    pub size: usize,
    pub field: Base64VecU8,
}

impl Board {
    pub fn new(size: usize) -> Self {
        require!(size <= 19, "The size of the field must be less or equal 19");
        let field_len = (size * size + 3) / 4;
        Board {
            size,
            field: Base64VecU8::from(vec![0u8; field_len]),
        }
    }

    fn get_byte_and_bit(&self, cell: &Cell) -> (u8, usize, usize) {
        let index = (self.size * cell.y + cell.x) * 2;
        let byte_index = index / 8;
        let byte: u8 = self.field.0[byte_index];
        let bit_index = index & 7;
        (byte, byte_index, bit_index)
    }

    pub fn get_cell(&self, cell: &Cell) -> u8 {
        require!(
            cell.x < self.size && cell.y < self.size,
            "Cell is out of bounds."
        );
        let (byte, _, bit_index) = self.get_byte_and_bit(cell);
        (byte >> bit_index) & 3
    }

    pub fn set_cell(&mut self, cell: &Cell, value: u8) {
        require!(
            cell.x < self.size && cell.y < self.size,
            "Cell is out of bounds."
        );
        require!(value <= 2, "Value is too big.");
        let (byte, byte_index, bit_index) = self.get_byte_and_bit(cell);
        let bits = (byte >> bit_index) & 3;
        let new_byte = byte ^ (bits << bit_index) ^ (value << bit_index);
        self.field.0[byte_index] = new_byte;
    }

    pub fn get_coords(&self, bit_number: usize) -> Cell {
        Cell::new(bit_number / 2 % self.size, bit_number / 2 / self.size)
    }

    pub fn get_board_as_strings(&self) -> Vec<String> {
        let mut vector = Vec::new();

        for i in 0..self.size {
            let mut result: String = (0..i).into_iter().map(|_| ' ').collect();
            for j in 0..self.size {
                let symbol = match self.get_cell(&Cell::new(j, i)) {
                    0 => '.',
                    1 => 'R',
                    2 => 'B',
                    _ => unreachable!(),
                };
                result.push(symbol);
                if j + 1 != self.size {
                    result.push(' ');
                }
            }
            vector.push(result);
        }

        vector
    }

    pub fn debug_logs(&self) {
        self.get_board_as_strings()
            .into_iter()
            .for_each(|s| env::log_str(&s));
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod board_tests {
    use near_sdk::json_types::Base64VecU8;

    use crate::cell::Cell;

    use super::Board;

    #[test]
    #[should_panic]
    fn test_board_is_too_big() {
        Board::new(20);
    }

    #[test]
    fn test_get_byte_and_bit() {
        let mut test_board = Board::new(11);
        assert_eq!((0, 3, 6), test_board.get_byte_and_bit(&Cell::new(4, 1)));
        assert_eq!((0, 0, 0), test_board.get_byte_and_bit(&Cell::new(0, 0)));
        assert_eq!((0, 5, 0), test_board.get_byte_and_bit(&Cell::new(9, 1)));

        let mut test_vec = vec![0u8; 7];
        test_vec[0] = 255;
        test_vec[1] = 19;
        test_vec[2] = 7;
        test_vec[3] = 113;
        test_board = Board {
            size: 5,
            field: Base64VecU8::from(test_vec),
        };

        assert_eq!((255, 0, 6), test_board.get_byte_and_bit(&Cell::new(3, 0)));
        assert_eq!((7, 2, 6), test_board.get_byte_and_bit(&Cell::new(1, 2)));
        assert_eq!((19, 1, 0), test_board.get_byte_and_bit(&Cell::new(4, 0)));
        assert_eq!((0, 6, 0), test_board.get_byte_and_bit(&Cell::new(4, 4)));
    }

    #[test]
    #[should_panic]
    fn test_get_cell_out_of_bounds() {
        Board::new(11).get_cell(&Cell::new(5, 11));
    }

    #[test]
    fn test_get_cell() {
        let mut test_vec = vec![0u8; 7];
        test_vec[0] = 255;
        test_vec[1] = 32;
        test_vec[2] = 7;
        test_vec[3] = 113;
        let test_board = Board {
            size: 5,
            field: Base64VecU8::from(test_vec),
        };

        assert_eq!(3, test_board.get_cell(&Cell::new(3, 0)));
        assert_eq!(1, test_board.get_cell(&Cell::new(4, 1)));
        assert_eq!(3, test_board.get_cell(&Cell::new(4, 2)));
        assert_eq!(2, test_board.get_cell(&Cell::new(1, 1)));
    }

    #[test]
    #[should_panic]
    fn test_set_cell_out_of_bounds() {
        Board::new(5).set_cell(&Cell::new(6, 3), 1);
    }

    #[test]
    #[should_panic]
    fn test_set_cell_too_big_value() {
        Board::new(4).set_cell(&Cell::new(1, 1), 3);
    }

    #[test]
    fn test_set_sell() {
        let mut test_board = Board::new(11);
        let test_cell = Cell::new(2, 5);

        test_board.set_cell(&test_cell, 1);
        assert_eq!(1, test_board.get_cell(&test_cell));

        test_board.set_cell(&test_cell, 0);
        assert_eq!(0, test_board.get_cell(&test_cell));

        test_board.set_cell(&test_cell, 2);
        assert_eq!(2, test_board.get_cell(&test_cell));

        test_board.set_cell(&Cell::new(10, 10), 1);
        test_board.set_cell(&Cell::new(3, 5), 1);

        assert_eq!(2, test_board.get_cell(&Cell::new(2, 5)));
        assert_eq!(1, test_board.get_cell(&Cell::new(10, 10)));
        assert_eq!(1, test_board.get_cell(&Cell::new(3, 5)));
    }

    #[test]
    fn test_get_coords() {
        let mut test_board = Board::new(5);
        assert_eq!(Cell::new(0, 1), test_board.get_coords(10));
        assert_eq!(Cell::new(0, 0), test_board.get_coords(0));
        assert_eq!(Cell::new(0, 0), test_board.get_coords(1));
        assert_eq!(Cell::new(4, 4), test_board.get_coords(48));

        test_board = Board::new(15);
        let mut test_cell = Cell::new(11, 7);
        let (_, mut byte, mut bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));

        test_cell = Cell::new(0, 14);
        (_, byte, bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));

        test_cell = Cell::new(10, 2);
        (_, byte, bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));
    }
}

'''
'''--- src/cell.rs ---
use near_sdk::require;

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Cell {
    pub x: usize,
    pub y: usize,
}

impl Cell {
    pub fn new(x: usize, y: usize) -> Self {
        Self { x, y }
    }

    pub fn get_neighbours(&self, field_size: usize) -> Vec<Cell> {
        require!(
            self.x < field_size && self.y < field_size,
            "Cell is out of bounds"
        );
        let mut neighbours: Vec<Cell> = Vec::new();
        let (x, y) = (self.x, self.y);
        if self.x > 0 {
            neighbours.push(Cell { x: x - 1, y });
        }
        if self.y > 0 {
            neighbours.push(Cell { x, y: y - 1 });
        }
        if self.x + 1 < field_size && self.y > 0 {
            neighbours.push(Cell { x: x + 1, y: y - 1 });
        }
        if self.x + 1 < field_size {
            neighbours.push(Cell { x: x + 1, y });
        }
        if self.y + 1 < field_size {
            neighbours.push(Cell { x, y: y + 1 });
        }
        if self.x > 0 && self.y + 1 < field_size {
            neighbours.push(Cell { x: x - 1, y: y + 1 });
        }
        return neighbours;
    }

    pub fn symm(&self) -> Self {
        Self {
            x: self.y,
            y: self.x,
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod cell_tests {
    use super::Cell;

    impl PartialEq for Cell {
        fn eq(&self, other: &Self) -> bool {
            self.x == other.x && self.y == other.y
        }
    }

    #[test]
    fn test_cell_neighbours_single() {
        let test_cell = Cell::new(0, 0);
        let neighbours = test_cell.get_neighbours(1);
        assert!(neighbours.is_empty());
    }

    #[test]
    fn test_cell_neighbours_center() {
        let test_cell = Cell::new(1, 1);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(0, 1),
                Cell::new(1, 0),
                Cell::new(2, 0),
                Cell::new(2, 1),
                Cell::new(1, 2),
                Cell::new(0, 2)
            ]
        );
    }
    #[test]
    fn test_cell_neighbours_right_bottom_corner() {
        let test_cell = Cell::new(1, 1);
        let neighbours = test_cell.get_neighbours(2);
        assert_eq!(neighbours, vec![Cell::new(0, 1), Cell::new(1, 0)]);
    }
    #[test]
    fn test_cell_neighbours_left_upper_corner() {
        let test_cell = Cell::new(0, 0);
        let neighbours = test_cell.get_neighbours(4);
        assert_eq!(neighbours, vec![Cell::new(1, 0), Cell::new(0, 1)]);
    }
    #[test]
    fn test_cell_neighbours_left_bottom_corner() {
        let test_cell = Cell::new(0, 2);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![Cell::new(0, 1), Cell::new(1, 1), Cell::new(1, 2)]
        );
    }
    #[test]
    fn test_cell_neighbours_right_upper_corner() {
        let test_cell = Cell::new(4, 0);
        let neighbours = test_cell.get_neighbours(5);
        assert_eq!(
            neighbours,
            vec![Cell::new(3, 0), Cell::new(4, 1), Cell::new(3, 1)]
        );
    }

    #[test]
    fn test_cell_neighbours_left_border() {
        let test_cell = Cell::new(0, 1);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(0, 0),
                Cell::new(1, 0),
                Cell::new(1, 1),
                Cell::new(0, 2)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_upper_border() {
        let test_cell = Cell::new(2, 0);
        let neighbours = test_cell.get_neighbours(4);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(1, 0),
                Cell::new(3, 0),
                Cell::new(2, 1),
                Cell::new(1, 1)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_right_border() {
        let test_cell = Cell::new(4, 3);
        let neighbours = test_cell.get_neighbours(5);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(3, 3),
                Cell::new(4, 2),
                Cell::new(4, 4),
                Cell::new(3, 4)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_bottom_border() {
        let test_cell = Cell::new(2, 5);
        let neighbours = test_cell.get_neighbours(6);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(1, 5),
                Cell::new(2, 4),
                Cell::new(3, 4),
                Cell::new(3, 5)
            ]
        );
    }

    #[test]
    #[should_panic]
    fn test_cell_of_bounds() {
        Cell::new(3, 4).get_neighbours(4);
    }
}

'''
'''--- src/external.rs ---
use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    ext_contract,
    json_types::{Base58CryptoHash, U128},
    serde::{Deserialize, Serialize},
    AccountId, Balance, CryptoHash, Timestamp,
};
use std::collections::HashMap;

use crate::*;

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod b58_dec_format {
    use near_sdk::json_types::Base58CryptoHash;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::CryptoHash;

    pub fn serialize<S>(val: &CryptoHash, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // impossible to do without intermediate serialization
        serializer.serialize_str(&String::from(&Base58CryptoHash::from(*val)))
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<CryptoHash, D::Error>
    where
        D: Deserializer<'de>,
    {
        // same as above
        Ok(Base58CryptoHash::deserialize(deserializer)?.into())
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum StreamFinishReason {
    StoppedByOwner,
    StoppedByReceiver,
    FinishedNaturally,
    FinishedBecauseCannotBeExtended,
    FinishedWhileTransferred,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum StreamStatus {
    Initialized,
    Active,
    Paused,
    Finished { reason: StreamFinishReason },
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Stream {
    #[serde(with = "b58_dec_format")]
    pub id: CryptoHash,
    pub description: Option<String>,
    pub creator_id: AccountId,
    pub owner_id: AccountId,
    pub receiver_id: AccountId,
    pub token_account_id: AccountId,

    pub timestamp_created: Timestamp,
    pub last_action: Timestamp,

    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    #[serde(with = "u128_dec_format")]
    pub tokens_per_sec: Balance,

    pub status: StreamStatus,
    #[serde(with = "u128_dec_format")]
    pub tokens_total_withdrawn: Balance,

    // Cliff is a moment of time which divides the stream into two parts:
    // - before the cliff - withdraw is disabled;
    // - after the cliff - stream becomes a regular one.
    //
    // Streams with cliff must be started immediately.
    // Additionally, pausing streams with cliff is disabled
    // because it's hard to predict the proper behavior of the stream.
    //
    // The only way to withdraw tokens from stream with active cliff
    // is to stop it completely. In this case we take commission
    // that is proportional to time passed for total stream time.
    //
    // The reason of having cliffs is to reproduce vesting contracts.
    pub cliff: Option<Timestamp>,

    // Stream non-expiration is a hard concept to understand.
    //
    // The idea is based on observation that no stream can be stopped
    // automatically with no action provided. So, if receiver haven't
    // withdraw his tokens from fully expired stream yet,
    // the stream is considered Active.
    //
    // This basically means, the owner can deposit tokens onto the stream
    // even it's already expired, as long as receiver haven't tried to withdraw
    // the tokens that leads to stream finishing. In other terms,
    // it's possible to have a credit that may be covered later.
    //
    // Such behavior called non-expirable streams and disabled by default.
    // Expirable streams will be terminated even on stream depositing.
    pub is_expirable: bool,

    // Locked streams are ones that are unable to pause, stop and change receiver.
    // Locked streams are still may be terminated or deposited until started.
    //
    // For locked streams we take commission when the stream is started,
    // to allow us to own and handle commission tokens without waiting
    // as the final result of locked stream cannot be changed.
    pub is_locked: bool,

    #[borsh_skip]
    #[serde(with = "u128_dec_format")]
    pub available_to_withdraw_by_formula: Balance,
}

#[derive(Deserialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountView {
    pub active_incoming_streams: u32,
    pub active_outgoing_streams: u32,
    pub inactive_incoming_streams: u32,
    pub inactive_outgoing_streams: u32,

    pub total_incoming: HashMap<AccountId, U128>,
    pub total_outgoing: HashMap<AccountId, U128>,
    pub total_received: HashMap<AccountId, U128>,

    #[serde(with = "u128_dec_format")]
    pub deposit: Balance,

    #[serde(with = "u128_dec_format")]
    pub stake: Balance,

    pub last_created_stream: Option<Base58CryptoHash>,
    pub is_cron_allowed: bool,
}

pub const TICKS_PER_SECOND: u64 = 10u64.pow(9 as _); // 1e9

impl Stream {
    pub(crate) fn available_to_withdraw(&self) -> Balance {
        if self.status == StreamStatus::Active {
            let period = env::block_timestamp() - self.last_action;
            std::cmp::min(
                self.balance,
                (period / TICKS_PER_SECOND) as u128 * self.tokens_per_sec,
            )
        } else {
            0
        }
    }
}

#[ext_contract(ext_roketo)]
pub trait Roketo {
    fn get_account_outgoing_streams(
        account_id: AccountId,
        from: Option<u32>,
        limit: Option<u32>,
    ) -> Vec<Stream>;
}

'''
'''--- src/game.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, require, AccountId, BlockHeight};

use crate::board::Board;
use crate::cell::Cell;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Game {
    pub first_player: AccountId,
    pub second_player: AccountId,
    pub turn: usize,
    pub board: Board,
    pub current_block_height: BlockHeight,
    pub prev_block_height: BlockHeight,
    pub is_finished: bool,
}

pub type GameIndex = u64;

impl Game {
    pub fn new(first_player: AccountId, second_player: AccountId, field_size: usize) -> Self {
        Game {
            first_player,
            second_player,
            turn: 0,
            board: Board::new(field_size),
            current_block_height: env::block_height(),
            prev_block_height: 0,
            is_finished: false,
        }
    }

    pub fn place_counter(&mut self, cell: &Cell, player: u8) {
        require!(self.board.get_cell(cell) == 0, "Cell is already filled.");
        require!(
            self.turn % 2 + 1 == player as usize,
            "It's another player turn now."
        );
        self.board.set_cell(cell, player);
        self.turn += 1;
        if env::block_height() != self.current_block_height {
            self.prev_block_height = self.current_block_height;
            self.current_block_height = env::block_height();
        }
    }

    pub fn swap_rule(&mut self) -> Cell {
        require!(
            self.turn == 1,
            "Swap rule can be applied only on the second player first turn"
        );

        let non_zero_byte = self
            .board
            .field
            .0
            .iter()
            .enumerate()
            .find(|(_, &x)| x != 0)
            .unwrap();
        let mut bit_number = 8 * non_zero_byte.0;
        if non_zero_byte.1 & 4 == 4 {
            bit_number += 2;
        } else if non_zero_byte.1 & 16 == 16 {
            bit_number += 4;
        } else if non_zero_byte.1 & 64 == 64 {
            bit_number += 6;
        }
        let cell = self.board.get_coords(bit_number);

        self.board.set_cell(&cell, 0);
        self.board.set_cell(&cell.symm(), 2);
        self.turn += 1;
        if env::block_height() != self.current_block_height {
            self.prev_block_height = self.current_block_height;
            self.current_block_height = env::block_height();
        }

        cell
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod game_tests {
    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env,
    };

    use crate::cell::Cell;

    use super::Game;

    fn get_context() -> VMContextBuilder {
        VMContextBuilder::new()
    }

    #[test]
    #[should_panic]
    fn test_place_counter_wrong_player_1() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(1, 1), 2);
    }

    #[test]
    #[should_panic]
    fn test_place_counter_wrong_player_2() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(2, 1), 1);
    }

    #[test]
    #[should_panic]
    fn test_place_counter_cell_is_already_filled() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(1, 1), 2);
    }

    #[test]
    fn test_place_counter() {
        testing_env!(get_context().block_index(0).build());

        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(1, 2), 2);
        game.place_counter(&Cell::new(10, 7), 1);
        assert_eq!(game.current_block_height, 0);
        assert_eq!(game.prev_block_height, 0);

        testing_env!(get_context().block_index(100).build());
        game.place_counter(&Cell::new(5, 9), 2);
        game.place_counter(&Cell::new(3, 7), 1);
        assert_eq!(game.current_block_height, 100);
        assert_eq!(game.prev_block_height, 0);

        assert_eq!(game.first_player, accounts(0));
        assert_eq!(game.second_player, accounts(1));
        assert_eq!(game.turn, 5);
        for i in 0..11 {
            for j in 0..11 {
                let cell = Cell::new(i, j);
                if cell == Cell::new(1, 1) || cell == Cell::new(10, 7) || cell == Cell::new(3, 7) {
                    assert_eq!(game.board.get_cell(&cell), 1);
                } else if cell == Cell::new(1, 2) || cell == Cell::new(5, 9) {
                    assert_eq!(game.board.get_cell(&cell), 2);
                } else {
                    assert_eq!(game.board.get_cell(&cell), 0);
                }
            }
        }
    }

    #[test]
    #[should_panic]
    fn test_swap_rule_too_early() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.swap_rule();
    }

    #[test]
    #[should_panic]
    fn test_swap_rule_too_late() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(2, 5), 1);
        game.place_counter(&Cell::new(10, 7), 2);
        game.swap_rule();
    }

    #[test]
    fn test_swap_rule() {
        let mut game = Game::new(accounts(0), accounts(1), 11);
        game.place_counter(&Cell::new(10, 7), 1);

        let c = game.swap_rule();
        assert_eq!(Cell::new(10, 7), c);
        assert_eq!(0, game.board.get_cell(&Cell::new(10, 7)));
        assert_eq!(2, game.board.get_cell(&Cell::new(7, 10)));

        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(5, 9), 2);
        game.place_counter(&Cell::new(3, 7), 1);

        assert_eq!(game.turn, 5);
        for i in 0..11 {
            for j in 0..11 {
                let cell = Cell::new(i, j);
                if cell == Cell::new(1, 1) || cell == Cell::new(3, 7) {
                    assert_eq!(game.board.get_cell(&cell), 1);
                } else if cell == Cell::new(7, 10) || cell == Cell::new(5, 9) {
                    assert_eq!(game.board.get_cell(&cell), 2);
                } else {
                    assert_eq!(game.board.get_cell(&cell), 0);
                }
            }
        }
    }
}

'''
'''--- src/game_with_data.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, require, AccountId};
use std::collections::VecDeque;

use crate::board::Board;
use crate::cell::Cell;
use crate::game::Game;
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct GameWithData {
    pub game: Game,
    pub data: Board,
}

impl GameWithData {
    pub fn new(first_player: AccountId, second_player: AccountId, field_size: usize) -> Self {
        Self {
            game: Game::new(first_player, second_player, field_size),
            data: Board::new(field_size),
        }
    }

    pub fn make_move(&mut self, move_type: MoveType, cell: Option<Cell>) {
        match (move_type, cell) {
            (MoveType::PLACE, Some(cell)) => {
                if self.game.turn % 2 == 0 {
                    require!(
                        env::predecessor_account_id() == self.game.first_player,
                        "Incorrect predecessor account"
                    );
                    self.game.place_counter(&cell, 1);
                } else {
                    require!(
                        env::predecessor_account_id() == self.game.second_player,
                        "Incorrect predecessor account"
                    );
                    self.game.place_counter(&cell, 2);
                }
                self.process_cell(cell);
            }
            (MoveType::SWAP, _) => {
                require!(
                    env::predecessor_account_id() == self.game.second_player,
                    "Incorrect predecessor account"
                );
                let cell = self.game.swap_rule();
                self.data.set_cell(&cell, 0);
                self.process_cell(cell.symm());
            }
            _ => env::panic_str("Incorrect move args"),
        }
    }

    fn process_cell(&mut self, cell: Cell) {
        let color = self.game.board.get_cell(&cell);
        let (mut border1, mut border2) = if color == 1 {
            (cell.y == 0, cell.y + 1 == self.data.size)
        } else {
            (cell.x == 0, cell.x + 1 == self.data.size)
        };
        let neighbours = cell.get_neighbours(self.data.size);
        let good_neighbours = neighbours
            .iter()
            .filter(|c| self.game.board.get_cell(c) == color);
        border1 = border1 || good_neighbours.clone().any(|c| self.data.get_cell(c) == 1);
        border2 = border2 || good_neighbours.clone().any(|c| self.data.get_cell(c) == 2);
        if border1 && border2 {
            self.game.is_finished = true;
        } else if border1 {
            self.bfs(cell, color, 1);
        } else if border2 {
            self.bfs(cell, color, 2);
        }
    }

    fn bfs(&mut self, cell: Cell, color: u8, border: u8) {
        self.data.set_cell(&cell, border);
        let mut q: VecDeque<Cell> = VecDeque::new();
        q.push_back(cell);
        let field_size = self.data.size;
        while !q.is_empty() {
            let v = q.pop_front().unwrap();
            let neighbours = v.get_neighbours(field_size);
            let good_neighbours: Vec<Cell> = neighbours
                .into_iter()
                .filter(|c| self.game.board.get_cell(c) == color && self.data.get_cell(c) != border)
                .collect();
            if good_neighbours
                .clone()
                .into_iter()
                .any(|c| self.data.get_cell(&c) != 0)
            {
                self.game.is_finished = true;
                return;
            }
            for c in good_neighbours.into_iter() {
                self.data.set_cell(&c, border);
                q.push_back(Cell { x: c.x, y: c.y });
            }
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod game_with_board_tests {
    use std::fmt::Debug;

    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env,
    };

    use super::*;

    impl PartialEq for Board {
        fn eq(&self, other: &Self) -> bool {
            self.size == other.size && self.field == other.field
        }
    }

    impl Debug for Board {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("Board")
                .field("size", &self.size)
                .field("field", &self.field)
                .finish()
        }
    }

    fn get_context(account: AccountId) -> near_sdk::VMContext {
        VMContextBuilder::new()
            .predecessor_account_id(account)
            .build()
    }

    #[test]
    fn test_bfs() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        test_game.game.board.set_cell(&Cell::new(0, 0), 1);
        test_game.game.board.set_cell(&Cell::new(0, 1), 1);
        test_game.game.board.set_cell(&Cell::new(0, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 4), 1);
        test_game.game.board.set_cell(&Cell::new(3, 4), 1);

        test_game.game.board.set_cell(&Cell::new(0, 3), 1);
        test_game.game.board.set_cell(&Cell::new(1, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 0), 2);

        test_game.game.board.set_cell(&Cell::new(2, 1), 1);

        test_game.game.board.set_cell(&Cell::new(3, 0), 2);

        let mut test_data = Board::new(5);
        test_data.set_cell(&Cell::new(0, 0), 2);
        test_data.set_cell(&Cell::new(0, 1), 2);
        test_data.set_cell(&Cell::new(0, 2), 2);
        test_data.set_cell(&Cell::new(0, 3), 2);
        test_data.set_cell(&Cell::new(1, 2), 2);
        test_data.set_cell(&Cell::new(2, 1), 2);

        test_game.bfs(Cell::new(0, 2), 1, 2);
        assert_eq!(test_game.data, test_data);

        test_data.set_cell(&Cell::new(4, 0), 2);
        test_data.set_cell(&Cell::new(3, 0), 2);

        test_game.bfs(Cell::new(3, 0), 2, 2);
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    fn test_process_cell() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        test_game.game.board.set_cell(&Cell::new(0, 0), 1);
        test_game.game.board.set_cell(&Cell::new(0, 1), 1);
        test_game.game.board.set_cell(&Cell::new(0, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 4), 1);
        test_game.game.board.set_cell(&Cell::new(3, 4), 1);

        test_game.game.board.set_cell(&Cell::new(0, 3), 1);
        test_game.game.board.set_cell(&Cell::new(1, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 0), 2);

        test_game.game.board.set_cell(&Cell::new(2, 1), 1);

        test_game.game.board.set_cell(&Cell::new(3, 0), 2);

        let mut test_data = Board::new(5);
        test_data.set_cell(&Cell::new(0, 0), 1);
        test_data.set_cell(&Cell::new(0, 1), 1);
        test_data.set_cell(&Cell::new(0, 2), 1);
        test_data.set_cell(&Cell::new(0, 3), 1);
        test_data.set_cell(&Cell::new(1, 2), 1);
        test_data.set_cell(&Cell::new(2, 1), 1);

        test_game.process_cell(Cell::new(0, 1));
        assert_eq!(test_game.data, Board::new(5));

        test_game.process_cell(Cell::new(0, 0));
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    fn test_make_move() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        let mut test_data = Board::new(5);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(3, 0)));
        test_data.set_cell(&Cell::new(3, 0), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::SWAP, None);
        test_data.set_cell(&Cell::new(3, 0), 0);
        test_data.set_cell(&Cell::new(0, 3), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 4)));
        test_data.set_cell(&Cell::new(4, 4), 2);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(1, 2)));
        test_data.set_cell(&Cell::new(1, 2), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 2)));
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(3, 2)));
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 3)));
        test_data.set_cell(&Cell::new(4, 2), 2);
        test_data.set_cell(&Cell::new(4, 3), 2);
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    #[should_panic]
    fn test_make_move_incorrect_args() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        test_game.make_move(MoveType::PLACE, None);
    }

    #[test]
    #[should_panic]
    fn test_make_move_wrong_player() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(0, 0)));
    }
}

'''
'''--- src/lib.rs ---
use cell::Cell;
use external::{Stream, StreamStatus};
use game::{Game, GameIndex};
use game_with_data::GameWithData;
use near_contract_standards::non_fungible_token::refund_deposit;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault, Promise};
use roketo::get_account_outgoing_streams;

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Games,
    Field { game_id: GameIndex },
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum MoveType {
    PLACE,
    SWAP,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub games: Vector<GameWithData>,
    pub roketo_acc: Option<AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(roketo_acc: Option<AccountId>) -> Self {
        Self {
            games: Vector::new(StorageKey::Games),
            roketo_acc,
        }
    }

    #[payable]
    pub fn create_game(
        &mut self,
        first_player: AccountId,
        second_player: AccountId,
        field_size: Option<usize>,
    ) -> GameIndex {
        let initial_storage_usage = env::storage_usage();

        let index = self.games.len();
        let size = field_size.unwrap_or(11);
        self.games
            .push(&GameWithData::new(first_player, second_player, size));

        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;
        refund_deposit(required_storage_in_bytes);

        env::log_str("Created board:");
        self.games.get(index).unwrap().game.board.debug_logs();
        index
    }

    pub fn get_game(&self, index: GameIndex) -> Option<Game> {
        let game = self.games.get(index).map(|x| x.game);
        if game.is_some() {
            env::log_str("Game board:");
            game.clone().unwrap().board.debug_logs();
        }
        game
    }

    pub fn make_move(&mut self, index: GameIndex, move_type: MoveType, cell: Option<Cell>) -> Game {
        let mut game_with_data = self.games.get(index).expect("Game doesn't exist.");
        require!(
            !game_with_data.game.is_finished,
            "Game is already finished!"
        );

        let old_board = game_with_data.game.board.clone();
        game_with_data.make_move(move_type, cell);

        env::log_str("Old board:");
        old_board.debug_logs();

        env::log_str("New board:");
        game_with_data.game.board.debug_logs();

        if game_with_data.game.is_finished {
            if game_with_data.game.turn % 2 == 1 {
                env::log_str("First player wins!");
            } else {
                env::log_str("Second player wins!");
            }
        }

        self.games.replace(index, &game_with_data);
        return self.games.get(index).unwrap().game;
    }

    pub fn check_premium_account(&self, account_id: AccountId) -> Promise {
        get_account_outgoing_streams(
            account_id,
            self.roketo_acc
                .clone()
                .expect("No Roketo account to check premium."),
        )
        .then(Self::ext(env::current_account_id()).check_premium_account_internal())
    }

    #[private]
    pub fn check_premium_account_internal(&self, #[callback_unwrap] streams: Vec<Stream>) -> bool {
        streams.iter().any(|stream| {
            stream.is_locked
                && stream.is_expirable
                && stream.status == StreamStatus::Active
                && stream.receiver_id == env::current_account_id()
                && stream.available_to_withdraw() != stream.balance
        })
    }
}

pub mod board;
pub mod cell;
pub mod external;
pub mod game;
pub mod game_with_data;
pub mod roketo;

#[cfg(all(test, not(target_arch = "wasm32")))]
mod contract_tests {
    use core::fmt::Debug;
    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env, AccountId, ONE_NEAR,
    };

    use crate::{
        board::Board, cell::Cell, game::Game, game_with_data::GameWithData, Contract, MoveType,
    };

    fn get_context(account: AccountId) -> near_sdk::VMContext {
        VMContextBuilder::new()
            .predecessor_account_id(account)
            .attached_deposit(10 * ONE_NEAR)
            .build()
    }

    impl PartialEq for Game {
        fn eq(&self, other: &Self) -> bool {
            self.first_player == other.first_player
                && self.second_player == other.second_player
                && self.turn == other.turn
                && self.board == other.board
                && self.current_block_height == other.current_block_height
                && self.prev_block_height == other.prev_block_height
                && self.is_finished == other.is_finished
        }
    }

    impl PartialEq for GameWithData {
        fn eq(&self, other: &Self) -> bool {
            self.game == other.game && self.data == other.data
        }
    }

    impl Debug for Game {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("Game")
                .field("first_player", &self.first_player)
                .field("second_player", &self.second_player)
                .field("turn", &self.turn)
                .field("board", &self.board)
                .field("current_block_height", &self.current_block_height)
                .field("prev_block_height", &self.prev_block_height)
                .field("is_finished", &self.is_finished)
                .finish()
        }
    }

    impl Debug for GameWithData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("GameWithData")
                .field("game", &self.game)
                .field("data", &self.data)
                .finish()
        }
    }

    #[test]
    fn test_create_get() {
        testing_env!(get_context(accounts(2)));
        let mut contract = Contract::new(None);
        contract.create_game(accounts(1), accounts(2), Some(3));
        contract.create_game(accounts(4), accounts(3), Some(4));
        let id = contract.create_game(accounts(0), accounts(1), None);
        assert_eq!(id, 2);
        let game = contract.get_game(id);

        assert!(contract.get_game(id + 1).is_none());
        assert!(game.is_some());
        assert_eq!(game.clone().unwrap().first_player, accounts(0));
        assert_eq!(game.clone().unwrap().second_player, accounts(1));
        assert_eq!(game.unwrap().board, Board::new(11));
    }

    #[test]
    fn test_make_move() {
        testing_env!(get_context(accounts(2)));
        let mut contract = Contract::new(None);
        let id = contract.create_game(accounts(0), accounts(1), Some(5));

        testing_env!(get_context(accounts(0)));
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5);
        assert_eq!(test_game, contract.games.get(id).unwrap());

        let game = contract.make_move(id, MoveType::PLACE, Some(Cell::new(4, 0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 0)));
        assert_eq!(test_game.game, game);
        assert_eq!(test_game, contract.games.get(id).unwrap());

        testing_env!(get_context(accounts(1)));
        let game = contract.make_move(id, MoveType::SWAP, Some(Cell::new(4, 0)));
        test_game.make_move(MoveType::SWAP, Some(Cell::new(4, 0)));
        assert_eq!(test_game.game, game);
        assert_eq!(test_game, contract.games.get(id).unwrap());
    }
}

'''
'''--- src/roketo.rs ---
use near_sdk::{AccountId, Promise};

use crate::external::ext_roketo;

pub(crate) fn get_account_outgoing_streams(
    account_id: AccountId,
    roketo_acc: AccountId,
) -> Promise {
    ext_roketo::ext(roketo_acc).get_account_outgoing_streams(account_id, None, None)
}

'''