*GitHub Repository "near/units-js"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/lint.yml ---
name: Lint
on: push
jobs:
  eslint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - run: yarn install
    - run: yarn lint
'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest, windows-latest]
        node-version: [14, 16]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Run tests
        run: yarn && yarn test
'''
'''--- .vim/coc-settings.json ---
{
  "workspace.workspaceFolderCheckCwd": false,
  "tsserver.tsdk": ".yarn/sdks/typescript/lib"
}

'''
'''--- .vscode/extensions.json ---
{
  "recommendations": [
    "arcanis.vscode-zipfs",
    "spence-s.linter-xo",
    "Orta.vscode-jest"
  ]
}
'''
'''--- .vscode/settings.json ---
{
  "search.exclude": {
    "**/.yarn": true,
    "**/.pnp.*": true
  },
  "typescript.tsdk": ".yarn/sdks/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true,
  "xo.format.enable": true,
  "xo.overrideSeverity": "info",
  "[javascript]": {
    "editor.defaultFormatter": "spence-s.linter-xo"
  },
  "[typescript]": {
    "editor.defaultFormatter": "spence-s.linter-xo"
  },
  "editor.codeActionsOnSave": {
    "spence-s.linter-xo": true
  },
  "jest.coverageColors": {
    "uncovered": "rgba(238,117,190, 0.15)",
    "partially-covered": "rgba(243,246,167, 0.15)"
  }
}
'''
'''--- .yarn/sdks/integrations.yml ---
# This file is automatically generated by @yarnpkg/sdks.
# Manual changes might be lost!

integrations:
  - vscode
  - vim

'''
'''--- .yarn/sdks/typescript/lib/tsc.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.cjs";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/tsc.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/tsc.js your application uses
module.exports = absRequire(`typescript/lib/tsc.js`);

'''
'''--- .yarn/sdks/typescript/lib/tsserver.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.cjs";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

const moduleWrapper = tsserver => {
  if (!process.versions.pnp) {
    return tsserver;
  }

  const {isAbsolute} = require(`path`);
  const pnpApi = require(`pnpapi`);

  const isVirtual = str => str.match(/\/(\$\$virtual|__virtual__)\//);
  const normalize = str => str.replace(/\\/g, `/`).replace(/^\/?/, `/`);

  const dependencyTreeRoots = new Set(pnpApi.getDependencyTreeRoots().map(locator => {
    return `${locator.name}@${locator.reference}`;
  }));

  // VSCode sends the zip paths to TS using the "zip://" prefix, that TS
  // doesn't understand. This layer makes sure to remove the protocol
  // before forwarding it to TS, and to add it back on all returned paths.

  function toEditorPath(str) {
    // We add the `zip:` prefix to both `.zip/` paths and virtual paths
    if (isAbsolute(str) && !str.match(/^\^zip:/) && (str.match(/\.zip\//) || isVirtual(str))) {
      // We also take the opportunity to turn virtual paths into physical ones;
      // this makes it much easier to work with workspaces that list peer
      // dependencies, since otherwise Ctrl+Click would bring us to the virtual
      // file instances instead of the real ones.
      //
      // We only do this to modules owned by the the dependency tree roots.
      // This avoids breaking the resolution when jumping inside a vendor
      // with peer dep (otherwise jumping into react-dom would show resolution
      // errors on react).
      //
      const resolved = isVirtual(str) ? pnpApi.resolveVirtual(str) : str;
      if (resolved) {
        const locator = pnpApi.findPackageLocator(resolved);
        if (locator && dependencyTreeRoots.has(`${locator.name}@${locator.reference}`)) {
          str = resolved;
        }
      }

      str = normalize(str);

      if (str.match(/\.zip\//)) {
        switch (hostInfo) {
          // Absolute VSCode `Uri.fsPath`s need to start with a slash.
          // VSCode only adds it automatically for supported schemes,
          // so we have to do it manually for the `zip` scheme.
          // The path needs to start with a caret otherwise VSCode doesn't handle the protocol
          //
          // Ref: https://github.com/microsoft/vscode/issues/105014#issuecomment-686760910
          //
          case `vscode`: {
            str = `^zip:${str}`;
          } break;

          // To make "go to definition" work,
          // We have to resolve the actual file system path from virtual path
          // and convert scheme to supported by [vim-rzip](https://github.com/lbrayner/vim-rzip)
          case `coc-nvim`: {
            str = normalize(resolved).replace(/\.zip\//, `.zip::`);
            str = resolve(`zipfile:${str}`);
          } break;

          // Support neovim native LSP and [typescript-language-server](https://github.com/theia-ide/typescript-language-server)
          // We have to resolve the actual file system path from virtual path,
          // everything else is up to neovim
          case `neovim`: {
            str = normalize(resolved).replace(/\.zip\//, `.zip::`);
            str = `zipfile:${str}`;
          } break;

          default: {
            str = `zip:${str}`;
          } break;
        }
      }
    }

    return str;
  }

  function fromEditorPath(str) {
    return process.platform === `win32`
      ? str.replace(/^\^?zip:\//, ``)
      : str.replace(/^\^?zip:/, ``);
  }

  // Force enable 'allowLocalPluginLoads'
  // TypeScript tries to resolve plugins using a path relative to itself
  // which doesn't work when using the global cache
  // https://github.com/microsoft/TypeScript/blob/1b57a0395e0bff191581c9606aab92832001de62/src/server/project.ts#L2238
  // VSCode doesn't want to enable 'allowLocalPluginLoads' due to security concerns but
  // TypeScript already does local loads and if this code is running the user trusts the workspace
  // https://github.com/microsoft/vscode/issues/45856
  const ConfiguredProject = tsserver.server.ConfiguredProject;
  const {enablePluginsWithOptions: originalEnablePluginsWithOptions} = ConfiguredProject.prototype;
  ConfiguredProject.prototype.enablePluginsWithOptions = function() {
    this.projectService.allowLocalPluginLoads = true;
    return originalEnablePluginsWithOptions.apply(this, arguments);
  };

  // And here is the point where we hijack the VSCode <-> TS communications
  // by adding ourselves in the middle. We locate everything that looks
  // like an absolute path of ours and normalize it.

  const Session = tsserver.server.Session;
  const {onMessage: originalOnMessage, send: originalSend} = Session.prototype;
  let hostInfo = `unknown`;

  Object.assign(Session.prototype, {
    onMessage(/** @type {string} */ message) {
      const parsedMessage = JSON.parse(message)

      if (
        parsedMessage != null &&
        typeof parsedMessage === `object` &&
        parsedMessage.arguments &&
        typeof parsedMessage.arguments.hostInfo === `string`
      ) {
        hostInfo = parsedMessage.arguments.hostInfo;
      }

      return originalOnMessage.call(this, JSON.stringify(parsedMessage, (key, value) => {
        return typeof value === `string` ? fromEditorPath(value) : value;
      }));
    },

    send(/** @type {any} */ msg) {
      return originalSend.call(this, JSON.parse(JSON.stringify(msg, (key, value) => {
        return typeof value === `string` ? toEditorPath(value) : value;
      })));
    }
  });

  return tsserver;
};

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/tsserver.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/tsserver.js your application uses
module.exports = moduleWrapper(absRequire(`typescript/lib/tsserver.js`));

'''
'''--- .yarn/sdks/typescript/lib/tsserverlibrary.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.cjs";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

const moduleWrapper = tsserver => {
  if (!process.versions.pnp) {
    return tsserver;
  }

  const {isAbsolute} = require(`path`);
  const pnpApi = require(`pnpapi`);

  const isVirtual = str => str.match(/\/(\$\$virtual|__virtual__)\//);
  const normalize = str => str.replace(/\\/g, `/`).replace(/^\/?/, `/`);

  const dependencyTreeRoots = new Set(pnpApi.getDependencyTreeRoots().map(locator => {
    return `${locator.name}@${locator.reference}`;
  }));

  // VSCode sends the zip paths to TS using the "zip://" prefix, that TS
  // doesn't understand. This layer makes sure to remove the protocol
  // before forwarding it to TS, and to add it back on all returned paths.

  function toEditorPath(str) {
    // We add the `zip:` prefix to both `.zip/` paths and virtual paths
    if (isAbsolute(str) && !str.match(/^\^zip:/) && (str.match(/\.zip\//) || isVirtual(str))) {
      // We also take the opportunity to turn virtual paths into physical ones;
      // this makes it much easier to work with workspaces that list peer
      // dependencies, since otherwise Ctrl+Click would bring us to the virtual
      // file instances instead of the real ones.
      //
      // We only do this to modules owned by the the dependency tree roots.
      // This avoids breaking the resolution when jumping inside a vendor
      // with peer dep (otherwise jumping into react-dom would show resolution
      // errors on react).
      //
      const resolved = isVirtual(str) ? pnpApi.resolveVirtual(str) : str;
      if (resolved) {
        const locator = pnpApi.findPackageLocator(resolved);
        if (locator && dependencyTreeRoots.has(`${locator.name}@${locator.reference}`)) {
          str = resolved;
        }
      }

      str = normalize(str);

      if (str.match(/\.zip\//)) {
        switch (hostInfo) {
          // Absolute VSCode `Uri.fsPath`s need to start with a slash.
          // VSCode only adds it automatically for supported schemes,
          // so we have to do it manually for the `zip` scheme.
          // The path needs to start with a caret otherwise VSCode doesn't handle the protocol
          //
          // Ref: https://github.com/microsoft/vscode/issues/105014#issuecomment-686760910
          //
          case `vscode`: {
            str = `^zip:${str}`;
          } break;

          // To make "go to definition" work,
          // We have to resolve the actual file system path from virtual path
          // and convert scheme to supported by [vim-rzip](https://github.com/lbrayner/vim-rzip)
          case `coc-nvim`: {
            str = normalize(resolved).replace(/\.zip\//, `.zip::`);
            str = resolve(`zipfile:${str}`);
          } break;

          // Support neovim native LSP and [typescript-language-server](https://github.com/theia-ide/typescript-language-server)
          // We have to resolve the actual file system path from virtual path,
          // everything else is up to neovim
          case `neovim`: {
            str = normalize(resolved).replace(/\.zip\//, `.zip::`);
            str = `zipfile:${str}`;
          } break;

          default: {
            str = `zip:${str}`;
          } break;
        }
      }
    }

    return str;
  }

  function fromEditorPath(str) {
    return process.platform === `win32`
      ? str.replace(/^\^?zip:\//, ``)
      : str.replace(/^\^?zip:/, ``);
  }

  // Force enable 'allowLocalPluginLoads'
  // TypeScript tries to resolve plugins using a path relative to itself
  // which doesn't work when using the global cache
  // https://github.com/microsoft/TypeScript/blob/1b57a0395e0bff191581c9606aab92832001de62/src/server/project.ts#L2238
  // VSCode doesn't want to enable 'allowLocalPluginLoads' due to security concerns but
  // TypeScript already does local loads and if this code is running the user trusts the workspace
  // https://github.com/microsoft/vscode/issues/45856
  const ConfiguredProject = tsserver.server.ConfiguredProject;
  const {enablePluginsWithOptions: originalEnablePluginsWithOptions} = ConfiguredProject.prototype;
  ConfiguredProject.prototype.enablePluginsWithOptions = function() {
    this.projectService.allowLocalPluginLoads = true;
    return originalEnablePluginsWithOptions.apply(this, arguments);
  };

  // And here is the point where we hijack the VSCode <-> TS communications
  // by adding ourselves in the middle. We locate everything that looks
  // like an absolute path of ours and normalize it.

  const Session = tsserver.server.Session;
  const {onMessage: originalOnMessage, send: originalSend} = Session.prototype;
  let hostInfo = `unknown`;

  Object.assign(Session.prototype, {
    onMessage(/** @type {string} */ message) {
      const parsedMessage = JSON.parse(message)

      if (
        parsedMessage != null &&
        typeof parsedMessage === `object` &&
        parsedMessage.arguments &&
        typeof parsedMessage.arguments.hostInfo === `string`
      ) {
        hostInfo = parsedMessage.arguments.hostInfo;
      }

      return originalOnMessage.call(this, JSON.stringify(parsedMessage, (key, value) => {
        return typeof value === `string` ? fromEditorPath(value) : value;
      }));
    },

    send(/** @type {any} */ msg) {
      return originalSend.call(this, JSON.parse(JSON.stringify(msg, (key, value) => {
        return typeof value === `string` ? toEditorPath(value) : value;
      })));
    }
  });

  return tsserver;
};

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/tsserverlibrary.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/tsserverlibrary.js your application uses
module.exports = moduleWrapper(absRequire(`typescript/lib/tsserverlibrary.js`));

'''
'''--- .yarn/sdks/typescript/lib/typescript.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.cjs";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/typescript.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/typescript.js your application uses
module.exports = absRequire(`typescript/lib/typescript.js`);

'''
'''--- .yarn/sdks/typescript/package.json ---
{
  "name": "typescript",
  "version": "4.4.2-sdk",
  "main": "./lib/typescript.js",
  "type": "commonjs"
}

'''
'''--- .yarnrc.yml ---
plugins:
  - path: .yarn/plugins/@yarnpkg/plugin-typescript.cjs
    spec: "@yarnpkg/plugin-typescript"

yarnPath: .yarn/releases/yarn-3.0.1.cjs
nodeLinker: node-modules

'''
'''--- CONTRIBUTING.md ---
# Contributing

You want to help improve near-runner-js? Thank you!

# Yarn 2

This project uses [Yarn 2](https://yarnpkg.com/getting-started/migration) in [Zero-Install mode](https://yarnpkg.com/features/zero-installs), but it uses `nodeLinker: node-modules` so you might still need to run `yarn install` when you first clone this repository.

* Make sure you have [Node.js] and the latest [Yarn] installed
* Clone the code
* `cd` into the repo

Now you should be able to run project scripts:

* `yarn test`
* `yarn lint`

Or run any other NPM package included in this project. For example, to run only tests that match pattern 'near':

* `yarn jest near`

  [Node.js]: https://nodejs.org/en/download/package-manager/
  [Yarn]: https://yarnpkg.com/

# Recommendation: VS Code

We recommend using [Visual Studio Code](https://code.visualstudio.com/). We included a nice `.vscode` folder in this repository that will suggest some extensions for you so you'll be productive right away. This will mean things like:

* It will work with Yarn 2, even if this project switches [away from the `node_modules` linker](https://yarnpkg.com/getting-started/migration/#switching-to-plugnplay) in the future
* Our linter will work with you instead of against you
* TypeScript will be fully integrated, giving you help and hints
* Tests will run inline as you make changes, and highlight untested lines in the files you modify
'''
'''--- README.md ---
NEAR Units
==========

TypeScript/JavaScript tools to help parse and format NEAR units. For now, this means NEAR tokens and [gas units](https://docs.near.org/concepts/basics/transactions/gas).

# Install

    npm i --save near-units

Or using [Yarn](https://yarnpkg.com/):

    yarn add near-units

# Parsing strings

```js
import { NEAR, Gas, parse } from 'near-units';

const near = NEAR.parse('1.25 mN');
console.log(near.toHuman()); // 1.25 mN

const gas = Gas.parse('1 Tgas');
console.log(gas.toHuman()); // 1 Tgas

// equivalent to the above, but TS typings might not be as helpful
const near = parse('1.25 mN');
const gas = parse('1 Tgas');
```

See [\_\_tests__](./__tests__) for a full list of examples of inputs that can be parsed and the human-readable version that can be returned by `toHuman`.

# Doing math

`NEAR` and `Gas` both wrap `BN` from [bn.js], so you can perform any math with them that you need:

```js
import { NEAR } from 'near-units';

const amount1 = NEAR.parse('100');
const amount2 = NEAR.parse('0.5');
const amount3 = amount1.mul(amount2);
```

See [the bn.js docs for all possible operations][bn.js].

  [bn.js]: https://github.com/indutny/bn.js/

# Interop

Since they wrap `BN`, they can be passed directly to function calls with [near-api-js](https://github.com/near/near-api-js) or [near-runner](https://github.com/near/runner-js):

```js
// with an Account object from near-api-js
someAccount.functionCall({
  contractId: 'example.near',
  methodName: 'do_something',
  args: { param1: 'whatever' },
  gas: Gas.parse('50,000,000,000,000'),
  attachedDeposit: NEAR.parse('1'),
});

// with an Account object from near-runner
someAccount.call(
  'example.near',
  'do_something',
  { param1: 'whatever' },
  {
    gas: Gas.parse('50,000,000,000,000'),
    attachedDeposit: NEAR.parse('1'),
  }
});
```

`NEAR` and `Gas` also both override `toJSON` to get to a string version that can be passed as an argument to near-cli and in other contexts.

# CLI

This package ships with a minimal CLI:

    npm i -g near-units

Now you can `near-units --help`:

    Parse and format NEAR tokens and gas units. Examples:

        near-units 10 N # => 10000000000000000000000000
        near-units -h 10000000000000000000000000 yN # => 10 N
        near-units 50 Tgas # => 50000000000000
        near-units -h 50000000000000 gas # => 50 Tgas

You can use it anywhere near units are accepted. For example, on macOS & Linux, you can:

```bash
near call $LOCKUP transfer '{
  "receiver_id": "example.near",
  "amount": "'$(near-units 1N)'"
}' --accountId=$ACCOUNT --gas=$(near-units 50Tgas)
```

'''
'''--- __tests__/gas.spec.ts ---
import BN from 'bn.js';
import {Gas} from '../src';

describe.each`
  input                  | gas                | human
  ${'1'}                 | ${'1'}             | ${'1 gas'}
  ${'1,000'}             | ${'1000'}          | ${'1 kgas'}
  ${'1,000,000'}         | ${'1000000'}       | ${'1 Mgas'}
  ${'1,000,000,000'}     | ${'1000000000'}    | ${'1 Ggas'}
  ${'1,000,000,000,000'} | ${'1000000000000'} | ${'1 Tgas'}
  ${'1Tgas'}             | ${'1000000000000'} | ${'1 Tgas'}
  ${'1Ggas'}             | ${'1000000000'}    | ${'1 Ggas'}
`('Gas.parse("$input")', ({input, gas, human}) => {
  const g = Gas.parse(input);

  test(`toJSON() === "${gas}"`, () => {
    expect(g.toJSON()).toBe(gas);
  });

  test(`toHuman() === "${human}"`, () => {
    expect(g.toHuman()).toBe(human);
  });
});

describe('Gas.parse() errors', () => {
  test('blank input', () => {
    expect(() => {
      Gas.parse('');
    }).toThrow('invalid input string');
  });

  test('decimals with no metric prefix', () => {
    expect(() => {
      Gas.parse('0.1 gas');
    }).toThrow('Cannot parse');
  });
});

describe.each`
  fromInput    | parseInput
  ${'1'}       | ${'1'}
  ${'1'}       | ${'1 gas'}
  ${1}         | ${'1'}
  ${new BN(1)} | ${'1'}
`('Gas.from("$fromInput")', ({fromInput, parseInput}) => {
  const n = Gas.from(fromInput);
  test(`== Gas.parse(${parseInput})`, () => {
    expect(n).toStrictEqual(Gas.parse(parseInput));
  });
});

'''
'''--- __tests__/near.spec.ts ---
import BN from 'bn.js';
import {NEAR} from '../src';

describe.each`
  input                     | yocto                                | human
  ${'1'}                    | ${'1000000000000000000000000'}       | ${'1 N'}
  ${'.1000000000000'}       | ${'100000000000000000000000'}        | ${'100 mN'}
  ${'1.0'}                  | ${'1000000000000000000000000'}       | ${'1 N'}
  ${'1,000'}                | ${'1000000000000000000000000000'}    | ${'1,000 N'}
  ${'1,000,000'}            | ${'1000000000000000000000000000000'} | ${'1,000,000 N'}
  ${'1,000,000.000_000_01'} | ${'1000000000000010000000000000000'} | ${'1,000,000.00000001 N'}
  ${'1MN'}                  | ${'1000000000000000000000000000000'} | ${'1,000,000 N'}
  ${'1kN'}                  | ${'1000000000000000000000000000'}    | ${'1,000 N'}
  ${'0.001_101'}            | ${'1101000000000000000000'}          | ${'1.101 mN'}
  ${'0.000,101'}            | ${'101000000000000000000'}           | ${'101 μN'}
  ${'1mN'}                  | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 mN'}                 | ${'1000000000000000000000'}          | ${'1 mN'}
  ${' 001      m N    '}    | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 milliNEAR'}          | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 milliN'}             | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 millinear'}          | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 milli'}              | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1 m'}                  | ${'1000000000000000000000'}          | ${'1 mN'}
  ${'1μ'}                   | ${'1000000000000000000'}             | ${'1 μN'}
  ${'1micro'}               | ${'1000000000000000000'}             | ${'1 μN'}
  ${'1nN'}                  | ${'1000000000000000'}                | ${'1 nN'}
  ${'1p'}                   | ${'1000000000000'}                   | ${'1 pN'}
  ${'1f'}                   | ${'1000000000'}                      | ${'1 fN'}
  ${'1a'}                   | ${'1000000'}                         | ${'1 aN'}
  ${'1z'}                   | ${'1000'}                            | ${'1 zN'}
  ${'1y'}                   | ${'1'}                               | ${'1 yN'}
`('NEAR.parse("$input")', ({input, yocto, human}) => {
  const n = NEAR.parse(input);

  test(`toJSON() === "${yocto}"`, () => {
    expect(n.toJSON()).toBe(yocto);
  });

  test(`toHuman() === "${human}"`, () => {
    expect(n.toHuman()).toBe(human);
  });
});

describe('NEAR.parse() errors', () => {
  test('blank input', () => {
    expect(() => {
      NEAR.parse('');
    }).toThrow('invalid input string');
  });

  test('too many dots (10.000.1)', () => {
    expect(() => {
      NEAR.parse('10.000.1');
    }).toThrow('Cannot parse');
  });

  test('too many decimals', () => {
    expect(() => {
      NEAR.parse('0.000_000_000_000_000_000_000_000_1');
    }).toThrow('Cannot parse');
  });

  test('decimals when using yocto', () => {
    expect(() => {
      NEAR.parse('0.1yN');
    }).toThrow('Cannot parse');
  });

  test("bald nano prefix, '1n', ambiguous with NEAR designation, '1N'", () => {
    expect(NEAR.parse('1n').toHuman()).toBe('1 N');
  });
});

describe.each`
  fromInput    | parseInput
  ${'1'}       | ${'1 yN'}
  ${1}         | ${'1 yN'}
  ${new BN(1)} | ${'1 yN'}
`('NEAR.from("$fromInput")', ({fromInput, parseInput}) => {
  const n = NEAR.from(fromInput);
  test(`== NEAR.parse(${parseInput})`, () => {
    expect(n).toStrictEqual(NEAR.parse(parseInput));
  });
});

'''
'''--- __tests__/parse.spec.ts ---
import {parse} from '../src';

describe.each`
  input      | human
  ${'1Tgas'} | ${'1 Tgas'}
  ${'1mN'}   | ${'1 mN'}
`('parse("$input")', ({input, human}) => {
  const x = parse(input);

  test(`toHuman() === "${human}"`, () => {
    expect(x.toHuman()).toBe(human);
  });
});

describe('parse() errors', () => {
  test('invalid unit', () => {
    expect(() => {
      parse('1 T');
    }).toThrow('Cannot parse');
  });

  test('invalid metric prefix', () => {
    expect(() => {
      parse('1 lolNEAR');
    }).toThrow('Unknown metric prefix: lol');
  });
});

'''
'''--- dist/bn.d.ts ---
import BN from 'bn.js';
export declare abstract class BNWrapper<T extends BN> extends BN {
    /**
     * @description returns the maximum of 2 BN instances.
     */
    max(other: BN): T;
    /**
     * @description returns the minimum of 2 BN instances.
     */
    min(other: BN): T;
    /**
     * @description  clone number
     */
    clone(): T;
    /**
     * @description convert to two's complement representation, where width is bit width
     */
    toTwos(width: number): T;
    /**
     * @description  convert from two's complement representation, where width is the bit width
     */
    fromTwos(width: number): T;
    /**
     * @description negate sign
     */
    neg(): T;
    /**
     * @description negate sign
     */
    ineg(): T;
    /**
     * @description absolute value
     */
    abs(): T;
    /**
     * @description absolute value
     */
    iabs(): T;
    /**
     * @description addition
     */
    add(b: BN): T;
    /**
     * @description  addition
     */
    iadd(b: BN): T;
    /**
     * @description addition
     */
    addn(b: number): T;
    /**
     * @description addition
     */
    iaddn(b: number): T;
    /**
     * @description subtraction
     */
    sub(b: BN): T;
    /**
     * @description subtraction
     */
    isub(b: BN): T;
    /**
     * @description subtraction
     */
    subn(b: number): T;
    /**
     * @description subtraction
     */
    isubn(b: number): T;
    /**
     * @description multiply
     */
    mul(b: BN): T;
    /**
     * @description multiply
     */
    imul(b: BN): T;
    /**
     * @description multiply
     */
    muln(b: number): T;
    /**
     * @description multiply
     */
    imuln(b: number): T;
    /**
     * @description square
     */
    sqr(): T;
    /**
     * @description square
     */
    isqr(): T;
    /**
     * @description raise `a` to the power of `b`
     */
    pow(b: BN): T;
    /**
     * @description divide
     */
    div(b: BN): T;
    /**
     * @description divide
     */
    divn(b: number): T;
    /**
     * @description divide
     */
    idivn(b: number): T;
    /**
     * @description reduct
     */
    mod(b: BN): T;
    /**
     * @description reduct
     */
    umod(b: BN): T;
    /**
     * @description  rounded division
     */
    divRound(b: BN): T;
    /**
     * @description or
     */
    or(b: BN): T;
    /**
     * @description or
     */
    ior(b: BN): T;
    /**
     * @description or
     */
    uor(b: BN): T;
    /**
     * @description or
     */
    iuor(b: BN): T;
    /**
     * @description and
     */
    and(b: BN): T;
    /**
     * @description and
     */
    iand(b: BN): T;
    /**
     * @description and
     */
    uand(b: BN): T;
    /**
     * @description and
     */
    iuand(b: BN): T;
    /**
     * @description and (NOTE: `andln` is going to be replaced with `andn` in future)
     */
    andln(b: number): T;
    /**
     * @description xor
     */
    xor(b: BN): T;
    /**
     * @description xor
     */
    ixor(b: BN): T;
    /**
     * @description xor
     */
    uxor(b: BN): T;
    /**
     * @description xor
     */
    iuxor(b: BN): T;
    /**
     * @description set specified bit to 1
     */
    setn(b: number): T;
    /**
     * @description shift left
     */
    shln(b: number): T;
    /**
     * @description shift left
     */
    ishln(b: number): T;
    /**
     * @description shift left
     */
    ushln(b: number): T;
    /**
     * @description shift left
     */
    iushln(b: number): T;
    /**
     * @description shift right
     */
    shrn(b: number): T;
    /**
     * @description shift right (unimplemented https://github.com/indutny/bn.js/blob/master/lib/bn.js#L2086)
     */
    ishrn(b: number): T;
    /**
     * @description shift right
     */
    ushrn(b: number): T;
    /**
     * @description shift right
     */
    iushrn(b: number): T;
    /**
     * @description  test if specified bit is set
     */
    maskn(b: number): T;
    /**
     * @description clear bits with indexes higher or equal to `b`
     */
    imaskn(b: number): T;
    /**
     * @description add `1 << b` to the number
     */
    bincn(b: number): T;
    /**
     * @description not (for the width specified by `w`)
     */
    notn(w: number): T;
    /**
     * @description not (for the width specified by `w`)
     */
    inotn(w: number): T;
    /**
     * @description GCD
     */
    gcd(b: BN): T;
    /**
     * @description Extended GCD results `({ a: ..., b: ..., gcd: ... })`
     */
    egcd(bn: BN): {
        a: T;
        b: T;
        gcd: T;
    };
    /**
     * @description inverse `a` modulo `b`
     */
    invm(b: BN): T;
    /**
     * Convert to BigInt type
     * @returns BigInt
     */
    toBigInt(): bigint;
    toJSON(): string;
    toString(base?: number | 'hex', length?: number): string;
    protected abstract from(bn: BN | number | string): T;
}

'''
'''--- dist/bn.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BNWrapper = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
class BNWrapper extends bn_js_1.default {
    /**
     * @description returns the maximum of 2 BN instances.
     */
    max(other) {
        return this.from(bn_js_1.default.max(this, other));
    }
    /**
     * @description returns the minimum of 2 BN instances.
     */
    min(other) {
        return this.from(bn_js_1.default.min(this, other));
    }
    /**
     * @description  clone number
     */
    clone() {
        return this.from(super.clone());
    }
    /**
     * @description convert to two's complement representation, where width is bit width
     */
    toTwos(width) {
        return this.from(super.toTwos(width));
    }
    /**
     * @description  convert from two's complement representation, where width is the bit width
     */
    fromTwos(width) {
        return this.from(super.fromTwos(width));
    }
    /**
     * @description negate sign
     */
    neg() {
        return this.from(super.neg());
    }
    /**
     * @description negate sign
     */
    ineg() {
        return this.from(super.ineg());
    }
    /**
     * @description absolute value
     */
    abs() {
        return this.from(super.abs());
    }
    /**
     * @description absolute value
     */
    iabs() {
        return this.from(super.iabs());
    }
    /**
     * @description addition
     */
    add(b) {
        return this.from(super.add(b));
    }
    /**
     * @description  addition
     */
    iadd(b) {
        return this.from(super.iadd(b));
    }
    /**
     * @description addition
     */
    addn(b) {
        return this.from(super.addn(b));
    }
    /**
     * @description addition
     */
    iaddn(b) {
        return this.from(super.iaddn(b));
    }
    /**
     * @description subtraction
     */
    sub(b) {
        return this.from(super.sub(b));
    }
    /**
     * @description subtraction
     */
    isub(b) {
        return this.from(super.isub(b));
    }
    /**
     * @description subtraction
     */
    subn(b) {
        return this.from(super.subn(b));
    }
    /**
     * @description subtraction
     */
    isubn(b) {
        return this.from(super.isubn(b));
    }
    /**
     * @description multiply
     */
    mul(b) {
        return this.from(super.mul(b));
    }
    /**
     * @description multiply
     */
    imul(b) {
        return this.from(super.imul(b));
    }
    /**
     * @description multiply
     */
    muln(b) {
        return this.from(super.muln(b));
    }
    /**
     * @description multiply
     */
    imuln(b) {
        return this.from(super.imuln(b));
    }
    /**
     * @description square
     */
    sqr() {
        return this.from(super.sqr());
    }
    /**
     * @description square
     */
    isqr() {
        return this.from(super.isqr());
    }
    /**
     * @description raise `a` to the power of `b`
     */
    pow(b) {
        return this.from(super.pow(b));
    }
    /**
     * @description divide
     */
    div(b) {
        return this.from(super.div(b));
    }
    /**
     * @description divide
     */
    divn(b) {
        return this.from(super.divn(b));
    }
    /**
     * @description divide
     */
    idivn(b) {
        return this.from(super.idivn(b));
    }
    /**
     * @description reduct
     */
    mod(b) {
        return this.from(super.mod(b));
    }
    /**
     * @description reduct
     */
    umod(b) {
        return this.from(super.umod(b));
    }
    /**
     * @description  rounded division
     */
    divRound(b) {
        return this.from(super.divRound(b));
    }
    /**
     * @description or
     */
    or(b) {
        return this.from(super.or(b));
    }
    /**
     * @description or
     */
    ior(b) {
        return this.from(super.ior(b));
    }
    /**
     * @description or
     */
    uor(b) {
        return this.from(super.uor(b));
    }
    /**
     * @description or
     */
    iuor(b) {
        return this.from(super.iuor(b));
    }
    /**
     * @description and
     */
    and(b) {
        return this.from(super.and(b));
    }
    /**
     * @description and
     */
    iand(b) {
        return this.from(super.iand(b));
    }
    /**
     * @description and
     */
    uand(b) {
        return this.from(super.uand(b));
    }
    /**
     * @description and
     */
    iuand(b) {
        return this.from(super.iuand(b));
    }
    /**
     * @description and (NOTE: `andln` is going to be replaced with `andn` in future)
     */
    andln(b) {
        return this.from(super.andln(b));
    }
    /**
     * @description xor
     */
    xor(b) {
        return this.from(super.xor(b));
    }
    /**
     * @description xor
     */
    ixor(b) {
        return this.from(super.ixor(b));
    }
    /**
     * @description xor
     */
    uxor(b) {
        return this.from(super.uxor(b));
    }
    /**
     * @description xor
     */
    iuxor(b) {
        return this.from(super.iuxor(b));
    }
    /**
     * @description set specified bit to 1
     */
    setn(b) {
        return this.from(super.setn(b));
    }
    /**
     * @description shift left
     */
    shln(b) {
        return this.from(super.shln(b));
    }
    /**
     * @description shift left
     */
    ishln(b) {
        return this.from(super.ishln(b));
    }
    /**
     * @description shift left
     */
    ushln(b) {
        return this.from(super.ushln(b));
    }
    /**
     * @description shift left
     */
    iushln(b) {
        return this.from(super.iushln(b));
    }
    /**
     * @description shift right
     */
    shrn(b) {
        return this.from(super.shrn(b));
    }
    /**
     * @description shift right (unimplemented https://github.com/indutny/bn.js/blob/master/lib/bn.js#L2086)
     */
    ishrn(b) {
        return this.from(super.ishrn(b));
    }
    /**
     * @description shift right
     */
    ushrn(b) {
        return this.from(super.ushrn(b));
    }
    /**
     * @description shift right
     */
    iushrn(b) {
        return this.from(super.iushrn(b));
    }
    /**
     * @description  test if specified bit is set
     */
    maskn(b) {
        return this.from(super.maskn(b));
    }
    /**
     * @description clear bits with indexes higher or equal to `b`
     */
    imaskn(b) {
        return this.from(super.imaskn(b));
    }
    /**
     * @description add `1 << b` to the number
     */
    bincn(b) {
        return this.from(super.bincn(b));
    }
    /**
     * @description not (for the width specified by `w`)
     */
    notn(w) {
        return this.from(super.notn(w));
    }
    /**
     * @description not (for the width specified by `w`)
     */
    inotn(w) {
        return this.from(super.inotn(w));
    }
    /**
     * @description GCD
     */
    gcd(b) {
        return this.from(super.gcd(b));
    }
    /**
     * @description Extended GCD results `({ a: ..., b: ..., gcd: ... })`
     */
    egcd(bn) {
        const { a, b, gcd } = super.egcd(bn);
        return { a: this.from(a), b: this.from(b), gcd: this.from(gcd) };
    }
    /**
     * @description inverse `a` modulo `b`
     */
    invm(b) {
        return this.from(super.invm(b));
    }
    /**
     * Convert to BigInt type
     * @returns BigInt
     */
    toBigInt() {
        return BigInt(this.toString());
    }
    toJSON() {
        return this.toString();
    }
    toString(base = 10, length) {
        return super.toString(base, length);
    }
}
exports.BNWrapper = BNWrapper;
//# sourceMappingURL=bn.js.map
'''
'''--- dist/cli.d.ts ---
#!/usr/bin/env node
export {};

'''
'''--- dist/cli.js ---
#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = __importDefault(require("process"));
const parse_1 = require("./parse");
const HELP = `Parse and format NEAR tokens and gas units. Examples:

    near-units 10 N                             # => 10000000000000000000000000
    near-units -h 10000000000000000000000000 yN # => 10 N
    near-units 50 Tgas                          # => 50000000000000
    near-units -h 50000000000000 gas            # => 50 Tgas
`;
let args = process_1.default.argv.slice(2);
if (args.length === 0) {
    console.log(HELP);
    process_1.default.exit(0);
}
let wantsHuman = false;
if (args.length > 1 && args.includes('-h')) {
    wantsHuman = true;
    args = args.filter((x) => x !== '-h');
}
const input = args.join('');
if (input === '--help') {
    console.log(HELP);
    process_1.default.exit(0);
}
try {
    if (wantsHuman) {
        console.log((0, parse_1.parse)(input).toHuman());
    }
    else {
        console.log((0, parse_1.parse)(input).toJSON());
    }
}
catch (error) {
    if (error instanceof Error) {
        console.error(error.message);
    }
    else {
        console.error(error);
    }
    process_1.default.exit(1);
}
//# sourceMappingURL=cli.js.map
'''
'''--- dist/gas.d.ts ---
import BN from 'bn.js';
import { BNWrapper } from './bn';
export declare class Gas extends BNWrapper<Gas> {
    /**
     * Converts a BN, number, or string in gas units to Gas.
     *
     * @example
     * ```ts
     * const gas  = Gas.from(new BN("10000000"))
     * const gas2 = Gas.from('1 TGas')
     * ```
     */
    static from(bn: BN | number | string): Gas;
    /**
     * Convert human readable gas amount to internal indivisible units.
     *
     * @example
     * ```ts
     * Gas.parse('1') // => Gas<'1'> (1 gas)
     * Gas.parse('1 Tgas') // => Gas<'1000000000000'> (1e12 gas)
     * Gas.parse('1 Ggas') // => Gas<'1000000000'> (1e9 gas)
     * ```
     *
     * @param x decimal string denominated in gas, Tgas, Ggas, etc.
     * @returns new Gas object wrapping the parsed amount
     */
    static parse(x: string): Gas;
    /**
     * Convert to string such as "53 Tgas" or "900 Ggas"
     * @returns string showing gas amount in a human-readable way
     */
    toHuman(): string;
    protected from(bn: BN | number | string): Gas;
}

'''
'''--- dist/gas.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gas = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bn_1 = require("./bn");
const utils_1 = require("./utils");
class Gas extends bn_1.BNWrapper {
    /**
     * Converts a BN, number, or string in gas units to Gas.
     *
     * @example
     * ```ts
     * const gas  = Gas.from(new BN("10000000"))
     * const gas2 = Gas.from('1 TGas')
     * ```
     */
    static from(bn) {
        if (bn instanceof bn_js_1.default) {
            const gas = new Gas(0);
            // @ts-expect-error internal method
            bn.copy(gas); // eslint-disable-line @typescript-eslint/no-unsafe-call
            return gas;
        }
        return new Gas(bn);
    }
    /**
     * Convert human readable gas amount to internal indivisible units.
     *
     * @example
     * ```ts
     * Gas.parse('1') // => Gas<'1'> (1 gas)
     * Gas.parse('1 Tgas') // => Gas<'1000000000000'> (1e12 gas)
     * Gas.parse('1 Ggas') // => Gas<'1000000000'> (1e9 gas)
     * ```
     *
     * @param x decimal string denominated in gas, Tgas, Ggas, etc.
     * @returns new Gas object wrapping the parsed amount
     */
    static parse(x) {
        x = x.replace(utils_1.gasPattern, '').trim(); // Clean string for use with generic `parse`
        return new Gas((0, utils_1.parse)(x));
    }
    /**
     * Convert to string such as "53 Tgas" or "900 Ggas"
     * @returns string showing gas amount in a human-readable way
     */
    toHuman() {
        return (0, utils_1.toHuman)(this, 'gas', 12, 12);
    }
    from(bn) {
        return Gas.from(bn);
    }
}
exports.Gas = Gas;
//# sourceMappingURL=gas.js.map
'''
'''--- dist/index.d.ts ---
export * from './near';
export * from './gas';
export * from './parse';

'''
'''--- dist/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./near"), exports);
__exportStar(require("./gas"), exports);
__exportStar(require("./parse"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- dist/near.d.ts ---
import BN from 'bn.js';
import { BNWrapper } from './bn';
/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
export declare const DECIMALS = 24;
export declare class NEAR extends BNWrapper<NEAR> {
    /**
     * Converts a BN, number, or string in yoctoNear to NEAR.
     *
     * @example
     * ```ts
     * const nearAmt  = NEAR.from(new BN("10000000"));
     * const nearAmt2 = NEAR.from("1");
     * ```
     */
    static from(bn: BN | number | string): NEAR;
    /**
     * Convert human readable NEAR amount string to a NEAR object.
     *
     * @example
     * ```ts
     * NEAR.parse('1')     // => NEAR<'1000000000000000000000000'> (1e24 yoctoNEAR; 1 NEAR)
     * NEAR.parse('1,000') // => NEAR<'1000000000000000000000000000'> (1e27 yoctoNEAR; 1,000 NEAR)
     * NEAR.parse('1 mN')  // => NEAR<'1000000000000000000000'> (1e21 yoctoNEAR; 0.001 NEAR)
     * NEAR.parse('1 nN')  // => NEAR<'1000000000000000'> (1e15 yoctoNEAR; 0.000000001 NEAR)
     * ```
     *
     * @param x string representation of NEAR tokens amount
     * @returns new NEAR object wrapping the parsed amount
     */
    static parse(x: string): NEAR;
    /**
     * Convert to string such as "1,000 N", "1 mN", or "1 nN"
     * @returns string showing NEAR amount in a human-readable way
     */
    toHuman(): string;
    protected from(bn: BN | number | string): NEAR;
}

'''
'''--- dist/near.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NEAR = exports.DECIMALS = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bn_1 = require("./bn");
const utils_1 = require("./utils");
/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
exports.DECIMALS = 24;
class NEAR extends bn_1.BNWrapper {
    /**
     * Converts a BN, number, or string in yoctoNear to NEAR.
     *
     * @example
     * ```ts
     * const nearAmt  = NEAR.from(new BN("10000000"));
     * const nearAmt2 = NEAR.from("1");
     * ```
     */
    static from(bn) {
        if (bn instanceof bn_js_1.default) {
            const near = new NEAR(0);
            // @ts-expect-error internal method
            bn.copy(near); // eslint-disable-line @typescript-eslint/no-unsafe-call
            return near;
        }
        return new NEAR(bn);
    }
    /**
     * Convert human readable NEAR amount string to a NEAR object.
     *
     * @example
     * ```ts
     * NEAR.parse('1')     // => NEAR<'1000000000000000000000000'> (1e24 yoctoNEAR; 1 NEAR)
     * NEAR.parse('1,000') // => NEAR<'1000000000000000000000000000'> (1e27 yoctoNEAR; 1,000 NEAR)
     * NEAR.parse('1 mN')  // => NEAR<'1000000000000000000000'> (1e21 yoctoNEAR; 0.001 NEAR)
     * NEAR.parse('1 nN')  // => NEAR<'1000000000000000'> (1e15 yoctoNEAR; 0.000000001 NEAR)
     * ```
     *
     * @param x string representation of NEAR tokens amount
     * @returns new NEAR object wrapping the parsed amount
     */
    static parse(x) {
        x = x.replace(utils_1.nearPattern, '').trim(); // Clean string for use with generic `parse`
        return new NEAR((0, utils_1.parse)(x, 24));
    }
    /**
     * Convert to string such as "1,000 N", "1 mN", or "1 nN"
     * @returns string showing NEAR amount in a human-readable way
     */
    toHuman() {
        return (0, utils_1.toHuman)(this, 'N', exports.DECIMALS);
    }
    from(bn) {
        return NEAR.from(bn);
    }
}
exports.NEAR = NEAR;
//# sourceMappingURL=near.js.map
'''
'''--- dist/parse.d.ts ---
import { Gas } from './gas';
import { NEAR } from './near';
/**
 * Parse a well-formatted string into a NEAR object or a Gas object.
 *
 * @example
 * ```
 * parse('1 N') // => NEAR<'1000000000000000000000000'>
 * parse('1mN') // => NEAR<'1000000000000000000000'>
 * parse('1Tgas') // => Gas<'1000000000000'>
 * ```
 * @param x string representing a value
 *
 */
export declare function parse(x: string): Gas | NEAR;

'''
'''--- dist/parse.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const gas_1 = require("./gas");
const near_1 = require("./near");
const utils_1 = require("./utils");
/**
 * Parse a well-formatted string into a NEAR object or a Gas object.
 *
 * @example
 * ```
 * parse('1 N') // => NEAR<'1000000000000000000000000'>
 * parse('1mN') // => NEAR<'1000000000000000000000'>
 * parse('1Tgas') // => Gas<'1000000000000'>
 * ```
 * @param x string representing a value
 *
 */
function parse(x) {
    if (utils_1.gasPattern.test(x)) {
        return gas_1.Gas.parse(x.replace(utils_1.gasPattern, ''));
    }
    if (utils_1.nearPattern.test(x)) {
        return near_1.NEAR.parse(x.replace(utils_1.nearPattern, ''));
    }
    throw new Error(`Cannot parse ${x}; expected a NEAR-like string ('1N') or a gas-like string ('1Tgas')`);
}
exports.parse = parse;
//# sourceMappingURL=parse.js.map
'''
'''--- dist/utils.d.ts ---
/**
 * Internal utilities.
 *
 * - not exported from index.ts
 * - do not make sense on their own, but only as internal tools to be used from NEAR or Gas classes
 */
import BN from 'bn.js';
export declare const gasPattern: RegExp;
export declare const nearPattern: RegExp;
/**
 * Internal function to be used by {@link Gas.parse} and {@link NEAR.parse}
 * after they have already stripped out 'N' or 'gas'.
 *
 * @example
 * ```
 * parse('1 m', 24) // => input passed from NEAR
 * parse('1T') // => input passed from Gas
 * ```
 *
 * @param x string with number and possibly a trailing metric prefix
 * @returns string suitable for initializing a BN
 */
export declare function parse(x: string, magnitude?: number): string;
/**
 * Removes commas, underscores, leading/trailing whitespace, and leading zeroes from the input
 * @param x A value or amount that may contain commas or underscores
 * @returns string The cleaned value
 */
export declare function clean(x: string): string;
/**
 * Get the order of magnitude of a given metric prefix. Throws an error if given string does not match a known metric prefix.
 * @param prefix string like 'c' or 'centi'
 * @returns corresponding order of magnitude (also sometimes called 'magnitude' of this metric prefix)
 */
export declare function getMagnitude(prefix: string): number;
/**
 * Generic `toHuman` function used by both NEAR and Gas.
 *
 * @param x BN to convert to human-readable format
 * @param baseUnit String like 'N' or 'gas' that will be added to the end of the returned string
 * @param magnitude How many numbers go after the decimal point for "one" of these things (for NEAR this is 24; for gas it's 0)
 * @param adjustMagnitude DO NOT USE! Only used internally by this function when it calls itself recursively.
 * @returns human-readable representation of `x`
 */
export declare function toHuman(x: BN, baseUnit: string, magnitude: number, adjustMagnitude?: number): string;

'''
'''--- dist/utils.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHuman = exports.getMagnitude = exports.clean = exports.parse = exports.nearPattern = exports.gasPattern = void 0;
/**
 * Internal utilities.
 *
 * - not exported from index.ts
 * - do not make sense on their own, but only as internal tools to be used from NEAR or Gas classes
 */
const bn_js_1 = __importDefault(require("bn.js"));
exports.gasPattern = /gas\s*$/i;
exports.nearPattern = /n(ear)?\s*$/i;
const possibleMetricPrefix = /([μa-z]+)$/i;
/**
 * Internal function to be used by {@link Gas.parse} and {@link NEAR.parse}
 * after they have already stripped out 'N' or 'gas'.
 *
 * @example
 * ```
 * parse('1 m', 24) // => input passed from NEAR
 * parse('1T') // => input passed from Gas
 * ```
 *
 * @param x string with number and possibly a trailing metric prefix
 * @returns string suitable for initializing a BN
 */
function parse(x, magnitude = 0) {
    var _a;
    if (!x) {
        throw new TypeError(`invalid input string: '${x.toString()}'`);
    }
    let amount = x; // Mutable copy that gets updated throughout function
    const metricPrefix = (_a = possibleMetricPrefix.exec(x)) === null || _a === void 0 ? void 0 : _a[1];
    if (metricPrefix) {
        magnitude += getMagnitude(metricPrefix);
        amount = amount.replace(possibleMetricPrefix, '');
    }
    amount = clean(amount);
    const split = amount.split('.');
    if (magnitude === 0 && split.length > 1) {
        throw new Error(`Cannot parse '${amount}'; unexpected decimal point${metricPrefix ? ` with metric prefix ${metricPrefix}` : ''}`);
    }
    if (split.length > 2) {
        throw new Error(`Cannot parse '${amount}'; too many decimal points (\`.\`)`);
    }
    const wholePart = split[0];
    const fracPart = split[1] || '';
    if (fracPart.length > magnitude) {
        throw new Error(`Cannot parse '${x}'; fractional part contains more than ${magnitude} digits`);
    }
    return `${wholePart}${fracPart.padEnd(magnitude, '0')}`;
}
exports.parse = parse;
/**
 * Removes commas, underscores, leading/trailing whitespace, and leading zeroes from the input
 * @param x A value or amount that may contain commas or underscores
 * @returns string The cleaned value
 */
function clean(x) {
    return x.trim().replace(/[,_]/g, '').replace(/^0+\b/, '');
}
exports.clean = clean;
/**
 * Get the order of magnitude of a given metric prefix. Throws an error if given string does not match a known metric prefix.
 * @param prefix string like 'c' or 'centi'
 * @returns corresponding order of magnitude (also sometimes called 'magnitude' of this metric prefix)
 */
function getMagnitude(prefix) {
    for (const [pattern, magnitude] of prefixToMagnitude.entries()) {
        if (pattern.test(prefix)) {
            return magnitude;
        }
    }
    throw new Error(`Unknown metric prefix: ${prefix}`);
}
exports.getMagnitude = getMagnitude;
const prefixToMagnitude = new Map([
    [/\bY\b/, 24],
    [/yotta/i, 24],
    [/\bZ\b/, 21],
    [/zetta/i, 21],
    [/\bE\b/, 18],
    [/exa/i, 18],
    [/\bP\b/, 15],
    [/peta/i, 15],
    [/\bT\b/, 12],
    [/tera/i, 12],
    [/\bG\b/, 9],
    [/giga/i, 9],
    [/\bM\b/, 6],
    [/mega/i, 6],
    [/\bk\b/, 3],
    [/kilo/i, 3],
    [/\bh\b/, 2],
    [/hecto/i, 2],
    [/\bda\b/, 1],
    [/deka/i, 1],
    [/\bd\b/, -1],
    [/deci/i, -1],
    [/\bc\b/, -2],
    [/centi/i, -2],
    [/\bm\b/, -3],
    [/milli/i, -3],
    [/μ/, -6],
    [/micro/i, -6],
    [/\bn\b/, -9],
    [/nano/i, -9],
    [/\bp\b/, -12],
    [/pico/i, -12],
    [/\bf\b/, -15],
    [/femto/i, -15],
    [/\ba\b/, -18],
    [/atto/i, -18],
    [/\bz\b/, -21],
    [/zepto/i, -21],
    [/\by\b/, -24],
    [/yocto/i, -24],
]);
const magnitudeToPrefix = new Map([
    [24, 'Y'],
    [21, 'Z'],
    [18, 'E'],
    [15, 'P'],
    [12, 'T'],
    [9, 'G'],
    [6, 'M'],
    [3, 'k'],
    [0, ''],
    [-3, 'm'],
    [-6, 'μ'],
    [-9, 'n'],
    [-12, 'p'],
    [-15, 'f'],
    [-18, 'a'],
    [-21, 'z'],
    [-24, 'y'],
]);
/**
 * Generic `toHuman` function used by both NEAR and Gas.
 *
 * @param x BN to convert to human-readable format
 * @param baseUnit String like 'N' or 'gas' that will be added to the end of the returned string
 * @param magnitude How many numbers go after the decimal point for "one" of these things (for NEAR this is 24; for gas it's 0)
 * @param adjustMagnitude DO NOT USE! Only used internally by this function when it calls itself recursively.
 * @returns human-readable representation of `x`
 */
function toHuman(x, baseUnit, magnitude, adjustMagnitude = 0) {
    const nomination = new bn_js_1.default(10).pow(new bn_js_1.default(magnitude));
    const quotient = x.div(nomination);
    const remainder = x.mod(nomination);
    if (quotient.gt(new bn_js_1.default(0))) {
        // Format the part before the decimal in en-US format (like "1,000");
        const integer = new Intl.NumberFormat('en-US').format(BigInt(quotient.toString(10)));
        // Leave the part after the decimal as-is (like ".00100200003")
        const fraction = remainder.eq(new bn_js_1.default(0))
            ? ''
            : `.${remainder
                .toString(10)
                .padStart(magnitude, '0')
                .replace(/0+$\b/, '')}`;
        const prefix = magnitudeToPrefix.get(adjustMagnitude);
        return `${integer}${fraction} ${prefix}${baseUnit}`;
    }
    return toHuman(x, baseUnit, magnitude - 3, adjustMagnitude - 3);
}
exports.toHuman = toHuman;
//# sourceMappingURL=utils.js.map
'''
'''--- package.json ---
{
  "name": "near-units",
  "version": "0.1.9",
  "description": "Easily parse, inspect, and operate on NEAR token or gas amounts. Wraps bn.js",
  "repository": "https://github.com/near/units-js",
  "author": "Near Inc <team@near.org>",
  "license": "(MIT AND Apache-2.0)",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/"
  ],
  "bin": "dist/cli.js",
  "scripts": {
    "build": "tsc",
    "lint": "xo",
    "lint:fix": "xo --fix",
    "test": "yarn build && jest",
    "prepare": "husky install"
  },
  "dependencies": {
    "bn.js": "^5.2.0"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.7",
    "husky": "^7.0.2",
    "jest": "^27.1.0",
    "ts-jest": "^27.0.5",
    "ts-node": "^10.2.1",
    "typescript": "^4.4.2",
    "webpack": "^5.51.1",
    "xo": "^0.44.0"
  },
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "testMatch": [
      "**/__tests__/*.spec.ts"
    ],
    "testPathIgnorePatterns": [
      "/node_modules/"
    ]
  },
  "xo": {
    "space": true,
    "prettier": true,
    "rules": {
      "unicorn/prefer-node-protocol": 0
    },
    "overrides": [
      {
        "files": "__tests__/**/*.spec.ts",
        "rules": {
          "@typescript-eslint/restrict-template-expressions": 0
        }
      }
    ]
  },
  "packageManager": "yarn@3.0.1"
}

'''
'''--- src/bn.ts ---
import BN from 'bn.js';

export abstract class BNWrapper<T extends BN> extends BN {
  /**
   * @description returns the maximum of 2 BN instances.
   */
  max(other: BN): T {
    return this.from(BN.max(this, other));
  }

  /**
   * @description returns the minimum of 2 BN instances.
   */
  min(other: BN): T {
    return this.from(BN.min(this, other));
  }

  /**
   * @description  clone number
   */
  clone(): T {
    return this.from(super.clone());
  }

  /**
   * @description convert to two's complement representation, where width is bit width
   */
  toTwos(width: number): T {
    return this.from(super.toTwos(width));
  }

  /**
   * @description  convert from two's complement representation, where width is the bit width
   */
  fromTwos(width: number): T {
    return this.from(super.fromTwos(width));
  }

  /**
   * @description negate sign
   */
  neg(): T {
    return this.from(super.neg());
  }

  /**
   * @description negate sign
   */
  ineg(): T {
    return this.from(super.ineg());
  }

  /**
   * @description absolute value
   */
  abs(): T {
    return this.from(super.abs());
  }

  /**
   * @description absolute value
   */
  iabs(): T {
    return this.from(super.iabs());
  }

  /**
   * @description addition
   */
  add(b: BN): T {
    return this.from(super.add(b));
  }

  /**
   * @description  addition
   */
  iadd(b: BN): T {
    return this.from(super.iadd(b));
  }

  /**
   * @description addition
   */
  addn(b: number): T {
    return this.from(super.addn(b));
  }

  /**
   * @description addition
   */
  iaddn(b: number): T {
    return this.from(super.iaddn(b));
  }

  /**
   * @description subtraction
   */
  sub(b: BN): T {
    return this.from(super.sub(b));
  }

  /**
   * @description subtraction
   */
  isub(b: BN): T {
    return this.from(super.isub(b));
  }

  /**
   * @description subtraction
   */
  subn(b: number): T {
    return this.from(super.subn(b));
  }

  /**
   * @description subtraction
   */
  isubn(b: number): T {
    return this.from(super.isubn(b));
  }

  /**
   * @description multiply
   */
  mul(b: BN): T {
    return this.from(super.mul(b));
  }

  /**
   * @description multiply
   */
  imul(b: BN): T {
    return this.from(super.imul(b));
  }

  /**
   * @description multiply
   */
  muln(b: number): T {
    return this.from(super.muln(b));
  }

  /**
   * @description multiply
   */
  imuln(b: number): T {
    return this.from(super.imuln(b));
  }

  /**
   * @description square
   */
  sqr(): T {
    return this.from(super.sqr());
  }

  /**
   * @description square
   */
  isqr(): T {
    return this.from(super.isqr());
  }

  /**
   * @description raise `a` to the power of `b`
   */
  pow(b: BN): T {
    return this.from(super.pow(b));
  }

  /**
   * @description divide
   */
  div(b: BN): T {
    return this.from(super.div(b));
  }

  /**
   * @description divide
   */
  divn(b: number): T {
    return this.from(super.divn(b));
  }

  /**
   * @description divide
   */
  idivn(b: number): T {
    return this.from(super.idivn(b));
  }

  /**
   * @description reduct
   */
  mod(b: BN): T {
    return this.from(super.mod(b));
  }

  /**
   * @description reduct
   */
  umod(b: BN): T {
    return this.from(super.umod(b));
  }

  /**
   * @description  rounded division
   */
  divRound(b: BN): T {
    return this.from(super.divRound(b));
  }

  /**
   * @description or
   */
  or(b: BN): T {
    return this.from(super.or(b));
  }

  /**
   * @description or
   */
  ior(b: BN): T {
    return this.from(super.ior(b));
  }

  /**
   * @description or
   */
  uor(b: BN): T {
    return this.from(super.uor(b));
  }

  /**
   * @description or
   */
  iuor(b: BN): T {
    return this.from(super.iuor(b));
  }

  /**
   * @description and
   */
  and(b: BN): T {
    return this.from(super.and(b));
  }

  /**
   * @description and
   */
  iand(b: BN): T {
    return this.from(super.iand(b));
  }

  /**
   * @description and
   */
  uand(b: BN): T {
    return this.from(super.uand(b));
  }

  /**
   * @description and
   */
  iuand(b: BN): T {
    return this.from(super.iuand(b));
  }

  /**
   * @description and (NOTE: `andln` is going to be replaced with `andn` in future)
   */
  andln(b: number): T {
    return this.from(super.andln(b));
  }

  /**
   * @description xor
   */
  xor(b: BN): T {
    return this.from(super.xor(b));
  }

  /**
   * @description xor
   */
  ixor(b: BN): T {
    return this.from(super.ixor(b));
  }

  /**
   * @description xor
   */
  uxor(b: BN): T {
    return this.from(super.uxor(b));
  }

  /**
   * @description xor
   */
  iuxor(b: BN): T {
    return this.from(super.iuxor(b));
  }

  /**
   * @description set specified bit to 1
   */
  setn(b: number): T {
    return this.from(super.setn(b));
  }

  /**
   * @description shift left
   */
  shln(b: number): T {
    return this.from(super.shln(b));
  }

  /**
   * @description shift left
   */
  ishln(b: number): T {
    return this.from(super.ishln(b));
  }

  /**
   * @description shift left
   */
  ushln(b: number): T {
    return this.from(super.ushln(b));
  }

  /**
   * @description shift left
   */
  iushln(b: number): T {
    return this.from(super.iushln(b));
  }

  /**
   * @description shift right
   */
  shrn(b: number): T {
    return this.from(super.shrn(b));
  }

  /**
   * @description shift right (unimplemented https://github.com/indutny/bn.js/blob/master/lib/bn.js#L2086)
   */
  ishrn(b: number): T {
    return this.from(super.ishrn(b));
  }

  /**
   * @description shift right
   */
  ushrn(b: number): T {
    return this.from(super.ushrn(b));
  }
  /**
   * @description shift right
   */

  iushrn(b: number): T {
    return this.from(super.iushrn(b));
  }
  /**
   * @description  test if specified bit is set
   */

  maskn(b: number): T {
    return this.from(super.maskn(b));
  }
  /**
   * @description clear bits with indexes higher or equal to `b`
   */

  imaskn(b: number): T {
    return this.from(super.imaskn(b));
  }
  /**
   * @description add `1 << b` to the number
   */

  bincn(b: number): T {
    return this.from(super.bincn(b));
  }

  /**
   * @description not (for the width specified by `w`)
   */
  notn(w: number): T {
    return this.from(super.notn(w));
  }

  /**
   * @description not (for the width specified by `w`)
   */
  inotn(w: number): T {
    return this.from(super.inotn(w));
  }

  /**
   * @description GCD
   */
  gcd(b: BN): T {
    return this.from(super.gcd(b));
  }

  /**
   * @description Extended GCD results `({ a: ..., b: ..., gcd: ... })`
   */
  egcd(bn: BN): {a: T; b: T; gcd: T} {
    const {a, b, gcd} = super.egcd(bn);
    return {a: this.from(a), b: this.from(b), gcd: this.from(gcd)};
  }

  /**
   * @description inverse `a` modulo `b`
   */
  invm(b: BN): T {
    return this.from(super.invm(b));
  }

  /**
   * Convert to BigInt type
   * @returns BigInt
   */
  toBigInt(): bigint {
    return BigInt(this.toString());
  }

  toJSON(): string {
    return this.toString();
  }

  toString(base: number | 'hex' = 10, length?: number): string {
    return super.toString(base, length);
  }

  protected abstract from(bn: BN | number | string): T;
}

'''
'''--- src/cli.ts ---
#!/usr/bin/env node
import process from 'process';
import {parse} from './parse';

const HELP = `Parse and format NEAR tokens and gas units. Examples:

    near-units 10 N                             # => 10000000000000000000000000
    near-units -h 10000000000000000000000000 yN # => 10 N
    near-units 50 Tgas                          # => 50000000000000
    near-units -h 50000000000000 gas            # => 50 Tgas
`;

let args = process.argv.slice(2);

if (args.length === 0) {
  console.log(HELP);
  process.exit(0);
}

let wantsHuman = false;
if (args.length > 1 && args.includes('-h')) {
  wantsHuman = true;
  args = args.filter((x) => x !== '-h');
}

const input = args.join('');

if (input === '--help') {
  console.log(HELP);
  process.exit(0);
}

try {
  if (wantsHuman) {
    console.log(parse(input).toHuman());
  } else {
    console.log(parse(input).toJSON());
  }
} catch (error: unknown) {
  if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error(error);
  }

  process.exit(1);
}

'''
'''--- src/gas.ts ---
import BN from 'bn.js';
import {BNWrapper} from './bn';
import {parse, gasPattern, toHuman} from './utils';

export class Gas extends BNWrapper<Gas> {
  /**
   * Converts a BN, number, or string in gas units to Gas.
   *
   * @example
   * ```ts
   * const gas  = Gas.from(new BN("10000000"))
   * const gas2 = Gas.from('1 TGas')
   * ```
   */
  static from(bn: BN | number | string): Gas {
    if (bn instanceof BN) {
      const gas = new Gas(0);
      // @ts-expect-error internal method
      bn.copy(gas); // eslint-disable-line @typescript-eslint/no-unsafe-call
      return gas;
    }

    return new Gas(bn);
  }

  /**
   * Convert human readable gas amount to internal indivisible units.
   *
   * @example
   * ```ts
   * Gas.parse('1') // => Gas<'1'> (1 gas)
   * Gas.parse('1 Tgas') // => Gas<'1000000000000'> (1e12 gas)
   * Gas.parse('1 Ggas') // => Gas<'1000000000'> (1e9 gas)
   * ```
   *
   * @param x decimal string denominated in gas, Tgas, Ggas, etc.
   * @returns new Gas object wrapping the parsed amount
   */
  static parse(x: string): Gas {
    x = x.replace(gasPattern, '').trim(); // Clean string for use with generic `parse`
    return new Gas(parse(x));
  }

  /**
   * Convert to string such as "53 Tgas" or "900 Ggas"
   * @returns string showing gas amount in a human-readable way
   */
  toHuman(): string {
    return toHuman(this, 'gas', 12, 12);
  }

  protected from(bn: BN | number | string): Gas {
    return Gas.from(bn);
  }
}

'''
'''--- src/index.ts ---
export * from './near';
export * from './gas';
export * from './parse';

'''
'''--- src/near.ts ---
import BN from 'bn.js';
import {BNWrapper} from './bn';
import {parse, nearPattern, toHuman} from './utils';

/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
export const DECIMALS = 24;

export class NEAR extends BNWrapper<NEAR> {
  /**
   * Converts a BN, number, or string in yoctoNear to NEAR.
   *
   * @example
   * ```ts
   * const nearAmt  = NEAR.from(new BN("10000000"));
   * const nearAmt2 = NEAR.from("1");
   * ```
   */
  static from(bn: BN | number | string): NEAR {
    if (bn instanceof BN) {
      const near = new NEAR(0);
      // @ts-expect-error internal method
      bn.copy(near); // eslint-disable-line @typescript-eslint/no-unsafe-call
      return near;
    }

    return new NEAR(bn);
  }

  /**
   * Convert human readable NEAR amount string to a NEAR object.
   *
   * @example
   * ```ts
   * NEAR.parse('1')     // => NEAR<'1000000000000000000000000'> (1e24 yoctoNEAR; 1 NEAR)
   * NEAR.parse('1,000') // => NEAR<'1000000000000000000000000000'> (1e27 yoctoNEAR; 1,000 NEAR)
   * NEAR.parse('1 mN')  // => NEAR<'1000000000000000000000'> (1e21 yoctoNEAR; 0.001 NEAR)
   * NEAR.parse('1 nN')  // => NEAR<'1000000000000000'> (1e15 yoctoNEAR; 0.000000001 NEAR)
   * ```
   *
   * @param x string representation of NEAR tokens amount
   * @returns new NEAR object wrapping the parsed amount
   */
  static parse(x: string): NEAR {
    x = x.replace(nearPattern, '').trim(); // Clean string for use with generic `parse`
    return new NEAR(parse(x, 24));
  }

  /**
   * Convert to string such as "1,000 N", "1 mN", or "1 nN"
   * @returns string showing NEAR amount in a human-readable way
   */
  toHuman(): string {
    return toHuman(this, 'N', DECIMALS);
  }

  protected from(bn: BN | number | string): NEAR {
    return NEAR.from(bn);
  }
}

'''
'''--- src/parse.ts ---
import {Gas} from './gas';
import {NEAR} from './near';
import {gasPattern, nearPattern} from './utils';

/**
 * Parse a well-formatted string into a NEAR object or a Gas object.
 *
 * @example
 * ```
 * parse('1 N') // => NEAR<'1000000000000000000000000'>
 * parse('1mN') // => NEAR<'1000000000000000000000'>
 * parse('1Tgas') // => Gas<'1000000000000'>
 * ```
 * @param x string representing a value
 *
 */
export function parse(x: string): Gas | NEAR {
  if (gasPattern.test(x)) {
    return Gas.parse(x.replace(gasPattern, ''));
  }

  if (nearPattern.test(x)) {
    return NEAR.parse(x.replace(nearPattern, ''));
  }

  throw new Error(
    `Cannot parse ${x}; expected a NEAR-like string ('1N') or a gas-like string ('1Tgas')`,
  );
}

'''
'''--- src/utils.ts ---
/**
 * Internal utilities.
 *
 * - not exported from index.ts
 * - do not make sense on their own, but only as internal tools to be used from NEAR or Gas classes
 */
import BN from 'bn.js';

export const gasPattern = /gas\s*$/i;
export const nearPattern = /n(ear)?\s*$/i;

const possibleMetricPrefix = /([μa-z]+)$/i;

/**
 * Internal function to be used by {@link Gas.parse} and {@link NEAR.parse}
 * after they have already stripped out 'N' or 'gas'.
 *
 * @example
 * ```
 * parse('1 m', 24) // => input passed from NEAR
 * parse('1T') // => input passed from Gas
 * ```
 *
 * @param x string with number and possibly a trailing metric prefix
 * @returns string suitable for initializing a BN
 */
export function parse(x: string, magnitude = 0): string {
  if (!x) {
    throw new TypeError(`invalid input string: '${x.toString()}'`);
  }

  let amount = x; // Mutable copy that gets updated throughout function

  const metricPrefix = possibleMetricPrefix.exec(x)?.[1];
  if (metricPrefix) {
    magnitude += getMagnitude(metricPrefix);
    amount = amount.replace(possibleMetricPrefix, '');
  }

  amount = clean(amount);

  const split = amount.split('.');

  if (magnitude === 0 && split.length > 1) {
    throw new Error(
      `Cannot parse '${amount}'; unexpected decimal point${
        metricPrefix ? ` with metric prefix ${metricPrefix}` : ''
      }`,
    );
  }

  if (split.length > 2) {
    throw new Error(
      `Cannot parse '${amount}'; too many decimal points (\`.\`)`,
    );
  }

  const wholePart = split[0];
  const fracPart = split[1] || '';

  if (fracPart.length > magnitude) {
    throw new Error(
      `Cannot parse '${x}'; fractional part contains more than ${magnitude} digits`,
    );
  }

  return `${wholePart}${fracPart.padEnd(magnitude, '0')}`;
}

/**
 * Removes commas, underscores, leading/trailing whitespace, and leading zeroes from the input
 * @param x A value or amount that may contain commas or underscores
 * @returns string The cleaned value
 */
export function clean(x: string): string {
  return x.trim().replace(/[,_]/g, '').replace(/^0+\b/, '');
}

/**
 * Get the order of magnitude of a given metric prefix. Throws an error if given string does not match a known metric prefix.
 * @param prefix string like 'c' or 'centi'
 * @returns corresponding order of magnitude (also sometimes called 'magnitude' of this metric prefix)
 */
export function getMagnitude(prefix: string): number {
  for (const [pattern, magnitude] of prefixToMagnitude.entries()) {
    if (pattern.test(prefix)) {
      return magnitude;
    }
  }

  throw new Error(`Unknown metric prefix: ${prefix}`);
}

const prefixToMagnitude = new Map([
  [/\bY\b/, 24],
  [/yotta/i, 24],
  [/\bZ\b/, 21],
  [/zetta/i, 21],
  [/\bE\b/, 18],
  [/exa/i, 18],
  [/\bP\b/, 15],
  [/peta/i, 15],
  [/\bT\b/, 12],
  [/tera/i, 12],
  [/\bG\b/, 9],
  [/giga/i, 9],
  [/\bM\b/, 6],
  [/mega/i, 6],
  [/\bk\b/, 3],
  [/kilo/i, 3],
  [/\bh\b/, 2],
  [/hecto/i, 2],
  [/\bda\b/, 1],
  [/deka/i, 1],
  [/\bd\b/, -1],
  [/deci/i, -1],
  [/\bc\b/, -2],
  [/centi/i, -2],
  [/\bm\b/, -3],
  [/milli/i, -3],
  [/μ/, -6],
  [/micro/i, -6],
  [/\bn\b/, -9],
  [/nano/i, -9],
  [/\bp\b/, -12],
  [/pico/i, -12],
  [/\bf\b/, -15],
  [/femto/i, -15],
  [/\ba\b/, -18],
  [/atto/i, -18],
  [/\bz\b/, -21],
  [/zepto/i, -21],
  [/\by\b/, -24],
  [/yocto/i, -24],
]);

const magnitudeToPrefix = new Map([
  [24, 'Y'],
  [21, 'Z'],
  [18, 'E'],
  [15, 'P'],
  [12, 'T'],
  [9, 'G'],
  [6, 'M'],
  [3, 'k'],
  [0, ''],
  [-3, 'm'],
  [-6, 'μ'],
  [-9, 'n'],
  [-12, 'p'],
  [-15, 'f'],
  [-18, 'a'],
  [-21, 'z'],
  [-24, 'y'],
]);

/**
 * Generic `toHuman` function used by both NEAR and Gas.
 *
 * @param x BN to convert to human-readable format
 * @param baseUnit String like 'N' or 'gas' that will be added to the end of the returned string
 * @param magnitude How many numbers go after the decimal point for "one" of these things (for NEAR this is 24; for gas it's 0)
 * @param adjustMagnitude DO NOT USE! Only used internally by this function when it calls itself recursively.
 * @returns human-readable representation of `x`
 */
export function toHuman(
  x: BN,
  baseUnit: string,
  magnitude: number,
  adjustMagnitude = 0
): string {
  const numberOfDigits = x.toString().length;
  const adjustment = numberOfDigits > magnitude ? 0 : Math.ceil((magnitude - numberOfDigits + 1) / 3) * 3;
  const nomination = new BN(10).pow(new BN(magnitude - adjustment));
  const quotient = x.div(nomination);
  const remainder = x.mod(nomination);

  // Format the part before the decimal in en-US format (like "1,000");
  const integer = new Intl.NumberFormat("en-US").format(
    BigInt(quotient.toString(10))
  );

  // Leave the part after the decimal as-is (like ".00100200003")
  const fraction = remainder.eq(new BN(0))
    ? ""
    : `.${remainder
        .toString(10)
        .padStart(magnitude - adjustment, "0")
        .replace(/0+$\b/, "")}`;

  const prefix = magnitudeToPrefix.get(adjustMagnitude - adjustment)!;
  return `${integer}${fraction} ${prefix}${baseUnit}`;
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    /* Basic Options */
    "incremental": true, /* Enable incremental compilation */
    "target": "ES2019", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */
    "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */
    "lib": [
      "es2020",
      "ESNext"
    ], /* Specify library files to be included in the compilation. */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    "declaration": true, /* Generates corresponding '.d.ts' file. */
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    "sourceMap": true, /* Generates corresponding '.map' file. */
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    "outDir": "./dist", /* Redirect output structure to the directory. */
    // "rootDir": "./",                          /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                     /* Enable project compilation */
    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */
    // "removeComments": true,                /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
    /* Strict Type-Checking Options */
    "strict": true, /* Enable all strict type-checking options. */
    "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true, /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */
    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */
    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    "typeRoots": [ /* List of folders to include type definitions from. */
      "node_modules/@types"
    ],
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
  },
  "include": [
    "src/*.ts",
    "src/**/*.ts"
  ]
}
'''