*GitHub Repository "everstake/NEAR-Stake-Pool-Smart-Contract"*

'''--- Cargo.toml ---
[package]
name = "stake_pool"
version = "0.0.1"
authors = ["/"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]
path = "./source/lib.rs"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-contract-standards = { version = "4.0.0", default-features = false }
near-sdk = { version = "4.0.0", default-features = false }
uint = { version = "0.9.3", default-features = false }
'''
'''--- README.md ---
# Stake pool contract

This contract provides a way for other users to delegate funds to a pool of validation nodes.

There are some different roles:
- The staking pool contract. An account with the contract that staking pools funds.
- The staking pool is owned by the `owner` and the `owner` is the general manager of the staking pool.
- The pool `manager` manages the pool. The `manager` is assigned by the `owner` of the staking pool and can be changed anytime.
- Delegator accounts - accounts that want to stake their funds with the staking pool.
- Delegator accounts can become an `investor`.

## Reward distribution

The reward is distributed by increasing the exchange rate of the pool's native token at the beginning of each epoch.

Every epoch validators bring rewards to the pool. So, at the beginning of each epoch, the pool synchronizes and updates the information about the native tokens under management from all validators and calculates a new exchange rate for the native token.

## Stake pool contract guarantees and invariants

This staking pool implementation guarantees the required properties of the staking pool standard:

- The contract can't lose or lock tokens of users.
- If a user deposited X, the user should be able to withdraw at least X.
- If a user successfully staked X, the user can unstake at least X.
- The contract should not lock unstaked funds for longer than 8 epochs after delayed withdraw action.

It also has inner invariants:

- The price of staking pool tokens is always at least `1`.
- The price of staking pool tokens never decreases.
- The comission is a fraction be from `0` to `1` inclusive.
- The owner can't withdraw funds from other delegators.

## Implementation details

The owner can set up such contract with different parameters and start receiving users native tokens.
Any other user can send their native tokens to the contract and increase the total stake distributed on validators and receive staking pool fungible tokens.
These users are rewarded by increasing the rate of the staking pool tokens they received, but the contract has the right to charge a commission.
Then users can withdraw their native tokens after some unlocking period by exchanging staking pool tokens.

The price of a staking pool token defined as the total amount of staked native tokens divided by the total amount of staking pool token.
The number of staking pool token is always less than the number of the staked native tokens, so the price of single staking pool token is not less than `1`.

## Existing `call` methods:
- `new`

Available for pool owner.

Initializes staking pool state.

```rust
#[init]
pub fn new(
    fungible_token_metadata: FungibleTokenMetadataDto,
    manager_id: Option<AccountId>,
    self_fee_receiver_account_id: AccountId,
    partner_fee_receiver_account_id: AccountId,
    reward_fee_self: Option<Fee>,
    reward_fee_partner: Option<Fee>,
    instant_withdraw_fee_self: Option<Fee>,
    instant_withdraw_fee_partner: Option<Fee>
) -> Self
```

near deploy --wasmFile ./target/wasm32-unknown-unknown/release/stake_pool.wasm --accountId=pool.testnet --initDeposit=1 --initArgs='{"fungible_token_metadata": {"name": "NAME", "symbol": "SYMBOL", "icon": "ICON", "reference": null, "reference_hash": null, "decimals": 24}, "manager_id": "account0.testnet", "self_fee_receiver_account_id": "account1.testnet", "partner_fee_receiver_account_id": "account2.testnet", "reward_fee_self": {"numerator": 1, "denominator": 100}, "reward_fee_partner": {"numerator": 1, "denominator": 100}, "instant_withdraw_fee_self": {"numerator": 3, "denominator":1000}, "instant_withdraw_fee_partner": {"numerator": 1, "denominator": 5}}'

- `deposit`

Available for all users.

The delegator makes a deposit of funds, and receiving pool tokens in return.
When a delegator account first deposits funds to the contract, the internal account is created and credited with the
`near_amount` native tokens. The attached deposit must be greater than `near_amount` to hide the storage staking,
with the excess fund being refunded.

```rust
#[payable]
pub fn deposit(&mut self, near_amount: U128) -> PromiseOrValue<()>
```
near call pool.testnet deposit '{"near_amount": "10000000000000000000000000"}' --deposit=2 --accountId=account3.testnet --gas=300000000000000

- `deposit_on_validator`

Available for investors.

The delegator makes a deposit of funds via pool directly to validator, and receiving pool tokens in return.
When a delegator account first deposits funds to the contract, the internal account is created and credited with the
`near_amount` native tokens. The attached deposit must be greater than `near_amount` to hide the storage staking,
with the excess fund being refunded.

```rust
#[payable]
pub fn deposit_on_validator(&mut self, near_amount: U128, validator_account_id: AccountId) -> Promise
```
near call pool.testnet deposit_on_validator '{"near_amount": "1000000000000000000000000", "validator_account_id": "legends.pool.f863973.m0"}' --accountId=account3.testnet --deposit=2 --gas=300000000000000

- `instant_withdraw`

Available for all users.

The delegator makes an instant unstake by exchanging the pool tokens he has for native tokens. Native tokens are returned
to the delegator immediately, so there may be a commission for this action.

```rust
#[payable]
pub fn instant_withdraw(&mut self, token_amount: U128) -> Promise
```
near call pool.testnet instant_withdraw '{"token_amount":"1000000000000000000000000"}' --accountId=account3.testnet --deposit=1 --gas=300000000000000

- `delayed_withdraw`

Available for all users.

The delegator makes an unstake by exchanging the pool tokens he has for native tokens. Native tokens can be returned
to the delegator only after 8 epochs.

```rust
#[payable]
pub fn delayed_withdraw(&mut self, token_amount: U128) -> PromiseOrValue<()>
```
near call pool.testnet delayed_withdraw '{"token_amount": "1000000000000000000000000"}' --accountId=account3.testnet --deposit=1 --gas=300000000000000

- `delayed_withdraw_from_validator`

Available for investors.

The delegator makes an unstake via pool directly from validator by exchanging the pool tokens he has for native tokens. Native tokens can be returned
to the delegator only after 8 epochs.

```rust
#[payable]
pub fn delayed_withdraw_from_validator(&mut self, near_amount: U128, validator_account_id: AccountId) -> PromiseOrValue<()>
```
near call pool.testnet delayed_withdraw_from_validator '{"near_amount": "1000000000000000000000000", "validator_account_id": "legends.pool.f863973.m0"}' --accountId=account3.testnet --deposit=1 --gas=300000000000000

- `take_delayed_withdrawal`

Available for all users.

The delegator takes Native tokens he requested after passing the delayed unstake process.

```rust
#[payable]
pub fn take_delayed_withdrawal(&mut self) -> Promise
```
near call pool.testnet take_delayed_withdrawal --accountId=account3.testnet --deposit=1 --gas=300000000000000

- `increase_validator_stake`

Available for pool manager.

Stakes unstaked funds to the validator.

```rust
pub fn increase_validator_stake(&mut self, validator_account_id: AccountId, near_amount: U128) -> Promise
```
near call pool.testnet increase_validator_stake '{"validator_account_id":"legends.pool.f863973.m0", "near_amount":"1000000000000000000000000"}' --accountId=account0.testnet --gas=300000000000000

- `requested_decrease_validator_stake`

Available for pool manager.

Unstakes staked funds from validator.

```rust
pub fn requested_decrease_validator_stake(
    &mut self,
    validator_account_id: AccountId,
    near_amount: U128,
    stake_decreasing_type: StakeDecreasingType
) -> Promise
```
near call pool.testnet requested_decrease_validator_stake '{"validator_account_id":"legends.pool.f863973.m0", "near_amount":"500000000000000000000000", "stake_decreasing_type":"Classic"}' --accountId=account0.testnet --gas=300000000000000

- `take_unstaked_balance`

Available for pool manager.

Takes requested to withdraw balance from validator.

```rust
pub fn take_unstaked_balance(&mut self, validator_account_id: AccountId) -> Promise
```
near call pool.testnet take_unstaked_balance '{"validator_account_id":"legends.pool.f863973.m0"}' --accountId=account0.testnet --gas=300000000000000

- `update_validator`

Available for pool manager.

Updates validator state.

```rust
pub fn update_validator(&mut self, validator_account_id: AccountId) -> Promise
```
near call pool.testnet update_validator '{"validator_account_id":"legends.pool.f863973.m0"}' --accountId=account0.testnet --gas=300000000000000

- `update`

Available for pool manager.

Updates pool state.

```rust
pub fn update(&mut self)
```
near call pool.testnet update --accountId=account0.testnet --gas=300000000000000

- `add_validator`

Available for pool manager.

Adds the validator to the list of validators to which the pool delegates the available native tokens.

```rust
pub fn add_validator(
    &mut self,
    validator_account_id: AccountId,
    staking_contract_version: StakingContractVersion,
    is_only_for_investment: bool,
    is_preferred: bool
) -> PromiseOrValue<()>
```
near call pool.testnet add_validator '{"validator_account_id":"legends.pool.f863973.m0","staking_contract_version":"Core", "is_only_for_investment": false, "is_preferred": true}' --accountId=account0.testnet --deposit=1 --gas=300000000000000

- `change_validator_investment_context`

Available for pool manager.

Changes validator state in context of investment flow.

```rust
pub fn change_validator_investment_context(&mut self, validator_account_id: AccountId, is_only_for_investment: bool)
```
near call pool.testnet change_validator_investment_context '{"validator_account_id":"legends.pool.f863973.m0", "is_only_for_investment": false}' --accountId=account0.testnet --gas=300000000000000

- `change_preffered_validator`

Available for pool manager.

Changes preffered validator.

```rust
pub fn change_preffered_validator(&mut self, validator_account_id: Option<AccountId>)
```
near call pool.testnet change_preffered_validator '{"validator_account_id":"legends.pool.f863973.m0", "is_only_for_investment": false}' --accountId=account0.testnet --gas=300000000000000

- `remove_validator`

Available for pool manager.

Removes the validator from the list of validators to which the pool delegates the available native tokens.

```rust
pub fn remove_validator(&mut self, validator_account_id: AccountId) -> Promise
```
near call pool.testnet remove_validator '{"validator_account_id":"legends.pool.f863973.m0"}' --accountId=account0.testnet --gas=300000000000000

- `add_investor`

Available for pool manager.

Adds the user to the list of investors.

```rust
#[payable]
pub fn add_investor(&mut self, investor_account_id: AccountId) -> PromiseOrValue<()>
```
near call pool.testnet add_investor '{"investor_account_id":"account4.testnet"}' --accountId=account0.testnet --deposit=1 --gas=300000000000000

- `remove_investor`

Available for pool manager.

Remove the user from the list of investors.

```rust
pub fn remove_investor(&mut self, investor_account_id: AccountId) -> Promise
```
near call pool.testnet remove_investor '{"investor_account_id":"account4.testnet"}' --accountId=account0.testnet --deposit=1 --gas=300000000000000

- `change_manager`

Available for pool owner and manager.

Changes pool manager.

```rust
pub fn change_manager(&mut self, manager_id: AccountId)
```
near call pool.testnet change_manager '{"manager_id":"account5.testnet"}' --accountId=account0.testnet --gas=300000000000000

- `change_reward_fee`

Available for pool manager.

Changes fee for validators rewards.

```rust
pub fn change_reward_fee(&mut self, reward_fee_self: Option<Fee>, reward_fee_partner: Option<Fee>)
```
near call pool.testnet change_reward_fee '{"reward_fee_self": {"numerator": 1, "denominator": 100}, "reward_fee_partner": {"numerator": 1, "denominator": 100}}' --accountId=account0.testnet --gas=300000000000000

- `change_instant_withdraw_fee`

Available for pool manager.

Changes fee for instant unstake process.

```rust
pub fn change_instant_withdraw_fee(&mut self, instant_withdraw_fee_self: Option<Fee>, instant_withdraw_fee_partner: Option<Fee>)
```
near call pool.testnet change_instant_withdraw_fee '{"instant_withdraw_fee_self": {"numerator": 1, "denominator": 100}, "instant_withdraw_fee_partner": {"numerator": 1, "denominator": 100}}' --accountId=account0.testnet --gas=300000000000000

- `confirm_stake_distribution`

Available for pool manager.

Confirms stake distributions.

```rust
pub fn confirm_stake_distribution(&mut self)
```
near call pool.testnet confirm_stake_distribution --accountId=account0.testnet --gas=300000000000000

## Existing `view` methods:
```rust
pub fn get_delayed_withdrawal_details(&self, account_id: AccountId) -> Option<DelayedWithdrawalDetails>
```
near view pool.testnet get_delayed_withdrawal_details '{"account_id": "account6.testnet"}'

```rust
pub fn get_account_balance(&self, account_id: AccountId) -> AccountBalanceDto
```
near view pool.testnet get_account_balance '{"account_id": "account6.testnet"}'

```rust
pub fn get_total_token_supply(&self) -> U128
```
near view pool.testnet get_total_token_supply

```rust
pub fn get_minimum_deposit_amount(&self) -> U128
```
near view pool.testnet get_minimum_deposit_amount

```rust
pub fn get_storage_staking_price(&self) -> StorageStakingPrice
```
near view pool.testnet get_storage_staking_price

```rust
pub fn get_storage_staking_requested_coverage(&self, account_id: AccountId) -> StorageStakingRequestedCoverage
```
near view pool.testnet get_storage_staking_requested_coverage '{"account_id": "account6.testnet"}'

```rust
pub fn get_fund(&self) -> FundDto
```
near view pool.testnet get_fund

```rust
pub fn get_fee_registry(&self) -> FeeRegistry
```
near view pool.testnet get_fee_registry

```rust
pub fn get_fee_registry_light(&self) -> FeeRegistryLight
```
near view pool.testnet get_fee_registry_light

```rust
pub fn get_current_epoch_height(&self) -> EpochHeightRegistry
```
near view pool.testnet get_current_epoch_height

```rust
pub fn is_stake_distributed(&self) -> bool
```
near view pool.testent is_stake_distributed

```rust
pub fn get_investor_investment(&self, account_id: AccountId) -> Option<InvestorInvestmentDto>
```
near view pool.testnet get_investor_investment '{"account_id": "account6.testnet"}'

```rust
pub fn get_validator_registry(&self) -> Vec<ValidatorDto>
```
near view pool.testnet get_validator_registry

```rust
pub fn get_preffered_validator(&self) -> Option<ValidatorDto>
```
near view pool.testnet get_preffered_validator

```rust
pub fn get_aggregated(&self) -> Aggregated
```
near view pool.testnet get_aggregated

```rust
pub fn get_requested_to_withdrawal_fund(&self) -> RequestedToWithdrawalFund
```
near view pool.testnet get_requested_to_withdrawal_fund

```rust
pub fn get_full(&self) -> Full
```
near view pool.testnet get_full

```rust
pub fn get_full_for_account(&self, account_id: AccountId) -> FullForAccount
```
near view pool.testnet get_full for account '{"account_id": "account6.testnet"}'
'''
'''--- source/account_balance.rs ---
use near_sdk::Balance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountBalance {
    pub token_amount: Balance,
    /// Amount of classic Near that remained as a result of the conversion at the exchange rate.
    pub classic_near_amount: Balance,
    /// Amount of investment Near that remained as a result of the conversion at the exchange rate.
    pub investment_near_amount: Balance
}
'''
'''--- source/account_registry.rs ---
use near_sdk::AccountId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountRegistry {
    pub owner_id: AccountId,
    pub manager_id: AccountId,
    /// Id of account, that will receive 'self_fee'.
    pub self_fee_receiver_account_id: AccountId,
    /// Id of account, that will receive 'partner_fee'.
    pub partner_fee_receiver_account_id: AccountId
}
'''
'''--- source/cross_contract_call/classic_validator.rs ---
use near_sdk::{ext_contract, AccountId};
use near_sdk::json_types::U128;

/// Default Near `staking pool` contract interface.
#[ext_contract(classic_validator)]
pub trait ClassicValidator {
    // #[payable]
    fn deposit(&mut self);

    // #[payable]
    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128);

    fn withdraw_all(&mut self);

    fn stake(&mut self, amount: U128);

    fn unstake(&mut self, amount: U128);

    fn unstake_all(&mut self);

    fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128;
}
'''
'''--- source/cross_contract_call/mod.rs ---
pub(crate) mod classic_validator;
'''
'''--- source/data_transfer_object/account_balance.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use super::base_account_balance::BaseAccountBalance;
use super::investment_account_balance::InvestmentAccountBalance;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountBalance {
    pub base_account_balance: Option<BaseAccountBalance>,
    pub investment_account_balance: Option<InvestmentAccountBalance>
}
'''
'''--- source/data_transfer_object/aggregated.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use crate::fee::Fee;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Aggregated {
    /// Near amount required for distribution on validators.
    pub unstaked_balance: U128,
    /// Near amount already distributed on validators.
    pub staked_balance: U128,
    /// Minted amount of token.
    pub token_total_supply: U128,
    /// Stakers quantity.
    pub token_accounts_quantity: u64,
    /// Near amount of rewards from validators.
    pub total_rewards_from_validators_near_amount: U128,
    /// Fee charged by the pool when receiving rewards from validators.
    pub reward_fee: Option<Fee>
}
'''
'''--- source/data_transfer_object/base_account_balance.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct BaseAccountBalance {
    pub token_balance: U128,
    pub common_near_balance: U128,
    pub classic_near_balance: U128,
    pub classic_near_balance_token_coverage: U128
}
'''
'''--- source/data_transfer_object/callback_result.rs ---
use near_sdk::EpochHeight;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CallbackResult {
    pub is_success: bool,
    pub network_epoch_height: EpochHeight
}
'''
'''--- source/data_transfer_object/delayed_withdrawal_details.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct DelayedWithdrawalDetails {
    pub epoch_quantity_to_take_delayed_withdrawal: u64,
    pub near_amount: U128
}
'''
'''--- source/data_transfer_object/epoch_height_registry.rs ---
use near_sdk::EpochHeight;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EpochHeightRegistry {
    pub pool_epoch_height: EpochHeight,
    pub network_epoch_height: EpochHeight
}
'''
'''--- source/data_transfer_object/fee_registry_light.rs ---
use crate::fee::Fee;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FeeRegistryLight {
    pub reward_fee: Option<Fee>,
    pub instant_withdraw_fee: Option<Fee>
}
'''
'''--- source/data_transfer_object/full.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use super::fee_registry_light::FeeRegistryLight;
use super::fund::Fund;
use super::requested_to_withdrawal_fund::RequestedToWithdrawalFund;
use super::storage_staking_price::StorageStakingPrice;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Full {
    pub storage_staking_price: StorageStakingPrice,
    pub fund: Fund,
    pub total_token_supply: U128,
    pub requested_to_withdrawal_fund: RequestedToWithdrawalFund,
    pub fee_registry_light: FeeRegistryLight,
    pub minimum_deposit_amount: U128
}
'''
'''--- source/data_transfer_object/full_for_account.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use super::account_balance::AccountBalance;
use super::delayed_withdrawal_details::DelayedWithdrawalDetails;
use super::full::Full;
use super::investor_investment::InvestorInvestment;
use super::storage_staking_requested_coverage::StorageStakingRequestedCoverage;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FullForAccount {
    pub full: Full,
    pub account_balance: AccountBalance,
    pub delayed_withdrawal_details: Option<DelayedWithdrawalDetails>,
    pub investor_investment: Option<InvestorInvestment>,
    pub storage_staking_requested_coverage: StorageStakingRequestedCoverage
}
'''
'''--- source/data_transfer_object/fund.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Fund {
    /// Near amount required for distribution on validators by pool.
    pub classic_unstaked_balance: U128,
    /// Near amount already distributed on validators by pool.
    pub classic_staked_balance: U128,
    /// Near amount already distributed on validators by investors.
    pub investment_staked_balance: U128,
    /// Near amount already distributed on validators by pool and investors.
    pub common_staked_balance: U128,
    /// Common management near amount.
    pub common_balance: U128
}
'''
'''--- source/data_transfer_object/fungible_token_metadata.rs ---
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
    pub decimals: u8,
}
'''
'''--- source/data_transfer_object/investment_account_balance.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct InvestmentAccountBalance {
    pub near_balance: U128,
    pub near_balance_token_coverage: U128
}
'''
'''--- source/data_transfer_object/investor_investment.rs ---
use near_sdk::AccountId;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct InvestorInvestment {
    pub distribution_registry: Vec<(AccountId, U128)>,
    pub staked_balance: U128
}
'''
'''--- source/data_transfer_object/mod.rs ---
pub(crate) mod account_balance;
pub(crate) mod aggregated;
pub(crate) mod base_account_balance;
pub(crate) mod callback_result;
pub(crate) mod delayed_withdrawal_details;
pub(crate) mod epoch_height_registry;
pub(crate) mod fee_registry_light;
pub(crate) mod full_for_account;
pub(crate) mod full;
pub(crate) mod fund;
pub(crate) mod fungible_token_metadata;
pub(crate) mod investment_account_balance;
pub(crate) mod investor_investment;
pub(crate) mod requested_to_withdrawal_fund;
pub(crate) mod storage_staking_price;
pub(crate) mod storage_staking_requested_coverage;
pub(crate) mod validator;
'''
'''--- source/data_transfer_object/requested_to_withdrawal_fund.rs ---
use near_sdk::AccountId;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RequestedToWithdrawalFund {
    pub classic_near_amount: U128,
    pub investment_near_amount: U128,
    pub investment_withdrawal_registry: Vec<(AccountId, U128)>
}
'''
'''--- source/data_transfer_object/storage_staking_price.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageStakingPrice {
    pub per_delayed_withdrawal_fund_delayed_withdrawal: U128,
    pub per_delayed_withdrawal_fund_investment_withdrawal: U128,
    pub per_fungible_token_account: U128,
    pub per_validating_node_validator: U128,
    pub per_validating_node_investor: U128,
    pub per_validating_node_distribution: U128
}
'''
'''--- source/data_transfer_object/storage_staking_requested_coverage.rs ---
use near_sdk::AccountId;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageStakingRequestedCoverage {
    pub per_method_deposit: U128,
    pub per_method_deposit_on_validator: Option<(U128, Vec<(AccountId, U128)>)>,
    pub per_method_delayed_withdraw: U128,
    pub per_method_delayed_withdraw_from_validator: Option<(U128, Vec<(AccountId, U128)>)>
}
'''
'''--- source/data_transfer_object/validator.rs ---
use near_sdk::{EpochHeight, AccountId};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Validator {
    pub account_id: AccountId,
    pub unstaked_balance: U128,
    pub classic_staked_balance: U128,
    pub investment_staked_balance: U128,
    pub is_only_for_investment: bool,
    pub last_update_epoch_height: EpochHeight,
    pub last_classic_stake_increasing_epoch_height: Option<EpochHeight>
}
'''
'''--- source/delayed_withdrawal.rs ---
use near_sdk::{EpochHeight, Balance, env};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use super::EPOCH_QUANTITY_FOR_DELAYED_WITHDRAWAL;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct DelayedWithdrawal {
    /// Near balance that the user requested to withdraw.
    pub near_amount: Balance,
    /// It is only needed in order to understand when it is possible to give
    /// the user his funds, because the funds can only be returned after EPOCH_QUANTITY_TO_DELAYED_WITHDRAWAL (8) epochs
    /// with delayed_withdraw method.
    pub started_epoch_height: EpochHeight
}

impl DelayedWithdrawal {
    pub fn get_epoch_quantity_to_take_delayed_withdrawal(&self, current_epoch_height: EpochHeight) -> u64 {
        if current_epoch_height < self.started_epoch_height {
            env::panic_str("Current epoch height must be greater or equal to started epoch height.");
        }
        let passed_epoch_height = current_epoch_height - self.started_epoch_height;

        if EPOCH_QUANTITY_FOR_DELAYED_WITHDRAWAL > passed_epoch_height {
            EPOCH_QUANTITY_FOR_DELAYED_WITHDRAWAL - passed_epoch_height
        } else {
            0
        }
    }

    pub fn can_take_delayed_withdrawal(&self, current_epoch_height: EpochHeight) -> bool {
        self.get_epoch_quantity_to_take_delayed_withdrawal(current_epoch_height) == 0
    }
}
'''
'''--- source/delayed_withdrawn_fund.rs ---
use near_sdk::{Balance, AccountId, env, StorageUsage};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use super::delayed_withdrawal::DelayedWithdrawal;
use super::get_account_id_with_maximum_length;
use super::investment_withdrawal::InvestmentWithdrawal;
use super::storage_key::StorageKey;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct DelayedWithdrawnFund {
    /// Storage.
    /// AccountId - user account id.
    pub delayed_withdrawal_registry: LookupMap<AccountId, DelayedWithdrawal>,
    /// Storage
    /// AccountId - validator account id.
    /// Balance - Near amount.
    pub investment_withdrawal_registry: LookupMap<AccountId, InvestmentWithdrawal>,
    /// Classic Near amount needed to request from the validator.
    pub needed_to_request_classic_near_amount: Balance,
    /// Investment Near amount needed to request from the validator.
    pub needed_to_request_investment_near_amount: Balance,
    /// Near balance available for withdrawal after passing the delayed withdrawal process.
    pub balance: Balance,
    /// In bytes.
    pub storage_usage_per_delayed_withdrawal: StorageUsage,
    /// In bytes.
    pub storage_usage_per_investment_withdrawal: StorageUsage
}

impl DelayedWithdrawnFund {
    pub fn new() -> Self {
        Self {
            delayed_withdrawal_registry: Self::initialize_delayed_withdrawal_registry(),
            investment_withdrawal_registry: Self::initialize_investment_withdrawal_registry(),
            needed_to_request_classic_near_amount: 0,
            needed_to_request_investment_near_amount: 0,
            balance: 0,
            storage_usage_per_delayed_withdrawal: Self::calculate_storage_usage_per_additional_delayed_withdrawal(),
            storage_usage_per_investment_withdrawal: Self::calculate_storage_usage_per_additional_investment_withdrawal()
        }
    }

    fn calculate_storage_usage_per_additional_delayed_withdrawal() -> StorageUsage {
        let mut delayed_withdrawal_registry = Self::initialize_delayed_withdrawal_registry();

        let initial_storage_usage = env::storage_usage();

        let account_id = get_account_id_with_maximum_length();

        delayed_withdrawal_registry.insert(
            &account_id,
            &DelayedWithdrawal {
                near_amount: 0,
                started_epoch_height: env::epoch_height()
            }
        );

        env::storage_usage() - initial_storage_usage
    }

    fn calculate_storage_usage_per_additional_investment_withdrawal() -> StorageUsage {
        let mut investment_withdrawal_registry = Self::initialize_investment_withdrawal_registry();

        let initial_storage_usage = env::storage_usage();

        let account_id = get_account_id_with_maximum_length();

        investment_withdrawal_registry.insert(
            &account_id,
            &InvestmentWithdrawal {
                near_amount: 0,
                account_id: account_id.clone()
            }
        );

        env::storage_usage() - initial_storage_usage
    }

    fn initialize_delayed_withdrawal_registry() -> LookupMap<AccountId, DelayedWithdrawal> {
        LookupMap::new(StorageKey::DelayedWithdrawnFund)
    }

    fn initialize_investment_withdrawal_registry() -> LookupMap<AccountId, InvestmentWithdrawal> {
        LookupMap::new(StorageKey::InvestmentWithdrawal)
    }
}
'''
'''--- source/fee.rs ---
use near_sdk::Balance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env;
use near_sdk::serde::{Deserialize, Serialize};
use std::clone::Clone;
use uint::construct_uint;

construct_uint! {
    pub struct U256(4);
}

#[derive(Clone, Debug, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Fee {
    pub numerator: u64,
    pub denominator: u64
}

impl Fee {
    pub fn assert_valid(&self) {
        if self.denominator == 0 || self.numerator == 0 || self.numerator >= self.denominator {
            env::panic_str("Fee is not valid.");
        }
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (
            U256::from(self.numerator) * U256::from(value)
            / U256::from(self.denominator)
        ).as_u128()
    }
}
'''
'''--- source/fee_registry.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::clone::Clone;
use super::shared_fee::SharedFee;

#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FeeRegistry {
    /// Fee that is taken from the rewards received on the validators.
    pub reward_fee: Option<SharedFee>,
    /// Fee that is taken from the Near amount on instant unstake process.
    pub instant_withdraw_fee: Option<SharedFee>
}
'''
'''--- source/fund.rs ---
use near_sdk::Balance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use super::delayed_withdrawn_fund::DelayedWithdrawnFund;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Fund {
    /// Near amount available in the pool that should be staked on validators in classic context.
    pub classic_unstaked_balance: Balance,
    /// Near amount already staked on validators in classic context.
    pub classic_staked_balance: Balance,
    /// Additional Near amount to ensure the possibility of instant withdrawal.
    pub classic_liquidity_balance: Balance,
    /// Near amount already staked on validators in investment context.
    pub investment_staked_balance: Balance,
    /// Fund that should be returned to users.
    pub delayed_withdrawn_fund: DelayedWithdrawnFund,
    pub is_distributed_on_validators_in_current_epoch: bool
}

impl Fund {
    pub fn new() -> Self {
        Self {
            classic_unstaked_balance: 0,
            classic_staked_balance: 0,
            classic_liquidity_balance: 0,
            investment_staked_balance: 0,
            delayed_withdrawn_fund: DelayedWithdrawnFund::new(),
            is_distributed_on_validators_in_current_epoch: false
        }
    }

    pub fn get_staked_balance(&self) -> Balance {
        self.classic_staked_balance + self.investment_staked_balance
    }

    pub fn get_common_balance(&self) -> Balance {
        self.classic_unstaked_balance + self.classic_staked_balance + self.investment_staked_balance
    }
}
'''
'''--- source/fungible_token.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::{env, AccountId, Balance, StorageUsage};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use super::account_balance::AccountBalance;
use super::get_account_id_with_maximum_length;
use super::storage_key::StorageKey;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct FungibleToken {
    pub total_supply: Balance,
    /// Storage.
    /// AccountId - user account id.
    pub account_registry: LookupMap<AccountId, AccountBalance>,
    pub accounts_quantity: u64,
    pub metadata: LazyOption<FungibleTokenMetadata>,
    /// In bytes.
    pub storage_usage_per_account: StorageUsage,
}

impl FungibleToken {
    pub fn new(fungible_token_metadata: FungibleTokenMetadata) -> Self {
        Self {
            total_supply: 0,
            account_registry: Self::initialize_account_registry(),
            accounts_quantity: 0,
            metadata: Self::initialize_metadata(&fungible_token_metadata),
            storage_usage_per_account: Self::calculate_storage_usage_per_additional_account()
        }
    }

    fn calculate_storage_usage_per_additional_account() -> StorageUsage {
        let mut account_registry = Self::initialize_account_registry();

        let initial_storage_usage = env::storage_usage();

        let account_id = get_account_id_with_maximum_length();

        account_registry.insert(
            &account_id,
            &AccountBalance {
                token_amount: 0,
                classic_near_amount: 0,
                investment_near_amount: 0
            }
        );

        env::storage_usage() - initial_storage_usage
    }

    fn initialize_account_registry() -> LookupMap<AccountId, AccountBalance> {
        LookupMap::new(StorageKey::FungibleToken)
    }

    fn initialize_metadata(fungible_token_metadata: &FungibleTokenMetadata) -> LazyOption<FungibleTokenMetadata> {
        LazyOption::new(StorageKey::FungibleTokenMetadata, Some(fungible_token_metadata))
    }
}
'''
'''--- source/investment_withdrawal.rs ---
use near_sdk::{AccountId, Balance};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct InvestmentWithdrawal {
    /// Near amount that the user requested to withdraw.
    pub near_amount: Balance,
    /// Id of account who spent funds on storage staking for this structure.
    pub account_id: AccountId
}
'''
'''--- source/investor_investment.rs ---
use near_sdk::{Balance, AccountId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use super::storage_key::StorageKey;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct InvestorInvestment {
    /// Storage
    /// AccountId - validator account id.
    /// Balance - staked Near Amount.
    pub distribution_registry: LookupMap<AccountId, Balance>,
    pub distributions_quantity: u64,
    /// Total Near amount distributed on validators.
    pub staked_balance: Balance
}

impl InvestorInvestment {
    pub fn new(investor_account_id: AccountId) -> Self {
        Self {
            distribution_registry: Self::initialize_distribution_registry(investor_account_id),
            distributions_quantity: 0,
            staked_balance: 0
        }
    }

    pub fn initialize_distribution_registry(investor_account_id: AccountId) -> LookupMap<AccountId, Balance> {
        LookupMap::new(StorageKey::Distribution { investor_account_id })
    }
}
'''
'''--- source/lib.rs ---
use near_sdk::ONE_NEAR;
use near_sdk::{AccountId, Balance};

pub mod stake_pool;
mod account_balance;
mod account_registry;
mod cross_contract_call;
mod data_transfer_object;
mod delayed_withdrawal;
mod delayed_withdrawn_fund;
mod fee_registry;
mod fee;
mod fund;
mod fungible_token;
mod investment_withdrawal;
mod investor_investment;
mod reward;
mod shared_fee;
mod stake_decreasing_kind;
mod staking_contract_version;
mod storage_key;
mod validating;
mod validator_balance;
mod validator;

/// Quantity of epochs after passing which it is possible to withdraw fund.
const EPOCH_QUANTITY_FOR_DELAYED_WITHDRAWAL: u64 = 8;
/// Quantity of epochs after passing which it is possible to request unstake from validator.
const EPOCH_QUANTITY_FOR_VALIDATOR_UNSTAKE: u64 = 4;
/// Minimum Gas amount for common transaction.
const MINIMUM_NUMBER_OF_TGAS: u64 = 300;
/// The minimum Near amount that must be attached to a transaction.
const MINIMUN_DEPOSIT_AMOUNT: Balance = ONE_NEAR;
/// Maximum number of characters in account name, it is needed for storage staking calculating.
const MAXIMUM_NUMBER_OF_CHARACTERS_IN_ACCOUNT_NAME: usize = 64;

fn get_account_id_with_maximum_length() -> AccountId {
    AccountId::new_unchecked("a".repeat(MAXIMUM_NUMBER_OF_CHARACTERS_IN_ACCOUNT_NAME))
}
'''
'''--- source/reward.rs ---
use near_sdk::Balance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Reward {
    // Near amount received from validators as rewards in previous epoch.
    pub previous_epoch_rewards_from_validators_near_amount: Balance,
    /// Total Near amount received from validators as rewards.
    pub total_rewards_from_validators_near_amount: Balance
}
'''
'''--- source/shared_fee.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::clone::Clone;
use super::fee::Fee;

#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SharedFee {
    /// Fee taken from object.
    pub self_fee: Fee,
    /// Fee taken from 'self_fee".
    pub partner_fee: Option<Fee>
}
'''
'''--- source/stake_decreasing_kind.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum StakeDecreasingType {
    /// For classic context.
    Classic,
    /// For investment context.
    Investment
}
'''
'''--- source/stake_pool.rs ---
use core::convert::Into;
use near_contract_standards::fungible_token::core::FungibleTokenCore;
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_sdk::{env, near_bindgen, PanicOnDefault, AccountId, Balance, EpochHeight, Promise, PromiseResult, StorageUsage, Gas, PromiseOrValue};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use super::account_balance::AccountBalance;
use super::account_registry::AccountRegistry;
use super::cross_contract_call::classic_validator::classic_validator;
use super::data_transfer_object::account_balance::AccountBalance as AccountBalanceDto;
use super::data_transfer_object::aggregated::Aggregated;
use super::data_transfer_object::base_account_balance::BaseAccountBalance;
use super::data_transfer_object::callback_result::CallbackResult;
use super::data_transfer_object::delayed_withdrawal_details::DelayedWithdrawalDetails;
use super::data_transfer_object::epoch_height_registry::EpochHeightRegistry;
use super::data_transfer_object::fee_registry_light::FeeRegistryLight;
use super::data_transfer_object::full_for_account::FullForAccount;
use super::data_transfer_object::full::Full;
use super::data_transfer_object::fund::Fund as FundDto;
use super::data_transfer_object::fungible_token_metadata::FungibleTokenMetadata as FungibleTokenMetadataDto;
use super::data_transfer_object::investment_account_balance::InvestmentAccountBalance;
use super::data_transfer_object::investor_investment::InvestorInvestment as InvestorInvestmentDto;
use super::data_transfer_object::requested_to_withdrawal_fund::RequestedToWithdrawalFund;
use super::data_transfer_object::storage_staking_price::StorageStakingPrice;
use super::data_transfer_object::storage_staking_requested_coverage::StorageStakingRequestedCoverage;
use super::data_transfer_object::validator::Validator as ValidatorDto;
use super::delayed_withdrawal::DelayedWithdrawal;
use super::EPOCH_QUANTITY_FOR_VALIDATOR_UNSTAKE;
use super::fee_registry::FeeRegistry;
use super::fee::Fee;
use super::fund::Fund;
use super::fungible_token::FungibleToken;
use super::investment_withdrawal::InvestmentWithdrawal;
use super::investor_investment::InvestorInvestment;
use super::MINIMUM_NUMBER_OF_TGAS;
use super::MINIMUN_DEPOSIT_AMOUNT;
use super::reward::Reward;
use super::shared_fee::SharedFee;
use super::stake_decreasing_kind::StakeDecreasingType;
use super::staking_contract_version::StakingContractVersion;
use super::validating::Validating;
use super::validator::Validator;
use uint::construct_uint;

construct_uint! {
    pub struct U256(4);
}

/// Classic context - flow for all users. Investment context - flow for investors.
/// Investor has classic and investment flow. Random user has only classic flow.
#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct StakePool {
    account_registry: AccountRegistry,
    fungible_token: FungibleToken,
    fund: Fund,
    fee_registry: FeeRegistry,
    validating: Validating,
    current_epoch_height: EpochHeight,
    reward: Reward
}

#[near_bindgen]
impl StakePool {
    /// Call-methods:

    /// Provides the ability to pool initialization.
    /// Available for pool owner.
    #[init]
    #[payable]
    pub fn new(
        fungible_token_metadata: FungibleTokenMetadataDto,
        manager_id: Option<AccountId>,
        self_fee_receiver_account_id: AccountId,
        partner_fee_receiver_account_id: AccountId,
        reward_fee_self: Option<Fee>,
        reward_fee_partner: Option<Fee>,
        instant_withdraw_fee_self: Option<Fee>,
        instant_withdraw_fee_partner: Option<Fee>
    ) -> Self {
        Self::internal_new(
            fungible_token_metadata,
            manager_id,
            self_fee_receiver_account_id,
            partner_fee_receiver_account_id,
            reward_fee_self,
            reward_fee_partner,
            instant_withdraw_fee_self,
            instant_withdraw_fee_partner
        )
    }

    /// Provides the ability to stake into pool.
    /// Available for all users.
    #[payable]
    pub fn deposit(&mut self, near_amount: U128) -> PromiseOrValue<()> {
        self.internal_deposit(near_amount.into())
    }

    /// Provides the ability to stake via pool directly to the validator.
    /// Available only for investor.
    #[payable]
    pub fn deposit_on_validator(&mut self, near_amount: U128, validator_account_id: AccountId) -> Promise {
        self.internal_deposit_on_validator(near_amount.into(), validator_account_id)
    }

    /// Provides the ability to instant unstake.
    /// Available for all users.
    #[payable]
    pub fn instant_withdraw(&mut self, token_amount: U128) -> Promise {
        self.internal_instant_withdraw(token_amount.into())
    }

    /// Provides the ability to delayed unstake.
    /// Available for all users.
    #[payable]
    pub fn delayed_withdraw(&mut self, token_amount: U128) -> PromiseOrValue<()> {
        self.internal_delayed_withdraw(token_amount.into())
    }

    /// Delayed unstake process directly from validator.
    /// Available only for investor.
    #[payable]
    pub fn delayed_withdraw_from_validator(&mut self, near_amount: U128, validator_account_id: AccountId) -> PromiseOrValue<()> {
        self.internal_delayed_withdraw_from_validator(near_amount.into(), validator_account_id)
    }

    /// Provides the ability to take unstaked balance after passing the delayed unstake process.
    /// Available for all users.
    #[payable]
    pub fn take_delayed_withdrawal(&mut self) -> Promise {
        self.internal_take_delayed_withdrawal()
    }

    /// Provides the ability to stake via pool directly to the validator.
    /// Available only for pool manager.
    pub fn increase_validator_stake(&mut self, validator_account_id: AccountId, near_amount: U128) -> Promise {
        self.internal_increase_validator_stake(validator_account_id, near_amount.into())
    }

    /// Provides the ability to unstake from validator for the needs of delayed withdrawal fund.
    /// Available only for pool manager.
    pub fn requested_decrease_validator_stake(
        &mut self,
        validator_account_id: AccountId,
        near_amount: U128,
        stake_decreasing_type: StakeDecreasingType
    ) -> Promise {
        self.internal_requested_decrease_validator_stake(validator_account_id, near_amount.into(), stake_decreasing_type)
    }

    /// Provides the ability to withdraw unstaked balance from validator for the needs of delayed withdrawal fund.
    /// Available only for pool manager.
    pub fn take_unstaked_balance(&mut self, validator_account_id: AccountId) -> Promise {
        self.internal_take_unstaked_balance(validator_account_id)
    }

    /// Provides the ability to update validator state.
    /// Available only for pool manager.
    pub fn update_validator(&mut self, validator_account_id: AccountId) -> Promise {
        self.internal_update_validator(validator_account_id)
    }

    /// Provides the ability to update pool state. Must be used after 'updated_validator'
    /// for each validator.
    /// Available only for pool manager.
    pub fn update(&mut self) {
        self.internal_update();
    }

    /// Provides the ability to add validator.
    /// Available only for pool manager.
    #[payable]
    pub fn add_validator(
        &mut self,
        validator_account_id: AccountId,
        staking_contract_version: StakingContractVersion,
        is_only_for_investment: bool,
        is_preferred: bool
    ) -> PromiseOrValue<()> {
        self.internal_add_validator(validator_account_id, staking_contract_version, is_only_for_investment, is_preferred)
    }

    /// Provides the ability to change validator state in context of in investment.
    /// Available only for pool manager.
    pub fn change_validator_investment_context(&mut self, validator_account_id: AccountId, is_only_for_investment: bool) {
        self.internal_change_validator_investment_context(validator_account_id, is_only_for_investment);
    }

    /// Provides the ability to change preffered validator.
    /// Available only for pool manager.
    pub fn change_preffered_validator(&mut self, validator_account_id: Option<AccountId>) {
        self.internal_change_preffered_validator(validator_account_id);
    }

    /// Provides the ability to remove validator.
    /// Available only for pool manager.
    pub fn remove_validator(&mut self, validator_account_id: AccountId) -> Promise {
        self.internal_remove_validator(validator_account_id)
    }

    /// Provides the ability to add investor.
    /// Available only for pool manager.
    #[payable]
    pub fn add_investor(&mut self, investor_account_id: AccountId) -> PromiseOrValue<()> {
        self.internal_add_investor(investor_account_id)
    }

    /// Provides the ability to add investor.
    /// Available only for pool manager.
    pub fn remove_investor(&mut self, investor_account_id: AccountId) -> Promise {
        self.internal_remove_investor(investor_account_id)
    }

    /// Provides the ability to change pool manager.
    /// Available only for pool owner and manager.
    pub fn change_manager(&mut self, manager_id: AccountId) {
        self.internal_change_manager(manager_id);
    }

    /// Provides the ability to change reward fee.
    /// Available only for pool manager.
    pub fn change_reward_fee(&mut self, reward_fee_self: Option<Fee>, reward_fee_partner: Option<Fee>) {
        self.internal_change_reward_fee(reward_fee_self, reward_fee_partner);
    }

    /// Provides the ability to change fee for instant unstake process.
    /// Available only for pool manager.
    pub fn change_instant_withdraw_fee(&mut self, instant_withdraw_fee_self: Option<Fee>, instant_withdraw_fee_partner: Option<Fee>) {
        self.internal_change_instant_withdraw_fee(instant_withdraw_fee_self, instant_withdraw_fee_partner);
    }

    /// Provides the ability to change state of fund.
    /// Available only for pool manager.
    pub fn confirm_stake_distribution(&mut self) {
        self.internal_confirm_stake_distribution();
    }

    /// View-methods:

    pub fn get_delayed_withdrawal_details(&self, account_id: AccountId) -> Option<DelayedWithdrawalDetails> {
        self.internal_get_delayed_withdrawal_details(account_id)
    }

    pub fn get_account_balance(&self, account_id: AccountId) -> AccountBalanceDto {
        self.internal_get_account_balance(account_id)
    }

    pub fn get_total_token_supply(&self) -> U128 {
        self.internal_get_total_token_supply().into()
    }

    pub fn get_minimum_deposit_amount(&self) -> U128 {
        self.internal_get_minimum_deposit_amount().into()
    }

    pub fn get_storage_staking_price(&self) -> StorageStakingPrice {
        self.internal_get_storage_staking_price()
    }

    pub fn get_storage_staking_requested_coverage(&self, account_id: AccountId) -> StorageStakingRequestedCoverage {
        self.internal_get_storage_staking_requested_coverage(account_id)
    }

    pub fn get_fund(&self) -> FundDto {
        self.internal_get_fund()
    }

    pub fn get_fee_registry(&self) -> FeeRegistry {
        self.internal_get_fee_registry()
    }

    pub fn get_fee_registry_light(&self) -> FeeRegistryLight {
        self.internal_get_fee_registry_light()
    }

    pub fn get_current_epoch_height(&self) -> EpochHeightRegistry {
        self.internal_get_current_epoch_height()
    }

    pub fn is_stake_distributed(&self) -> bool {
        self.internal_is_stake_distributed()
    }

    pub fn get_investor_investment(&self, account_id: AccountId) -> Option<InvestorInvestmentDto> {
        self.internal_get_investor_investment(account_id)
    }

    pub fn get_validator_registry(&self) -> Vec<ValidatorDto> {
        self.internal_get_validator_registry()
    }

    pub fn get_preffered_validator(&self) -> Option<ValidatorDto> {
        self.internal_get_preffered_validator()
    }

    pub fn get_aggregated(&self) -> Aggregated {
        self.internal_get_aggregated()
    }

    pub fn get_requested_to_withdrawal_fund(&self) -> RequestedToWithdrawalFund {
        self.internal_get_requested_to_withdrawal_fund()
    }

    pub fn get_full(&self) -> Full {
        self.internal_get_full()
    }

    pub fn get_full_for_account(&self, account_id: AccountId) -> FullForAccount {
        self.internal_get_full_for_account(account_id)
    }
}

#[near_bindgen]
impl FungibleTokenCore for StakePool {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, _memo: Option<String>) {
        self.internal_ft_transfer(receiver_id, amount.into());
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        _receiver_id: AccountId,
        _amount: U128,
        _memo: Option<String>,
        _msg: String,
    ) -> PromiseOrValue<U128> {
        todo!("Implementation depends on the needed.");
    }

    fn ft_total_supply(&self) -> U128 {
        self.internal_ft_total_supply().into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        self.internal_ft_balance_of(account_id).into()
    }
}

impl StakePool {
    fn internal_new(
        fungible_token_metadata: FungibleTokenMetadataDto,
        manager_id: Option<AccountId>,
        self_fee_receiver_account_id: AccountId,
        partner_fee_receiver_account_id: AccountId,
        reward_fee_self: Option<Fee>,
        reward_fee_partner: Option<Fee>,
        instant_withdraw_fee_self: Option<Fee>,
        instant_withdraw_fee_partner: Option<Fee>
    ) -> Self {
        if env::state_exists() {
            env::panic_str("Contract state is already initialize.");
        }

        let fungible_token_metadata_ = FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: fungible_token_metadata.name,
            symbol: fungible_token_metadata.symbol,
            icon: fungible_token_metadata.icon,
            reference: fungible_token_metadata.reference,
            reference_hash: fungible_token_metadata.reference_hash,
            decimals: fungible_token_metadata.decimals
        };
        fungible_token_metadata_.assert_valid();

        if self_fee_receiver_account_id == partner_fee_receiver_account_id {
            env::panic_str("The self fee receiver account and partner fee receiver account can not be the same.");
        }

        if reward_fee_self.is_none() && reward_fee_partner.is_some() {
            env::panic_str("Reward fees are not valid.");
        }
        let reward_fee = if let Some(reward_fee_self_) = reward_fee_self {
            reward_fee_self_.assert_valid();

            if let Some(ref reward_fee_partner_) = reward_fee_partner {
                reward_fee_partner_.assert_valid();
            }

            Some (
                SharedFee {
                    self_fee: reward_fee_self_,
                    partner_fee: reward_fee_partner
                }
            )
        } else {
            None
        };

        if instant_withdraw_fee_self.is_none() && instant_withdraw_fee_partner.is_some() {
            env::panic_str("Instant withdraw fees are not valid.");
        }
        let instant_withdraw_fee = if let Some(instant_withdraw_fee_self_) = instant_withdraw_fee_self {
            instant_withdraw_fee_self_.assert_valid();

            if let Some(ref instant_withdraw_fee_partner_) = instant_withdraw_fee_partner {
                instant_withdraw_fee_partner_.assert_valid();
            }

            Some (
                SharedFee {
                    self_fee: instant_withdraw_fee_self_,
                    partner_fee: instant_withdraw_fee_partner
                }
            )
        } else {
            None
        };

        let predecessor_account_id = env::predecessor_account_id();

        let manager_id_ = match manager_id {
            Some(manager_id__) => manager_id__,
            None => predecessor_account_id.clone()
        };

        let account_balance = AccountBalance {
            token_amount: 0,
            classic_near_amount: 0,
            investment_near_amount: 0
        };

        let mut stake_pool = Self {
            account_registry: AccountRegistry {
                owner_id: predecessor_account_id.clone(),
                manager_id: manager_id_,
                self_fee_receiver_account_id,
                partner_fee_receiver_account_id
            },
            fee_registry: FeeRegistry {
                reward_fee,
                instant_withdraw_fee
            },
            fungible_token: FungibleToken::new(fungible_token_metadata_.clone()),
            fund: Fund::new(),
            validating: Validating::new(),
            current_epoch_height: env::epoch_height(),
            reward: Reward {
                previous_epoch_rewards_from_validators_near_amount: 0,
                total_rewards_from_validators_near_amount: 0
            }
        };
        stake_pool.fungible_token.account_registry.insert(&stake_pool.account_registry.self_fee_receiver_account_id, &account_balance);
        stake_pool.fungible_token.account_registry.insert(&stake_pool.account_registry.partner_fee_receiver_account_id, &account_balance);
        stake_pool.fungible_token.accounts_quantity = 2;

        stake_pool
    }

    fn internal_deposit(&mut self, near_amount: Balance) -> PromiseOrValue<()> {
        Self::assert_gas_is_enough();
        Self::assert_minimum_deposit();
        self.assert_epoch_is_synchronized();

        let predecessor_account_id = env::predecessor_account_id();

        let attached_deposit = env::attached_deposit();

        let (storage_staking_price_per_additional_account, mut account_balance) = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance_) => (0, account_balance_),
            None => {
                (
                    Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account),
                    AccountBalance { token_amount: 0, classic_near_amount: 0, investment_near_amount: 0 }
                )
            }
        };

        let minimum_near_amount = if MINIMUN_DEPOSIT_AMOUNT > storage_staking_price_per_additional_account {
            MINIMUN_DEPOSIT_AMOUNT - storage_staking_price_per_additional_account
        } else {
            env::panic_str("Logic error.");
        };
        if near_amount < minimum_near_amount {
            env::panic_str("Near amount less then minimum required near amount.");
        }

        if attached_deposit < storage_staking_price_per_additional_account {
            env::panic_str("Insufficient near deposit.");
        }

        let available_for_staking_near_amount = attached_deposit - storage_staking_price_per_additional_account;

        if near_amount > available_for_staking_near_amount {
            env::panic_str("Insufficient near deposit.");
        }

        let refundable_near_amount = available_for_staking_near_amount - near_amount;

        let (token_amount, remainder_near_amount) = self.convert_near_amount_to_token_amount(near_amount);
        if token_amount == 0 {
            env::panic_str("Insufficient near amount.");
        }

        if self.fund.is_distributed_on_validators_in_current_epoch && self.validating.preffered_validator.is_some() {
            match self.validating.preffered_validator {
                Some(ref preffered_validator_account_id) => {
                    match self.validating.validator_registry.get(preffered_validator_account_id) {
                        Some(validator) => {
                            match validator.staking_contract_version {
                                StakingContractVersion::Core => {
                                    PromiseOrValue::Promise(
                                        classic_validator::ext(preffered_validator_account_id.clone())
                                            .with_attached_deposit(near_amount)
                                            .deposit_and_stake()
                                            .then(
                                                Self::ext(env::current_account_id())
                                                    .deposit_callback(
                                                        predecessor_account_id,
                                                        preffered_validator_account_id.clone(),
                                                        attached_deposit,
                                                        near_amount,
                                                        refundable_near_amount,
                                                        token_amount,
                                                        remainder_near_amount,
                                                        self.current_epoch_height,
                                                        storage_staking_price_per_additional_account
                                                    )
                                            )
                                    )
                                }
                            }
                        }
                        None => {
                            env::panic_str("Nonexecutable code. Object must exist.");
                        }
                    }
                }
                None => {
                    env::panic_str("Nonexecutable code. Object must exist.");
                }
            }
        } else {
            self.fund.classic_unstaked_balance += near_amount;
            self.fungible_token.total_supply += token_amount;

            account_balance.token_amount += token_amount;
            account_balance.classic_near_amount += remainder_near_amount;
            if let None = self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance) {
                self.fungible_token.accounts_quantity += 1;
            }

            if refundable_near_amount > 0 {
                Promise::new(predecessor_account_id.clone())
                    .transfer(refundable_near_amount);
            }

            let current_account_id_log = env::current_account_id();
            env::log_str(
                format!(
                    "
                    Deposited to @{} in {} epoch.
                    Attached deposit is {} yoctoNear.
                    Exchangeable deposit is {} yoctoNear.
                    Reserved storage staking price is {} yoctoNear.
                    Refundable deposit is {} yoctoNear.
                    Old @{} total supply is {} yoctoStNear.
                    Old @{} balance is {} yoctoNear.
                    Old @{} balance is {} yoctoStNear.
                    @{} received {} yoctoStNear.
                    New @{} balance is {} yoctoStNear.
                    New @{} balance is {} yoctoNear.
                    New @{} total supply is {} yoctoStNear.
                    ",
                    &current_account_id_log,
                    self.current_epoch_height,
                    attached_deposit,
                    near_amount,
                    storage_staking_price_per_additional_account,
                    refundable_near_amount,
                    &current_account_id_log,
                    self.fungible_token.total_supply - token_amount,
                    &current_account_id_log,
                    self.fund.get_common_balance() - near_amount,
                    &predecessor_account_id,
                    account_balance.token_amount - token_amount,
                    &predecessor_account_id,
                    token_amount,
                    &predecessor_account_id,
                    account_balance.token_amount,
                    &current_account_id_log,
                    self.fund.get_common_balance(),
                    &current_account_id_log,
                    self.fungible_token.total_supply
                ).as_str()
            );

            PromiseOrValue::Value(())
        }
    }

    fn internal_deposit_on_validator(&mut self, near_amount: Balance, validator_account_id: AccountId) -> Promise {
        Self::assert_gas_is_enough();
        Self::assert_minimum_deposit();
        self.assert_epoch_is_synchronized();

        let validator = match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };

        let predecessor_account_id = env::predecessor_account_id();

        let attached_deposit = env::attached_deposit();

        let investor_investment = match self.validating.investor_investment_registry.get(&predecessor_account_id) {
            Some(investor_investment_) => investor_investment_,
            None => {
                env::panic_str("Investor account is not registered yet.");
            }
        };

        let mut storage_staking_price_per_additional_accounts: Balance = 0;

        if let None = investor_investment.distribution_registry.get(&validator_account_id) {
            storage_staking_price_per_additional_accounts += Self::calculate_storage_staking_price(self.validating.storage_usage_per_distribution);
        }

        if let None = self.fungible_token.account_registry.get(&predecessor_account_id) {
            storage_staking_price_per_additional_accounts += Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);
        };

        let minimum_near_amount = if MINIMUN_DEPOSIT_AMOUNT > storage_staking_price_per_additional_accounts {
            MINIMUN_DEPOSIT_AMOUNT - storage_staking_price_per_additional_accounts
        } else {
            env::panic_str("Logic error.");
        };
        if near_amount < minimum_near_amount {
            env::panic_str("Near amount less then minimum required near amount.");
        }

        if attached_deposit <= storage_staking_price_per_additional_accounts {
            env::panic_str("Insufficient near deposit.");
        }
        let available_for_staking_near_amount = attached_deposit - storage_staking_price_per_additional_accounts;

        if near_amount > available_for_staking_near_amount {
            env::panic_str("Insufficient near deposit.");
        }
        let refundable_near_amount = available_for_staking_near_amount - near_amount;

        let (token_amount, remainder_near_amount) = self.convert_near_amount_to_token_amount(near_amount);
        if token_amount == 0 {
            env::panic_str("Insufficient near deposit.");
        }

        match validator.staking_contract_version {
            StakingContractVersion::Core => {
                classic_validator::ext(validator_account_id.clone())
                    .with_attached_deposit(near_amount)
                    .deposit_and_stake()
                    .then(
                        Self::ext(env::current_account_id())
                            .deposit_on_validator_callback(
                                predecessor_account_id,
                                validator_account_id.clone(),
                                near_amount,
                                attached_deposit,
                                refundable_near_amount,
                                token_amount,
                                remainder_near_amount,
                                storage_staking_price_per_additional_accounts
                            )
                    )
            }
        }
    }

    fn internal_instant_withdraw(&mut self, mut token_amount: Balance) -> Promise {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();

        if token_amount == 0 {
            env::panic_str("Insufficient token amount.");
        }

        let token_amount_log = token_amount;

        let predecessor_account_id = env::predecessor_account_id();

        let mut account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance_) => account_balance_,
            None => {
                env::panic_str("Token account is not registered.");
            }
        };
        if account_balance.token_amount < token_amount {
            env::panic_str("Token amount exceeded the available token balance.");
        }

        let token_balance_log = account_balance.token_amount;

        account_balance.token_amount -= token_amount;
        if let Some(investor_investment) = self.validating.investor_investment_registry.get(&predecessor_account_id) {
            if (self.convert_token_amount_to_near_amount(account_balance.token_amount) + account_balance.investment_near_amount) < investor_investment.staked_balance {
                env::panic_str("Token amount exceeded the available to instant withdraw token amount.");
            }
        }

        let mut instant_withdraw_fee_self_token_amount: u128 = 0;

        let mut instant_withdraw_fee_partner_token_amount: u128 = 0;

        let mut instant_withdraw_fee_self_log: Option<Fee> = None;

        if let Some(ref instant_withdraw_fee) = self.fee_registry.instant_withdraw_fee {
            instant_withdraw_fee_self_log = Some(instant_withdraw_fee.self_fee.clone());

            let mut instant_withdraw_fee_self_token_amount_ = instant_withdraw_fee.self_fee.multiply(token_amount);
            if instant_withdraw_fee_self_token_amount_ != 0 {
                token_amount -= instant_withdraw_fee_self_token_amount_;

                if let Some(ref instant_withdraw_fee_partner) = instant_withdraw_fee.partner_fee {
                    let instant_withdraw_fee_partner_token_amount_ = instant_withdraw_fee_partner.multiply(instant_withdraw_fee_self_token_amount_);
                    if instant_withdraw_fee_partner_token_amount_ != 0 {
                        instant_withdraw_fee_partner_token_amount = instant_withdraw_fee_partner_token_amount_;

                        instant_withdraw_fee_self_token_amount_ -= instant_withdraw_fee_partner_token_amount_;
                    }
                }

                instant_withdraw_fee_self_token_amount = instant_withdraw_fee_self_token_amount_;
            }
        }

        let mut near_amount = self.convert_token_amount_to_near_amount(token_amount) + account_balance.classic_near_amount;

        if near_amount == 0 {
            env::panic_str("Insufficient token amount.");
        }
        if near_amount > self.fund.classic_unstaked_balance {
            env::panic_str("Token amount exceeded the available unstaked near balance.");
        }

        account_balance.classic_near_amount = 0;

        self.fund.classic_unstaked_balance -= near_amount;

        if predecessor_account_id == self.account_registry.self_fee_receiver_account_id {
            account_balance.token_amount += instant_withdraw_fee_self_token_amount;
        } else {
            let mut account_balance_ = match self.fungible_token.account_registry.get(&self.account_registry.self_fee_receiver_account_id) {
                Some(account_balance__) => account_balance__,
                None => {
                    env::panic_str("Nonexecutable code. Object must exist.");
                }
            };
            account_balance_.token_amount += instant_withdraw_fee_self_token_amount;

            self.fungible_token.account_registry.insert(&self.account_registry.self_fee_receiver_account_id, &account_balance_);
        }
        if predecessor_account_id == self.account_registry.partner_fee_receiver_account_id {
            account_balance.token_amount += instant_withdraw_fee_partner_token_amount
        } else {
            let mut account_balance_ = match self.fungible_token.account_registry.get(&self.account_registry.partner_fee_receiver_account_id) {
                Some(account_balance__) => account_balance__,
                None => {
                    env::panic_str("Nonexecutable code. Object must exist.");
                }
            };
            account_balance_.token_amount += instant_withdraw_fee_partner_token_amount;

            self.fungible_token.account_registry.insert(&self.account_registry.partner_fee_receiver_account_id, &account_balance_);
        }

        let released_storage_staking_price_per_additional_account_log = if account_balance.token_amount > 0
            || predecessor_account_id == self.account_registry.self_fee_receiver_account_id
            || predecessor_account_id == self.account_registry.partner_fee_receiver_account_id {
            self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance);

            0
        } else {
            self.fungible_token.account_registry.remove(&predecessor_account_id);
            self.fungible_token.accounts_quantity -= 1;

            let storage_staking_price_per_additional_account = Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);

            near_amount += storage_staking_price_per_additional_account;

            storage_staking_price_per_additional_account
        };

        self.fungible_token.total_supply -= token_amount;

        let attached_deposit = env::attached_deposit();

        near_amount += attached_deposit;

        let current_account_id_log = env::current_account_id();
        env::log_str(
            format!(
                "
                Instant withdrawing from @{} in {} epoch.
                Attached deposit is {} yoctoNear.
                Exchangeable deposit is {} yoctoStNear.
                Fee is {:?}.
                Released storage staking price is {} yoctoNear.
                Received amount is {} yoctoNear.
                Old @{} total supply is {} yoctoStNear.
                Old @{} balance is {} yoctoNear.
                Old @{} balance is {} yoctoStNear.
                @{} sent {} yoctoStNear.
                New @{} balance is {} yoctoStNear.
                New @{} balance is {} yoctoNear.
                New @{} total supply is {} yoctoStNear.
                ",
                &current_account_id_log,
                self.current_epoch_height,
                attached_deposit,
                token_amount_log,
                instant_withdraw_fee_self_log,
                released_storage_staking_price_per_additional_account_log,
                near_amount,
                &current_account_id_log,
                self.fungible_token.total_supply + token_amount,
                &current_account_id_log,
                self.fund.get_common_balance() + near_amount - released_storage_staking_price_per_additional_account_log - attached_deposit,
                &predecessor_account_id,
                token_balance_log,
                &predecessor_account_id,
                token_amount + instant_withdraw_fee_self_token_amount + instant_withdraw_fee_partner_token_amount,
                &predecessor_account_id,
                account_balance.token_amount,
                &current_account_id_log,
                self.fund.get_common_balance(),
                &current_account_id_log,
                self.fungible_token.total_supply
            ).as_str()
        );

        Promise::new(predecessor_account_id)
            .transfer(near_amount)
    }

    fn internal_delayed_withdraw(&mut self, token_amount: Balance) -> PromiseOrValue<()> {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();

        if token_amount == 0 {
            env::panic_str("Insufficient token amount.");
        }

        let predecessor_account_id = env::predecessor_account_id();

        let mut account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance_) => account_balance_,
            None => {
                env::panic_str("Token account is not registered.");
            }
        };
        if account_balance.token_amount < token_amount {
            env::panic_str("Token amount exceeded the available token balance.");
        }

        let near_amount = self.convert_token_amount_to_near_amount(token_amount) + account_balance.classic_near_amount;

        if near_amount == 0 {
            env::panic_str("Insufficient token amount.");
        }
        if near_amount > self.fund.classic_staked_balance {
            env::panic_str("Token amount exceeded the available staked near balance.");
        }

        account_balance.classic_near_amount = 0;

        self.fund.classic_staked_balance -= near_amount;

        let attached_deposit = env::attached_deposit();

        let (
            mut refundable_near_amount,
            reserved_storage_staking_price_per_additional_delayed_withdrawal_log,
            delayed_withdrawal_near_amount_log,
            epoch_quantity_to_take_delayed_withdrawal_log,
            mut delayed_withdrawal
        ) = match self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.get(&predecessor_account_id) {
            Some(delayed_withdrawal_) => {
                (
                    attached_deposit,
                    0,
                    delayed_withdrawal_.near_amount,
                    delayed_withdrawal_.get_epoch_quantity_to_take_delayed_withdrawal(self.current_epoch_height),
                    delayed_withdrawal_
                )
            }
            None => {
                let storage_staking_price_per_additional_delayed_withdrawal =
                    Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_delayed_withdrawal);
                if attached_deposit < storage_staking_price_per_additional_delayed_withdrawal {
                    env::panic_str("Insufficient near deposit.");
                }

                (
                    attached_deposit - storage_staking_price_per_additional_delayed_withdrawal,
                    storage_staking_price_per_additional_delayed_withdrawal,
                    0,
                    0,
                    DelayedWithdrawal {
                        near_amount: 0,
                        started_epoch_height: self.current_epoch_height
                    },
                )
            }
        };
        delayed_withdrawal.near_amount += near_amount;
        delayed_withdrawal.started_epoch_height = self.current_epoch_height;
        self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.insert(&predecessor_account_id, &delayed_withdrawal);
        self.fund.delayed_withdrawn_fund.needed_to_request_classic_near_amount += near_amount;

        account_balance.token_amount -= token_amount;
        if let Some(investor_investment) = self.validating.investor_investment_registry.get(&predecessor_account_id) {
            if (self.convert_token_amount_to_near_amount(account_balance.token_amount) + account_balance.investment_near_amount) < investor_investment.staked_balance {
                env::panic_str("Token amount exceeded the available to delayed withdraw token amount.");
            }
        }
        let released_storage_staking_price_per_additional_account_log = if account_balance.token_amount > 0
            || predecessor_account_id == self.account_registry.self_fee_receiver_account_id
            || predecessor_account_id == self.account_registry.partner_fee_receiver_account_id  {
            self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance);

            0
        } else {
            self.fungible_token.account_registry.remove(&predecessor_account_id);
            self.fungible_token.accounts_quantity -= 1;

            let storage_staking_price_per_additional_account =
                Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);

            refundable_near_amount += storage_staking_price_per_additional_account;

            storage_staking_price_per_additional_account
        };

        self.fungible_token.total_supply -= token_amount;

        let current_account_id_log = env::current_account_id();
        env::log_str(
            format!(
                "
                Delayed withdrawing from @{} in {} epoch.
                Attached deposit is {} yoctoNear.
                Exchangeable deposit is {} yoctoStNear.
                Refundable deposit is {} yoctoNear.
                Reserved storage staking price is {} yoctoNear.
                Released storage staking price is {} yoctoNear.
                Old expected for receiving amount is {} yoctoNear.
                Old epoch quantity to take delayed withdrawal is {}.
                Additional expected for receiving amount is {} yoctoNear.
                New expected for receiving amount is {} yoctoNear.
                New epoch quantity to take delayed withdrawal is {}.
                Old @{} total supply is {} yoctoStNear.
                Old @{} balance is {} yoctoNear.
                Old @{} balance is {} yoctoStNear.
                @{} sent {} yoctoStNear.
                New @{} balance is {} yoctoStNear.
                New @{} balance is {} yoctoNear.
                New @{} total supply is {} yoctoStNear.
                ",
                &current_account_id_log,
                self.current_epoch_height,
                attached_deposit,
                token_amount,
                refundable_near_amount,
                reserved_storage_staking_price_per_additional_delayed_withdrawal_log,
                released_storage_staking_price_per_additional_account_log,
                delayed_withdrawal_near_amount_log,
                epoch_quantity_to_take_delayed_withdrawal_log,
                near_amount,
                delayed_withdrawal.near_amount,
                delayed_withdrawal.get_epoch_quantity_to_take_delayed_withdrawal(self.current_epoch_height),
                &current_account_id_log,
                self.fungible_token.total_supply + token_amount,
                &current_account_id_log,
                self.fund.get_common_balance() + near_amount,
                &predecessor_account_id,
                account_balance.token_amount + token_amount,
                &predecessor_account_id,
                token_amount,
                &predecessor_account_id,
                account_balance.token_amount,
                &current_account_id_log,
                self.fund.get_common_balance(),
                &current_account_id_log,
                self.fungible_token.total_supply
            ).as_str()
        );

        if refundable_near_amount > 0 {
            return PromiseOrValue::Promise(
                Promise::new(predecessor_account_id)
                    .transfer(refundable_near_amount)
            );
        }

        PromiseOrValue::Value(())
    }

    fn internal_delayed_withdraw_from_validator(&mut self, near_amount: Balance, validator_account_id: AccountId) -> PromiseOrValue<()> {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();

        if near_amount == 0 {
            env::panic_str("Insufficient near amount.");
        }
        if near_amount > self.fund.investment_staked_balance {
            env::panic_str("Token amount exceeded the available staked near balance.");
        }

        let validator = match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };

        let predecessor_account_id = env::predecessor_account_id();

        let mut investor_investment = match self.validating.investor_investment_registry.get(&predecessor_account_id) {
            Some(investor_investment_) => investor_investment_,
            None => {
                env::panic_str("Investor account is not registered yet.");
            }
        };

        let mut staked_balance = match investor_investment.distribution_registry.get(&validator_account_id) {
            Some(staked_balance_) => staked_balance_,
            None => {
                env::panic_str("There is no investor stake on this validator.");
            }
        };
        if near_amount > staked_balance {
            env::panic_str("Near amount exceeded the available investor near balance on validator.");
        }

        let attached_deposit = env::attached_deposit();

        let (
            mut refundable_near_amount,
            mut investment_withdrawal,
            mut reserved_storage_staking_price_per_additional_accounts_log
        ) = match self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.get(&validator_account_id) {
            Some(investment_withdrawal_) => (attached_deposit, investment_withdrawal_, 0),
            None => {
                let storage_staking_price_per_additional_investment_withdrawal =
                    Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_investment_withdrawal);
                if attached_deposit < storage_staking_price_per_additional_investment_withdrawal {
                    env::panic_str("Insufficient near deposit.");
                }

                (
                    attached_deposit - storage_staking_price_per_additional_investment_withdrawal,
                    InvestmentWithdrawal {
                        near_amount: 0,
                        account_id: predecessor_account_id.clone()
                    },
                    storage_staking_price_per_additional_investment_withdrawal
                )
            }
        };
        if near_amount > (validator.balance.investment_near_amount - investment_withdrawal.near_amount) {
            env::panic_str("Near amount exceeded the available near balance on validator.");
        }

        let (token_amount, _) = self.convert_near_amount_to_token_amount(near_amount);
        if token_amount == 0 {
            env::panic_str("Insufficient near amount.");
        }

        let mut account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance_) => account_balance_,
            None => {
                env::panic_str("Token account is not registered.");
            }
        };
        if account_balance.token_amount < token_amount {
            env::panic_str("Token amount exceeded the available token balance.");
        }

        self.fund.investment_staked_balance -= near_amount;

        let (
            delayed_withdrawal_near_amount_log,
            epoch_quantity_to_take_delayed_withdrawal_log,
            mut delayed_withdrawal
         ) = match self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.get(&predecessor_account_id) {
            Some(delayed_withdrawal_) => {
                (
                    delayed_withdrawal_.near_amount,
                    delayed_withdrawal_.get_epoch_quantity_to_take_delayed_withdrawal(self.current_epoch_height),
                    delayed_withdrawal_
                )
            }
            None => {
                let storage_staking_price_per_additional_delayed_withdrawal =
                    Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_delayed_withdrawal);
                if refundable_near_amount < storage_staking_price_per_additional_delayed_withdrawal {
                    env::panic_str("Insufficient near deposit.");
                }
                refundable_near_amount -= storage_staking_price_per_additional_delayed_withdrawal;

                reserved_storage_staking_price_per_additional_accounts_log += storage_staking_price_per_additional_delayed_withdrawal;

                (
                    0,
                    0,
                    DelayedWithdrawal {
                        near_amount: 0,
                        started_epoch_height: self.current_epoch_height
                    }
                )
            }
        };
        delayed_withdrawal.started_epoch_height = self.current_epoch_height;
        delayed_withdrawal.near_amount += near_amount;
        self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.insert(&predecessor_account_id, &delayed_withdrawal);

        investment_withdrawal.near_amount += near_amount;
        self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.insert(&validator_account_id, &investment_withdrawal);
        self.fund.delayed_withdrawn_fund.needed_to_request_investment_near_amount += near_amount;

        let mut released_storage_staking_price_per_additional_accounts_log = if near_amount < staked_balance {
            staked_balance -= near_amount;

            investor_investment.distribution_registry.insert(&validator_account_id, &staked_balance);

            0
        } else {
            investor_investment.distribution_registry.remove(&validator_account_id);
            investor_investment.distributions_quantity -= 1;

            let storage_staking_price_per_additional_distribution =
                Self::calculate_storage_staking_price(self.validating.storage_usage_per_distribution);

            refundable_near_amount += storage_staking_price_per_additional_distribution;

            storage_staking_price_per_additional_distribution
        };
        investor_investment.staked_balance -= near_amount;
        self.validating.investor_investment_registry.insert(&predecessor_account_id, &investor_investment);

        account_balance.token_amount -= token_amount;
        if account_balance.token_amount > 0
            || predecessor_account_id == self.account_registry.self_fee_receiver_account_id
            || predecessor_account_id == self.account_registry.partner_fee_receiver_account_id  {
            self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance);
        } else {
            self.fungible_token.account_registry.remove(&predecessor_account_id);
            self.fungible_token.accounts_quantity -= 1;

            let storage_staking_price_per_additional_account =
                Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);

            refundable_near_amount += storage_staking_price_per_additional_account;

            released_storage_staking_price_per_additional_accounts_log += storage_staking_price_per_additional_account;
        }

        self.fungible_token.total_supply -= token_amount;

        let current_account_id_log = env::current_account_id();
        env::log_str(
            format!(
                "
                Delayed withdrawing from @{} via @{} in {} epoch.
                Attached deposit is {} yoctoNear.
                Exchangeable deposit is {} yoctoNear.
                Refundable deposit is {} yoctoNear.
                Reserved storage staking price is {} yoctoNear.
                Released storage staking price is {} yoctoNear.
                Old expected for receiving amount is {} yoctoNear.
                Old epoch quantity to take delayed withdrawal is {}.
                Additional expected for receiving amount is {} yoctoNear.
                New expected for receiving amount is {} yoctoNear.
                New epoch quantity to take delayed withdrawal is {}.
                Old @{} total supply is {} yoctoStNear.
                Old @{} balance is {} yoctoNear.
                Old @{} balance is {} yoctoStNear.
                @{} sent {} yoctoStNear.
                New @{} balance is {} yoctoStNear.
                New @{} balance is {} yoctoNear.
                New @{} total supply is {} yoctoStNear.
                ",
                &validator_account_id,
                &current_account_id_log,
                self.current_epoch_height,
                attached_deposit,
                near_amount,
                refundable_near_amount,
                reserved_storage_staking_price_per_additional_accounts_log,
                released_storage_staking_price_per_additional_accounts_log,
                delayed_withdrawal_near_amount_log,
                epoch_quantity_to_take_delayed_withdrawal_log,
                near_amount,
                delayed_withdrawal.near_amount,
                delayed_withdrawal.get_epoch_quantity_to_take_delayed_withdrawal(self.current_epoch_height),
                &current_account_id_log,
                self.fungible_token.total_supply + token_amount,
                &current_account_id_log,
                self.fund.get_common_balance() + near_amount,
                &predecessor_account_id,
                account_balance.token_amount + token_amount,
                &predecessor_account_id,
                token_amount,
                &predecessor_account_id,
                account_balance.token_amount,
                &current_account_id_log,
                self.fund.get_common_balance(),
                &current_account_id_log,
                self.fungible_token.total_supply
            ).as_str()
        );

        if refundable_near_amount > 0 {
            return PromiseOrValue::Promise(
                Promise::new(predecessor_account_id)
                    .transfer(refundable_near_amount)
            )
        }

        PromiseOrValue::Value(())
    }

    fn internal_take_delayed_withdrawal(&mut self) -> Promise {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();

        let predecessor_account_id = env::predecessor_account_id();

        let delayed_withdrawal = match self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.remove(&predecessor_account_id) {
            Some(delayed_withdrawal_) => delayed_withdrawal_,
            None => {
                env::panic_str("Delayed withdrawal account is not registered.");
            }
        };
        if !delayed_withdrawal.can_take_delayed_withdrawal(self.current_epoch_height) {
            env::panic_str("Wrong epoch for withdrawal.");
        }

        self.fund.delayed_withdrawn_fund.balance -= delayed_withdrawal.near_amount;

        let near_amount = delayed_withdrawal.near_amount
            + Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_delayed_withdrawal)
            + env::attached_deposit();

        Promise::new(predecessor_account_id)
            .transfer(near_amount)
    }

    fn internal_increase_validator_stake(&mut self, validator_account_id: AccountId, near_amount: Balance) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        if near_amount == 0 {
            env::panic_str("Insufficient near amount.");
        }
        if near_amount > self.fund.classic_unstaked_balance {
            env::panic_str("Near amount exceeded the available unstaked near balance.");
        }

        let validator = match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };
        if validator.is_only_for_investment {
            env::panic_str("Validator is used only for investment purpose.");
        }

        match validator.staking_contract_version {
            StakingContractVersion::Core => {
                classic_validator::ext(validator_account_id.clone())
                    .with_attached_deposit(near_amount)
                    .deposit_and_stake()
                    .then(
                        Self::ext(env::current_account_id())
                            .increase_validator_stake_callback(validator_account_id, near_amount, env::epoch_height())
                    )
            }
        }
    }

    fn internal_requested_decrease_validator_stake(
        &mut self,
        validator_account_id: AccountId,
        near_amount: Balance,
        stake_decreasing_type: StakeDecreasingType
    ) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_desynchronized();
        self.assert_authorized_management_only_by_manager();
        if !Self::is_right_epoch(env::epoch_height()) {
            env::panic_str("Epoch is not intended for a requested decrease validator stake request.");
        }

        if near_amount == 0 {
            env::panic_str("Insufficient near amount.");
        }

        let validator = match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };
        match stake_decreasing_type {
            StakeDecreasingType::Classic => {
                if near_amount > validator.balance.classic_near_amount {
                    env::panic_str("Near amount exceeded the available staked near balance.");
                }
                if near_amount > self.fund.delayed_withdrawn_fund.needed_to_request_classic_near_amount {
                    env::panic_str("Near amount is more than requested near amount.");
                }
            }
            StakeDecreasingType::Investment => {
                if near_amount > validator.balance.investment_near_amount {
                    env::panic_str("Near amount exceeded the available unstaked near balance.");
                }
                if near_amount > self.fund.delayed_withdrawn_fund.needed_to_request_investment_near_amount {
                    env::panic_str("Near amount is more than requested near amount.");
                }

                let investment_withdrawal = match self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.get(&validator_account_id) {
                    Some(investment_withdrawal_) => investment_withdrawal_,
                    None => {
                        env::panic_str("Investment withdrawal account is not registered yet.");
                    }
                };
                if near_amount > investment_withdrawal.near_amount {
                    env::panic_str("Near amount is more than requested near amount from validator.");
                }
            }
        }

        let current_account_id = env::current_account_id();

        match validator.staking_contract_version {
            StakingContractVersion::Core => {
                classic_validator::ext(validator_account_id.clone())
                    .get_account_unstaked_balance(current_account_id.clone())
                    .then(
                        Self::ext(current_account_id)
                            .requested_decrease_validator_stake_callback_1(
                                validator_account_id,
                                near_amount,
                                stake_decreasing_type,
                                Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_investment_withdrawal)
                            )
                    )
            }
        }
    }

    fn internal_take_unstaked_balance(&mut self, validator_account_id: AccountId) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_desynchronized();
        self.assert_authorized_management_only_by_manager();

        let current_epoch_height = env::epoch_height();

        if !Self::is_right_epoch(current_epoch_height) {
            env::panic_str("Epoch is not intended for a take unstaked balance.");
        }
        match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator) => {
                if validator.balance.requested_to_withdrawal_near_amount == 0 {
                    env::panic_str("Insufficient unstaked balance on validator.");
                }
                if validator.last_update_epoch_height >= current_epoch_height {
                    env::panic_str("Validator is already updated.");
                }

                match validator.staking_contract_version {
                    StakingContractVersion::Core => {
                        classic_validator::ext(validator_account_id.clone())
                            .withdraw(validator.balance.requested_to_withdrawal_near_amount.into())
                            .then(
                                Self::ext(env::current_account_id())
                                    .take_unstaked_balance_callback(
                                        validator_account_id,
                                        validator.balance.requested_to_withdrawal_near_amount
                                    )
                            )
                    }
                }
            }
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        }
    }

    fn internal_update_validator(&mut self, validator_account_id: AccountId) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_desynchronized();
        self.assert_authorized_management_only_by_manager();

        match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator) => {
                let current_epoch_height = env::epoch_height();

                if validator.last_update_epoch_height < current_epoch_height {
                    let current_account_id = env::current_account_id();
                    match validator.staking_contract_version {
                        StakingContractVersion::Core => {
                            classic_validator::ext(validator_account_id.clone())
                                .get_account_total_balance(current_account_id.clone())
                                .then(
                                    Self::ext(current_account_id)
                                        .update_validator_callback(validator_account_id, current_epoch_height)
                                )
                        }
                    }
                } else {
                    env::panic_str("Validator is already updated.");
                }
            }
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        }
    }

    fn internal_update(&mut self) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_desynchronized();
        self.assert_authorized_management_only_by_manager();

        let current_epoch_height = env::epoch_height();

        let common_balance_log = self.fund.get_common_balance();

        let total_supply_log = self.fungible_token.total_supply;

        if self.validating.validators_quantity > 0 {
            if (self.validating.quantity_of_validators_updated_in_current_epoch / self.validating.validators_quantity == 0)
                || (self.validating.quantity_of_validators_updated_in_current_epoch % self.validating.validators_quantity != 0) {
                env::panic_str("Some validators are not updated.");
            }

            if Self::is_right_epoch(current_epoch_height)
                && (self.fund.delayed_withdrawn_fund.needed_to_request_classic_near_amount > 0
                    || self.fund.delayed_withdrawn_fund.needed_to_request_investment_near_amount > 0) {
                    env::panic_str("Some funds are not unstaked from validators.");
            }

            self.fund.classic_staked_balance += self.reward.previous_epoch_rewards_from_validators_near_amount;
            self.validating.quantity_of_validators_updated_in_current_epoch = 0;
            self.reward.total_rewards_from_validators_near_amount += self.reward.previous_epoch_rewards_from_validators_near_amount;

            let (previous_epoch_rewards_from_validators_token_amount, _) = self.convert_near_amount_to_token_amount(
                self.reward.previous_epoch_rewards_from_validators_near_amount
            );

            let mut reward_fee_self_log: Option<Fee> = None;

            if let Some(ref reward_fee) = self.fee_registry.reward_fee {
                reward_fee_self_log = Some(reward_fee.self_fee.clone());

                let mut reward_fee_self_token_amount = reward_fee.self_fee.multiply(previous_epoch_rewards_from_validators_token_amount);
                if reward_fee_self_token_amount != 0 {
                    self.fungible_token.total_supply += reward_fee_self_token_amount;

                    if let Some(ref reward_fee_partner) = reward_fee.partner_fee {
                        let reward_fee_partner_token_amount = reward_fee_partner.multiply(reward_fee_self_token_amount);
                        if reward_fee_partner_token_amount != 0 {
                            reward_fee_self_token_amount -= reward_fee_partner_token_amount;

                            let mut account_balance = match self.fungible_token.account_registry.get(&self.account_registry.partner_fee_receiver_account_id) {
                                Some(account_balance_) => account_balance_,
                                None => {
                                    env::panic_str("Nonexecutable code. Object must exist.");
                                }
                            };
                            account_balance.token_amount += reward_fee_partner_token_amount;

                            self.fungible_token.account_registry.insert(&self.account_registry.partner_fee_receiver_account_id, &account_balance);
                        }
                    }

                    let mut account_balance = match self.fungible_token.account_registry.get(&self.account_registry.self_fee_receiver_account_id) {
                        Some(account_balance_) => account_balance_,
                        None => {
                            env::panic_str("Nonexecutable code. Object must exist.");
                        }
                    };
                    account_balance.token_amount += reward_fee_self_token_amount;

                    self.fungible_token.account_registry.insert(&self.account_registry.self_fee_receiver_account_id, &account_balance);
                }
            }

            let current_account_id_log = env::current_account_id();
            env::log_str(
                format!(
                    "
                    Updating @{} pool from {} epoch to {} epoch.
                    Old @{} total supply is {} yoctoStNear.
                    Old @{} balance is {} yoctoNear.
                    Received rewards from validators is {} yoctoNear.
                    Fee is {:?}.
                    Received token amount as fee is {}.
                    New @{} balance is {} yoctoNear.
                    New @{} total supply is {} yoctoStNear.
                    ",
                    current_account_id_log,
                    current_epoch_height - 1,
                    current_epoch_height,
                    current_account_id_log,
                    total_supply_log,
                    current_account_id_log,
                    common_balance_log,
                    self.reward.previous_epoch_rewards_from_validators_near_amount,
                    reward_fee_self_log,
                    self.fungible_token.total_supply - total_supply_log,
                    current_account_id_log,
                    self.fund.get_common_balance(),
                    current_account_id_log,
                    self.fungible_token.total_supply
                ).as_str()
            );

            self.reward.previous_epoch_rewards_from_validators_near_amount = 0;
        }

        self.fund.is_distributed_on_validators_in_current_epoch = false;
        self.current_epoch_height = current_epoch_height;
    }

    fn internal_add_validator(
        &mut self,
        validator_account_id: AccountId,
        staking_contract_version: StakingContractVersion,
        is_only_for_investment: bool,
        is_preferred: bool
    ) -> PromiseOrValue<()> {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        if is_preferred && is_only_for_investment {
            env::panic_str("Prefferred validator can not be only for investment.");
        }

        let attached_deposit = env::attached_deposit();

        let storage_staking_price_per_additional_validator = Self::calculate_storage_staking_price(self.validating.storage_usage_per_validator);
        if attached_deposit < storage_staking_price_per_additional_validator {
            env::panic_str("Insufficient near deposit.");
        }

        if let Some(_) = self.validating.validator_registry.insert(
            &validator_account_id, &Validator::new(staking_contract_version, is_only_for_investment)
        ) {
            env::panic_str("Validator account is already registered.");
        }
        self.validating.validators_quantity += 1;

        if is_preferred {
            self.validating.preffered_validator = Some(validator_account_id);
        }

        let near_amount = attached_deposit - storage_staking_price_per_additional_validator;
        if near_amount > 0 {
            return PromiseOrValue::Promise(
                Promise::new(env::predecessor_account_id())
                    .transfer(near_amount)
            );
        }

        PromiseOrValue::Value(())
    }

    fn internal_remove_validator(&mut self, validator_account_id: AccountId) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        let validator = match self.validating.validator_registry.remove(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };
        if validator.balance.classic_near_amount > 0
            || validator.balance.investment_near_amount > 0
            || validator.balance.requested_to_withdrawal_near_amount > 0 {
            env::panic_str("Validator has an available balance.");
        }

        self.validating.validators_quantity -= 1;

        if let Some(ref preffered_validator_account_id) = self.validating.preffered_validator {
            if *preffered_validator_account_id == validator_account_id {
                self.validating.preffered_validator = None;
            }
        }

        let refundable_near_amount = Self::calculate_storage_staking_price(self.validating.storage_usage_per_validator);

        Promise::new(env::predecessor_account_id())
            .transfer(refundable_near_amount)
    }

    fn internal_change_validator_investment_context(&mut self, validator_account_id: AccountId, is_only_for_investment: bool) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
            Some(validator_) => validator_,
            None => {
                env::panic_str("Validator account is not registered yet.");
            }
        };

        if validator.is_only_for_investment == is_only_for_investment {
            env::panic_str("Changing the state to the same state.");
        }

        if is_only_for_investment {
            if let Some(ref preffered_validator_account_id) = self.validating.preffered_validator {
                if *preffered_validator_account_id == validator_account_id {
                    env::panic_str("Prefferred validator can not be only for investment.");
                }
            }

            if validator.balance.classic_near_amount > 0 {
                env::panic_str("Validator classic staked balance is not equal to zero.");
            }
        }

        validator.is_only_for_investment = is_only_for_investment;
        self.validating.validator_registry.insert(&validator_account_id, &validator);
    }

    fn internal_change_preffered_validator(&mut self, validator_account_id: Option<AccountId>) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        match validator_account_id {
            Some(validator_account_id_) => {
                let validator = match self.validating.validator_registry.get(&validator_account_id_) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Validator account is not registered yet.");
                    }
                };

                if let Some(ref preffered_validator_account_id) = self.validating.preffered_validator {
                    if *preffered_validator_account_id == validator_account_id_ {
                        env::panic_str("Changing the state to the same state.");
                    }
                }

                if validator.is_only_for_investment {
                    env::panic_str("Prefferred validator can not be only for investment.");
                }

                self.validating.preffered_validator = Some(validator_account_id_);
            }
            None => {
                if let None = self.validating.preffered_validator {
                    env::panic_str("Changing the state to the same state.");
                }

                self.validating.preffered_validator = None;
            }
        }
    }

    fn internal_add_investor(&mut self, investor_account_id: AccountId) -> PromiseOrValue<()> {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        let storage_staking_price_per_additional_investor_investment = Self::calculate_storage_staking_price(self.validating.storage_usage_per_investor_investment);
        if env::attached_deposit() < storage_staking_price_per_additional_investor_investment {
            env::panic_str("Insufficient near deposit.");
        }

        if let Some(_) = self.validating.investor_investment_registry.insert(
            &investor_account_id, &InvestorInvestment::new(investor_account_id.clone())
        ) {
            env::panic_str("Investor account is already registered.");
        }

        let near_amount = env::attached_deposit() - storage_staking_price_per_additional_investor_investment;
        if near_amount > 0 {
            return PromiseOrValue::Promise(
                Promise::new(env::predecessor_account_id())
                    .transfer(near_amount)
            );
        }

        PromiseOrValue::Value(())
    }

    fn internal_remove_investor(&mut self, investor_account_id: AccountId) -> Promise {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        let investor_investment = match self.validating.investor_investment_registry.remove(&investor_account_id) {
            Some(investor_investment_) => investor_investment_,
            None => {
                env::panic_str("Investor account is not registered yet.");
            }
        };
        if investor_investment.staked_balance > 0 || investor_investment.distributions_quantity > 0 {
            env::panic_str("Validator has an available balance.");
        }

        let near_amount = Self::calculate_storage_staking_price(self.validating.storage_usage_per_investor_investment);

        Promise::new(env::predecessor_account_id())
            .transfer(near_amount)
    }

    fn internal_change_manager(&mut self, manager_id: AccountId) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management();

        self.account_registry.manager_id = manager_id;
    }

    fn internal_change_reward_fee(&mut self, reward_fee_self: Option<Fee>, reward_fee_partner: Option<Fee>) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        if reward_fee_self.is_none() && reward_fee_partner.is_some() {
            env::panic_str("Reward fees are not valid.");
        }
        self.fee_registry.reward_fee = if let Some(reward_fee_self_) = reward_fee_self {
            reward_fee_self_.assert_valid();

            if let Some(ref reward_fee_partner) = reward_fee_partner {
                reward_fee_partner.assert_valid();
            }

            Some (
                SharedFee {
                    self_fee: reward_fee_self_,
                    partner_fee: reward_fee_partner
                }
            )
        } else {
            None
        };
    }

    fn internal_change_instant_withdraw_fee(&mut self, instant_withdraw_fee_self: Option<Fee>, instant_withdraw_fee_partner: Option<Fee>) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        if instant_withdraw_fee_self.is_none() && instant_withdraw_fee_partner.is_some() {
            env::panic_str("Instant withdraw fees are not valid.");
        }
        self.fee_registry.instant_withdraw_fee = if let Some(instant_withdraw_fee_self_) = instant_withdraw_fee_self {
            instant_withdraw_fee_self_.assert_valid();

            if let Some(ref instant_withdraw_fee_partner) = instant_withdraw_fee_partner {
                instant_withdraw_fee_partner.assert_valid();
            }

            Some (
                SharedFee {
                    self_fee: instant_withdraw_fee_self_,
                    partner_fee: instant_withdraw_fee_partner
                }
            )
        } else {
            None
        };
    }

    fn internal_confirm_stake_distribution(&mut self) {
        Self::assert_gas_is_enough();
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        if self.fund.is_distributed_on_validators_in_current_epoch {
            env::panic_str("Fund has already been distributed.");
        }

        self.fund.is_distributed_on_validators_in_current_epoch = true;
    }

    fn internal_ft_transfer(&mut self, receiver_account_id: AccountId, token_amount: Balance) -> Promise {
        Self::assert_gas_is_enough();
        Self::assert_natural_deposit();

        if token_amount == 0 {
            env::panic_str("Insufficient token amount.");
        }

        let mut refundable_near_amount = env::attached_deposit();

        let predecessor_account_id = env::predecessor_account_id();
        let mut predecessor_account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance) => account_balance,
            None => {
                env::panic_str("Token account is not registered yet.");
            }
        };

        let mut receiver_account_balance = match self.fungible_token.account_registry.get(&receiver_account_id) {
            Some(account_balance) => account_balance,
            None => {
                env::panic_str("Token account is not registered yet.");
            }
        };

        if predecessor_account_balance.token_amount < token_amount {
            env::panic_str("Token amount exceeded the available token balance.");
        }

        predecessor_account_balance.token_amount -= token_amount;

        if let Some(investor_investment) = self.validating.investor_investment_registry.get(&predecessor_account_id) {
            if (self.convert_token_amount_to_near_amount(predecessor_account_balance.token_amount) + predecessor_account_balance.investment_near_amount)
                < investor_investment.staked_balance {
                env::panic_str("Token amount exceeded the available to transfer token amount.");
            }
        }

        receiver_account_balance.token_amount += token_amount;

        if predecessor_account_balance.token_amount > 0
            || predecessor_account_id == self.account_registry.self_fee_receiver_account_id
            || predecessor_account_id == self.account_registry.partner_fee_receiver_account_id {
            self.fungible_token.account_registry.insert(&predecessor_account_id, &predecessor_account_balance);
        } else {
            self.fungible_token.account_registry.remove(&predecessor_account_id);
            self.fungible_token.accounts_quantity -= 1;

            receiver_account_balance.classic_near_amount += predecessor_account_balance.classic_near_amount;

            refundable_near_amount += Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);
        }
        self.fungible_token.account_registry.insert(&receiver_account_id, &receiver_account_balance);

        Promise::new(predecessor_account_id)
            .transfer(refundable_near_amount)
    }

    pub fn internal_get_delayed_withdrawal_details(&self, account_id: AccountId) -> Option<DelayedWithdrawalDetails> {
        self.assert_epoch_is_synchronized();

        if let Some(delayed_withdrawal) = self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.get(&account_id) {
            return Some(
                    DelayedWithdrawalDetails {
                        epoch_quantity_to_take_delayed_withdrawal: delayed_withdrawal.get_epoch_quantity_to_take_delayed_withdrawal(self.current_epoch_height),
                        near_amount: delayed_withdrawal.near_amount.into()
                }
            );
        }

        None
    }

    fn internal_get_total_token_supply(&self) -> Balance {
        self.assert_epoch_is_synchronized();

        self.fungible_token.total_supply
    }

    fn internal_get_minimum_deposit_amount(&self) -> Balance {
        MINIMUN_DEPOSIT_AMOUNT
    }

    pub fn internal_get_storage_staking_price(&self) -> StorageStakingPrice {
        StorageStakingPrice {
            per_delayed_withdrawal_fund_delayed_withdrawal: Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_delayed_withdrawal).into(),
            per_delayed_withdrawal_fund_investment_withdrawal: Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_investment_withdrawal).into(),
            per_fungible_token_account: Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account).into(),
            per_validating_node_validator: Self::calculate_storage_staking_price(self.validating.storage_usage_per_validator).into(),
            per_validating_node_investor: Self::calculate_storage_staking_price(self.validating.storage_usage_per_investor_investment).into(),
            per_validating_node_distribution: Self::calculate_storage_staking_price(self.validating.storage_usage_per_distribution).into()
        }
    }

    pub fn internal_get_storage_staking_requested_coverage(&self, account_id: AccountId) -> StorageStakingRequestedCoverage {
        self.assert_epoch_is_synchronized();

        let storage_staking_price_per_delayed_withdrawal_fund_delayed_withdrawal = Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_delayed_withdrawal);

        let storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal = Self::calculate_storage_staking_price(self.fund.delayed_withdrawn_fund.storage_usage_per_investment_withdrawal);

        let storage_staking_price_per_fungible_token_account = Self::calculate_storage_staking_price(self.fungible_token.storage_usage_per_account);

        let storage_staking_price_per_validating_node_distribution = Self::calculate_storage_staking_price(self.validating.storage_usage_per_distribution);

        let per_method_deposit = if !self.fungible_token.account_registry.contains_key(&account_id) {
            storage_staking_price_per_fungible_token_account
        } else {
            0
        };

        let per_method_delayed_withdraw = if !self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.contains_key(&account_id) {
            storage_staking_price_per_delayed_withdrawal_fund_delayed_withdrawal
        } else {
            0
        };

        let (per_method_deposit_on_validator, per_method_delayed_withdraw_from_validator): (Option<(U128, Vec<(AccountId, U128)>)>, Option<(U128, Vec<(AccountId, U128)>)>) =
            match self.validating.investor_investment_registry.get(&account_id) {
            Some(investor_investment) => {
                let requested_storage_staking_price_per_fungible_token_account = if !self.fungible_token.account_registry.contains_key(&account_id) {
                    storage_staking_price_per_fungible_token_account
                } else {
                    0
                };

                let requested_storage_staking_price_per_delayed_withdrawal_fund_delayed_withdrawal = if !self.fund.delayed_withdrawn_fund.delayed_withdrawal_registry.contains_key(&account_id) {
                    storage_staking_price_per_delayed_withdrawal_fund_delayed_withdrawal
                } else {
                    0
                };

                let mut requested_storage_staking_price_per_distribution_registry: Vec<(AccountId, U128)> = vec![];

                let mut requested_storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal_registry: Vec<(AccountId, U128)> = vec![];

                for validator_account_id in self.validating.validator_registry.keys() {
                    if !investor_investment.distribution_registry.contains_key(&validator_account_id) {
                        requested_storage_staking_price_per_distribution_registry.push((validator_account_id, storage_staking_price_per_validating_node_distribution.into()));
                    } else {
                        requested_storage_staking_price_per_distribution_registry.push((validator_account_id.clone(), 0.into()));

                        if !self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.contains_key(&validator_account_id) {
                            requested_storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal_registry.push((validator_account_id, storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal.into()));
                        } else {
                            requested_storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal_registry.push((validator_account_id, 0.into()));
                        }
                    }
                }

                (
                    Some((requested_storage_staking_price_per_fungible_token_account.into(), requested_storage_staking_price_per_distribution_registry)),
                    Some((requested_storage_staking_price_per_delayed_withdrawal_fund_delayed_withdrawal.into(), requested_storage_staking_price_per_delayed_withdrawal_fund_investment_withdrawal_registry))
                )
            }
            None => {
                (None, None)
            }
        };

        StorageStakingRequestedCoverage {
            per_method_deposit: per_method_deposit.into(),
            per_method_deposit_on_validator,
            per_method_delayed_withdraw: per_method_delayed_withdraw.into(),
            per_method_delayed_withdraw_from_validator
        }
    }

    fn internal_get_account_balance(&self, account_id: AccountId) -> AccountBalanceDto {
        match self.fungible_token.account_registry.get(&account_id) {
            Some(account_balance) => {
                let common_near_balance = self.convert_token_amount_to_near_amount(account_balance.token_amount)
                + account_balance.classic_near_amount
                + account_balance.investment_near_amount;

                match self.validating.investor_investment_registry.get(&account_id) {
                    Some(investor_investment) => {
                        if common_near_balance < investor_investment.staked_balance {
                            env::panic_str("Nonexecutable code. Near balance should be greater then or equal to investment near balance.");
                        }

                        let (mut investment_near_balance_token_coverage, remainder_near_amount) = self.convert_near_amount_to_token_amount(investor_investment.staked_balance);

                        if remainder_near_amount > 0 {
                            investment_near_balance_token_coverage += 1;
                        }

                        AccountBalanceDto {
                            base_account_balance: Some(
                                BaseAccountBalance {
                                    token_balance: account_balance.token_amount.into(),
                                    common_near_balance: common_near_balance.into(),
                                    classic_near_balance: (common_near_balance - investor_investment.staked_balance).into(),
                                    classic_near_balance_token_coverage: (account_balance.token_amount - investment_near_balance_token_coverage).into()
                                }
                            ),
                            investment_account_balance: Some(
                                InvestmentAccountBalance {
                                    near_balance: investor_investment.staked_balance.into(),
                                    near_balance_token_coverage: investment_near_balance_token_coverage.into()
                                }
                            )
                        }
                    }
                    None => {
                        AccountBalanceDto {
                            base_account_balance: Some(
                                BaseAccountBalance {
                                    token_balance: account_balance.token_amount.into(),
                                    common_near_balance: common_near_balance.into(),
                                    classic_near_balance: common_near_balance.into(),
                                    classic_near_balance_token_coverage: account_balance.token_amount.into(),
                                }
                            ),
                            investment_account_balance: None
                        }
                    }
                }
            }
            None => {
                match self.validating.investor_investment_registry.get(&account_id) {
                    Some(_) => {
                        AccountBalanceDto {
                            base_account_balance: None,
                            investment_account_balance: Some(
                                InvestmentAccountBalance {
                                    near_balance: 0.into(),
                                    near_balance_token_coverage: 0.into()
                                }
                            )
                        }
                    }
                    None => {
                        AccountBalanceDto {
                            base_account_balance: None,
                            investment_account_balance: None
                        }
                    }
                }
            }
        }
    }

    fn internal_get_fund(&self) -> FundDto {
        self.assert_epoch_is_synchronized();

        FundDto {
            classic_unstaked_balance: self.fund.classic_unstaked_balance.into(),
            classic_staked_balance: self.fund.classic_staked_balance.into(),
            investment_staked_balance: self.fund.investment_staked_balance.into(),
            common_staked_balance: self.fund.get_staked_balance().into(),
            common_balance: self.fund.get_common_balance().into()
        }
    }

    fn internal_get_fee_registry(&self) -> FeeRegistry {
        self.assert_epoch_is_synchronized();
        self.assert_authorized_management_only_by_manager();

        self.fee_registry.clone()
    }

    fn internal_get_fee_registry_light(&self) -> FeeRegistryLight {
        self.assert_epoch_is_synchronized();

        let reward_fee = match self.fee_registry.reward_fee {
            Some(ref reward_fee_) => Some(reward_fee_.self_fee.clone()),
            None => None
        };

        let instant_withdraw_fee = match self.fee_registry.instant_withdraw_fee {
            Some(ref instant_withdraw_fee_) => Some(instant_withdraw_fee_.self_fee.clone()),
            None => None
        };

        FeeRegistryLight {
            reward_fee,
            instant_withdraw_fee
        }
    }

    pub fn internal_get_current_epoch_height(&self) -> EpochHeightRegistry {
        EpochHeightRegistry {
            pool_epoch_height: self.current_epoch_height,
            network_epoch_height: env::epoch_height()
        }
    }

    pub fn internal_is_stake_distributed(&self) -> bool {
        self.fund.is_distributed_on_validators_in_current_epoch
    }

    pub fn internal_get_investor_investment(&self, account_id: AccountId) -> Option<InvestorInvestmentDto> {
        self.assert_epoch_is_synchronized();

        let mut distribution_registry: Vec<(AccountId, U128)> = vec![];

        let investor_investment = match self.validating.investor_investment_registry.get(&account_id) {
            Some(investor_investment_) => investor_investment_,
            None => {
                return None;
            }
        };

        for validator_account_id in self.validating.validator_registry.keys() {
            if let Some(staked_balance) = investor_investment.distribution_registry.get(&validator_account_id) {
                distribution_registry.push((validator_account_id, staked_balance.into()));
            }
        }

        Some(
            InvestorInvestmentDto {
                distribution_registry,
                staked_balance: investor_investment.staked_balance.into()
            }
        )
    }

    fn internal_get_validator_registry(&self) -> Vec<ValidatorDto> {
        let mut validator_dto_registry: Vec<ValidatorDto> = vec![];

        for (account_id, validator) in self.validating.validator_registry.into_iter() {
            validator_dto_registry.push(
                ValidatorDto {
                    account_id,
                    unstaked_balance: validator.balance.requested_to_withdrawal_near_amount.into(),
                    classic_staked_balance: validator.balance.classic_near_amount.into(),
                    investment_staked_balance: validator.balance.investment_near_amount.into(),
                    is_only_for_investment: validator.is_only_for_investment,
                    last_update_epoch_height: validator.last_update_epoch_height,
                    last_classic_stake_increasing_epoch_height: validator.last_classic_stake_increasing_epoch_height
                }
            );
        }

        validator_dto_registry
    }

    fn internal_get_preffered_validator(&self) -> Option<ValidatorDto> {
        if let Some(ref preffered_validator_account_id) = self.validating.preffered_validator {
            let validator = match self.validating.validator_registry.get(preffered_validator_account_id) {
                Some(validator_) => validator_,
                None => {
                    env::panic_str("Nonexecutable code. Object must exist.");
                }
            };

            return Some(
                ValidatorDto {
                    account_id: preffered_validator_account_id.clone(),
                    unstaked_balance: validator.balance.requested_to_withdrawal_near_amount.into(),
                    classic_staked_balance: validator.balance.classic_near_amount.into(),
                    investment_staked_balance: validator.balance.investment_near_amount.into(),
                    is_only_for_investment: validator.is_only_for_investment,
                    last_update_epoch_height: validator.last_update_epoch_height,
                    last_classic_stake_increasing_epoch_height: validator.last_classic_stake_increasing_epoch_height
                }
            )
        }

        None
    }

    fn internal_get_aggregated(&self) -> Aggregated {
        self.assert_epoch_is_synchronized();

        Aggregated {
            unstaked_balance: self.fund.classic_unstaked_balance.into(),
            staked_balance: self.fund.get_staked_balance().into(),
            token_total_supply: self.fungible_token.total_supply.into(),
            token_accounts_quantity: self.fungible_token.accounts_quantity,
            total_rewards_from_validators_near_amount: self.reward.total_rewards_from_validators_near_amount.into(),
            reward_fee: self.get_fee_registry_light().reward_fee
        }
    }

    fn internal_get_requested_to_withdrawal_fund(&self) -> RequestedToWithdrawalFund {
        let mut investment_withdrawal_registry: Vec<(AccountId, U128)> = vec![];

        for validator_account_id in self.validating.validator_registry.keys() {
            if let Some(investment_withdrawal) = self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.get(&validator_account_id) {
                investment_withdrawal_registry.push((validator_account_id, investment_withdrawal.near_amount.into()))
            }
        }

        RequestedToWithdrawalFund {
            classic_near_amount: self.fund.delayed_withdrawn_fund.needed_to_request_classic_near_amount.into(),
            investment_near_amount: self.fund.delayed_withdrawn_fund.needed_to_request_investment_near_amount.into(),
            investment_withdrawal_registry
        }
    }

    pub fn internal_get_full(&self) -> Full {
        self.assert_epoch_is_synchronized();

        Full {
            storage_staking_price: self.internal_get_storage_staking_price(),
            fund: self.internal_get_fund(),
            total_token_supply: self.internal_get_total_token_supply().into(),
            requested_to_withdrawal_fund: self.internal_get_requested_to_withdrawal_fund(),
            fee_registry_light: self.internal_get_fee_registry_light(),
            minimum_deposit_amount: self.get_minimum_deposit_amount()
        }
    }

    pub fn internal_get_full_for_account(&self, account_id: AccountId) -> FullForAccount {
        self.assert_epoch_is_synchronized();

        FullForAccount {
            full: self.internal_get_full(),
            account_balance: self.internal_get_account_balance(account_id.clone()),
            delayed_withdrawal_details: self.internal_get_delayed_withdrawal_details(account_id.clone()),
            investor_investment: self.get_investor_investment(account_id.clone()),
            storage_staking_requested_coverage: self.get_storage_staking_requested_coverage(account_id)
        }
    }

    fn internal_ft_total_supply(&self) -> Balance {
        self.fungible_token.total_supply
    }

    fn internal_ft_balance_of(&self, account_id: AccountId) -> Balance {
        match self.fungible_token.account_registry.get(&account_id) {
            Some(account_balance) => account_balance.token_amount,
            None => 0
        }
    }

    fn convert_near_amount_to_token_amount(&self, near_amount: Balance) -> (Balance, Balance) {
        let common_balance = self.fund.get_common_balance();

        if common_balance == 0 || near_amount == 0 || self.fungible_token.total_supply == 0 {
            return (near_amount, 0);
        }

        let token_amount = (
            U256::from(near_amount)
            * U256::from(self.fungible_token.total_supply)
            / U256::from(common_balance)
        ).as_u128();

        let remainder_near_amount = near_amount - self.convert_token_amount_to_near_amount(token_amount);

        (token_amount, remainder_near_amount)
    }

    fn convert_token_amount_to_near_amount(&self, token_amount: Balance) -> Balance {
        if self.fungible_token.total_supply == 0 || token_amount == 0 {
            return token_amount
        }

        (
            U256::from(token_amount)
            * U256::from(self.fund.get_common_balance())
            / U256::from(self.fungible_token.total_supply)
        ).as_u128()
    }

    fn assert_authorized_management_only_by_manager(&self) {
        if env::predecessor_account_id() != self.account_registry.manager_id {
            env::panic_str("Unauthorized management. Management must be carried out either by the manager of the pool.");
        }
    }

    fn assert_authorized_management(&self) {
        let predecessor_account_id = env::predecessor_account_id();

        if predecessor_account_id != self.account_registry.owner_id
            && predecessor_account_id != self.account_registry.manager_id {
            env::panic_str("Unauthorized management. Management must be carried out either by the owner or manager of the pool.");
        }
    }

    fn assert_natural_deposit() {
        if env::attached_deposit() == 0 {
            env::panic_str("Not natural attached deposit.");
        }
    }

    fn assert_minimum_deposit() {
        if env::attached_deposit() < MINIMUN_DEPOSIT_AMOUNT {
            env::panic_str("Attached deposit less then minimum required deposit.");
        }
    }

    fn assert_epoch_is_synchronized(&self) {
        if self.current_epoch_height != env::epoch_height() {
            env::panic_str("Epoch should be in synchronized state.");
        }
    }

    fn assert_epoch_is_desynchronized(&self) {
        if self.current_epoch_height == env::epoch_height() {
            env::panic_str("Epoch should be in desynchronized state.");
        }
    }

    fn assert_gas_is_enough() {
        if env::prepaid_gas() < (Gas::ONE_TERA * MINIMUM_NUMBER_OF_TGAS) {
            env::panic_str("Not enough Gas quantity.");
        }
    }

    fn is_right_epoch(epoch_height: EpochHeight) -> bool {
        (epoch_height % EPOCH_QUANTITY_FOR_VALIDATOR_UNSTAKE) == 0
    }

    fn calculate_storage_staking_price(quantity_of_bytes: StorageUsage) -> Balance {
        match Balance::from(quantity_of_bytes).checked_mul(env::storage_byte_cost()) {
            Some(storage_staking_price) => storage_staking_price,
            None => {
                env::panic_str("Calculation overflow.");
            }
        }
    }
}

#[near_bindgen]
impl StakePool {
    #[private]
    pub fn deposit_callback(
        &mut self,
        predecessor_account_id: AccountId,
        validator_account_id: AccountId,
        attached_deposit: Balance,
        near_amount: Balance,
        refundable_near_amount: Balance,
        token_amount: Balance,
        near_remainder: Balance,
        current_epoch_height: EpochHeight,
        storage_staking_price_per_additional_account: Balance
    ) {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };
                validator.balance.classic_near_amount += near_amount;
                validator.last_classic_stake_increasing_epoch_height = Some(current_epoch_height);
                self.validating.validator_registry.insert(&validator_account_id, &validator);

                self.fund.classic_staked_balance += near_amount;
            }
            _ => {
                self.fund.classic_unstaked_balance += near_amount;
            }
        }

        let mut account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
            Some(account_balance_) => account_balance_,
            None => {
                self.fungible_token.accounts_quantity += 1;

                AccountBalance {token_amount: 0, classic_near_amount: 0, investment_near_amount: 0}
            }
        };
        account_balance.token_amount += token_amount;
        account_balance.classic_near_amount += near_remainder;
        self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance);
        self.fungible_token.total_supply += token_amount;

        if refundable_near_amount > 0 {
            Promise::new(predecessor_account_id.clone())
                .transfer(refundable_near_amount);
        }

        let current_account_id_log = env::current_account_id();
        env::log_str(
            format!(
                "
                Deposited to @{} via @{} in {} epoch.
                Attached deposit is {} yoctoNear.
                Exchangeable deposit is {} yoctoNear.
                Reserved storage staking price is {} yoctoNear.
                Refundable deposit is {} yoctoNear.
                Old @{} total supply is {} yoctoStNear.
                Old @{} balance is {} yoctoNear.
                Old @{} balance is {} yoctoStNear.
                @{} received {} yoctoStNear.
                New @{} balance is {} yoctoStNear.
                New @{} balance is {} yoctoNear.
                New @{} total supply is {} yoctoStNear.
                ",
                &validator_account_id,
                &current_account_id_log,
                env::epoch_height(),
                attached_deposit,
                near_amount,
                storage_staking_price_per_additional_account,
                refundable_near_amount,
                &current_account_id_log,
                self.fungible_token.total_supply - token_amount,
                &current_account_id_log,
                self.fund.get_common_balance() - near_amount,
                &predecessor_account_id,
                account_balance.token_amount - token_amount,
                &predecessor_account_id,
                token_amount,
                &predecessor_account_id,
                account_balance.token_amount,
                &current_account_id_log,
                self.fund.get_common_balance(),
                &current_account_id_log,
                self.fungible_token.total_supply
            ).as_str()
        );
    }

    #[private]
    pub fn deposit_on_validator_callback(
        &mut self,
        predecessor_account_id: AccountId,
        validator_account_id: AccountId,
        near_amount: Balance,
        attached_deposit: Balance,
        refundable_near_amount: Balance,
        token_amount: Balance,
        near_remainder: Balance,
        storage_staking_price_per_additional_accounts: Balance
    ) -> bool {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };
                validator.balance.investment_near_amount += near_amount;
                self.validating.validator_registry.insert(&validator_account_id, &validator);

                let mut investor_investment = match self.validating.investor_investment_registry.get(&predecessor_account_id) {
                    Some(investor_investment_) => investor_investment_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };
                let mut staked_balance = match investor_investment.distribution_registry.get(&validator_account_id) {
                    Some(staked_balance_) => staked_balance_,
                    None => {
                        investor_investment.distributions_quantity += 1;

                        0
                    }
                };
                staked_balance += near_amount;
                investor_investment.distribution_registry.insert(&validator_account_id, &staked_balance);
                investor_investment.staked_balance += near_amount;
                self.validating.investor_investment_registry.insert(&predecessor_account_id, &investor_investment);

                let mut account_balance = match self.fungible_token.account_registry.get(&predecessor_account_id) {
                    Some(account_balance_) => account_balance_,
                    None => {
                        self.fungible_token.accounts_quantity += 1;

                        AccountBalance { token_amount: 0, classic_near_amount: 0, investment_near_amount: 0}
                    }
                };
                account_balance.token_amount += token_amount;
                account_balance.investment_near_amount += near_remainder;
                self.fungible_token.account_registry.insert(&predecessor_account_id, &account_balance);
                self.fungible_token.total_supply += token_amount;

                self.fund.investment_staked_balance += near_amount;

                if refundable_near_amount > 0 {
                    Promise::new(predecessor_account_id.clone())
                        .transfer(refundable_near_amount);
                }

                let current_account_id_log = env::current_account_id();
                env::log_str(
                    format!(
                        "
                        Deposited to @{} via @{} in {} epoch.
                        Attached deposit is {} yoctoNear.
                        Exchangeable deposit is {} yoctoNear.
                        Reserved storage staking price is {} yoctoNear.
                        Refundable deposit is {} yoctoNear.
                        Old @{} total supply is {} yoctoStNear.
                        Old @{} balance is {} yoctoNear.
                        Old @{} balance is {} yoctoStNear.
                        @{} received {} yoctoStNear.
                        New @{} balance is {} yoctoStNear.
                        New @{} balance is {} yoctoNear.
                        New @{} total supply is {} yoctoStNear.
                        ",
                        &validator_account_id,
                        &current_account_id_log,
                        env::epoch_height(),
                        attached_deposit,
                        near_amount,
                        storage_staking_price_per_additional_accounts,
                        refundable_near_amount,
                        &current_account_id_log,
                        self.fungible_token.total_supply - token_amount,
                        &current_account_id_log,
                        self.fund.get_common_balance() - near_amount,
                        &predecessor_account_id,
                        account_balance.token_amount - token_amount,
                        &predecessor_account_id,
                        token_amount,
                        &predecessor_account_id,
                        account_balance.token_amount,
                        &current_account_id_log,
                        self.fund.get_common_balance(),
                        &current_account_id_log,
                        self.fungible_token.total_supply
                    ).as_str()
                );

                true
            }
            _ => {
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit);

                false
            }
        }
    }

    #[private]
    pub fn increase_validator_stake_callback(
        &mut self,
        validator_account_id: AccountId,
        near_amount: Balance,
        current_epoch_height: EpochHeight
    ) -> bool {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                self.fund.classic_unstaked_balance -= near_amount;
                self.fund.classic_staked_balance += near_amount;

                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };
                validator.balance.classic_near_amount += near_amount;
                validator.last_classic_stake_increasing_epoch_height = Some(current_epoch_height);
                self.validating.validator_registry.insert(&validator_account_id, &validator);

                let current_account_id_log = env::current_account_id();
                env::log_str(
                    format!(
                        "
                        Increasing validator stake on validator @{} in {} epoch.
                        Old @{} classic Near amount on validator is {} yoctoNear.
                        Old @{} investment Near amount on validator is {} yoctoNear.
                        Old @{} unstaked Near amount on validator is {} yoctoNear.
                        Staking on validator with {} yoctoNear.
                        New @{} classic Near amount on validator is {} yoctoNear.
                        New @{} investment Near amount on validator is {} yoctoNear.
                        New @{} unstaked Near amount on validator is {} yoctoNear.
                        ",
                        validator_account_id,
                        env::epoch_height(),
                        current_account_id_log,
                        validator.balance.classic_near_amount - near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount,
                        near_amount,
                        current_account_id_log,
                        validator.balance.classic_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount,
                    ).as_str()
                );

                true
            }
            _ => {
                false
            }
        }
    }

    #[private]
    pub fn requested_decrease_validator_stake_callback_1(
        &mut self,
        validator_account_id: AccountId,
        near_amount: Balance,
        stake_decreasing_type: StakeDecreasingType,
        refundable_near_amount: Balance
    ) -> PromiseOrValue<CallbackResult> {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(data) => {
                let unstaked_balance: Balance = match near_sdk::serde_json::from_slice::<U128>(data.as_slice()) {
                    Ok(unstaked_balance_) => unstaked_balance_.into(),
                    Err(_) => {
                        env::panic_str("Nonexecutable code. It should be valid JSON object.");
                    }
                };

                let validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };

                let unstaked_remainder = unstaked_balance - validator.balance.requested_to_withdrawal_near_amount;

                let needed_to_unstake_near_amount = near_amount - unstaked_remainder;

                match validator.staking_contract_version {
                    StakingContractVersion::Core => {
                        PromiseOrValue::Promise(
                            classic_validator::ext(validator_account_id.clone())
                                .unstake(needed_to_unstake_near_amount.into())
                                .then(
                                    Self::ext(env::current_account_id())
                                        .requested_decrease_validator_stake_callback_2(
                                            validator_account_id,
                                            near_amount,
                                            stake_decreasing_type,
                                            refundable_near_amount,
                                        )
                                )
                        )
                    }
                }
            }
            _ => {
                PromiseOrValue::Value(
                    CallbackResult {
                        is_success: false,
                        network_epoch_height: env::epoch_height()
                    }
                )
            }
        }
    }

    #[private]
    pub fn requested_decrease_validator_stake_callback_2(
        &mut self,
        validator_account_id: AccountId,
        near_amount: Balance,
        stake_decreasing_type: StakeDecreasingType,
        refundable_near_amount: Balance
    ) -> CallbackResult {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };

                let classic_near_amount_log = validator.balance.classic_near_amount;

                let investment_near_amount_log = validator.balance.investment_near_amount;

                match stake_decreasing_type {
                    StakeDecreasingType::Classic => {
                        validator.balance.classic_near_amount -= near_amount;
                        self.fund.delayed_withdrawn_fund.needed_to_request_classic_near_amount -= near_amount;
                    }
                    StakeDecreasingType::Investment => {
                        let mut investment_withdrawal = match self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.get(&validator_account_id) {
                            Some(investment_withdrawal_) => investment_withdrawal_,
                            None => {
                                env::panic_str("Nonexecutable code. Object must exist.");
                            }
                        };
                        if near_amount < investment_withdrawal.near_amount {
                            investment_withdrawal.near_amount -= near_amount;

                            self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.insert(&validator_account_id, &investment_withdrawal);
                        } else {
                            self.fund.delayed_withdrawn_fund.investment_withdrawal_registry.remove(&validator_account_id);

                            Promise::new(investment_withdrawal.account_id)
                                .transfer(refundable_near_amount);
                        }

                        validator.balance.investment_near_amount -= near_amount;
                        self.fund.delayed_withdrawn_fund.needed_to_request_investment_near_amount -= near_amount;
                    }
                }

                validator.balance.requested_to_withdrawal_near_amount += near_amount;
                self.validating.validator_registry.insert(&validator_account_id, &validator);

                let current_account_id_log = env::current_account_id();
                env::log_str(
                    format!(
                        "
                        Requested decreasing validator stake from validator @{} in {} epoch.
                        Old @{} classic Near amount on validator is {} yoctoNear.
                        Old @{} investment Near amount on validator is {} yoctoNear.
                        Old @{} unstaked Near amount on validator is {} yoctoNear.
                        Requested to unstake from validator is {} yoctoNear.
                        New @{} classic Near amount on validator is {} yoctoNear.
                        New @{} investment Near amount on validator is {} yoctoNear.
                        New @{} unstaked Near amount on validator is {} yoctoNear.
                        ",
                        validator_account_id,
                        env::epoch_height(),
                        current_account_id_log,
                        classic_near_amount_log,
                        current_account_id_log,
                        investment_near_amount_log,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount - near_amount,
                        near_amount,
                        current_account_id_log,
                        validator.balance.classic_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount,
                    ).as_str()
                );

                CallbackResult {
                    is_success: true,
                    network_epoch_height: env::epoch_height()
                }
            }
            _ => {
                CallbackResult {
                    is_success: false,
                    network_epoch_height: env::epoch_height()
                }
            }
        }
    }

    #[private]
    pub fn take_unstaked_balance_callback(
        &mut self,
        validator_account_id: AccountId,
        requested_to_withdrawal_near_amount: Balance
    ) -> CallbackResult {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };

                self.fund.delayed_withdrawn_fund.balance += requested_to_withdrawal_near_amount;

                validator.balance.requested_to_withdrawal_near_amount -= requested_to_withdrawal_near_amount;
                self.validating.validator_registry.insert(&validator_account_id, &validator);

                let current_account_id_log = env::current_account_id();
                env::log_str(
                    format!(
                        "
                        Taking unstaked balance from validator @{} in {} epoch.
                        Old @{} classic Near amount on validator is {} yoctoNear.
                        Old @{} investment Near amount on validator is {} yoctoNear.
                        Old @{} unstaked Near amount on validator is {} yoctoNear.
                        Received Near amount from validator is {} yoctoNear.
                        New @{} classic Near amount on validator is {} yoctoNear.
                        New @{} investment Near amount on validator is {} yoctoNear.
                        New @{} unstaked Near amount on validator is {} yoctoNear.
                        ",
                        validator_account_id,
                        env::epoch_height(),
                        current_account_id_log,
                        validator.balance.classic_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount + requested_to_withdrawal_near_amount,
                        requested_to_withdrawal_near_amount,
                        current_account_id_log,
                        validator.balance.classic_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount
                    ).as_str()
                );

                CallbackResult {
                    is_success: true,
                    network_epoch_height: env::epoch_height()
                }
            }
            _ => {
                CallbackResult {
                    is_success: false,
                    network_epoch_height: env::epoch_height()
                }
            }
        }
    }

    #[private]
    pub fn update_validator_callback(
        &mut self,
        validator_account_id: AccountId,
        current_epoch_height: EpochHeight
    ) -> CallbackResult {
        if env::promise_results_count() == 0 {
            env::panic_str("Contract expected a result on the callback.");
        }

        match env::promise_result(0) {
            PromiseResult::Successful(data) => {
                let new_balance: u128 = match near_sdk::serde_json::from_slice::<U128>(data.as_slice()) {
                    Ok(new_balance_) => new_balance_.into(),
                    Err(_) => {
                        env::panic_str("Nonexecutable code. It should be valid JSON object.");
                    }
                };

                let mut validator = match self.validating.validator_registry.get(&validator_account_id) {
                    Some(validator_) => validator_,
                    None => {
                        env::panic_str("Nonexecutable code. Object must exist.");
                    }
                };

                let staking_rewards_near_amount = new_balance - validator.balance.get_balance();

                validator.last_update_epoch_height = current_epoch_height;
                validator.balance.classic_near_amount += staking_rewards_near_amount;

                self.validating.validator_registry.insert(&validator_account_id, &validator);
                self.validating.quantity_of_validators_updated_in_current_epoch += 1;

                self.reward.previous_epoch_rewards_from_validators_near_amount += staking_rewards_near_amount;

                let current_account_id_log = env::current_account_id();
                env::log_str(
                    format!(
                        "
                        Updating validator @{} from {} epoch to {} epoch.
                        Old @{} classic Near amount on validator is {} yoctoNear.
                        Old @{} investment Near amount on validator is {} yoctoNear.
                        Old @{} unstaked near amount from validator is {} yoctoNear.
                        Received on validator Near amount is {} yoctoNear.
                        New @{} classic Near amount on validator is {} yoctoNear.
                        New @{} investment Near amount on validator is {} yoctoNear.
                        New @{} unstaked near amount from validator is {} yoctoNear.
                        ",
                        validator_account_id,
                        current_epoch_height - 1,
                        current_epoch_height,
                        current_account_id_log,
                        validator.balance.classic_near_amount - staking_rewards_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount,
                        staking_rewards_near_amount,
                        current_account_id_log,
                        validator.balance.classic_near_amount,
                        current_account_id_log,
                        validator.balance.investment_near_amount,
                        current_account_id_log,
                        validator.balance.requested_to_withdrawal_near_amount
                    ).as_str()
                );

                CallbackResult {
                    is_success: true,
                    network_epoch_height: env::epoch_height()
                }
            }
            _ => {
                CallbackResult {
                    is_success: false,
                    network_epoch_height: env::epoch_height()
                }
            }
        }
    }
}
'''
'''--- source/staking_contract_version.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

/// Do not change the order of variants.
/// The number of options must be less than or equal to 256 (1 byte).
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum StakingContractVersion {
    /// For https://github.com/near/core-contracts/tree/master/staking-pool contracts.
    Core
}
'''
'''--- source/storage_key.rs ---
use near_sdk::AccountId;
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::BorshStorageKey;

/// Do not change the order of variants.
/// The number of options must be less than or equal to 256 (1 byte).
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    InvestorInvestment,
    FungibleToken,
    FungibleTokenMetadata,
    Validator,
    DelayedWithdrawnFund,
    Distribution {
        investor_account_id: AccountId
    },
    InvestmentWithdrawal
}
'''
'''--- source/validating.rs ---
use near_sdk::{env, StorageUsage, AccountId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, LookupMap};
use super::get_account_id_with_maximum_length;
use super::investor_investment::InvestorInvestment;
use super::staking_contract_version::StakingContractVersion;
use super::storage_key::StorageKey;
use super::validator::Validator;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Validating {
    /// Storage.
    /// AccountId - validator account id.
    pub validator_registry: UnorderedMap<AccountId, Validator>,
    /// Registry of investors who are allowed to make an deposit/withdrawal directly on/from the validator.
    pub investor_investment_registry: LookupMap<AccountId, InvestorInvestment>,
    pub validators_quantity: u64,
    pub preffered_validator: Option<AccountId>,
    pub quantity_of_validators_updated_in_current_epoch: u64,
    /// In bytes.
    pub storage_usage_per_validator: StorageUsage,
    /// In bytes.
    pub storage_usage_per_investor_investment: StorageUsage,
    /// In bytes.
    pub storage_usage_per_distribution: StorageUsage
}

impl Validating {
    pub fn new() -> Self {
        Self {
            validator_registry: Self::initialize_validator_registry(),
            investor_investment_registry: Self::initialize_investor_investment_registry(),
            validators_quantity: 0,
            preffered_validator: None,
            quantity_of_validators_updated_in_current_epoch: 0,
            storage_usage_per_validator: Self::calculate_storage_usage_per_additional_validator(),
            storage_usage_per_investor_investment: Self::calculate_storage_usage_per_additional_investor_investment(),
            storage_usage_per_distribution: Self::calculate_storage_usage_per_additional_distribution()
        }
    }

    fn calculate_storage_usage_per_additional_validator() -> StorageUsage {
        let mut validator_registry = Self::initialize_validator_registry();

        let initial_storage_usage = env::storage_usage();

        let account_id = get_account_id_with_maximum_length();

        validator_registry.insert(
            &account_id, &Validator::new(StakingContractVersion::Core, false)
        );

        env::storage_usage() - initial_storage_usage
    }

    fn calculate_storage_usage_per_additional_investor_investment() -> StorageUsage {
        let mut investor_investment_registry = Self::initialize_investor_investment_registry();

        let initial_storage_usage = env::storage_usage();

        let account_id = get_account_id_with_maximum_length();

        investor_investment_registry.insert(&account_id, &InvestorInvestment::new(account_id.clone()));

        env::storage_usage() - initial_storage_usage
    }

    fn calculate_storage_usage_per_additional_distribution() -> StorageUsage {
        let account_id = get_account_id_with_maximum_length();

        let mut distribution_registry = InvestorInvestment::initialize_distribution_registry(account_id.clone());

        let initial_storage_usage = env::storage_usage();

        distribution_registry.insert(&account_id, &0);

        env::storage_usage() - initial_storage_usage
    }

    fn initialize_validator_registry() -> UnorderedMap<AccountId, Validator> {
        UnorderedMap::new(StorageKey::Validator)
    }

    fn initialize_investor_investment_registry() -> LookupMap<AccountId, InvestorInvestment> {
        LookupMap::new(StorageKey::InvestorInvestment)
    }
}
'''
'''--- source/validator.rs ---
use near_sdk::{env, EpochHeight};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use super::staking_contract_version::StakingContractVersion;
use super::validator_balance::ValidatorBalance;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Validator {
    pub balance: ValidatorBalance,
    pub staking_contract_version: StakingContractVersion,
    /// Validator, which is needed ONLY for investment purpose.
    /// The pool should not distribute unstaked balance to validators with a TRUE value,
    /// and this means, that classic staked balance must always be equal to zero and investment
    /// staked balance can be greater than zero. The pool should distribute unstaked balance
    /// only to validators with a FALSE value, and it is also possible to use the validator for
    /// investment purposes, this means, that classic staked balance and investment staked balance
    /// can be greater than zero.
    pub is_only_for_investment: bool,
    pub last_update_epoch_height: EpochHeight,
    pub last_classic_stake_increasing_epoch_height: Option<EpochHeight>
}

impl Validator {
    pub fn new(
        staking_contract_version: StakingContractVersion,
        is_only_for_investment: bool
    ) -> Self {
        Self {
            balance: ValidatorBalance {
                classic_near_amount: 0,
                investment_near_amount: 0,
                requested_to_withdrawal_near_amount: 0
            },
            staking_contract_version,
            is_only_for_investment,
            last_update_epoch_height: env::epoch_height(),
            last_classic_stake_increasing_epoch_height: None
        }
    }
}
'''
'''--- source/validator_balance.rs ---
use near_sdk::Balance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ValidatorBalance {
    /// Classic part of valdator total Near amount.
    pub classic_near_amount: Balance,
    /// Investment part of valdator total Near amount.
    pub investment_near_amount: Balance,
    /// Requested to withdrawal Near amount.
    pub requested_to_withdrawal_near_amount: Balance
}

impl ValidatorBalance {
    pub fn get_balance(&self) -> Balance {
        self.classic_near_amount + self.investment_near_amount + self.requested_to_withdrawal_near_amount
    }
}
'''