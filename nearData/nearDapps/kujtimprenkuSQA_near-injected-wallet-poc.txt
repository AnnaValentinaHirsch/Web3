*GitHub Repository "kujtimprenkuSQA/near-injected-wallet-poc"*

'''--- README.md ---
# NEAR Injected Wallet (POC)

This is POC for the NEAR Injected Wallet standard.

## Getting Started

To get up and running with this project, you will need to run the following.

```shell
yarn install # Install packages.
yarn start # Bundle modules and serve at localhost:1234.
```

Once the project has been bundled, you can open your browser at `localhost:1234` and play around with the POC in the developer console via `window.near.wallet`.

Although out of scope for the standard, it's important that we have accounts imported in the wallet to use any of the methods:

```ts
// Note: This demo is hardcoded to the testnet network. 
window.near.wallet._restore({
  accountId: "test.testnet",
  mnemonic: "mnemonic encoding of a FullAccess key pair linked to the accountId",
});
```

'''
'''--- package.json ---
{
  "name": "near-injected-wallet-poc",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "source": "src/index.html",
  "license": "MIT",
  "author": {
    "name": "Lewis Barnes"
  },
  "scripts": {
    "start": "parcel",
    "build": "parcel build"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "buffer": "^6.0.3",
    "crypto-browserify": "^3.12.0",
    "events": "^3.3.0",
    "parcel": "^2.4.0",
    "process": "^0.11.10",
    "stream-browserify": "^3.0.0",
    "typescript": "^4.6.3"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "js-sha256": "^0.9.0",
    "near-api-js": "^0.44.2",
    "near-seed-phrase": "^0.2.0"
  }
}

'''
'''--- src/TestWallet.ts ---
import {
  InMemorySigner,
  KeyPair,
  keyStores,
  providers,
  utils,
  transactions as nearTransactions
} from "near-api-js";
import { AccessKeyView } from "near-api-js/lib/providers/provider";
// @ts-ignore.
import { parseSeedPhrase } from "near-seed-phrase";

import { Network, Wallet } from "./Wallet.types";
import { WalletState } from "./TestWallet.types";
import * as storage from "./utils/storage";
import * as restore from "./utils/restore";
import * as format from "./utils/format";

const network: Network = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

const loadState = (): WalletState => {
  const state = storage.getJsonItem<WalletState>("wallet_state");

  if (!state) {
    return {
      accounts: [],
    };
  }

  return state;
}

export function TestWallet(): Wallet {
  const keyStore = new keyStores.BrowserLocalStorageKeyStore();
  const signer = new InMemorySigner(keyStore);
  let state = loadState();

  const setState = (reducer: (prevState: WalletState) => WalletState) => {
    const nextState = reducer(state);

    state = nextState;
    storage.setJsonItem("wallet_state", nextState);
  }

  return {
    // Exposed for testing.
    // @ts-ignore:next-line
    get _state() {
      return state;
    },
    // Exposed for testing.
    // @ts-ignore:next-line
    get _keyStore() {
      return keyStore;
    },
    get id() {
      return "wallet";
    },
    get connected() {
      return Boolean(state.accounts.length);
    },
    get network() {
      return { ...network };
    },
    get accounts() {
      return state.accounts.map((account) => ({
        ...account,
        publicKey: utils.PublicKey.from(account.publicKey)
      }));
    },
    // Exposed for testing
    _restore: async ({ accountId, mnemonic }) => {
      const keyPair = await keyStore.getKey(network.networkId, accountId);

      if (keyPair) {
        throw new Error("Account already restored");
      }

      const { publicKey, secretKey } = parseSeedPhrase(mnemonic);
      await restore.validateAccessKey({ accountId, publicKey });

      await keyStore.setKey(
        network.networkId,
        accountId,
        KeyPair.fromString(secretKey)
      );

      console.log("Successfully restored account", { accountId, publicKey });
    },
    connect: async () => {
      const accountIds = await keyStore.getAccounts(network.networkId);
      const total = accountIds.length;

      if (!total) {
        throw new Error("No accounts imported. Use window.near.wallet._restore to import accounts");
      }

      console.log(`There are ${total} accounts(s) imported`);

      const accounts = await Promise.all(accountIds.map(async (accountId) => {
        const keyPair = await keyStore.getKey(network.networkId, accountId);

        return {
          accountId,
          publicKey: keyPair.getPublicKey(),
        };
      }))

      setState((prevState) => ({
        ...prevState,
        accounts: accounts.map((account) => ({
          ...account,
          publicKey: account.publicKey.toString()
        })),
      }));

      console.log("Selected all account(s)");

      return accounts;
    },
    disconnect: async () => {
      if (!state.accounts.length) {
        throw new Error("Not connected");
      }

      const total = state.accounts.length;

      setState((prevState) => ({
        ...prevState,
        accounts: [],
      }));

      console.log(`Removed visibility of ${total} account(s)`);
    },
    signTransaction: async ({ transaction }) => {
      const formattedTx = format.formatTransaction(transaction);

      const approved = confirm([
        "Permission to sign transaction?",
        JSON.stringify(formattedTx, null, 2),
      ].join("\n"))

      if (!approved) {
        throw new Error("User rejected signing");
      }

      const tx = nearTransactions.Transaction.decode(Buffer.from(transaction.encode()));
      const [, signedTx] = await nearTransactions.signTransaction(
        tx,
        signer,
        tx.signerId,
        network.networkId
      );

      return signedTx;
    },
    signTransactions: async ({ transactions }) => {
      const formattedTxs = transactions.map(format.formatTransaction);
      const signedTxs: Array<nearTransactions.SignedTransaction> = [];

      const approved = confirm([
        "Permission to sign transactions?",
        JSON.stringify(formattedTxs, null, 2),
      ].join("\n"))

      if (!approved) {
        throw new Error("User rejected signing");
      }

      for (let i = 0; i < transactions.length; i += 1) {
        const tx = nearTransactions.Transaction.decode(Buffer.from(transactions[i].encode()));
        const [, signedTx] = await nearTransactions.signTransaction(
          tx,
          signer,
          tx.signerId,
          network.networkId
        );

        signedTxs.push(signedTx);
      }

      return signedTxs;
    },
    signIn: async ({ permission, accounts }) => {
      const approved = confirm([
        `Permission to sign in to ${permission.receiverId} with the following accounts:`,
        accounts.map((account) => `- ${account.accountId}`),
      ].join("\n"));

      if (!approved) {
        throw new Error("User rejected sign in");
      }

      const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });
      const block = await provider.block({ finality: "final" });

      for (let i = 0; i < accounts.length; i += 1) {
        const account = accounts[i];

        const keyPair = await keyStore.getKey(network.networkId, account.accountId);
        const accessKey = await provider.query<AccessKeyView>({
          request_type: "view_access_key",
          finality: "final",
          account_id: account.accountId,
          public_key: keyPair.getPublicKey().toString(),
        });

        const transaction = nearTransactions.createTransaction(
          account.accountId,
          keyPair.getPublicKey(),
          account.accountId,
          accessKey.nonce + i + 1,
          [nearTransactions.addKey(
            utils.PublicKey.from(account.publicKey),
            nearTransactions.functionCallAccessKey(
              permission.receiverId,
              permission.methodNames,
              permission.allowance
            )
          )],
          utils.serialize.base_decode(block.header.hash)
        );

        const [, signedTx] = await nearTransactions.signTransaction(
          transaction,
          signer,
          transaction.signerId,
          network.networkId
        );

        await provider.sendTransaction(signedTx);
      }
    },
    signOut: async ({ accounts }) => {
      const approved = confirm([
        `Permission to sign out of the following accounts:`,
        accounts.map((account) => `- ${account.accountId}`),
      ].join("\n"));

      if (!approved) {
        throw new Error("User rejected sign out");
      }

      const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });
      const block = await provider.block({ finality: "final" });

      for (let i = 0; i < accounts.length; i += 1) {
        const account = accounts[i];

        const keyPair = await keyStore.getKey(network.networkId, account.accountId);
        const accessKey = await provider.query<AccessKeyView>({
          request_type: "view_access_key",
          finality: "final",
          account_id: account.accountId,
          public_key: keyPair.getPublicKey().toString(),
        });

        const transaction = nearTransactions.createTransaction(
          account.accountId,
          keyPair.getPublicKey(),
          account.accountId,
          accessKey.nonce + i + 1,
          [nearTransactions.deleteKey(utils.PublicKey.from(account.publicKey))],
          utils.serialize.base_decode(block.header.hash)
        );

        const [, signedTx] = await nearTransactions.signTransaction(
          transaction,
          signer,
          transaction.signerId,
          network.networkId
        );

        await provider.sendTransaction(signedTx);
      }
    },
    on: () => {
      throw new Error("Not implemented");
    },
    off: () => {
      throw new Error("Not implemented");
    }
  }
}

'''
'''--- src/TestWallet.types.ts ---
export interface AccountState {
  accountId: string;
  publicKey: string;
}

export interface WalletState {
  accounts: Array<AccountState>;
}

'''
'''--- src/Wallet.types.ts ---
import { transactions, utils } from "near-api-js";

export interface Account {
  accountId: string;
  publicKey: utils.PublicKey;
}

export interface Network {
  networkId: string;
  nodeUrl: string;
}

interface RestoreParams {
  accountId: string;
  mnemonic: string;
}

interface SignInParams {
  permission: transactions.FunctionCallPermission;
  accounts: Array<Account>;
}

interface SignOutParams {
  accounts: Array<Account>;
}

interface SignTransactionParams {
  transaction: transactions.Transaction;
}

interface SignTransactionsParams {
  transactions: Array<transactions.Transaction>;
}

interface Events {
  accountsChanged: { accounts: Array<Account> };
  networkChanged: { network: Network };
}

type Unsubscribe = () => void;

export interface Wallet {
  id: string;
  connected: boolean;
  network: Network;
  accounts: Array<Account>;

  _restore(params: RestoreParams): Promise<void>;

  connect(): Promise<Array<Account>>;
  signIn(params: SignInParams): Promise<void>;
  signOut(params: SignOutParams): Promise<void>;
  signTransaction(params: SignTransactionParams): Promise<transactions.SignedTransaction>;
  signTransactions(params: SignTransactionsParams): Promise<Array<transactions.SignedTransaction>>;
  disconnect(): Promise<void>;
  on<EventName extends keyof Events>(
    event: EventName,
    callback: (params: Events[EventName]) => void
  ): Unsubscribe;
  off<EventName extends keyof Events>(
    event: EventName,
    callback?: () => void
  ): void;
}

'''
'''--- src/index.html ---
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>NEAR Injected Wallet</title>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <script type="module" src="./main.ts"></script>
</body>
</html>

'''
'''--- src/main.ts ---
import { keyStores, transactions, providers, utils } from "near-api-js";
import { AccessKeyView } from "near-api-js/lib/providers/provider";

import { TestWallet } from "./TestWallet";
import { Wallet } from "./Wallet.types";

declare global {
  interface Window {
    near: Record<string, Wallet>;
  }
}

setTimeout(() => {
  if (!window.near) {
    window.near = {};
  }

  window.near.wallet = TestWallet();

  // @ts-ignore
  window._testSignAndSendTransaction = async () => {
    if (!window.near.wallet.connected) {
      await window.near.wallet.connect();
    }

    // Retrieve accounts (assuming already connected) and current network.
    const { network, accounts } = window.near.wallet;

    // Setup RPC to retrieve transaction-related prerequisites.
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    const [block, accessKey] = await Promise.all([
      provider.block({ finality: "final" }),
      provider.query<AccessKeyView>({
        request_type: "view_access_key",
        finality: "final",
        account_id: accounts[0].accountId,
        public_key: accounts[0].publicKey.toString(),
      }),
    ]);

    const signedTx = await window.near.wallet.signTransaction({
      transaction: transactions.createTransaction(
        accounts[0].accountId,
        accounts[0].publicKey,
        "guest-book.testnet",
        accessKey.nonce + 1,
        [transactions.functionCall(
          "addMessage",
          { text: "Hello World!" },
          utils.format.parseNearAmount("0.00000000003"),
          utils.format.parseNearAmount("0")
        )],
        utils.serialize.base_decode(block.header.hash)
      ),
    });

    // Send the transaction to the blockchain.
    await provider.sendTransaction(signedTx);
  };

  // @ts-ignore
  window._testSignAndSendTransactions = async () => {
    if (!window.near.wallet.connected) {
      await window.near.wallet.connect();
    }

    // Retrieve accounts (assuming already connected) and current network.
    const { network, accounts } = window.near.wallet;

// Setup RPC to retrieve transaction-related prerequisites.
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    const [block, accessKey] = await Promise.all([
      provider.block({ finality: "final" }),
      provider.query<AccessKeyView>({
        request_type: "view_access_key",
        finality: "final",
        account_id: accounts[0].accountId,
        public_key: accounts[0].publicKey.toString(),
      }),
    ]);

    const signedTxs = await window.near.wallet.signTransactions({
      transactions: [
        transactions.createTransaction(
          accounts[0].accountId,
          accounts[0].publicKey,
          "guest-book.testnet",
          accessKey.nonce + 1,
          [transactions.functionCall(
            "addMessage",
            { text: "Hello World! (1/2)" },
            utils.format.parseNearAmount("0.00000000003"),
            utils.format.parseNearAmount("0.01")
          )],
          utils.serialize.base_decode(block.header.hash)
        ),
        transactions.createTransaction(
          accounts[0].accountId,
          accounts[0].publicKey,
          "guest-book.testnet",
          accessKey.nonce + 2,
          [transactions.functionCall(
            "addMessage",
            { text: "Hello World! (2/2)" },
            utils.format.parseNearAmount("0.00000000003"),
            utils.format.parseNearAmount("0.01")
          )],
          utils.serialize.base_decode(block.header.hash)
        )
      ]
    });

    for (let i = 0; i < signedTxs.length; i += 1) {
      const signedTx = signedTxs[i];

      // Send the transaction to the blockchain.
      await provider.sendTransaction(signedTx);
    }
  };

  // @ts-ignore
  window._testSignIn = async () => {
    // Setup keystore to locally store FunctionCall access keys.
    const keystore = new keyStores.BrowserLocalStorageKeyStore(
      window.localStorage,
      "dapp:keystore:"
    );

    // Retrieve the list of accounts we have visibility of.
    const { accounts, network } = window.near.wallet;

    if (!accounts.length) {
      throw new Error("No accounts to sign in to");
    }

    // Request FunctionCall access to the 'guest-book.testnet' smart contract for each account.
    await window.near.wallet.signIn({
      permission: {
        receiverId: "guest-book.testnet",
        methodNames: [],
      },
      accounts: await Promise.all(
        accounts.map(async ({ accountId }) => {
          const keyPair = utils.KeyPair.fromRandom("ed25519");
          await keystore.setKey(network.networkId, accountId, keyPair);

          return {
            accountId,
            publicKey: keyPair.getPublicKey()
          };
      })
      ),
    });
  };

  // @ts-ignore
  window._testSignOut = async () => {
    // Setup keystore to retrieve locally stored FunctionCall access keys.
    const keystore = new keyStores.BrowserLocalStorageKeyStore(
      window.localStorage,
      "dapp:keystore:"
    );

    // Retrieve current network and accounts with FunctionCall access keys.
    const { network } = window.near.wallet;
    const accountIds = await keystore.getAccounts(network.networkId);

    if (!accountIds.length) {
      throw new Error("No accounts to sign out of");
    }

    // Remove FunctionCall access (previously granted via signIn) for each account.
    await window.near.wallet.signOut({
      accounts: await Promise.all(
        accountIds.map(async (accountId) => {
          const keyPair = await keystore.getKey(network.networkId, accountId);

          return {
            accountId,
            publicKey: keyPair.getPublicKey()
          };
        })
      ),
    });
  };

  console.log("Successfully injected test wallet under window.near.wallet");
}, 500);

'''
'''--- src/utils/format.ts ---
import { transactions } from "near-api-js";

export const formatTransaction = (transaction: transactions.Transaction) => {
  return {
    signerId: transaction.signerId,
    receiverId: transaction.receiverId,
    actions: transaction.actions.map((action) => {
      switch (action.enum) {
        case "createAccount": {
          return {
            type: "CreateAccount",
            params: action.createAccount
          };
        }
        case "deployContract": {
          return {
            type: "DeployContract",
            params: {
              ...action.deployContract,
              args: Buffer.from(action.deployContract.code).toString(),
            }
          };
        }
        case "functionCall": {
          return {
            type: "FunctionCall",
            params: {
              ...action.functionCall,
              args: JSON.parse(Buffer.from(action.functionCall.args).toString()),
            }
          };
        }
        case "transfer": {
          return {
            type: "Transfer",
            params: action.transfer
          };
        }
        case "stake": {
          return {
            type: "Stake",
            params: {
              ...action.stake,
              publicKey: action.stake.publicKey.toString()
            }
          };
        }
        case "addKey": {
          return {
            type: "AddKey",
            params: {
              ...action.addKey,
              publicKey: action.addKey.publicKey.toString()
            }
          };
        }
        case "deleteKey": {
          return {
            type: "DeleteKey",
            params: {
              ...action.deleteKey,
              publicKey: action.deleteKey.publicKey.toString()
            }
          };
        }
        case "deleteAccount": {
          return {
            type: "DeleteAccount",
            params: action.deleteAccount
          };
        }
        default: {
          return {
            type: action.enum,
            params: action[action.enum]
          };
        }
      }
    })
  }
}

'''
'''--- src/utils/restore.ts ---
import { providers } from "near-api-js";
import { AccessKeyView } from "near-api-js/lib/providers/provider";

interface ValidateAccessKeyParams {
  accountId: string;
  publicKey: string;
}

export const validateAccessKey = ({ accountId, publicKey }: ValidateAccessKeyParams) => {
  const provider = new providers.JsonRpcProvider({ url: "https://rpc.testnet.near.org" });

  return provider.query<AccessKeyView>({
    request_type: "view_access_key",
    finality: "final",
    account_id: accountId,
    public_key: publicKey
  }).then(
    (accessKey) => {
      if (accessKey.permission !== "FullAccess") {
        throw new Error("Public key requires 'FullAccess' permission");
      }

      return accessKey;
    },
    (err) => {
      if (err instanceof providers.TypedError && err.type === "AccessKeyDoesNotExist") {
        return null;
      }

      throw err;
    }
  );
}

'''
'''--- src/utils/storage.ts ---
export const getJsonItem = <Value extends unknown>(key: string) => {
  const item = localStorage.getItem(key);

  return item ? JSON.parse(item) as Value : null;
}

export const setJsonItem = (key: string, value: unknown) => {
  localStorage.setItem(key, JSON.stringify(value));
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["es6", "dom", "es2016", "es2017"],
    "declaration": true,
    "moduleResolution": "node",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "esModuleInterop": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "suppressImplicitAnyIndexErrors": true,
    "allowSyntheticDefaultImports": true
  },
  "include": [
    "src"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}

'''