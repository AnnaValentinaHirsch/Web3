*GitHub Repository "pmarangone/near-debugging"*

'''--- 1-sim-tests/Cargo.toml ---
[package]
name = "unit-testing"
version = "0.0.0"
authors = ["pmarangone"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs", tag = "4.0.0-pre.6"}

[dev-dependencies]
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs", tag = "4.0.0-pre.6"}

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []

'''
'''--- 1-sim-tests/build.sh ---
#!/bin/bash
set -e

if [ -d "res" ]; then
  echo ""
else
  mkdir res
fi

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release

cp ./target/wasm32-unknown-unknown/release/unit_testing.wasm ./res/

'''
'''--- 1-sim-tests/run.sh ---
# build wasm
./build.sh

#Deploy with near-dev
near dev-deploy --wasmFile ./res/unit_testing.wasm

source neardev/dev-account.env
echo $CONTRACT_NAME

username=''
echo $username
 
#### Initialize contract
near call $CONTRACT_NAME new '{"owner_id":"'$username'", "placeholder": 0}' --accountId $username

#### Call say_hello
near call $CONTRACT_NAME say_hello --accountId $username
'''
'''--- 1-sim-tests/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{ext_contract, log, near_bindgen, AccountId, PanicOnDefault};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
    placeholder: u128,
}

#[ext_contract(ext_self)]
pub trait ExtContract {
    fn say_hello(&self);
}

#[near_bindgen]
impl Contract {
    /// Function that initialize the contract.
    ///
    /// Arguments:
    ///
    /// - `owner_id` - the account id that owns the contract
    /// - `placeholder` - symbolic number to demonstrate error when using `deploy!` near-sdk-sim
    #[init]
    pub fn new(owner_id: AccountId, placeholder: u128) -> Self {
        Self {
            owner_id: owner_id,
            placeholder,
        }
    }

    pub fn say_hello(&self) {
        log!("Hello world");
    }
}

'''
'''--- 1-sim-tests/tests/general.rs ---
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount};

extern crate unit_testing;
use unit_testing::ContractContract as Contract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TOKEN_WASM_BYTES => "./res/unit_testing.wasm",
}

const SOME_ID: &str = "unit_testing";

pub fn init_one(initial_balance: u128) -> (UserAccount, ContractAccount<Contract>) {
    let mut genesis = near_sdk_sim::runtime::GenesisConfig::default();
    genesis.gas_price = 0;
    genesis.gas_limit = u64::MAX;
    let master_account = init_simulator(Some(genesis));
    // uses default values for deposit and gas
    let contract = deploy!(
      // Contract Proxy
      contract: Contract,
      // Contract account id
      contract_id: SOME_ID,
      // Bytes of contract
      bytes: &TOKEN_WASM_BYTES,
      // User deploying the contract,
      signer_account: master_account,
      // init method
      init_method: new(
          master_account.account_id(),
          initial_balance
      )
    );

    (master_account, contract)
}

#[test]
fn first_test() {
    let initial_balance = to_yocto("0");
    let (root, contract) = init_one(initial_balance);

    let outcome = call!(root, contract.say_hello(), deposit = 1);
    outcome.assert_success();

    assert_eq!(outcome.logs()[0], "Hello world");
}

'''
'''--- 2-callbacks/Cargo.toml ---
[package]
name = "callback-results"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs", tag = "4.0.0-pre.6" }

[dev-dependencies]
workspaces = "0.1"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
anyhow = "1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

'''
'''--- 2-callbacks/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`"
cargo build --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/callback_results.wasm ./res/

'''
'''--- 2-callbacks/readme.md ---

Copy .env.example to .env and add your account to easily use it on run.sh
'''
'''--- 2-callbacks/run.sh ---
# build wasm
./build.sh

#Deploy with near-dev
near dev-deploy --wasmFile ./res/callback_results.wasm

source neardev/dev-account.env
echo $CONTRACT_NAME

source .env
echo $username

near call $CONTRACT_NAME call_all2 '{ "fail_b" : true, "c_value": 1 }' --accountId $username --gas 300000000000000
'''
'''--- 2-callbacks/src/lib.rs ---
use near_sdk::require;
use near_sdk::serde_json::json;
use near_sdk::AccountId;
use near_sdk::{env, ext_contract, near_bindgen, Promise, PromiseError, PromiseResult};

const A_VALUE: u8 = 8;

#[near_bindgen]
pub struct Callback;

// One can provide a name, e.g. `ext` to use for generated methods.
#[ext_contract(ext)]
pub trait ExtCrossContract {
    fn a() -> Promise;
    fn b(fail: bool) -> String;
    fn c(value: u8) -> u8;
    fn handle_callbacks(
        #[callback_result] a: Result<u8, PromiseError>,
        #[callback_result] b: Result<String, PromiseError>,
        #[callback_result] c: Result<u8, PromiseError>,
    ) -> (bool, bool, bool);
}

#[near_bindgen]
impl Callback {
    /// Call functions a, b, and c asynchronously and handle results with `handle_callbacks`.
    pub fn call_all(fail_b: bool, c_value: u8) -> Promise {
        let gas_per_promise = env::prepaid_gas() / 5;
        ext::a(env::current_account_id(), 0, gas_per_promise)
            .and(ext::b(
                fail_b,
                env::current_account_id(),
                0,
                gas_per_promise,
            ))
            .and(ext::c(
                c_value,
                env::current_account_id(),
                0,
                gas_per_promise,
            ))
            .then(ext::handle_callbacks(
                env::current_account_id(),
                0,
                gas_per_promise,
            ))
    }

    pub fn call_all2(fail_b: bool, c_value: u8) {
        let account_id: AccountId = env::current_account_id();
        let gas_per_promise = env::prepaid_gas() / 5;

        let promise0 = env::promise_create(
            account_id.clone(),
            "a",
            json!({}).to_string().as_bytes(),
            0,
            gas_per_promise,
        );
        let promise1 = env::promise_then(
            promise0,
            account_id.clone(),
            "b",
            json!({ "fail": fail_b.clone() }).to_string().as_bytes(),
            0,
            gas_per_promise,
        );
        let promise2 = env::promise_then(
            promise1,
            account_id.clone(),
            "c",
            json!({ "value": c_value }).to_string().as_bytes(),
            0,
            gas_per_promise,
        );
        env::promise_return(promise2);
    }

    /// Calls function c with a value that will always succeed
    pub fn a() -> Promise {
        ext::c(
            A_VALUE,
            env::current_account_id(),
            0,
            env::prepaid_gas() / 2,
        )
    }

    /// Returns a static string if fail is false, return
    #[private]
    pub fn b(fail: bool) -> &'static str {
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                env::log_str("Check_promise successful");
            }
            _ => env::panic_str("Promise with index 0 failed"),
        };
        if fail {
            env::panic_str("failed within function b");
        }
        "Some string"
    }

    /// Panics if value is 0, returns the value passed in otherwise.
    #[private]
    pub fn c(value: u8) -> u8 {
        match env::promise_results_count() {
            0 => {
                env::log_str("First time access");
            }
            1 => {
                match env::promise_result(0) {
                    PromiseResult::Successful(_) => {
                        env::log_str("Check_promise successful");
                    }
                    _ => env::panic_str("Promise with index 0 failed"),
                };
            }
            _ => env::panic_str("Unexpected error"),
        }
        require!(value > 0, "Value must be positive");
        return value;
    }

    /// Receives the callbacks from the other promises called.
    #[private]
    pub fn handle_callbacks(
        #[callback_unwrap] a: u8,
        #[callback_result] b: Result<String, PromiseError>,
        #[callback_result] c: Result<u8, PromiseError>,
    ) -> (bool, bool) {
        require!(a == A_VALUE, "Promise returned incorrect value");
        if let Ok(s) = b.as_ref() {
            require!(s == "Some string");
        }
        (b.is_err(), c.is_err())
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use tokio::fs;
    use workspaces::prelude::*;

    #[tokio::test]
    async fn workspaces_test() -> anyhow::Result<()> {
        let wasm = fs::read("res/callback_results.wasm").await?;

        let worker = workspaces::sandbox();

        let contract = worker.dev_deploy(wasm).await?;

        // Call function a only to ensure it has correct behaviour
        let res = contract.call(&worker, "a").transact().await?;
        assert_eq!(res.json::<u8>()?, 8);

        // Following tests the function call where the `call_all` function always succeeds and handles
        // the result of the async calls made from within the function with callbacks.

        // No failures
        let res = contract
            .call(&worker, "call_all")
            .args_json((false, 1u8))?
            .gas(300_000_000_000_000)
            .transact()
            .await?;
        assert_eq!(res.json::<(bool, bool)>()?, (false, false));

        // Fail b
        let res = contract
            .call(&worker, "call_all")
            .args_json((true, 1u8))?
            .gas(300_000_000_000_000)
            .transact()
            .await?;
        assert_eq!(res.json::<(bool, bool)>()?, (true, false));

        // Fail c
        let res = contract
            .call(&worker, "call_all")
            .args_json((false, 0u8))?
            .gas(300_000_000_000_000)
            .transact()
            .await?;
        assert_eq!(res.json::<(bool, bool)>()?, (false, true));

        // Fail both b and c
        let res = contract
            .call(&worker, "call_all")
            .args_json((true, 0u8))?
            .gas(300_000_000_000_000)
            .transact()
            .await?;
        assert_eq!(res.json::<(bool, bool)>()?, (true, true));

        Ok(())
    }
}

'''
'''--- 3-types-issues/Cargo.toml ---
[package]
name = "types_issues"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs", tag = "4.0.0-pre.9"}
uint = "0.9"

'''
'''--- 3-types-issues/README.md ---

'''
'''--- 3-types-issues/run.sh ---

#!/bin/bash
set -e

if [ -d "res" ]; then
  echo ""
else
  mkdir res
fi

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/types_issues.wasm res/

# #Deploy with near-dev
near dev-deploy --wasmFile res/types_issues.wasm

'''
'''--- 3-types-issues/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{log, near_bindgen};
use uint::construct_uint;

const VALUE: u128 = 199999999999999999999;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[near_bindgen]
#[derive(Default, BorshSerialize, BorshDeserialize)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    pub fn pprint_u128(&self) -> u128 {
        let x: u128 = 199999579045383882874;
        let y: u128 = 429189948917157334187;
        let z: u128 = 429190852266509618340;

        let value: u128 = (U256::from(x) * U256::from(z) / U256::from(y)).as_u128();
        let value_str: U128 = U128((U256::from(x) * U256::from(z) / U256::from(y)).as_u128());

        log!("u128: {}", value);
        log!("U128: {:?}", value_str);

        value
    }

    pub fn pprint_str(&self) -> U128 {
        let x: u128 = 199999579045383882874;
        let y: u128 = 429189948917157334187;
        let z: u128 = 429190852266509618340;

        let value: u128 = (U256::from(x) * U256::from(z) / U256::from(y)).as_u128();
        let value_str: U128 = U128((U256::from(x) * U256::from(z) / U256::from(y)).as_u128());

        log!("u128: {}", value);
        log!("U128: {:?}", value_str);

        value_str
    }

    pub fn default_u128(&self) -> u128 {
        let value_str: U128 = U128(VALUE);

        log!("u128: {}", VALUE);
        log!("U128: {:?}", value_str);

        VALUE
    }

    pub fn default_str(&self) -> U128 {
        let value_str: U128 = U128(VALUE);

        log!("u128: {}", VALUE);
        log!("U128: {:?}", value_str);

        value_str
    }
}

'''
'''--- 3-types-issues/views.sh ---

source neardev/dev-account.env
echo $CONTRACT_NAME

near view $CONTRACT_NAME pprint_u128 '{}'
near view $CONTRACT_NAME pprint_str '{}'

near view $CONTRACT_NAME default_u128 '{}'
near view $CONTRACT_NAME default_str '{}'

'''