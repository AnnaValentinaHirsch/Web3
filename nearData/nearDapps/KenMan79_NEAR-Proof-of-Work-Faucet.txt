*GitHub Repository "KenMan79/NEAR-Proof-of-Work-Faucet"*

'''--- .dependabot/config.yml ---
version: 1
update_configs:
  - package_manager: "rust:cargo"
    directory: "/contract-rs"
    update_schedule: "live"
    automerged_updates:
      - match:
          dependency_type: "development"
          update_type: "all"
      - match:
          dependency_type: "production"
          update_type: "all"
'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for all branches in this repo (defaults to false)
    branches: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default

vscode:
  extensions:
    - hbenl.vscode-test-explorer@2.15.0:koqDUMWDPJzELp/hdS/lWw==
    - Swellaby.vscode-rust-test-adapter@0.11.0:Xg+YeZZQiVpVUsIkH+uiiw==
    - bungcip.better-toml@0.3.2:3QfgGxxYtGHfJKQU7H0nEw==

'''
'''--- .travis.yml ---
language: rust
rust:
  - stable
before_install:
  - rustup target add wasm32-unknown-unknown
script:
  - cd contract-rs
  - ./build.sh
  - cargo test --verbose --all
'''
'''--- README.md ---
Proof of Work Faucet
====================

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

A cryptocurrency "faucet" is a site that gives away cryptocurrency. Faucets are especially common on test networks such as [NEAR TestNet](https://docs.near.org/docs/roles/developer/connecting) to allow developers to test apps with tokens which have no monetary value.

Faucets can run out of tokens, especially if people abuse them and purposely attempt to drain available funds. While test network tokens can be replenished one way or another, doing so can be a hassle, so it's useful to deter this sort of behavior.

To this end, some faucets require that token requests be accompanied by a post on Twitter. But it's easy for one person to spin up many fake Twitter accounts to drain a faucet. This sort of behavior would be classified as a [Sybil attack](https://bitcoin.stackexchange.com/questions/50922/whats-a-sybil-attack).

This demo uses a different approach.

First, each new account created with this faucet receives 1/1000 of the funds remaining at the time it was created.

Second, this faucet requires [Proof of Work](https://www.khanacademy.org/economics-finance-domain/core-finance/money-and-banking/bitcoin/v/bitcoin-proof-of-work): before the faucet creates your new account, you need to wait while the JavaScript on the page churns through some complex computation (in this demo, that specific computation is to compute a `u64` salt for a given account id + public key in such a way that the `sha256(account_id + ':' + public_key + ':' + salt)` has `min_difficulty` leading zeroes).

Try it out
==========

You can try out a live version of this demo: https://near-examples.github.io/pow-faucet/

This demo version creates new NEAR TestNet accounts with a `.meta` suffix.

Playing with the Code
=====================

The code lives in two different places:

Faucet Contract
---------------

The smart contract source code lives in the `contract-rs` folder, and specifically in `contract-rs/src/lib.rs`.

After you make changes, run tests by entering the `contract-rs` directory (`cd contract-rs`) and running:

    cargo test

To recompile the smart contract in preparation for deploying it, again enter the `contract-rs` directory and run:

    ./build.sh

Faucet Frontend
---------------

This contains the JavaScript that shows the UI and runs the proof-of-work algorithm. It lives in the `frontend` folder.

It was bootstrapped with [`create-react-app`](https://create-react-app.dev). Check out the README in the `frontend` folder to learn how to play with the code.

Deploying
=========

The Contract and the Frontend need to be deployed separately.

* See instructions on [docs.near.org](https://docs.near.org) for how to [deploy the contract to the NEAR blockchain](https://docs.near.org/docs/tutorials/intro-to-rust#finally-test-compile-and-deploy-).
* The frontend compiles to static assets – HTML, CSS, and JavaScript. The demo frontend is deployed to GitHub Pages using [gh-pages](https://www.npmjs.com/package/gh-pages). Feel free to re-use this approach or [find another](https://www.slant.co/topics/2256/~best-static-website-hosting-provider).

See Also
========

As a follow-up to this demo, we created a [Proof of Work Transfer Faucet](https://github.com/near-examples/token-printer). This "Transfer Faucet" differs from the current example in two main ways:

1. Rather than create a new account, it sends NEAR Tokens to an existing account
2. Rather than send 1/1000th of the remaining funds, it always sends 100Ⓝ

Data collection
===============

By using Gitpod in this project, you agree to opt-in to basic, anonymous analytics. No personal information is transmitted. Instead, these usage statistics aid in discovering potential bugs and user flow information.

'''
'''--- contract-rs/Cargo.toml ---
[package]
name = "faucet"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
near-sdk = "3.1.0"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract-rs/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/faucet.wasm ./res/

'''
'''--- contract-rs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::{env, near_bindgen, Promise, PromiseOrValue, PanicOnDefault};

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

pub type AccountId = String;
pub type PublicKey = Vec<u8>;
pub type Salt = u64;

/// A Faucet contract that creates and funds accounts if the caller provides basic proof of work
/// to avoid sybil attacks and draining balance too fast.
/// The new account always receives 1/1000 of the remaining balance.
/// Proof of Work works the following way:
/// You need to compute a u64 salt (nonce) for a given account and a given public key in such a way
/// that the `sha256(account_id + ':' + public_key + ':' + salt)` has more leading zero bits than
/// the required `min_difficulty`.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Faucet {
    /// Account ID which will be a suffix for each account (including a '.' separator).
    pub account_suffix: AccountId,
    /// Number of leading zeros in binary representation for a hash
    pub min_difficulty: u32,
    /// Created accounts
    pub created_accounts: UnorderedSet<AccountId>,
}

/// Returns the number of leading zero bits for a given slice of bits.
fn num_leading_zeros(v: &[u8]) -> u32 {
    let mut res = 0;
    for z in v.iter().map(|b| b.leading_zeros()) {
        res += z;
        if z < 8 {
            break;
        }
    }
    res
}

fn assert_self() {
    assert_eq!(
        env::current_account_id(),
        env::predecessor_account_id(),
        "Can only be called by owner"
    );
}

#[near_bindgen]
impl Faucet {
    #[init]
    pub fn new(account_suffix: AccountId, min_difficulty: u32) -> Self {
        assert!(env::state_read::<Self>().is_none(), "Already initialized");
        Self {
            account_suffix,
            min_difficulty,
            created_accounts: UnorderedSet::new(b"a".to_vec()),
        }
    }

    pub fn get_account_suffix(&self) -> AccountId {
        self.account_suffix.clone()
    }

    pub fn get_min_difficulty(&self) -> u32 {
        self.min_difficulty
    }

    pub fn get_num_created_accounts(&self) -> u64 {
        self.created_accounts.len()
    }

    pub fn create_account(
        &mut self,
        account_id: AccountId,
        public_key: PublicKey,
        salt: Salt,
    ) -> PromiseOrValue<()> {
        // Checking account_id suffix first.
        assert!(
            account_id.ends_with(&self.account_suffix),
            "Account has to end with the suffix"
        );

        // Checking that the given account is not created yet.
        assert!(
            !self.created_accounts.contains(&account_id),
            "The given given account is already created"
        );

        // Checking proof of work
        //     Constructing a message for checking
        let mut message = account_id.as_bytes().to_vec();
        message.push(b':');
        message.extend_from_slice(&public_key);
        message.push(b':');
        message.extend_from_slice(&salt.to_le_bytes());
        //     Computing hash of the message
        let hash = env::sha256(&message);
        //     Checking that the resulting hash has enough leading zeros.
        assert!(
            num_leading_zeros(&hash) >= self.min_difficulty,
            "The proof is work is too weak"
        );

        // All checks are good, let's proceed by creating an account

        // Save that we already has created an account.
        self.created_accounts.insert(&account_id);

        // Creating new account. It still can fail (e.g. account already exists or name is invalid),
        // but we don't care, we'll get a refund back.
        Promise::new(account_id)
            .create_account()
            .transfer(env::account_balance() / 1000)
            .add_full_access_key(public_key)
            .into()
    }

    // Owner's methods. Can only be called by the owner

    pub fn set_min_difficulty(&mut self, min_difficulty: u32) {
        assert_self();
        self.min_difficulty = min_difficulty;
    }

    pub fn add_access_key(&mut self, public_key: PublicKey) -> PromiseOrValue<()> {
        assert_self();
        Promise::new(env::current_account_id())
            .add_access_key(
                public_key,
                0,
                env::current_account_id(),
                b"create_account".to_vec(),
            )
            .into()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use std::panic;

    use super::*;

    fn catch_unwind_silent<F: FnOnce() -> R + panic::UnwindSafe, R>(
        f: F,
    ) -> std::thread::Result<R> {
        let prev_hook = panic::take_hook();
        panic::set_hook(Box::new(|_| {}));
        let result = panic::catch_unwind(f);
        panic::set_hook(prev_hook);
        result
    }

    fn get_context() -> VMContext {
        VMContext {
            current_account_id: "alice".to_string(),
            signer_account_id: "bob".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "bob".to_string(),
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(15),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn test_new() {
        let context = get_context();
        testing_env!(context);
        let account_suffix = ".alice".to_string();
        let min_difficulty = 5;
        let contract = Faucet::new(account_suffix.clone(), min_difficulty);
        assert_eq!(contract.get_account_suffix(), account_suffix);
        assert_eq!(contract.get_min_difficulty(), min_difficulty);
        assert_eq!(contract.get_num_created_accounts(), 0);
    }

    #[test]
    fn test_create_account_ok() {
        let context = get_context();
        testing_env!(context);
        let account_suffix = ".alice".to_string();
        let min_difficulty = 20;
        let mut contract = Faucet::new(account_suffix.clone(), min_difficulty);
        let account_id = "test.alice";
        let public_key = vec![0u8; 33];
        let salt = 89949;
        contract.create_account(account_id.to_string(), public_key, salt);
        assert_eq!(contract.get_num_created_accounts(), 1);
    }

    #[test]
    fn test_fail_default() {
        let context = get_context();
        testing_env!(context);
        catch_unwind_silent(|| {
            Faucet::default();
        })
        .unwrap_err();
    }

    #[test]
    fn test_fail_create_account_bad_name() {
        let context = get_context();
        testing_env!(context);
        let account_suffix = ".alice".to_string();
        let min_difficulty = 0;
        let mut contract = Faucet::new(account_suffix.clone(), min_difficulty);
        let account_id = "bob";
        let public_key = vec![0u8; 33];
        let salt = 0;
        catch_unwind_silent(move || {
            contract.create_account(account_id.to_string(), public_key, salt);
        })
        .unwrap_err();
    }

    #[test]
    fn test_fail_create_account_already_created() {
        let context = get_context();
        testing_env!(context);
        let account_suffix = ".alice".to_string();
        let min_difficulty = 10;
        let mut contract = Faucet::new(account_suffix.clone(), min_difficulty);
        let account_id = "test.alice";
        let public_key = vec![0u8; 33];
        let salt = 123;
        contract.create_account(account_id.to_string(), public_key.clone(), salt);
        catch_unwind_silent(move || {
            contract.create_account(account_id.to_string(), public_key, salt);
        })
        .unwrap_err();
    }

    #[test]
    fn test_num_leading_zeros() {
        assert_eq!(num_leading_zeros(&[0u8; 4]), 32);
        assert_eq!(num_leading_zeros(&[255u8; 4]), 0);
        assert_eq!(num_leading_zeros(&[254u8; 4]), 0);
        assert_eq!(num_leading_zeros(&[]), 0);
        assert_eq!(num_leading_zeros(&[127u8]), 1);
        assert_eq!(num_leading_zeros(&[0u8; 32]), 256);
        assert_eq!(num_leading_zeros(&[1u8; 4]), 7);
        assert_eq!(num_leading_zeros(&[0u8, 0u8, 255u8 >> 3]), 19);
        assert_eq!(num_leading_zeros(&[0u8, 0u8, 255u8 >> 3, 0u8]), 19);
    }
}

'''
'''--- frontend/README.md ---
This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Getting Started

1. Prerequisites: Make sure you have Node.js ≥ 12 installed (https://nodejs.org), then use it to install [yarn]: `npm install --global yarn` (or just
   `npm i -g yarn`)
2. Install dependencies: `yarn install` (or just `yarn`)

  [yarn]: https://yarnpkg.com/

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.<br />
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

### `yarn deploy`

Deploys app to github pages.<br />

### `yarn test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "homepage": "pow-faucet",
  "dependencies": {
    "@testing-library/jest-dom": "^5.9.0",
    "@testing-library/react": "^10.2.1",
    "@testing-library/user-event": "^11.4.0",
    "near-api-js": "^0.29.1",
    "near-seed-phrase": "^0.0.2",
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "react-scripts": "3.4.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "deploy": "yarn build && gh-pages -d build"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "gh-pages": "^3.0.0"
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Faucet</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.js ---
import React from 'react';
import * as nearAPI from 'near-api-js';
import { generateSeedPhrase } from 'near-seed-phrase';

const FaucetPrivateKey = 'ed25519:2Rtn6ms22rCRMgmGgLRSPPd6gYDCgWDuFrX6gERknSA8GKiCHE5L9Rksc1ihsSCDvMSptfbipzq29H7cDZhR1Ze3';
const FaucetName = 'meta';
const MinAccountIdLen = 2;
const MaxAccountIdLen = 64;
const ValidAccountRe = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
const AuthDataKey = "meta-faucet-auth-data";

class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      connected: false,
      signedIn: false,
      accountId: null,
      newAccountId: "",
      creating: false,
      accountLoading: false,
      newAccountExists: false,
      computingProofOfWork: false,
    };

    this.initNear().then(() => {
      this.setState({
        connected: true,
        signedIn: !!this._authData.accountId,
        accountId: this._authData.accountId,
      })
    })
  }

  async initFaucet() {
    let key = await this._keyStore.getKey(this._nearConfig.networkId, FaucetName);
    if (!key) {
      const keyPair = nearAPI.KeyPair.fromString(FaucetPrivateKey);
      await this._keyStore.setKey(this._nearConfig.networkId, FaucetName, keyPair);
    }
    const account = new nearAPI.Account(this._near.connection, FaucetName);
    this._faucetContract =  new nearAPI.Contract(account, FaucetName, {
      viewMethods: ['get_min_difficulty', 'get_account_suffix', 'get_num_created_accounts'],
      changeMethods: ['create_account'],
      sender: FaucetName
    });
    this._accountSuffix = await this._faucetContract.get_account_suffix();
    this._minDifficulty = await this._faucetContract.get_min_difficulty();
    this.setState({
      numCreatedAccounts: await this._faucetContract.get_num_created_accounts(),
    });
    // console.log(JSON.stringify([...key.getPublicKey().data]));
  }

  async initNear() {
    const nearConfig = {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.nearprotocol.com',
      contractName: FaucetName,
      walletUrl: 'https://wallet.testnet.near.org',
    };
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(Object.assign({ deps: { keyStore } }, nearConfig));
    this._keyStore = keyStore;
    this._nearConfig = nearConfig;
    this._near = near;

    this._authData = JSON.parse(window.localStorage.getItem(AuthDataKey) || '{}');
    await this.initFaucet();
  }

  handleChange(key, value) {
    const stateChange = {
      [key]: value,
    };
    if (key === 'newAccountId') {
      value = value.toLowerCase().replace(/[^a-z0-9\-_.]/, '');
      stateChange[key] = value;
      stateChange.newAccountExists = false;
      if (this.isValidAccount(value)) {
        stateChange.accountLoading = true;
        this._near.connection.provider.query(`account/${value + this._accountSuffix}`, '').then((_a) => {
          if (this.state.newAccountId === value) {
            this.setState({
              accountLoading: false,
              newAccountExists: true,
            })
          }
        }).catch((e) => {
          if (this.state.newAccountId === value) {
            this.setState({
              accountLoading: false,
              newAccountExists: false,
            })
          }
        })
      }
    }
    this.setState(stateChange);
  }

  isValidAccount(newAccountId) {
    if (newAccountId.includes('.')) {
      return false;
    }
    const accountId = newAccountId + this._accountSuffix;
    return accountId.length >= MinAccountIdLen &&
        accountId.length <= MaxAccountIdLen &&
        accountId.match(ValidAccountRe);
  }

  newAccountClass() {
    if (!this.state.newAccountId || this.state.accountLoading) {
      return "form-control form-control-large";
    } else if (!this.state.newAccountExists && this.isValidAccount(this.state.newAccountId)) {
      return "form-control form-control-large is-valid";
    } else {
      return "form-control form-control-large is-invalid";
    }
  }

  async computeProofOfWork(accountId, publicKey) {
    let msg = [...new TextEncoder('utf-8').encode(accountId + ':')];
    // curve
    msg.push(0);
    // key
    msg.push(...publicKey.data);
    // separator
    msg.push(':'.charCodeAt(0));
    // salt
    msg.push(0, 0, 0, 0, 0, 0, 0, 0);
    msg = new Uint8Array(msg);
    const len = msg.length;
    let bestDifficulty = 0;
    for (let salt = 0; ; ++salt) {
      // compute hash
      const hashBuffer = new Uint8Array(await crypto.subtle.digest('SHA-256', msg));
      // compute number of leading zero bits
      let totalNumZeros = 0;
      for (let i = 0; i < hashBuffer.length; ++i) {
        let numZeros = Math.clz32(hashBuffer[i]) - 24;
        totalNumZeros += numZeros;
        if (numZeros < 8) {
          break;
        }
      }
      // checking difficulty
      if (totalNumZeros >= this._minDifficulty) {
        this.setState({
          computingProofOfWork: false,
        });
        return salt;
      } else if (totalNumZeros > bestDifficulty) {
        bestDifficulty = totalNumZeros;
        this.setState({
          proofOfWorkProgress: Math.trunc(bestDifficulty * 100 / this._minDifficulty),
          proofOfWorkDifficulty: bestDifficulty,
          proofOfWorkSalt: salt,
        });
      } else if (salt % 10000 === 0) {
        this.setState({
          proofOfWorkSalt: salt
        });
      }
      // incrementing salt
      for (let i = len - 8; i < len; ++i) {
        if (msg[i] === 255) {
          msg[i] = 0;
        } else {
          ++msg[i];
          break;
        }
      }
    }
  }

  async createAccount() {
    this.setState({
      creating: true,
      computingProofOfWork: true,
      proofOfWorkProgress: 0,
      proofOfWorkDifficulty: 0,
      proofOfWorkSalt: 0,
    })
    const newAccountId = this.state.newAccountId + this._accountSuffix;
    const seed = generateSeedPhrase();
    const newKeyPair = nearAPI.KeyPair.fromString(seed.secretKey);
    const salt = await this.computeProofOfWork(newAccountId, newKeyPair.getPublicKey());
    await this._faucetContract.create_account({
      account_id: newAccountId,
      public_key: [0, ...newKeyPair.getPublicKey().data],
      salt,
    });
    await this._keyStore.setKey(this._nearConfig.networkId, newAccountId, newKeyPair);
    this._authData = {
      accountId: newAccountId,
      seed,
    };
    window.localStorage.setItem(AuthDataKey, JSON.stringify(this._authData));
    this.setState({
      signedIn: true,
      accountId: newAccountId,
      creating: false,
      numCreatedAccounts: await this._faucetContract.get_num_created_accounts(),
    })
  }

  moveAccountToWallet() {
    window.location = `https://wallet.testnet.near.org/recover-with-link/${this._authData.accountId}/${this._authData.seed.seedPhrase}`;
  }

  logout() {
    window.localStorage.removeItem(AuthDataKey);
    this._authData = {};
    this.setState({
      signedIn: false,
      accountId: null,
      newAccountId: "",
      creating: false,
      accountLoading: false,
      newAccountExists: false,
      computingProofOfWork: false,
    });
  }

  render() {
    const content = !this.state.connected ? (
      <div>Connecting... <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span></div>
    ) : (this.state.signedIn ? (
      <div>
        <h3>Hello, {this.state.accountId}</h3>
        <div className="form-group">
          <button
            className="btn btn-success"
            onClick={() => this.moveAccountToWallet()}
          >
            Move account to NEAR Wallet
          </button>
        </div>
        <div className="form-group">
          <button
            className="btn btn-danger"
            onClick={() => this.logout()}
          >
            Logout from Faucet
          </button>
        </div>
      </div>
    ) : (
      <div>
        <div className="form-group">
          <label htmlFor="accountId">Create a new account</label>
          <div className="input-group">
            <div className="input-group-prepend">
              <div className="input-group-text">{"@"}</div>
            </div>
            <input
              placeholder="bob"
              id="accountId"
              className={this.newAccountClass()}
              value={this.state.newAccountId}
              onChange={(e) => this.handleChange('newAccountId', e.target.value)}
              disabled={this.state.creating}
            />
            <div className="input-group-append">
              <div className="input-group-text">{this._accountSuffix}</div>
            </div>
          </div>
        </div>
        {this.state.newAccountExists && (
          <div className="alert alert-warning" role="alert">
            Account {'"' + this.state.newAccountId + this._accountSuffix + '"'} already exists!
          </div>
        )}
        <div className="form-group">
          <button
            className="btn btn-primary"
            disabled={this.state.creating || this.state.accountLoading || this.state.newAccountExists || !this.isValidAccount(this.state.newAccountId)}
            onClick={() => this.createAccount()}
          >
            {(this.state.creating || this.state.accountLoading) && (
              <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
            )} Create Account {this.isValidAccount(this.state.newAccountId) ? ('"' + this.state.newAccountId + this._accountSuffix + '"') : ""}
          </button>
        </div>
        {this.state.creating && (
          <div>
            {this.state.computingProofOfWork ? (
              <div>
                Computing Proof of Work. Done {this.state.proofOfWorkSalt} operations.
                <div className="progress">
                  <div className="progress-bar" role="progressbar" style={{width: this.state.proofOfWorkProgress + '%'}} aria-valuenow={this.state.proofOfWorkProgress} aria-valuemin="0"
                       aria-valuemax="100">{this.state.proofOfWorkDifficulty} out of {this._minDifficulty}
                  </div>
                </div>
              </div>
            ) : (
              <div>
                Proof of Work is Done! Creating account {'"' + this.state.newAccountId + this._accountSuffix + '"'}
              </div>
            )}
          </div>
        )}
      </div>
    ));
    return (
      <div>
        <div>
          <h1>NEAR Proof of Work Faucet</h1>
          There were <span className="font-weight-bold">{this.state.numCreatedAccounts} accounts</span> created using this faucet.
        </div>
        <hr/>
        {content}
      </div>
    );
  }
}

export default App;

'''
'''--- frontend/src/App.test.js ---
import React from 'react';
import { render } from '@testing-library/react';
import App from './App';

test('renders header', () => {
  const { getByText } = render(<App />);
  const header = getByText(/Proof of Work Faucet/i);
  expect(header).toBeInTheDocument();
});

'''
'''--- frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));

'''
'''--- frontend/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom/extend-expect';

'''