*GitHub Repository "near-examples/coin-flip-js"*

'''--- .github/workflows/tests-rs.yml ---
name: Tests Contract RS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
      - name: Install and test modules
        run: |
          cd ./contract-rs
          cargo test
'''
'''--- .github/workflows/tests-ts.yml ---
name: Tests Contract TS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        node-version: [18, 20]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: Install and test modules
        run: |
          cd ./contract-ts
          yarn
          yarn test
'''
'''--- README.md ---
# Coin Flip Examples ðŸª™ 

[![](https://img.shields.io/badge/â‹ˆ%20Examples-Basics-green)](https://docs.near.org/tutorials/welcome)
[![](https://img.shields.io/badge/Contract-JS-yellow)](contract-ts)
[![](https://img.shields.io/badge/Contract-Rust-red)](contract-rs)
[![](https://img.shields.io/badge/Frontend-JS-yellow)](frontend)
![example workflow](https://github.com/near-examples/coin-flip-examples/actions/workflows/tests-ts.yml/badge.svg)
![example workflow](https://github.com/near-examples/coin-flip-examples/actions/workflows/tests-rs.yml/badge.svg)

This repository contains examples of a simple coin flip contract in both JavaScript and Rust, as well as a frontend interacting with a deployed coin flip smart contract. 

- [Coin Flip Contract - JavaScript](contract-ts)
- [Coin Flip Contract - Rust](contract-ts)
- [Coin Flip Frontend](frontend)

<br />

# What These Examples Show

1. How to generate a random number.

<br />

# Learn More
1. Learn more about the contract through its [README](./contract-ts/README.md).
2. Check [**our documentation**](https://docs.near.org/develop/welcome).

'''
'''--- contract-rs/Cargo.toml ---
[package]
name = "contract-rs"
description = "Coin Flip Examples"
version = "0.1.0"
edition = "2021"
# TODO: Fill out the repository field to help NEAR ecosystem tools to discover your project.
# NEP-0330 is automatically implemented for all contracts built with https://github.com/near/cargo-near.
# Link to the repository will be available via `contract_source_metadata` view-function.
#repository = "https://github.com/xxx/xxx"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

[dev-dependencies]
near-sdk = { version = "5.1.0", features = ["unit-testing"] }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract-rs/README.md ---
# contract-rs

cargo-near-new-project-description

## How to Build Locally?

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near build
```

## How to Test Locally?

```bash
cargo test
```

## How to Deploy?

To deploy manually, install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# Create a new account
cargo near create-dev-account

# Deploy the contract on it
cargo near deploy <account-id>
```

## Useful Links

- [cargo-near](https://github.com/near/cargo-near) - NEAR smart contract development toolkit for Rust
- [near CLI](https://near.cli.rs) - Iteract with NEAR blockchain from command line
- [NEAR Rust SDK Documentation](https://docs.near.org/sdk/rust/introduction)
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub), [Twitter](https://twitter.com/neardevhub)

'''
'''--- contract-rs/rust-toolchain.toml ---
[toolchain]
channel = "stable"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]
'''
'''--- contract-rs/src/lib.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::collections::UnorderedMap;
use near_sdk::env::{self, log_str};
use near_sdk::{near, AccountId, BorshStorageKey};

#[near(serializers = [borsh])]
#[derive(BorshStorageKey)]
enum StorageKey {
    Points,
}

pub(crate) fn simulate_coin_flip() -> String {
    // Here we get a first byte of a random seed
    let random_seed = *env::random_seed().get(0).unwrap() as i8;

    // If a first byte is EVEN we choose heads, otherwise tails
    if let 0 = random_seed % 2 {
        return "heads".to_string();
    } else {
        return "tails".to_string();
    };
}

// Define the contract structure
#[near(contract_state)]
pub struct Contract {
    points: UnorderedMap<AccountId, u8>,
}

// Define the default, which automatically initializes the contract
impl Default for Contract {
    fn default() -> Self {
        Self {
            points: UnorderedMap::new(StorageKey::Points),
        }
    }
}

// Implement the contract structure
#[near]
impl Contract {
    /*
      Flip a coin. Pass in the side (heads or tails) and a random number will be chosen
      indicating whether the flip was heads or tails. If you got it right, you get a point.
    */
    pub fn flip_coin(&mut self, player_guess: String) -> String {
        // Check who called the method
        let player: AccountId = env::predecessor_account_id();
        log_str(&format!("{player} chose {player_guess}"));

        // Simulate a Coin Flip
        let outcome = simulate_coin_flip();

        // Get the current player points
        let mut player_points = self.points.get(&player).unwrap_or(0);

        // Check if their guess was right and modify the points accordingly
        if outcome.eq(&player_guess) {
            player_points = player_points + 1;
        } else {
            player_points = player_points.saturating_sub(1);
        };

        log_str(&format!("player_points: {player_points}"));

        // Store the new points
        self.points.insert(&player, &player_points);

        return outcome;
    }

    // View how many points a specific player has
    pub fn points_of(&self, player: AccountId) -> u8 {
        let points = self.points.get(&player).unwrap_or(0);
        log_str(&format!("Points for {player}: {points}"));

        return points;
    }
}

'''
'''--- contract-rs/tests/tests.rs ---
use near_workspaces::{types::NearToken, Account, Contract};
use serde_json::json;
 
#[tokio::test]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let worker = near_workspaces::sandbox().await?;
    let contract_wasm = near_workspaces::compile_project("./").await?;
    let contract = worker.dev_deploy(&contract_wasm).await?;
 
    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount("alice")
        .initial_balance(NearToken::from_near(30))
        .transact()
        .await?
        .into_result()?;
 
    // begin tests
    test_user_has_no_points(&alice, &contract).await?;
    test_points_are_correctly_computed(&alice, &contract).await?;
    Ok(())
}

async fn test_user_has_no_points(
    user: &Account,
    contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
    let points: u8 = user
        .call(contract.id(), "points_of")
        .args_json(json!({ "player": user.id()}))
        .transact()
        .await?
        .json()?;
 
    assert_eq!(points, 0);
    println!("      Passed âœ… test_user_has_no_points");
    Ok(())
}
 
async fn test_points_are_correctly_computed(
    user: &Account,
    contract: &Contract,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut tails_counter = 0;
    let mut heads_counter = 0;
    let mut expected_points = 0;

    let mut i = 0;
    while i < 10 {
        let outcome: String = user.call(contract.id(), "flip_coin")
          .args_json(json!({"player_guess": "tails"}))
          .transact()
          .await?
          .json()?;

        if outcome.eq("tails") {
          tails_counter = tails_counter + 1;
          expected_points = expected_points + 1;
        } else {
          heads_counter = heads_counter + 1;
          if expected_points > 0 {
            expected_points = expected_points - 1;
          }
        }
        i = i + 1;
    }

    assert!(heads_counter >= 2);
    assert!(tails_counter >= 2);
    
    let points: u8 = user
        .call(contract.id(), "points_of")
        .args_json(json!({ "player": user.id()}))
        .transact()
        .await?
        .json()?;
 
    assert_eq!(points, expected_points);
    println!("      Passed âœ… test_points_are_correctly_computed");
    Ok(())
}
'''
'''--- contract-ts/README.md ---
# Coin Flip Contract

The smart contract implements a flip coin game in which the player tries to guess the next outcome.
The player gets a point on each correct guess, and losses one for each wrong one.

```ts
function simulateCoinFlip(): Side {
  const randomString: string = near.randomSeed();
  return randomString.charCodeAt(0) % 2 ? 'heads' : 'tails';
}

flip_coin({ player_guess }: { player_guess: Side  }): Side {
  // Check who called the method
  const player = near.predecessorAccountId(); 
  near.log(`${player} chose ${player_guess}`);

  // Simulate a Coin Flip
  const outcome = simulateCoinFlip();

  // Get the current player points
  let player_points: number = (this.points.get(player) || 0) as number
  
  // Check if their guess was right and modify the points accordingly
  if(player_guess == outcome) {
    near.log(`The result was ${outcome}, you get a point!`);
    player_points += 1;
  } else {
    near.log(`The result was ${outcome}, you lost a point`);
    player_points = player_points? player_points - 1 : 0;
  }

  // Store the new points
  this.points.set(player, player_points)

  return outcome
}
```

<br />

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Test the Contract
You can automatically compile and test the contract in the NEAR testnet by running:

```bash
npm run test
```

<br />

## 2. Create Account and Deploy the Contract
You can create a new account and deploy the contract on it by running:

```bash
near create-account <your-account>.testnet --useFaucet
near deploy <your-account>.testnet build/contract.wasm
```

<br />

## 3. Get the Score
`points_of` performs read-only operations, therefore it is a `view` method.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
# Use near-cli to get the points
near view <your-account> points_of '{"player": "<dev-account>"}'
```

<br />

## 4. Flip a Coin and Try to Guess the Outcome
`flip_coin` takes a guess ("heads" or "tails"), simulates a coin flip and gives/removes points to the player.

It changes the contract's state, for which it is a `call` method.

`Call` methods can only be invoked using a NEAR account, since the account needs to pay GAS for the transaction.

```bash
# Use near-cli to play
near call <your-account> flip_coin '{"player_guess":"tails"}' --accountId <your-account>
```

**Tip:** If you would like to call `flip_coin` using another account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <another-account>`.

## A Note on Random Numbers
Generating random numbers in an adversarial environment such as a blockchain is very difficult. This spawns from
the fact that everything is public on the network.

Please check our documentation to learn more about handling [random numbers in a blockchain](https://docs.near.org/develop/contracts/security/storage).
'''
'''--- contract-ts/package.json ---
{
  "name": "contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/contract.wasm",
    "test": "$npm_execpath run build && ava -- ./build/contract.wasm"
  },
  "dependencies": {
    "near-cli": "^4.0.10",
    "near-sdk-js": "1.0.0"
  },
  "devDependencies": {
    "@ava/typescript": "^4.1.0",
    "ava": "^6.1.2",
    "near-workspaces": "^3.5.0",
    "ts-morph": "^22.0.0",
    "ts-node": "^10.9.2",
    "tsimp": "^2.0.11",
    "typescript": "^5.4.2"
  }
}

'''
'''--- contract-ts/sandbox-ts/main.ava.ts ---
import { Worker, NearAccount } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { setDefaultResultOrder } from 'dns'; setDefaultResultOrder('ipv4first'); // temp fix for node >v17

// Global context
const test = anyTest as TestFn<{ worker: Worker, accounts: Record<string, NearAccount> }>;

test.beforeEach(async (t) => {
  // Create sandbox, accounts, deploy contracts, etc.
  const worker = t.context.worker = await Worker.init();

  // Deploy contract
  const root = worker.rootAccount;

  // Get wasm file path from package.json test script in folder above
  const contract = await root.createSubAccount('contract');
  await contract.deploy(process.argv[2]);

  // Save state for test runs, it is unique for each test
  t.context.accounts = { root, contract };
});

test.afterEach.always(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log('Failed to stop the Sandbox:', error);
  });
});

test('by default the user has no points', async (t) => {
  const { root, contract } = t.context.accounts;
  const points: number = await contract.view('points_of', { player: root.accountId });
  t.is(points, 0);
});

test('the points are correctly computed', async (t) => {
  const { root, contract } = t.context.accounts;

  let counter: {[key:string]:number} = { 'heads': 0, 'tails': 0 }
  let expected_points = 0;

  for(let i=0; i<10; i++){
    const res = await root.call(contract, 'flip_coin', { 'player_guess': 'heads' })
    counter[res as string] += 1;
    expected_points += res == 'heads' ? 1 : -1;
    expected_points = Math.max(expected_points, 0);
  }

  // A binomial(10, 1/2) has a P(x>2) ~ 0.98%
  t.true(counter['heads'] >= 2);

  const points: number = await contract.view('points_of', { 'player': root.accountId });
  t.is(points, expected_points);
});
'''
'''--- contract-ts/src/contract.ts ---
import { NearBindgen, near, call, view, UnorderedMap } from 'near-sdk-js';
import { AccountId } from 'near-sdk-js/lib/types';

type Side = 'heads' | 'tails'

function simulateCoinFlip(): Side {
  // randomSeed creates a random string, learn more about it in the README
  const randomString: string = near.randomSeed().toString();

  // If the last charCode is even we choose heads, otherwise tails
  return randomString.charCodeAt(0) % 2 ? 'heads' : 'tails';
}

@NearBindgen({})
class CoinFlip {
  points: UnorderedMap<number> = new UnorderedMap<number>("points");

  /*
    Flip a coin. Pass in the side (heads or tails) and a random number will be chosen
    indicating whether the flip was heads or tails. If you got it right, you get a point.
  */
  @call({})
  flip_coin({ player_guess }: { player_guess: Side }): Side {
    // Check who called the method
    const player: AccountId = near.predecessorAccountId();
    near.log(`${player} chose ${player_guess}`);

    // Simulate a Coin Flip
    const outcome = simulateCoinFlip();

    // Get the current player points
    let player_points: number = this.points.get(player, { defaultValue: 0 })

    // Check if their guess was right and modify the points accordingly
    if (player_guess == outcome) {
      near.log(`The result was ${outcome}, you get a point!`);
      player_points += 1;
    } else {
      near.log(`The result was ${outcome}, you lost a point`);
      player_points = player_points ? player_points - 1 : 0;
    }

    // Store the new points
    this.points.set(player, player_points)

    return outcome
  }

  // View how many points a specific player has
  @view({})
  points_of({ player }: { player: AccountId }): number {
    const points = this.points.get(player, {defaultValue: 0})
    near.log(`Points for ${player}: ${points}`)
    return points
  }
}
'''
'''--- contract-ts/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "es5",
    "noEmit": true
  },
  "exclude": [
    "node_modules"
  ],
}
'''
'''--- frontend/assets/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 26em;
}

h1 {
  background-image: url(./logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0;
  text-align: center;
  font-size: 1.5em;
}

h2 {
  text-align: center;
}

table {
  margin-top: 1em;
}

.status {
  font-size: small;
  font-family: monospace;
  text-align: center;
}

.please-wait .change {
  pointer-events: none;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}

a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}

a:active,
.link:active {
  color: var(--secondary);
}

button,
input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}

button:focus {
  border: 2px solid rgb(48, 188, 244);
}

button:hover {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }

  h1 {
    background-image: url(./logo-white.svg);
  }

  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

/* coin flip animations: https://rezabaharvand.dev/blog/coin-flip-javascript */

#coin {
  height: 150px;
  width: 150px;
  margin: 2em auto 0 auto;
  transform-style: preserve-3d;
}

#coin img {
  width: 150px;
}

.heads {
  transform: rotateY(180deg);
}

.tails,
.heads {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}

@keyframes flip-heads {
  100% {
    transform: rotateY(540deg);
  }
}

@keyframes flip-tails {
  100% {
    transform: rotateY(360deg);
  }
}

@keyframes flip {
  0% {
    transform: rotateY(0);
  }

  100% {
    transform: rotateY(2160deg);
  }
}
'''
'''--- frontend/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- frontend/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- frontend/cypress/coin-flip.cy.js ---
Cypress.on('uncaught:exception', (err, runnable) => {
  return false;
})

const SEED = Cypress.env('seed')

context('coin flip example', () => {
  beforeEach(() => {
    cy.visit('/')
  })

  it('test flow', () => {

    cy.get('button#sign-in-button').should('be.visible');
    cy.contains('button', 'Sign in with NEAR Wallet').click();
    cy.contains('div', 'MyNearWallet').click();
    cy.contains('button', 'Import Existing Account').click();
    cy.contains('button', 'Recover Account').click();
    cy.get('input').type(SEED);
    cy.contains('button', 'Find My Account').click();
    cy.contains('button', 'Next').click();
    cy.contains('button', 'Connect').click();
    cy.contains('button', 'Sign out').should('be.visible');
    cy.wait(5000);
    cy.get('.points').then($points => {
      let currentPoints = Number($points.text());
      for (let i = 0; i < 5; i ++) {
        cy.get('.points').then($points => {
          cy.wait(5000);
          const p = Number($points.text());
          if (p !== currentPoints) {
            throw new Error(`(1) expected points: ${currentPoints} actual: ${p}`);
          }
          cy.contains('button', 'Tails').click();
          cy.get('.status').should('contain.text', 'Status: Asking the contract to flip a coin');
          cy.get('.status').should('not.contain.text', 'Status: Asking the contract to flip a coin');
          cy.wait(5000);
          cy.get('.points').then($points => {
            const p = Number($points.text());
            if (p !== currentPoints + 1 && p !== currentPoints - 1) {
              throw new Error(`(2) expected points: ${currentPoints}+-1 actual: ${p}`);
            }
            currentPoints = p;
            cy.contains('button', 'Heads').click();
            cy.get('.status').should('contain.text', 'Status: Asking the contract to flip a coin');
            cy.get('.status').should('not.contain.text', 'Status: Asking the contract to flip a coin');
            cy.wait(5000);
            cy.get('.points').then($points => {
              const p = Number($points.text());
              if (p !== currentPoints + 1 && p !== currentPoints - 1) {
                throw new Error(`(3) expected points: ${currentPoints}+-1 actual: ${p}`);
              }
              currentPoints = p;
            })
          })
        })
      }
    })
  })
})

'''
'''--- frontend/cypress/cypres.config.js ---
const { defineConfig } = require('cypress')

module.exports = defineConfig({
  e2e: {
    baseUrl: 'http://localhost:1234',
    specPattern: 'cypress/**/*.cy.{js,jsx,ts,tsx}',
    supportFile: false,
    chromeWebSecurity: false,
    experimentalSessionAndOrigin: true,
    testIsolation: 'on',
    defaultCommandTimeout: 30000,
    env: {
      seed: 'give laugh youth nice fossil common neutral since best biology swift unhappy',
    },
    excludeSpecPattern: [
      '**/__snapshots__/*',
      '**/__image_snapshots__/*'
    ]
  }
})

'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="assets/favicon.ico"/>
  <link rel="apple-touch-icon" href="assets/favicon.ico"/>
  <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous"> -->
  <title>Welcome to NEAR</title>
  <link rel="stylesheet" href="assets/global.css">
</head>
<body>
  <div id="signed-in-flow">
    <button style="float: right" id="sign-out-button">
      Sign out <span data-behavior="account-id"></span>
    </button>
  </div>
  <main>
    <h1 id="signed-out-flow"> Welcome! Login to Play </h1>
    <h1 id="signed-in-flow"> Welcome <span data-behavior="account-id"></span>!</h1>      
    
    <div id="coin">
      <div class="tails">
        <img src="./assets/tails.png" alt="Coin's tail" />
      </div>
      <div class="heads">
        <img src="./assets/heads.png" alt="Coin's head" />
      </div>
    </div>

    <div id="signed-out-flow">

      <p style="text-align: center; margin-top: 2.5em">
        <button id="sign-in-button">Sign in with NEAR Wallet</button>
      </p>

    </div>

    <div id="signed-in-flow">
      
      <table>
        <tr>
          <td><p>What do you think is coming next?</p></td>
          <td>
              <button id="choose-tails">Tails</button>
              <button id="choose-heads">Heads</button>
          </td>
        </tr>
      </table>
      <p class="status"><b>Status</b>: <span data-behavior="status">Waiting user input</span></p>
      <h3>
        Your points so far: <span class="points" data-behavior="points"></span>
      </h3>
    </div>
  </main>
  <script src="index.js" type="module"></script>
</body>
</html>

'''
'''--- frontend/index.js ---
import 'regenerator-runtime/runtime';
import { Wallet } from './near-wallet';

// When creating the wallet you can optionally ask to create an access key
// Having the key enables to call non-payable methods without interrupting the user to sign
const CONTRACT_ADDRESS = process.env.CONTRACT_NAME || "coinflip.near-examples.testnet"
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS })

// Setup on page load
window.onload = async () => {
  let isSignedIn = await wallet.startUp();

  if (isSignedIn) {
    signedInFlow();
  } else {
    signedOutFlow();
  }
};

// Button clicks
const $get = (e) => document.querySelector(e);
$get('#sign-in-button').addEventListener('click', () => wallet.signIn());
$get('#sign-out-button').addEventListener('click', () => wallet.signOut());
$get('#choose-heads').addEventListener('click', () => player_choose('heads'));
$get('#choose-tails').addEventListener('click', () => player_choose('tails'));

// Executed when the player chooses a side
async function player_choose(side) {
  reset_buttons()
  start_flip_animation()
  set_status("Asking the contract to flip a coin")

  // Call the smart contract asking to flip a coin
  let outcome = await wallet.callMethod({
    contractId: CONTRACT_ADDRESS,
    method: 'flip_coin',
    args: { player_guess: side }
  });

  // UI
  set_status(`The outcome was ${outcome}`)
  stop_flip_animation_in(outcome)

  if (outcome === side) {
    set_status("You were right, you win a point!")
    $get(`#choose-${side}`).style.backgroundColor = "green"
  } else {
    set_status("You were wrong, you lost a point")
    $get(`#choose-${side}`).style.backgroundColor = "red"
  }

  // Fetch the new score
  fetchScore();
}

async function fetchScore() {
  console.log(wallet.accountId)
  const score = await wallet.viewMethod({
    contractId: CONTRACT_ADDRESS,
    method: 'points_of',
    args: { player: wallet.accountId }
  });

  document.querySelectorAll('[data-behavior=points]').forEach(el => {
    el.innerText = score;
  });
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelectorAll('#signed-in-flow').forEach(el => {
    el.style.display = 'none';
  });

  document.querySelectorAll('#signed-out-flow').forEach(el => {
    el.style.display = 'block';
  });

  // animate the coin
  $get('#coin').style.animation = "flip 3.5s ease 0.5s";
}

// Displaying the signed in flow container and fill in account-specific data
function signedInFlow() {
  document.querySelectorAll('#signed-in-flow').forEach(el => {
    el.style.display = 'block';
  });
  document.querySelectorAll('#signed-out-flow').forEach(el => {
    el.style.display = 'none';
  });
  document.querySelectorAll('[data-behavior=account-id]').forEach(el => {
    el.innerText = wallet.accountId;
  });

  fetchScore()
}

// Aux methods to simplify handling the interface
function set_status(message) {
  document.querySelectorAll('[data-behavior=status]').forEach(el => {
    el.innerText = message;
  });
}

function reset_buttons() {
  $get(`#choose-heads`).style.backgroundColor = "var(--secondary)"
  $get(`#choose-tails`).style.backgroundColor = "var(--secondary)"
}

function start_flip_animation() {
  $get('#coin').style.animation = 'flip 2s linear 0s infinite';
}

function stop_flip_animation_in(side) {
  $get('#coin').style.animation = `flip-${side} 1s linear 0s 1 forwards`;
}

'''
'''--- frontend/near-wallet.js ---
/* A helper file that simplifies using the wallet selector */

// near api js
import { providers } from 'near-api-js';

// wallet selector UI
import '@near-wallet-selector/modal-ui/styles.css';
import { setupModal } from '@near-wallet-selector/modal-ui';

// wallet selector options
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';

const THIRTY_TGAS = '30000000000000';
const NO_DEPOSIT = '0';

// Wallet that simplifies using the wallet selector
export class Wallet {
  walletSelector;
  wallet;
  network;
  createAccessKeyFor;

  constructor({ createAccessKeyFor = undefined, network = 'testnet' }) {
    // Login to a wallet passing a contractId will create a local
    // key, so the user skips signing non-payable transactions.
    // Omitting the accountId will result in the user being
    // asked to sign all transactions.
    this.createAccessKeyFor = createAccessKeyFor
    this.network = network
  }

  // To be called when the website loads
  async startUp() {
    this.walletSelector = await setupWalletSelector({
      network: this.network,
      modules: [setupMyNearWallet()],
    });

    const isSignedIn = this.walletSelector.isSignedIn();

    if (isSignedIn) {
      this.wallet = await this.walletSelector.wallet();
      this.accountId = this.walletSelector.store.getState().accounts[0].accountId;
    }

    return isSignedIn;
  }

  // Sign-in method
  signIn() {
    const description = 'Please select a wallet to sign in.';
    const modal = setupModal(this.walletSelector, { contractId: this.createAccessKeyFor, description });
    modal.show();
  }

  // Sign-out method
  signOut() {
    this.wallet.signOut();
    this.wallet = this.accountId = this.createAccessKeyFor = null;
    window.location.replace(window.location.origin + window.location.pathname);
  }

  // Make a read-only call to retrieve information from the network
  async viewMethod({ contractId, method, args = {} }) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    let res = await provider.query({
      request_type: 'call_function',
      account_id: contractId,
      method_name: method,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
      finality: 'optimistic',
    });
    return JSON.parse(Buffer.from(res.result).toString());
  }

  // Call a method that changes the contract's state
  async callMethod({ contractId, method, args = {}, gas = THIRTY_TGAS, deposit = NO_DEPOSIT }) {
    // Sign a transaction with the "FunctionCall" action
    const outcome = await this.wallet.signAndSendTransaction({
      signerId: this.accountId,
      receiverId: contractId,
      actions: [
        {
          type: 'FunctionCall',
          params: {
            methodName: method,
            args,
            gas,
            deposit,
          },
        },
      ],
    });

    return providers.getTransactionLastResult(outcome)
  }

  // Get transaction result from the network
  async getTransactionResult(txhash) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    // Retrieve transaction result from the network
    const transaction = await provider.txStatus(txhash, 'unnused');
    return providers.getTransactionLastResult(transaction);
  }
}
'''
'''--- frontend/package.json ---
{
  "name": "my-near-app",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html --public-url ./",
    "test:e2e": "npm run start:headless & npm run cypress:run",
    "cypress:run": "cypress run --config-file cypress/cypres.config.js",
    "cypress:open": "cypress open --browser chromium --config-file cypress/cypres.config.js"
  },
  "devDependencies": {
    "buffer": "^5.5.0||^6.0.0",
    "crypto-browserify": "^3.12.0",
    "cypress": "^13.6.6",
    "events": "^3.3.0",
    "https-browserify": "^1.0.0",
    "nodemon": "^3.1.0",
    "parcel": "^2.7.0",
    "process": "^0.11.10",
    "punycode": "^1.4.1",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.1.0",
    "url": "^0.11.0",
    "vm-browserify": "^1.1.2"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^8.9.5",
    "@near-wallet-selector/math-wallet": "^8.9.5",
    "@near-wallet-selector/meteor-wallet": "^8.9.5",
    "@near-wallet-selector/modal-ui": "^8.9.5",
    "@near-wallet-selector/my-near-wallet": "^8.9.5",
    "@near-wallet-selector/near-wallet": "^8.9.3",
    "@near-wallet-selector/nightly": "^8.9.5",
    "@near-wallet-selector/nightly-connect": "^8.7.0",
    "@near-wallet-selector/sender": "^8.9.5",
    "@near-wallet-selector/wallet-connect": "^8.9.5",
    "near-api-js": "^3.0.3"
  }
}

'''