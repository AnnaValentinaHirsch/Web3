*GitHub Repository "Mycelium-Lab/crisp-exchange"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: [ "main", "dev" ]
  pull_request:
    branches: [ "main", "dev" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
    - name: Check fmt
      run: cargo fmt --all -- --check
'''
'''--- Cargo.toml ---
[package]
name = "mycelium-lab-near-amm"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
serde = "0.9.0-rc2"
near-contract-standards = "3.1.0"

[patch.crates-io]
parity-secp256k1 = { git = 'https://github.com/paritytech/rust-secp256k1.git' }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- OVERVIEW.md ---
# Crisp: Functional Overview

Crisp provides the following functionality:
- [Swapping](#swapping)
- [Liquidity](#liquidity) provision (LP) with leverage
- [Lending](#lending)

## Swapping

As Crisp is a DEX, it allows swapping your tokens, e.g. USDC to NEAR. It is very much industry standard:
- choose the token you want to pay with
- choose the token you want to buy
- enter the amount
- see the price and check the slippage
- sign the transaction

It also implements multi-hop swap routing where if the pool with chosen tokens A and B doesn't exist then a route between token A and token B is found among existing pools.

## Liquidity

Liquidity for swaps is provided in liquidity pools for each token pair and work as a concentrated liquidity AMM. Liquidity provider (LP) creates a position in a chosen price range and earns a portion of swap fees proportional to their liquidity share at the current price level, as long as the price is within that price range.

In addition to that, LPs can apply [leverage](#leverage) on their liquidity positions. In this case, a liquidity position acts as collateral to borrow more tokens and multiply the position size.

LP can:
- create a liquidity position in a chosen pool
- choose their price range, position size, leverage
- see their position amounts, revenue generated, liquidation prices
- add liquidity to the position
- remove liquidity from the position
- add leverage to an existing unleveraged position
- unleverage a leveraged position
- close the position

### Leverage

Because every liquidity position has an easily and reliably determined value at any moment, every liquidity position can act as collateral for a loan, which is used to multiply the position size. The amount of leverage possible is limited by:
- the position price range
- $LTV_{max}$

With $LTV_{max}$ (loan-to-value) at its current 0.8, which means that every loan must be overcollateralized by at least 125%, the highest possible leverage gets close to 5x.

Leveraged positions hence provide up to 5x more liquidity than the LP's initial liquidity by employing the capital deposited by lenders. This generates them proportionally more revenue while also exposes the LP to higher volatility risks and potential [liquidation](#liquidation).

### Liquidation

Leveraged positions can be liquidated if the price goes far enough in either direction. As leverage is provided by borrowing fixed amounts of both tokens, collateralized by a position subject to changes of token amounts (known as "impermanent loss"), every leveraged position has two liquidation prices: below and above its price range. The higher the leverage of a position, the closer its liquidation prices will be to its active price range.

Every user can be a liquidator, finding undercollateralized positions and liquidating them. To do that they repay the outstanding loan in both tokens and acquire the position, which can then be immediately closed to take the profits or kept (it is now unleveraged, as the loan has been repaid).

Keepers are provided as protection against liquidations, they monitor user positions and close them as soon as a given price condition is met to avoid liquidation.

## Lending

Lending allows users to deposit their tokens and earn interest risk-free. These deposits fill up the reserves that are used by the leveraged liquidity positions. LPs act as borrowers when they use leverage and pay lenders the interest for using their capital.

'''
'''--- README.md ---
# Crisp

[Crisp](https://crisp.exchange/) is an open-source structured liquidity protocol on the NEAR blockchain.

This repository contains the Rust smart contract.

There is also a [frontend repository](https://github.com/Mycelium-Lab/crisp-frontend).

## How it works

The smart contract implements an advanced DEX where you can:
- trade with existing liquidity
- place concentrated liquidity positions in a chosen price range to earn trading fees
- leverage your positions up to 5x
- lend your tokens for others to borrow for leverage and earn interest
- liquidate underwater leveraged positions to earn a premium

Read a more detailed overview [here](OVERVIEW.md).

## Requirements
- NEAR 3.4.2
- Rust 1.64.0

## Setup

1. Install near-cli using instructions found [here](https://docs.near.org/tools/near-cli). 

2. Install rust using [this](https://www.rust-lang.org/tools/install).

3. Clone the repository and open it.

## Deploy

`./deploy.sh` will build and deploy the smart contract

## Usage

Interactions with the contract are documented [here](https://github.com/Mycelium-Lab/crisp-exchange/tree/main/docs).

## Tests

Run `cargo test` to run Rust tests

# License

[Apache 2.0](https://choosealicense.com/licenses/apache-2.0/)

'''
'''--- build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- deploy.sh ---
#!/bin/sh

set -e

./build.sh

echo ">> Deploying contract"

near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/mycelium_lab_near_amm.wasm
'''
'''--- docs/README.md ---
# near-amm
How to use this contract via near-cli

Set env variables:
```
export CONTRACT_ID=yourdevaccount.testnet
export NEAR_ENV=testnet
export TOKEN1=token1-ft.testnet
export TOKEN2=token2-ft.testnet
export USER_ID=someuser.testnet
```
Build contract:
```
./build.sh
```
Deploy contract:
```
./deploy.sh
```
Initialize contract:
```
near call $CONTRACT_ID new '{"owner_id": "'$CONTRACT_ID'"}" --accountId $CONTRACT_ID
```
Create pool:
```
near call $CONTRACT_ID create_pool '{"token1": "'$TOKEN1'", "token2": "'$TOKEN2'", "initial_price": 100.0, "protocol_fee": 10, "rewards": 20}' --accountId $CONTRACT_ID
```
Return - pool_id:
```
0
```
View a specific pool:
```
near view $CONTRACT_ID get_pool '{"pool_id": 0}'
```
Return - pool information:
```
[
  {
    token0: 'near-ft.testnet',
    token1: 'usn-ft.testnet',
    liquidity: 26528334.515969425,
    sqrt_price: 10,
    tick: 46054,
    positions: [
      {
        id: 0,
        owner_id: 'liquidity-provider.testnet',
        liquidity: 26528334.515969425,
        token0_real_liquidity: 123456,
        token1_real_liquidity: 13613466.3557227,
        tick_lower_bound_price: 45000,
        tick_upper_bound_price: 47007,
        sqrt_lower_bound_price: 9.48666859725659,
        sqrt_upper_bound_price: 10.487483440671777,
        is_active: false
      }
    ],
    protocol_fee: 0,
    rewards: 0
  }
]

```
View all the pools:
```
near view $CONTRACT_ID get_pools '{}'
```
Returns list of pools.

View balance of a specific account:
```
near view $CONTRACT_ID get_balance '{"account_id": "'$USER_ID'", "token": "'$TOKEN1'"}'
```
Returns balance:
```
'near-ft.testnet: 1000000000000'
```
View balance of a specific account (all the tokens):
```
near view $CONTRACT_ID get_balance_all_tokens '{"account_id": "'$USER_ID'"}'
```
Returns string containing balances:
```
'near-ft.testnet: 1000000000000, usn-ft.testnet: 100000,'
```
Deposit tokens (We have to interact with fungible token smart-contract. You should already have tokens):
```
near call $TOKEN1 storage_deposit '{"account_id": "'$CONTRACT_ID'"}' --accountId $USER_ID --amount 0.0125
near call $TOKEN1 ft_transfer_call '{"receiver_id": "'$CONTRACT_ID'", "amount": "10000", "msg": ""}' --accountId $USER_ID --depositYocto 1
```
Withdraw tokens:
```
near call $CONTRACT_ID withdraw '{"token": "'$TOKEN1'", "amount": "12345"}' --accountId $USER_ID
```
Get return (how much tokens I get if I send `amount_in` tokens to the pool):
```
near view $CONTRACT_ID get_return '{"pool_id": 0, "token_in": "'$TOKEN1'", "amount_in": "9876"}'
```
Returns amount I will get:
```
"1342"
```
Get expense (how much tokens should I send to get `amount_out` tokens from the pool):
```
near view $CONTRACT_ID get_expense '{"pool_id": 0, "token_out": "'$TOKEN1'", "amount_out": "2345"}'
```
Returns amount I will send:
```
"2453"
```
Get pool`s price:
```
near view $CONTRACT_ID get_price '{"pool_id": 0}'
```
Returns float price:
```
99.83752
```
Swap in the pool (If I know how much I want to send):
```
near call $CONTRACT_ID swap '{"pool_id": 0, "token_in": "'$TOKEN1'", "amount_in": "1357984", "token_out": "'$TOKEN2'"}' --accountId $USER_ID
```
Returns given amount I get:
```
"13562"
```
Open position (Choose only one token, amount of another token will be calculated automatically):
```
near call $CONTRACT_ID open_position '{"pool_id": 0, token0_liquidity: "100000", "lower_bound_price": 90.0, "upper_bound_price": 110.0}' --accountId $USER_ID
```
Returns position id:
```
0
```
For use through frontend you have to add parameter ```request_id``` on cross-contract call string. This parameter has to be equal for both calls (for token0.testnet and token1.testnet), to make cross-contract calls match on our contract.
Close position:
```
near call $CONTRACT_ID close_position '{"pool_id": 0, "position_id": 12}' --accountId $USER_ID
```
Returns bool (true if positions was actually closed and false otherwise)
```
true
```
Add tokens to the position:
```
near call $CONTRACT_ID add_liquidity '{"pool_id": 0, "position_id": 12, "token0_liquidity": "1000"}' --accountId $USER_ID
```
Returns bool (true if liquidity was actually added to the position and false otherwise)

Add tokens to the position:
```
near call $CONTRACT_ID remove_liquidity '{"pool_id": 0, "position_id": 12, "token0_liquidity": "1000"}' --accountId $USER_ID
```
Returns bool (true if liquidity was actually removed from the position and false otherwise)

Swap on exchange using multihope:
```
near call $CONTRACT_ID swap_multihope '{"token_in": "'$TOKEN1'", "amount_in": "100000", "token_out": "'$TOKEN2'"}' --accountId $USER_ID --gas 300000000000000
```
Returns given amount I get:
```
"13562"
```

Create reserve:
```
near call $CONTRACT_ID create_reserve '{"reserve_token": "'$TOKEN1'"}' --accountId $CONTRACT_ID
```

Create deposit:
```
near call $CONTRACT_ID create_deposit '{"asset": "'$TOKEN1'", "amount": "100000"}' --accountId $USER_ID
```

Take out arbitrary amount of tokens from deposit:
```
near call $CONTRACT_ID close_deposit '{"asset": "'$TOKEN1'", "amount": "100000"}' --accountId $USER_ID
```

Refresh deposits growth:
```
near call $CONTRACT_ID refresh_deposits_growth '{}' --accountId $CONTRACT_ID
```

Get deposits for a certain account:
```
near call $CONTRACT_ID get_account_deposits '{"account_id": "'$USER_ID'"}' --accountId $USER_ID
```
Returns all the deposits made from USER_ID account

Supply collateral and borrow with leverage:
```
near call $CONTRACT_ID supply_collateral_and_borrow '{"pool_id": 0, "position_id": 0, "leverage": 2}' --accountId $USER_ID
```

Return collateral and repay:
```
near call $CONTRACT_ID return_collateral_and_repay '{"borrow_id": 0}' --accountId $USER_ID
```

Get borrows which could be liquidated:
```
near call $CONTRACT_ID get_liquidation_list '{}' --accountId $USER_ID
```
Return vector of ids:
```
[1, 3, 5, 6]
```

Get borrow`s health factor:
```
near view $CONTRACT_ID get_borrow_health_factor '{"borrow_id": 0}'
```
Returns float
```
1.25
```

Liquidate a borrow:
```
near call $CONTRACT_ID liquidate '{"borrow_id": 0}' --accountId $USER_ID
```

How to make a deposit for lending:
1. call method ```create_deposit``` with arguments ```asset = example.near```, ```amount = 10```
2. as a default ARP for deposits is 5%
3. to close deposit use method ```close_deposit``` with argument ```deposit_id = 1```

How to borrow assets:
1. to calculate how much we can take from position use formula ```p * x + y``` (this is for second token)
2. to borrow use method ```supply_collateral_and_borrow``` with arguments ```position_id = 2``` ```pool_id = 1``` ```leverage = 4```
3. to check the health factor of a borrow use method ```get_borrow_health_factor``` with argument ```borrow_id = 0```
4. to return borrow use ```return_collateral_and_repay``` with argument ```borrow_id = 0```

'''
'''--- init.sh ---
#!/bin/sh

if [ $# -ne 2 ]; then
    echo "Usage: $0 <contract_account> <master_account>"
    exit 1
fi

CONTRACT=$1
MASTER_ACCOUNT=$2

echo ">> Initializing the contract"
near call $CONTRACT new '{"owner_id": "'$MASTER_ACCOUNT'"}' --accountId $MASTER_ACCOUNT

echo ">> Creating the pools"
near call $CONTRACT create_pool '{"token1": "usdt.fakes.testnet", "token2": "usdc.fakes.testnet", "initial_price": 1.0, "protocol_fee": 1, "rewards": 1}' --accountId $CONTRACT
near call $CONTRACT create_pool '{"token1": "wrap.testnet", "token2": "usdt.fakes.testnet", "initial_price": 0.0000000000000001, "protocol_fee": 1, "rewards": 1}' --accountId $CONTRACT

echo ">> Pools created:"
near view $CONTRACT get_pools '{}'

echo ">> Creating reserves"
near call $CONTRACT create_reserve '{"reserve_token": "'usdt.fakes.testnet'"}' --accountId $CONTRACT
near call $CONTRACT create_reserve '{"reserve_token": "usdc.fakes.testnet"}' --accountId $CONTRACT
near call $CONTRACT create_reserve '{"reserve_token": "wrap.testnet"}' --accountId $CONTRACT

'''
'''--- src/action.rs ---
use near_sdk::{
    json_types::U128,
    serde::{Deserialize, Serialize},
    AccountId,
};

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapAction {
    pub pool_id: usize,
    pub token_in: AccountId,
    pub amount_in: U128,
    pub token_out: AccountId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultihopeSwapAction {
    pub token_in: AccountId,
    pub amount_in: U128,
    pub token_out: AccountId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OpenPositionAction {
    pub request_id: usize,
    pub pool_id: usize,
    pub token0_liquidity: Option<U128>,
    pub token1_liquidity: Option<U128>,
    pub lower_bound_price: f64,
    pub upper_bound_price: f64,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AddLiquidityAction {
    pub pool_id: usize,
    pub position_id: u128,
    pub token0_liquidity: Option<U128>,
    pub token1_liquidity: Option<U128>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CreateDepositAction {
    pub asset: AccountId,
    pub amount: U128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ReturnCollateralAndRepayAction {
    pub borrow_id: u128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LiquidateAction {
    pub borrow_id: u128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WithdrawAction {
    pub token: AccountId,
    pub amount: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Swap(SwapAction),
    Withdraw(WithdrawAction),
    MultihopeSwap(MultihopeSwapAction),
    OpenPosition(OpenPositionAction),
    AddLiquidity(AddLiquidityAction),
    CreateDeposit(CreateDepositAction),
    ReturnCollateralAndRepay(ReturnCollateralAndRepayAction),
    Liquidate(LiquidateAction),
}

'''
'''--- src/balance.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::json_types::U128;
use near_sdk::{collections::UnorderedMap, AccountId};
use std::collections::HashMap;

use crate::pool::CollectedFee;

pub const GAS_FOR_FT_TRANSFER: u64 = 20_000_000_000_000;

pub type BalancesMap = UnorderedMap<AccountId, Balance>;
type Balance = UnorderedMap<AccountId, u128>;

pub use crate::*;

impl Contract {
    pub fn deposit_ft(&mut self, account_id: &AccountId, token_in: &AccountId, amount: u128) {
        if let Some(mut balance) = self.balances_map.get(account_id) {
            let current_value = balance.get(token_in).unwrap_or(0);
            let new_value = current_value + amount;
            balance.insert(token_in, &new_value);
            self.balances_map.insert(account_id, &balance);
        } else {
            let mut balance = UnorderedMap::new(account_id.clone().into_bytes());
            balance.insert(&token_in.to_string(), &amount);
            self.balances_map.insert(account_id, &balance);
        }
    }

    pub fn balance_withdraw(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        let mut balance = self.balances_map.get(account_id).expect(BAL0);
        let current_amount = balance.get(token).expect(BAL0);
        assert!(
            amount <= current_amount,
            "{}",
            withdraw_error(token, amount, current_amount)
        );
        balance.insert(token, &(current_amount - amount));
        self.balances_map.insert(account_id, &balance);
        ext_fungible_token::ft_transfer(
            account_id.to_string(),
            U128(amount),
            None,
            &token,
            1,
            GAS_FOR_FT_TRANSFER,
        );
    }

    pub fn decrease_balance(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        let mut balance = self
            .balances_map
            .get(account_id)
            .expect(&withdraw_error(token, amount, 0));
        let current_amount = balance.get(token).expect(&withdraw_error(token, amount, 0));
        assert!(
            amount <= current_amount,
            "{}",
            &withdraw_error(token, amount, current_amount)
        );
        balance.insert(token, &(current_amount - amount));
        self.balances_map.insert(account_id, &balance);
    }

    pub fn increase_balance(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        if let Some(mut balance) = self.balances_map.get(account_id) {
            let current_amount = balance.get(token).unwrap_or(0);
            balance.insert(token, &(current_amount + amount));
            self.balances_map.insert(account_id, &balance);
        } else {
            let mut balance = UnorderedMap::new(account_id.clone().into_bytes());
            balance.insert(token, &amount);
            self.balances_map.insert(account_id, &balance);
        }
    }

    pub fn apply_collected_fees(
        &mut self,
        collected_fees: &HashMap<u128, CollectedFee>,
        token: &AccountId,
    ) {
        for (_, collected_fee) in collected_fees {
            self.increase_balance(
                &collected_fee.account_id,
                token,
                collected_fee.amount.round() as u128,
            );
        }
    }
}

'''
'''--- src/borrow.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use near_sdk::AccountId;

use crate::deposit::{BASIS_POINT_BASE, MS_IN_YEAR};

pub type BorrowId = u128;
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Borrow {
    pub id: BorrowId,
    pub owner_id: AccountId,
    pub asset0: AccountId,
    pub asset1: AccountId,
    pub borrowed0: u128,
    pub borrowed1: u128,
    pub position_id: u128,
    pub pool_id: usize,
    pub last_update_timestamp: u64,
    pub apr: u16,
    pub leverage: f64,
    pub fees: u128,
    pub liquidation_price: (f64, f64),
}

impl Borrow {
    pub fn update_timestamp(&mut self, current_timestamp: u64) {
        self.last_update_timestamp = current_timestamp;
    }

    pub fn calculate_fees(&self, current_timestamp: u64) -> u128 {
        let fees = (self.borrowed1 as f64)
            * Self::timestamp_difference_to_coefficient(
                current_timestamp - self.last_update_timestamp,
                self.apr,
            );
        fees.round() as u128
    }

    fn timestamp_difference_to_coefficient(timestamp_difference: u64, apr: u16) -> f64 {
        (timestamp_difference as f64 / MS_IN_YEAR as f64)
            * (1_f64 + apr as f64 / BASIS_POINT_BASE as f64)
    }

    pub fn refresh_fees(&mut self, current_timestamp: u64) {
        self.fees += self.calculate_fees(current_timestamp);
    }
}

'''
'''--- src/deposit.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::Serialize,
    AccountId,
};

pub const MS_IN_YEAR: u64 = 31536000000;
pub const BASIS_POINT_BASE: u16 = 10000;

pub type DepositId = u128;

#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Deposit {
    pub owner_id: AccountId,
    pub asset: AccountId,
    pub amount: u128,
    pub timestamp: u64,
    pub last_update_timestamp: u64,
    pub apr: u16,
    pub growth: u128,
}

impl Deposit {
    pub fn new(owner_id: AccountId, asset: AccountId, amount: u128) -> Deposit {
        Deposit {
            owner_id,
            asset,
            amount,
            timestamp: 0,
            last_update_timestamp: 0,
            apr: 0,
            growth: 0,
        }
    }
    pub fn update_timestamp(&mut self, current_timestamp: u64) {
        self.last_update_timestamp = current_timestamp;
    }

    pub fn calculate_growth(&self, current_timestamp: u64) -> u128 {
        let growth = (self.amount as f64)
            * Self::timestamp_difference_to_coefficient(
                current_timestamp - self.last_update_timestamp,
                self.apr,
            );
        growth.round() as u128
    }

    pub fn timestamp_difference_to_coefficient(timestamp_difference: u64, apr: u16) -> f64 {
        (timestamp_difference as f64 / MS_IN_YEAR as f64) * (apr as f64 / BASIS_POINT_BASE as f64)
    }

    pub fn refresh_growth(&mut self, current_timestamp: u64) {
        self.growth += self.calculate_growth(current_timestamp);
        self.last_update_timestamp = current_timestamp;
    }

    pub fn take_growth(&mut self, amount: u128) -> u128 {
        if amount > self.growth {
            let result = self.growth;
            self.growth = 0;
            result
        } else {
            self.growth -= amount;
            amount
        }
    }
}
#[cfg(test)]
mod test {

    use crate::deposit::*;

    #[test]
    fn timestamp_difference_to_coefficient_test() {
        let asset_token = "wnear".to_string();
        let deposit = Deposit::new(String::new(), asset_token.clone(), 500);
        assert!(deposit.owner_id == String::new(), "{}", "No valid owner id");
        let current_timestamp = 100;
        let last_update_timestamp = 50;
        let timestamp_difference = current_timestamp - last_update_timestamp;
        assert_eq!(timestamp_difference, 50);
        let coefficent =
            Deposit::timestamp_difference_to_coefficient(timestamp_difference, deposit.apr);
        assert_eq!(coefficent, 0.0);
    }

    #[test]
    fn update_timestamp_test() {
        let asset_token = "wnear".to_string();
        let mut deposit = Deposit::new(String::new(), asset_token.clone(), 500);
        assert!(deposit.owner_id == String::new(), "{}", "No valid owner id");
        let current_timestamp = 50;
        assert_eq!(deposit.last_update_timestamp, 0);
        deposit.update_timestamp(current_timestamp);
        assert_eq!(deposit.last_update_timestamp, 50);
    }

    #[test]
    fn calculate_growth_test() {
        let asset_token = "wnear".to_string();
        let mut deposit = Deposit::new(String::new(), asset_token.clone(), 500);
        assert!(deposit.owner_id == String::new(), "{}", "No valid owner id");
        let mut current_timestamp = 20;
        assert!(deposit.last_update_timestamp == 0);
        deposit.update_timestamp(current_timestamp);
        assert!(deposit.last_update_timestamp == 20);
        current_timestamp = 100;
        let coefficentt = Deposit::timestamp_difference_to_coefficient(
            current_timestamp - deposit.last_update_timestamp,
            deposit.apr,
        );
        assert_eq!(coefficentt, 0.0);
        assert!(deposit.amount == 500);
        let growth = deposit.calculate_growth(current_timestamp);
        assert_eq!(growth, 0); // ?
    }

    #[test]
    fn take_growth_test() {
        let asset_token = "wnear".to_string();
        let mut deposit = Deposit::new(String::new(), asset_token.clone(), 500);
        assert!(deposit.owner_id == String::new(), "{}", "No valid owner id");
        assert!(deposit.amount == 500);
        let growth = deposit.take_growth(deposit.amount);
        assert!(growth == 0);
        deposit.growth = 501;
        let growth_1 = deposit.take_growth(deposit.amount);
        assert_eq!(growth_1, 500);
    }

    #[test]
    fn check_growth() {
        let mut deposit = Deposit::new(String::new(), String::new(), 100);
        deposit.apr = 500;
        let index = Deposit::timestamp_difference_to_coefficient(MS_IN_YEAR, 500);
        assert_eq!(index, 0.05);
        let growth = deposit.calculate_growth(MS_IN_YEAR);
        assert_eq!(growth, 5);
        deposit.refresh_growth(MS_IN_YEAR);
        assert_eq!(deposit.growth, 5);
    }
}

'''
'''--- src/errors.rs ---
use near_sdk::AccountId;

pub const BAD_POOL_ID: &str = "Bad pool_id";

pub const NFT0: &str = "NFT not found";
pub const NFT1: &str = "Predecessor must be the token owner.";
pub const NFT2: &str = "Requires attached deposit of exactly 1 yoctoNEAR";
pub const NFT3: &str = "Token should be owned by the sender";
pub const _NFT4: &str = "Unauthorized";
pub const NFT5: &str = "Sender is not approved account";
pub const NFT6: &str = "The token owner and the receiver should be different";
pub const NFT7: &str = "Token already exists";
pub const NFT8: &str = "Market cannot payout to that many receivers";

pub const BAL0: &str = "Token has not been deposited";
pub const BAL1: &str = "Account is not registered";

pub const SWP0: &str = "Route does not exist!";
pub const SWP1: &str = "Not enough liquidity in pool to cover this swap";

pub const PST0: &str = "Position not found";
pub const PST1: &str = "token0 liqudity cannot be 0";
pub const PST2: &str = "send token1 liquidity instead of token0";
pub const PST3: &str = "token1 liqudity cannot be 0";
pub const PST4: &str = "send token0 liquidity instead of token1";
pub const PST5: &str = "Incorrect token";

pub const RSR0: &str = "Reserve not found";

pub const DPS0: &str = "Deposit not found";
pub const DPS1: &str = "You do not own this deposit";

pub const BRR0: &str = "Borrow not found";

pub fn withdraw_error(token: &AccountId, amount: u128, amount_actual: u128) -> String {
    format!(
        "You want to withdraw {} of {} but only have {}",
        amount, token, amount_actual
    )
}

pub fn borrow_error(token: &AccountId, amount: u128, amount_actual: u128) -> String {
    format!(
        "You want to borrow {} of {} but only {} is available in reserve",
        amount, token, amount_actual
    )
}

'''
'''--- src/futures.rs ---
enum FuturesType {
    Deliverable,
    Settlement,
}

pub struct Futures {
    pub price: f64,
    pub expiration_ts: u64,
    pub futures_type: FuturesType,
    pub token: AccountId,
    pub collateral: u128,
}
'''
'''--- src/lib.rs ---
use balance::borrow::{Borrow, BorrowId};
use balance::deposit::{Deposit, DepositId};
use balance::reserve::Reserve;
use balance::token_receiver::OpenPositionRequest;
pub use balance::BalancesMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::{env, ext_contract, near_bindgen};
use near_sdk::{AccountId, PanicOnDefault};
use nft::metadata::{NFTContractMetadata, Token, TokenId, TokenMetadata};
use pool::Pool;

pub use crate::balance::*;
use crate::errors::*;
use crate::nft::nft_core::NonFungibleTokenCore;
use crate::position::Position;

pub mod balance;
mod errors;
pub mod pool;
pub mod position;
mod token_receiver;

use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{Balance, CryptoHash, Promise, PromiseOrValue};
use std::collections::HashMap;

mod action;
mod borrow;
mod deposit;
mod nft;
mod reserve;

#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NFTContractMetadata,
    Balances,
    Reserves,
    Borrows,
}

pub const NFT_METADATA_SPEC: &str = "1.0.0";
pub const NFT_STANDARD_NAME: &str = "nep171";
pub const BASIS_POINT: f64 = 1.0001;
pub const BASIS_POINT_TO_PERCENT: f64 = 10000.0;
pub const APR_DEPOSIT: u16 = 500;
pub const APR_BORROW: u16 = 1000;

/// Maximum Loan-to-Value (LTV) ratio
/// This is the maximum ratio of the loan amount to the value of the collateral.
/// For example, if LTV_MAX is 0.8, you can borrow up to 80% of the value of your collateral.
pub const LTV_MAX: f64 = 0.8;

pub const TGAS: u64 = 1000000000000;

type Pair = (AccountId, AccountId);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub pools: Vec<Pool>,
    //  Accounts registered, keeping track all the amounts deposited
    pub balances_map: BalancesMap,
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub tokens_by_id: LookupMap<TokenId, Token>,
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
    pub metadata: LazyOption<NFTContractMetadata>,
    pub positions_opened: u128,
    pub deposits: HashMap<AccountId, HashMap<TokenId, Deposit>>,
    pub deposits_created_number: DepositId,
    pub reserves: UnorderedMap<AccountId, Reserve>,
    pub borrows: UnorderedMap<BorrowId, Borrow>,
    pub borrows_number: BorrowId,
    pub routes: HashMap<Pair, Vec<i32>>,
    pub routes_counter: i32,
    pub open_position_requests: HashMap<usize, OpenPositionRequest>,
}

#[ext_contract(ext_self)]
pub trait SelfCallbacks {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let metadata = NFTContractMetadata {
            spec: "nft-1.0.0".to_string(),
            name: "Crisp Exchange Contract".to_string(),
            symbol: "CRISP.EX".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
        Self {
            owner_id,
            pools: Vec::new(),
            balances_map: UnorderedMap::new(StorageKey::Balances.try_to_vec().unwrap()),
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
            positions_opened: 0,
            deposits: HashMap::new(),
            deposits_created_number: 0,
            reserves: UnorderedMap::new(StorageKey::Reserves.try_to_vec().unwrap()),
            borrows: UnorderedMap::new(StorageKey::Borrows.try_to_vec().unwrap()),
            borrows_number: 0,
            routes: HashMap::new(),
            routes_counter: 1,
            open_position_requests: HashMap::new(),
        }
    }

    #[private]
    pub fn create_pool(
        &mut self,
        token1: AccountId,
        token2: AccountId,
        initial_price: f64,
        protocol_fee: u16,
        rewards: u16,
    ) -> i32 {
        self.pools.push(Pool::new(
            token1.clone(),
            token2.clone(),
            initial_price,
            protocol_fee,
            rewards,
        ));
        assert!(!self.routes.contains_key(&(token1.clone(), token2.clone())));
        assert!(!self.routes.contains_key(&(token2.clone(), token1.clone())));
        let routes = self.routes.clone();
        for (pair, route) in routes {
            if pair.0 == token1 {
                let mut new_route = route.clone();
                new_route.push(self.routes_counter);
                self.routes
                    .insert((pair.0.clone(), token2.clone()), new_route.clone());
                self.routes.insert(
                    (token2.clone(), pair.0.clone()),
                    Self::modify_vec(new_route),
                );
            } else if pair.0 == token2 {
                let mut new_route = route.clone();
                new_route.push(self.routes_counter);
                self.routes
                    .insert((pair.0.clone(), token1.clone()), new_route.clone());
                self.routes.insert(
                    (token1.clone(), pair.0.clone()),
                    Self::modify_vec(new_route),
                );
            } else if pair.1 == token1 {
                let mut new_route = route.clone();
                new_route.push(self.routes_counter);
                self.routes
                    .insert((pair.0.clone(), token2.clone()), new_route.clone());
                self.routes.insert(
                    (token2.clone(), pair.0.clone()),
                    Self::modify_vec(new_route),
                );
            } else if pair.1 == token2 {
                let mut new_route = route.clone();
                new_route.push(-self.routes_counter);
                self.routes
                    .insert((pair.0.clone(), token1.clone()), new_route.clone());
                self.routes.insert(
                    (token1.clone(), pair.0.clone()),
                    Self::modify_vec(new_route),
                );
            }
        }
        self.routes
            .insert((token1.clone(), token2.clone()), vec![self.routes_counter]);
        self.routes
            .insert((token2.clone(), token1.clone()), vec![-self.routes_counter]);
        self.routes_counter += 1;
        self.routes_counter - 1
    }

    fn modify_vec(mut vec: Vec<i32>) -> Vec<i32> {
        vec.reverse();
        vec.into_iter().map(|x| -x).collect()
    }

    pub fn positions_opened(&self) -> u128 {
        self.positions_opened
    }

    #[private]
    pub fn remove_pool(&mut self, pool_id: usize) {
        self.assert_pool_exists(pool_id);
        self.pools.remove(pool_id);
    }

    pub fn get_pools(&self) -> Vec<Pool> {
        self.pools.clone()
    }

    fn assert_pool_exists(&self, pool_id: usize) {
        assert!(pool_id < self.pools.len(), "{}", BAD_POOL_ID);
    }

    fn assert_account_owns_nft(account_id: &AccountId, nft_owner: &AccountId) {
        assert!(account_id == nft_owner);
    }

    pub fn get_pool(&self, pool_id: usize) -> Pool {
        self.assert_pool_exists(pool_id);
        self.pools[pool_id].clone()
    }

    pub fn get_balance(&self, account_id: &AccountId, token: &AccountId) -> U128 {
        let balance = match self.balances_map.get(account_id) {
            None => panic!("{}", BAL1),
            Some(balance) => balance.get(token),
        };
        if let Some(amount) = balance {
            amount.into()
        } else {
            U128(0)
        }
    }

    pub fn get_balance_all_tokens(&self, account_id: &AccountId) -> String {
        if let Some(balance) = self.balances_map.get(account_id) {
            let mut result = String::new();
            for (token, amount) in balance.iter() {
                result += &format!("{token}: {amount}, ");
            }
            result
        } else {
            String::new()
        }
    }

    pub fn withdraw(&mut self, token: &AccountId, amount: U128) {
        let account_id = env::signer_account_id();
        let amount: u128 = amount.into();
        self.balance_withdraw(&account_id, token, amount);
    }

    pub fn get_return(&self, pool_id: usize, token_in: &AccountId, amount_in: U128) -> U128 {
        let pool = self.get_pool(pool_id);
        let swap_result =
            pool.get_swap_result(token_in, amount_in.into(), pool::SwapDirection::Return);
        let fees_amount = swap_result.amount * (pool.protocol_fee as f64 + pool.rewards as f64)
            / BASIS_POINT_TO_PERCENT;
        (swap_result.amount.round() as u128 - fees_amount.round() as u128).into()
    }

    // not too accurate because of fees :( [TO DO]
    pub fn get_expense(&self, pool_id: usize, token_out: &AccountId, amount_out: U128) -> U128 {
        let pool = self.get_pool(pool_id);
        let swap_result =
            pool.get_swap_result(token_out, amount_out.into(), pool::SwapDirection::Expense);
        (swap_result.amount.round() as u128).into()
    }

    pub fn get_price(&self, pool_id: usize) -> f64 {
        self.get_pool(pool_id).sqrt_price.powf(2.0)
    }

    pub fn swap(
        &mut self,
        pool_id: usize,
        token_in: &AccountId,
        amount_in: U128,
        token_out: &AccountId,
    ) -> U128 {
        self.assert_pool_exists(pool_id);
        let account_id = env::signer_account_id();
        let amount_in: u128 = amount_in.into();
        self.decrease_balance(&account_id, token_in, amount_in);
        let pool = &mut self.pools[pool_id];
        let swap_result = pool.get_swap_result(token_in, amount_in, pool::SwapDirection::Return);
        let fees_amount = swap_result.amount * (pool.protocol_fee as f64 + pool.rewards as f64)
            / BASIS_POINT_TO_PERCENT;
        self.apply_collected_fees(&swap_result.collected_fees, token_out);
        let result_amount = swap_result.amount.round() as u128 - fees_amount.round() as u128;
        self.increase_balance(&account_id, token_out, result_amount);
        let pool = &mut self.pools[pool_id];
        pool.apply_swap_result(&swap_result);
        pool.refresh(env::block_timestamp());
        result_amount.into()
    }

    pub fn swap_multihope(
        &mut self,
        token_in: &AccountId,
        amount_in: U128,
        token_out: &AccountId,
    ) -> U128 {
        let mut amount = amount_in;
        let route = self
            .routes
            .get(&(token_in.to_string(), token_out.to_string()))
            .expect(SWP0)
            .clone();
        for pool_id in route {
            if pool_id > 0 {
                let pool = self.pools[pool_id as usize].clone();
                amount = self.swap(pool_id as usize, &pool.token0, amount, &pool.token1);
            } else {
                let pool = self.pools[-pool_id as usize].clone();
                amount = self.swap(-pool_id as usize, &pool.token1, amount, &pool.token0);
            }
        }
        amount
    }

    pub fn open_position(
        &mut self,
        pool_id: usize,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
        lower_bound_price: f64,
        upper_bound_price: f64,
    ) -> u128 {
        self.assert_pool_exists(pool_id);
        let position_id = self.positions_opened;
        self.positions_opened += 1;
        let pool = &self.pools[pool_id];
        let account_id = env::signer_account_id();
        let position = Position::new(
            account_id.clone(),
            token0_liquidity,
            token1_liquidity,
            lower_bound_price,
            upper_bound_price,
            pool.sqrt_price,
        );
        let token0 = pool.token0.clone();
        let token1 = pool.token1.clone();
        self.decrease_balance(&account_id, &token0, position.token0_locked.round() as u128);
        self.decrease_balance(&account_id, &token1, position.token1_locked.round() as u128);
        let pool = &mut self.pools[pool_id];
        pool.open_position(position_id, position.clone());
        pool.refresh(env::block_timestamp());
        let metadata = TokenMetadata::new(pool_id, position_id, &position);
        self.nft_mint(position_id.to_string(), account_id.clone(), metadata);
        position_id
    }

    pub fn close_position(&mut self, pool_id: usize, position_id: u128) {
        self.assert_pool_exists(pool_id);
        let pool = &self.pools[pool_id];
        let account_id = env::predecessor_account_id();
        let token = self.tokens_by_id.get(&position_id.to_string()).expect(NFT0);
        Self::assert_account_owns_nft(&account_id, &token.owner_id);
        let position = pool.positions.get(&position_id).expect(PST0);
        let amount0 = position.token0_locked.round() as u128;
        let amount1 = position.token1_locked.round() as u128;
        let token0 = pool.token0.clone();
        let token1 = pool.token1.clone();
        self.increase_balance(&account_id, &token0, amount0);
        self.increase_balance(&account_id, &token1, amount1);
        let pool = &mut self.pools[pool_id];
        pool.close_position(position_id);
    }

    pub fn add_liquidity(
        &mut self,
        pool_id: usize,
        position_id: u128,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
    ) {
        self.assert_pool_exists(pool_id);
        let pool = &mut self.pools[pool_id];
        let account_id = env::predecessor_account_id();
        let token = self.tokens_by_id.get(&position_id.to_string()).expect(NFT0);
        Self::assert_account_owns_nft(&account_id, &token.owner_id);
        let mut position = pool.positions.get(&position_id).expect(PST0).clone();
        let token0_locked_before = position.token0_locked as u128;
        let token1_locked_before = position.token1_locked as u128;
        position.add_liquidity(token0_liquidity, token1_liquidity, pool.sqrt_price);
        let token0_locked_after = position.token0_locked as u128;
        let token1_locked_after = position.token1_locked as u128;
        pool.positions.insert(position_id, position);
        pool.refresh(env::block_timestamp());
        let token0 = pool.token0.to_string();
        let token1 = pool.token1.to_string();
        self.decrease_balance(
            &account_id,
            &token0,
            token0_locked_after - token0_locked_before,
        );
        self.decrease_balance(
            &account_id,
            &token1,
            token1_locked_after - token1_locked_before,
        );
    }

    pub fn remove_liquidity(
        &mut self,
        pool_id: usize,
        position_id: u128,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
    ) {
        self.assert_pool_exists(pool_id);
        let pool = &mut self.pools[pool_id];
        let account_id = env::predecessor_account_id();
        let token = self.tokens_by_id.get(&position_id.to_string()).expect(NFT0);
        Self::assert_account_owns_nft(&account_id, &token.owner_id);
        let mut position = pool.positions.get(&position_id).expect(PST0).clone();
        let token0_locked_before = position.token0_locked as u128;
        let token1_locked_before = position.token1_locked as u128;
        position.remove_liquidity(token0_liquidity, token1_liquidity, pool.sqrt_price);
        let token0_locked_after = position.token0_locked as u128;
        let token1_locked_after = position.token1_locked as u128;
        pool.positions.insert(position_id, position);
        pool.refresh(env::block_timestamp());
        let token0 = pool.token0.to_string();
        let token1 = pool.token1.to_string();
        self.increase_balance(
            &account_id,
            &token0,
            token0_locked_before - token0_locked_after,
        );
        self.increase_balance(
            &account_id,
            &token1,
            token1_locked_before - token1_locked_after,
        );
    }

    #[private]
    pub fn create_reserve(&mut self, reserve_token: &AccountId) {
        let reserve = Reserve::default();
        self.reserves.insert(reserve_token, &reserve);
    }

    pub fn create_deposit(&mut self, asset: &AccountId, amount: U128) {
        let account_id = env::predecessor_account_id();
        let timestamp = env::block_timestamp();
        if let Some(map) = self.deposits.get(&account_id) {
            if let Some(deposit) = map.get(asset) {
                let old_amount = deposit.amount;
                let old_growth = deposit.growth;
                let deposit = Deposit {
                    owner_id: account_id.clone(),
                    asset: asset.clone(),
                    amount: amount.0 + old_amount,
                    timestamp,
                    last_update_timestamp: timestamp,
                    apr: APR_DEPOSIT,
                    growth: old_growth,
                };
                let mut map = map.clone();
                map.insert(asset.clone(), deposit);
                self.deposits.insert(account_id.clone(), map);
            } else {
                let deposit = Deposit {
                    owner_id: account_id.clone(),
                    asset: asset.clone(),
                    amount: amount.0,
                    timestamp,
                    last_update_timestamp: timestamp,
                    apr: APR_DEPOSIT,
                    growth: 0,
                };
                let mut map = map.clone();
                map.insert(asset.clone(), deposit);
                self.deposits.insert(account_id.clone(), map.clone());
            }
        } else {
            let deposit = Deposit {
                owner_id: account_id.clone(),
                asset: asset.clone(),
                amount: amount.0,
                timestamp,
                last_update_timestamp: timestamp,
                apr: APR_DEPOSIT,
                growth: 0,
            };
            let mut map = HashMap::new();
            map.insert(asset.clone(), deposit);
            self.deposits.insert(account_id.clone(), map);
        }
        self.decrease_balance(&account_id, &asset.to_string(), amount.0);

        let mut reserve = self.reserves.get(&asset).expect(RSR0);
        reserve.increase_deposit(amount.0);
        self.reserves.insert(&asset, &reserve);
    }

    pub fn close_deposit(&mut self, asset: &AccountId, amount: U128) {
        let account_id = env::predecessor_account_id();
        let timestamp = env::block_timestamp();
        let map = self.deposits.get(&account_id).unwrap();
        let deposit = map.get(asset).unwrap();
        let old_amount = deposit.amount;
        assert!(old_amount >= amount.0);
        let old_growth = deposit.growth;
        let deposit = Deposit {
            owner_id: account_id.clone(),
            asset: asset.clone(),
            amount: old_amount - amount.0,
            timestamp,
            last_update_timestamp: timestamp,
            apr: APR_DEPOSIT,
            growth: old_growth,
        };
        let mut map = map.clone();
        map.insert(asset.clone(), deposit);
        self.deposits.insert(account_id.clone(), map.clone());
        self.increase_balance(&account_id, &asset.to_string(), amount.0);

        let mut reserve = self.reserves.get(&asset).expect(RSR0);
        reserve.decrease_deposit(amount.0);
        self.reserves.insert(&asset, &reserve);
    }

    pub fn refresh_deposits_growth(&mut self) {
        let current_timestamp = env::block_timestamp();
        for (_, map) in &mut self.deposits {
            for (_, deposit) in map {
                deposit.refresh_growth(current_timestamp);
            }
        }
    }

    // #[allow(unused_assignments)]
    // pub fn take_deposit_growth(&mut self, asset: AccountId, amount: U128) -> U128 {
    //     let account_id = env::predecessor_account_id();
    //     let mut growth = 0;
    //     let map = self.deposits.get_mut(&account_id).expect(DPS0);
    //     let deposit
    //     assert_eq!(deposit.owner_id, account_id, "{}", DPS1);
    //     deposit.refresh_growth(env::block_timestamp());
    //     growth = deposit.take_growth(amount.0);
    //     asset = Some(deposit.asset.clone());
    //     if let Some(asset) = asset {
    //         self.increase_balance(&account_id, &asset, growth);
    //         return growth.into();
    //     }
    //     0.into()
    // }

    pub fn get_account_deposits(&self, account_id: AccountId) -> HashMap<TokenId, Deposit> {
        if let Some(deposit) = self.deposits.get(&account_id) {
            deposit.clone()
        } else {
            HashMap::new()
        }
    }

    // #[payable]
    // pub fn supply_collateral_and_borrow_simple(
    //     &mut self,
    //     pool_id: usize,
    //     position_id: u128,
    // ) -> U128 {
    //     let account_id = env::predecessor_account_id();
    //     let pool = &self.pools[pool_id];
    //     let position = pool.positions.get(&position_id).expect(PST0).clone();
    //     let token = pool.token1.clone();
    //     let collateral = position.total_locked;
    //     let borrowed = (BORROW_RATIO * collateral).round() as u128; // health factor 1.25
    //     let liquidation_price = position.get_liquidation_price(borrowed as f64);
    //     self.increase_balance(&account_id, &token, borrowed);
    //     let mut reserve = self.reserves.get(&token).expect(RSR0);
    //     reserve.borrowed += borrowed;
    //     assert!(
    //         reserve.deposited >= reserve.borrowed,
    //         "{}",
    //         borrow_error(&token, reserve.borrowed, reserve.deposited)
    //     );
    //     self.reserves.insert(&token, &reserve);
    //     let borrow = Borrow {
    //         owner_id: account_id,
    //         asset0: String::new(),
    //         asset1: token.to_string(),
    //         borrowed0: 0,
    //         borrowed1: borrowed,
    //         collateral: collateral as u128,
    //         position_id,
    //         pool_id,
    //         last_update_timestamp: env::block_timestamp(),
    //         apr: APR_BORROW,
    //         leverage: None,
    //         fees: 0,
    //         liquidation_price,
    //     };
    //     self.borrows.insert(&self.borrows_number, &borrow);
    //     self.borrows_number += 1;
    //     self.nft_transfer(
    //         env::current_account_id(),
    //         position_id.to_string(),
    //         None,
    //         None,
    //     );
    //     borrowed.into()
    // }

    #[payable]
    pub fn supply_collateral_and_borrow(
        &mut self,
        pool_id: usize,
        position_id: u128,
        leverage: f64,
    ) {
        assert!(leverage > 1.0);
        let account_id = env::predecessor_account_id();
        let pool = &mut self.pools[pool_id];
        let token0 = pool.token0.clone();
        let token1 = pool.token1.clone();
        let position = pool.positions.get(&position_id).expect(PST0).clone();
        let borrowed0 = (position.token0_locked * (leverage - 1.0)) as u128;
        let borrowed1 = (position.token1_locked * (leverage - 1.0)) as u128;

        let mut reserve = self.reserves.get(&token0).expect(RSR0);
        reserve.borrowed += borrowed0;
        assert!(reserve.deposited >= reserve.borrowed);
        self.reserves.insert(&token0, &reserve);

        let mut reserve = self.reserves.get(&token1).expect(RSR0);
        reserve.borrowed += borrowed1;
        assert!(reserve.deposited >= reserve.borrowed);
        self.reserves.insert(&token1, &reserve);

        let mut position = pool.positions.get(&position_id).expect(PST0).clone();
        position.add_liquidity(
            Some(U128::from(borrowed0)),
            None,
            pool.sqrt_price,
        );
        let liquidation_price = position.get_liquidation_price(borrowed0 as f64, borrowed1 as f64, LTV_MAX);
        pool.positions.insert(position_id, position);

        let borrow = Borrow {
            id: self.borrows_number,
            owner_id: account_id,
            asset0: token0,
            asset1: token1,
            borrowed0,
            borrowed1,
            position_id,
            pool_id,
            last_update_timestamp: env::block_timestamp(),
            apr: APR_BORROW,
            leverage: leverage,
            fees: 0,
            liquidation_price,
        };
        self.borrows.insert(&self.borrows_number, &borrow);
        self.borrows_number += 1;
        // Make sure the loan is sufficiently overcollateralized
        let health_factor = self.get_borrow_health_factor(borrow.id);
        assert!(health_factor >= 1.0);

        // commented out for now because when NFT is tranferred away from the owner
        // other functions will fail without it, including return_collateral_and_repay()
        //
        // self.nft_transfer(
        //     env::current_account_id(),
        //     position_id.to_string(),
        //     None,
        //     None,
        // );
    }

    pub fn return_collateral_and_repay(&mut self, borrow_id: u128) {
        let account_id = env::predecessor_account_id();
        let borrow = self.borrows.remove(&borrow_id).expect(BRR0);
        let pool = &self.pools[borrow.pool_id];
        let position = pool.positions.get(&borrow.position_id).expect(PST0);
        assert_eq!(account_id, borrow.owner_id);
        let mut reserve = self.reserves.get(&borrow.asset0).expect(RSR0);
        reserve.borrowed -= borrow.borrowed0;
        self.reserves.insert(&borrow.asset0, &reserve);
        let mut reserve = self.reserves.get(&borrow.asset1).expect(RSR0);
        reserve.borrowed -= borrow.borrowed1;
        self.reserves.insert(&borrow.asset1, &reserve);
        self.remove_liquidity(
            borrow.pool_id,
            borrow.position_id,
            None,
            Some(U128::from(borrow.borrowed1 + borrow.fees)),
        );
        // ext_self::nft_transfer(
        //     account_id,
        //     borrow.position_id.to_string(),
        //     None,
        //     None,
        //     &env::current_account_id(),
        //     0,
        //     10 * TGAS,
        // );
    }

    pub fn get_liquidation_list(&self) -> Vec<BorrowId> {
        self.borrows
            .iter()
            .filter(|(id, _)| self.get_borrow_health_factor(*id) < 1.0)
            .map(|(id, _)| id)
            .collect()
    }

    pub fn get_borrows_by_account(&self, account_id: AccountId) -> Vec<Borrow> {
        self.borrows
            .iter()
            .filter(|(_, borrow)| borrow.owner_id == account_id)
            .map(|(_, borrow)| borrow)
            .collect()
    }

    pub fn get_liquidation_price(
        &self,
        pool_id: usize,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
        lower_bound_price: f64,
        upper_bound_price: f64,
        borrowed0: f64,
        borrowed1: f64,
    ) -> (f64, f64) {
        self.assert_pool_exists(pool_id);
        let pool = &self.pools[pool_id];
        let position = Position::new(
            String::new(),
            token0_liquidity.map(|v| U128(v.0 + borrowed0 as u128)).or(None),
            token1_liquidity.map(|v| U128(v.0 + borrowed1 as u128)).or(None),
            lower_bound_price,
            upper_bound_price,
            pool.sqrt_price,
        );
        position.get_liquidation_price(borrowed0, borrowed1, LTV_MAX)
    }

    pub fn get_max_leverage(
        &self,
        pool_id: usize,
        lower_bound_price: f64,
        upper_bound_price: f64,
    ) -> f64 {
        self.assert_pool_exists(pool_id);
        let pool = &self.pools[pool_id];
        let pb = upper_bound_price;
        let rpa = lower_bound_price.sqrt();
        let rpb = upper_bound_price.sqrt();
        let rp = pool.sqrt_price;
        if rp > rpa && rp < rpb {
            1.0 / (1.0 - LTV_MAX / f64::max(
                ((rp - rpa) / (rpb - rpa)) * (rp / rpa) + ((rpb - rp) / (rpb - rpa)) * (rpa / rp),
                (pb / rp - rpb + rp - rpa) / (rpb - rpa)
            ))
        } else {
            1.0 / (1.0 - LTV_MAX * rpa / rpb)
        }
    }

    pub fn get_borrow_health_factor(&self, borrow_id: BorrowId) -> f64 {
        let borrow = self.borrows.get(&borrow_id).expect(BRR0);
        let pool = &self.pools[borrow.pool_id];
        let position = pool.positions.get(&borrow.position_id).unwrap();
        let price = pool.sqrt_price * pool.sqrt_price;
        let ltv = (borrow.borrowed0 as f64 * price + borrow.borrowed1 as f64) / (position.total_locked as f64);
        LTV_MAX / ltv
    }

    pub fn liquidate(&mut self, borrow_id: BorrowId) {
        let account_id = env::predecessor_account_id();
        let borrow = self.borrows.remove(&borrow_id).expect(BRR0);
        let pool = &self.pools[borrow.pool_id];
        let position = pool.positions.get(&borrow.position_id).unwrap();
        let health_factor = self.get_borrow_health_factor(borrow_id);
        assert!(health_factor < 1.0);
        let discount = (1.0 + health_factor) / 2.0;
        let discounted_collateral_sum = (position.total_locked * discount / borrow.leverage) as u128;
        self.decrease_balance(&account_id, &borrow.asset1, discounted_collateral_sum);
        if let leverage = borrow.leverage {
            let pool = &mut self.pools[borrow.pool_id];
            let mut position = pool.positions.get(&borrow.position_id).unwrap().clone();
            position.remove_liquidity(
                Some(U128::from(
                    (position.token0_locked * (leverage - 1.0) / leverage) as u128,
                )),
                None,
                pool.sqrt_price,
            );
            pool.positions.insert(borrow.position_id, position);
        }
        ext_self::nft_transfer(
            account_id,
            borrow.position_id.to_string(),
            None,
            None,
            &env::current_account_id(),
            0,
            10 * TGAS,
        );
    }
}

'''
'''--- src/nft/approval.rs ---
use crate::{
    nft::internal::{
        assert_at_least_one_yocto, assert_one_yocto, bytes_for_approved_account_id,
        refund_approved_account_ids, refund_approved_account_ids_iter, refund_deposit,
    },
    *,
};
use near_sdk::ext_contract;

use super::metadata::TokenId;

pub const GAS: u64 = 30_000_000_000_000;
pub trait NonFungibleTokenCore {
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        assert_at_least_one_yocto();
        let mut token = self.tokens_by_id.get(&token_id).expect(NFT0);
        assert_eq!(&env::predecessor_account_id(), &token.owner_id, "{}", NFT1);
        let approval_id: u64 = token.next_approval_id;
        let is_new_approval = token
            .approved_account_ids
            .insert(account_id.clone(), approval_id)
            .is_none();
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        } else {
            0
        };
        token.next_approval_id += 1;
        self.tokens_by_id.insert(&token_id, &token);
        refund_deposit(storage_used);
        if let Some(msg) = msg {
            ext_non_fungible_approval_receiver::nft_on_approve(
                token_id,
                token.owner_id,
                approval_id,
                msg,
                &account_id,
                0,
                GAS,
            );
        }
    }

    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        let token = self.tokens_by_id.get(&token_id).expect(NFT0);
        if let Some(approval) = token.approved_account_ids.get(&approved_account_id) {
            if let Some(approval_id) = approval_id {
                approval_id == *approval
            } else {
                true
            }
        } else {
            false
        }
    }

    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        assert_one_yocto();
        let mut token = self.tokens_by_id.get(&token_id).expect(NFT0);
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);
        if token.approved_account_ids.remove(&account_id).is_some() {
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        assert_one_yocto();
        let mut token = self.tokens_by_id.get(&token_id).expect(NFT0);
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);
        if !token.approved_account_ids.is_empty() {
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            token.approved_account_ids.clear();
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}

'''
'''--- src/nft/enumeration.rs ---
use crate::{nft::nft_core::NonFungibleTokenCore, *};

use super::metadata::JsonToken;

#[near_bindgen]
impl Contract {
    pub fn nft_total_supply(&self) -> U128 {
        U128(self.token_metadata_by_id.len() as u128)
    }

    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let start = u128::from(from_index.unwrap_or(U128(0)));
        self.token_metadata_by_id
            .keys()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            U128(0)
        }
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            return vec![];
        };
        let start = u128::from(from_index.unwrap_or(U128(0)));
        tokens
            .iter()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }
}

'''
'''--- src/nft/events.rs ---
use std::fmt;

use near_sdk::{
    serde::{Deserialize, Serialize},
    serde_json,
};

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,
    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,
    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
}

'''
'''--- src/nft/internal.rs ---
use crate::{
    nft::events::{EventLog, EventLogVariant, NftTransferLog},
    *,
};
use near_sdk::CryptoHash;
use std::mem::size_of;

use super::metadata::{Token, TokenId};

pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I,
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1, "{}", NFT2)
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1, "{}", NFT2)
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );
    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        tokens_set.insert(token_id);
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        let mut tokens_set = self.tokens_per_owner.get(account_id).expect(NFT3);
        tokens_set.remove(token_id);
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        let token = self.tokens_by_id.get(token_id).expect(NFT0);
        if sender_id != &token.owner_id {
            // if !token.approved_account_ids.contains_key(sender_id) {
            //     panic!("{}", NFT4);
            // }
            if let Some(enforced_approval_id) = approval_id {
                let actual_approval_id = token.approved_account_ids.get(sender_id).expect(NFT5);
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }
        assert_ne!(&token.owner_id, receiver_id, "{}", NFT6);
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        self.internal_add_token_to_owner(receiver_id, token_id);
        if receiver_id.to_string() != env::current_account_id() {
            let id = token_id.parse::<u128>().unwrap();
            for pool in &mut self.pools {
                if let Some(position) = pool.positions.get(&id) {
                    let mut position = position.clone();
                    position.owner_id = receiver_id.to_string();
                    pool.positions.insert(id, position);
                }
            }
        }
        let new_token = Token {
            owner_id: receiver_id.clone(),
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
            royalty: token.royalty.clone(),
        };
        self.tokens_by_id.insert(token_id, &new_token);
        if let Some(memo) = memo.as_ref() {
            env::log(&format!("Memo: {}", memo).to_string().as_bytes());
        }
        let mut authorized_id = None;
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }
        let nft_transfer_log: EventLog = EventLog {
            standard: NFT_STANDARD_NAME.to_string(),
            version: NFT_METADATA_SPEC.to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id,
                old_owner_id: token.owner_id.to_string(),
                new_owner_id: receiver_id.to_string(),
                token_ids: vec![token_id.to_string()],
                memo,
            }]),
        };
        env::log(&nft_transfer_log.to_string().as_bytes());
        token
    }
}

'''
'''--- src/nft/metadata.rs ---
use crate::*;
pub type TokenId = String;
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    pub owner_id: AccountId,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub next_approval_id: u64,
    pub royalty: HashMap<AccountId, u32>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: TokenMetadata,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub royalty: HashMap<AccountId, u32>,
}

pub trait NonFungibleTokenMetadata {
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

impl TokenMetadata {
    pub fn new(pool_id: usize, id: u128, position: &Position) -> TokenMetadata {
        let description = Some(format!(
            "pool: {}, position_id: {}, lower_tick: {}, upper_tick: {}",
            pool_id, id, position.tick_lower_bound_price, position.tick_upper_bound_price
        ));
        TokenMetadata {
            title: Some("Crisp Ex LP Token".to_string()),
            media: Some("https://bafkreibjmwxasfb76j6tepmrcgdh3zq3uxz5eunklfs23pfjwocswsntfq.ipfs.nftstorage.link/".to_string()),
            description,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }
}

'''
'''--- src/nft/mint.rs ---
use crate::{
    nft::{
        events::{EventLog, EventLogVariant, NftMintLog},
        metadata::{Token, TokenId, TokenMetadata},
    },
    *,
};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn nft_mint(&mut self, token_id: TokenId, receiver_id: AccountId, metadata: TokenMetadata) {
        let royalty = HashMap::new();
        let token = Token {
            owner_id: receiver_id,
            approved_account_ids: Default::default(),
            next_approval_id: 0,
            royalty,
        };
        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "{}",
            NFT7
        );
        self.tokens_by_id.insert(&token_id, &token);
        self.token_metadata_by_id.insert(&token_id, &metadata);
        self.internal_add_token_to_owner(&token.owner_id, &token_id);
        let nft_mint_log: EventLog = EventLog {
            standard: NFT_STANDARD_NAME.to_string(),
            version: NFT_METADATA_SPEC.to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: token.owner_id.to_string(),
                token_ids: vec![token_id.to_string()],
                memo: None,
            }]),
        };
        env::log(&nft_mint_log.to_string().as_bytes());
    }

    #[private]
    #[payable]
    pub fn nft_burn(&mut self, token_id: TokenId) {
        assert!(self.tokens_by_id.get(&token_id).is_some(), "{}", NFT0);
        let token = self.tokens_by_id.get(&token_id).unwrap();
        self.token_metadata_by_id.remove(&token_id);
        self.internal_remove_token_from_owner(&token.owner_id, &token_id);
    }
}

'''
'''--- src/nft/mod.rs ---
pub mod approval;
pub mod enumeration;
pub mod events;
pub mod internal;
pub mod metadata;
pub mod mint;
pub mod nft_core;
pub mod royalty;

'''
'''--- src/nft/nft_core.rs ---
use crate::*;
use near_contract_standards::non_fungible_token::core::NonFungibleTokenResolver;
use near_sdk::{ext_contract, Gas, PromiseResult};

use super::{
    events::{EventLog, EventLogVariant, NftTransferLog},
    internal::{assert_one_yocto, refund_approved_account_ids},
    metadata::{JsonToken, TokenId},
};

const GAS_FOR_NFT_ON_TRANSFER: Gas = 25_000_000_000_000;

pub trait NonFungibleTokenCore {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: HashMap<AccountId, u64>,
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    // #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        // assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo);
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            approval_id,
            memo.clone(),
        );
        let mut authorized_id = None;
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_token.owner_id.clone(),
            token_id.clone(),
            msg,
            &receiver_id,
            0,
            GAS_FOR_NFT_ON_TRANSFER,
        )
        .then(ext_self::nft_resolve_transfer(
            authorized_id,
            previous_token.owner_id,
            receiver_id.clone(),
            token_id,
            previous_token.approved_account_ids,
            memo,
            &receiver_id,
            0,
            GAS_FOR_NFT_ON_TRANSFER,
        ))
        .into()
    }

    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: token.royalty,
            })
        } else {
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        // authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        _approved_account_ids: Option<HashMap<AccountId, u64>>,
        // memo: Option<String>,
    ) -> bool {
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                if !return_token {
                    // refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                // refund_approved_account_ids(owner_id, &approved_account_ids);
                return true;
            }
            token
        } else {
            // refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        self.internal_add_token_to_owner(&owner_id, &token_id);
        token.owner_id = owner_id.clone();
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        // token.approved_account_ids = approved_account_ids;
        self.tokens_by_id.insert(&token_id, &token);
        let nft_transfer_log: EventLog = EventLog {
            standard: NFT_STANDARD_NAME.to_string(),
            version: NFT_METADATA_SPEC.to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: None,
                old_owner_id: receiver_id.to_string(),
                new_owner_id: owner_id.to_string(),
                token_ids: vec![token_id.to_string()],
                memo: None,
            }]),
        };
        env::log(nft_transfer_log.to_string().as_bytes());
        false
    }
}

'''
'''--- src/nft/royalty.rs ---
use crate::{
    nft::internal::{assert_one_yocto, refund_approved_account_ids, royalty_to_payout},
    *,
};

use super::metadata::{Payout, TokenId};

pub trait NonFungibleTokenCore {
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout;

    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        let token = self.tokens_by_id.get(&token_id).expect(NFT0);
        let owner_id = token.owner_id;
        let mut total_perpetual = 0;
        let balance_u128 = u128::from(balance);
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        assert!(token.royalty.len() as u32 <= max_len_payout, "{}", NFT8);
        for (k, v) in token.royalty.iter() {
            let key = k.clone();
            if key != owner_id {
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );
        payout_object
    }

    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, Some(approval_id), memo);
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
        let owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let balance_u128 = u128::from(balance);
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        assert!(
            previous_token.royalty.len() as u32 <= max_len_payout,
            "{}",
            NFT8
        );
        for (k, v) in previous_token.royalty.iter() {
            let key = k.clone();
            if key != owner_id {
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );
        payout_object
    }
}

'''
'''--- src/option.rs ---
enum OptionType {
    Put,
    Call,
}

pub struct Option {
    pub price: f64,
    pub expiration_ts: u64,
    pub option_type: OptionType,
    pub insurance: u128,
    pub token: AccountId,
}
'''
'''--- src/pool.rs ---
use std::collections::HashMap;

use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::Serialize,
    AccountId,
};

use crate::{
    balance::{PST0, SWP1},
    position::{sqrt_price_to_tick, tick_to_sqrt_price, Position},
    BASIS_POINT_TO_PERCENT,
};

#[derive(Clone)]
pub struct CollectedFee {
    pub account_id: AccountId,
    pub amount: f64,
    pub token: AccountId,
}

#[derive(Clone)]
pub struct SwapResult {
    pub amount: f64,
    pub new_liquidity: f64,
    pub new_sqrt_price: f64,
    pub collected_fees: HashMap<u128, CollectedFee>,
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum SwapDirection {
    Return,
    Expense,
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub token0: AccountId,
    pub token1: AccountId,
    pub liquidity: f64,
    pub sqrt_price: f64,
    pub token0_locked: u128,
    pub token1_locked: u128,
    pub tick: i32,
    pub positions: HashMap<u128, Position>,
    pub protocol_fee: u16,
    pub rewards: u16,
}

impl Pool {
    pub fn new(
        token0: AccountId,
        token1: AccountId,
        price: f64,
        protocol_fee: u16,
        rewards: u16,
    ) -> Pool {
        let tick = sqrt_price_to_tick(price.sqrt());
        Pool {
            token0,
            token1,
            liquidity: 0.0,
            sqrt_price: price.sqrt(),
            token0_locked: 0,
            token1_locked: 0,
            positions: HashMap::new(),
            tick,
            protocol_fee,
            rewards,
        }
    }

    pub fn get_swap_result(
        &self,
        token: &AccountId,
        amount: u128,
        direction: SwapDirection,
    ) -> SwapResult {
        if direction == SwapDirection::Return {
            if token == &self.token0 {
                if amount > self.token0_locked {
                    panic!("{}", SWP1);
                }
            } else {
                if amount > self.token1_locked {
                    panic!("{}", SWP1);
                }
            }
        }
        let mut collected = 0.0;
        let mut tick = sqrt_price_to_tick(self.sqrt_price);
        let mut price = self.sqrt_price;
        let mut remaining = amount as f64;
        let mut collected_fees: HashMap<u128, CollectedFee> = HashMap::new();
        while remaining > 0.0 {
            let liquidity = self.calculate_liquidity_within_tick(price);
            if liquidity == 0.0 && !self.check_available_liquidity(price, token, direction) {
                panic!("{}", SWP1);
            }
            let temp = match direction {
                SwapDirection::Expense => self.get_amount_in_within_tick(
                    &mut tick,
                    &mut price,
                    token,
                    &mut remaining,
                    liquidity,
                ),
                SwapDirection::Return => self.get_amount_out_within_tick(
                    &mut tick,
                    &mut price,
                    token,
                    &mut remaining,
                    liquidity,
                ),
            };
            self.collect_fees(liquidity, price, temp, token, &mut collected_fees);
            collected += temp;
        }
        let liquidity = self.calculate_liquidity_within_tick(price);
        SwapResult {
            amount: collected,
            new_liquidity: liquidity,
            new_sqrt_price: price,
            collected_fees,
        }
    }

    fn collect_fees(
        &self,
        liquidity: f64,
        sqrt_price: f64,
        amount: f64,
        token: &AccountId,
        collected_fees: &mut HashMap<u128, CollectedFee>,
    ) {
        for (i, position) in &self.positions {
            if position.is_active(sqrt_price) {
                let share = (position.liquidity / liquidity)
                    * amount
                    * (self.rewards as f64 / BASIS_POINT_TO_PERCENT);
                let old_collected_fee_option = collected_fees.get(&i);
                let mut old_share = 0.0;
                if let Some(old_collected_fee) = old_collected_fee_option {
                    old_share = old_collected_fee.amount;
                }
                let collected_fee = CollectedFee {
                    account_id: position.owner_id.clone(),
                    amount: share + old_share,
                    token: self.toggle_token(token),
                };
                collected_fees.insert(*i, collected_fee);
            }
        }
    }

    fn toggle_token(&self, token: &AccountId) -> AccountId {
        if token == &self.token0 {
            self.token1.to_string()
        } else {
            self.token0.to_string()
        }
    }

    fn check_available_liquidity(
        &self,
        sqrt_price: f64,
        token: &AccountId,
        direction: SwapDirection,
    ) -> bool {
        for (_, position) in &self.positions {
            if direction == SwapDirection::Expense && *token == self.token1
                || direction == SwapDirection::Return && *token == self.token0
            {
                // price goes down
                if position.sqrt_upper_bound_price < sqrt_price {
                    return true;
                }
            } else {
                // price goes up
                if position.sqrt_lower_bound_price > sqrt_price {
                    return true;
                }
            }
        }
        false
    }

    fn calculate_liquidity_within_tick(&self, sqrt_price: f64) -> f64 {
        self.positions
            .iter()
            .filter(|(_, x)| x.is_active(sqrt_price))
            .map(|(_, x)| x.liquidity)
            .sum()
    }

    fn get_amount_in_within_tick(
        &self,
        tick: &mut i32,
        sqrt_price: &mut f64,
        token_out: &AccountId,
        remaining: &mut f64,
        liquidity: f64,
    ) -> f64 {
        let mut new_sqrt_price;
        let mut amount_in;
        let amount_out;
        if token_out == &self.token1 {
            let new_tick = *tick - 1;
            new_sqrt_price = tick_to_sqrt_price(new_tick);
            amount_in = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
            amount_out = (new_sqrt_price - *sqrt_price) * liquidity;
            if amount_out.abs() > *remaining {
                let delta_sqrt_price = *remaining / liquidity;
                new_sqrt_price = *sqrt_price - delta_sqrt_price;
                amount_in = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
                *remaining = 0.0;
            } else {
                *remaining -= amount_out.abs();
                *tick -= 1;
            }
        } else {
            let new_tick = *tick + 1;
            new_sqrt_price = tick_to_sqrt_price(new_tick);
            amount_in = (new_sqrt_price - *sqrt_price) * liquidity;
            amount_out = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
            if amount_out.abs() > *remaining {
                let delta_reversed_sqrt_price = *remaining / liquidity;
                new_sqrt_price = *sqrt_price / (-delta_reversed_sqrt_price * *sqrt_price + 1.0);
                amount_in = (new_sqrt_price - *sqrt_price) * liquidity;
                *remaining = 0.0;
            } else {
                *remaining -= amount_out.abs();
                *tick += 1;
            }
        }
        *sqrt_price = new_sqrt_price;
        amount_in.abs()
    }

    fn get_amount_out_within_tick(
        &self,
        tick: &mut i32,
        sqrt_price: &mut f64,
        token_in: &AccountId,
        remaining: &mut f64,
        liquidity: f64,
    ) -> f64 {
        let mut new_sqrt_price;
        let mut amount_out;
        let amount_in;
        if token_in == &self.token1 {
            let new_tick = *tick + 1;
            new_sqrt_price = tick_to_sqrt_price(new_tick);
            amount_in = (new_sqrt_price - *sqrt_price) * liquidity;
            amount_out = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
            assert!(new_sqrt_price > *sqrt_price);
            assert!(amount_out < 0.0);
            if amount_in > *remaining {
                let delta_sqrt_price = *remaining / liquidity;
                new_sqrt_price = *sqrt_price + delta_sqrt_price;
                amount_out = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
                assert!(new_sqrt_price > *sqrt_price);
                assert!(amount_out < 0.0);
                *remaining = 0.0;
            } else {
                *remaining -= amount_in.abs();
                *tick += 1;
            }
        } else {
            let new_tick = *tick - 1;
            new_sqrt_price = tick_to_sqrt_price(new_tick);
            amount_in = (1.0 / new_sqrt_price - 1.0 / *sqrt_price) * liquidity;
            amount_out = (new_sqrt_price - *sqrt_price) * liquidity;
            assert!(new_sqrt_price < *sqrt_price);
            assert!(amount_out < 0.0);
            if amount_in > *remaining {
                let delta_reversed_sqrt_price = *remaining / liquidity;
                new_sqrt_price = *sqrt_price / (delta_reversed_sqrt_price * *sqrt_price + 1.0);
                amount_out = (new_sqrt_price - *sqrt_price) * liquidity;
                assert!(new_sqrt_price < *sqrt_price);
                assert!(amount_out < 0.0);
                *remaining = 0.0;
            } else {
                *remaining -= amount_in.abs();
                *tick -= 1;
            }
        }
        *sqrt_price = new_sqrt_price;
        amount_out.abs()
    }

    pub fn refresh(&mut self, current_timestamp: u64) {
        let mut liquidity = 0.0;
        let mut token0_locked = 0.0;
        let mut token1_locked = 0.0;
        for (_, position) in &mut self.positions {
            position.refresh(self.sqrt_price, current_timestamp);
            if position.is_active(self.sqrt_price) {
                liquidity += position.liquidity;
            }
            token0_locked += position.token0_locked;
            token1_locked += position.token1_locked;
        }
        self.liquidity = liquidity;
        self.token0_locked = token0_locked.round() as u128;
        self.token1_locked = token1_locked.round() as u128;
    }

    pub fn open_position(&mut self, id: u128, position: Position) {
        self.positions.insert(id, position);
    }

    pub fn close_position(&mut self, id: u128) {
        let position = self.positions.get(&id).expect(PST0);
        if position.is_active(self.sqrt_price) {
            self.liquidity -= position.liquidity;
            self.token0_locked -= position.token0_locked.round() as u128;
            self.token1_locked -= position.token1_locked.round() as u128;
        }
        self.positions.remove(&id);
    }

    pub fn apply_swap_result(&mut self, swap_result: &SwapResult) {
        self.liquidity = swap_result.new_liquidity;
        self.sqrt_price = swap_result.new_sqrt_price;
        self.tick = sqrt_price_to_tick(self.sqrt_price);
        for (id, collected_fee) in &swap_result.collected_fees {
            let mut position = self.positions.get(&id).unwrap().clone();
            if collected_fee.token == self.token0 {
                position.fees_earned_token0 += collected_fee.amount.round() as u128;
            } else {
                position.fees_earned_token1 += collected_fee.amount.round() as u128;
            }
            self.positions.insert(*id, position);
        }
    }
}

#[cfg(test)]
mod test {
    use crate::{pool::SwapDirection, position::sqrt_price_to_tick, *};
    #[test]
    fn pool_get_expense_x() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 7.0);
        assert!(position.liquidity == 376.34409850346157);
        pool.open_position(0, position);
        let result = pool.get_swap_result(&token0, 10, SwapDirection::Expense);
        assert!(result.amount == 601.9655974035782); // last digit was added, so the test passes
        assert!(result.new_sqrt_price == 8.599508534336799);
        assert!(result.new_liquidity == 376.34409850346157);
    }

    #[test]
    fn pool_get_expense_y() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 7.0);
        assert!(position.liquidity == 376.34409850346157);
        pool.open_position(0, position);
        let result = pool.get_swap_result(&token1, 10, SwapDirection::Expense);
        assert!(result.amount == 0.20485926166133644);
        assert!(result.new_sqrt_price == 6.973428572309849);
        assert!(result.new_liquidity == 376.34409850346157);
    }

    #[test]
    fn pool_get_return_x() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 10.0);
        assert!(position.liquidity.floor() == 555.0);
        pool.open_position(0, position);
        pool.refresh(0);
        let exp = pool.get_swap_result(&token0, 1, SwapDirection::Return);
        assert!(exp.amount.floor() == 98.0);
        assert!(exp.new_sqrt_price.floor() == 9.0);
        assert!(exp.new_liquidity.floor() == 555.0);
    }

    #[test]
    fn pool_get_return_y1() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 10.0);
        assert!(position.liquidity.floor() == 555.0);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token1, 1000, SwapDirection::Return);
        assert!(result.amount.floor() == 8.0);
        assert!(result.new_sqrt_price.floor() == 11.0);
        assert!(result.new_liquidity.floor() == 555.0);
    }
    #[test]
    fn pool_get_expense_x_out_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 25.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(10)), None, 20.0, 26.0, 5.0);
        assert_eq!(position.liquidity, 2578.6245298379777);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token0, 1, SwapDirection::Expense);
        let new_tick = sqrt_price_to_tick(result.new_sqrt_price);
        assert_ne!(new_tick, pool.tick);
    }

    #[test]
    fn pool_get_expense_y_out_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 25.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(10)), None, 20.0, 26.0, 5.0);
        assert_eq!(position.liquidity, 2578.6245298379777);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token1, 1, SwapDirection::Expense);
        let new_tick = sqrt_price_to_tick(result.new_sqrt_price);
        assert_ne!(new_tick, pool.tick);
    }

    #[test]
    fn pool_get_expense_x_in_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(500)), None, 99.0, 101.0, 10.0);
        assert_eq!(position.liquidity, 1012698.5416276127);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token0, 5, SwapDirection::Expense);
        let new_tick = sqrt_price_to_tick(result.new_sqrt_price);
        assert_eq!(new_tick, pool.tick);
    }

    #[test]
    fn pool_get_expense_y_in_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(500)), None, 99.0, 101.0, 10.0);
        assert_eq!(position.liquidity, 1012698.5416276127);
        pool.open_position(0, position);
        pool.refresh(0);
        let exp = pool.get_swap_result(&token1, 1, SwapDirection::Expense);
        let new_tick = sqrt_price_to_tick(exp.new_sqrt_price);
        assert_eq!(new_tick, pool.tick);
    }
    #[test]
    fn pool_get_return_x_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 105.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(5000)), None, 90.0, 110.0, 10.0);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token0, 1, SwapDirection::Return);
        let new_tick = sqrt_price_to_tick(result.new_sqrt_price);
        assert!(new_tick == pool.tick);
    }

    #[test]
    fn pool_get_return_y_within_one_tick() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(500)), None, 99.0, 101.0, 10.0);
        pool.open_position(0, position);
        pool.refresh(0);
        let exp = pool.get_swap_result(&token1, 1, SwapDirection::Return);
        let new_tick = sqrt_price_to_tick(exp.new_sqrt_price);
        assert!(new_tick == pool.tick);
    }

    #[test]
    #[should_panic(expected = "Not enough liquidity in pool to cover this swap")]
    fn pool_get_return_not_enough_liquidity() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        pool.get_swap_result(&token1, 1000, SwapDirection::Return);
    }

    #[test]
    #[should_panic(expected = "Not enough liquidity in pool to cover this swap")]
    fn pool_get_expense_not_enough_liquidity() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        pool.get_swap_result(&token1, 1000, SwapDirection::Expense);
    }

    #[test]
    #[should_panic(expected = "Not enough liquidity in pool to cover this swap")]
    fn pool_get_amount_many_positions_panic() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        for i in 1..100 {
            let position = Position::new(
                String::new(),
                Some(U128(i * 100)),
                None,
                100.0 - i as f64,
                100.0 + i as f64,
                10.0,
            );
            pool.open_position(i, position);
            pool.refresh(0);
        }
        pool.get_swap_result(&token0, 1000000, SwapDirection::Return);
        pool.get_swap_result(&token1, 1000000, SwapDirection::Expense);
    }

    #[test]
    fn pool_get_amount_many_positions() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        for i in 1..100 {
            let position = Position::new(
                String::new(),
                Some(U128(i * 100)),
                None,
                100.0 - i as f64,
                100.0 + i as f64,
                10.0,
            );
            pool.open_position(i, position);
            pool.refresh(0);
        }
        pool.get_swap_result(&token0, 495000, SwapDirection::Return);
        pool.get_swap_result(&token1, 1000000, SwapDirection::Expense);
    }

    #[test]
    fn pool_apply_swap_result_return() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 100.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 10.0);
        assert!(position.liquidity.floor() == 555.0);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token0, 1, SwapDirection::Return);
        pool.apply_swap_result(&result);
        assert!(pool.sqrt_price.floor() == 9.0);
        assert!(pool.liquidity.floor() == 555.0);
    }

    #[test]
    fn pool_apply_swap_result_expense() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let position = Position::new(String::new(), Some(U128(50)), None, 1.0, 10000.0, 7.0);
        assert!(position.liquidity == 376.34409850346157);
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token1, 10, SwapDirection::Expense);
        pool.apply_swap_result(&result);
        assert!(pool.sqrt_price == 6.973428572309849);
        assert!(pool.liquidity == 376.34409850346157);
    }

    #[test]
    fn pool_fees_expense() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 100, 100);
        let position = Position::new(
            "user.near".to_string(),
            Some(U128(50)),
            None,
            1.0,
            10000.0,
            7.0,
        );
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token1, 10, SwapDirection::Expense);
        let amount = result.amount / 100.0;
        let mut fee = 0.0;
        for (_, collected_fee) in result.collected_fees {
            fee += collected_fee.amount;
        }
        assert!((amount - fee).abs() < 0.00001);
    }

    #[test]
    fn pool_fees_return() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 100, 100);
        let position = Position::new(
            "user.near".to_string(),
            Some(U128(50)),
            None,
            1.0,
            10000.0,
            7.0,
        );
        pool.open_position(0, position);
        pool.refresh(0);
        let result = pool.get_swap_result(&token1, 10, SwapDirection::Return);
        let amount = result.amount / 100.0;
        let mut fee = 0.0;
        for (_, collected_fee) in result.collected_fees {
            fee += collected_fee.amount;
        }
        assert!((amount - fee).abs() < 0.00001);
    }

    #[test]
    fn pool_fees2() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 100, 100);
        for i in 0..9 {
            let position = Position::new(
                "user.near".to_string(),
                Some(U128(50)),
                None,
                1.0,
                10000.0,
                7.0,
            );
            pool.open_position(i, position);
            pool.refresh(0);
        }
        let result = pool.get_swap_result(&token1, 10, SwapDirection::Expense);
        let amount = result.amount / 100.0;
        let mut fee = 0.0;
        for (_, collected_fee) in result.collected_fees {
            fee += collected_fee.amount;
        }
        assert!((amount - fee).abs() < 0.00001);
    }

    #[test]
    fn pool_add_liquidity1() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let mut position = Position::new(
            "user.near".to_string(),
            Some(U128(50)),
            None,
            1.0,
            10000.0,
            7.0,
        );
        position.refresh(7.0, 0);
        pool.refresh(0);
        assert!(position.token0_locked.round() == 50.0);
        let liquidity1 = position.liquidity;
        let token1_locked1 = position.token1_locked;
        position.add_liquidity(Some(U128(100)), None, 7.0);
        pool.refresh(0);
        position.refresh(7.0, 0);
        assert!(position.token0_locked.round() == 150.0);
        let liquidity2 = position.liquidity;
        let token1_locked2 = position.token1_locked;
        assert!((liquidity2 / liquidity1) == (token1_locked2 / token1_locked1));
    }

    #[test]
    fn pool_add_liquidity2() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let mut position = Position::new(
            "user.near".to_string(),
            None,
            Some(U128(50)),
            1.0,
            10000.0,
            7.0,
        );
        position.refresh(7.0, 0);
        pool.refresh(0);
        assert!(position.token1_locked.round() == 50.0);
        let liquidity1 = position.liquidity;
        let token0_locked1 = position.token0_locked;
        position.add_liquidity(None, Some(U128(100)), 7.0);
        pool.refresh(0);
        position.refresh(7.0, 0);
        assert!(position.token1_locked.round() == 150.0);
        let liquidity2 = position.liquidity;
        let token0_locked2 = position.token0_locked;
        assert!((liquidity2 / liquidity1) == (token0_locked2 / token0_locked1));
    }

    #[test]
    fn pool_remove_liquidity1() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let mut position = Position::new(
            "user.near".to_string(),
            Some(U128(150)),
            None,
            1.0,
            10000.0,
            7.0,
        );
        position.refresh(7.0, 0);
        pool.refresh(0);
        assert!(position.token0_locked.round() == 150.0);
        let liquidity1 = position.liquidity;
        let token1_locked1 = position.token1_locked;
        position.remove_liquidity(Some(U128(100)), None, 7.0);
        pool.refresh(0);
        position.refresh(7.0, 0);
        assert!(position.token0_locked.round() == 50.0);
        let liquidity2 = position.liquidity;
        let token1_locked2 = position.token1_locked;
        assert!((liquidity1 / liquidity2) == (token1_locked1 / token1_locked2));
    }

    #[test]
    fn pool_remove_liquidity2() {
        let token0 = "first".to_string();
        let token1 = "second".to_string();
        let mut pool = Pool::new(token0.clone(), token1.clone(), 49.0, 0, 0);
        let mut position = Position::new(
            "user.near".to_string(),
            None,
            Some(U128(150)),
            1.0,
            10000.0,
            7.0,
        );
        position.refresh(7.0, 0);
        pool.refresh(0);
        assert!(position.token1_locked.round() == 150.0);
        let liquidity1 = position.liquidity;
        let token0_locked1 = position.token0_locked;
        position.remove_liquidity(None, Some(U128(100)), 7.0);
        pool.refresh(0);
        position.refresh(7.0, 0);
        assert!(position.token1_locked.round() == 50.0);
        let liquidity2 = position.liquidity;
        let token0_locked2 = position.token0_locked;
        assert!((liquidity1 / liquidity2) == (token0_locked1 / token0_locked2));
    }
}

'''
'''--- src/position.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::U128,
    serde::Serialize,
    AccountId,
};

use crate::errors::*;

#[derive(Clone, Serialize, BorshDeserialize, BorshSerialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Position {
    pub owner_id: AccountId, // position owner account
    pub liquidity: f64,     // L
    pub token0_locked: f64, // x
    pub token1_locked: f64, // y
    pub total_locked: f64,
    pub tick_lower_bound_price: i32,
    pub tick_upper_bound_price: i32,
    pub sqrt_lower_bound_price: f64, // p_a
    pub sqrt_upper_bound_price: f64, // p_b
    pub is_active: bool,
    pub last_update: u64,
    pub rewards_for_time: u64,
    pub fees_earned_token0: u128,
    pub fees_earned_token1: u128,
}

impl Default for Position {
    fn default() -> Self {
        Position {
            owner_id: String::new(),
            liquidity: 0.0,
            token0_locked: 0.0,
            token1_locked: 0.0,
            total_locked: 0.0,
            tick_lower_bound_price: 0,
            tick_upper_bound_price: 0,
            sqrt_lower_bound_price: 0.0,
            sqrt_upper_bound_price: 0.0,
            is_active: false,
            last_update: 0,
            rewards_for_time: 0,
            fees_earned_token0: 0,
            fees_earned_token1: 0,
        }
    }
}

impl Position {
    pub fn new(
        owner_id: AccountId,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
        lower_bound_price: f64,
        upper_bound_price: f64,
        sqrt_price: f64,
    ) -> Position {
        assert!(
            token0_liquidity.is_some() ^ token1_liquidity.is_some(),
            "{}",
            PST5
        );
        assert!(lower_bound_price < upper_bound_price);
        let liquidity;
        let x;
        let y;
        let tick_lower_bound_price = sqrt_price_to_tick(lower_bound_price.sqrt());
        let tick_upper_bound_price = sqrt_price_to_tick(upper_bound_price.sqrt());
        let sqrt_lower_bound_price = tick_to_sqrt_price(tick_lower_bound_price);
        let sqrt_upper_bound_price = tick_to_sqrt_price(tick_upper_bound_price);
        if token0_liquidity.is_some() { 
            let token0_liquidity: u128 = token0_liquidity.unwrap().into();
            x = token0_liquidity as f64;
            assert!(x > 0.0, "{}", PST1);
            assert!(sqrt_price <= sqrt_upper_bound_price, "{}", PST2);
            if sqrt_lower_bound_price < sqrt_price && sqrt_price < sqrt_upper_bound_price {
                liquidity = get_liquidity_0(x, sqrt_price, sqrt_upper_bound_price);
            } else {
                liquidity = get_liquidity_0(x, sqrt_lower_bound_price, sqrt_upper_bound_price);
            }
            y = calculate_y(
                liquidity,
                sqrt_price,
                sqrt_lower_bound_price,
                sqrt_upper_bound_price,
            );
        } else {
            let token1_liquidity: u128 = token1_liquidity.unwrap().into();
            y = token1_liquidity as f64;
            assert!(y > 0.0, "{}", PST3);
            assert!(sqrt_price >= sqrt_lower_bound_price, "{}", PST4);
            if sqrt_lower_bound_price <= sqrt_price && sqrt_price <= sqrt_upper_bound_price {
                liquidity = get_liquidity_1(y, sqrt_lower_bound_price, sqrt_price);
            } else {
                liquidity = get_liquidity_1(y, sqrt_lower_bound_price, sqrt_upper_bound_price);
            }
            x = calculate_x(
                liquidity,
                sqrt_price,
                sqrt_lower_bound_price,
                sqrt_upper_bound_price,
            );
        }
        let total_locked = y + x * sqrt_price * sqrt_price;
        Position {
            owner_id,
            liquidity,
            token0_locked: x,
            token1_locked: y,
            total_locked,
            tick_lower_bound_price,
            tick_upper_bound_price,
            sqrt_lower_bound_price,
            sqrt_upper_bound_price,
            is_active: true,
            last_update: 0,
            rewards_for_time: 0,
            fees_earned_token0: 0,
            fees_earned_token1: 0,
        }
    }

    pub fn refresh(&mut self, sqrt_price: f64, current_timestamp: u64) {
        self.token0_locked = calculate_x(
            self.liquidity,
            sqrt_price,
            self.sqrt_lower_bound_price,
            self.sqrt_upper_bound_price,
        );
        self.token1_locked = calculate_y(
            self.liquidity,
            sqrt_price,
            self.sqrt_lower_bound_price,
            self.sqrt_upper_bound_price,
        );
        self.total_locked = self.token1_locked + self.token0_locked * sqrt_price * sqrt_price;
        if self.is_active {
            self.rewards_for_time = current_timestamp - self.last_update;
        }
        self.is_active = self.is_active(sqrt_price);
        self.last_update = current_timestamp;
    }

    pub fn is_active(&self, sqrt_price: f64) -> bool {
        self.sqrt_lower_bound_price <= sqrt_price && self.sqrt_upper_bound_price >= sqrt_price
    }

    pub fn add_liquidity( // there are two tests of this function in pool.rs
        &mut self,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
        sqrt_price: f64,
    ) {
        assert!(
            token0_liquidity.is_some() ^ token1_liquidity.is_some(),
            "{}",
            PST5
        );
        if token0_liquidity.is_some() {
            let token0_liquidity: u128 = token0_liquidity.unwrap().into();
            self.token0_locked += token0_liquidity as f64;
            assert!(sqrt_price <= self.sqrt_upper_bound_price, "{}", PST2);
            if self.sqrt_lower_bound_price < sqrt_price && sqrt_price < self.sqrt_upper_bound_price
            {
                self.liquidity =
                    get_liquidity_0(self.token0_locked, sqrt_price, self.sqrt_upper_bound_price);
            } else {
                self.liquidity = get_liquidity_0(
                    self.token0_locked,
                    self.sqrt_lower_bound_price,
                    self.sqrt_upper_bound_price,
                );
            }
            self.token1_locked = calculate_y(
                self.liquidity,
                sqrt_price,
                self.sqrt_lower_bound_price,
                self.sqrt_upper_bound_price,
            );
        } else {
            let token1_liquidity: u128 = token1_liquidity.unwrap().into();
            self.token1_locked += token1_liquidity as f64;
            assert!(sqrt_price >= self.sqrt_lower_bound_price, "{}", PST4);
            if self.sqrt_lower_bound_price <= sqrt_price
                && sqrt_price <= self.sqrt_upper_bound_price
            {
                self.liquidity =
                    get_liquidity_1(self.token1_locked, self.sqrt_lower_bound_price, sqrt_price);
            } else {
                self.liquidity = get_liquidity_1(
                    self.token1_locked,
                    self.sqrt_lower_bound_price,
                    self.sqrt_upper_bound_price,
                );
            }
            self.token0_locked = calculate_x(
                self.liquidity,
                sqrt_price,
                self.sqrt_lower_bound_price,
                self.sqrt_upper_bound_price,
            );
        }
        self.total_locked = self.token1_locked + self.token0_locked * sqrt_price * sqrt_price;
    }

    pub fn remove_liquidity(
        &mut self,
        token0_liquidity: Option<U128>,
        token1_liquidity: Option<U128>,
        sqrt_price: f64,
    ) {
        assert!(
            token0_liquidity.is_some() ^ token1_liquidity.is_some(),
            "{}",
            PST5
        );
        if token0_liquidity.is_some() {
            let token0_liquidity: u128 = token0_liquidity.unwrap().into();
            self.token0_locked -= token0_liquidity as f64;
            assert!(self.token0_locked > 0.0);
            assert!(sqrt_price <= self.sqrt_upper_bound_price, "{}", PST2);
            if self.sqrt_lower_bound_price < sqrt_price && sqrt_price < self.sqrt_upper_bound_price
            {
                self.liquidity =
                    get_liquidity_0(self.token0_locked, sqrt_price, self.sqrt_upper_bound_price);
            } else {
                self.liquidity = get_liquidity_0(
                    self.token0_locked,
                    self.sqrt_lower_bound_price,
                    self.sqrt_upper_bound_price,
                );
            }
            self.token1_locked = calculate_y(
                self.liquidity,
                sqrt_price,
                self.sqrt_lower_bound_price,
                self.sqrt_upper_bound_price,
            );
        } else {
            let token1_liquidity: u128 = token1_liquidity.unwrap().into();
            self.token1_locked -= token1_liquidity as f64;
            assert!(self.token1_locked > 0.0);
            assert!(sqrt_price >= self.sqrt_lower_bound_price, "{}", PST4);
            if self.sqrt_lower_bound_price <= sqrt_price
                && sqrt_price <= self.sqrt_upper_bound_price
            {
                self.liquidity =
                    get_liquidity_1(self.token1_locked, self.sqrt_lower_bound_price, sqrt_price);
            } else {
                self.liquidity = get_liquidity_1(
                    self.token1_locked,
                    self.sqrt_lower_bound_price,
                    self.sqrt_upper_bound_price,
                );
            }
            self.token0_locked = calculate_x(
                self.liquidity,
                sqrt_price,
                self.sqrt_lower_bound_price,
                self.sqrt_upper_bound_price,
            );
        }
        self.total_locked = self.token1_locked + self.token0_locked * sqrt_price * sqrt_price;
    }

    pub fn get_liquidation_price(&self, xd: f64, yd: f64, ltv_max: f64) -> (f64, f64) {
        // for brevity
        let sb = self.sqrt_upper_bound_price;
        let sa = self.sqrt_lower_bound_price;
        let l = self.liquidity;

        assert!(xd > 0.0 && yd > 0.0);
        let pliqa = yd / ( ltv_max * l * (sb - sa) / (sb * sa) - xd);
        let pliqb = (ltv_max * l * (sb - sa) - yd) / xd;
        println!("sb = {sb}, sa = {sa}, l = {l}, xd = {xd}, yd = {yd}");
        (pliqa, pliqb)
    }
}

fn min(first: f64, second: f64) -> f64 {
    if first < second {
        first
    } else {
        second
    }
}

fn max(first: f64, second: f64) -> f64 {
    if first > second {
        first
    } else {
        second
    }
}

pub fn get_liquidity_0(x: f64, sa: f64, sb: f64) -> f64 {
    x * sa * sb / (sb - sa)
}

pub fn get_liquidity_1(y: f64, sa: f64, sb: f64) -> f64 {
    y / (sb - sa)
}

pub fn _get_liquidity(x: f64, y: f64, sp: f64, sa: f64, sb: f64) -> f64 {
    let liquidity;
    if sp <= sa {
        liquidity = get_liquidity_0(x, sa, sb);
    } else if sp < sb {
        let liquidity0 = get_liquidity_0(x, sp, sb);
        let liquidity1 = get_liquidity_1(y, sa, sp);
        liquidity = min(liquidity0, liquidity1)
    } else {
        liquidity = get_liquidity_1(y, sa, sb);
    }
    liquidity
}

pub fn calculate_x(l: f64, sp: f64, sa: f64, sb: f64) -> f64 {
    let sp = max(min(sp, sb), sa);
    l * (sb - sp) / (sp * sb)
}

pub fn calculate_y(l: f64, sp: f64, sa: f64, sb: f64) -> f64 {
    let sp = max(min(sp, sb), sa);
    l * (sp - sa)
}

pub fn _calculate_a1(l: f64, sp: f64, _sb: f64, _x: f64, y: f64) -> f64 {
    (sp - y / l).powf(2.0)
}

pub fn _calculate_a2(sp: f64, sb: f64, x: f64, y: f64) -> f64 {
    let sa = y / (sb * x) + sp - y / (sp * x);
    sa.powf(2.0)
}

pub fn _calculate_b1(l: f64, sp: f64, _sa: f64, x: f64, _y: f64) -> f64 {
    ((l * sp) / (l - sp * x)).powf(2.0)
}

pub fn _calculate_b2(sp: f64, sa: f64, x: f64, y: f64) -> f64 {
    let p = sp.powf(2.0);
    (sp * y / ((sa * sp - p) * x + y)).powf(2.0)
}

pub fn tick_to_sqrt_price(tick: i32) -> f64 {
    1.0001_f64.powf(tick as f64 / 2.0)
}

pub fn sqrt_price_to_tick(sqrt_price: f64) -> i32 {
    (2.0 * sqrt_price.log(1.0001)).floor() as i32
}

pub fn _calculate_sp(l: f64, x: f64, sb: f64) -> f64 {
    (l * sb) / (x * sb + l)
}

#[cfg(test)]

mod test {
    use super::min;
    use crate::position::max;
    use crate::{position::*, LTV_MAX};

    #[test]
    fn debug_info() {
        let _p = 3227.02_f64;
        let _a = 1626.3_f64;
        let _b = 4846.3_f64;
        let _x = 1_f64;
        let _y = 5096.06_f64;
    }

    #[test]
    fn min_vault() {
        let first = 50_f64;
        let second = 100_f64;
        assert_eq!(min(first, second), 50_f64);
    }

    #[test]
    fn max_vault() {
        let first = 50_f64;
        let second = 100_f64;
        assert_eq!(max(first, second), 100_f64);
    }

    #[test]
    fn get_liquidity_0_test() {
        let sa = 1626.3_f64.powf(0.5);
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let l_0 = get_liquidity_0(x, sa.powf(0.5), sb.powf(0.5)).floor();
        assert_eq!(l_0, 26.0);
    }

    #[test]
    fn get_liquidity_1_test() {
        let sa = 1626.3_f64.powf(0.5);
        let sb = 4846.3_f64.powf(0.5);
        let y = 5096.06_f64;
        let l_1 = get_liquidity_1(y, sa.powf(0.5), sb.powf(0.5)).floor();
        assert_eq!(l_1, 2556.0);
    }

    #[test]
    fn get_liquidity_test() {
        // At sp <= sa ((x * sa * sb)/(sb - sa))
        let mut sp = 1500.02_f64.powf(0.5);
        let mut sa = 3500.3_f64.powf(0.5);
        let mut sb = 1500.3_f64.powf(0.5);
        let mut x = 2_f64;
        let mut y = 5096.06_f64;
        let mut l = _get_liquidity(x, y, sp, sa, sb).floor();
        assert_eq!(l, -225.0);
        // At sp < sb
        // min(get_liquidity_0, get_liquidity_1)
        // get_liquidity_0 = ((x * sa * sb)/(sb - sa))
        // get_liquidity_1 = y /(sb - sa)
        sp = 3227.02_f64.powf(0.5);
        sa = 3000.3_f64.powf(0.5);
        sb = 3800.3_f64.powf(0.5);
        x = 1_f64;
        y = 5096.06_f64;
        l = _get_liquidity(x, y, sp, sa, sb).floor();
        assert_eq!(l, 723.0);
        // At sa < sp > sb
        sp = 3600.02_f64.powf(0.5);
        sa = 3500.3_f64.powf(0.5);
        sb = 3000.3_f64.powf(0.5);
        x = 1_f64;
        y = 5096.06_f64;
        l = _get_liquidity(x, y, sp, sa, sb).floor();
        assert_eq!(l, -1162.0);
    }

    #[test]
    fn calculate_x_test() {
        let sp = 3227.02_f64.powf(0.5);
        let sa = 1626.3_f64.powf(0.5);
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let y = 5096.06_f64;
        let l = _get_liquidity(x, y, sp, sa, sb);
        let _x1 = calculate_x(l, sp, sa, sb);
        assert_eq!(x, 1.00);
        assert!(x == 1.0);
    }

    #[test]
    fn calculate_y_test() {
        let sp = 3227.02_f64.powf(0.5);
        let sa = 1626.3_f64.powf(0.5);
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let y = 5096.06_f64;
        let l = _get_liquidity(x, y, sp, sa, sb);
        let y1 = calculate_y(l, sp, sa, sb);
        assert_eq!(y1.floor(), 5088.0);
    }

    #[test]
    fn calculate_a1_test() {
        let sp = 3227.02_f64.powf(0.5);
        let _a = 1626.3_f64;
        let sa = 1626.3_f64.powf(0.5);
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let y = 5096.06_f64;
        let l = _get_liquidity(x, y, sp, sa, sb);
        let a1 = _calculate_a1(l, sp, sb, x, y);
        assert_eq!(a1.floor(), 1624.0);
    }

    #[test]
    fn calculate_a2_test() {
        let sp = 3227.02_f64.powf(0.5);
        let _a = 1626.3_f64;
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let y = 5096.06_f64;
        let a2 = _calculate_a2(sp, sb, x, y);
        assert_eq!(a2.floor(), 1624.0);
    }

    #[test]
    fn calculate_b1_test() {
        let sp = 3227.02_f64.powf(0.5);
        let sa = 1626.3_f64.powf(0.5);
        let _b = 4846.3_f64;
        let sb = 4846.3_f64.powf(0.5);
        let x = 1_f64;
        let y = 5096.06_f64;
        let l = _get_liquidity(x, y, sp, sa, sb);
        let b1 = _calculate_b1(l, sp, sa, x, y);
        assert_eq!(b1.floor(), 4846.0);
    }

    #[test]
    fn calculate_b2_test() {
        let sp = 3227.02_f64.powf(0.5);
        let sa = 1626.3_f64.powf(0.5);
        let _b = 4846.3_f64;
        let x = 1_f64;
        let y = 5096.06_f64;
        let b2 = _calculate_b2(sp, sa, x, y);
        assert_eq!(b2.floor(), 4842.0);
    }

    #[test]
    fn open_position() {
        let position = Position::new(String::new(), Some(U128(50)), None, 25.0, 121.0, 10.0);
        assert!(position.owner_id == String::new());
        assert!(position.token0_locked.floor() == 50.0,);
        assert!(position.token1_locked == 27504.676564711368,);
        assert!(position.liquidity == 5500.834197154125,);
        assert!(position.tick_lower_bound_price == 32190,);
        assert!(position.tick_upper_bound_price == 47960,);
        assert!(position.sqrt_lower_bound_price == 4.999908090496346,);
        assert!(position.sqrt_upper_bound_price == 10.999833188399927,);
    }

    #[test]
    fn open_position_less_than_lower_bound() {
        let position = Position::new(String::new(), Some(U128(50)), None, 121.0, 144.0, 10.0);
        assert!(position.owner_id == String::new());
        assert!(position.token0_locked == 50.0,);
        assert!(position.token1_locked == 0.0,);
        assert!(position.liquidity == 6601.04186065018,);
        assert!(position.tick_lower_bound_price == 47960,);
        assert!(position.tick_upper_bound_price == 49700,);
        assert!(position.sqrt_lower_bound_price == 10.999833188399927,);
        assert!(position.sqrt_upper_bound_price == 11.99962930765891,);
    }

    #[test]
    fn open_position_more_than_upper_bound() {
        let position = Position::new(String::new(), None, Some(U128(50)), 121.0, 144.0, 13.0);
        assert!(position.owner_id == String::new());
        assert!(position.token0_locked == 0.0,);
        assert!(position.token1_locked == 50.0,);
        assert!(position.liquidity == 50.010196115842504,);
        assert!(position.tick_lower_bound_price == 47960,);
        assert!(position.tick_upper_bound_price == 49700,);
        assert!(position.sqrt_lower_bound_price == 10.999833188399927,);
        assert!(position.sqrt_upper_bound_price == 11.99962930765891,);
    }

    #[should_panic(expected = "token0 liqudity cannot be 0")]
    #[test]
    fn open_position_wrong_order_x_zero() {
        let _position = Position::new(String::new(), Some(U128(0)), None, 121.0, 144.0, 11.5);
    }

    #[should_panic(expected = "send token1 liquidity instead of token0")]
    #[test]
    fn open_position_wrong_order_x_not_zero_higher_than_upper_bound() {
        let _position = Position::new(String::new(), Some(U128(1)), None, 121.0, 144.0, 13.0);
    }

    #[should_panic(expected = "token1 liqudity cannot be 0")]
    #[test]
    fn open_position_wrong_order_y_zero() {
        let _position = Position::new(String::new(), None, Some(U128(0)), 121.0, 144.0, 11.5);
    }

    #[should_panic(expected = "send token0 liquidity instead of token1")]
    #[test]
    fn open_position_wrong_order_y_not_zero_higher_than_upper_bound() {
        let _position = Position::new(String::new(), None, Some(U128(1)), 121.0, 144.0, 10.0);
    }

    #[test] 
    fn open_position_0() {
        let position = Position::new(
            String::new(),
            None,
            Some(U128(50)),
            121.0,
            169.0,
            12.0,
        );
        let delta = 0.01;
        let token0_locked_calc = 0.3205128205;
        let liquidity_calc = 50.0;
        let sqrt_lower_bound_price_calc = 11.0;
        let sqrt_upper_bound_price_calc = 13.0;

        println!("liquidity = {}", position.liquidity);
        println!("token0_locked = {}", position.token0_locked);
        println!("token1_locked = {}", position.token1_locked);
        println!("sqrt_lower_bound_price = {}", position.sqrt_lower_bound_price);
        println!("sqrt_upper_bound_price = {}", position.sqrt_upper_bound_price);

        assert!(max(position.token0_locked, token0_locked_calc)-min(position.token0_locked, token0_locked_calc) < delta);
        assert!(position.token1_locked == 50.0);

        assert!(max(position.liquidity, liquidity_calc)-min(position.liquidity, liquidity_calc) < delta);
        assert!(max(position.sqrt_lower_bound_price, sqrt_lower_bound_price_calc)-min(position.sqrt_lower_bound_price, sqrt_lower_bound_price_calc) < delta);
        assert!(max(position.sqrt_upper_bound_price, sqrt_upper_bound_price_calc)-min(position.sqrt_upper_bound_price, sqrt_upper_bound_price_calc) < delta);
    }

    #[test] 
    fn open_position_0_0() {
        let position = Position::new(
            String::new(),
            None,
            Some(U128(50)),
            1.0,
            1000.0,
            20.0,
        );
        let delta = 0.01;
        let token0_locked_calc = 0.04836;
        let liquidity_calc = 2.631579;
        let sqrt_lower_bound_price_calc = 1.0;
        let sqrt_upper_bound_price_calc = 31.622777;

        println!("liquidity = {}", position.liquidity);
        println!("token0_locked = {}", position.token0_locked);
        println!("token1_locked = {}", position.token1_locked);
        println!("sqrt_lower_bound_price = {}", position.sqrt_lower_bound_price);
        println!("sqrt_upper_bound_price = {}", position.sqrt_upper_bound_price);

        assert!(max(position.token0_locked, token0_locked_calc)-min(position.token0_locked, token0_locked_calc) < delta);
        assert!(position.token1_locked == 50.0);

        assert!(max(position.liquidity, liquidity_calc)-min(position.liquidity, liquidity_calc) < delta);
        assert!(max(position.sqrt_lower_bound_price, sqrt_lower_bound_price_calc)-min(position.sqrt_lower_bound_price, sqrt_lower_bound_price_calc) < delta);
        assert!(max(position.sqrt_upper_bound_price, sqrt_upper_bound_price_calc)-min(position.sqrt_upper_bound_price, sqrt_upper_bound_price_calc) < delta);
    }

    #[test]
    fn open_position1() {
        let position = Position::new(
            String::new(),
            Some(U128(1000000000000000000)),
            None,
            900.0,
            1100.0,
            1000.0_f64.sqrt(),
        );
        assert!(position.token0_locked == 1000000000000000000.0);
        assert!(position.token1_locked == 1103229672007021900000.0);
        assert!(position.liquidity == 679621668342898400000.0);
        assert!(position.sqrt_lower_bound_price == 29.999476869794734);
        assert!(position.sqrt_upper_bound_price == 33.16598911754618);
    }

    #[test]
    fn open_position2() {
        let position = Position::new(
            String::new(),
            Some(U128(1000000000000000000000000)),
            None,
            900.0,
            1100.0,
            1000.0_f64.sqrt(),
        );
        assert!(position.token0_locked == 1000000000000000000000000.0);
        assert!(position.token1_locked == 1103229672007021800000000000.0);
        assert!(position.liquidity == 679621668342898300000000000.0);
        assert!(position.sqrt_lower_bound_price == 29.999476869794734);
        assert!(position.sqrt_upper_bound_price == 33.16598911754618);
    }

    #[test]
    fn open_position3() {
        let position = Position::new(
            String::new(),
            Some(U128(1000000000000000000000000)),
            None,
            1000.0,
            1100.0,
            1000.0_f64.sqrt(),
        );
        assert!(position.token0_locked == 1000000000000000000000000.0);
        assert!(position.token1_locked == 7102492217198050000000.0);
        assert!(position.liquidity == 679621668342898300000000000.0);
        assert!(position.sqrt_lower_bound_price == 31.622766151027864);
        assert!(position.sqrt_upper_bound_price == 33.16598911754618);
    }

    #[test]
    fn ticks1() {
        let tick = 500;
        let sqrt_price = tick_to_sqrt_price(tick);
        let new_tick = sqrt_price_to_tick(sqrt_price);
        assert!(tick == new_tick);
    }

    #[test]
    fn ticks2() {
        let sqrt_price = 10.0;
        let tick = sqrt_price_to_tick(sqrt_price);
        assert!(tick == 46054);
        let new_sqrt_price = tick_to_sqrt_price(tick + 1);
        assert!(new_sqrt_price > sqrt_price);
        let new_tick = sqrt_price_to_tick(new_sqrt_price);
        assert!(new_tick > tick)
    }

    #[test] 
    fn liquidation_prices1() {
        let position = Position::new(String::new(), None, Some(U128(50)), 121.0, 169.0, 12.0);
        let prices = position.get_liquidation_price(position.token0_locked, position.token1_locked, LTV_MAX);
        println!("prices are {} {}", prices.0, prices.1);
        assert_eq!(prices.0.round(), 209.0);
        assert_eq!(prices.1.round(), 94.0);
    }

    #[test] 
    fn liquidation_prices2() {
        let position = Position::new(String::new(), None, Some(U128(50)), 1.0, 1000.0, 20.0);
        let prices = position.get_liquidation_price(position.token0_locked, position.token1_locked, LTV_MAX);
        println!("prices are {} {}", prices.0, prices.1);
        assert_eq!(prices.0.round(), 25.0);
        assert_eq!(prices.1.round(), 299.0);
    }

    #[should_panic]
    #[test] 
    fn liquidation_prices3() {
        let position = Position::new(String::new(), None, Some(U128(50)), 121.0, 144.0, 13.0);
        let prices = position.get_liquidation_price(position.token0_locked, position.token1_locked, LTV_MAX);
        println!("prices are {} {}", prices.0, prices.1);
    }

    #[should_panic]
    #[test] 
    fn add_liquidity_both_tokens() {
        let position = Position::new(String::new(), Some(U128(10)), Some(U128(50)), 121.0, 169.0, 12.0);
    }
}

'''
'''--- src/reserve.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Reserve {
    pub deposited: u128,
    pub borrowed: u128,
    pub utilization_rate: f64,
    pub target_utilization_rate: f64,
}

impl Default for Reserve {
    fn default() -> Self {
        Reserve {
            deposited: 0,
            borrowed: 0,
            utilization_rate: 0.0,
            target_utilization_rate: 0.0,
        }
    }
}

impl Reserve {
    pub fn increase_deposit(&mut self, amount: u128) {
        self.deposited += amount;
    }

    pub fn decrease_deposit(&mut self, amount: u128) {
        self.deposited -= amount;
    }

    pub fn refresh_utilization_rate(&mut self) {
        self.utilization_rate = match self.deposited {
            0 => 0.0,
            _ => self.borrowed as f64 / self.deposited as f64,
        }
    }
}
#[cfg(test)]
mod test {

    use crate::reserve::*;

    #[test]
    fn increase_deposit_test() {
        let mut reserve = Reserve::default();
        let new_amount = 500;
        assert!(reserve.deposited == 0);
        reserve.increase_deposit(new_amount);
        assert!(reserve.deposited == 500);
    }
    #[test]
    fn decrease_deposit_test() {
        let mut reserve = Reserve::default();
        let new_amount = 500;
        assert!(reserve.deposited == 0);
        reserve.increase_deposit(new_amount);
        assert!(reserve.deposited == 500);
        reserve.decrease_deposit(200);
        assert!(reserve.deposited == 300);
    }
}

'''
'''--- src/token_receiver.rs ---
use crate::Contract;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde_json;
use near_sdk::{env, json_types::U128, near_bindgen, PromiseOrValue};

use crate::action::Action;
use crate::*;

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
enum TokenReceiverMessage {
    /// Alternative to deposit + execute actions call.
    Execute { actions: Vec<Action> },
}

#[derive(Clone, Serialize, BorshDeserialize, BorshSerialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct OpenPositionRequest {
    pub owner_id: AccountId,
    pub pool_id: usize,
    pub token0_liquidity: Option<U128>,
    pub token1_liquidity: Option<U128>,
    pub lower_bound_price: f64,
    pub upper_bound_price: f64,
}

impl Contract {
    // may be needed to change predecessor_id -> signer_id in some method
    fn internal_execute(&mut self, token_in: AccountId, actions: &[Action]) {
        for action in actions {
            match action {
                Action::Swap(action) => {
                    assert_eq!(token_in, action.token_in);
                    self.swap(
                        action.pool_id,
                        &action.token_in,
                        action.amount_in,
                        &action.token_out,
                    );
                }
                Action::Withdraw(action) => {
                    self.withdraw(&action.token, action.amount);
                }
                Action::MultihopeSwap(action) => {
                    self.swap_multihope(&action.token_in, action.amount_in, &action.token_out);
                }
                Action::OpenPosition(action) => {
                    let account = env::signer_account_id();
                    if let Some(request) = self.open_position_requests.get(&action.request_id) {
                        let mut request = request.clone();
                        assert_eq!(account, request.owner_id);
                        assert_eq!(action.pool_id, request.pool_id);
                        assert_eq!(action.lower_bound_price, request.lower_bound_price);
                        assert_eq!(action.upper_bound_price, request.upper_bound_price);
                        if request.token0_liquidity.is_none() {
                            request.token0_liquidity = action.token0_liquidity;
                        } else {
                            request.token1_liquidity = action.token1_liquidity;
                        }
                        self.open_position(
                            request.pool_id,
                            request.token0_liquidity,
                            request.token1_liquidity,
                            request.lower_bound_price,
                            request.upper_bound_price,
                        );
                        self.open_position_requests.remove(&action.request_id);
                    } else {
                        assert!(
                            action.token0_liquidity.is_some() ^ action.token1_liquidity.is_some(),
                            "{}",
                            PST5
                        );
                        let request = OpenPositionRequest {
                            owner_id: account,
                            pool_id: action.pool_id,
                            token0_liquidity: action.token0_liquidity,
                            token1_liquidity: action.token1_liquidity,
                            lower_bound_price: action.lower_bound_price,
                            upper_bound_price: action.upper_bound_price,
                        };
                        self.open_position_requests
                            .insert(action.request_id, request);
                    }
                }
                Action::AddLiquidity(action) => {
                    self.add_liquidity(
                        action.pool_id,
                        action.position_id,
                        action.token0_liquidity,
                        action.token1_liquidity,
                    );
                }
                Action::CreateDeposit(action) => {
                    self.create_deposit(&action.asset, action.amount);
                }
                Action::ReturnCollateralAndRepay(action) => {
                    self.return_collateral_and_repay(action.borrow_id);
                }
                Action::Liquidate(action) => {
                    self.liquidate(action.borrow_id);
                }
            }
        }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unreachable_code)]
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_in = env::predecessor_account_id();
        self.deposit_ft(&sender_id.into(), &token_in, amount.into());
        if msg == "".to_string() {
            return PromiseOrValue::Value(U128(0));
        }
        // instant swap
        let message = serde_json::from_str::<TokenReceiverMessage>(&msg).expect("Wrong msg format");
        match message {
            TokenReceiverMessage::Execute { actions } => {
                self.internal_execute(token_in, &actions);
                return PromiseOrValue::Value(U128(0));
            }
        }
        PromiseOrValue::Value(U128(0))
    }
}

#[cfg(test)]
mod test {
    use crate::action::{SwapAction, WithdrawAction};

    use super::*;

    #[test]
    fn message_test() {
        let swap_action = Action::Swap(SwapAction {
            pool_id: 0,
            token_in: "token_in.testnet".to_string(),
            amount_in: U128(1000),
            token_out: "token_out.testnet".to_string(),
        });
        let withdraw_action = Action::Withdraw(WithdrawAction {
            token: "token_in.testnet".to_string(),
            amount: U128(1000),
        });
        let token_receiver_message = TokenReceiverMessage::Execute {
            actions: vec![swap_action, withdraw_action],
        };
        let message: String = serde_json::to_value(&token_receiver_message)
            .unwrap()
            .to_string();
        println!("message is: {}", message);
    }
}

'''
'''--- tests/balance.rs ---
use crate::common::utils::{deposit_tokens, setup_contract, withdraw_tokens};
use near_sdk::MockedBlockchain;
use near_sdk::{json_types::U128, test_utils::accounts, testing_env};

mod common;

#[test]
fn test_balance_after_deposit() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(123456),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(123456));
}

#[test]
fn test_balance_after_two_deposits() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000),
    );
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(30000));
}

#[test]
fn test_balance_after_withdraw() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000),
    );
    withdraw_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(0));
}

#[test]
#[should_panic(expected = "You want to withdraw 20000 of bob but only have 10000")]
fn test_balance_withdraw_not_enough_token() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000),
    );
    withdraw_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
}

#[test]
#[should_panic]
fn test_balance_withdraw_without_deposit() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    withdraw_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
}

#[test]
fn test_balance_after_two_deposits_two_accounts() {
    let (mut context, mut contract) = setup_contract();
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(20000),
    );
    testing_env!(context.predecessor_account_id(accounts(3)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(1),
        U128(30000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(2),
        U128(40000),
    );
    let balance1 = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2 = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    let balance3 = contract.get_balance(&accounts(3).to_string(), &accounts(1).to_string());
    let balance4 = contract.get_balance(&accounts(3).to_string(), &accounts(2).to_string());
    assert_eq!(balance1, U128(10000));
    assert_eq!(balance2, U128(20000));
    assert_eq!(balance3, U128(30000));
    assert_eq!(balance4, U128(40000));
}

'''
'''--- tests/common/mod.rs ---
pub mod utils;

'''
'''--- tests/common/utils.rs ---
use mycelium_lab_near_amm::Contract;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::MockedBlockchain;
use near_sdk::{
    json_types::{ValidAccountId, U128},
    test_utils::{accounts, VMContextBuilder},
    testing_env,
};
use near_sdk_sim::to_yocto;

pub fn setup_contract() -> (VMContextBuilder, Contract) {
    let mut context = VMContextBuilder::new();
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    let contract = Contract::new(accounts(0).to_string());
    (context, contract)
}

pub fn deposit_tokens(
    context: &mut VMContextBuilder,
    contract: &mut Contract,
    account_id: ValidAccountId,
    token_id: ValidAccountId,
    amount: U128,
) {
    testing_env!(context
        .predecessor_account_id(token_id)
        .attached_deposit(to_yocto("1"))
        .build());
    contract.ft_on_transfer(account_id.clone(), amount, "".to_string());
}

#[allow(dead_code)]
pub fn withdraw_tokens(
    context: &mut VMContextBuilder,
    contract: &mut Contract,
    account_id: ValidAccountId,
    token_id: ValidAccountId,
    amount: U128,
) {
    testing_env!(context
        .predecessor_account_id(account_id)
        .attached_deposit(to_yocto("1"))
        .build());
    contract.withdraw(&token_id.to_string(), amount.into());
}

'''
'''--- tests/fee.rs ---
use near_sdk::json_types::U128;
use near_sdk::test_utils::accounts;
use near_sdk::testing_env;
use near_sdk::MockedBlockchain;

use crate::common::utils::deposit_tokens;
use crate::common::utils::setup_contract;

mod common;

#[test]
fn fee_test() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        100,
        100,
    );
    testing_env!(context.signer_account_id(accounts(1)).build());
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100000),
    );
    testing_env!(context.signer_account_id(accounts(1)).build());
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(11005078),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    testing_env!(context.signer_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(1),
        U128(0),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    testing_env!(context.signer_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(2),
        U128(100000),
    );
    let balance1_before = contract.get_balance(&accounts(3).to_string(), &accounts(1).to_string());
    let balance2_before = contract.get_balance(&accounts(3).to_string(), &accounts(2).to_string());
    assert!(balance1_before == U128(0));
    assert!(balance2_before == U128(100000));
    let amount1 = 100000;
    testing_env!(context.predecessor_account_id(accounts(3)).build());
    testing_env!(context.signer_account_id(accounts(3)).build());
    let result: u128 = contract
        .swap(
            0,
            &accounts(2).to_string(),
            U128(amount1),
            &accounts(1).to_string(),
        )
        .into();
    let balance1_after: u128 = contract
        .get_balance(&accounts(3).to_string(), &accounts(1).to_string())
        .into();
    let balance2_after: u128 = contract
        .get_balance(&accounts(3).to_string(), &accounts(2).to_string())
        .into();
    let amount2 = result as f64 * 0.98;
    assert!((balance1_after as f64 - amount2).abs() < 20.0);
    assert!(balance2_after == 0);
    let balance1_lp_after: u128 = contract
        .get_balance(&accounts(0).to_string(), &accounts(1).to_string())
        .into();
    let balance2_lp_after: u128 = contract
        .get_balance(&accounts(0).to_string(), &accounts(2).to_string())
        .into();
    let amount3 = result as f64 * 0.01;
    assert!((balance1_lp_after as f64 - amount3).abs() < 10.0);
    assert!(balance2_lp_after == 0);
}

#[test]
fn collected_fee() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        100,
        100,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(11000000),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(50000)), None, 81.0, 121.0);
    contract.open_position(0, Some(U128(50000)), None, 91.0, 111.0);
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    testing_env!(context.signer_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(1),
        U128(100000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    testing_env!(context.signer_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(3),
        accounts(2),
        U128(100000),
    );
    let balance1_before = contract.get_balance(&accounts(3).to_string(), &accounts(1).to_string());
    let balance2_before = contract.get_balance(&accounts(3).to_string(), &accounts(2).to_string());
    assert!(balance1_before == U128(100000));
    assert!(balance2_before == U128(100000));
    let amount1 = 100000;
    testing_env!(context.predecessor_account_id(accounts(3)).build());
    testing_env!(context.signer_account_id(accounts(3)).build());
    let _pool = &contract.pools[0];
    let _result: u128 = contract
        .swap(
            0,
            &accounts(2).to_string(),
            U128(amount1),
            &accounts(1).to_string(),
        )
        .into();
    let _pool = &contract.pools[0];
    let _result: u128 = contract
        .swap(
            0,
            &accounts(1).to_string(),
            U128(99001),
            &accounts(2).to_string(),
        )
        .into();
    let pool = &contract.pools[0];
    let position = pool.positions.get(&0).unwrap();
    assert!(position.fees_earned_token0 == 4);
    assert!(position.fees_earned_token1 == 46522);
    let position = pool.positions.get(&1).unwrap();
    assert!(position.fees_earned_token0 == 6);
    assert!(position.fees_earned_token1 == 46007);
}

'''
'''--- tests/lending.rs ---
use near_sdk::json_types::ValidAccountId;
use near_sdk::json_types::U128;
use near_sdk::test_utils::accounts;
use near_sdk::testing_env;
use near_sdk::MockedBlockchain;

use crate::common::utils::deposit_tokens;
use crate::common::utils::setup_contract;

mod common;

// #[test]
// fn liquidate() {
//     let (mut context, mut contract) = setup_contract();
//     let alice = ValidAccountId::try_from("john.near").unwrap();
//     contract.create_reserve(&accounts(2).into());
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.signer_account_id(alice.clone()).build());
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(1),
//         U128(99999999999999999),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(2),
//         U128(99999999999999999),
//     );
//     testing_env!(context
//         .predecessor_account_id(alice.clone())
//         .attached_deposit(1)
//         .build());
//     let pool = &contract.pools[0];
//     assert_eq!(pool.positions.len(), 0);
//     contract.open_position(0, Some(U128(1)), None, 99.0, 101.0);
//     contract.open_position(0, None, Some(U128(100)), 50.0, 101.0);
//     contract.create_deposit(&accounts(2).into(), U128::from(1000000000000));
//     contract.supply_collateral_and_borrow_simple(0, 0);
//     let h = contract.get_borrow_health_factor(0);
//     assert_eq!((h * 100.0).round(), 125.0);
//     let list = contract.get_liquidation_list();
//     assert!(list.is_empty());
//     for _ in 0..2 {
//         contract.swap(
//             0,
//             &accounts(1).to_string(),
//             U128(1),
//             &accounts(2).to_string(),
//         );
//     }
//     let balance1_before = contract.get_balance(&"john.near".to_string(), &accounts(1).to_string());
//     let balance2_before = contract.get_balance(&"john.near".to_string(), &accounts(2).to_string());
//     testing_env!(context.build());
//     contract.liquidate(0);
//     let balance1_after = contract.get_balance(&"john.near".to_string(), &accounts(1).to_string());
//     let balance2_after = contract.get_balance(&"john.near".to_string(), &accounts(2).to_string());
//     assert_eq!(balance1_before, balance1_after);
//     assert!(balance2_before.0 > balance2_after.0);
// }

// #[test]
// fn get_liquidation_list() {
//     let (mut context, mut contract) = setup_contract();
//     let alice = ValidAccountId::try_from("john.near").unwrap();
//     contract.create_reserve(&accounts(2).into());
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     testing_env!(context.signer_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(1),
//         U128(99999999999999999),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     testing_env!(context.signer_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(2),
//         U128(99999999999999999),
//     );
//     testing_env!(context
//         .predecessor_account_id(alice.clone())
//         .attached_deposit(1)
//         .build());
//     testing_env!(context.signer_account_id(alice.clone()).build());
//     let pool = &contract.pools[0];
//     assert_eq!(pool.positions.len(), 0);
//     contract.open_position(0, Some(U128(1)), None, 99.0, 101.0);
//     contract.open_position(0, None, Some(U128(100)), 50.0, 101.0);
//     contract.create_deposit(&accounts(2).into(), U128::from(1000000000000));
//     contract.supply_collateral_and_borrow_simple(0, 0);
//     let h = contract.get_borrow_health_factor(0);
//     assert_eq!((h * 100.0).round(), 125.0);
//     let list = contract.get_liquidation_list();
//     assert!(list.is_empty());
//     for _ in 0..2 {
//         contract.swap(
//             0,
//             &accounts(1).to_string(),
//             U128(1),
//             &accounts(2).to_string(),
//         );
//     }
//     let list = contract.get_liquidation_list();
//     assert_eq!(list.len(), 1);
//     assert_eq!(list[0], 0);
// }

// #[test]
// fn return_collateral_and_repay() {
//     let alice = ValidAccountId::try_from("john.near").unwrap();
//     let (mut context, mut contract) = setup_contract();
//     contract.create_reserve(&accounts(2).into());
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(1),
//         U128(50),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         alice.clone(),
//         accounts(2),
//         U128(127515),
//     );
//     testing_env!(context
//         .predecessor_account_id(alice.clone())
//         .attached_deposit(1)
//         .build());
//     testing_env!(context
//         .signer_account_id(alice.clone())
//         .attached_deposit(1)
//         .build());
//     contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
//     contract.create_deposit(&accounts(2).into(), U128::from(100000));
//     let borrowed = contract.supply_collateral_and_borrow_simple(0, 0);
//     testing_env!(context.predecessor_account_id(alice.clone()).build());
//     let _token = contract.tokens_by_id.get(&"0".to_string()).unwrap();
//     let balance1_before = contract.get_balance(&"john.near".to_string(), &accounts(1).to_string());
//     let balance2_before = contract.get_balance(&"john.near".to_string(), &accounts(2).to_string());
//     contract.return_collateral_and_repay(0);
//     testing_env!(context.predecessor_account_id(alice).build());
//     let balance1_after = contract.get_balance(&"john.near".to_string(), &accounts(1).to_string());
//     let balance2_after = contract.get_balance(&"john.near".to_string(), &accounts(2).to_string());
//     assert_eq!(balance1_before, balance1_after);
//     assert_eq!(balance2_before.0 - borrowed.0, balance2_after.0);
// }

#[test]
fn supply_collateral_and_borrow_leveraged() {
    let (mut context, mut contract) = setup_contract();
    contract.create_reserve(&accounts(1).into());
    contract.create_reserve(&accounts(2).into());
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100050),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(127515),
    );
    testing_env!(context
        .predecessor_account_id(accounts(0))
        .attached_deposit(1)
        .build());
    testing_env!(context
        .signer_account_id(accounts(0))
        .attached_deposit(1)
        .build());
    contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
    let pool = &contract.pools[0];
    let position = pool.positions.get(&0).unwrap();
    let total_locked = position.total_locked as u128;
    contract.create_deposit(&accounts(1).into(), U128::from(100000));
    contract.create_deposit(&accounts(2).into(), U128::from(100000));
    let balance_before = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    let leverage = 2;
    contract.supply_collateral_and_borrow(0, 0, leverage);
    let balance_after = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance_before.0, balance_after.0);
    let borrow = contract.borrows.get(&0).unwrap();
    assert_eq!(borrow.owner_id, accounts(0).to_string());
    // assert_eq!(borrow.asset, accounts(2).to_string());
    // assert_eq!(borrow.borrowed, (leverage - 1) * total_locked);
    assert_eq!(borrow.collateral, leverage * total_locked);
    assert_eq!(borrow.position_id, 0);
    assert_eq!(borrow.pool_id, 0);
    assert_eq!(borrow.last_update_timestamp, 0);
    assert_eq!(borrow.apr, 1000);
    assert_eq!(borrow.leverage, Some(leverage));
    assert_eq!(borrow.fees, 0);
    let token = contract.tokens_by_id.get(&"0".to_string()).unwrap();
    assert_eq!(token.owner_id, context.context.current_account_id);
}

// #[test]
// fn supply_collateral_and_borrow_simple_should_work() {
//     let (mut context, mut contract) = setup_contract();
//     contract.create_reserve(&accounts(2).into());
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(1),
//         U128(50),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(2),
//         U128(127515),
//     );
//     testing_env!(context
//         .predecessor_account_id(accounts(0))
//         .attached_deposit(1)
//         .build());
//     testing_env!(context
//         .signer_account_id(accounts(0))
//         .attached_deposit(1)
//         .build());
//     contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
//     contract.create_deposit(&accounts(2).into(), U128::from(100000));
//     let balance_before = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
//     let borrowed = contract.supply_collateral_and_borrow_simple(0, 0);
//     let balance_after = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
//     assert_eq!(balance_before.0 + borrowed.0, balance_after.0);
//     let borrow = contract.borrows.get(&0).unwrap();
//     let pool = &contract.pools[0];
//     let position = pool.positions.get(&0).unwrap();
//     assert_eq!(borrow.owner_id, accounts(0).to_string());
//     // assert_eq!(borrow.asset, accounts(2).to_string());
//     // assert_eq!(borrow.borrowed, borrowed.0);
//     assert_eq!(borrow.collateral, position.total_locked as u128);
//     assert_eq!(borrow.position_id, 0);
//     assert_eq!(borrow.pool_id, 0);
//     assert_eq!(borrow.last_update_timestamp, 0);
//     assert_eq!(borrow.apr, 1000);
//     assert_eq!(borrow.leverage, None);
//     assert_eq!(borrow.fees, 0);
//     let token = contract.tokens_by_id.get(&"0".to_string()).unwrap();
//     assert_eq!(token.owner_id, context.context.current_account_id);
// }

// #[should_panic(
//     expected = "You want to borrow 26004 of charlie but only 10 is available in reserve"
// )]
// #[test]
// fn supply_collateral_and_borrow_simple_not_enough_reserves() {
//     let (mut context, mut contract) = setup_contract();
//     contract.create_reserve(&accounts(2).into());
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(1),
//         U128(50),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(2),
//         U128(27515),
//     );
//     testing_env!(context.predecessor_account_id(accounts(0)).build());
//     testing_env!(context
//         .signer_account_id(accounts(0))
//         .attached_deposit(1)
//         .build());
//     contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
//     contract.create_deposit(&accounts(2).into(), U128::from(10));
//     contract.supply_collateral_and_borrow_simple(0, 0);
// }

// #[should_panic(expected = "Reserve not found")]
// #[test]
// fn supply_collateral_and_borrow_simple_panic() {
//     let (mut context, mut contract) = setup_contract();
//     contract.create_pool(
//         accounts(1).to_string(),
//         accounts(2).to_string(),
//         100.0,
//         0,
//         0,
//     );
//     testing_env!(context.predecessor_account_id(accounts(1)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(1),
//         U128(50),
//     );
//     testing_env!(context.predecessor_account_id(accounts(2)).build());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(2),
//         U128(27505),
//     );
//     testing_env!(context.predecessor_account_id(accounts(0)).build());
//     testing_env!(context
//         .signer_account_id(accounts(0))
//         .attached_deposit(1)
//         .build());
//     contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
//     contract.supply_collateral_and_borrow_simple(0, 0);
// }

#[test]
fn get_account_deposits() {
    let (mut context, mut contract) = setup_contract();
    contract.create_reserve(&accounts(1).into());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    contract.create_deposit(&accounts(1).into(), U128::from(10));
    contract.create_deposit(&accounts(1).into(), U128::from(20));
    contract.create_deposit(&accounts(1).into(), U128::from(30));
    contract.create_deposit(&accounts(1).into(), U128::from(40));
    let _deposits = contract.get_account_deposits(accounts(0).to_string());
}

// #[test]
// fn take_deposit_growth() {
//     let (mut context, mut contract) = setup_contract();
//     contract.create_reserve(&accounts(1).into());
//     deposit_tokens(
//         &mut context,
//         &mut contract,
//         accounts(0),
//         accounts(1),
//         U128(100),
//     );
//     testing_env!(context.predecessor_account_id(accounts(0)).build());
//     contract.create_deposit(&accounts(1).into(), U128::from(100));
//     let context = context.block_timestamp(31536000000);
//     testing_env!(context.predecessor_account_id(accounts(0)).build());
//     context.block_index(31536000);
//     context.epoch_height(31536000);
//     contract.refresh_deposits_growth();
//     let deposit = contract.deposits.get(&0).unwrap();
//     assert_eq!(deposit.growth, 5);
//     let growth = contract.take_deposit_growth(0, U128::from(10));
//     assert_eq!(growth, 5.into());
//     let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
//     assert_eq!(balance, U128::from(5));
// }

#[test]
fn refresh_deposit_growth() {
    let (mut context, mut contract) = setup_contract();
    contract.create_reserve(&accounts(1).into());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(300),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    contract.create_deposit(&accounts(1).into(), U128::from(100));
    contract.create_deposit(&accounts(1).into(), U128::from(200));
    let context = context.block_timestamp(31536000000);
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    context.block_index(31536000);
    context.epoch_height(31536000);
    assert_eq!(context.context.block_timestamp, 31536000000);
    assert_eq!(context.context.block_index, 31536000);
    assert_eq!(context.context.epoch_height, 31536000);
    contract.refresh_deposits_growth();
    // let deposit1 = contract.deposits.get(&0).unwrap();
    // let deposit2 = contract.deposits.get(&1).unwrap();
    // assert_eq!(deposit1.growth, 5);
    // assert_eq!(deposit2.growth, 10);
}

#[test]
fn create_deposit2() {
    let (mut context, mut contract) = setup_contract();
    contract.create_reserve(&accounts(1).into());
    contract.create_reserve(&accounts(2).into());
    contract.create_reserve(&accounts(3).into());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100),
    );
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(100),
    );
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(3),
        U128(100),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    contract.create_deposit(&accounts(1).into(), U128::from(10));
    contract.create_deposit(&accounts(1).into(), U128::from(20));
    contract.create_deposit(&accounts(1).into(), U128::from(30));
    contract.create_deposit(&accounts(2).into(), U128::from(1));
    contract.create_deposit(&accounts(2).into(), U128::from(2));
    contract.create_deposit(&accounts(2).into(), U128::from(3));
    contract.create_deposit(&accounts(3).into(), U128::from(50));
    contract.create_deposit(&accounts(3).into(), U128::from(10));
    contract.create_deposit(&accounts(3).into(), U128::from(20));
    // let deposit = contract.deposits.get(&0).unwrap();
    // assert_eq!(deposit.owner_id, accounts(0).to_string());
    // assert_eq!(deposit.asset, accounts(1).to_string());
    // assert_eq!(deposit.amount, 10);
    // assert_eq!(deposit.timestamp, 0);
    // assert_eq!(deposit.last_update_timestamp, 0);
    // assert_eq!(deposit.apr, 500);
    // assert_eq!(deposit.growth, 0);

    let _deposits = contract.get_account_deposits(accounts(0).to_string());
    // assert_eq!(*deposits.get(&accounts(1).to_string()).unwrap(), 60);
    // assert_eq!(*deposits.get(&accounts(2).to_string()).unwrap(), 6);
    // assert_eq!(*deposits.get(&accounts(3).to_string()).unwrap(), 80);
}

#[test]
fn close_deposit() {
    let (mut context, mut contract) = setup_contract();
    contract.create_reserve(&accounts(1).into());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    contract.create_deposit(&accounts(1).into(), U128::from(100));
    // contract.deposits.get(&0).unwrap();
    // contract.close_deposit(0);
    // assert!(contract.deposits.is_empty());
}

#[test]
fn create_reserve() {
    let (mut _context, mut contract) = setup_contract();
    assert!(contract.reserves.is_empty());
    contract.create_reserve(&"usdt.testnet".to_string());
    let reserve = contract.reserves.get(&"usdt.testnet".to_string()).unwrap();
    assert_eq!(reserve.deposited, 0);
    assert_eq!(reserve.borrowed, 0);
    assert_eq!(reserve.liquidation_threshold, 0.0);
    assert_eq!(reserve.loan_to_value, 0.0);
    assert_eq!(reserve.target_utilization_rate, 0.0);
    assert_eq!(reserve.total_liquidity, 0);
    assert_eq!(reserve.utilization_rate, 0.0);
}

#[should_panic]
#[test]
fn create_deposit1() {
    let (mut _context, mut contract) = setup_contract();
    contract.create_reserve(&"usdt.testnet".to_string());
    contract.create_deposit(&"usn.testnet".to_string(), U128::from(100));
}

'''
'''--- tests/pool.rs ---
use std::collections::HashMap;

use mycelium_lab_near_amm::position::Position;
use near_sdk::json_types::U128;
use near_sdk::serde_json;
use near_sdk::test_utils::accounts;
use near_sdk::testing_env;
use near_sdk::MockedBlockchain;

use crate::common::utils::deposit_tokens;
use crate::common::utils::setup_contract;

mod common;

#[test]
fn create_pool() {
    let (mut _context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(0).to_string(),
        accounts(1).to_string(),
        100.0,
        0,
        0,
    );
    let pool = contract.get_pool(0);
    assert!(pool.token0 == accounts(0).to_string());
    assert!(pool.token1 == accounts(1).to_string());
    assert!(pool.liquidity == 0.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions == HashMap::new());
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.protocol_fee == 0);
    assert!(pool.rewards == 0);
}

#[test]
fn open_position_is_correct() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(50),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(50));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(27505),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(27505));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(50)), None, 25.0, 121.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 5500.834197154125);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 1);
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(0));
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(0));
}

#[test]
fn open_position_one_more_test() {
    // let (mut context, mut contract) = setup_contract();
    // contract.create_pool(
    //     accounts(1).to_string(),
    //     accounts(2).to_string(),
    //     0.000000000001,
    //     1,
    //     1,
    // );
    // testing_env!(context.predecessor_account_id(accounts(1)).build());
    // deposit_tokens(
    //     &mut context,
    //     &mut contract,
    //     accounts(0),
    //     accounts(1),
    //     U128(100000000000000000000000000),
    // );
    // testing_env!(context.predecessor_account_id(accounts(2)).build());
    // deposit_tokens(
    //     &mut context,
    //     &mut contract,
    //     accounts(0),
    //     accounts(2),
    //     U128(100000000000000000000000000),
    // );
    // testing_env!(context.predecessor_account_id(accounts(0)).build());
    // testing_env!(context.signer_account_id(accounts(0)).build());
    // contract.open_position(0, Some(U128(10000000000000000000)), None, 0.9 / 1000000000000.0, 1.1 / 1000000000000.0);
    let position = Position::new(
        String::new(),
        Some(U128(10000000000000000000)),
        None,
        0.9 / 1000000000000.0,
        1.1 / 1000000000000.0,
        0.000001,
    );
    // let pool = &contract.pools[0];
    // let position = pool.positions.get(&0).unwrap();
    println!("position.liquidity[0] = {}, position.liquidity[1] = {}", position.token0_locked, position.token1_locked);
    println!("position.liquidity = {}", position.liquidity);
    println!("position.sqrt_upper_price = {}", position.sqrt_upper_bound_price);
    println!("position.sqrt_lower_price = {}", position.sqrt_lower_bound_price);
}

#[test]
fn open_position_less_than_lower_bound() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(2000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(3000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(50)), None, 121.0, 144.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 0.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 1);
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(1950));
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000));
}

#[test]
fn open_position_more_than_upper_bound() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(2000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(3000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(50)), 64.0, 81.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 0.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 1);
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000));
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(2950));
}

#[test]
fn open_two_positions() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(20000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(30000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(30000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(50)), 64.0, 121.0);
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 6025.922352607511);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 2);
}

#[test]
fn open_three_positions() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(20000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(30000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(30000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(50)), 64.0, 121.0);
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    contract.open_position(0, None, Some(U128(150)), 81.0, 169.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity.round() == 6176.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 3);
}

#[test]
fn open_ten_positions() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(2000000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(3000000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(50)), 64.0, 121.0);
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    contract.open_position(0, None, Some(U128(150)), 81.0, 169.0);
    contract.open_position(0, Some(U128(200)), None, 110.0, 121.0);
    contract.open_position(0, None, Some(U128(250)), 49.0, 99.0);
    contract.open_position(0, Some(U128(300)), None, 149.0, 154.0);
    contract.open_position(0, None, Some(U128(350)), 81.0, 99.0);
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    contract.open_position(0, None, Some(U128(50)), 64.0, 121.0);
    contract.open_position(0, Some(U128(500)), None, 120.0, 130.0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity.round() == 12202.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 10);
}

#[test]
fn close_position() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(20000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(20000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(30000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(30000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(50)), 64.0, 121.0);
    contract.close_position(0, 0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 0.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 0);
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(20000));
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(30000));
}

#[test]
fn close_two_position() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(2000000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(3000000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000000));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    contract.open_position(0, Some(U128(100)), None, 49.0, 144.0);
    contract.close_position(0, 1);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 6000.926902650581);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 1);
    contract.close_position(0, 0);
    let pool = contract.get_pool(0);
    assert!(pool.liquidity == 0.0);
    assert!(pool.sqrt_price == 10.0);
    assert!(pool.tick == 46054);
    assert!(pool.positions.len() == 0);
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(2000000));
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(3000000));
}

#[test]
fn get_expense() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(10000000),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    assert_eq!(balance, U128(10000000));
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(1100507792),
    );
    let balance = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert_eq!(balance, U128(1100507792));
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(10000000)), None, 81.0, 121.0);
    let result1 = contract.get_expense(0, &accounts(1).to_string(), U128(1));
    let result2 = contract.get_expense(0, &accounts(2).to_string(), U128(1000));
    let _result3 = contract.get_expense(0, &accounts(1).to_string(), U128(10005000));
    let _result4 = contract.get_expense(0, &accounts(2).to_string(), U128(1101002812));
    let pool = &contract.pools[0];
    let _position = &pool.positions.get(&0).unwrap();
    assert!(result1 == U128(100));
    assert!(result2 == U128(10));
}

#[test]
fn swap_in_token0() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(200000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(11005078),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    let balance1_before = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2_before = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1_before == U128(100000));
    assert!(balance2_before == U128(0));
    let amount1 = 100000;
    let amount2 = contract.swap(
        0,
        &accounts(1).to_string(),
        U128(amount1),
        &accounts(2).to_string(),
    );
    let balance1_after = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2_after = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1_after == U128(0));
    assert!(balance2_after == amount2);
}

#[test]
fn swap_in_token1() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(11105078),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    let balance1_before = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2_before = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1_before == U128(0));
    assert!(balance2_before == U128(100000));
    let amount1 = 100000;
    let amount2 = contract.swap(
        0,
        &accounts(2).to_string(),
        U128(amount1),
        &accounts(1).to_string(),
    );
    let balance1_after = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2_after = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1_after == amount2);
    assert!(balance2_after == U128(0));
}

#[test]
fn value_locked_open_close() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        100,
        100,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    let initial_balance1 = 100000;
    let initial_balance2 = 11005077;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(100000),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(11005078),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    let pool = &contract.pools[0];
    assert!(pool.token0_locked == 100000);
    assert!(pool.token1_locked == 11005078);
    contract.close_position(0, 0);
    let pool = &contract.pools[0];
    assert!(pool.token0_locked == 0);
    assert!(pool.token1_locked == 0);

    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    let pool = &contract.pools[0];
    assert!(pool.token0_locked == 100000);
    assert!(pool.token1_locked == 11005078);

    contract.close_position(0, 1);
    let pool = &contract.pools[0];
    assert!(pool.token0_locked == 0);
    assert!(pool.token1_locked == 0);
    let final_balance1 = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let final_balance2 = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(initial_balance1 == final_balance1.0);
    assert!(((initial_balance2 as f64).abs() - (final_balance2.0 as f64).abs()) <= 1.0);
}

#[test]
fn value_locked_swap() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    testing_env!(context.signer_account_id(accounts(1)).build());
    let initial_balance1 = 200000;
    let initial_balance2 = 11005078;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(initial_balance1),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    testing_env!(context.signer_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(initial_balance2),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 81.0, 121.0);
    contract.swap(
        0,
        &accounts(1).to_string(),
        U128(100000),
        &accounts(2).to_string(),
    );
    contract.close_position(0, 0);
    let balance1 = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2 = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1.0 == 200000);
    assert!(balance2.0 == 11005078);
}

#[test]
fn value_locked_more_open() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        100,
        100,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    testing_env!(context.signer_account_id(accounts(1)).build());
    let initial_balance1 = 100000;
    let initial_balance2 = 11005100;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(initial_balance1),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    testing_env!(context.signer_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(initial_balance2),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    for _ in 0..100 {
        contract.open_position(0, Some(U128(1000)), None, 81.0, 121.0);
        let pool = &contract.pools[0];
        assert!(pool.token0_locked <= initial_balance1);
        assert!(pool.token1_locked <= initial_balance2);
    }
    let pool = &contract.pools[0];
    assert!(pool.token0_locked == 100000);
    assert!(pool.token1_locked == 11005078);
}

#[test]
fn value_locked_more_swaps() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        10000.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    testing_env!(context.signer_account_id(accounts(1)).build());
    let initial_balance1 = 101000;
    let initial_balance2 = 10763056;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(initial_balance1),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    testing_env!(context.signer_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(initial_balance2),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 9990.0, 11000.0);
    for _ in 0..10 {
        contract.swap(
            0,
            &accounts(1).to_string(),
            U128(100),
            &accounts(2).to_string(),
        );
        let pool = &contract.pools[0];
        let position = &pool.positions.get(&0).unwrap();
        assert!(pool.token0_locked == (position.token0_locked.round() as u128));
        assert!(pool.token1_locked == (position.token1_locked.round() as u128));
        assert!(pool.token0_locked <= initial_balance1);
        assert!(pool.token1_locked <= initial_balance2);
        let balance1 = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
        let balance2 = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
        assert!((balance1.0 + pool.token0_locked) <= initial_balance1);
        assert!((balance2.0 + pool.token1_locked) <= (initial_balance2 + 2));
    }
    contract.close_position(0, 0);
    let balance1 = contract.get_balance(&accounts(0).to_string(), &accounts(1).to_string());
    let balance2 = contract.get_balance(&accounts(0).to_string(), &accounts(2).to_string());
    assert!(balance1.0 <= initial_balance1);
    assert!(balance2.0 <= (initial_balance2 + 2));
}

#[test]
fn add_and_remove_liquidity1() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        10000.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    let initial_balance1 = 101000;
    let initial_balance2 = 10763056;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(initial_balance1),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(initial_balance2),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, Some(U128(100000)), None, 9990.0, 11000.0);
    contract.remove_liquidity(0, 0, Some(U128(10000)), None);
    contract.add_liquidity(0, 0, Some(U128(10000)), None);
    let pool = &contract.pools[0];
    let position = &pool.positions.get(&0).unwrap();
    assert!(position.token0_locked.round() == 100000.0);
}

#[test]
fn add_and_remove_liquidity2() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        10000.0,
        0,
        0,
    );
    testing_env!(context.predecessor_account_id(accounts(1)).build());
    let initial_balance1 = 101000;
    let initial_balance2 = 10763056;
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(1),
        U128(initial_balance1),
    );
    testing_env!(context.predecessor_account_id(accounts(2)).build());
    deposit_tokens(
        &mut context,
        &mut contract,
        accounts(0),
        accounts(2),
        U128(initial_balance2),
    );
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    testing_env!(context.signer_account_id(accounts(0)).build());
    contract.open_position(0, None, Some(U128(100000)), 9990.0, 11000.0);
    contract.remove_liquidity(0, 0, None, Some(U128(10000)));
    contract.add_liquidity(0, 0, None, Some(U128(10000)));
    let pool = &contract.pools[0];
    let position = &pool.positions.get(&0).unwrap();
    assert!(position.token1_locked.round() == 100000.0);
}

#[test]
fn open_many_positions() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    for i in 3..103 {
        let account = format!("\"{i}.testnet\"");
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(1),
            U128(2000000),
        );
        testing_env!(context.predecessor_account_id(accounts(2)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(2),
            U128(3000000),
        );
        testing_env!(context
            .predecessor_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        testing_env!(context
            .signer_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        for _ in 0..10 {
            contract.open_position(0, Some(U128(50)), None, 64.0, 121.0);
        }
    }
    let pool = &contract.pools[0];
    assert!(pool.positions.len() == 1000);
}

#[test]
fn open_many_positions_with_swap1() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    for i in 3..13 {
        let account = format!("\"{i}.testnet\"");
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        testing_env!(context.signer_account_id(accounts(1)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(1),
            U128(2000000),
        );
        testing_env!(context.predecessor_account_id(accounts(2)).build());
        testing_env!(context.signer_account_id(accounts(2)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(2),
            U128(3000000),
        );
        testing_env!(context
            .predecessor_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        testing_env!(context
            .signer_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        for _ in 0..10 {
            contract.open_position(0, Some(U128(50)), None, 64.0, 121.0);
        }
        let amount = contract.swap(
            0,
            &accounts(1).to_string(),
            U128(10),
            &accounts(2).to_string(),
        );
        contract.swap(
            0,
            &accounts(2).to_string(),
            amount,
            &accounts(1).to_string(),
        );
    }
    let pool = &contract.pools[0];
    assert!(pool.positions.len() == 100);
}

#[test]
fn open_many_positions_with_swap2() {
    let (mut context, mut contract) = setup_contract();
    contract.create_pool(
        accounts(1).to_string(),
        accounts(2).to_string(),
        100.0,
        0,
        0,
    );
    for i in 3..153 {
        let account = format!("\"{i}.testnet\"");
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        testing_env!(context.signer_account_id(accounts(1)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(1),
            U128(2000000),
        );
        testing_env!(context.predecessor_account_id(accounts(2)).build());
        testing_env!(context.signer_account_id(accounts(2)).build());
        deposit_tokens(
            &mut context,
            &mut contract,
            serde_json::from_str(account.as_str()).unwrap(),
            accounts(2),
            U128(3000000),
        );
        testing_env!(context
            .predecessor_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        testing_env!(context
            .signer_account_id(serde_json::from_str(account.as_str()).unwrap())
            .build());
        contract.open_position(0, Some(U128(50)), None, 64.0, 121.0);
        let amount = contract.swap(
            0,
            &accounts(1).to_string(),
            U128(10),
            &accounts(2).to_string(),
        );
        contract.swap(
            0,
            &accounts(2).to_string(),
            amount,
            &accounts(1).to_string(),
        );
    }
    let pool = &contract.pools[0];
    assert!(pool.positions.len() == 150);
}

'''