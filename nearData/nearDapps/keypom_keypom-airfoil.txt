*GitHub Repository "keypom/keypom-airfoil"*

'''--- .eslintrc.js ---
/* eslint-disable semi */
/* eslint-disable comma-dangle */
module.exports = {
  env: {
    browser: true,
    es2021: true,
    es6: true,
  },
  root: true,
  extends: [
    'plugin:react/jsx-runtime',
    'plugin:react/recommended',
    'standard-with-typescript',
    'plugin:@typescript-eslint/recommended',
    'prettier',
    'plugin:prettier/recommended',
  ],
  overrides: [],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.json',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
  },
  plugins: [
    'react',
    'unused-imports',
    'simple-import-sort',
    'prettier',
    'import',
    '@typescript-eslint',
  ],
  rules: {
    'react/react-in-jsx-scope': 'off',
    'react/jsx-sort-props': [
      2,
      {
        callbacksLast: true,
        shorthandFirst: true,
        ignoreCase: true,
        reservedFirst: true,
      },
    ],
    'no-unused-vars': 'error',
    'no-console': 'warn',
    'prefer-const': [
      'error',
      {
        destructuring: 'any',
      },
    ],
    'react/no-unknown-property': ['error', { ignore: ['css', 'global', 'jsx'] }],
    'array-callback-return': [
      'error',
      {
        checkForEach: true,
      },
    ],
    '@typescript-eslint/no-misused-promises': 'off',
    camelcase: 'off',
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/naming-convention': 'off',
    '@typescript-eslint/no-empty-interface': 'off',
    'prettier/prettier': 'error',
    'simple-import-sort/exports': 'error',
    'react/no-unescaped-entities': 'off',
    'import/first': 'error',
    'import/newline-after-import': 'error',
    'import/no-duplicates': 'error',
    'unused-imports/no-unused-imports': 'error',
    '@typescript-eslint/restrict-template-expressions': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/prefer-nullish-coalescing': 'off',
    'import/order': [
      'warn',
      {
        pathGroups: [
          {
            pattern: '@/**',
            group: 'external',
            position: 'after',
          },
        ],
        'newlines-between': 'always',
      },
    ],
    '@typescript-eslint/strict-boolean-expressions': [
      'warn',
      {
        allowNullableBoolean: true,
        allowNullableString: true,
        allowNullableNumber: true,
        allowAny: true,
        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: true,
      },
    ],
    '@typescript-eslint/restrict-template-expressions': [
      'error',
      {
        allowNullish: true,
      },
    ],
    '@typescript-eslint/no-misused-promises': 'off',
    '@typescript-eslint/no-floating-promises': 'off',
  },
};

'''
'''--- .github/ISSUE_TEMPLATE/1-feature_request_template.md ---
---
name: Feature request
about: Suggest a feature for Keypom App
labels: kind/feature
---

## Describe the feature you would like to request
Describe the feature here. 

## Provide a brief explanation of why this feature is necessary
Explain why is this feature necessary here.

## Acceptance Criteria
List down criterias that should be included in this issue. This is to help reviewers look out for expected changes in PR.
- [ ] Criteria 1
- [ ] Criteria 2

## Provide an estimation of how long the developers should spend on implementing this feature
Estimations can be in terms of hours or a specific deadline. 

## References
Include any URLs, screenshots, or source code that would be helpful as reference or inspiration towards implementing the feature.
'''
'''--- .github/ISSUE_TEMPLATE/2-issue_template.md ---
---
name: Bug report
about: Report a bug encountered with using Keypom App
labels: kind/bug
---

# Describe the problem
Describe the problem clearly here. 

# Describe the expected behaviour
Describe the expected behaviour.

# Steps to reproduce problem
List down the steps required to replicate the problem.

# Implications
Let us know if this problem is affecting other parts of the application that we should be aware of and might require patching up.

# Additional Documentations
Include any console logs, screenshots, or source code that would be helpful to diagnose the problem. 
'''
'''--- .github/pull_request_template.md ---
# Description
Please include a summary of the change and which issue is fixed. Please also include relevant motivation and context. List any dependencies that are required for this change.

Fixes # (issue)

# How to test
Show steps to replicate and test the feature/fixes in this PR

1. check out locally, and go to http://localhost:3000
2. ...

# Screenshots/Screen Recording of Implementation

'''
'''--- .github/workflows/main.yml ---
# Simple workflow for deploying static content to GitHub Pages
name: Build

on: [pull_request]

jobs:
  build:
    concurrency: ci-${{ github.ref }} # Recommended if you intend to make multiple deployments in quick succession.
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x]
    steps:
      - name: Check out repo
        uses: actions/checkout@v2
      - name: Configure yarn caching
        uses: actions/cache@v2
        with:
          path: ~/.yarn
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/workflows/prettier.yml') }}
          restore-keys: |
            ${{ runner.os }}-yarn-
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'yarn'
      - name: Install dependencies
        run: yarn install
      - name: Format the code
        run: yarn run format
      - name: Check the code style
        run: yarn run lint
      - name: Check the types
        run: yarn check-types
      - name: Build the project
        run: yarn build

'''
'''--- .vscode/extensions.json ---
{
  "recommendations": ["esbenp.prettier-vscode", "dbaeumer.vscode-eslint", "prisma.prisma"]
}

'''
'''--- .vscode/settings.json ---
{
  // eslint extension options
  "eslint.enable": true,
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  // prettier extension setting
  "editor.formatOnSave": true,
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[javascriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "editor.rulers": [80],
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "cSpell.words": ["bgcolor"],
  "typescript.tsdk": "node_modules/typescript/lib"
}

'''
'''--- CONTRIBUTING.md ---
# Contributing to Parcel + React Boilerplate

We would love for you to contribute to Parcel + React Boilerplate and help make it even better than it is today! As a contributor, here are the guidelines we would like you to follow:

- [Contributing to Parcel + React Boilerplate](#contributing-to-parcel--react-boilerplate)
  - [Getting Started](#getting-started)
  - [Issues](#issues)
    - [Questions](#questions)
    - [Help Wanted](#help-wanted)
    - [Bugs](#bugs)
    - [Features](#features)
  - [Pulls Requests](#pulls-requests)
  - [Submission Guidelines](#submission-guidelines)
    - [Submitting an Issue](#submitting-an-issue)
    - [Submitting a Pull Request](#submitting-a-pull-request)

## Getting Started

Start by **starring** the repo or [forking](https://github.com/ayungavis/parcel-react-typescript/fork) it. Go through the [GitHub Community Guidelines](https://help.github.com/en/github/site-policy/github-community-guidelines) to have a better understanding about `DOS` and `DON'TS` in the open source community.

## Issues

The issues can be [opened](#submitting-an-issue) on our [GitHub Repository][github] and used for the following purposes adhering to their respective guidelines:

### Questions

If you have a general question related to documentation or anything in particular to ours, please elaborate it as much as possible so that we can have a good understanding and provide you with the best possible answer.

### Help Wanted

We'd be happy to help you to the best of our knowledge with any blockers that you have while making a documentation for your projects.

### Bugs

If you find a bug, typo or something invalid in the documentation, you can help us by mentioning where exactly it is and how it can be corrected. It would be even better if you [submit a Pull Request](#submitting-a-pull-request) with a fix.

### Features

There are two scenario's for features:

- **_Requesting_** a new feature by provide a comprehensive explanation of your idea
- **_Implementing_** a new feature for the project by submitting an issue with a proposal for your work first, to be sure that we can use it and then later [submitting a Pull Request](#submitting-a-pull-request) with the implementation. A brief explanation would be enough

## Pulls Requests

Pull requests are, a great way to get your ideas into this repository. PRs can be [opened](#submitting-a-pull-request) on our [GitHub Repository][github] and used for the following purposes adhering to their respective guidelines

When deciding if we merge in a pull request, we look for the following things:

- improves the project in the direction of our vision
- follows the contributor covenant
- states the intent
- is of good quality
  - no spelling mistakes
  - good grammer

## Submission Guidelines

### Submitting an Issue

Before you submit an issue, please search the [Issue tracker](https://github.com/ayungavis/parcel-react-typescript/issues) for an existing issues that might be similar to your problem and the discussion might inform you of workarounds readily available.

We want to fix all the issues as soon as possible, but before fixing them, we have do check on our end to make sure everything is perfect. To speed up things, please provide all the information that you think might be relavant to it.

If we don't hear back from you, we are going to close the issue that we think don't have enough info to be reproduced.

### Submitting a Pull Request

Before you submit a Pull Request (PR), consider the following guidelines, search the repo for an open or closed [PR tracker](https://github.com/ayungavis/parcel-react-typescript/pulls) that relates to your submission. You don't want to duplicate effort.

Follow these steps and guidelines when starting with a PR:

- Make your changes in a new local git branch:
  ```shell
  git checkout -b BRANCH_NAME origin/master
  ```
- Use one branch per fix / feature
- Follow our [Coding Rules](#coding-rules)
- Commit your changes

  - Please provide a git message that explains what you've done
  - Make sure your commit messages follow the [conventional guidelines](https://gist.github.com/robertpainsi/b632364184e70900af4ab688decf6f53#file-commit-message-guidelines-md)
  - Commit to the forked repository

    Example :pencil2: :

    ```
    $ git commit -am 'Adding Details in Deployment Section'
    ```

  - Push to the branch in the forked repository
    Example :pencil2: :
    ```
    $ git push origin BRANCH_NAME
    ```

After making sure that all above guidelines have been followed completely,

- Make a pull request to the `master` branch in the [main repo][github]
- If we suggest any changes then make the required updates
- If we don't hear back from you for a while, we are going to close the PR if it doesn't meet the guidelines
- Make sure there are no merge conflicts
- Once your PR is approved and you are done with any follow up changes:

  - Rebase to the current master to pre-emptively address any merge conflicts.

    ```shell
    git rebase master -i
    git push -f
    ```

  - Add the `PR action: merge` label

- The current caretaker will merge the PR to the target branch(es) within 1-2 business days.

That's it! Thank you for your contribution! 🎉

[github]: https://github.com/ayungavis/parcel-react-typescript

'''
'''--- README.md ---
# Keypom App 🚀

![Current Version](https://img.shields.io/badge/version-v1.0-blue)
![GitHub contributors](https://img.shields.io/github/contributors/ayungavis/parcel-react-typescript)
![GitHub stars](https://img.shields.io/github/stars/keypom/keypom-airfoil?style=social)
![GitHub forks](https://img.shields.io/github/forks/keypom/keypom-airfoil?style=social)
![Twitter Follow](https://img.shields.io/twitter/follow/keypomxyz?style=social)

This is a React application which comes with a suite of use cases to create drops with UI that interacts with Keypom SDK and NEAR protocol.

The project is hosted on Cloudflare - https://keypom.xyz/.

### Tools Required

All tools required go here. You would require the following tools to develop and run the project:

- A text editor or an IDE (like VSCode)
- Node.js => `v16.0.0`
- Yarn => `v1.22.10`

### Running the App

All installation steps go here.

- Clone the repository
  ```bash
  git clone https://github.com/keypom/keypom-airfoil
  ```
- Install dependencies
  ```bash
  yarn install
  ```
- Run the app
  ```bash
  yarn dev
  ```
- Build the app
  ```bash
  yarn build
  ```

## Project Structure

The project structure is inspired by [Bulletproof React](https://github.com/alan2207/bulletproof-react/blob/master/docs/project-structure.md). 

## Deployment

This app is deployed on Cloudflare Pages. Preview site is deployed when a feature branch has been commited to origin. 
`pr-main` is the current production/mainnet branch.
`testnet` is the current staging/testnet branch.

'''
'''--- package.json ---
{
  "name": "parcel-react-typescript",
  "version": "1.0.0",
  "author": "Keypom",
  "license": "MIT",
  "scripts": {
    "clean": "rm -rf dist .parcel-cache",
    "dev": "yarn clean && yarn static && parcel src/index.html -p 3000",
    "storybook": "yarn clean && yarn static && IS_STORYBOOK_VIEW=true parcel src/index.html -p 3000",
    "dev-mainnet": "yarn clean && yarn static && REACT_APP_CONTRACT_ID=v2.keypom.near REACT_APP_NETWORK_ID=mainnet parcel src/index.html -p 3000",
    "build": "yarn static && parcel build src/index.html --public-url ./ --no-cache --no-source-maps",
    "build:analyze": "yarn static && parcel build src/index.html --public-url ./ --no-cache --reporter @parcel/reporter-bundle-analyzer",
    "static": "rm -rf dist && mkdir dist && cp -a ./public/* ./dist",
    "serve": "yarn build && npx serve dist -s",
    "check-types": "tsc --noEmit",
    "lint": "eslint ./src --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint ./src --ext .js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write 'src/**/*.{js,jsx,ts,tsx,scss}'"
  },
  "dependencies": {
    "@chakra-ui/anatomy": "^2.1.1",
    "@chakra-ui/icons": "2.0.14",
    "@chakra-ui/react": "^2.4.9",
    "@chakra-ui/styled-system": "2.5.0",
    "@chakra-ui/system": "2.3.5",
    "@emotion/react": "^11.10.5",
    "@emotion/styled": "^11.10.5",
    "@hookform/resolvers": "^2.9.10",
    "@near-wallet-selector/core": "^7.6.1",
    "@near-wallet-selector/modal-ui": "^7.6.1",
    "@near-wallet-selector/my-near-wallet": "^7.8.2",
    "@near-wallet-selector/near-wallet": "^7.6.1",
    "bn.js": "^5.2.1",
    "copy-to-clipboard": "^3.3.3",
    "framer-motion": "^8.5.5",
    "idb-keyval": "^6.2.0",
    "ipfs-car": "^0.9.2",
    "keypom-js": "^1.4.7",
    "mathjs": "^11.5.1",
    "near-api-js": "^1.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.43.0",
    "react-qr-code": "^2.0.11",
    "react-qr-reader": "3.0.0-beta-1",
    "react-router-dom": "^6.8.0",
    "rxjs": "^7.8.0",
    "string_decoder": "^1.3.0",
    "swr": "^2.0.3",
    "zod": "^3.20.2"
  },
  "devDependencies": {
    "@parcel/config-default": "^2.8.3",
    "@parcel/reporter-bundle-analyzer": "^2.8.3",
    "@parcel/transformer-svg-react": "^2.8.3",
    "@parcel/transformer-typescript-tsc": "^2.8.3",
    "@parcel/validator-typescript": "^2.8.3",
    "@types/node": "^18.11.18",
    "@types/react": "^18.0.27",
    "@types/react-dom": "^18.0.10",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.50.0",
    "buffer": "^5.5.0",
    "crypto-browserify": "^3.12.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.6.0",
    "eslint-config-standard-with-typescript": "^33.0.0",
    "eslint-plugin-import": "^2.25.2",
    "eslint-plugin-n": "^15.0.0",
    "eslint-plugin-prettier": "^4.2.1",
    "eslint-plugin-promise": "^6.0.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-simple-import-sort": "^10.0.0",
    "eslint-plugin-unused-imports": "^2.0.0",
    "events": "^3.1.0",
    "parcel": "^2.8.3",
    "parcel-resolver-ts-base-url": "^1.3.1",
    "parcel-resolver-tspaths": "^0.0.9",
    "parcel-resolver-typescript-module": "^0.1.8",
    "path-browserify": "^1.0.0",
    "prettier": "^2.8.3",
    "process": "^0.11.10",
    "stream-browserify": "^3.0.0",
    "tslint-config-prettier": "^1.18.0",
    "typescript": "^4.9.5",
    "util": "^0.12.3"
  },
  "browserslist": [
    "last 2 Chrome versions"
  ]
}
'''
'''--- public/README.md ---
This is the public directory of your application. You can place your static assets here.

'''
'''--- src/components/AppModal/index.ts ---
export * from './AppModal';

'''
'''--- src/components/AvatarImage/index.ts ---
export * from './AvatarImage';

'''
'''--- src/components/BoxWithShape/index.ts ---
export * from './BoxWithShape';

'''
'''--- src/components/Breadcrumbs/index.ts ---
export * from './Breadcrumbs';

'''
'''--- src/components/Checkboxes/index.ts ---
export * from './Checkboxes';

'''
'''--- src/components/ConnectWalletButton/ConnectWalletModal/index.ts ---
export * from './ConnectWalletModal';

'''
'''--- src/components/ConnectWalletButton/index.ts ---
export * from './ConnectWalletButton';

'''
'''--- src/components/CoreLayout/index.ts ---
export * from './CoreLayout';

'''
'''--- src/components/DropBox/index.ts ---
export * from './DropBox';

'''
'''--- src/components/ErrorBox/index.ts ---
export * from './ErrorBox';

'''
'''--- src/components/Footer/index.ts ---
export * from './Footer';

'''
'''--- src/components/FormControl/index.ts ---
export * from './FormControl';

'''
'''--- src/components/GradientSpan/index.ts ---
export * from './GradientSpan';

'''
'''--- src/components/IconBox/index.ts ---
export * from './IconBox';

'''
'''--- src/components/Icons/index.ts ---
export * from './CheckedIcon';
export * from './ChevronLeftIcon';
export * from './CopyIcon';
export * from './DeleteIcon';
export * from './DropIcon';
export * from './ImageIcon';
export * from './KeyIcon';
export * from './LinkIcon';
export * from './LogoNear';
export * from './MenuIcon';
export * from './NearIcon';
export * from './NFTIcon';
export * from './POAPNftIcon';
export * from './SignOutIcon';
export * from './StarIcon';
export * from './TicketIcon';
export * from './tokens/TokenEthIcon';
export * from './TwitterLogoIcon';
export * from './UncheckedIcon';
export * from './wallets/HereWalletIcon';
export * from './wallets/MyNearWalletIcon';

'''
'''--- src/components/ImageFileInput/index.ts ---
export * from './ImageFileInput';

'''
'''--- src/components/KeypomLogo/index.ts ---
export * from './KeypomLogo';

'''
'''--- src/components/Loading/index.ts ---
export * from './Loading';

'''
'''--- src/components/Menu/index.ts ---
export * from './Menu';

'''
'''--- src/components/Navbar/index.ts ---
export * from './MobileMenu';
export * from './Navbar';

'''
'''--- src/components/NotFound404/index.ts ---
export * from './NotFound404';

'''
'''--- src/components/Pagination/index.ts ---
export * from './NextButton';
export * from './PrevButton';

'''
'''--- src/components/PopoverTemplate/index.ts ---
export * from './PopoverTemplate';

'''
'''--- src/components/ProtectedRoutes/index.ts ---
export * from './ProtectedRoute';

'''
'''--- src/components/RoundedTabs/index.ts ---
export * from './RoundedTabs';

'''
'''--- src/components/SignedInButton/index.ts ---
export * from './SignedInButton';

'''
'''--- src/components/Step/index.ts ---
export * from './Step';

'''
'''--- src/components/SwitchInput/index.ts ---
export * from './SwitchInput';

'''
'''--- src/components/Table/constants.ts ---
export const EMPTY_TABLE_TEXT_MAP = {
  'all-drops': {
    heading: `You haven't added any drops`,
    text: `Let's create a drop!`,
  },
  'drop-manager': {
    heading: `You haven't added any keys`,
    text: '',
  },
};

'''
'''--- src/components/Table/index.ts ---
export * from './DataTable';
export * from './MobileDataTable';

'''
'''--- src/components/Table/types.ts ---
import { type TableCellProps } from '@chakra-ui/react';

type Primitive = string | number | boolean;

export interface DataItem {
  id: string | number;
  [key: string]: React.ReactNode | Primitive;
}

export interface ColumnItem {
  id: string; // unique key
  title: string;
  selector: (arg: DataItem) => React.ReactNode | Primitive;
  loadingElement?: React.ReactNode;
  tdProps?: TableCellProps;
  thProps?: TableCellProps;
}

export interface Pagination {
  pageIndex: number;
  pageSize: number;
}

'''
'''--- src/components/TextAreaInput/index.ts ---
export * from './TextAreaInput';

'''
'''--- src/components/TextInput/index.ts ---
export * from './TextInput';

'''
'''--- src/components/TokenIcon/index.ts ---
export * from './TokenIcon';

'''
'''--- src/components/TokenInputMenu/index.ts ---
export * from './CostDisplay';
export * from './TokenInput';
export * from './TokenMenuSelector';

'''
'''--- src/components/ViewFinder/index.ts ---
export * from './ViewFinder';

'''
'''--- src/components/WalletIcon/index.ts ---
export * from './WalletIcon';

'''
'''--- src/components/WalletSelectorModal/WalletSelectorModal.css ---
.nws-modal {
  z-index: 9999999 !important;
  border: 2px solid transparent;
  background: var(--chakra-colors-border-box) !important;
}

.nws-modal-wrapper {
  width: 99%;
}

@media screen and (min-width: 576px) {
  :root {
    --wallet-selector-heading-color: var(--chakra-colors-gray-900);
    --wallet-selector-text-color: var(--chakra-colors-gray-900);
    --wallet-selector-close-button-bg-color: var(--chakra-colors-gray-100);
    --wallet-selector-sidebar-border-color: var(--chakra-colors-gray-100);
    --get-wallet-option-border-color: var(--chakra-colors-gray-100);
  }
  
  .nws-modal {
    z-index: 9999999 !important;
    border: 2px solid transparent;
    background: var(--chakra-colors-border-box) !important;
    color: var(--chakra-colors-gray-600);
  }
  
  .nws-modal-wrapper {
    font-family: var(--chakra-fonts-body);
  }
  
  .nws-modal-wrapper .nws-modal .nws-modal-body button.middleButton {
    background-color: var(--chakra-colors-gray-800);
    color: var(--chakra-colors-white);
    border-radius: var(--chakra-radii-6xl);
  }
  
  .nws-modal .options-list-section-header {
    display: none;
  }
  
  .nws-modal-wrapper .nws-modal .modal-right .wallet-what .icon-side {
    background: var(--chakra-colors-gray-800);
    color: var(--chakra-colors-white);
  } 
  
  .single-wallet-get {
    border: 1px solid var(--chakra-colors-gray-100);
    border-radius: var(--chakra-radii-6xl);
    background-color: var(--chakra-colors-white);
    color: var(--chakra-colors-gray-900);
  }
  
  .single-wallet-get .title {
    color: var(--chakra-colors-gray-900);
  }
  
  .single-wallet-get .type {
    color: var(--chakra-colors-gray-600);
  }

 }

'''
'''--- src/config/config.ts ---
import { type IToken, type IWalletOption } from '@/types/common';

const contractName = process.env.REACT_APP_CONTRACT_ID ?? 'v2.keypom.testnet';
const cloudflareIfps = process.env.REACT_APP_CLOUDFLARE_IFPS ?? 'https://cloudflare-ipfs.com/ipfs';
// eslint-disable-next-line no-console
console.log(process.env.REACT_APP_NETWORK_ID, process.env.REACT_APP_CONTRACT_ID);

const SUPPORTED_WALLET_OPTIONS: IWalletOption[] = [
  {
    name: 'mynearwallet',
    title: 'My Near Wallet',
  },
  // support only mynearwallet for now
  // https://docs.keypom.xyz/docs/next/keypom-sdk/modules#supportedlinkdropclaimpages
  // {
  //   title: 'HERE',
  //   walletName: 'My HERE',
  //   id: 'herewallet',
  // },
];

const DEFAULT_WALLET = SUPPORTED_WALLET_OPTIONS[0];

// used in create drops
const DEFAULT_TOKEN: IToken = {
  amount: '',
  symbol: 'NEAR',
};

export interface Config {
  networkId: string;
  nodeUrl: string;
  walletUrl: string;
  helperUrl: string;
  contractName: string;
  explorerUrl: string;
  GAS: string;
  gas: string;
  attachedDeposit: string;
  NEW_ACCOUNT_AMOUNT: string;
  NEW_CONTRACT_AMOUNT: string;
  contractId: string;
  isBrowser: boolean;
  cloudflareIfps: string;
  supportedWallets: IWalletOption[];
  defaultWallet: IWalletOption;
  defaultToken: IToken;
}

function getConfig(network = process.env.REACT_APP_NETWORK_ID ?? 'testnet'): Config {
  const defaultConfig = {
    GAS: '200000000000000',
    gas: '200000000000000',
    attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
    NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
    NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
    contractId: contractName,
    isBrowser: typeof window !== 'undefined',
    cloudflareIfps,
    supportedWallets: SUPPORTED_WALLET_OPTIONS,
    defaultWallet: DEFAULT_WALLET,
    defaultToken: DEFAULT_TOKEN,
  };

  switch (network) {
    case 'testnet':
      return {
        ...defaultConfig,
        contractName,
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://testnet.mynearwallet.com',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      };

    case 'mainnet':
      return {
        ...defaultConfig,
        contractName,
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://app.mynearwallet.com',
        helperUrl: 'https://helper.near.org',
        explorerUrl: 'https://explorer.near.org',
      };
    default:
      throw Error(`Unconfigured environment '${network}'. Can be configured in src/config.ts.`);
  }
}

export default getConfig;

'''
'''--- src/constants/common.ts ---
// Matches with optional protocol and URL with one dot
export const urlRegex = /(?:(?:https?:\/\/)?[\w.-]*\.[\w]{2,3})/;

export const CLOUDFLARE_IPFS = 'https://cloudflare-ipfs.com/ipfs';

export const DROP_TYPE = {
  TOKEN: 'TOKEN',
  TICKET: 'TICKET',
  TRIAL: 'TRIAL',
  NFT: 'NFT',
  SIMPLE: 'SIMPLE',
  OTHER: 'OTHER',
} as const;

type DROP_TYPE_KEYS = keyof typeof DROP_TYPE;
export type DROP_TYPES = (typeof DROP_TYPE)[DROP_TYPE_KEYS];

export const MASTER_KEY = 'MASTER_KEY';

export const MAX_FILE_SIZE = 10000000;

export const PAGE_SIZE_LIMIT = 10;
export const NFT_ATTEMPT_KEY = 'NFT_ATTEMPT';
export const PAGE_QUERY_PARAM = 'page';

'''
'''--- src/constants/toast.ts ---
import { type UseToastOptions } from '@chakra-ui/react';

export const UNAUTHORIZED_TOAST: UseToastOptions = {
  title: 'User is not authorized',
  description: 'Please connect to your wallet.',
  status: 'error',
  duration: 2000,
  isClosable: true,
};

'''
'''--- src/features/create-drop/components/DropSummary/index.ts ---
export * from './DropSummary';

'''
'''--- src/features/create-drop/components/nft/index.ts ---
export * from './CreateNftDropForm';
export * from './CreateNftDropSummary';

'''
'''--- src/features/create-drop/components/ticket/index.ts ---
export * from './AdditionalGiftsForm/POAPNftForm';
export * from './AdditionalGiftsForm/TokenForm';
export * from './CreateTicketDropForm';
export * from './CreateTicketDropSummary';
export * from './EventInfoForm';
export * from './SignUpInfoForm';

'''
'''--- src/features/create-drop/components/token/index.ts ---
export * from './CreateTokenDropForm';
export * from './CreateTokenDropSummary';

'''
'''--- src/features/create-drop/contexts/CreateTicketDropContext/FormValidations.ts ---
import * as z from 'zod';

import { MAX_FILE_SIZE } from '@/constants/common';

const ACCEPTED_IMAGE_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];

export const EventInfoSchema = z.object({
  eventName: z.string().min(1, 'Event name required'),
  totalTickets: z
    .number({ invalid_type_error: 'Number of tickets required' })
    .positive()
    .min(1, 'Required'),
});

export const SignUpInfoSchema = z.object({
  firstName: z.boolean().optional(),
  secondName: z.boolean().optional(),
  emailAddress: z.boolean().optional(),
});

const additionalGiftTokenSchema = z.object({
  selectedToken: z
    .object({
      symbol: z.string(),
      amount: z.string(),
    })
    .nullable(),
  amountPerLink: z.number().or(z.string()).or(z.nan()),
});

const additionalGiftPOAPSchema = z.object({
  name: z.string(),
  description: z.string(),
  artwork: z.any(),
});

export const AdditionalGiftSchema = z
  .object({
    additionalGift: z.object({
      type: z.enum(['none', 'poapNft', 'token']),
      token: additionalGiftTokenSchema.deepPartial(),
      poapNft: additionalGiftPOAPSchema.deepPartial(),
    }),
  })
  .superRefine(({ additionalGift }, ctx) => {
    if (additionalGift.type === 'token') {
      const token = additionalGift.token;
      let amount = token?.amountPerLink;
      if (!amount) amount = 0;
      if (typeof amount === 'string') amount = parseInt(amount);

      if (amount <= 0) {
        ctx.addIssue({
          path: ['additionalGift.token.amountPerLink'],
          code: z.ZodIssueCode.custom,
          message: `Token amount is required and greater than 0.`,
          fatal: true,
        });
        return z.NEVER;
      }

      if (token.selectedToken === null) {
        ctx.addIssue({
          path: ['additionalGift.token.selectedToken'],
          code: z.ZodIssueCode.custom,
          message: `Wallet tokens is required.`,
        });
        return z.NEVER;
      }

      return true;
    } else if (additionalGift.type === 'poapNft') {
      const poapNft = additionalGift.poapNft;

      if (!poapNft.name || poapNft?.name?.length === 0) {
        ctx.addIssue({
          path: ['additionalGift.poapNft.name'],
          code: z.ZodIssueCode.custom,
          message: `POAP NFT name is required.`,
        });
      }

      if (!poapNft.description || poapNft?.description?.length === 0) {
        ctx.addIssue({
          path: ['additionalGift.poapNft.description'],
          code: z.ZodIssueCode.custom,
          message: `POAP NFT description is required.`,
        });
      }

      const artworkFiles = poapNft.artwork;
      if (artworkFiles?.length !== 1) {
        ctx.addIssue({
          path: ['additionalGift.poapNft.artwork'],
          code: z.ZodIssueCode.custom,
          message: `Image is required.`,
        });
        return z.NEVER;
      }

      if (artworkFiles?.[0]?.size > MAX_FILE_SIZE) {
        ctx.addIssue({
          path: ['additionalGift.poapNft.artwork'],
          code: z.ZodIssueCode.custom,
          message: `Max file size is 10MB.`,
        });
        return z.NEVER;
      }

      if (!ACCEPTED_IMAGE_TYPES.includes(artworkFiles?.[0]?.type)) {
        ctx.addIssue({
          path: ['additionalGift.poapNft.artwork'],
          code: z.ZodIssueCode.custom,
          message: `Only .jpg, .jpeg, .png and .webp files are accepted.`,
        });
        return z.NEVER;
      }
    }
    return true;
  });

'''
'''--- src/features/create-drop/contexts/CreateTicketDropContext/index.ts ---
export * from './CreateTicketDropContext';

'''
'''--- src/features/create-drop/contexts/index.ts ---
export * from './DropFlowContext';

'''
'''--- src/features/create-drop/contexts/nft-utils.ts ---
import { getEnv, generateKeys, createDrop, parseNearAmount } from 'keypom-js';
import { get, update, del } from 'idb-keyval';
import { pack } from 'ipfs-car/dist/esm/pack';
import { MemoryBlockStore } from 'ipfs-car/dist/esm/blockstore/memory';

import { MASTER_KEY, NFT_ATTEMPT_KEY } from '@/constants/common';

const WORKER_BASE_URL = 'https://keypom-nft-storage.keypom.workers.dev/';

export const DEBUG_DEL_NFT_ATTEMPT = async () => {
  await del(NFT_ATTEMPT_KEY);
};

export const getNFTAttempt = async () => {
  const data = (await get(NFT_ATTEMPT_KEY)) || {};
  if (!data.dropId) {
    return null;
  }
  return data;
};

export const createDropsForNFT = async (dropId, returnTransactions, data, setAppModal) => {
  const { networkId } = getEnv();
  const networkSuffix = networkId === 'testnet' ? networkId : 'near';

  const file = await data?.media?.arrayBuffer();

  let { media = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' } = data;

  const { numKeys, title, description } = data;

  const wallet = await window.selector.wallet();

  // generate CID locally HERE
  if (file) {
    const { root } = await pack({
      input: file,
      blockstore: new MemoryBlockStore(),
      wrapWithDirectory: false,
    });
    media = root.toString();
    console.log('CID', media);
  }

  let keys, requiredDeposit;
  if (!data.seriesSecret) {
    try {
      const res = await createDrop({
        wallet,
        numKeys: 1,
        metadata: JSON.stringify({
          name: title,
        }),
        depositPerUseNEAR: 0.1,
        fcData: {
          methods: [
            [
              {
                receiverId: 'nft-v2.keypom.' + networkSuffix,
                methodName: 'create_series',
                args: JSON.stringify({
                  mint_id: parseInt(dropId),
                  metadata: {
                    title,
                    description,
                    copies: numKeys,
                    media,
                  },
                  // royalty?
                }),
                attachedDeposit: parseNearAmount('0.1')!,
              },
            ],
          ],
        },
        useBalance: !returnTransactions,
        returnTransactions,
      });

      keys = res.keys;
      requiredDeposit = res.requiredDeposit;

      if (!returnTransactions && !keys) {
        throw new Error('Error creating drop');
      }

      // we're making the NFT now, so store the secret in case we have to re-attempt media upload
      if (file) {
        await update(NFT_ATTEMPT_KEY, (val) => ({ ...val, seriesSecret: keys.secretKeys[0] }));
        data.seriesSecret = keys.secretKeys[0];
      }
    } catch (e) {
      console.warn(e);
      throw new Error('Error creating drop');
    }
  }

  if (file) {
    const { networkId } = getEnv();
    const url = `${WORKER_BASE_URL}?network=${networkId as string}&secretKey=${
      data.seriesSecret as string
    }`;
    let res;
    try {
      res = await fetch(url, {
        method: 'POST',
        body: file,
      }).then(async (r) => await r.json());
    } catch (error) {
      console.warn('cfw error', error);
      res = { error };
    }

    if (res.error) {
      console.warn('cfw error', res.error);

      const mediaErrorModal = () =>
        setAppModal({
          isOpen: true,
          header: 'Whoops',
          message: 'Your media failed to upload. Please reload this page to try again.',
          options: [
            {
              label: 'Ok Reload',
              func: () => {
                window.location.reload();
              },
              buttonProps: {
                variant: 'outline',
              },
            },
            {
              label: 'DEBUG - CANCEL',
              func: async () => {
                await DEBUG_DEL_NFT_ATTEMPT();
                window.location.reload();
              },
              buttonProps: {
                variant: 'outline',
              },
            },
          ],
        });

      if (/Invalid drop/.test(res.error.toString())) {
        return mediaErrorModal();
      }

      if (/drop not claimed/.test(res.error.toString())) {
        return mediaErrorModal();
      }

      if (/media not uploaded/.test(res.error.toString())) {
        // TODO get tx hash from error and store locally, resubmit tx hash to worker
        // TODO worker verifies that it tried to claim and was successful
        return mediaErrorModal();
      }
    }

    await update(NFT_ATTEMPT_KEY, (val) => ({ ...val, seriesClaimed: true, fileUploaded: true }));

    console.log('response from worker', res);
  }

  try {
    const { publicKeys } = await generateKeys({
      numKeys,
      rootEntropy: `${localStorage.getItem(MASTER_KEY) as string}-${dropId as string}`,
      autoMetaNonceStart: 0,
    });

    const { responses, requiredDeposit: requiredDeposit2 } = await createDrop({
      wallet,
      dropId,
      numKeys,
      publicKeys,
      metadata: JSON.stringify({
        dropName: title,
      }),
      fcData: {
        methods: [
          [
            {
              receiverId: 'nft-v2.keypom.' + networkSuffix,
              methodName: 'nft_mint',
              args: '',
              dropIdField: 'mint_id',
              accountIdField: 'receiver_id',
              attachedDeposit: parseNearAmount('0.1')!,
            },
          ],
        ],
      },
      useBalance: !returnTransactions,
      returnTransactions,
    });

    if (returnTransactions) {
      return { requiredDeposit, requiredDeposit2 };
    }

    return { responses };
  } catch (e) {
    // TODO better error here
    console.warn(e);
    return {};
  }
};

const unloadFn = (e) => {
  e.preventDefault();
  e.returnValue = '';
};

export const handleFinishNFTDrop = async (setAppModal) => {
  const data = await getNFTAttempt();
  if (!data?.confirmed) {
    return false;
  }

  window.addEventListener('beforeunload', unloadFn);
  let res;
  try {
    res = await createDropsForNFT(data.dropId, false, data, setAppModal);
  } catch (e) {
    console.warn(e);
  }

  const { responses } = res;
  console.log(responses);
  if (responses?.length > 0) {
    del(NFT_ATTEMPT_KEY);
  }

  window.removeEventListener('beforeunload', unloadFn);

  return data.dropId;
};

'''
'''--- src/features/create-drop/routes/index.ts ---
export * from './CreateNftDropPage';
export * from './CreateTokenDropPage';

'''
'''--- src/features/create-drop/types/types.ts ---
export interface SummaryItem {
  type: 'text' | 'image' | 'number';
  name: string;
  value: string | number;
}

export interface PaymentItem {
  name: string;
  total: number;
  isDiscount?: boolean;
  discountText?: string;
  helperText?: string;
  doNotRender?: boolean;
}

export interface PaymentData {
  costsData: PaymentItem[];
  totalCost: number;
  confirmationText: string;
}

export interface NFTType {
  title: string;
  description: string;
  artwork: string;
}

'''
'''--- src/features/drop-manager/constants/common.ts ---
import { type DropKeyItem } from '@/features/drop-manager/components/DropManager';

export const INITIAL_SAMPLE_DATA: DropKeyItem[] = [
  {
    id: 1,
    link: 'https://example.com',
    slug: 'https://example.com',
    publicKey: '',
    hasClaimed: false,
  },
  {
    id: 2,
    link: 'https://example.com',
    slug: 'https://example.com',
    publicKey: '',
    hasClaimed: false,
  },
];

'''
'''--- src/features/drop-manager/types/types.ts ---
export type TicketClaimStatus = 'Unclaimed' | 'Viewed' | 'Attended' | 'Claimed';

'''
'''--- src/features/drop-manager/utils/getClaimStatus.ts ---
import { type ProtocolReturnedKeyInfo } from 'keypom-js';

import { type TicketClaimStatus } from '../types/types';

export const getClaimStatus = (key: ProtocolReturnedKeyInfo | null): TicketClaimStatus => {
  if (!key) return 'Claimed';
  const { cur_key_use } = key;

  // cur_key_use is not zero indexed
  switch (cur_key_use) {
    case 2:
      return 'Viewed';
    case 3:
      return 'Attended';
    case 1:
    default:
      return 'Unclaimed';
  }
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="../dist/favicon.ico" />
    <link rel="preload" href="../dist/assets/fonts/archia/archia-regular-webfont.woff2" as="font" type="font/woff2" crossorigin="anonymous" />
    <!-- <link rel="preload" href="../dist/assets/fonts/archia/archia-medium-webfont.woff2" as="font" type="font/woff2" crossorigin="anonymous" />
    <link rel="preload" href="../dist/assets/fonts/archia/archia-semibold-webfont.woff2" as="font" type="font/woff2" crossorigin="anonymous" /> -->
    <link rel="preload" href="../dist/assets/fonts/inter/Inter-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous" />
    <!-- <link rel="preload" href="../dist/assets/fonts/inter/Inter-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous" />
    <link rel="preload" href="../dist/assets/fonts/inter/Inter-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous" /> -->
    <link rel="preload" as="image" href="../public/assets/logo_white.webp">
    <link rel="preload" as="image" href="../public/assets/token_banner.webp">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Keypom</title>
    <base href="/" />
  </head>

  <body>
    <noscript>You need to enable JavaScript to run this application 😰</noscript>
    <div id="app"></div>

    <script type="module" src="./index.tsx"></script>
  </body>
</html>

'''
'''--- src/lib/keypom.ts ---
import {
  getDropInformation,
  getEnv,
  initKeypom,
  type ProtocolReturnedDrop,
  updateKeypomContractId,
  getFTMetadata,
  claim,
  getKeyInformation,
  hashPassword,
  getPubFromSecret,
  formatNearAmount,
  formatLinkdropUrl,
  generateKeys,
  getKeyInformationBatch,
  getKeySupplyForDrop,
  deleteKeys,
  getKeysForDrop,
  deleteDrops,
  getDropSupplyForOwner,
  getDrops,
} from 'keypom-js';
import * as nearAPI from 'near-api-js';

import { CLOUDFLARE_IPFS, DROP_TYPE, MASTER_KEY } from '@/constants/common';
import getConfig from '@/config/config';
import { get } from '@/utils/localStorage';

let instance: KeypomJS;
const ACCOUNT_ID_REGEX = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
const networkId = process.env.REACT_APP_NETWORK_ID ?? 'testnet';

const myKeyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
const config = getConfig();

const connectionConfig = {
  networkId,
  keyStore: myKeyStore,
  nodeUrl: config.nodeUrl,
  walletUrl: config.walletUrl,
  helperUrl: config.helperUrl,
  explorerUrl: config.explorerUrl,
};

const CACHE_MAX_AGE = 5000; // in ms
class KeypomJS {
  private static instance: KeypomJS;
  nearConnection: nearAPI.Near;
  test = 0;

  dropStore: {
    dropWithKeys: Record<
      string,
      Record<
        number,
        {
          drop: ProtocolReturnedDrop;
          cacheExpiryTime: number;
          pk?: string[];
          sk?: string[];
        }
      >
    >;
    paginatedMyDrops: Record<number, { drops: ProtocolReturnedDrop[]; cacheExpiryTime: number }>;
  } = {
    dropWithKeys: {}, // this is to cache the keys of each respective drops, mainly used in DropManager.tsx and [id].tsx
    paginatedMyDrops: {}, // this is to cache the drops from My Drops, mainly used in AllDrops.tsx
  };

  constructor() {
    if (instance !== undefined) {
      throw new Error('New instance cannot be created!!');
    }
  }

  init = async () => {
    initKeypom({ network: networkId })
      .then(() => {
        console.log('KeypomJS initialized');
      })
      .catch((err) => {
        console.error('Failed to initialize KeypomJS', err);
      });

    const { connect } = nearAPI;

    this.nearConnection = await connect(connectionConfig);
  };

  public static getInstance(): KeypomJS {
    if (!KeypomJS.instance) {
      KeypomJS.instance = new KeypomJS();
    }

    return KeypomJS.instance;
  }

  validateAccountId = async (accountId: string) => {
    if (!(accountId.length >= 2 && accountId.length <= 64 && ACCOUNT_ID_REGEX.test(accountId))) {
      throw new Error('Account Id is invalid');
    }

    try {
      const account = await this.nearConnection.account(accountId);
      await account.state();
    } catch (err) {
      throw new Error('Account Id does not exist');
    }
    return true;
  };

  verifyDrop = async (contractId: string, secretKey: string) => {
    const { networkId, supportedKeypomContracts } = getEnv();

    if (
      supportedKeypomContracts === undefined ||
      networkId === undefined ||
      contractId === undefined
    ) {
      throw new Error('Please supply supportedKeypomContracts, networkId and contractId');
    }

    if (supportedKeypomContracts[networkId][contractId] === undefined) {
      throw new Error("Linkdrop is invalid and isn't officially supported by Keypom contract.");
    }

    updateKeypomContractId({ keypomContractId: contractId });
  };

  getCurrentKeyUse = async (contractId: string, secretKey: string) => {
    await this.verifyDrop(contractId, secretKey);

    const keyInfo = await getKeyInformation({ secretKey });

    if (keyInfo === null || keyInfo === undefined) {
      throw new Error('Drop has been deleted or has already been claimed');
    }

    return keyInfo.cur_key_use;
  };

  checkIfDropExists = async (secretKey: string) => {
    try {
      await this.getDropInfo({ secretKey });
      return true;
    } catch (err) {
      return false;
    }
  };

  claimTicket = async (secretKey: string, password: string) => {
    let keyInfo = await getKeyInformation({ secretKey });
    const publicKey: string = getPubFromSecret(secretKey);
    const passwordForClaim = await hashPassword(
      password + publicKey + keyInfo.cur_key_use.toString(),
    );

    try {
      await claim({ secretKey, password: passwordForClaim, accountId: 'foo' });
    } catch (e) {
      console.warn(e);
    }

    keyInfo = await getKeyInformation({ secretKey });
    if (keyInfo.remaining_uses === 2) {
      throw new Error('Password is incorrect. Please try again.');
    }
  };

  // valid contract id -> v1-3.keypom.testnet
  // getEnv check for contractid validity
  // updateKeypomContractId
  // getDropInformation
  // check drop type
  /*
    ft -> Tokens
    fc -> Ticket (3 method calls)
    fc -> NFT (1 method call)
    simple -> simple drop?
  */
  getLinkdropType = async (drop: ProtocolReturnedDrop, contractId: string, secretKey: string) => {
    await this.verifyDrop(contractId, secretKey);
    return this.getDropType(drop);
  };

  getDropType = (drop: ProtocolReturnedDrop) => {
    if (drop.fc === undefined && drop.nft === undefined) {
      return DROP_TYPE.TOKEN;
    }

    if (drop.fc !== undefined) {
      if (drop.fc.methods[0]?.length === 2) {
        return DROP_TYPE.TRIAL;
      }

      if (drop.fc.methods.length === 3) {
        return DROP_TYPE.TICKET;
      }

      if (
        drop.fc.methods.length === 1 &&
        drop.fc.methods[0] !== undefined &&
        drop.fc.methods[0][0].method_name === 'nft_mint'
      ) {
        return DROP_TYPE.NFT;
      }
    }

    return DROP_TYPE.OTHER;
  };

  getDrops = async ({
    accountId,
    start,
    limit,
    withKeys,
  }: {
    accountId: string;
    start: number;
    limit: number;
    withKeys: boolean;
  }) => {
    /** Get Drops caching logic */
    if (
      !Object.prototype.hasOwnProperty.call(this.dropStore.paginatedMyDrops, start) ||
      Date.now() > this.dropStore.paginatedMyDrops[start].cacheExpiryTime
    ) {
      const newDropsCacheExpiryTime = new Date(Date.now() + CACHE_MAX_AGE).getTime();

      this.dropStore.paginatedMyDrops[start] = {
        drops: await getDrops({ accountId, start, limit, withKeys }),
        cacheExpiryTime: newDropsCacheExpiryTime,
      };
    }

    return this.dropStore.paginatedMyDrops[start].drops;
  };

  getDropSupplyForOwner = async ({ accountId }) => await getDropSupplyForOwner({ accountId });

  getDropMetadata = (metadata: string | undefined) => {
    const parsedObj = JSON.parse(metadata || '{}');
    if (!Object.hasOwn(parsedObj, 'dropName')) {
      parsedObj.dropName = 'Untitled';
    }
    return parsedObj;
  };

  deleteDrops = async ({ wallet, dropIds }) => await deleteDrops({ wallet, dropIds });

  deleteKeys = async ({ wallet, dropId, publicKeys }) =>
    await deleteKeys({ wallet, dropId, publicKeys });

  getDropInfo = async ({
    dropId,
    secretKey,
  }: {
    dropId?: string;
    secretKey?: string;
  }): Promise<ProtocolReturnedDrop> => {
    let drop: ProtocolReturnedDrop;

    if (!dropId && !secretKey) {
      throw new Error('dropId or secretKey must be provided.');
    }

    try {
      drop = await getDropInformation({ dropId, secretKey });
    } catch (err) {
      throw new Error('Unable to claim. This drop may have been claimed before.');
    }

    return drop;
  };

  getAvailableKeys = async (dropId: string) => await getKeySupplyForDrop({ dropId });

  getKeysForDrop = async ({ dropId, limit, start }) =>
    await getKeysForDrop({ dropId, limit, start });

  getLinksToExport = async (dropId) => {
    const drop = await this.getDropInfo({ dropId });
    const { secretKeys } = await generateKeys({
      numKeys: drop.next_key_id,
      rootEntropy: `${get(MASTER_KEY) as string}-${dropId as string}`,
      autoMetaNonceStart: 0,
    });

    const links = secretKeys.map(
      (key, i) =>
        `${window.location.origin}/claim/${getConfig().contractId}#${key.replace('ed25519:', '')}`,
    );

    return links;
  };

  getKeysInfo = async (
    dropId: string,
    pageIndex: number,
    pageSize: number,
    getDropErrorCallback?: () => void,
  ) => {
    try {
      /** Get PaginatedDrops caching logic */
      if (
        !Object.prototype.hasOwnProperty.call(this.dropStore.dropWithKeys, dropId) ||
        !Object.prototype.hasOwnProperty.call(this.dropStore.dropWithKeys[dropId], pageIndex) ||
        Date.now() > this.dropStore.dropWithKeys[dropId][pageIndex].cacheExpiryTime
      ) {
        if (this.dropStore.dropWithKeys[dropId] === undefined)
          this.dropStore.dropWithKeys[dropId] = {};
        const newPaginatedDropsCacheExpiryTime = new Date(Date.now() + CACHE_MAX_AGE).getTime();

        this.dropStore.dropWithKeys[dropId][pageIndex] = {
          drop: await this.getDropInfo({ dropId }),
          cacheExpiryTime: newPaginatedDropsCacheExpiryTime,
          pk: undefined,
          sk: undefined,
        };
      }

      const dropSize = this.dropStore.dropWithKeys[dropId][pageIndex].drop.next_key_id;
      const { dropName } = this.getDropMetadata(
        this.dropStore.dropWithKeys[dropId][pageIndex].drop.metadata,
      );

      // Get PaginatedDrops PK SK caching logic
      if (
        this.dropStore.dropWithKeys[dropId][pageIndex].pk === undefined ||
        this.dropStore.dropWithKeys[dropId][pageIndex].sk === undefined
      ) {
        const { publicKeys, secretKeys } = await generateKeys({
          numKeys:
            (pageIndex + 1) * pageSize > dropSize
              ? dropSize - pageIndex * pageSize
              : Math.min(dropSize, pageSize),
          rootEntropy: `${get(MASTER_KEY) as string}-${dropId}`,
          autoMetaNonceStart: pageIndex * pageSize,
        });

        this.dropStore.dropWithKeys[dropId][pageIndex].pk = publicKeys;
        this.dropStore.dropWithKeys[dropId][pageIndex].sk = secretKeys;
      }

      const keyInfo = await getKeyInformationBatch({
        publicKeys: this.dropStore.dropWithKeys[dropId][pageIndex].pk,
        secretKeys: this.dropStore.dropWithKeys[dropId][pageIndex].sk,
      });

      return {
        dropSize,
        dropName,
        publicKeys: this.dropStore.dropWithKeys[dropId][pageIndex].pk,
        secretKeys: this.dropStore.dropWithKeys[dropId][pageIndex].sk,
        keyInfo,
      };
    } catch (e) {
      if (getDropErrorCallback) getDropErrorCallback();
      return; // eslint-disable-line no-useless-return
    }
  };

  generateExternalWalletLink = async (
    walletName: string,
    contractId: string,
    secretKey: string,
  ) => {
    // verify the drop first
    try {
      await this.getDropInfo({ secretKey });
    } catch (err) {
      console.error(err);
      throw new Error('This drop has been claimed.');
    }

    // generate the link to navigate to
    const urls = formatLinkdropUrl({
      claimPage: walletName,
      contractId,
      secretKeys: [secretKey],
    });

    return urls[0];
  };

  getTokenClaimInformation = async (contractId: string, secretKey: string) => {
    const drop = await this.getDropInfo({ secretKey });

    // verify if secretKey is a token drop
    const linkdropType = await this.getLinkdropType(drop, contractId, secretKey);
    if (linkdropType && !DROP_TYPE[linkdropType]) {
      throw new Error('This drop is not supported. Please contact the sender of this link.');
    }

    const dropMetadata = this.getDropMetadata(drop.metadata);
    let ftMetadata;
    if (drop.ft !== undefined) {
      ftMetadata = await getFTMetadata({ contractId: drop.ft.contract_id });
    }

    return {
      dropName: dropMetadata.dropName,
      wallets: dropMetadata.wallets,
      redirectUrl: dropMetadata.redirectUrl,
      ftMetadata,
      amountTokens: drop.ft?.balance_per_use, // TODO: format correctly with FT metadata
      amountNEAR: formatNearAmount(drop.deposit_per_use, 4),
    };
  };

  getNFTorTokensMetadata = async (
    fcMethod: { receiver_id: string },
    dropId: string,
    secretKey?: string,
    contractId?: string,
  ) => {
    let nftData;
    let tokensData;

    const { receiver_id: receiverId } = fcMethod;
    const { viewCall } = getEnv();

    try {
      nftData = await viewCall({
        contractId: receiverId,
        methodName: 'get_series_info',
        args: { mint_id: parseFloat(dropId) },
      });
    } catch (err) {
      console.error('NFT series not found');
      // throw new Error('NFT series not found');
    }

    // show tokens if NFT series not found
    if (nftData === undefined && contractId && secretKey) {
      tokensData = await this.getTokenClaimInformation(contractId, secretKey);
    }

    return {
      nftData,
      tokensData,
    };
  };

  getNFTClaimInformation = async (contractId: string, secretKey: string) => {
    // given fc
    const drop = await this.getDropInfo({ secretKey });

    // verify if secretKey is a nft drop
    const linkdropType = await this.getLinkdropType(drop, contractId, secretKey);
    if (linkdropType !== DROP_TYPE.NFT) {
      throw new Error('This drop is not an NFT drop. Please contact your drop creator.');
    }

    const dropMetadata = this.getDropMetadata(drop.metadata);

    const fcMethods = drop.fc?.methods;
    if (
      fcMethods === undefined ||
      fcMethods.length === 0 ||
      fcMethods[0] === undefined ||
      fcMethods[0][0] === undefined
    ) {
      throw new Error('Unable to retrieve function calls.');
    }

    const { nftData, tokensData } = await this.getNFTorTokensMetadata(
      fcMethods[0][0],
      drop.drop_id,
      secretKey,
      contractId,
    );

    return {
      type: nftData ? DROP_TYPE.NFT : DROP_TYPE.TOKEN,
      dropName: dropMetadata.dropName,
      wallets: dropMetadata.wallets,
      redirectUrl: dropMetadata.redirectUrl,
      ...(nftData
        ? {
            media: `${CLOUDFLARE_IPFS}/${nftData.metadata.media}`, // eslint-disable-line
            title: nftData.metadata.title,
            description: nftData.metadata.description,
          }
        : {}),
      ...(tokensData || {}),
    };
  };

  getTicketNftInformation = async (contractId: string, secretKey: string) => {
    const drop = await this.getDropInfo({ secretKey });

    // verify if secretKey is a ticket drop
    const linkdropType = await this.getLinkdropType(drop, contractId, secretKey);
    if (linkdropType !== DROP_TYPE.TICKET) {
      throw new Error('This drop is not a Ticket drop. Please contact your drop creator.');
    }

    const dropMetadata = this.getDropMetadata(drop.metadata);

    const fcMethods = drop.fc?.methods;
    if (
      fcMethods === undefined ||
      fcMethods.length < 3 ||
      fcMethods[2] === undefined ||
      fcMethods[2][0] === undefined
    ) {
      throw new Error('Unable to retrieve function calls.');
    }

    const fcMethod = fcMethods[2][0];

    const { nftData, tokensData } = await this.getNFTorTokensMetadata(
      fcMethod,
      drop.drop_id,
      secretKey,
      contractId,
    );

    return {
      type: nftData ? DROP_TYPE.NFT : DROP_TYPE.TOKEN,
      dropName: dropMetadata.dropName,
      wallets: dropMetadata.wallets,
      redirectUrl: dropMetadata.redirectUrl,
      ...(nftData
        ? {
            media: `${CLOUDFLARE_IPFS}/${nftData.metadata.media}`, // eslint-disable-line
            title: nftData.metadata.title,
            description: nftData.metadata.description,
          }
        : {}),
      ...(tokensData || {}),
    };
  };

  claim = async (secretKey: string, walletAddress: string, skipValidation = false) => {
    if (!skipValidation) {
      await this.validateAccountId(walletAddress);
    }
    await claim({ secretKey, accountId: walletAddress });
  };
}

const keypomInstance = KeypomJS.getInstance();

export default keypomInstance;

'''
'''--- src/lib/walletSelector.ts ---
import {
  type AccountState,
  type NetworkId,
  setupWalletSelector,
  type WalletSelector,
} from '@near-wallet-selector/core';
import { setupModal, type WalletSelectorModal } from '@near-wallet-selector/modal-ui';
import { setupNearWallet } from '@near-wallet-selector/near-wallet';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';

const NETWORK_ID = process.env.REACT_APP_NETWORK_ID ?? 'testnet';
const CONTRACT_ID = process.env.REACT_APP_CONTRACT_ID ?? 'v2.keypom.testnet';

export class NearWalletSelector {
  public accounts: AccountState[];
  public selector: WalletSelector;
  public modal: WalletSelectorModal;

  async init(): Promise<void> {
    const _selector = await setupWalletSelector({
      network: NETWORK_ID as NetworkId,
      debug: true,
      modules: [setupNearWallet(), setupMyNearWallet()],
    });
    const _modal = setupModal(_selector, { contractId: CONTRACT_ID, theme: 'light' });
    const state = _selector.store.getState();

    this.accounts = state.accounts;
    this.modal = _modal;
    this.selector = _selector;
  }
}

'''
'''--- src/theme/colors.ts ---
import { type RecursiveObject } from '@chakra-ui/react';

export const colors: RecursiveObject<string> = {
  border: {
    box: 'linear-gradient(white, white) padding-box, linear-gradient(0deg, rgba(255,207,234,1) 0%, rgba(182,232,247,1) 100%) border-box',
    round:
      'linear-gradient(0deg, #B6E8F7, #B6E8F7), linear-gradient(344.12deg, #EFFAFD 10.78%, #DDF4FA 88.63%)',
    landing: {
      800: 'linear-gradient(#1e293b, #1e293b) padding-box, linear-gradient(0deg, #FFA9DC 0%, #73D6F3 100%) border-box',

      900: 'linear-gradient(#0f172a, #0f172a) padding-box, linear-gradient(0deg, #FFA9DC 0%, #73D6F3 100%) border-box',
    },
  },
  brand: {
    100: '#f7fafc',
    900: '#1a202c',
  },
  white: '#ffffff',
  bg: '#ffffff',
  gray: {
    '50': '#f8fafc',
    '100': '#f1f5f9',
    '200': '#e2e8f0',
    '300': '#cbd5e1',
    '400': '#94a3b8',
    '500': '#64748b',
    '600': '#475569',
    '700': '#334155',
    '800': '#1e293b',
    '900': '#0f172a',
  },
  blue: {
    '50': '#effafd',
    '100': '#ddf4fa',
    '200': '#b6e8f7',
    '300': '#73d6f3',
    '400': '#30c9f3',
    '500': '#00a7e4',
    '600': '#0185c3',
    '700': '#096a9e',
    '800': '#0d5986',
    '900': '#0e4a6e',
  },
  pink: {
    '50': '#fff4fa',
    '100': '#ffe8f4',
    '200': '#ffcfea',
    '300': '#ffa9dc',
    '400': '#f670c5',
    '500': '#f338ba',
    '600': '#d824a2',
    '700': '#b21a85',
    '800': '#961470',
    '900': '#7f115e',
  },
  green: {
    '50': '#f0fdf4',
    '100': '#dcfce7',
    '200': '#bbf7d0',
    '300': '#86efac',
    '400': '#4ade80',
    '500': '#22c55e',
    '600': '#16a34a',
    '700': '#15803d',
    '800': '#166534',
    '900': '#14532d',
  },
  red: {
    '50': '#fef2f2',
    '100': '#fee2e2',
    '200': '#fecaca',
    '300': '#fca5a5',
    '400': '#f87171',
    '500': '#ef4444',
    '600': '#dc2626',
    '700': '#b91c1c',
    '800': '#991b1b',
    '900': '#7f1d1d',
  },
};

'''
'''--- src/theme/components/BadgeTheme.ts ---
import { defineStyleConfig } from '@chakra-ui/react';

export const BadgeTheme = defineStyleConfig({
  baseStyle: {
    textTransform: 'initial',
    py: '1.5',
    px: '3',
  },
  sizes: {
    sm: {
      fontSize: 'xs',
    },
    md: {
      fontSize: 'sm',
    },
  },
  variants: {
    lightgreen: {
      color: 'green.600',
      bgColor: 'green.50',
      fontWeight: 'medium',
    },
    blue: {
      color: 'blue.600',
      bgColor: 'blue.50',
      fontWeight: 'medium',
    },
    pink: {
      color: 'pink.600',
      bgColor: 'pink.50',
      fontWeight: 'medium',
    },
    gray: {
      color: 'gray.600',
      bgColor: 'gray.50',
      fontWeight: 'medium',
    },
  },
  defaultProps: {
    size: 'md',
  },
});

'''
'''--- src/theme/components/ButtonTheme.ts ---
import { defineStyleConfig } from '@chakra-ui/react';

export const ButtonTheme = defineStyleConfig({
  baseStyle: {
    borderRadius: '6xl',
    fontWeight: 'medium',
  },
  sizes: {
    sm: {
      fontSize: 'sm',
      py: '3',
      px: '4',
    },
    md: {
      fontSize: 'md',
      py: '4',
      px: '6',
    },
  },
  variants: {
    primary: {
      border: '2px solid transparent',
      color: 'white',
      bgColor: 'gray.800',
      _hover: {
        bgColor: 'gray.900',
        _disabled: {
          bgColor: 'gray.900',
        },
      },
      _focus: {
        bgColor: 'gray.900',
        border: '2px solid',
        borderColor: 'blue.400',
      },
    },
    landing: {
      border: '2px solid transparent',
      color: 'white',
      bg: 'border.landing.800',
      _hover: {
        bgColor: 'border.landing.900',
        _disabled: {
          bgColor: 'border.landing.900',
        },
      },
      _focus: {
        bgColor: 'border.landing.900',
        border: '2px solid',
        borderColor: 'blue.400',
      },
      _disabled: {
        pointerEvents: 'none',
      },
    },
    secondary: {
      border: '2px solid',
      borderColor: 'gray.200',
      color: 'gray.800',
      bgColor: 'white',
      _hover: {
        bgColor: 'gray.200',
      },
      _focus: {
        bgColor: 'gray.200',
        border: '2px solid',
        borderColor: 'blue.400',
      },
    },
    'secondary-content-box': {
      boxSizing: 'content-box',
      h: 'calc(40px - 24px)',
      border: '2px solid',
      borderColor: 'gray.200',
      color: 'gray.800',
      bgColor: 'white',
      _hover: {
        bgColor: 'gray.200',
      },
      _focus: {
        bgColor: 'gray.200',
        border: '2px solid',
        borderColor: 'blue.400',
      },
    },
    icon: {
      border: '2px solid',
      borderColor: 'gray.200',
      color: 'gray.800',
      bgColor: 'white',
      borderRadius: '100%',
      px: '8px',
      _hover: {
        bgColor: 'gray.200',
      },
      _focus: {
        bgColor: 'gray.200',
        border: '2px solid',
        borderColor: 'blue.400',
      },
    },
    pill: {
      borderRadius: '52px',
      bg: 'border.box',
      border: '1px solid transparent',
    },
  },
  defaultProps: {
    variant: 'primary',
    size: 'md',
  },
});

'''
'''--- src/theme/components/CheckboxTheme.ts ---
import { defineStyleConfig } from '@chakra-ui/react';

export const CheckboxTheme = defineStyleConfig({
  baseStyle: {
    border: '1px solid',
    borderColor: 'gray.100',

    _checked: {
      bgColor: 'red',
    },
  },
});

'''
'''--- src/theme/components/HeadingTheme.ts ---
import { defineStyleConfig } from '@chakra-ui/react';

export const HeadingTheme = defineStyleConfig({
  baseStyle: {
    fontWeight: 'medium',
  },
  sizes: {
    md: {
      fontSize: { base: '2xl', md: '4xl' },
    },
  },
  defaultProps: {
    size: 'md',
  },
});

'''
'''--- src/theme/components/InputTheme.ts ---
import { inputAnatomy as parts } from '@chakra-ui/anatomy';
import { createMultiStyleConfigHelpers } from '@chakra-ui/react';

// This function creates a set of function that helps us create multipart component styles.
const helpers = createMultiStyleConfigHelpers(parts.keys);

export const InputTheme = helpers.defineMultiStyleConfig({
  sizes: {
    md: {
      field: {
        borderRadius: '6xl',
        h: '12',
      },
    },
  },
  variants: {
    outline: {
      field: {
        _invalid: {
          borderColor: 'red.300',
        },
      },
    },
  },
});

'''
'''--- src/theme/components/MenuTheme.ts ---
import { menuAnatomy as parts } from '@chakra-ui/anatomy';
import { createMultiStyleConfigHelpers } from '@chakra-ui/react';

// This function creates a set of function that helps us create multipart component styles.
const helpers = createMultiStyleConfigHelpers(parts.keys);

export const MenuTheme = helpers.defineMultiStyleConfig({
  baseStyle: {
    item: {
      fontWeight: 'medium',
      lineHeight: 'normal',
      color: 'gray.600',
      borderBottom: '1px solid',
      borderBottomColor: 'gray.100',
      _first: {
        borderTopRadius: '6xl',
      },
      _last: {
        borderBottom: 'none',
        borderBottomRadius: '6xl',
      },
      _hover: {
        color: 'gray.800',
        bgColor: 'gray.100',
      },
    },
    list: {
      p: '0',
      borderRadius: '6xl',
      minW: '177px',
    },
  },
  sizes: {
    md: {
      item: {
        fontSize: 'md',
        px: '6',
        py: '3',
      },
    },
  },
  variants: {},
  defaultProps: {
    size: 'md',
  },
});

'''
'''--- src/theme/components/ModalTheme/index.ts ---
export * from './ModalTheme';

'''
'''--- src/theme/components/TableTheme.ts ---
import { tableAnatomy as parts } from '@chakra-ui/anatomy';
import { createMultiStyleConfigHelpers } from '@chakra-ui/react';

// This function creates a set of function that helps us create multipart component styles.
const helpers = createMultiStyleConfigHelpers(parts.keys);

export const TableTheme = helpers.defineMultiStyleConfig({
  baseStyle: {
    table: {
      bg: 'border.box',
      border: '2px solid white',
      borderRadius: '8xl',
      borderCollapse: 'collapse',
      borderSpacing: 0,
      overflow: 'hidden',
    },
    th: {
      textTransform: 'capitalize',
      _first: {
        borderTopLeftRadius: '26px',
      },
      _last: {
        borderTopRightRadius: '26px',
      },
    },
    td: {
      pl: '4',
    },
    tr: {
      borderBottom: '1px solid',
      borderBottomColor: 'gray.100',
      borderStyle: 'solid',
    },
  },
  sizes: {
    sm: {
      tr: {
        borderBottom: '2px solid',
        borderBottomColor: 'gray.100',
      },
    },
    md: {
      td: {
        fontSize: 'md',
        py: { base: '6', md: '9' },
        px: { base: '5', md: '8' },
      },
      th: {
        fontSize: 'md',
        py: '5',
        pl: '8',
      },
    },
  },
  variants: {
    primary: {
      th: {
        bg: 'gray.100',
        color: 'gray.600',
        fontWeight: 'medium',
        overflow: 'hidden',
      },
    },
    secondary: {
      th: {
        bg: 'inherit',
        color: 'gray.800',
        fontWeight: 'semibold',
        overflow: 'hidden',
        height: '88px',
      },
    },
  },
  defaultProps: {
    variant: 'primary',
  },
});

'''
'''--- src/theme/components/TextTheme.ts ---
import { defineStyleConfig } from '@chakra-ui/react';

export const TextTheme = defineStyleConfig({
  baseStyle: {
    fontWeight: 'normal',
    color: 'gray.600',
  },
  sizes: {
    xs: {
      fontSize: 'xs',
      lineHeight: '16px',
    },
    sm: {
      fontSize: 'sm',
      lineHeight: '20px',
    },
    md: {
      fontSize: { base: 'sm', md: 'base' },
      lineHeight: '24px',
    },
    lg: {
      fontSize: 'lg',
      lineHeight: '28px',
    },
    xl: {
      fontSize: 'xl',
      lineHeight: '28px',
    },
    '2xl': {
      fontSize: '2xl',
      lineHeight: '32px',
    },
    '3xl': {
      fontSize: '3xl',
      lineHeight: '36px',
    },
    '4xl': {
      fontSize: '4xl',
      lineHeight: '43px',
    },
    '5xl': {
      fontSize: '5xl',
      lineHeight: '58px',
    },
    '6xl': {
      fontSize: '6xl',
      lineHeight: '72px',
    },
    '7xl': {
      fontSize: '7xl',
      lineHeight: '86px',
    },
    '8xl': {
      fontSize: '8xl',
      lineHeight: '115px',
    },
  },
  variants: {
    error: {
      color: 'red.600',
    },
  },
  defaultProps: {
    size: 'md',
  },
});

'''
'''--- src/theme/components/index.ts ---
export * from './BadgeTheme';
export * from './ButtonTheme';
export * from './CheckboxTheme';
export * from './HeadingTheme';
export * from './InputTheme';
export * from './MenuTheme';
export * from './ModalTheme';
export * from './TableTheme';
export * from './TextTheme';

'''
'''--- src/theme/config.ts ---
import { type ThemeConfig } from '@chakra-ui/react';

export const config: ThemeConfig = {
  initialColorMode: 'light',
  useSystemColorMode: false,
};

'''
'''--- src/theme/fontSizes.ts ---
import { type RecursiveObject } from '@chakra-ui/react';

export const fontSizes: RecursiveObject<string> = {
  xs: '0.75rem',
  sm: '0.875rem',
  base: '1rem',
  lg: '1.125rem',
  xl: '1.25rem',
  '2xl': '1.5rem',
  '3xl': '1.875rem',
  '4xl': '2.25rem',
  '5xl': '3rem',
  '6xl': '3.75rem',
  '7xl': '4.5rem',
  '8xl': '6rem',
};

'''
'''--- src/theme/fonts.ts ---
import { type RecursiveObject } from '@chakra-ui/react';

export const fonts: RecursiveObject<string> = {
  heading: 'Archia, sans-serif',
  body: 'Inter, sans-serif',
};

'''
'''--- src/theme/index.ts ---
export * from './theme';

'''
'''--- src/theme/sizes.ts ---
import { type RecursiveObject } from '@chakra-ui/react';

export const radii: RecursiveObject<string> = {
  none: '0',
  xs: '0.03125rem',
  sm: '0.0625rem',
  base: '0.125rem',
  lg: '0.1875rem',
  xl: '0.25rem',
  '2xl': '0.3125rem',
  '3xl': '0.375rem',
  '4xl': '0.4375rem',
  '5xl': '0.5rem',
  '6xl': '0.75rem',
  '7xl': '0.8125rem',
  '8xl': '1.5rem',
  '9xl': '1.875rem',
  '10xl': '2.875rem',
  full: '9999px',
};

'''
'''--- src/theme/theme.ts ---
import { extendTheme } from '@chakra-ui/react';

import {
  ModalTheme,
  ButtonTheme,
  TableTheme,
  MenuTheme,
  BadgeTheme,
  InputTheme,
  TextTheme,
  CheckboxTheme,
  HeadingTheme,
} from './components';
import { fontSizes } from './fontSizes';
import { fonts } from './fonts';
import { colors } from './colors';
import { config } from './config';
import { radii } from './sizes';

export const theme = extendTheme({
  components: {
    Modal: ModalTheme,
    Button: ButtonTheme,
    Table: TableTheme,
    Menu: MenuTheme,
    Badge: BadgeTheme,
    Input: InputTheme,
    Checkbox: CheckboxTheme,
    Text: TextTheme,
    Heading: HeadingTheme,
  },
  colors,
  config,
  fontSizes,
  fonts,
  radii,
});

'''
'''--- src/types/common.ts ---
import type React from 'react';

export interface IFlowPage {
  name: string;
  description: string;
  component: React.ReactNode; // forms, summary. etc
}

export interface ApiResponse<T> {
  data?: T;
  error?: string;
}

export interface IWalletOption {
  name: string;
  title: string;
}

export interface IToken {
  amount: string;
  symbol: string;
}

export interface TokenAsset {
  icon: string;
  value: string;
  symbol: string;
}

'''
'''--- src/utils/claimedDrops.ts ---
import { get, set } from './localStorage';

const CLAIMED_DROPS_KEY = 'claimed_drop_keys';

// check if local storage if drop has been claimed before
export const checkClaimedDrop = (secretKey: string) => {
  const claimedDropItem: string[] = get(CLAIMED_DROPS_KEY);

  if (claimedDropItem === undefined) {
    return false;
  }

  if (claimedDropItem.includes(secretKey)) {
    return true;
  }

  return false;
};

// store in local storage after claim is done
export const storeClaimDrop = (secretKey: string) => {
  const claimedDropItem: string[] = get(CLAIMED_DROPS_KEY);

  if (claimedDropItem === undefined) {
    set(CLAIMED_DROPS_KEY, [secretKey]);
    return;
  }

  set(CLAIMED_DROPS_KEY, [...claimedDropItem, secretKey]);
};

'''
'''--- src/utils/file.ts ---
export const file = (fn, data) => {
  // Dynamically create a File
  const file = new File([data], fn);
  // Create a link and set the URL using `createObjectURL`
  const link = document.createElement('a');
  link.style.display = 'none';
  link.href = URL.createObjectURL(file);
  link.download = file.name;

  // It needs to be added to the DOM so it can be clicked
  document.body.appendChild(link);
  link.click();

  // To make this work on Firefox we need to wait
  // a little while before removing it.
  setTimeout(() => {
    URL.revokeObjectURL(link.href);
    link.parentNode.removeChild(link);
  }, 0);
};

'''
'''--- src/utils/formatAmount.ts ---
export const formatAmount = (number: number, options?: Intl.NumberFormatOptions): string =>
  new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    maximumFractionDigits: 2,
    minimumFractionDigits: 0,
    ...options,
  }).format(number);

'''
'''--- src/utils/localStorage.ts ---
export const get = (key: string) => {
  const value = localStorage.getItem(key);
  if (value !== null) {
    if (!/\{|\[/.test(value?.charAt(0))) {
      return value;
    }
    try {
      return JSON.parse(value);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn(e);
    }
  }
};
export const set = (key: string, value: unknown) => {
  localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
};
export const del = (key: string) => {
  localStorage.removeItem(key);
};

'''
'''--- src/utils/replaceSpace.ts ---
export const replaceSpace = (text: string, replaceStr = '_'): string =>
  text.replace(/\s/g, replaceStr);

'''
'''--- src/utils/share.ts ---
import copy from 'copy-to-clipboard';

export const share = (text) => {
  console.log(navigator);
  if (navigator.share && /mobile/gi.test(window.navigator.userAgent)) {
    navigator
      .share({
        text,
      })
      .catch((e) => {
        copy(text);
        return { mobile: true, error: true };
      });
    return { mobile: true };
  } else {
    copy(text);
    return { mobile: false };
  }
};

'''
'''--- src/utils/truncateAddress.ts ---
type Placement = 'start' | 'middle' | 'end';

export const truncateAddress = (
  address: string,
  placement: Placement = 'middle',
  maxLength = 24,
) => {
  if (!address) return '';
  if (address.length > maxLength) {
    switch (placement) {
      case 'start':
        return '...' + address.slice(-maxLength);
      case 'middle':
        return address.slice(0, maxLength - 6) + '...' + address.slice(-6);
      case 'end':
      default:
        return address.slice(0, maxLength) + '...';
    }
  }

  return address;
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "module": "esnext",
    "target": "es5",
    "lib": [
      "es6",
      "dom",
      "es2017",
      "es2022",
    ],
    "sourceMap": true,
    "allowJs": true,
    "jsx": "react-jsx",
    "moduleResolution": "node",
    "rootDir": "src",
    "forceConsistentCasingInFileNames": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "noUnusedLocals": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "skipLibCheck": true,
    "baseUrl": "./",
    "outDir": "dist",
    "paths": {
      "@/*": [
        "src/*"
      ],
      "~/*": [
        "public/*"
      ]
    }
  },
  "include": [
    "./src/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}
'''
'''--- tslint.json ---
{
  "extends": ["tslint:recommended", "tslint-react", "tslint-config-prettier"],
  "rules": {
    "interface-name": [false],
    "object-literal-sort-keys": false,
    "ordered-imports": false
  }
}

'''