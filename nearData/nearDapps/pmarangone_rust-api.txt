*GitHub Repository "pmarangone/rust-api"*

'''--- Cargo.toml ---
[package]
name = "http"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rocket = { version =  "0.5.0-rc.2", features = ["json"] } 
reqwest = { version = "0.11.10", features = ["json"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.66"
env_logger = "0.9.0"
futures = "0.3"

near-jsonrpc-client = { version = "0.3.0", features = ["any"] }
near-jsonrpc-primitives = "0.12.0"
near-primitives = "0.12.0"

redis = { version = "0.21.5", features = ["tls"] }
derive-redis-json = "0.1.1"

mongodb = "2.2.0"

'''
'''--- README.md ---

# Indexer

# API

## Export (more information about redis [here](https://github.com/redis-developer/rust-redis-101)):

`export REDIS_HOSTNAME=localhost:6379`

'''
'''--- src/consts.rs ---
pub enum Contracts {
    RefExchange,
    RefFarm,
}

impl Contracts {
    pub fn value(&self) -> &str {
        match *self {
            Contracts::RefExchange => "ref-finance-101.testnet",
            Contracts::RefFarm => "v2.ref-farming.testnet",
        }
    }
}

// https://stackoverflow.com/a/36928678
pub enum Methods {
    NumPools,
    GetPools,
    ListSeeds,
    ListFarmsBySeeds,
    WhitelistedTokens,
    FtMetadata,
}

impl Methods {
    pub fn value(&self) -> String {
        match *self {
            // Exchange Contract
            Methods::NumPools => String::from("get_number_of_pools"), // ex
            Methods::GetPools => String::from("get_pools"),
            Methods::WhitelistedTokens => String::from("get_whitelisted_tokens"),

            // Farm Contract
            Methods::ListSeeds => String::from("list_seeds"),
            Methods::ListFarmsBySeeds => String::from("list_farms_by_seed"),

            // Token Contract
            Methods::FtMetadata => String::from("ft_metadata"),
        }
    }
}

'''
'''--- src/main.rs ---
#[macro_use]
extern crate rocket;

use std::collections::BTreeMap;
use std::collections::HashMap;

use near_jsonrpc_client::methods::query::RpcQueryResponse;
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{BlockReference, Finality, FunctionArgs};
use near_primitives::views::QueryRequest;

use derive_redis_json::RedisJsonValue;
use rocket::serde::json::{json, Json};
use serde::{Deserialize, Serialize};
use serde_json::from_slice;

mod consts;
mod models;
mod mongo_impl;
mod redis_impl;
mod routes;
mod utils;

use consts::*;
use models::*;
use mongo_impl::*;
use redis_impl::*;
use utils::*;

async fn get_seeds() -> Result<HashMap<String, String>, Box<dyn std::error::Error>> {
    let args = FunctionArgs::from(
        json!({
            "from_index": 0u64,
            "limit": 100u64
        })
        .to_string()
        .into_bytes(),
    );

    let response = call_view(Contracts::RefFarm.value(), Methods::ListSeeds.value(), args).await?;

    let mut seeds: HashMap<String, String> = HashMap::new();

    if let QueryResponseKind::CallResult(result) = response.kind {
        seeds = from_slice::<HashMap<String, String>>(&result.result)?;
    }

    Ok(seeds)
}

async fn get_farms() -> Result<Vec<FarmInfo>, Box<dyn std::error::Error>> {
    let seeds = get_seeds().await.unwrap_or_default();

    if seeds.is_empty() {
        println!("ERR_FETCHING_SEEDS");
        return Ok(vec![]);
    }

    let mut farms: Vec<FarmInfo> = Vec::new();

    for (key, _) in &seeds {
        let args = FunctionArgs::from(
            json!({
                "seed_id": key,
            })
            .to_string()
            .into_bytes(),
        );

        let response = call_view(
            Contracts::RefFarm.value(),
            Methods::ListFarmsBySeeds.value(),
            args,
        )
        .await?;

        if let QueryResponseKind::CallResult(result) = response.kind {
            let res: Vec<FarmInfo> = from_slice::<Vec<FarmInfo>>(&result.result)?;
            farms.extend(res);
        }
    }

    if farms.is_empty() {
        println!("ERR_FETCHING_FARMS");
    }

    Ok(farms)
}

async fn get_pools() -> Result<Vec<PoolInfo>, Box<dyn std::error::Error>> {
    let mut pools: Vec<PoolInfo> = Vec::new();
    let token_metadata: BTreeMap<String, FungibleTokenMetadata> =
        get_whitelisted_tokens().await.unwrap_or_default();
    let seeds = internal_farm_seeds().await.unwrap_or_default();

    if seeds.is_empty() {
        println!("ERR_FETCHING_SEEDS");
    }

    let method_name = Methods::NumPools.value();

    let args = FunctionArgs::from(json!({}).to_string().into_bytes());
    let response = call_view(Contracts::RefExchange.value(), method_name, args).await?;

    let mut num_pools: u64 = 0;
    if let QueryResponseKind::CallResult(result) = response.kind {
        num_pools = from_slice::<u64>(&result.result)?;
    }

    let mut base_index = 0;
    while base_index < num_pools {
        let args = FunctionArgs::from(
            json!({
                "from_index": base_index,
                "limit": 200u64
            })
            .to_string()
            .into_bytes(),
        );

        let response = call_view(
            Contracts::RefExchange.value(),
            Methods::GetPools.value(),
            args,
        )
        .await?;

        if let QueryResponseKind::CallResult(result) = response.kind {
            let mut batch_pools = from_slice::<Vec<PoolInfo>>(&result.result)?;
            base_index += batch_pools.len() as u64;

            pools.append(&mut batch_pools);
        }
    }

    for (idx, pool) in pools.iter_mut().enumerate() {
        pool.id = Some(idx as u64);

        let lpt_id: String = format!("{}@{}", Contracts::RefExchange.value(), idx);
        if seeds.contains(&lpt_id) {
            pool.farming = Some(true);
        } else {
            pool.farming = Some(false);
        }

        let mut symbols: Vec<String> = Vec::new();

        for token in pool.token_account_ids.iter() {
            if token_metadata.contains_key(token) {
                let metadata = token_metadata.get(token).unwrap();
                let symbol: String = metadata.symbol.clone();
                symbols.push(symbol);
            } else {
                let vec = &vec![token.clone()];
                let metadata = internal_update_token_metadata(vec)
                    .await
                    .unwrap_or_default();

                if !metadata.is_empty() {
                    let symbol = metadata.get(token).unwrap().symbol.clone();
                    symbols.push(symbol);

                    // redis_update_tokens_metadata(Some(metadata)); // preserve updated value
                }
            }
        }

        let _ = pool.token_symbols.insert(symbols);
    }

    Ok(pools)
}

pub async fn internal_farm_seeds() -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let farms = get_farms().await.unwrap_or_default();
    let mut seeds: Vec<String> = Vec::new();

    for farm in farms.iter() {
        let status = &farm.farm_status;
        let total_reward: u128 = farm.total_reward.parse::<u128>().unwrap();
        let claimed_reward: u128 = farm.claimed_reward.parse::<u128>().unwrap();
        let unclaimed_reward: u128 = farm.unclaimed_reward.parse::<u128>().unwrap();

        if *status == "Running".to_string() && total_reward > claimed_reward + unclaimed_reward {
            seeds.push(farm.seed_id.clone());
        }
    }

    Ok(seeds)
}

pub async fn internal_update_token_metadata(
    tokens: &Vec<String>,
) -> Result<BTreeMap<String, FungibleTokenMetadata>, Box<dyn std::error::Error>> {
    let mut valid_tokens: BTreeMap<String, FungibleTokenMetadata> = BTreeMap::new();

    for token_contract in tokens.iter() {
        let args = FunctionArgs::from(json!({}).to_string().into_bytes());
        let response = call_view(token_contract, Methods::FtMetadata.value(), args).await?;

        if let QueryResponseKind::CallResult(result) = response.kind {
            let metadata = from_slice::<FungibleTokenMetadata>(&result.result)?;
            valid_tokens.insert(token_contract.clone(), metadata);
        }
    }

    Ok(valid_tokens)
}

pub async fn get_whitelisted_tokens(
) -> Result<BTreeMap<String, FungibleTokenMetadata>, Box<dyn std::error::Error>> {
    let args = FunctionArgs::from(json!({}).to_string().into_bytes());
    let response = call_view(
        Contracts::RefExchange.value(),
        Methods::WhitelistedTokens.value(),
        args,
    )
    .await?;

    let mut tokens: Vec<String> = Vec::new();

    if let QueryResponseKind::CallResult(result) = response.kind {
        tokens = from_slice::<Vec<String>>(&result.result)?;
    }

    let valid_tokens = internal_update_token_metadata(&tokens)
        .await
        .unwrap_or_default();

    Ok(valid_tokens)
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount(
        "/",
        routes![
            routes::root,
            routes::init_redis,
            routes::init_mongo,
            routes::list_farms,
            routes::list_pools,
            routes::list_whitelisted_tokens,
            routes::mongo_list_farms,
            routes::mongo_list_pools,
            routes::mongo_list_whitelisted_tokens,
        ],
    )
}

'''
'''--- src/models.rs ---
use crate::*;

#[derive(Debug, Serialize, Deserialize, RedisJsonValue, Clone)]
pub struct TokenInfo {
    pub decimal: u8,
    pub price: String,
    pub symbol: String,
}

#[derive(Debug, Serialize, Deserialize, RedisJsonValue, Clone)]
pub struct FarmInfo {
    pub farm_id: String,
    pub farm_kind: String,
    pub farm_status: String,
    pub seed_id: String,
    pub reward_token: String,
    pub start_at: u64,
    pub reward_per_session: String,
    pub session_interval: u64,
    pub total_reward: String,
    pub cur_round: u64,
    pub last_round: u64,
    pub claimed_reward: String,
    pub unclaimed_reward: String,
    pub beneficiary_reward: String,
}

#[derive(Debug, Serialize, Deserialize, RedisJsonValue, Clone)]
pub struct PoolInfo {
    pub id: Option<u64>,
    /// Pool kind.
    pub pool_kind: String,
    /// List of tokens in the pool.
    pub token_account_ids: Vec<String>,
    /// How much NEAR this contract has.
    pub amounts: Vec<String>,
    /// Fee charged for swap.
    pub total_fee: u32,
    /// Total number of shares.
    pub shares_total_supply: String,
    pub amp: u64,
    pub farming: Option<bool>,
    pub token_symbols: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize, RedisJsonValue, Clone)]
pub struct FungibleTokenMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
    pub decimals: u8,
}

'''
'''--- src/mongo_impl.rs ---
use crate::*;

// This trait is required to use `try_next()` on the cursor
use futures::stream::TryStreamExt;

use mongodb::{options::ClientOptions, Client};

pub async fn mongo_connection() -> Result<Client, Box<dyn std::error::Error>> {
    // Parse a connection string into an options struct.
    let mut client_options = ClientOptions::parse("mongodb://localhost:27017").await?;

    // Manually set an option.
    client_options.app_name = Some("My App".to_string());

    // Get a handle to the deployment.
    let client = Client::with_options(client_options)?;

    Ok(client)
}

pub async fn mongo_add_tokens() -> Result<String, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<FungibleTokenMetadata>("ft_metadata");

    let tokens_metadata = get_whitelisted_tokens().await.unwrap_or_default();

    let mut tokens: Vec<FungibleTokenMetadata> = Vec::new();

    for (_, metadata) in tokens_metadata {
        tokens.push(metadata);
    }

    // Insert
    typed_collection.insert_many(tokens, None).await?;

    Ok(format!("Done"))
}

pub async fn mongo_add_farms() -> Result<String, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<FarmInfo>("farms");

    let farms = get_farms().await.unwrap_or_default();

    // Insert
    typed_collection.insert_many(farms, None).await?;

    Ok(format!("Done"))
}
pub async fn mongo_add_pools() -> Result<String, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<PoolInfo>("pools");

    let pools = get_pools().await.unwrap_or_default();

    // Insert
    typed_collection.insert_many(pools, None).await?;
    Ok(format!("Done"))
}

pub async fn mongo_get_tokens_metadata(
) -> Result<Vec<FungibleTokenMetadata>, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<FungibleTokenMetadata>("ft_metadata");

    // Query
    let mut cursor = typed_collection.find(None, None).await?;

    let mut tokens: Vec<FungibleTokenMetadata> = Vec::new();

    // Iterate over the results of the cursor.
    while let Some(token) = cursor.try_next().await? {
        println!("token name: {}", token.name);
        tokens.push(token);
    }

    Ok(tokens)
}

pub async fn mongo_get_farms() -> Result<Vec<FarmInfo>, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<FarmInfo>("farms");

    // Query
    let mut cursor = typed_collection.find(None, None).await?;

    let mut farms: Vec<FarmInfo> = Vec::new();

    // Iterate over the results of the cursor.
    while let Some(farm) = cursor.try_next().await? {
        println!("token name: {:#?}", farm.seed_id);
        farms.push(farm);
    }

    Ok(farms)
}
pub async fn mongo_get_pools() -> Result<Vec<PoolInfo>, Box<dyn std::error::Error>> {
    let client = mongo_connection().await.unwrap();

    // Get a handle to a database.
    let db = client.database("db");

    // Get a handle to a collection
    let typed_collection = db.collection::<PoolInfo>("pools");

    // Query
    let mut cursor = typed_collection.find(None, None).await?;

    let mut pools: Vec<PoolInfo> = Vec::new();

    // Iterate over the results of the cursor.
    while let Some(pool) = cursor.try_next().await? {
        println!("token name: {:#?}", pool.token_account_ids);
        pools.push(pool);
    }

    Ok(pools)
}

'''
'''--- src/redis_impl.rs ---
use crate::*;

use std::env;

/***************************
    Redis implementation
****************************/

// Connect to redis
pub fn connect() -> redis::Connection {
    //format - host:port
    let redis_host_name =
        env::var("REDIS_HOSTNAME").expect("missing environment variable REDIS_HOSTNAME");
    let redis_password = env::var("REDIS_PASSWORD").unwrap_or_default();

    //if Redis server needs secure connection
    let uri_scheme = match env::var("IS_TLS") {
        Ok(_) => "rediss",
        Err(_) => "redis",
    };

    let redis_conn_url = format!("{}://:{}@{}", uri_scheme, redis_password, redis_host_name);
    println!("{}", redis_conn_url);

    redis::Client::open(redis_conn_url)
        .expect("Invalid connection URL")
        .get_connection()
        .expect("failed to connect to Redis")
}

pub async fn redis_update_farms() -> Result<String, Box<dyn std::error::Error>> {
    let mut conn = connect();

    let res = get_farms().await;
    let farms = res.unwrap();

    let mut driver: BTreeMap<String, FarmInfo> = BTreeMap::new();

    for farm in farms.clone() {
        driver.insert(farm.farm_id.clone(), farm);
    }

    let prefix = "redis-driver";

    let _: () = redis::cmd("HSET")
        .arg(format!("{}:{}", prefix, "farms"))
        .arg(driver)
        .query(&mut conn)
        .expect("failed to execute HSET");

    Ok(format!("Done"))
}

pub async fn redis_update_pools() -> Result<String, Box<dyn std::error::Error>> {
    let mut conn = connect();

    let res = get_pools().await;
    let pools = res.unwrap();

    let mut driver: BTreeMap<String, PoolInfo> = BTreeMap::new();

    for pool in pools.clone() {
        driver.insert(pool.id.unwrap().to_string(), pool);
    }

    let prefix = "redis-driver";

    let _: () = redis::cmd("HSET")
        .arg(format!("{}:{}", prefix, "pool"))
        .arg(driver)
        .query(&mut conn)
        .expect("failed to execute HSET");

    Ok(format!("Done"))
}

pub async fn redis_update_tokens_metadata(
    tokens: Option<BTreeMap<String, FungibleTokenMetadata>>,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut conn = connect();

    let tokens_metadata = if tokens.is_some() {
        tokens.unwrap()
    } else {
        let res = get_whitelisted_tokens().await;
        res.unwrap()
    };

    let prefix = "redis-driver";

    let _: () = redis::cmd("HSET")
        .arg(format!("{}:{}", prefix, "metadata"))
        .arg(tokens_metadata)
        .query(&mut conn)
        .expect("failed to execute HSET");

    Ok(format!("Done"))
}

pub async fn get_redis_tokens_metadata() -> BTreeMap<String, FungibleTokenMetadata> {
    let mut conn = connect();

    let prefix = "redis-driver";

    let info: BTreeMap<String, FungibleTokenMetadata> = redis::cmd("HGETALL")
        .arg(format!("{}:{}", prefix, "metadata"))
        .query(&mut conn)
        .expect("failed to execute HGETALL");

    info
}

pub async fn get_redis_farms() -> BTreeMap<String, FarmInfo> {
    let mut conn = connect();

    let prefix = "redis-driver";

    let info: BTreeMap<String, FarmInfo> = redis::cmd("HGETALL")
        .arg(format!("{}:{}", prefix, "farms"))
        .query(&mut conn)
        .expect("failed to execute HGETALL");

    info
}

pub async fn get_redis_pools() -> BTreeMap<String, PoolInfo> {
    let mut conn = connect();

    let prefix = "redis-driver";

    let info: BTreeMap<String, PoolInfo> = redis::cmd("HGETALL")
        .arg(format!("{}:{}", prefix, "pool"))
        .query(&mut conn)
        .expect("failed to execute HGETALL");

    info
}

'''
'''--- src/routes.rs ---
use crate::*;

#[get("/")]
pub async fn root() -> String {
    format!("Hello world")
}

#[get("/list-farms")]
pub async fn list_farms() -> Json<Vec<FarmInfo>> {
    let farms_map = get_redis_farms().await;

    let farms = farms_map.values().cloned().collect();

    Json(farms)
}

#[get("/list-pools")]
pub async fn list_pools() -> Json<Vec<PoolInfo>> {
    let pools_map = get_redis_pools().await;

    let pools = pools_map.values().cloned().collect();

    Json(pools)
}

#[get("/whitelisted-tokens")]
pub async fn list_whitelisted_tokens() -> Json<Vec<FungibleTokenMetadata>> {
    let tokens_map = get_redis_tokens_metadata().await;

    if tokens_map.is_empty() {
        println!("ERR_FETCHING_TOKENS_METADATA");
        return Json(vec![]);
    }

    let tokens = tokens_map.values().cloned().collect();

    Json(tokens)
}

#[get("/mongo-list-farms")]
pub async fn mongo_list_farms() -> Json<Vec<FarmInfo>> {
    let farms = mongo_get_farms().await.unwrap_or_default();

    Json(farms)
}

#[get("/mongo-list-pools")]
pub async fn mongo_list_pools() -> Json<Vec<PoolInfo>> {
    let pools = mongo_get_pools().await.unwrap_or_default();

    Json(pools)
}

#[get("/mongo-whitelisted-tokens")]
pub async fn mongo_list_whitelisted_tokens() -> Json<Vec<FungibleTokenMetadata>> {
    let tokens = mongo_get_tokens_metadata().await.unwrap_or_default();

    Json(tokens)
}

type Result<T, E = rocket::response::Debug<Box<dyn std::error::Error>>> = std::result::Result<T, E>;

#[get("/init-redis")]
pub async fn init_redis() -> Result<()> {
    // TODO: improve this by collecting string results, like "Ok"
    println!("Redis is starting");
    let result = redis_update_tokens_metadata(None).await.expect("Done");
    println!("Get tokens finished");
    let result = redis_update_farms().await.expect("Done");
    println!("Get farms finished");
    let result = redis_update_pools().await.expect("Done");
    println!("Get pools finished");

    Ok(())
}

#[get("/init-mongo")]
pub async fn init_mongo() -> Result<()> {
    // TODO: improve this by collecting string results, like "Ok"
    println!("Mongo is starting");
    let result = mongo_add_tokens().await.expect("Done");
    println!("Redis is starting");
    let result = mongo_add_farms().await.expect("Done");
    println!("Get farms finished");
    let result = mongo_add_pools().await.expect("Done");
    println!("Get pools finished");

    Ok(())
}

'''
'''--- src/utils.rs ---
use crate::*;

pub async fn call_view(
    contract: &str,
    method_name: String,
    args: FunctionArgs,
) -> Result<RpcQueryResponse, Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect("https://rpc.testnet.near.org");

    let request = methods::query::RpcQueryRequest {
        block_reference: BlockReference::Finality(Finality::Final),
        request: QueryRequest::CallFunction {
            account_id: contract.parse()?,
            method_name: method_name,
            args: args,
        },
    };

    let response = client.call(request).await?;
    Ok(response)
}

'''