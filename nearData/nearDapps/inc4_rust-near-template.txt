*GitHub Repository "inc4/rust-near-template"*

'''--- Cargo.toml ---
[package]
name = "template-contract"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "4.1.1", features = [] }
near-contract-standards = "4.1.1"
primitive-types = {version = "0.12.1", default-features = false}

[dev-dependencies]
assert_matches = "1.5.0"
workspaces = { version = "0.7.0", features = ["unstable"] }
near-units = "0.2.0"
tokio = { version = "1.24.2", features = ["full"] }
anyhow = "1.0.68"

'''
'''--- src/account.rs ---
use crate::misc::Hash;
use crate::storage::{MAX_ACCOUNT_ID_LENGTH, REGISTERED_MAX_ID_LENGTH_ACCOUNT_INITIAL_STORAGE};
use near_contract_standards::storage_management::StorageBalance;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{env, AccountId, Balance, StorageUsage};

/// Current account data struct
///
/// Contains most recent storage data
#[derive(BorshSerialize, BorshDeserialize)]
pub(crate) struct Account {
    /// Total account storage deposit amount in $NEAR
    pub(crate) storage_balance: u128,
    /// Total used by account storage amount in bytes
    pub(crate) storage_usage: StorageUsage,
}

/// Versioned account data struct
///
/// Could contain legacy account data structs,
/// which would be upgraded to current version upon next write access
#[derive(BorshDeserialize, BorshSerialize)]
pub(crate) enum VAccount {
    Current(Account),
}

impl Account {
    /// Creates new account data struct with optionally provided initial storage balance
    pub(crate) fn new(account_id: &AccountId, storage_balance: Option<Balance>) -> Self {
        Self {
            storage_balance: storage_balance.unwrap_or_default(),
            storage_usage: Self::initial_storage_usage(Some(account_id)),
        }
    }

    /// Returns storage usage by optionally provided `account_id`, otherwise use maximum account id length
    pub(crate) fn initial_storage_usage(account_id: Option<&AccountId>) -> u64 {
        // compute storage usage diff for specific `account id` length, which is used when saving account data in lookup map
        let storage_diff = account_id
            .map(|account_id| MAX_ACCOUNT_ID_LENGTH - account_id.as_bytes().len() as u64)
            .unwrap_or_default();

        REGISTERED_MAX_ID_LENGTH_ACCOUNT_INITIAL_STORAGE - storage_diff
    }

    /// Returns required deposit by optionally provided `account_id`
    pub(crate) fn required_deposit(account_id: Option<&AccountId>) -> U128 {
        (Self::initial_storage_usage(account_id) as Balance * env::storage_byte_cost()).into()
    }

    /// Returns storage balance
    pub(crate) fn storage_balance(&self) -> StorageBalance {
        StorageBalance {
            total: self.storage_balance.into(),
            available: self
                .storage_balance
                .saturating_sub(self.storage_usage as Balance * env::storage_byte_cost())
                .into(),
        }
    }
}

impl<'a> From<&'a VAccount> for &'a Account {
    fn from(v_acc: &'a VAccount) -> Self {
        match v_acc {
            VAccount::Current(account) => account,
        }
    }
}

impl<'a> From<&'a mut VAccount> for &'a mut Account {
    fn from(v_acc: &'a mut VAccount) -> Self {
        match v_acc {
            VAccount::Current(account) => account,
        }
    }
}

impl From<VAccount> for Account {
    fn from(v_acc: VAccount) -> Self {
        match v_acc {
            VAccount::Current(account) => account,
        }
    }
}

impl From<Account> for VAccount {
    fn from(account: Account) -> Self {
        Self::Current(account)
    }
}

impl Hash for AccountId {
    fn hash(&self) -> Vec<u8> {
        env::sha256(self.as_bytes())
    }
}

'''
'''--- src/contract.rs ---
use crate::account::{Account, VAccount};
use crate::misc::RunningState;
use crate::storage::StorageKey;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::store::LookupMap;
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// The contract's owner account id
    pub(crate) owner_id: AccountId,
    /// Contract's state, e.g. running, paused
    pub(crate) running_state: RunningState,
    /// User versioned accounts data keyed by AccountId
    pub(crate) accounts: LookupMap<AccountId, VAccount>,
}

#[near_bindgen]
impl Contract {
    /// Initializes contract
    #[init]
    pub fn init(owner_id: Option<AccountId>) -> Self {
        Self {
            owner_id: owner_id.unwrap_or_else(env::predecessor_account_id),
            running_state: RunningState::Running,
            accounts: LookupMap::new(StorageKey::Accounts),
        }
    }
}

impl Contract {
    /// Checks if contract is at running state
    pub(crate) fn assert_contract_running(&self) {
        require!(
            self.running_state == RunningState::Running,
            "Contract paused"
        );
    }

    /// Asserts if the caller is not an owner of the contract
    pub(crate) fn assert_owner(&self) {
        require!(self.is_owner(&env::predecessor_account_id()), "Not allowed");
    }

    /// Checks ifn the caller is an owner of the contract
    pub(crate) fn is_owner(&self, account_id: &AccountId) -> bool {
        account_id == &self.owner_id
    }

    /// Returns reference to account by provided `account_id`
    pub(crate) fn remove_account(
        &mut self,
        account_id: &AccountId,
    ) -> Result<Account, &'static str> {
        self.accounts
            .remove(account_id)
            .map(Account::from)
            .ok_or("Account is not registered")
    }

    /// Returns reference to account by provided `account_id`
    pub(crate) fn get_account<'a>(
        &'a self,
        account_id: &'a AccountId,
    ) -> Result<&'a Account, &'static str> {
        self.accounts
            .get(account_id)
            .map(<&'a Account>::from)
            .ok_or("Account is not registered")
    }

    /// Returns mutable reference to account by provided `account_id`
    pub(crate) fn get_account_mut<'a>(
        &'a mut self,
        account_id: &'a AccountId,
    ) -> Result<&'a mut Account, &'static str> {
        self.accounts
            .get_mut(account_id)
            .map(<&'a mut Account>::from)
            .ok_or("Account is not registered")
    }
}

'''
'''--- src/lib.rs ---
mod account;
mod contract;
mod misc;
mod storage;
mod storage_management;
mod storage_tracker;
#[cfg(test)]
mod tests;

pub use contract::*;

'''
'''--- src/misc.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum RunningState {
    Running,
    Paused,
}

pub(crate) trait Hash {
    fn hash(&self) -> Vec<u8>;
}

'''
'''--- src/storage.rs ---
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::{BorshStorageKey, StorageUsage};

pub(crate) const U128_STORAGE: StorageUsage = 16;
pub(crate) const U64_STORAGE: StorageUsage = 8;
pub(crate) const U8_STORAGE: StorageUsage = 1;

/// Max length of account id [64 bytes]
pub(crate) const MAX_ACCOUNT_ID_LENGTH: StorageUsage = 64;

// Serialized AccountId with maximum id length (len + id) [68 bytes]
pub(crate) const ACCOUNT_ID_STORAGE: StorageUsage =
    std::mem::size_of::<u32>() as u64 + MAX_ACCOUNT_ID_LENGTH;

/// Every storage entry additionally uses 40 bytes
/// - key len as u64,
/// - key ptr as u64,
/// - value len as u64,
/// - value ptr as u64,
/// - register as u64
pub(crate) const STORAGE_ENTRY: StorageUsage = 5 * U64_STORAGE;

/// enum::StorageKey size [1 byte]
const ENUM_STORAGE_KEY: StorageUsage = U8_STORAGE;

/// Current user account struct size
///
/// - storage_balance: [U128_STORAGE]
/// - storage_usage: [U64_STORAGE]
pub(crate) const ACCOUNT_STORAGE: StorageUsage = U128_STORAGE + U64_STORAGE;

/// Versioned user account size
///
/// - enum VAccount [U8_STORAGE]
/// - current account variant value [ACCOUNT_STORAGE]
pub(crate) const VACCOUNT_STORAGE: StorageUsage = U8_STORAGE + ACCOUNT_STORAGE;

/// Initial (minimum) storage in bytes used by registered user account with maximum id length (64 symbols)
///
/// - `Contract::accounts` (LookupMap<AccountId, VAccount>) entry [STORAGE_ENTRY] + [ENUM_STORAGE_KEY] + [ACCOUNT_ID_STORAGE] + [VACCOUNT_STORAGE]
pub(crate) const REGISTERED_MAX_ID_LENGTH_ACCOUNT_INITIAL_STORAGE: StorageUsage =
    STORAGE_ENTRY + ENUM_STORAGE_KEY + ACCOUNT_ID_STORAGE + VACCOUNT_STORAGE;

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Accounts,
}

'''
'''--- src/storage_management.rs ---
use crate::account::Account;
use crate::{Contract, ContractExt};
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::{assert_one_yocto, env, near_bindgen, AccountId, Promise};

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        self.assert_contract_running();

        let deposit_amount = env::attached_deposit();
        if deposit_amount == 0 {
            env::panic_str("No deposit provided")
        }

        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        let registration_only = registration_only.unwrap_or(false);

        match self.get_account_mut(&account_id) {
            // if exists and registration only flag is true, then return deposit to user
            Ok(account) if registration_only => {
                Promise::new(env::predecessor_account_id()).transfer(deposit_amount);
                account.storage_balance()
            }

            // if exists then update near_balance
            Ok(account) => {
                account.storage_balance = account
                    .storage_balance
                    .checked_add(deposit_amount)
                    .unwrap_or_else(|| env::panic_str("Storage balance overflow"));
                account.storage_balance()
            }

            // if not exist and registration only then register and refund
            Err(_) if registration_only => {
                let min_balance = Account::required_deposit(Some(&account_id)).into();

                let refund = deposit_amount.checked_sub(min_balance).unwrap_or_else(|| {
                    env::panic_str("Not enough minimum deposit to register account")
                });

                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }

                let account = Account::new(&account_id, Some(min_balance));
                let storage_balance = account.storage_balance();

                self.accounts.insert(account_id.clone(), account.into());

                storage_balance
            }

            // else register account with all deposit
            _ => {
                let account = Account::new(&account_id, Some(deposit_amount));
                let storage_balance = account.storage_balance();

                self.accounts.insert(account_id.clone(), account.into());

                storage_balance
            }
        }
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();

        self.assert_contract_running();

        let account_id = env::predecessor_account_id();
        let account = self
            .get_account_mut(&account_id)
            .unwrap_or_else(|e| env::panic_str(e));

        let available_balance = account.storage_balance().available;
        let withdraw_amount = match amount {
            Some(U128(amount)) if amount > 0 && amount <= available_balance.0 => amount,

            // If amount not provided, use all available storage balance
            None if available_balance.0 > 0 => available_balance.0,

            _ => env::panic_str("Not enough available storage to withdraw"),
        };

        account.storage_balance = account
            .storage_balance
            .checked_sub(withdraw_amount)
            .unwrap_or_else(|| env::panic_str("Not enough available storage to withdraw"));

        let storage_balance = account.storage_balance();

        Promise::new(account_id).transfer(withdraw_amount);

        storage_balance
    }

    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();

        self.assert_contract_running();

        let account_id = env::predecessor_account_id();
        let force = force.unwrap_or(false);

        match self.remove_account(&account_id) {
            // If account by provided `account_id` not found
            Err(_) => false,

            // If try to unregister a positive balance account without `force` set to `true`
            Ok(account) if account.storage_balance > 0 && !force => env::panic_str(
                "Unable to unregister a positive balance account without `force` set to `true`",
            ),

            // Unregister account and transfer all funds
            Ok(account) => {
                Promise::new(account_id).transfer(account.storage_balance);
                true
            }
        }
    }

    /// Returns storage min/max bounds in $NEAR for account with maximum id length
    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: Account::required_deposit(None),
            max: None,
        }
    }

    /// Returns storage balance by `account_id` if account is registered, otherwise None
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.assert_contract_running();
        self.get_account(&account_id)
            .map(|account| account.storage_balance())
            .ok()
    }
}

'''
'''--- src/storage_tracker.rs ---
use std::cmp::Ordering;

use near_sdk::{env, require, StorageUsage};

#[derive(Default)]
pub(crate) struct StorageUsageTrackerData {
    is_tracked: bool,
    pub(crate) last_storage_usage: StorageUsage,
}

impl StorageUsageTrackerData {
    /// Starts tracking storage usage changes
    pub(crate) fn track(mut self) -> Self {
        self.assert_storage_tracking_disabled();
        self.is_tracked = true;
        self.last_storage_usage = env::storage_usage();
        self
    }

    /// Finalizes storage usage changes and returns adjusted value
    pub(crate) fn finish(mut self, storage_usage: StorageUsage) -> StorageUsage {
        self.assert_storage_tracking_enabled();
        self.is_tracked = false;
        let current_storage_usage = env::storage_usage();

        match current_storage_usage.cmp(&self.last_storage_usage) {
            Ordering::Equal => Some(storage_usage),
            Ordering::Greater => {
                storage_usage.checked_add(current_storage_usage - self.last_storage_usage)
            }
            Ordering::Less => {
                storage_usage.checked_sub(self.last_storage_usage - current_storage_usage)
            }
        }
        .unwrap_or_else(|| env::panic_str("Storage computation overflow"))
    }

    fn assert_storage_tracking_disabled(&self) {
        require!(!self.is_tracked, "Storage tracking is already enabled")
    }

    fn assert_storage_tracking_enabled(&self) {
        require!(self.is_tracked, "Storage tracking is not enabled")
    }
}

'''
'''--- src/tests/automation/mod.rs ---
mod storage_management_test;
mod utils;

'''
'''--- src/tests/automation/storage_management_test.rs ---
use std::str::FromStr;

use super::utils::{build_contract, gen_user_account};
use near_contract_standards::storage_management::StorageBalance;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::{ONE_NEAR, ONE_YOCTO};
use workspaces::{Account, Contract};

#[tokio::test]
async fn test_user_registration_and_withdraw() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let contract = build_contract(&worker, "./").await?;

    // generate sub-account and transfer funds
    let user1 = gen_user_account(&worker, "user1.test.near").await?;
    let user1_account_id = near_sdk::AccountId::from_str(user1.id().as_str())?;

    let deposit = 3 * ONE_NEAR;
    let withdraw = ONE_NEAR;
    let storage_balance_left = deposit - withdraw;

    let user1_storage_balance = storage_deposit(&contract, &user1, deposit, None).await?;
    assert_eq!(user1_storage_balance.total.0, deposit);

    let user1_storage_balance = storage_withdraw(&contract, &user1, Some(withdraw.into())).await?;
    assert_eq!(user1_storage_balance.total.0, storage_balance_left);

    let opt_user1_storage_balance = storage_balance_of(&contract, &user1).await?;
    match opt_user1_storage_balance {
        Some(StorageBalance { total, available })
            if total.0 == storage_balance_left
                && available.0
                    == storage_balance_left
                        - crate::account::Account::required_deposit(Some(&user1_account_id)).0 => {}
        _ => panic!("Verify user `{:?}` storage balance failed!", user1.id()),
    };

    Ok(())
}

#[tokio::test]
async fn test_user_registration_only() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let contract = build_contract(&worker, "./").await?;

    // generate sub-account and transfer funds
    let user1 = gen_user_account(&worker, "user1.test.near").await?;
    let user1_account_id = near_sdk::AccountId::from_str(user1.id().as_str())?;

    // register user at OCC contract
    storage_deposit(&contract, &user1, ONE_NEAR, Some(true)).await?;

    let user1_storage_balance = storage_balance_of(&contract, &user1).await?;
    match user1_storage_balance {
        Some(StorageBalance { total, available })
            if total.0 == crate::account::Account::required_deposit(Some(&user1_account_id)).0
                && available.0 == 0 => {}
        _ => panic!("Verify user `{:?}` storage balance failed!", user1.id()),
    };

    Ok(())
}

async fn storage_deposit(
    contract: &Contract,
    target_account: &Account,
    deposit: u128,
    registration_only: Option<bool>,
) -> anyhow::Result<StorageBalance> {
    let res = target_account
        .call(contract.id(), "storage_deposit")
        .args_json(json!({
            "registration_only": registration_only,
        }))
        .deposit(deposit)
        .max_gas()
        .transact()
        .await?;

    match res.clone().into_result() {
        Ok(res) => res
            .json::<StorageBalance>()
            .map_err(|e| anyhow::Error::msg(format!("Parse `StorageBalance` failed. {:?}", e))),
        Err(_) => Err(anyhow::Error::msg(format!(
            "Registration of account `{:?}` failed on contract `{:?}`. Log {:?}",
            target_account.id(),
            contract.id(),
            res
        ))),
    }
}

async fn storage_withdraw(
    contract: &Contract,
    target_account: &Account,
    amount: Option<U128>,
) -> anyhow::Result<StorageBalance> {
    let res = target_account
        .call(contract.id(), "storage_withdraw")
        .args_json(json!({
            "amount": amount,
        }))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?;

    match res.clone().into_result() {
        Ok(res) => res
            .json::<StorageBalance>()
            .map_err(|e| anyhow::Error::msg(format!("Parse `StorageBalance` failed. {:?}", e))),
        Err(_) => Err(anyhow::Error::msg(format!(
            "Registration of account `{:?}` failed on contract `{:?}`. Log {:?}",
            target_account.id(),
            contract.id(),
            res
        ))),
    }
}

async fn storage_balance_of(
    contract: &Contract,
    account: &Account,
) -> anyhow::Result<Option<StorageBalance>> {
    let res = contract
        .view("storage_balance_of")
        .args_json(json!({
            "account_id": account.id(),
        }))
        .await;

    match res {
        Ok(res) => res
            .json::<Option<StorageBalance>>()
            .map_err(|e| anyhow::Error::msg(format!("Parse `StorageBalance` failed. {:?}", e))),
        Err(_) => Err(anyhow::Error::msg(format!(
            "Get storage balance of account `{:?}` failed. Log {:?}",
            account.id(),
            res
        ))),
    }
}

'''
'''--- src/tests/automation/utils.rs ---
use near_sdk::serde_json::json;
use std::str::FromStr;
use workspaces::network::{NetworkClient, NetworkInfo};
use workspaces::{
    types::{KeyType, SecretKey},
    Account, Contract, DevNetwork, Worker,
};

// Generate user sub-account
pub(crate) async fn gen_user_account<T>(
    worker: &Worker<T>,
    account_id: &str,
) -> anyhow::Result<Account>
where
    T: DevNetwork + Send + Sync,
{
    let id = workspaces::AccountId::from_str(account_id)?;
    let sk = SecretKey::from_random(KeyType::ED25519);

    let account = worker.create_tla(id, sk).await?.into_result()?;

    Ok(account)
}

// Build contract from sources and initialize it
pub(crate) async fn build_contract<T>(
    worker: &Worker<T>,
    project_path: &str,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = workspaces::compile_project(project_path).await?;
    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id.clone(), sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call("init")
        .args_json(json!({
            "owner_id": id,
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

// Load already built contract and initialize it
pub(crate) async fn load_contract<T>(
    worker: &Worker<T>,
    contract_path: &str,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = std::fs::read(contract_path)?;
    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id, sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call("init")
        .args_json(())
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

// Get current block timestamp
pub(crate) async fn get_block_timestamp<T>(worker: &Worker<T>) -> anyhow::Result<u64>
where
    T: NetworkClient + Send + Sync,
{
    Ok(worker.view_block().await?.timestamp())
}

'''
'''--- src/tests/common/mod.rs ---
use near_sdk::{test_utils::VMContextBuilder, AccountId, Balance, Gas};

pub(crate) const MAX_GAS: Gas = Gas(300_000_000_000_000);

pub(crate) fn build_default_context(
    predecessor_account_id: AccountId,
    deposit: Option<Balance>,
    prepaid_gas: Option<Gas>,
) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
        .signer_account_id(predecessor_account_id.clone())
        .predecessor_account_id(predecessor_account_id)
        .prepaid_gas(prepaid_gas.unwrap_or(MAX_GAS))
        .attached_deposit(deposit.unwrap_or_default());
    builder
}

'''
'''--- src/tests/mod.rs ---
pub(crate) mod automation;
mod common;
mod storage_management_test;

'''
'''--- src/tests/storage_management_test.rs ---
use super::super::account::Account;
use super::super::Contract;
use super::common::*;
use crate::storage_tracker::StorageUsageTrackerData;
use near_contract_standards::storage_management::*;
use near_sdk::test_utils::accounts;
use near_sdk::{env, testing_env, AccountId, ONE_NEAR};

#[test]
fn test_single_account_max_id_len_storage_deposit() {
    // AccountId with max length 64 bytes
    let account_id = AccountId::new_unchecked(
        "n.aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz0123456789".to_owned(),
    );

    let context = build_default_context(account_id.clone(), Some(ONE_NEAR), None);

    let mut contract = Contract::init(Some(accounts(0)));

    let storage_tracker = StorageUsageTrackerData::default().track();

    testing_env!(context.build());
    contract.storage_deposit(account_id.clone().into(), Some(false));
    contract.accounts.flush(); // flush content before use env::storage_usage()

    let account_storage_used = storage_tracker.finish(0);

    let account = contract.get_account(&account_id).unwrap();

    assert!(contract.accounts.get(&account_id).is_some());
    assert_eq!(account.storage_usage, account_storage_used)
}

#[test]
fn test_account_storage_deposit_registration_and_deposit() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(ONE_NEAR), None);

    let mut contract = Contract::init(Some(accounts(0)));

    let storage_tracker = StorageUsageTrackerData::default().track();

    testing_env!(context.build());
    contract.storage_deposit(account_id.clone().into(), Some(false));
    contract.accounts.flush(); // flush content before use env::storage_usage()

    let account_storage_used = storage_tracker.finish(0);

    let account = contract.get_account(&account_id).unwrap();

    assert!(contract.accounts.get(&account_id).is_some());
    assert_eq!(account.storage_usage, account_storage_used)
}

#[test]
fn test_account_storage_deposit_registration_only() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(ONE_NEAR), None);

    let mut contract = Contract::init(Some(accounts(0)));

    let storage_tracker = StorageUsageTrackerData::default().track();

    testing_env!(context.build());
    contract.storage_deposit(account_id.clone().into(), Some(true));
    contract.accounts.flush(); // flush content before use env::storage_usage()

    let account_storage_used = storage_tracker.finish(0);

    let account = contract.get_account(&account_id).unwrap();

    assert!(contract.accounts.get(&account_id).is_some());
    assert_eq!(account.storage_usage, account_storage_used);
    assert_eq!(
        account.storage_balance,
        account_storage_used as u128 * env::storage_byte_cost()
    )
}

#[test]
fn test_account_storage_deposit_registration_only_register_twice() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(ONE_NEAR), None);

    let mut contract = Contract::init(Some(accounts(0)));

    let storage_tracker = StorageUsageTrackerData::default().track();

    testing_env!(context.build());
    contract.storage_deposit(account_id.clone().into(), Some(true));
    contract.accounts.flush(); // flush content before use env::storage_usage()

    let account_storage_used = storage_tracker.finish(0);

    let account = contract.get_account(&account_id).unwrap();

    assert!(contract.accounts.get(&account_id).is_some());
    assert_eq!(account.storage_usage, account_storage_used);
    assert_eq!(
        account.storage_balance,
        account_storage_used as u128 * env::storage_byte_cost()
    )
}

#[test]
#[should_panic = "Storage balance overflow"]
fn test_account_storage_deposit_overflow() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(ONE_NEAR), None);

    let mut contract = Contract::init(Some(accounts(0)));

    // register account with maximum allowed deposit
    contract.accounts.insert(
        account_id.clone(),
        Account::new(&account_id, Some(u128::MAX)).into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    testing_env!(context.build());
    contract.storage_deposit(account_id.clone().into(), Some(false));
}

#[test]
#[should_panic = "Not enough available storage to withdraw"]
fn test_storage_withdraw_not_enough_storage_panic() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    // register account with minimum required deposit
    contract.accounts.insert(
        account_id.clone(),
        Account::new(
            &account_id,
            Some(Account::required_deposit(Some(&account_id)).0),
        )
        .into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    // try to withdraw more than have
    testing_env!(context.build());
    contract.storage_withdraw(Some(
        (Account::required_deposit(Some(&account_id)).0 + 1).into(),
    ));
}

#[test]
fn test_storage_withdraw() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    contract.accounts.insert(
        account_id.clone(),
        Account::new(&account_id, Some(ONE_NEAR)).into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    let minimum_account_deposit = Account::required_deposit(Some(&account_id)).0;

    testing_env!(context.build());
    let storage_balance =
        contract.storage_withdraw(Some((ONE_NEAR - minimum_account_deposit).into()));
    assert_eq!(storage_balance.total.0, minimum_account_deposit);
    assert_eq!(storage_balance.available.0, 0);
}

#[test]
#[should_panic = "Unable to unregister a positive balance account without `force` set to `true`"]
fn test_storage_unregister_without_force() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    contract.accounts.insert(
        account_id.clone(),
        Account::new(&account_id, Some(ONE_NEAR)).into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    testing_env!(context.build());
    let unregistered = contract.storage_unregister(Some(false));

    assert_eq!(unregistered, true)
}

#[test]
fn test_storage_unregister_zero_balance() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    contract
        .accounts
        .insert(account_id.clone(), Account::new(&account_id, None).into());
    contract.accounts.flush(); // flush content before use env::storage_usage()

    testing_env!(context.build());
    let unregistered = contract.storage_unregister(Some(false));

    assert_eq!(unregistered, true)
}

#[test]
fn test_storage_unregister_with_force() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    contract.accounts.insert(
        account_id.clone(),
        Account::new(&account_id, Some(ONE_NEAR)).into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    testing_env!(context.build());
    let unregistered = contract.storage_unregister(Some(true));

    assert_eq!(unregistered, true)
}

#[test]
fn test_not_exist_account_storage_unregister() {
    let account_id = accounts(1);

    let context = build_default_context(account_id.clone(), Some(1), None);

    let mut contract = Contract::init(Some(accounts(0)));

    testing_env!(context.build());
    let unregistered = contract.storage_unregister(Some(false));

    assert_eq!(unregistered, false)
}

#[test]
fn test_storage_balance_bounds() {
    let account_id = accounts(1);

    let mut context = build_default_context(account_id.clone(), None, None);

    let contract = Contract::init(Some(accounts(0)));

    testing_env!(context.is_view(true).build());
    let balance_bounds = contract.storage_balance_bounds();

    assert_eq!(balance_bounds.min, Account::required_deposit(None));
    assert_eq!(balance_bounds.max, None);
}

#[test]
fn test_storage_balance_of_not_registered_user() {
    let account_id = accounts(1);

    let mut context = build_default_context(account_id.clone(), None, None);

    let contract = Contract::init(Some(accounts(0)));

    testing_env!(context.is_view(true).build());
    assert!(contract.storage_balance_of(account_id).is_none());
}

#[test]
fn test_storage_balance_of() {
    let account_id = accounts(1);

    let mut context = build_default_context(account_id.clone(), None, None);

    let mut contract = Contract::init(Some(accounts(0)));

    contract.accounts.insert(
        account_id.clone(),
        Account::new(&account_id, Some(ONE_NEAR)).into(),
    );
    contract.accounts.flush(); // flush content before use env::storage_usage()

    testing_env!(context.is_view(true).build());
    let storage_balance = contract.storage_balance_of(account_id.clone()).unwrap();

    assert_eq!(storage_balance.total.0, ONE_NEAR);
    assert_eq!(
        storage_balance.available.0,
        ONE_NEAR - Account::required_deposit(Some(&account_id)).0
    );
}

'''