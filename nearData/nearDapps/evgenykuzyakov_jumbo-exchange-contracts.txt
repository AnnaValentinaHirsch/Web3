*GitHub Repository "evgenykuzyakov/jumbo-exchange-contracts"*

'''--- Cargo.toml ---
[workspace]
members = [
    "./ref-exchange",
    "./test-token",
    "./ref-farming"
]

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "z"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Ref Finance Contracts

This mono repo contains the source code for the smart contracts of Ref Finance on [NEAR](https://near.org).

## Contracts

| Contract | Reference | Description |
| - | - | - |
| [test-token](test-token/src/lib.rs) | - | Test token contract |
| [ref-exchange](ref-exchange/src/lib.rs) | [docs](https://ref-finance.gitbook.io/ref-finance/smart-contracts/ref-exchange) | Main exchange contract, that allows to deposit and withdraw tokens, exchange them via various pools |

## Development

1. Install `rustup` via https://rustup.rs/
2. Run the following:

```
rustup default stable
rustup target add wasm32-unknown-unknown
```

### Testing

Contracts have unit tests and also integration tests using NEAR Simulation framework. All together can be run:

```
cd ref-exchange
cargo test --all
```

### Compiling

You can build release version by running next scripts inside each contract folder:

```
cd ref-exchange
./build.sh
```

### Deploying to TestNet

To deploy to TestNet, you can use next command:
```
near dev-deploy
```

This will output on the contract ID it deployed.

'''
'''--- docs.md ---
# Ref Finance

[Ref Finance](https://ref.finance) is the protocol for creating synthetic tokenized assets on NEAR blockchain.

It uses NEAR as collateral and allows to mint any token that has a whitelisted price feed, for example: rUSD, rBTC, rTESLA, rSPBEAR (short S&P500) or rOIL.

The protocol will be governed by an instance of SputnikDAO.

## Approach

There are two main approaches to create synthetic assets:
- Collateralized Debt Position, where the position is over collateralized and serves to borrow the synthetic asset
- A fractional reserve approach, selling tokens above the peg value and allowing to trade in below with various incentives.

Ref Finance is taking an approach of fractional reserve that is used to provide liquidity instead of just sitting as collateral, while allowing people to use other lending protocols for CDP-like experience.

*This design leverages Fei Protocol's stabilization mechanics extended to multiple assets.*

Ref Finance maintains internal pools of <collateral, synthetic asset> for each asset. These assets provide liquidity in the form of Uniswap exchange.

Additionally new assets are minted with price above `x%` (configurable parameter) the oracle price. This allows to expand the supply when there is demand.

If the price is below the pool price:
- For anyone who is buying under the price, additional tokens are minted to reward them based on time-weighted difference with the market price `r * num_blocks * (target_price - current_price) * amount`.
- If someone is selling more below the oracle price - the slippage increases and extra tokens `(target_price - end_price) ^ 2 * 100 * amount` are burnt.

If that didn't help to bring the price, the pool can be reweighted by burning the extra Ref tokens to bring price to the target price. Condition for reweight to happen if `num_blocks = (target_price - current_price) * 100 / r`.

There is a central contract "Controller" that provides all operations including minting and exchange functionality.

Next functions are available on `Controller`:
- `add_asset(asset_name, oracle_feed, config)` - adds new assets to available with given oracle feed. Only allowed by `owner`.
- `set_asset_config(asset_name, config)` - sets config including all the trading parameters for given asset. Only allowed by `owner`.
- `buy(asset_name, amount_out)` - buy given `amount_out` of `asset_name`, must attach enough $NEAR to cover the trade. This will first buy from the Uniswap formula (rewarding with new minted tokens if the price of liquidity below oracle price) and if the amount brings price above current bonding curve - will buy from bonding curve expanding the supply.
- `sell(asset_name, amount_in, amount_out)` - (works as callback from `asset_name`) sell `amount_in` of given `asset_name` and expecting at least `amount_out` of $N. This uses Uniswap curve and uses quadratic penalty to disinsentivize large sell orders. Penalty is getting burnt.
- `trade(asset_name_in, amount_in, asset_name_in, amount_out)` - (works as callback from `asset_name_in`) trade two assets between each other. Uses internal calculations to exchange them to save on the fees.
- `reweight(asset_name)` - if the internal exchange rate is way below the oracle price for given `asset_name` and ??? - allows to reweight the Uniswap pool to bring it back to the pool.
- `stage_upgrade(contract)` - Stage upgrade for this contract. Only allowed by `owner`.
- `upgrade()` - Upgrade to staged contract. Only allowed by `owner`.

Each Ref Token will have it's own contract living under sub-name of the Controller contract. These token contracts provide `owner` ability for Controller to mint / burn assets .

Future features:
- Allowing to add external capital as LP to the exchange.

# References

- MarkerDAO - https://makerdao.com/whitepaper/
- Synthetix - https://synthetix.io/
- Mirror Protocol - https://mirror.finance/
- Fei Protocol - https://fei.money/static/media/whitepaper.7d5e2986.pdf

'''
'''--- ref-exchange/Cargo.toml ---
[package]
name = "ref-exchange"
version = "1.4.1"
authors = ["Illia Polosukhin <illia.polosukhin@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint = { version = "0.9.0", default-features = false }
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"
test-token = { path = "../test-token" }
rand = "0.8"
rand_pcg = "0.3"
'''
'''--- ref-exchange/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_ref_exchange"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/ref-exchange \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2020-10-08; rustup default stable-2020-10-08; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/../target/wasm32-unknown-unknown/release/ref_exchange.wasm $DIR/../res/ref_exchange_release.wasm

'''
'''--- ref-exchange/build_local.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/ref_exchange.wasm ./res/ref_exchange_local.wasm

'''
'''--- ref-exchange/release_notes.md ---
# Release Notes

### Version 1.4.1
1. Introduce Stable-Swap-Pool;

### Version 1.4.0
1. Make exchange fee and referal fee inclusive in total fee;
2. Make exchange fee (in the form of lp shares) belongs to contract itself;

### Version 1.3.1
1. Apply HOTFIX in v1.0.3;

### Version 1.3.0
---
1. feature instant swap;  
Allows to swap with a single transaction without needing to deposit / withdraw. Not even storage deposits are required for the pool (inner account not touched). But FE must make sure that receiver is registered in the outgoing token, or they would go to inner account or lost-found account.  
Example usage: 
    ```bash
    contract.ft_transfer_call(
        to_va(swap()),
        to_yocto("1").into(),
        None,
        "{{\"actions\": [{{\"pool_id\": 0, \"token_in\": \"dai\", \"token_out\": \"eth\", \"min_amount_out\": \"1\"}}]}}".to_string()
    ),
    ```  
    Specifically for TokenReceiverMessage message parameters are:  
    ```rust
    enum TokenReceiverMessage {
        /// Alternative to deposit + execute actions call.
        Execute {
            referral_id: Option<ValidAccountId>,
            /// List of sequential actions.
            actions: Vec<Action>,
        },
    }
    ```
    where Action is either SwapAction or any future action added there.

### Version 1.2.0
---
1. upgrade inner account;
    * inner account upgrade to use `UnorderedMap`;
    * keep exist deposits in `legacy_tokens` in `HashMap`; 
    * move it to `tokens` in `UnorderedMap` when deposit or withdraw token;
    
### Version 1.1.0
---
1. feature Guardians;
    * guardians are managed by owner;
    * guardians and owner can switch contract state to Paused;
    * owner can resume the contract;
    * guardians and owner can manager global whitelist;
    * a new view method metadata to show overall info includes version, owner, guardians, state, pool counts.

### Version 1.0.3
---
1. HOTFIX -- increase ft_transfer GAS from 10T to 20T;

### Version 1.0.2
---
1. fixed storage_withdraw bug;
'''
'''--- ref-exchange/src/account_deposit.rs ---
//! Account deposit is information per user about their balances in the exchange.

use std::collections::HashMap;
use near_sdk::collections::UnorderedMap;

use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    assert_one_yocto, env, near_bindgen, 
    AccountId, Balance, PromiseResult, StorageUsage,
};
use crate::legacy::AccountV1;
use crate::utils::{ext_self, GAS_FOR_FT_TRANSFER, GAS_FOR_RESOLVE_TRANSFER};
use crate::*;

// [AUDIT_01]
// const MAX_ACCOUNT_LENGTH: u128 = 64;
// const MAX_ACCOUNT_BYTES: u128 = MAX_ACCOUNT_LENGTH + 4;
// const MIN_ACCOUNT_DEPOSIT_LENGTH: u128 = 1 + MAX_ACCOUNT_BYTES + 16 + 4;

const U128_STORAGE: StorageUsage = 16;
const U64_STORAGE: StorageUsage = 8;
const U32_STORAGE: StorageUsage = 4;
/// max length of account id is 64 bytes. We charge per byte.
const ACC_ID_STORAGE: StorageUsage = 64;
/// As a key, 4 bytes length would be added to the head
const ACC_ID_AS_KEY_STORAGE: StorageUsage = ACC_ID_STORAGE + 4;
const KEY_PREFIX_ACC: StorageUsage = 64;
/// As a near_sdk::collection key, 1 byte for prefiex
const ACC_ID_AS_CLT_KEY_STORAGE: StorageUsage = ACC_ID_AS_KEY_STORAGE + 1;

// ACC_ID: the Contract accounts map key length
// + VAccount enum: 1 byte
// + U128_STORAGE: near_amount storage
// + U32_STORAGE: legacy_tokens HashMap length
// + U32_STORAGE: tokens HashMap length
// + U64_STORAGE: storage_used
pub const INIT_ACCOUNT_STORAGE: StorageUsage =
    ACC_ID_AS_CLT_KEY_STORAGE + 1 + U128_STORAGE + U32_STORAGE + U32_STORAGE + U64_STORAGE;

#[derive(BorshDeserialize, BorshSerialize)]
pub enum VAccount {
    V1(AccountV1),
    Current(Account),
}

impl VAccount {
    /// Upgrades from other versions to the currently used version.
    pub fn into_current(self, account_id: &AccountId) -> Account {
        match self {
            VAccount::Current(account) => account,
            VAccount::V1(account) => account.into_current(account_id),
        }
    }
}

impl From<Account> for VAccount {
    fn from(account: Account) -> Self {
        VAccount::Current(account)
    }
}

/// Account deposits information and storage cost.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Account {
    /// Native NEAR amount sent to the exchange.
    /// Used for storage right now, but in future can be used for trading as well.
    pub near_amount: Balance,
    /// Amounts of various tokens deposited to this account.
    pub legacy_tokens: HashMap<AccountId, Balance>,
    pub tokens: UnorderedMap<AccountId, Balance>,
    pub storage_used: StorageUsage,
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Account {
            near_amount: 0,
            legacy_tokens: HashMap::new(),
            tokens: UnorderedMap::new(StorageKey::AccountTokens {
                account_id: account_id.clone(),
            }),
            storage_used: 0,
        }
    }

    pub fn get_balance(&self, token_id: &AccountId) -> Option<Balance> {
        if let Some(token_balance) = self.tokens.get(token_id) {
            Some(token_balance)
        } else if let Some(legacy_token_balance) = self.legacy_tokens.get(token_id) {
            Some(*legacy_token_balance)
        } else {
            None
        }
    }

    pub fn get_tokens(&self) -> Vec<AccountId> {
        let mut a: Vec<AccountId> = self.tokens.keys().collect();
        let b: Vec<AccountId> = self.legacy_tokens
            .keys()
            .cloned()
            .collect();
        a.extend(b);
        a
    }

    /// Deposit amount to the balance of given token,
    /// if given token not register and not enough storage, deposit fails 
    pub(crate) fn deposit_with_storage_check(&mut self, token: &AccountId, amount: Balance) -> bool { 
        if let Some(balance) = self.tokens.get(token) {
            // token has been registered, just add without storage check, 
            let new_balance = balance + amount;
            self.tokens.insert(token, &new_balance);
            true
        } else if let Some(x) = self.legacy_tokens.get_mut(token) {
            // token has been registered, just add without storage check
            *x += amount;
            true
        } else {
            // check storage after insert, if fail should unregister the token
            self.tokens.insert(token, &(amount));
            if self.storage_usage() <= self.near_amount {
                true
            } else {
                self.tokens.remove(token);
                false
            }
        }
    }

    /// Deposit amount to the balance of given token.
    pub(crate) fn deposit(&mut self, token: &AccountId, amount: Balance) {
        if let Some(x) = self.legacy_tokens.remove(token) {
            // need convert to tokens
            self.tokens.insert(token, &(amount + x));
        } else if let Some(x) = self.tokens.get(token) {
            self.tokens.insert(token, &(amount + x));
        } else {
            self.tokens.insert(token, &amount);
        }
    }

    /// Withdraw amount of `token` from the internal balance.
    /// Panics if `amount` is bigger than the current balance.
    pub(crate) fn withdraw(&mut self, token: &AccountId, amount: Balance) {
        if let Some(x) = self.legacy_tokens.remove(token) {
            // need convert to 
            assert!(x >= amount, "{}", ERR22_NOT_ENOUGH_TOKENS);
            self.tokens.insert(token, &(x - amount));
        } else if let Some(x) = self.tokens.get(token) {
            assert!(x >= amount, "{}", ERR22_NOT_ENOUGH_TOKENS);
            self.tokens.insert(token, &(x - amount));
        } else {
            env::panic(ERR21_TOKEN_NOT_REG.as_bytes());
        }
    }

    // [AUDIT_01]
    /// Returns amount of $NEAR necessary to cover storage used by this data structure.
    pub fn storage_usage(&self) -> Balance {
        (INIT_ACCOUNT_STORAGE + 
            self.legacy_tokens.len() as u64 * (ACC_ID_AS_KEY_STORAGE + U128_STORAGE) + 
            self.tokens.len() as u64 * (KEY_PREFIX_ACC + ACC_ID_AS_KEY_STORAGE + U128_STORAGE)
        ) as u128
            * env::storage_byte_cost()
    }

    /// Returns how much NEAR is available for storage.
    pub fn storage_available(&self) -> Balance {
        // [AUDIT_01] avoid math overflow
        let locked = self.storage_usage();
        if self.near_amount > locked {
            self.near_amount - locked
        } else {
            0
        }
    }

    /// Asserts there is sufficient amount of $NEAR to cover storage usage.
    pub fn assert_storage_usage(&self) {
        assert!(
            self.storage_usage() <= self.near_amount,
            "{}",
            ERR11_INSUFFICIENT_STORAGE
        );
    }

    /// Returns minimal account deposit storage usage possible.
    pub fn min_storage_usage() -> Balance {
        INIT_ACCOUNT_STORAGE as Balance * env::storage_byte_cost()
    }

    /// Registers given token and set balance to 0.
    pub(crate) fn register(&mut self, token_ids: &Vec<ValidAccountId>) {
        for token_id in token_ids {
            let t = token_id.as_ref();
            if self.get_balance(t).is_none() {
                self.tokens.insert(t, &0);
            }
        }
    }

    /// Unregisters `token_id` from this account balance.
    /// Panics if the `token_id` balance is not 0.
    pub(crate) fn unregister(&mut self, token_id: &AccountId) {
        let amount = self.legacy_tokens.remove(token_id).unwrap_or_default();
        assert_eq!(amount, 0, "{}", ERR24_NON_ZERO_TOKEN_BALANCE);
        let amount = self.tokens.remove(token_id).unwrap_or_default();
        assert_eq!(amount, 0, "{}", ERR24_NON_ZERO_TOKEN_BALANCE);
    }
}

#[near_bindgen]
impl Contract {
    /// Registers given token in the user's account deposit.
    /// Fails if not enough balance on this account to cover storage.
    #[payable]
    pub fn register_tokens(&mut self, token_ids: Vec<ValidAccountId>) {
        assert_one_yocto();
        self.assert_contract_running();
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        account.register(&token_ids);
        self.internal_save_account(&sender_id, account);
    }

    /// Unregister given token from user's account deposit.
    /// Panics if the balance of any given token is non 0.
    #[payable]
    pub fn unregister_tokens(&mut self, token_ids: Vec<ValidAccountId>) {
        assert_one_yocto();
        self.assert_contract_running();
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        for token_id in token_ids {
            account.unregister(token_id.as_ref());
        }
        self.internal_save_account(&sender_id, account);
    }

    /// Withdraws given token from the deposits of given user.
    /// Optional unregister will try to remove record of this token from AccountDeposit for given user.
    /// Unregister will fail if the left over balance is non 0.
    #[payable]
    pub fn withdraw(
        &mut self,
        token_id: ValidAccountId,
        amount: U128,
        unregister: Option<bool>,
    ) -> Promise {
        assert_one_yocto();
        self.assert_contract_running();
        let token_id: AccountId = token_id.into();
        let amount: u128 = amount.into();
        assert!(amount > 0, "{}", ERR29_ILLEGAL_WITHDRAW_AMOUNT);
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        // Note: subtraction and deregistration will be reverted if the promise fails.
        account.withdraw(&token_id, amount);
        if unregister == Some(true) {
            account.unregister(&token_id);
        }
        self.internal_save_account(&sender_id, account);
        self.internal_send_tokens(&sender_id, &token_id, amount)
    }

    #[private]
    pub fn exchange_callback_post_withdraw(
        &mut self,
        token_id: AccountId,
        sender_id: AccountId,
        amount: U128,
    ) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "{}",
            ERR25_CALLBACK_POST_WITHDRAW_INVALID
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {}
            PromiseResult::Failed => {
                // This reverts the changes from withdraw function.
                // If account doesn't exit, deposits to the owner's account as lostfound.
                let mut failed = false;
                if let Some(mut account) = self.internal_get_account(&sender_id) {
                    if account.deposit_with_storage_check(&token_id, amount.0) {
                        // cause storage already checked, here can directly save
                        self.accounts.insert(&sender_id, &account.into());
                    } else {
                        // we can ensure that internal_get_account here would NOT cause a version upgrade, 
                        // cause it is callback, the account must be the current version or non-exist,
                        // so, here we can just leave it without insert, won't cause storage collection inconsistency.
                        env::log(
                            format!(
                                "Account {} has not enough storage. Depositing to owner.",
                                sender_id
                            )
                            .as_bytes(),
                        );
                        failed = true;
                    }
                } else {
                    env::log(
                        format!(
                            "Account {} is not registered. Depositing to owner.",
                            sender_id
                        )
                        .as_bytes(),
                    );
                    failed = true;
                }
                if failed {
                    self.internal_lostfound(&token_id, amount.0);
                }
            }
        };
    }
}

impl Contract {

    /// Checks that account has enough storage to be stored and saves it into collection.
    /// This should be only place to directly use `self.accounts`.
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: Account) {
        account.assert_storage_usage();
        self.accounts.insert(&account_id, &account.into());
    }

    /// save token to owner account as lostfound, no need to care about storage
    /// only global whitelisted token can be stored in lost-found
    pub(crate) fn internal_lostfound(&mut self, token_id: &AccountId, amount: u128) {
        if self.whitelisted_tokens.contains(token_id) {
            let mut lostfound = self.internal_unwrap_or_default_account(&self.owner_id);
            lostfound.deposit(token_id, amount);
            self.accounts.insert(&self.owner_id, &lostfound.into());
        } else {
            env::panic("ERR: non-whitelisted token can NOT deposit into lost-found.".as_bytes());
        }
        
    }
    

    /// Registers account in deposited amounts with given amount of $NEAR.
    /// If account already exists, adds amount to it.
    /// This should be used when it's known that storage is prepaid.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.internal_unwrap_or_default_account(&account_id);
        account.near_amount += amount;
        self.internal_save_account(&account_id, account);
    }

    /// storage withdraw
    pub(crate) fn internal_storage_withdraw(&mut self, account_id: &AccountId, amount: Balance) -> u128 {
        let mut account = self.internal_unwrap_account(&account_id);
        let available = account.storage_available();
        assert!(available > 0, "ERR_NO_STORAGE_CAN_WITHDRAW");
        let mut withdraw_amount = amount;
        if amount == 0 {
            withdraw_amount = available;
        }
        assert!(withdraw_amount <= available, "ERR_STORAGE_WITHDRAW_TOO_MUCH");
        account.near_amount -= withdraw_amount;
        self.internal_save_account(&account_id, account);
        withdraw_amount
    }

    /// Record deposit of some number of tokens to this contract.
    /// Fails if account is not registered or if token isn't whitelisted.
    pub(crate) fn internal_deposit(
        &mut self,
        sender_id: &AccountId,
        token_id: &AccountId,
        amount: Balance,
    ) {
        let mut account = self.internal_unwrap_account(sender_id);
        assert!(
            self.whitelisted_tokens.contains(token_id) 
                || account.get_balance(token_id).is_some(),
            "{}",
            ERR12_TOKEN_NOT_WHITELISTED
        );
        account.deposit(token_id, amount);
        self.internal_save_account(&sender_id, account);
    }

    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts
            .get(account_id)
            .map(|va| va.into_current(account_id))
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect(errors::ERR10_ACC_NOT_REGISTERED)
    }

    pub fn internal_unwrap_or_default_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .unwrap_or_else(|| Account::new(account_id))
    }

    /// Returns current balance of given token for given user. If there is nothing recorded, returns 0.
    pub(crate) fn internal_get_deposit(
        &self,
        sender_id: &AccountId,
        token_id: &AccountId,
    ) -> Balance {
        self.internal_get_account(sender_id)
            .and_then(|x| x.get_balance(token_id))
            .unwrap_or(0)
    }

    /// Sends given amount to given user and if it fails, returns it back to user's balance.
    /// Tokens must already be subtracted from internal balance.
    pub(crate) fn internal_send_tokens(
        &self,
        sender_id: &AccountId,
        token_id: &AccountId,
        amount: Balance,
    ) -> Promise {
        ext_fungible_token::ft_transfer(
            sender_id.clone(),
            U128(amount),
            None,
            token_id,
            1,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::exchange_callback_post_withdraw(
            token_id.clone(),
            sender_id.clone(),
            U128(amount),
            &env::current_account_id(),
            0,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
    }
}

'''
'''--- ref-exchange/src/action.rs ---
use crate::errors::ERR41_WRONG_ACTION_RESULT;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, json_types::U128, AccountId, Balance};

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapAction {
    /// Pool which should be used for swapping.
    pub pool_id: u64,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Action {
    Swap(SwapAction),
}

impl Action {
    /// Returns involved tokens in this action. Useful for checking permissions and storage.
    pub fn tokens(&self) -> Vec<AccountId> {
        match self {
            Action::Swap(swap_action) => {
                vec![swap_action.token_in.clone(), swap_action.token_out.clone()]
            }
        }
    }
}

/// Result from action execution.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ActionResult {
    /// No result.
    None,
    /// Amount of token was received.
    /// [AUDIT_02]
    Amount(U128),
}

impl ActionResult {
    pub fn to_amount(self) -> Balance {
        match self {
            // [AUDIT_02]
            ActionResult::Amount(result) => result.0,
            _ => env::panic(ERR41_WRONG_ACTION_RESULT.as_bytes()),
        }
    }
}

'''
'''--- ref-exchange/src/admin_fee.rs ---
use near_sdk::{env, AccountId};

/// Maintain information about fees.
pub struct AdminFees {
    /// Basis points of the fee for exchange.
    pub exchange_fee: u32,
    /// Basis points of the fee for referrer.
    pub referral_fee: u32,
    pub exchange_id: AccountId,
    pub referral_id: Option<AccountId>,
}

impl AdminFees {
    pub fn new(exchange_fee: u32) -> Self {
        AdminFees {
            exchange_fee,
            exchange_id: env::current_account_id(),
            referral_fee: 0,
            referral_id: None,
        }
    }

    pub fn zero() -> Self {
        Self::new(0)
    }
}

'''
'''--- ref-exchange/src/errors.rs ---
// Storage errors.

pub const ERR10_ACC_NOT_REGISTERED: &str = "E10: account not registered";
pub const ERR11_INSUFFICIENT_STORAGE: &str = "E11: insufficient $NEAR storage deposit";
pub const ERR12_TOKEN_NOT_WHITELISTED: &str = "E12: token not whitelisted";
pub const ERR13_LP_NOT_REGISTERED: &str = "E13: LP not registered";
pub const ERR14_LP_ALREADY_REGISTERED: &str = "E14: LP already registered";

// Accounts.

pub const ERR21_TOKEN_NOT_REG: &str = "E21: token not registered";
pub const ERR22_NOT_ENOUGH_TOKENS: &str = "E22: not enough tokens in deposit";
// pub const ERR23_NOT_ENOUGH_NEAR: &str = "E23: not enough NEAR in deposit";
pub const ERR24_NON_ZERO_TOKEN_BALANCE: &str = "E24: non-zero token balance";
pub const ERR25_CALLBACK_POST_WITHDRAW_INVALID: &str =
    "E25: expected 1 promise result from withdraw";
// [AUDIT_05]
// pub const ERR26_ACCESS_KEY_NOT_ALLOWED: &str = "E26: access key not allowed";
pub const ERR27_DEPOSIT_NEEDED: &str = 
    "E27: attach 1yN to swap tokens not in whitelist";
pub const ERR28_WRONG_MSG_FORMAT: &str = "E28: Illegal msg in ft_transfer_call";
pub const ERR29_ILLEGAL_WITHDRAW_AMOUNT: &str = "E29: Illegal withdraw amount";

// Liquidity operations.

pub const ERR31_ZERO_AMOUNT: &str = "E31: adding zero amount";
pub const ERR32_ZERO_SHARES: &str = "E32: minting zero shares";
// [AUDIT_07]
pub const ERR33_TRANSFER_TO_SELF: &str = "E33: transfer to self";
pub const ERR34_INSUFFICIENT_LP_SHARES: &str = "E34: insufficient lp shares";

// Action result.

pub const ERR41_WRONG_ACTION_RESULT: &str = "E41: wrong action result type";

// Contract Level
pub const ERR51_CONTRACT_PAUSED: &str = "E51: contract paused";

// Swap
pub const ERR60_DECIMAL_ILLEGAL: &str = "E60: illegal decimal";
pub const ERR61_AMP_ILLEGAL: &str = "E61: illegal amp";
pub const ERR62_FEE_ILLEGAL: &str = "E62: illegal fee";
pub const ERR63_MISSING_TOKEN: &str = "E63: missing token";
pub const ERR64_TOKENS_COUNT_ILLEGAL: &str = "E64: illegal tokens count";
pub const ERR65_INIT_TOKEN_BALANCE: &str = "E65: init token balance should be non-zero";
pub const ERR66_INVARIANT_CALC_ERR: &str = "E66: encounter err when calc invariant D";
pub const ERR67_LPSHARE_CALC_ERR: &str = "E67: encounter err when calc lp shares";
pub const ERR68_SLIPPAGE: &str = "E68: slippage error";
pub const ERR69_MIN_RESERVE: &str = "E69: pool reserved token balance less than MIN_RESERVE";
pub const ERR70_SWAP_OUT_CALC_ERR: &str = "E70: encounter err when calc swap out";
pub const ERR71_SWAP_DUP_TOKENS: &str = "E71: illegal swap with duplicated tokens";

// pool manage
pub const ERR81_AMP_IN_LOCK: &str = "E81: amp is currently in lock";
pub const ERR82_INSUFFICIENT_RAMP_TIME: &str = "E82: insufficient ramp time";
pub const ERR83_INVALID_AMP_FACTOR: &str = "E83: invalid amp factor";
pub const ERR84_AMP_LARGE_CHANGE: &str = "E84: amp factor change is too large";

// Permissions
pub const ERR100_NOT_ALLOWED: &str = "E100: no permission to invoke this";

'''
'''--- ref-exchange/src/legacy.rs ---
//! This modules captures all the code needed to migrate from previous version.
use std::collections::HashMap;
use near_sdk::collections::{UnorderedMap, Vector, LookupMap, UnorderedSet};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId, Balance, StorageUsage, near_bindgen, PanicOnDefault};
use crate::account_deposit::{Account, VAccount};
use crate::StorageKey;
use crate::pool::Pool;

/// Account deposits information and storage cost.
#[derive(BorshSerialize, BorshDeserialize, Default, Clone)]
pub struct AccountV1 {
    /// Native NEAR amount sent to the exchange.
    /// Used for storage right now, but in future can be used for trading as well.
    pub near_amount: Balance,
    /// Amounts of various tokens deposited to this account.
    pub tokens: HashMap<AccountId, Balance>,
    pub storage_used: StorageUsage,
}

impl AccountV1 {
    pub fn into_current(&self, account_id: &AccountId) -> Account {
        Account {
            near_amount: self.near_amount,
            legacy_tokens: self.tokens.clone(),
            tokens: UnorderedMap::new(StorageKey::AccountTokens {
                account_id: account_id.clone(),
            }),
            storage_used: self.storage_used,
        }
    }
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct ContractV1 {
    /// Account of the owner.
    pub owner_id: AccountId,
    /// Exchange fee, that goes to exchange itself (managed by governance).
    pub exchange_fee: u32,
    /// Referral fee, that goes to referrer in the call.
    pub referral_fee: u32,
    /// List of all the pools.
    pub pools: Vector<Pool>,
    /// Accounts registered, keeping track all the amounts deposited, storage and more.
    pub accounts: LookupMap<AccountId, VAccount>,
    /// Set of whitelisted tokens by "owner".
    pub whitelisted_tokens: UnorderedSet<AccountId>,
}

'''
'''--- ref-exchange/src/lib.rs ---
use std::convert::TryInto;
use std::fmt;

use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, Vector};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    assert_one_yocto, env, log, near_bindgen, AccountId, Balance, PanicOnDefault, Promise,
    PromiseResult, StorageUsage, BorshStorageKey
};

use crate::account_deposit::{VAccount, Account};
pub use crate::action::SwapAction;
use crate::action::{Action, ActionResult};
use crate::errors::*;
use crate::admin_fee::AdminFees;
use crate::pool::Pool;
use crate::simple_pool::SimplePool;
use crate::stable_swap::StableSwapPool;
use crate::utils::check_token_duplicates;
pub use crate::views::{PoolInfo, ContractMetadata};

mod account_deposit;
mod action;
mod errors;
mod admin_fee;
mod legacy;
mod multi_fungible_token;
mod owner;
mod pool;
mod simple_pool;
mod stable_swap;
mod storage_impl;
mod token_receiver;
mod utils;
mod views;

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Pools,
    Accounts,
    Shares { pool_id: u32 },
    Whitelist,
    Guardian,
    AccountTokens {account_id: AccountId},
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum RunningState {
    Running, Paused
}

impl fmt::Display for RunningState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RunningState::Running => write!(f, "Running"),
            RunningState::Paused => write!(f, "Paused"),
        }
    }
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    /// Account of the owner.
    owner_id: AccountId,
    /// Exchange fee, that goes to exchange itself (managed by governance).
    exchange_fee: u32,
    /// Referral fee, that goes to referrer in the call.
    referral_fee: u32,
    /// List of all the pools.
    pools: Vector<Pool>,
    /// Accounts registered, keeping track all the amounts deposited, storage and more.
    accounts: LookupMap<AccountId, VAccount>,
    /// Set of whitelisted tokens by "owner".
    whitelisted_tokens: UnorderedSet<AccountId>,
    /// Set of guardians.
    guardians: UnorderedSet<AccountId>,
    /// Running state
    state: RunningState,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId, exchange_fee: u32, referral_fee: u32) -> Self {
        Self {
            owner_id: owner_id.as_ref().clone(),
            exchange_fee,
            referral_fee,
            pools: Vector::new(StorageKey::Pools),
            accounts: LookupMap::new(StorageKey::Accounts),
            whitelisted_tokens: UnorderedSet::new(StorageKey::Whitelist),
            guardians: UnorderedSet::new(StorageKey::Guardian),
            state: RunningState::Running,
        }
    }

    /// Adds new "Simple Pool" with given tokens and given fee.
    /// Attached NEAR should be enough to cover the added storage.
    #[payable]
    pub fn add_simple_pool(&mut self, tokens: Vec<ValidAccountId>, fee: u32) -> u64 {
        self.assert_contract_running();
        check_token_duplicates(&tokens);
        self.internal_add_pool(Pool::SimplePool(SimplePool::new(
            self.pools.len() as u32,
            tokens,
            fee,
            0,
            0,
        )))
    }

    /// Adds new "Stable Pool" with given tokens, decimals, fee and amp.
    /// It is limited to owner or guardians, cause a complex and correct config is needed.
    /// tokens: pool tokens in this stable swap.
    /// decimals: each pool tokens decimal, needed to make them comparable.
    /// fee: total fee of the pool, admin fee is inclusive.
    /// amp_factor: algorithm parameter, decide how stable the pool will be.
    #[payable]
    pub fn add_stable_swap_pool(
        &mut self,
        tokens: Vec<ValidAccountId>,
        decimals: Vec<u8>,
        fee: u32,
        amp_factor: u64,
    ) -> u64 {
        assert!(self.is_owner_or_guardians(), "{}", ERR100_NOT_ALLOWED);
        check_token_duplicates(&tokens);
        self.internal_add_pool(Pool::StableSwapPool(StableSwapPool::new(
            self.pools.len() as u32,
            tokens,
            decimals,
            amp_factor as u128,
            fee,
        )))
    }

    /// [AUDIT_03_reject(NOPE action is allowed by design)]
    /// [AUDIT_04]
    /// Executes generic set of actions.
    /// If referrer provided, pays referral_fee to it.
    /// If no attached deposit, outgoing tokens used in swaps must be whitelisted.
    #[payable]
    pub fn execute_actions(
        &mut self,
        actions: Vec<Action>,
        referral_id: Option<ValidAccountId>,
    ) -> ActionResult {
        self.assert_contract_running();
        let sender_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&sender_id);
        // Validate that all tokens are whitelisted if no deposit (e.g. trade with access key).
        if env::attached_deposit() == 0 {
            for action in &actions {
                for token in action.tokens() {
                    assert!(
                        account.get_balance(&token).is_some() 
                            || self.whitelisted_tokens.contains(&token),
                        "{}",
                        // [AUDIT_05]
                        ERR27_DEPOSIT_NEEDED
                    );
                }
            }
        }
        let referral_id = referral_id.map(|r| r.into());
        let result =
            self.internal_execute_actions(&mut account, &referral_id, &actions, ActionResult::None);
        self.internal_save_account(&sender_id, account);
        result
    }

    /// Execute set of swap actions between pools.
    /// If referrer provided, pays referral_fee to it.
    /// If no attached deposit, outgoing tokens used in swaps must be whitelisted.
    #[payable]
    pub fn swap(&mut self, actions: Vec<SwapAction>, referral_id: Option<ValidAccountId>) -> U128 {
        self.assert_contract_running();
        assert_ne!(actions.len(), 0, "ERR_AT_LEAST_ONE_SWAP");
        U128(
            self.execute_actions(
                actions
                    .into_iter()
                    .map(|swap_action| Action::Swap(swap_action))
                    .collect(),
                referral_id,
            )
            .to_amount(),
        )
    }

    /// Add liquidity from already deposited amounts to given pool.
    #[payable]
    pub fn add_liquidity(
        &mut self,
        pool_id: u64,
        amounts: Vec<U128>,
        min_amounts: Option<Vec<U128>>,
    ) {
        self.assert_contract_running();
        assert!(
            env::attached_deposit() > 0,
            "Requires attached deposit of at least 1 yoctoNEAR"
        );
        let prev_storage = env::storage_usage();
        let sender_id = env::predecessor_account_id();
        let mut amounts: Vec<u128> = amounts.into_iter().map(|amount| amount.into()).collect();
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        // Add amounts given to liquidity first. It will return the balanced amounts.
        pool.add_liquidity(
            &sender_id,
            &mut amounts,
        );
        if let Some(min_amounts) = min_amounts {
            // Check that all amounts are above request min amounts in case of front running that changes the exchange rate.
            for (amount, min_amount) in amounts.iter().zip(min_amounts.iter()) {
                assert!(amount >= &min_amount.0, "ERR_MIN_AMOUNT");
            }
        }
        let mut deposits = self.internal_unwrap_or_default_account(&sender_id);
        let tokens = pool.tokens();
        // Subtract updated amounts from deposits. This will fail if there is not enough funds for any of the tokens.
        for i in 0..tokens.len() {
            deposits.withdraw(&tokens[i], amounts[i]);
        }
        self.internal_save_account(&sender_id, deposits);
        self.pools.replace(pool_id, &pool);
        self.internal_check_storage(prev_storage);
    }

    /// For stable swap pool, user can add liquidity with token's combination as his will.
    /// But there is a little fee according to the bias of token's combination with the one in the pool.
    /// pool_id: stable pool id. If simple pool is given, panic with unimplement.
    /// amounts: token's combination (in pool tokens sequence) user want to add into the pool, a 0 means absent of that token.
    /// min_shares: Slippage, if shares mint is less than it (cause of fee for too much bias), panic with  ERR68_SLIPPAGE
    #[payable]
    pub fn add_stable_liquidity(
        &mut self,
        pool_id: u64,
        amounts: Vec<U128>,
        min_shares: U128,
    ) -> U128 {
        self.assert_contract_running();
        assert!(
            env::attached_deposit() > 0,
            "Requires attached deposit of at least 1 yoctoNEAR"
        );
        let prev_storage = env::storage_usage();
        let sender_id = env::predecessor_account_id();
        let amounts: Vec<u128> = amounts.into_iter().map(|amount| amount.into()).collect();
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        // Add amounts given to liquidity first. It will return the balanced amounts.
        let mint_shares = pool.add_stable_liquidity(
            &sender_id,
            &amounts,
            min_shares.into(),
            AdminFees::new(self.exchange_fee),
        );
        let mut deposits = self.internal_unwrap_or_default_account(&sender_id);
        let tokens = pool.tokens();
        // Subtract amounts from deposits. This will fail if there is not enough funds for any of the tokens.
        for i in 0..tokens.len() {
            deposits.withdraw(&tokens[i], amounts[i]);
        }
        self.internal_save_account(&sender_id, deposits);
        self.pools.replace(pool_id, &pool);
        self.internal_check_storage(prev_storage);

        mint_shares.into()
    }

    /// Remove liquidity from the pool into general pool of liquidity.
    #[payable]
    pub fn remove_liquidity(&mut self, pool_id: u64, shares: U128, min_amounts: Vec<U128>) {
        assert_one_yocto();
        self.assert_contract_running();
        let prev_storage = env::storage_usage();
        let sender_id = env::predecessor_account_id();
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        let amounts = pool.remove_liquidity(
            &sender_id,
            shares.into(),
            min_amounts
                .into_iter()
                .map(|amount| amount.into())
                .collect(),
        );
        self.pools.replace(pool_id, &pool);
        let tokens = pool.tokens();
        let mut deposits = self.internal_unwrap_or_default_account(&sender_id);
        for i in 0..tokens.len() {
            deposits.deposit(&tokens[i], amounts[i]);
        }
        // Freed up storage balance from LP tokens will be returned to near_balance.
        if prev_storage > env::storage_usage() {
            deposits.near_amount +=
                (prev_storage - env::storage_usage()) as Balance * env::storage_byte_cost();
        }
        self.internal_save_account(&sender_id, deposits);
    }

    /// For stable swap pool, LP can use it to remove liquidity with given token amount and distribution.
    /// pool_id: the stable swap pool id. If simple pool is given, panic with Unimplement.
    /// amounts: Each tokens (in pool tokens sequence) amounts user want get, a 0 means user don't want to get that token back.
    /// max_burn_shares: This is slippage protection, if user request would burn shares more than it, panic with ERR68_SLIPPAGE
    #[payable]
    pub fn remove_liquidity_by_tokens(
        &mut self, pool_id: u64, 
        amounts: Vec<U128>, 
        max_burn_shares: U128
    ) -> U128 {
        assert_one_yocto();
        self.assert_contract_running();
        let prev_storage = env::storage_usage();
        let sender_id = env::predecessor_account_id();
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        let burn_shares = pool.remove_liquidity_by_tokens(
            &sender_id,
            amounts
                .clone()
                .into_iter()
                .map(|amount| amount.into())
                .collect(),
            max_burn_shares.into(),
            AdminFees::new(self.exchange_fee),
        );
        self.pools.replace(pool_id, &pool);
        let tokens = pool.tokens();
        let mut deposits = self.internal_unwrap_or_default_account(&sender_id);
        for i in 0..tokens.len() {
            deposits.deposit(&tokens[i], amounts[i].into());
        }
        // Freed up storage balance from LP tokens will be returned to near_balance.
        if prev_storage > env::storage_usage() {
            deposits.near_amount +=
                (prev_storage - env::storage_usage()) as Balance * env::storage_byte_cost();
        }
        self.internal_save_account(&sender_id, deposits);

        burn_shares.into()
    }
}

/// Internal methods implementation.
impl Contract {

    fn assert_contract_running(&self) {
        match self.state {
            RunningState::Running => (),
            _ => env::panic(ERR51_CONTRACT_PAUSED.as_bytes()),
        };
    }

    /// Check how much storage taken costs and refund the left over back.
    fn internal_check_storage(&self, prev_storage: StorageUsage) {
        let storage_cost = env::storage_usage()
            .checked_sub(prev_storage)
            .unwrap_or_default() as Balance
            * env::storage_byte_cost();

        let refund = env::attached_deposit()
            .checked_sub(storage_cost)
            .expect(
                format!(
                    "ERR_STORAGE_DEPOSIT need {}, attatched {}", 
                    storage_cost, env::attached_deposit()
                ).as_str()
            );
        if refund > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }
    }

    /// Adds given pool to the list and returns it's id.
    /// If there is not enough attached balance to cover storage, fails.
    /// If too much attached - refunds it back.
    fn internal_add_pool(&mut self, mut pool: Pool) -> u64 {
        let prev_storage = env::storage_usage();
        let id = self.pools.len() as u64;
        // exchange share was registered at creation time
        pool.share_register(&env::current_account_id());
        self.pools.push(&pool);
        self.internal_check_storage(prev_storage);
        id
    }

    /// Execute sequence of actions on given account. Modifies passed account.
    /// Returns result of the last action.
    fn internal_execute_actions(
        &mut self,
        account: &mut Account,
        referral_id: &Option<AccountId>,
        actions: &[Action],
        prev_result: ActionResult,
    ) -> ActionResult {
        let mut result = prev_result;
        for action in actions {
            result = self.internal_execute_action(account, referral_id, action, result);
        }
        result
    }

    /// Executes single action on given account. Modifies passed account. Returns a result based on type of action.
    fn internal_execute_action(
        &mut self,
        account: &mut Account,
        referral_id: &Option<AccountId>,
        action: &Action,
        prev_result: ActionResult,
    ) -> ActionResult {
        match action {
            Action::Swap(swap_action) => {
                let amount_in = swap_action
                    .amount_in
                    .map(|value| value.0)
                    .unwrap_or_else(|| prev_result.to_amount());
                account.withdraw(&swap_action.token_in, amount_in);
                let amount_out = self.internal_pool_swap(
                    swap_action.pool_id,
                    &swap_action.token_in,
                    amount_in,
                    &swap_action.token_out,
                    swap_action.min_amount_out.0,
                    referral_id,
                );
                account.deposit(&swap_action.token_out, amount_out);
                // [AUDIT_02]
                ActionResult::Amount(U128(amount_out))
            }
        }
    }

    /// Swaps given amount_in of token_in into token_out via given pool.
    /// Should be at least min_amount_out or swap will fail (prevents front running and other slippage issues).
    fn internal_pool_swap(
        &mut self,
        pool_id: u64,
        token_in: &AccountId,
        amount_in: u128,
        token_out: &AccountId,
        min_amount_out: u128,
        referral_id: &Option<AccountId>,
    ) -> u128 {
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        let amount_out = pool.swap(
            token_in,
            amount_in,
            token_out,
            min_amount_out,
            AdminFees {
                exchange_fee: self.exchange_fee,
                exchange_id: env::current_account_id(),
                referral_fee: self.referral_fee,
                referral_id: referral_id.clone(),
            },
        );
        self.pools.replace(pool_id, &pool);
        amount_out
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, Balance, MockedBlockchain};
    use near_sdk_sim::to_yocto;

    use super::*;

    /// Creates contract and a pool with tokens with 0.3% of total fee.
    fn setup_contract() -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let contract = Contract::new(accounts(0), 1600, 400);
        (context, contract)
    }

    fn deposit_tokens(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        account_id: ValidAccountId,
        token_amounts: Vec<(ValidAccountId, Balance)>,
    ) {
        if contract.storage_balance_of(account_id.clone()).is_none() {
            testing_env!(context
                .predecessor_account_id(account_id.clone())
                .attached_deposit(to_yocto("1"))
                .build());
            contract.storage_deposit(None, None);
        }
        testing_env!(context
            .predecessor_account_id(account_id.clone())
            .attached_deposit(to_yocto("1"))
            .build());
        let tokens = token_amounts
            .iter()
            .map(|(token_id, _)| token_id.clone().into())
            .collect();
        testing_env!(context.attached_deposit(1).build());
        contract.register_tokens(tokens);
        for (token_id, amount) in token_amounts {
            testing_env!(context
                .predecessor_account_id(token_id)
                .attached_deposit(1)
                .build());
            contract.ft_on_transfer(account_id.clone(), U128(amount), "".to_string());
        }
    }

    fn create_pool_with_liquidity(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        account_id: ValidAccountId,
        token_amounts: Vec<(ValidAccountId, Balance)>,
    ) -> u64 {
        let tokens = token_amounts
            .iter()
            .map(|(x, _)| x.clone())
            .collect::<Vec<_>>();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        contract.extend_whitelisted_tokens(tokens.clone());
        testing_env!(context
            .predecessor_account_id(account_id.clone())
            .attached_deposit(env::storage_byte_cost() * 300)
            .build());
        let pool_id = contract.add_simple_pool(tokens, 25);
        testing_env!(context
            .predecessor_account_id(account_id.clone())
            .attached_deposit(to_yocto("0.03"))
            .build());
        contract.storage_deposit(None, None);
        deposit_tokens(context, contract, accounts(3), token_amounts.clone());
        testing_env!(context
            .predecessor_account_id(account_id.clone())
            .attached_deposit(to_yocto("0.0007"))
            .build());
        contract.add_liquidity(
            pool_id,
            token_amounts.into_iter().map(|(_, x)| U128(x)).collect(),
            None,
        );
        pool_id
    }

    fn swap(
        contract: &mut Contract,
        pool_id: u64,
        token_in: ValidAccountId,
        amount_in: Balance,
        token_out: ValidAccountId,
    ) -> Balance {
        contract
            .swap(
                vec![SwapAction {
                    pool_id,
                    token_in: token_in.into(),
                    amount_in: Some(U128(amount_in)),
                    token_out: token_out.into(),
                    min_amount_out: U128(1),
                }],
                None,
            )
            .0
    }

    #[test]
    fn test_basics() {
        let one_near = 10u128.pow(24);
        let (mut context, mut contract) = setup_contract();
        // add liquidity of (1,2) tokens
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![(accounts(1), to_yocto("5")), (accounts(2), to_yocto("10"))],
        );
        deposit_tokens(
            &mut context,
            &mut contract,
            accounts(3),
            vec![
                (accounts(1), to_yocto("100")),
                (accounts(2), to_yocto("100")),
            ],
        );
        deposit_tokens(&mut context, &mut contract, accounts(1), vec![]);

        assert_eq!(
            contract.get_deposit(accounts(3), accounts(1)),
            to_yocto("100").into()
        );
        assert_eq!(
            contract.get_deposit(accounts(3), accounts(2)),
            to_yocto("100").into()
        );
        assert_eq!(
            contract.get_pool_total_shares(0).0,
            crate::utils::INIT_SHARES_SUPPLY
        );

        // Get price from pool :0 1 -> 2 tokens.
        let expected_out = contract.get_return(0, accounts(1), one_near.into(), accounts(2));
        assert_eq!(expected_out.0, 1663192997082117548978741);

        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());
        let amount_out = swap(&mut contract, 0, accounts(1), one_near, accounts(2));
        assert_eq!(amount_out, expected_out.0);
        assert_eq!(
            contract.get_deposit(accounts(3), accounts(1)).0,
            99 * one_near
        );
        // transfer some of token_id 2 from acc 3 to acc 1.
        testing_env!(context.predecessor_account_id(accounts(3)).build());
        contract.mft_transfer(accounts(2).to_string(), accounts(1), U128(one_near), None);
        assert_eq!(
            contract.get_deposit(accounts(3), accounts(2)).0,
            99 * one_near + amount_out
        );
        assert_eq!(contract.get_deposit(accounts(1), accounts(2)).0, one_near);

        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(to_yocto("0.0067"))
            .build());
        contract.mft_register(":0".to_string(), accounts(1));
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());
        // transfer 1m shares in pool 0 to acc 1.
        contract.mft_transfer(":0".to_string(), accounts(1), U128(1_000_000), None);

        testing_env!(context.predecessor_account_id(accounts(3)).build());
        contract.remove_liquidity(
            0,
            contract.get_pool_shares(0, accounts(3)),
            vec![1.into(), 2.into()],
        );
        // Exchange fees left in the pool as liquidity + 1m from transfer.
        assert_eq!(
            contract.get_pool_total_shares(0).0,
            33336806279123620258 + 1_000_000
        );

        contract.withdraw(
            accounts(1),
            contract.get_deposit(accounts(3), accounts(1)),
            None,
        );
        assert_eq!(contract.get_deposit(accounts(3), accounts(1)).0, 0);
    }

    /// Test liquidity management.
    #[test]
    fn test_liquidity() {
        let (mut context, mut contract) = setup_contract();
        deposit_tokens(
            &mut context,
            &mut contract,
            accounts(3),
            vec![
                (accounts(1), to_yocto("100")),
                (accounts(2), to_yocto("100")),
            ],
        );
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(to_yocto("1"))
            .build());
        let id = contract.add_simple_pool(vec![accounts(1), accounts(2)], 25);
        testing_env!(context.attached_deposit(to_yocto("0.0007")).build());
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("10"))], None);
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("50"))], None);
        testing_env!(context.attached_deposit(1).build());
        contract.remove_liquidity(id, U128(to_yocto("1")), vec![U128(1), U128(1)]);

        // Check that amounts add up to deposits.
        let amounts = contract.get_pool(id).amounts;
        let deposit1 = contract.get_deposit(accounts(3), accounts(1)).0;
        let deposit2 = contract.get_deposit(accounts(3), accounts(2)).0;
        assert_eq!(amounts[0].0 + deposit1, to_yocto("100"));
        assert_eq!(amounts[1].0 + deposit2, to_yocto("100"));
    }

    /// Should deny creating a pool with duplicate tokens.
    #[test]
    #[should_panic(expected = "ERR_TOKEN_DUPLICATES")]
    fn test_deny_duplicate_tokens_pool() {
        let (mut context, mut contract) = setup_contract();
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![(accounts(1), to_yocto("5")), (accounts(1), to_yocto("10"))],
        );
    }

    /// Deny pool with a single token
    #[test]
    #[should_panic(expected = "ERR_SHOULD_HAVE_2_TOKENS")]
    fn test_deny_single_token_pool() {
        let (mut context, mut contract) = setup_contract();
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![(accounts(1), to_yocto("5"))],
        );
    }

    /// Deny pool with a single token
    #[test]
    #[should_panic(expected = "ERR_SHOULD_HAVE_2_TOKENS")]
    fn test_deny_too_many_tokens_pool() {
        let (mut context, mut contract) = setup_contract();
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![
                (accounts(1), to_yocto("5")),
                (accounts(2), to_yocto("10")),
                (accounts(3), to_yocto("10")),
            ],
        );
    }

    #[test]
    #[should_panic(expected = "E12: token not whitelisted")]
    fn test_deny_send_malicious_token() {
        let (mut context, mut contract) = setup_contract();
        let acc = ValidAccountId::try_from("test_user").unwrap();
        testing_env!(context
            .predecessor_account_id(acc.clone())
            .attached_deposit(to_yocto("1"))
            .build());
        contract.storage_deposit(Some(acc.clone()), None);
        testing_env!(context
            .predecessor_account_id(ValidAccountId::try_from("malicious").unwrap())
            .build());
        contract.ft_on_transfer(acc, U128(1_000), "".to_string());
    }

    #[test]
    fn test_send_user_specific_token() {
        let (mut context, mut contract) = setup_contract();
        let acc = ValidAccountId::try_from("test_user").unwrap();
        let custom_token = ValidAccountId::try_from("custom").unwrap();
        testing_env!(context
            .predecessor_account_id(acc.clone())
            .attached_deposit(to_yocto("1"))
            .build());
        contract.storage_deposit(None, None);
        testing_env!(context.attached_deposit(1).build());
        contract.register_tokens(vec![custom_token.clone()]);
        testing_env!(context.predecessor_account_id(custom_token.clone()).build());
        contract.ft_on_transfer(acc.clone(), U128(1_000), "".to_string());
        let prev = contract.storage_balance_of(acc.clone()).unwrap();
        testing_env!(context
            .predecessor_account_id(acc.clone())
            .attached_deposit(1)
            .build());
        contract.withdraw(custom_token, U128(1_000), Some(true));
        let new = contract.storage_balance_of(acc.clone()).unwrap();
        // More available storage after withdrawing & unregistering the token.
        assert!(new.available.0 > prev.available.0);
    }

    #[test]
    #[should_panic(expected = "ERR_MIN_AMOUNT")]
    fn test_deny_min_amount() {
        let (mut context, mut contract) = setup_contract();
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![(accounts(1), to_yocto("1")), (accounts(2), to_yocto("1"))],
        );
        let acc = ValidAccountId::try_from("test_user").unwrap();

        deposit_tokens(
            &mut context,
            &mut contract,
            acc.clone(),
            vec![(accounts(1), 1_000_000)],
        );

        testing_env!(context
            .predecessor_account_id(acc.clone())
            .attached_deposit(1)
            .build());
        contract.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: accounts(1).into(),
                amount_in: Some(U128(1_000_000)),
                token_out: accounts(2).into(),
                min_amount_out: U128(1_000_000),
            }],
            None,
        );
    }

    #[test]
    fn test_second_storage_deposit_works() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.storage_deposit(None, None);
        testing_env!(context.attached_deposit(to_yocto("0.001")).build());
        contract.storage_deposit(None, None);
    }

    #[test]
    #[should_panic(expected = "ERR_AT_LEAST_ONE_SWAP")]
    fn test_fail_swap_no_actions() {
        let (mut context, mut contract) = setup_contract();
        testing_env!(context.attached_deposit(to_yocto("1")).build());
        contract.storage_deposit(None, None);
        testing_env!(context.attached_deposit(1).build());
        contract.swap(vec![], None);
    }

    /// Check that can not swap non whitelisted tokens when attaching 0 deposit (access key).
    #[test]
    #[should_panic(expected = "E27: attach 1yN to swap tokens not in whitelist")]
    fn test_fail_swap_not_whitelisted() {
        let (mut context, mut contract) = setup_contract();
        deposit_tokens(
            &mut context,
            &mut contract,
            accounts(0),
            vec![(accounts(1), 2_000_000), (accounts(2), 1_000_000)],
        );
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(0),
            vec![(accounts(1), 1_000_000), (accounts(2), 1_000_000)],
        );
        contract.remove_whitelisted_tokens(vec![accounts(2)]);
        testing_env!(context.attached_deposit(1).build());
        contract.unregister_tokens(vec![accounts(2)]);
        testing_env!(context.attached_deposit(0).build());
        swap(&mut contract, 0, accounts(1), 10, accounts(2));
    }

    #[test]
    fn test_roundtrip_swap() {
        let (mut context, mut contract) = setup_contract();
        create_pool_with_liquidity(
            &mut context,
            &mut contract,
            accounts(3),
            vec![(accounts(1), to_yocto("5")), (accounts(2), to_yocto("10"))],
        );
        let acc = ValidAccountId::try_from("test_user").unwrap();
        deposit_tokens(
            &mut context,
            &mut contract,
            acc.clone(),
            vec![(accounts(1), 1_000_000)],
        );
        testing_env!(context
            .predecessor_account_id(acc.clone())
            .attached_deposit(1)
            .build());
        contract.swap(
            vec![
                SwapAction {
                    pool_id: 0,
                    token_in: accounts(1).into(),
                    amount_in: Some(U128(1_000)),
                    token_out: accounts(2).into(),
                    min_amount_out: U128(1),
                },
                SwapAction {
                    pool_id: 0,
                    token_in: accounts(2).into(),
                    amount_in: None,
                    token_out: accounts(1).into(),
                    min_amount_out: U128(1),
                },
            ],
            None,
        );
        // Roundtrip returns almost everything except 0.25% fee.
        assert_eq!(contract.get_deposit(acc, accounts(1)).0, 1_000_000 - 6);
    }

    #[test]
    #[should_panic(expected = "E14: LP already registered")]
    fn test_lpt_transfer() {
        // account(0) -- swap contract
        // account(1) -- token0 contract
        // account(2) -- token1 contract
        // account(3) -- user account
        // account(4) -- another user account
        let (mut context, mut contract) = setup_contract();
        deposit_tokens(
            &mut context,
            &mut contract,
            accounts(3),
            vec![
                (accounts(1), to_yocto("100")),
                (accounts(2), to_yocto("100")),
            ],
        );
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(to_yocto("1"))
            .build());
        let id = contract.add_simple_pool(vec![accounts(1), accounts(2)], 25);
        testing_env!(context.attached_deposit(to_yocto("0.0007")).build());
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("10"))], None);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("1")
        );
        assert_eq!(contract.mft_total_supply(":0".to_string()).0, to_yocto("1"));
        testing_env!(context.attached_deposit(1).build());
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("50"))], None);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("2")
        );
        assert_eq!(contract.mft_total_supply(":0".to_string()).0, to_yocto("2"));

        // register another user
        testing_env!(context
            .predecessor_account_id(accounts(4))
            .attached_deposit(to_yocto("0.00071"))
            .build());
        contract.mft_register(":0".to_string(), accounts(4));
        // make transfer to him
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());
        contract.mft_transfer(":0".to_string(), accounts(4), U128(to_yocto("1")), None);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("1")
        );
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(4)).0,
            to_yocto("1")
        );
        assert_eq!(contract.mft_total_supply(":0".to_string()).0, to_yocto("2"));
        // remove lpt for account 3
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());
        contract.remove_liquidity(id, U128(to_yocto("0.6")), vec![U128(1), U128(1)]);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("0.4")
        );
        assert_eq!(
            contract.mft_total_supply(":0".to_string()).0,
            to_yocto("1.4")
        );
        // remove lpt for account 4 who got lpt from others
        if contract.storage_balance_of(accounts(4)).is_none() {
            testing_env!(context
                .predecessor_account_id(accounts(4))
                .attached_deposit(to_yocto("1"))
                .build());
            contract.storage_deposit(None, None);
        }
        testing_env!(context
            .predecessor_account_id(accounts(4))
            .attached_deposit(1)
            .build());
        contract.remove_liquidity(id, U128(to_yocto("1")), vec![U128(1), U128(1)]);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(4)).0,
            to_yocto("0")
        );
        assert_eq!(
            contract.mft_total_supply(":0".to_string()).0,
            to_yocto("0.4")
        );

        // [AUDIT_13]
        // should panic cause accounts(4) not removed by a full remove liquidity
        testing_env!(context
            .predecessor_account_id(accounts(4))
            .attached_deposit(to_yocto("0.00071"))
            .build());
        contract.mft_register(":0".to_string(), accounts(4));
    }

    #[test]
    #[should_panic(expected = "E33: transfer to self")]
    fn test_lpt_transfer_self() {
        // [AUDIT_07]
        // account(0) -- swap contract
        // account(1) -- token0 contract
        // account(2) -- token1 contract
        // account(3) -- user account
        let (mut context, mut contract) = setup_contract();
        deposit_tokens(
            &mut context,
            &mut contract,
            accounts(3),
            vec![
                (accounts(1), to_yocto("100")),
                (accounts(2), to_yocto("100")),
            ],
        );
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(to_yocto("1"))
            .build());
        let id = contract.add_simple_pool(vec![accounts(1), accounts(2)], 25);
        testing_env!(context.attached_deposit(to_yocto("0.0007")).build());
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("10"))], None);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("1")
        );
        testing_env!(context.attached_deposit(1).build());
        contract.add_liquidity(id, vec![U128(to_yocto("50")), U128(to_yocto("50"))], None);
        assert_eq!(
            contract.mft_balance_of(":0".to_string(), accounts(3)).0,
            to_yocto("2")
        );

        // make transfer to self
        testing_env!(context
            .predecessor_account_id(accounts(3))
            .attached_deposit(1)
            .build());
        contract.mft_transfer(":0".to_string(), accounts(3), U128(to_yocto("1")), None);
    }
}

'''
'''--- ref-exchange/src/multi_fungible_token.rs ---
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{ext_contract, near_bindgen, Balance, PromiseOrValue};

use crate::utils::{GAS_FOR_FT_TRANSFER_CALL, GAS_FOR_RESOLVE_TRANSFER, NO_DEPOSIT};
use crate::*;

#[ext_contract(ext_self)]
trait MFTTokenResolver {
    fn mft_resolve_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[ext_contract(ext_share_token_receiver)]
pub trait MFTTokenReceiver {
    fn mft_on_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

enum TokenOrPool {
    Token(AccountId),
    Pool(u64),
}

/// [AUDIT_06]
/// This is used to parse token_id fields in mft protocol used in ref,
/// So, if we choose #nn as a partern, should announce it in mft protocol.
/// cause : is not allowed in a normal account id, it can be a partern leading char
fn try_identify_pool_id(token_id: &String) -> Result<u64, &'static str> {
    if token_id.starts_with(":") {
        if let Ok(pool_id) = str::parse::<u64>(&token_id[1..token_id.len()]) {
            Ok(pool_id)
        } else {
            Err("Illegal pool id")
        }
    } else {
        Err("Illegal pool id")
    }
}

fn parse_token_id(token_id: String) -> TokenOrPool {
    if let Ok(pool_id) = try_identify_pool_id(&token_id) {
        TokenOrPool::Pool(pool_id)
    } else {
        TokenOrPool::Token(token_id)
    }
}

#[near_bindgen]
impl Contract {
    fn internal_mft_transfer(
        &mut self,
        token_id: String,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: u128,
        memo: Option<String>,
    ) {
        // [AUDIT_07]
        assert_ne!(sender_id, receiver_id, "{}", ERR33_TRANSFER_TO_SELF);
        match parse_token_id(token_id) {
            TokenOrPool::Pool(pool_id) => {
                let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
                pool.share_transfer(sender_id, receiver_id, amount);
                self.pools.replace(pool_id, &pool);
                log!(
                    "Transfer shares {} pool: {} from {} to {}",
                    pool_id,
                    amount,
                    sender_id,
                    receiver_id
                );
            }
            TokenOrPool::Token(token_id) => {
                let mut sender_account: Account = self.internal_unwrap_account(&sender_id);
                let mut receiver_account: Account = self.internal_unwrap_account(&receiver_id);
                
                sender_account.withdraw(&token_id, amount);
                receiver_account.deposit(&token_id, amount);
                self.internal_save_account(&sender_id, sender_account);
                self.internal_save_account(&receiver_id, receiver_account);
                log!(
                    "Transfer {}: {} from {} to {}",
                    token_id,
                    amount,
                    sender_id,
                    receiver_id
                );
            }
        }
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }
    }

    fn internal_mft_balance(&self, token_id: String, account_id: &AccountId) -> Balance {
        match parse_token_id(token_id) {
            TokenOrPool::Pool(pool_id) => {
                let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
                pool.share_balances(account_id)
            }
            TokenOrPool::Token(token_id) => self.internal_get_deposit(account_id, &token_id),
        }
    }

    /// Returns the balance of the given account. If the account doesn't exist will return `"0"`.
    pub fn mft_balance_of(&self, token_id: String, account_id: ValidAccountId) -> U128 {
        self.internal_mft_balance(token_id, account_id.as_ref())
            .into()
    }

    /// Returns the total supply of the given token, if the token is one of the pools.
    /// If token references external token - fails with unimplemented.
    pub fn mft_total_supply(&self, token_id: String) -> U128 {
        match parse_token_id(token_id) {
            TokenOrPool::Pool(pool_id) => {
                let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
                U128(pool.share_total_balance())
            }
            TokenOrPool::Token(_token_id) => unimplemented!(),
        }
    }

    /// Register LP token of given pool for given account.
    /// Fails if token_id is not a pool.
    #[payable]
    pub fn mft_register(&mut self, token_id: String, account_id: ValidAccountId) {
        self.assert_contract_running();
        let prev_storage = env::storage_usage();
        match parse_token_id(token_id) {
            TokenOrPool::Token(_) => env::panic(b"ERR_INVALID_REGISTER"),
            TokenOrPool::Pool(pool_id) => {
                let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
                pool.share_register(account_id.as_ref());
                self.pools.replace(pool_id, &pool);
                self.internal_check_storage(prev_storage);
            }
        }
    }

    /// Transfer one of internal tokens: LP or balances.
    /// `token_id` can either by account of the token or pool number.
    #[payable]
    pub fn mft_transfer(
        &mut self,
        token_id: String,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
    ) {
        assert_one_yocto();
        self.assert_contract_running();
        self.internal_mft_transfer(
            token_id,
            &env::predecessor_account_id(),
            receiver_id.as_ref(),
            amount.0,
            memo,
        );
    }

    #[payable]
    pub fn mft_transfer_call(
        &mut self,
        token_id: String,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_one_yocto();
        self.assert_contract_running();
        let sender_id = env::predecessor_account_id();
        self.internal_mft_transfer(
            token_id.clone(),
            &sender_id,
            receiver_id.as_ref(),
            amount.0,
            memo,
        );
        ext_share_token_receiver::mft_on_transfer(
            token_id.clone(),
            sender_id.clone(),
            amount,
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::mft_resolve_transfer(
            token_id,
            sender_id,
            receiver_id.into(),
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()
    }

    /// Returns how much was refunded back to the sender.
    /// If sender removed account in the meantime, the tokens are sent to the contract account.
    /// Tokens are never burnt.
    #[private]
    pub fn mft_resolve_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        receiver_id: &AccountId,
        amount: U128,
    ) -> U128 {
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount.0, unused_amount.0)
                } else {
                    amount.0
                }
            }
            PromiseResult::Failed => amount.0,
        };
        if unused_amount > 0 {
            let receiver_balance = self.internal_mft_balance(token_id.clone(), &receiver_id);
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                
                let refund_to = if self.accounts.get(&sender_id).is_some() {
                    sender_id
                } else {
                    // If sender's account was deleted, we assume that they have also withdrew all the liquidity from pools.
                    // Funds are sent to the contract account.
                    env::current_account_id()
                };
                self.internal_mft_transfer(token_id, &receiver_id, &refund_to, refund_amount, None);
            }
        }
        U128(unused_amount)
    }

    pub fn mft_metadata(&self, token_id: String) -> FungibleTokenMetadata {
        match parse_token_id(token_id) {
            TokenOrPool::Pool(pool_id) => {
                let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
                let decimals = pool.get_share_decimal();
                FungibleTokenMetadata {
                    // [AUDIT_08]
                    spec: "mft-1.0.0".to_string(),
                    name: format!("ref-pool-{}", pool_id),
                    symbol: format!("REF-POOL-{}", pool_id),
                    icon: None,
                    reference: None,
                    reference_hash: None,
                    decimals,
                }
            },
            TokenOrPool::Token(_token_id) => unimplemented!(),
        }
    }
}

'''
'''--- ref-exchange/src/owner.rs ---
//! Implement all the relevant logic for owner of this contract.

use near_sdk::json_types::WrappedTimestamp;

use crate::*;
use crate::utils::FEE_DIVISOR;

#[near_bindgen]
impl Contract {
    /// Change owner. Only can be called by owner.
    pub fn set_owner(&mut self, owner_id: ValidAccountId) {
        self.assert_owner();
        self.owner_id = owner_id.as_ref().clone();
    }

    /// Get the owner of this account.
    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Extend guardians. Only can be called by owner.
    #[payable]
    pub fn extend_guardians(&mut self, guardians: Vec<ValidAccountId>) {
        self.assert_owner();
        for guardian in guardians {
            self.guardians.insert(guardian.as_ref());
        }
    }

    /// Remove guardians. Only can be called by owner.
    pub fn remove_guardians(&mut self, guardians: Vec<ValidAccountId>) {
        self.assert_owner();
        for guardian in guardians {
            self.guardians.remove(guardian.as_ref());
        }
    }

    /// Change state of contract, Only can be called by owner or guardians.
    #[payable]
    pub fn change_state(&mut self, state: RunningState) {
        assert_one_yocto();
        assert!(self.is_owner_or_guardians(), "ERR_NOT_ALLOWED");

        if self.state != state {
            if state == RunningState::Running {
                // only owner can resume the contract
                self.assert_owner();
            }
            env::log(
                format!(
                    "Contract state changed from {} to {} by {}",
                    self.state, state, env::predecessor_account_id()
                )
                .as_bytes(),
            );       
            self.state = state;
        }
    }

    /// Extend whitelisted tokens with new tokens. Only can be called by owner.
    #[payable]
    pub fn extend_whitelisted_tokens(&mut self, tokens: Vec<ValidAccountId>) {
        assert!(self.is_owner_or_guardians(), "ERR_NOT_ALLOWED");
        for token in tokens {
            self.whitelisted_tokens.insert(token.as_ref());
        }
    }

    /// Remove whitelisted token. Only can be called by owner.
    pub fn remove_whitelisted_tokens(&mut self, tokens: Vec<ValidAccountId>) {
        assert!(self.is_owner_or_guardians(), "ERR_NOT_ALLOWED");
        for token in tokens {
            self.whitelisted_tokens.remove(token.as_ref());
        }
    }

    pub fn modify_admin_fee(&mut self, exchange_fee: u32, referral_fee: u32) {
        self.assert_owner();
        assert!(exchange_fee + referral_fee <= FEE_DIVISOR, "ERR_ILLEGAL_FEE");
        self.exchange_fee = exchange_fee;
        self.referral_fee = referral_fee;
    }

    /// Remove exchange fee liquidity to owner's inner account.
    /// without any storage and fee.
    #[payable]
    pub fn remove_exchange_fee_liquidity(&mut self, pool_id: u64, shares: U128, min_amounts: Vec<U128>) {
        assert_one_yocto();
        self.assert_owner();
        self.assert_contract_running();
        let ex_id = env::current_account_id();
        let owner_id = self.owner_id.clone();
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        let amounts = pool.remove_liquidity(
            &ex_id,
            shares.into(),
            min_amounts
                .into_iter()
                .map(|amount| amount.into())
                .collect(),
        );
        self.pools.replace(pool_id, &pool);
        let tokens = pool.tokens();
        let mut deposits = self.internal_unwrap_or_default_account(&owner_id);
        for i in 0..tokens.len() {
            deposits.deposit(&tokens[i], amounts[i]);
        }
        self.internal_save_account(&owner_id, deposits);
    }

    /// to eventually change a stable pool's amp factor
    /// pool_id: the target stable pool;
    /// future_amp_factor: the target amp factor, could be less or more than current one;
    /// future_amp_time: the endtime of the increasing or decreasing process;
    pub fn stable_swap_ramp_amp(
        &mut self,
        pool_id: u64,
        future_amp_factor: u64,
        future_amp_time: WrappedTimestamp,
    ) {
        assert!(self.is_owner_or_guardians(), "ERR_NOT_ALLOWED");
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        match &mut pool {
            Pool::StableSwapPool(pool) => {
                pool.ramp_amplification(future_amp_factor as u128, future_amp_time.0)
            }
            _ => env::panic(b"ERR_NOT_STABLE_POOL"),
        }
        self.pools.replace(pool_id, &pool);
    }

    pub fn stable_swap_stop_ramp_amp(&mut self, pool_id: u64) {
        assert!(self.is_owner_or_guardians(), "ERR_NOT_ALLOWED");
        let mut pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        match &mut pool {
            Pool::StableSwapPool(pool) => pool.stop_ramp_amplification(),
            _ => env::panic(b"ERR_NOT_STABLE_POOL"),
        }
        self.pools.replace(pool_id, &pool);
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "ERR_NOT_ALLOWED"
        );
    }

    pub(crate) fn is_owner_or_guardians(&self) -> bool {
        env::predecessor_account_id() == self.owner_id 
            || self.guardians.contains(&env::predecessor_account_id())
    }

    /// Migration function from v2 to v2.
    /// For next version upgrades, change this function.
    #[init(ignore_state)]
    // [AUDIT_09]
    #[private]
    pub fn migrate() -> Self {
        let mut prev: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");
        prev.exchange_fee = 1600;
        prev.referral_fee = 400;
        prev
    }
}

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::env::BLOCKCHAIN_INTERFACE;
    use near_sdk::Gas;

    use super::*;

    const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

    /// Gas for calling migration call.
    pub const GAS_FOR_MIGRATE_CALL: Gas = 5_000_000_000_000;

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub extern "C" fn upgrade() {
        env::setup_panic_hook();
        env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));
        let contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_owner();
        let current_id = env::current_account_id().into_bytes();
        let method_name = "migrate".as_bytes().to_vec();
        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input into register 0.
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
                let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_MIGRATE_CALL;
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        attached_gas,
                    );
            });
        }
    }

}

'''
'''--- ref-exchange/src/pool.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId, Balance};

use crate::admin_fee::AdminFees;
use crate::simple_pool::SimplePool;
use crate::stable_swap::StableSwapPool;
use crate::utils::SwapVolume;

/// Generic Pool, providing wrapper around different implementations of swap pools.
/// Allows to add new types of pools just by adding extra item in the enum without needing to migrate the storage.
#[derive(BorshSerialize, BorshDeserialize)]
pub enum Pool {
    SimplePool(SimplePool),
    StableSwapPool(StableSwapPool),
}

impl Pool {
    /// Returns pool kind.
    pub fn kind(&self) -> String {
        match self {
            Pool::SimplePool(_) => "SIMPLE_POOL".to_string(),
            Pool::StableSwapPool(_) => "STABLE_SWAP".to_string(),
        }
    }

    /// Returns which tokens are in the underlying pool.
    pub fn tokens(&self) -> &[AccountId] {
        match self {
            Pool::SimplePool(pool) => pool.tokens(),
            Pool::StableSwapPool(pool) => pool.tokens(),
        }
    }

    /// Adds liquidity into underlying pool.
    /// Updates amounts to amount kept in the pool.
    pub fn add_liquidity(
        &mut self,
        sender_id: &AccountId,
        amounts: &mut Vec<Balance>,
    ) -> Balance {
        match self {
            Pool::SimplePool(pool) => pool.add_liquidity(sender_id, amounts),
            Pool::StableSwapPool(_) => unimplemented!(),
        }
    }

    pub fn add_stable_liquidity(
        &mut self,
        sender_id: &AccountId,
        amounts: &Vec<Balance>,
        min_shares: Balance,
        admin_fee: AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => pool.add_liquidity(sender_id, amounts, min_shares, &admin_fee),
        }
    }

    /// Removes liquidity from underlying pool.
    pub fn remove_liquidity(
        &mut self,
        sender_id: &AccountId,
        shares: Balance,
        min_amounts: Vec<Balance>,
    ) -> Vec<Balance> {
        match self {
            Pool::SimplePool(pool) => pool.remove_liquidity(sender_id, shares, min_amounts),
            Pool::StableSwapPool(pool) => {
                pool.remove_liquidity_by_shares(sender_id, shares, min_amounts)
            }
        }
    }

    /// Removes liquidity from underlying pool.
    pub fn remove_liquidity_by_tokens(
        &mut self,
        sender_id: &AccountId,
        amounts: Vec<Balance>,
        max_burn_shares: Balance,
        admin_fee: AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => {
                pool.remove_liquidity_by_tokens(sender_id, amounts, max_burn_shares, &admin_fee)
            }
        }
    }

    /// Returns how many tokens will one receive swapping given amount of token_in for token_out.
    pub fn get_return(
        &self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
        fees: &AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(pool) => pool.get_return(token_in, amount_in, token_out),
            Pool::StableSwapPool(pool) => pool.get_return(token_in, amount_in, token_out, fees),
        }
    }

    /// Return share decimal.
    pub fn get_share_decimal(&self) -> u8 {
        match self {
            Pool::SimplePool(_) => 24,
            Pool::StableSwapPool(_) => 18,
        }
    }

    /// Returns given pool's total fee.
    pub fn get_fee(&self) -> u32 {
        match self {
            Pool::SimplePool(pool) => pool.get_fee(),
            Pool::StableSwapPool(pool) => pool.get_fee(),
        }
    }

    /// Returns volumes of the given pool.
    pub fn get_volumes(&self) -> Vec<SwapVolume> {
        match self {
            Pool::SimplePool(pool) => pool.get_volumes(),
            Pool::StableSwapPool(pool) => pool.get_volumes(),
        }
    }

    /// Returns given pool's share price in precision 1e8.
    pub fn get_share_price(&self) -> u128 {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => pool.get_share_price(),
        }
    }

    /// Swaps given number of token_in for token_out and returns received amount.
    pub fn swap(
        &mut self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
        min_amount_out: Balance,
        admin_fee: AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(pool) => {
                pool.swap(token_in, amount_in, token_out, min_amount_out, &admin_fee)
            }
            Pool::StableSwapPool(pool) => {
                pool.swap(token_in, amount_in, token_out, min_amount_out, &admin_fee)
            }
        }
    }

    pub fn share_total_balance(&self) -> Balance {
        match self {
            Pool::SimplePool(pool) => pool.share_total_balance(),
            Pool::StableSwapPool(pool) => pool.share_total_balance(),
        }
    }

    pub fn share_balances(&self, account_id: &AccountId) -> Balance {
        match self {
            Pool::SimplePool(pool) => pool.share_balance_of(account_id),
            Pool::StableSwapPool(pool) => pool.share_balance_of(account_id),
        }
    }

    pub fn share_transfer(&mut self, sender_id: &AccountId, receiver_id: &AccountId, amount: u128) {
        match self {
            Pool::SimplePool(pool) => pool.share_transfer(sender_id, receiver_id, amount),
            Pool::StableSwapPool(pool) => pool.share_transfer(sender_id, receiver_id, amount),
        }
    }

    pub fn share_register(&mut self, account_id: &AccountId) {
        match self {
            Pool::SimplePool(pool) => pool.share_register(account_id),
            Pool::StableSwapPool(pool) => pool.share_register(account_id),
        }
    }

    pub fn predict_add_stable_liquidity(
        &self,
        amounts: &Vec<Balance>,
        fees: &AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => pool.predict_add_stable_liquidity(amounts, fees),
        }
    }

    pub fn predict_remove_liquidity(
        &self,
        shares: Balance,
    ) -> Vec<Balance> {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => pool.predict_remove_liquidity(shares),
        }
    }

    pub fn predict_remove_liquidity_by_tokens(
        &self,
        amounts: &Vec<Balance>,
        fees: &AdminFees,
    ) -> Balance {
        match self {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => pool.predict_remove_liquidity_by_tokens(amounts, fees),
        }
    }
}

'''
'''--- ref-exchange/src/simple_pool.rs ---
use std::cmp::min;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{env, AccountId, Balance};
use crate::StorageKey;
use crate::admin_fee::AdminFees;

use crate::errors::{
    ERR13_LP_NOT_REGISTERED, ERR14_LP_ALREADY_REGISTERED, ERR31_ZERO_AMOUNT, ERR32_ZERO_SHARES,
};
use crate::utils::{
    add_to_collection, integer_sqrt, SwapVolume, FEE_DIVISOR, INIT_SHARES_SUPPLY, U256,
};

const NUM_TOKENS: usize = 2;

/// Implementation of simple pool, that maintains constant product between balances of all the tokens.
/// Similar in design to "Uniswap".
/// Liquidity providers when depositing receive shares, that can be later burnt to withdraw pool's tokens in proportion.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct SimplePool {
    /// List of tokens in the pool.
    pub token_account_ids: Vec<AccountId>,
    /// How much NEAR this contract has.
    pub amounts: Vec<Balance>,
    /// Volumes accumulated by this pool.
    pub volumes: Vec<SwapVolume>,
    /// Fee charged for swap (gets divided by FEE_DIVISOR).
    pub total_fee: u32,
    /// Obsolete, reserve to simplify upgrade.
    pub exchange_fee: u32,
    /// Obsolete, reserve to simplify upgrade.
    pub referral_fee: u32,
    /// Shares of the pool by liquidity providers.
    pub shares: LookupMap<AccountId, Balance>,
    /// Total number of shares.
    pub shares_total_supply: Balance,
}

impl SimplePool {
    pub fn new(
        id: u32,
        token_account_ids: Vec<ValidAccountId>,
        total_fee: u32,
        exchange_fee: u32,
        referral_fee: u32,
    ) -> Self {
        assert!(
            total_fee < FEE_DIVISOR,
            "ERR_FEE_TOO_LARGE"
        );
        // [AUDIT_10]
        assert_eq!(token_account_ids.len(), NUM_TOKENS, "ERR_SHOULD_HAVE_2_TOKENS");
        Self {
            token_account_ids: token_account_ids.iter().map(|a| a.clone().into()).collect(),
            amounts: vec![0u128; token_account_ids.len()],
            volumes: vec![SwapVolume::default(); token_account_ids.len()],
            total_fee,
            exchange_fee,
            referral_fee,
            // [AUDIT_11]
            shares: LookupMap::new(StorageKey::Shares {
                pool_id: id,
            }),
            shares_total_supply: 0,
        }
    }

    /// Register given account with 0 balance in shares.
    /// Storage payment should be checked by caller.
    pub fn share_register(&mut self, account_id: &AccountId) {
        if self.shares.contains_key(account_id) {
            env::panic(ERR14_LP_ALREADY_REGISTERED.as_bytes());
        }
        self.shares.insert(account_id, &0);
    }

    /// Transfers shares from predecessor to receiver.
    pub fn share_transfer(&mut self, sender_id: &AccountId, receiver_id: &AccountId, amount: u128) {
        let balance = self.shares.get(&sender_id).expect("ERR_NO_SHARES");
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.shares.insert(&sender_id, &new_balance);
        } else {
            env::panic(b"ERR_NOT_ENOUGH_SHARES");
        }
        let balance_out = self
            .shares
            .get(&receiver_id)
            .expect(ERR13_LP_NOT_REGISTERED);
        self.shares.insert(&receiver_id, &(balance_out + amount));
    }

    /// Returns balance of shares for given user.
    pub fn share_balance_of(&self, account_id: &AccountId) -> Balance {
        self.shares.get(account_id).unwrap_or_default()
    }

    /// Returns total number of shares in this pool.
    pub fn share_total_balance(&self) -> Balance {
        self.shares_total_supply
    }

    /// Returns list of tokens in this pool.
    pub fn tokens(&self) -> &[AccountId] {
        &self.token_account_ids
    }

    /// Adds the amounts of tokens to liquidity pool and returns number of shares that this user receives.
    /// Updates amount to amount kept in the pool.
    pub fn add_liquidity(&mut self, sender_id: &AccountId, amounts: &mut Vec<Balance>) -> Balance {
        assert_eq!(
            amounts.len(),
            self.token_account_ids.len(),
            "ERR_WRONG_TOKEN_COUNT"
        );
        let shares = if self.shares_total_supply > 0 {
            let mut fair_supply = U256::max_value();
            for i in 0..self.token_account_ids.len() {
                assert!(amounts[i] > 0, "{}", ERR31_ZERO_AMOUNT);
                fair_supply = min(
                    fair_supply,
                    U256::from(amounts[i]) * U256::from(self.shares_total_supply) / self.amounts[i],
                );
            }
            for i in 0..self.token_account_ids.len() {
                let amount = (U256::from(self.amounts[i]) * fair_supply
                    / U256::from(self.shares_total_supply))
                .as_u128();
                assert!(amount > 0, "{}", ERR31_ZERO_AMOUNT);
                self.amounts[i] += amount;
                amounts[i] = amount;
            }
            fair_supply.as_u128()
        } else {
            for i in 0..self.token_account_ids.len() {
                self.amounts[i] += amounts[i];
            }
            INIT_SHARES_SUPPLY
        };
        self.mint_shares(&sender_id, shares);
        assert!(shares > 0, "{}", ERR32_ZERO_SHARES);
        env::log(
            format!(
                "Liquidity added {:?}, minted {} shares",
                amounts
                    .iter()
                    .zip(self.token_account_ids.iter())
                    .map(|(amount, token_id)| format!("{} {}", amount, token_id))
                    .collect::<Vec<String>>(),
                shares
            )
            .as_bytes(),
        );
        shares
    }

    /// Mint new shares for given user.
    fn mint_shares(&mut self, account_id: &AccountId, shares: Balance) {
        if shares == 0 {
            return;
        }
        self.shares_total_supply += shares;
        add_to_collection(&mut self.shares, &account_id, shares);
    }

    /// Removes given number of shares from the pool and returns amounts to the parent.
    pub fn remove_liquidity(
        &mut self,
        sender_id: &AccountId,
        shares: Balance,
        min_amounts: Vec<Balance>,
    ) -> Vec<Balance> {
        assert_eq!(
            min_amounts.len(),
            self.token_account_ids.len(),
            "ERR_WRONG_TOKEN_COUNT"
        );
        let prev_shares_amount = self.shares.get(&sender_id).expect("ERR_NO_SHARES");
        assert!(prev_shares_amount >= shares, "ERR_NOT_ENOUGH_SHARES");
        let mut result = vec![];
        for i in 0..self.token_account_ids.len() {
            let amount = (U256::from(self.amounts[i]) * U256::from(shares)
                / U256::from(self.shares_total_supply))
            .as_u128();
            assert!(amount >= min_amounts[i], "ERR_MIN_AMOUNT");
            self.amounts[i] -= amount;
            result.push(amount);
        }
        if prev_shares_amount == shares {
            // [AUDIT_13] Never unregister a LP when he removed all his liquidity.
            self.shares.insert(&sender_id, &0);
        } else {
            self.shares
                .insert(&sender_id, &(prev_shares_amount - shares));
        }
        env::log(
            format!(
                "{} shares of liquidity removed: receive back {:?}",
                shares,
                result
                    .iter()
                    .zip(self.token_account_ids.iter())
                    .map(|(amount, token_id)| format!("{} {}", amount, token_id))
                    .collect::<Vec<String>>(),
            )
            .as_bytes(),
        );
        self.shares_total_supply -= shares;
        result
    }

    /// Returns token index for given pool.
    fn token_index(&self, token_id: &AccountId) -> usize {
        self.token_account_ids
            .iter()
            .position(|id| id == token_id)
            .expect("ERR_MISSING_TOKEN")
    }

    /// Returns number of tokens in outcome, given amount.
    /// Tokens are provided as indexes into token list for given pool.
    fn internal_get_return(
        &self,
        token_in: usize,
        amount_in: Balance,
        token_out: usize,
    ) -> Balance {
        let in_balance = U256::from(self.amounts[token_in]);
        let out_balance = U256::from(self.amounts[token_out]);
        assert!(
            in_balance > U256::zero()
                && out_balance > U256::zero()
                && token_in != token_out
                && amount_in > 0,
            "ERR_INVALID"
        );
        let amount_with_fee = U256::from(amount_in) * U256::from(FEE_DIVISOR - self.total_fee);
        (amount_with_fee * out_balance / (U256::from(FEE_DIVISOR) * in_balance + amount_with_fee))
            .as_u128()
    }

    /// Returns how much token you will receive if swap `token_amount_in` of `token_in` for `token_out`.
    pub fn get_return(
        &self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
    ) -> Balance {
        self.internal_get_return(
            self.token_index(token_in),
            amount_in,
            self.token_index(token_out),
        )
    }

    /// Returns given pool's total fee.
    pub fn get_fee(&self) -> u32 {
        self.total_fee
    }

    /// Returns volumes of the given pool.
    pub fn get_volumes(&self) -> Vec<SwapVolume> {
        self.volumes.clone()
    }

    /// Swap `token_amount_in` of `token_in` token into `token_out` and return how much was received.
    /// Assuming that `token_amount_in` was already received from `sender_id`.
    pub fn swap(
        &mut self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
        min_amount_out: Balance,
        admin_fee: &AdminFees,
    ) -> Balance {
        assert_ne!(token_in, token_out, "ERR_SAME_TOKEN_SWAP");
        let in_idx = self.token_index(token_in);
        let out_idx = self.token_index(token_out);
        let amount_out = self.internal_get_return(in_idx, amount_in, out_idx);
        assert!(amount_out >= min_amount_out, "ERR_MIN_AMOUNT");
        env::log(
            format!(
                "Swapped {} {} for {} {}",
                amount_in, token_in, amount_out, token_out
            )
            .as_bytes(),
        );

        let prev_invariant =
            integer_sqrt(U256::from(self.amounts[in_idx]) * U256::from(self.amounts[out_idx]));

        self.amounts[in_idx] += amount_in;
        self.amounts[out_idx] -= amount_out;

        // "Invariant" is by how much the dot product of amounts increased due to fees.
        let new_invariant =
            integer_sqrt(U256::from(self.amounts[in_idx]) * U256::from(self.amounts[out_idx]));

        // Invariant can not reduce (otherwise loosing balance of the pool and something it broken).
        assert!(new_invariant >= prev_invariant, "ERR_INVARIANT");
        let numerator = (new_invariant - prev_invariant) * U256::from(self.shares_total_supply);

        // Allocate exchange fee as fraction of total fee by issuing LP shares proportionally.
        if admin_fee.exchange_fee > 0 && numerator > U256::zero() {
            let denominator = new_invariant * FEE_DIVISOR / admin_fee.exchange_fee;
            self.mint_shares(&admin_fee.exchange_id, (numerator / denominator).as_u128());
        }

        // If there is referral provided and the account already registered LP, allocate it % of LP rewards.
        if let Some(referral_id) = &admin_fee.referral_id {
            if admin_fee.referral_fee > 0
                && numerator > U256::zero()
                && self.shares.contains_key(referral_id)
            {
                let denominator = new_invariant * FEE_DIVISOR / admin_fee.referral_fee;
                self.mint_shares(referral_id, (numerator / denominator).as_u128());
            }
        }

        // Keeping track of volume per each input traded separately.
        // Reported volume with fees will be sum of `input`, without fees will be sum of `output`.
        self.volumes[in_idx].input.0 += amount_in;
        self.volumes[in_idx].output.0 += amount_out;

        amount_out
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};
    use near_sdk_sim::to_yocto;

    use super::*;

    #[test]
    fn test_pool_swap() {
        let one_near = 10u128.pow(24);
        let mut context = VMContextBuilder::new();
        context.predecessor_account_id(accounts(0));
        testing_env!(context.build());
        let mut pool = SimplePool::new(0, vec![accounts(1), accounts(2)], 30, 0, 0);
        let mut amounts = vec![to_yocto("5"), to_yocto("10")];
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts);
        assert_eq!(amounts, vec![to_yocto("5"), to_yocto("10")]);
        assert_eq!(
            pool.share_balance_of(accounts(0).as_ref()),
            INIT_SHARES_SUPPLY
        );
        let out = pool.swap(
            accounts(1).as_ref(),
            one_near,
            accounts(2).as_ref(),
            1,
            &AdminFees {
                exchange_fee: 0,
                exchange_id: accounts(3).as_ref().clone(),
                referral_fee: 0,
                referral_id: None,
            },
        );
        assert_eq!(
            pool.share_balance_of(accounts(0).as_ref()),
            INIT_SHARES_SUPPLY
        );
        pool.share_register(accounts(1).as_ref());
        pool.share_transfer(
            accounts(0).as_ref(),
            accounts(1).as_ref(),
            INIT_SHARES_SUPPLY / 2,
        );
        assert_eq!(
            pool.share_balance_of(accounts(0).as_ref()),
            INIT_SHARES_SUPPLY / 2
        );
        assert_eq!(
            pool.share_balance_of(accounts(1).as_ref()),
            INIT_SHARES_SUPPLY / 2
        );
        assert_eq!(
            pool.remove_liquidity(accounts(0).as_ref(), num_shares / 2, vec![1, 1]),
            [3 * one_near, 5 * one_near - out / 2]
        );
    }

    #[test]
    fn test_pool_swap_with_fees() {
        let one_near = 10u128.pow(24);
        let mut context = VMContextBuilder::new();
        context.predecessor_account_id(accounts(0));
        testing_env!(context.build());
        let mut pool = SimplePool::new(0, vec![accounts(1), accounts(2)], 100, 100, 0);
        let mut amounts = vec![to_yocto("5"), to_yocto("10")];
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts);
        assert_eq!(amounts, vec![to_yocto("5"), to_yocto("10")]);
        assert_eq!(
            pool.share_balance_of(accounts(0).as_ref()),
            INIT_SHARES_SUPPLY
        );
        let out = pool.swap(
            accounts(1).as_ref(),
            one_near,
            accounts(2).as_ref(),
            1,
            &AdminFees {
                exchange_fee: 100,
                exchange_id: accounts(3).as_ref().clone(),
                referral_fee: 0,
                referral_id: None,
            },
        );
        assert_eq!(
            pool.share_balance_of(accounts(0).as_ref()),
            INIT_SHARES_SUPPLY
        );
        let liq1 = pool.remove_liquidity(accounts(0).as_ref(), num_shares, vec![1, 1]);
        let num_shares2 = pool.share_balance_of(accounts(3).as_ref());
        let liq2 = pool.remove_liquidity(accounts(3).as_ref(), num_shares2, vec![1, 1]);
        assert_eq!(liq1[0] + liq2[0], to_yocto("6"));
        assert_eq!(liq1[1] + liq2[1], to_yocto("10") - out);
    }

    #[test]
    #[should_panic(expected = "E31: adding zero amount")]
    fn test_rounding() {
        testing_env!(VMContextBuilder::new().build());
        let mut pool = SimplePool {
            token_account_ids: vec![accounts(0).to_string(), accounts(1).to_string()],
            amounts: vec![367701466208080431008668441, 2267116519548219219535],
            volumes: vec![SwapVolume::default(), SwapVolume::default()],
            total_fee: 30,
            exchange_fee: 5,
            referral_fee: 1,
            shares_total_supply: 35967818779820559673547466,
            shares: LookupMap::new(StorageKey::Shares {
                pool_id: 0,
            }),
        };
        let mut amounts = vec![145782, 1];
        let _ = pool.add_liquidity(&accounts(2).to_string(), &mut amounts);
    }
}

'''
'''--- ref-exchange/src/stable_swap/curve.md ---

# math for stable swap pool
## About the D
---

### The equation: 

$$ 
An^n \sum x_{i} + D = ADn^n + \frac{D^{n+1}}{n^n \prod x_{i}} 
$$

$$
f(D) = \frac{D^{n+1}}{n^n \prod x_{i}} + (An^n - 1)D - An^n \sum x_{i} = 0
$$

$$
f'(D) = \frac{n+1}{n^n \prod x_{i}} D^n + An^n - 1 = 0
$$

### Solve for D using Newton method
---
  
Newton's method to solve for D:  
$$
D_{k+1} = D_{k} - \frac{f(D_{k})}{f'(D_{k})}
$$

Let  
$$
D_{prod} = \frac{D^{n+1}}{n^n \prod x_{i}} 
$$
  
Then,  
$$
D_{k+1} = \frac{D_k(An^n \sum x_{i} + nD_{k,prod})} {D_{k}(An^n - 1) + (n+1)D_{k,prod}}
$$  

### Specialize 
---
Our conditions:  

$ n = 2 $
     
$ \sum x_i = (x+y) $  
  
$ \prod x_i = (xy) $  
  
So,   
$$
D_{prod} = \frac{D^{3}}{4xy} 
$$
  
$$
D_{k+1} = \frac{D_k(4A(x+y) + 2D_{k,prod})} {D_{k}(4A - 1) + 3D_{k,prod}}
$$
  
## About the y
---
Let's withdraw y from $x_i$ :  
$$
\sum x_i = y + \sum x'_i  
$$
  
$$
\prod x_i = y \prod x'_i
$$

Assume we know $D$, $A$ and $x_i$, let's solve for $y$:

$$ 
An^n (y+\sum x'_{i}) + D = ADn^n + \frac{D^{n+1}}{n^n y \prod x'_i} 
$$  
Make it to be $f(y)$:  
$$
An^ny^2 + [An^n\sum x'_i - (An^n-1)D]y = \frac{D^{n+1}}{n^n\prod x'_i}
$$  

Simplify to $f(y)$ is:  
$$
y^2 + (\sum x'_i + \frac{D}{An^n} - D)y = \frac{D^{n+1}}{An^{2n}\prod x'_i}
$$  

And $f'(y)$ is:  
$$
2y + \sum x'_i + \frac{D}{An^n} - D = 0
$$

### Solve for y using Newton method
---
  
Newton's method to solve for D:  

$$
y_{k+1} = y_{k} - \frac{f(y_{k})}{f'(y_{k})}
$$  

Let's define $b$, $c$ as:  

$$
b = \sum x'_i + \frac{D}{An^n}
$$
  
$$
c = \frac{D^{n+1}}{An^{2n}\prod x'_i}
$$  

Then:  
$$
y_{k+1} = \frac{y_k^2 + c}{2y_k + b - D}
$$  
'''
'''--- ref-exchange/src/stable_swap/fee_strategy.md ---
# FEE Strategy in REF Stable Swap Pool
## Fee Structure

```rust
// fee rate in bps
pub struct StableSwapPool {
    // ... ...
    
    // total fee rate
    pub total_fee: u32,

    // ... ...
}

// used in math of stable swap
pub struct Fees {
    pub trade_fee: u32, // equal to total_fee above
    pub admin_fee: u32, // based on trade_fee amount.
}

/// details of admin_fee,
/// admin_fee = exchange_fee + referral_fee
pub struct AdminFees {
    /// Basis points of the fee for exchange.
    pub exchange_fee: u32,
    /// Basis points of the fee for referrer.
    pub referral_fee: u32,
    pub exchange_id: AccountId,
    pub referral_id: Option<AccountId>,
}
```

## Actions Involved
### Add liquidity
* D0 = original invariant D;  
* D1 = D after adding deposit tokens;  
* D2 = D after adding deposit tokens (subtract with fee per token);  

Relations: D1 >= D2 >= D0;  

```bash
share_increased = share_supply * (D1-D0)/D0;
share_mint_for_user = share_supply * (D2-D0)/D0;
share_fee_parts = share_increased - share_mint_for_user;
```
**exchange_fee:**  
```bash
share_mint_for_ex = share_fee_parts * exchange_fee / FEE_DIVISOR;
```
**referral_fee:**  
```bash
share_mint_for_re = share_fee_parts * referral_fee / FEE_DIVISOR;
```

**Remark**  
A portion of share does NOT mint:
```bash
share_gap = share_fee_parts - share_mint_for_ex - share_mint_for_re
```
This gap actually promotes the unit share value, that is to say, will benefit to all LP of this pool.

***Note:*** 
* Why charge fee when adding/removing liquidity?
    imbalanced token in/out won't be good for the pool, so need fee;
* Fee algorithm when adding/removing liquidity?  
     Based on the difference between real token in/out and an ideal in/out amount per token. 

### Remove liquidity
**Remove by share won't involve any fee;**  
*Cause there is no difference with ideal token amount*  

**Remove by token amounts**  
Same as add liquidity,  
* D0 = original invariant D;  
* D1 = D after remove tokens;  
* D2 = D after remove tokens (subtract with fee per token);  

Relations: D0 >= D1 >= D2;

```bash
share_decreased = share_supply * (D0-D1)/D0;
share_burn_for_user = share_supply * (D0-D2)/D0;
share_fee_parts = share_burn_for_user - share_decreased;
```
**exchange_fee:**  
```bash
share_mint_for_ex = share_fee_parts * exchange_fee / FEE_DIVISOR;
```
**referral_fee:**  
```bash
share_mint_for_re = share_fee_parts * referral_fee / FEE_DIVISOR;
```

**Remark**  
A portion of share was over burned:
```bash
share_gap = share_fee_parts - share_mint_for_ex - share_mint_for_re
```
This gap actually promotes the unit share value, that is to say, will benefit to all LP of this pool.

## Swap
Given that Alice want swap dX tokenA to get tokenB, then:  
dY is the out-amount of tokenB to keep D unchanged and despite any fees;  
`trading_fee_amount = dY * trade_fee / FEE_DIVISOR`  
Alice actually got `dY - trading_fee_amount` tokenB.  
We have:  
`admin_fee_amount = trading_fee_amount * admin_fee / FEE_DIVISOR`  

If referral and its account is valid, referral got:  
`referral_tokenB = admin_fee_amount * referral_fee / (referral_fee + exchange_fee)`  

Exchange would got:  
`exchange_tokenB = admin_fee_amount - referral_tokenB`  
That is to say, the exchange got all admin fee if referral is invalid.

Both referral and exchange pour their tokenB back to pool as an adding liquidity process with 0 fee. That is the way they got their fee incoming as shares.

**Remark**  
A portion of TokenB was sustained in pool:
```bash
tokenB_gap = trading_fee_amount - admin_fee_amount
```
This gap actually promotes the unit share value, that is to say, will benefit to all LP of this pool.

'''
'''--- ref-exchange/src/stable_swap/math.rs ---
///! Calculator to maintain the invariant on adding/removing liquidity and on swapping.
///! Large part of the code was taken from https://github.com/saber-hq/stable-swap/blob/master/stable-swap-math/src/curve.rs
use near_sdk::{Balance, Timestamp};

use crate::admin_fee::AdminFees;
use crate::utils::{FEE_DIVISOR, U256};

/// Minimum ramp duration, in nano sec.
pub const MIN_RAMP_DURATION: Timestamp = 86400 * 1_000_000_000;
/// Min amplification coefficient.
pub const MIN_AMP: u128 = 1;
/// Max amplification coefficient.
pub const MAX_AMP: u128 = 1_000_000;
/// Max amplification change.
pub const MAX_AMP_CHANGE: u128 = 10;

/// Stable Swap Fee calculator.
pub struct Fees {
    pub trade_fee: u32,
    pub admin_fee: u32,
}

impl Fees {
    pub fn new(total_fee: u32, fees: &AdminFees) -> Self {
        Self {
            trade_fee: total_fee,
            admin_fee: fees.exchange_fee + fees.referral_fee,
        }
    }

    pub fn zero() -> Self {
        Self {
            trade_fee: 0,
            admin_fee: 0,
        }
    }

    pub fn trade_fee(&self, amount: Balance) -> Balance {
        amount * (self.trade_fee as u128) / (FEE_DIVISOR as u128)
    }

    pub fn admin_trade_fee(&self, amount: Balance) -> Balance {
        amount * (self.admin_fee as u128) / (FEE_DIVISOR as u128)
    }

    /// Used to normalize fee applid on difference amount with ideal balance, This logic is from 
    /// https://github.com/saber-hq/stable-swap/blob/5db776fb0a41a0d1a23d46b99ef412ca7ccc5bf6/stable-swap-program/program/src/fees.rs#L73
    pub fn normalized_trade_fee(&self, num_coins: u32, amount: Balance) -> Balance {
        let adjusted_trade_fee = (self.trade_fee * num_coins) / (4 * (num_coins - 1));
        amount * (adjusted_trade_fee as u128) / (FEE_DIVISOR as u128)
    }
}

/// Encodes all results of swapping from a source token to a destination token.
#[derive(Debug)]
pub struct SwapResult {
    /// New amount of source token.
    pub new_source_amount: Balance,
    /// New amount of destination token.
    pub new_destination_amount: Balance,
    /// Amount of destination token swapped.
    pub amount_swapped: Balance,
    /// Admin fee for the swap.
    pub admin_fee: Balance,
    /// Fee for the swap.
    pub fee: Balance,
}

/// The StableSwap invariant calculator.
pub struct StableSwap {
    /// Initial amplification coefficient (A)
    initial_amp_factor: u128,
    /// Target amplification coefficient (A)
    target_amp_factor: u128,
    /// Current unix timestamp
    current_ts: Timestamp,
    /// Ramp A start timestamp
    start_ramp_ts: Timestamp,
    /// Ramp A stop timestamp
    stop_ramp_ts: Timestamp,
}

impl StableSwap {
    pub fn new(
        initial_amp_factor: u128,
        target_amp_factor: u128,
        current_ts: Timestamp,
        start_ramp_ts: Timestamp,
        stop_ramp_ts: Timestamp,
    ) -> Self {
        Self {
            initial_amp_factor,
            target_amp_factor,
            current_ts,
            start_ramp_ts,
            stop_ramp_ts,
        }
    }

    /// Compute the amplification coefficient (A)
    pub fn compute_amp_factor(&self) -> Option<Balance> {
        if self.current_ts < self.stop_ramp_ts {
            let time_range = self.stop_ramp_ts.checked_sub(self.start_ramp_ts)?;
            let time_delta = self.current_ts.checked_sub(self.start_ramp_ts)?;

            // Compute amp factor based on ramp time
            if self.target_amp_factor >= self.initial_amp_factor {
                // Ramp up
                let amp_range = self
                    .target_amp_factor
                    .checked_sub(self.initial_amp_factor)?;
                let amp_delta = (amp_range as u128)
                    .checked_mul(time_delta as u128)?
                    .checked_div(time_range as u128)?;
                self.initial_amp_factor
                    .checked_add(amp_delta)
                    .map(|x| x as u128)
            } else {
                // Ramp down
                let amp_range = self
                    .initial_amp_factor
                    .checked_sub(self.target_amp_factor)?;
                let amp_delta = (amp_range as u128)
                    .checked_mul(time_delta as u128)?
                    .checked_div(time_range as u128)?;
                self.initial_amp_factor
                    .checked_sub(amp_delta)
                    .map(|x| x as u128)
            }
        } else {
            // when stop_ramp_ts == 0 or current_ts >= stop_ramp_ts
            Some(self.target_amp_factor as u128)
        }
    }

    /// Compute stable swap invariant (D)
    /// Equation:
    /// A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))
    pub fn compute_d(&self, c_amounts: &Vec<Balance>) -> Option<U256> {
        let n_coins = c_amounts.len() as u128;
        let sum_x = c_amounts.iter().fold(0, |sum, i| sum + i);
        if sum_x == 0 {
            Some(0.into())
        } else {
            let amp_factor = self.compute_amp_factor()?;
            let mut d_prev: U256;
            let mut d: U256 = sum_x.into();
            for _ in 0..256 {
                // $ D_{k,prod} = \frac{D_k^{n+1}}{n^n \prod x_{i}} = \frac{D^3}{4xy} $
                let mut d_prod = d;
                for c_amount in c_amounts {
                    d_prod = d_prod.checked_mul(d)?
                    .checked_div((c_amount * n_coins).into())?;
                }
                d_prev = d;

                let ann = amp_factor.checked_mul(n_coins.checked_pow(n_coins as u32)?.into())?;
                let leverage = (U256::from(sum_x)).checked_mul(ann.into())?;
                // d = (ann * sum_x + d_prod * n_coins) * d_prev / ((ann - 1) * d_prev + (n_coins + 1) * d_prod)
                let numerator = d_prev.checked_mul(
                    d_prod
                        .checked_mul(n_coins.into())?
                        .checked_add(leverage.into())?,
                )?;
                let denominator = d_prev
                    .checked_mul(ann.checked_sub(1)?.into())?
                    .checked_add(d_prod.checked_mul((n_coins + 1).into())?)?;
                d = numerator.checked_div(denominator)?;

                // Equality with the precision of 1
                if d > d_prev {
                    if d.checked_sub(d_prev)? <= 1.into() {
                        break;
                    }
                } else if d_prev.checked_sub(d)? <= 1.into() {
                    break;
                }
            }
            Some(d)
        }
    }

    /// Compute the amount of LP tokens to mint after a deposit
    /// return <lp_amount_to_mint, lp_fees_part>
    pub fn compute_lp_amount_for_deposit(
        &self,
        deposit_c_amounts: &Vec<Balance>, // deposit tokens in comparable precision,
        old_c_amounts: &Vec<Balance>, // current in-pool tokens in comparable precision,
        pool_token_supply: Balance, // current share supply
        fees: &Fees,
    ) -> Option<(Balance, Balance)> {
        let n_coins = old_c_amounts.len();
        
        // Initial invariant
        let d_0 = self.compute_d(old_c_amounts)?;

        let mut new_balances = vec![0_u128; n_coins];
        for (index, value) in deposit_c_amounts.iter().enumerate() {
            new_balances[index] = old_c_amounts[index].checked_add(*value)?;
        }
        // Invariant after change
        let d_1 = self.compute_d(&new_balances)?;
        if d_1 <= d_0 {
            None
        } else {
            // Recalculate the invariant accounting for fees
            for i in 0..new_balances.len() {
                let ideal_balance = d_1
                    .checked_mul(old_c_amounts[i].into())?
                    .checked_div(d_0)?
                    .as_u128();
                let difference = if ideal_balance > new_balances[i] {
                    ideal_balance.checked_sub(new_balances[i])?
                } else {
                    new_balances[i].checked_sub(ideal_balance)?
                };
                let fee = fees.normalized_trade_fee(n_coins as u32, difference);
                new_balances[i] = new_balances[i].checked_sub(fee)?;
            }

            let d_2 = self.compute_d(&new_balances)?;

            // d1 > d2 > d0, 
            // (d2-d0) => mint_shares (charged fee),
            // (d1-d0) => diff_shares (without fee),
            // (d1-d2) => fee part,
            // diff_shares = mint_shares + fee part

            let mint_shares = U256::from(pool_token_supply)
                .checked_mul(d_2.checked_sub(d_0)?)?
                .checked_div(d_0)?
                .as_u128();
            
            let diff_shares = U256::from(pool_token_supply)
                .checked_mul(d_1.checked_sub(d_0)?)?
                .checked_div(d_0)?
                .as_u128();

            Some((mint_shares, diff_shares-mint_shares))
        }
    }

    /// Compute new amount of token 'y' with new amount of token 'x'
    /// return new y_token amount according to the equation
    pub fn compute_y(
        &self, 
        x_c_amount: Balance, // new x_token amount in comparable precision, 
        current_c_amounts: &Vec<Balance>,  // in-pool tokens amount in comparable precision,
        index_x: usize, // x token's index
        index_y: usize, // y token's index
    ) -> Option<U256> {
        let n_coins = current_c_amounts.len() as u128;
        let amp_factor = self.compute_amp_factor()?;
        let ann = amp_factor.checked_mul(n_coins.checked_pow(n_coins as u32)?.into())?;
        // invariant
        let d = self.compute_d(current_c_amounts)?;
        let mut s_ = x_c_amount;
        let mut c = d.checked_mul(d)?.checked_div(x_c_amount.into())?;
        for (idx, c_amount) in current_c_amounts.iter().enumerate() {
            if idx != index_x && idx != index_y {
                s_ += *c_amount;
                c = c.checked_mul(d)?
                    .checked_div((*c_amount).into())?;
            }
        }
        c = c
            .checked_mul(d)?
            .checked_div(ann.checked_mul((n_coins as u128).checked_pow(n_coins as u32)?.into())?.into())?;

        let b = d.checked_div(ann.into())?.checked_add(s_.into())?; // d will be subtracted later

        // Solve for y by approximating: y**2 + b*y = c
        let mut y_prev: U256;
        let mut y = d;
        for _ in 0..256 {
            y_prev = y;
            // $ y_{k+1} = \frac{y_k^2 + c}{2y_k + b - D} $
            let y_numerator = y.checked_pow(2.into())?.checked_add(c)?;
            let y_denominator = y.checked_mul(2.into())?.checked_add(b)?.checked_sub(d)?;
            y = y_numerator.checked_div(y_denominator)?;
            if y > y_prev {
                if y.checked_sub(y_prev)? <= 1.into() {
                    break;
                }
            } else if y_prev.checked_sub(y)? <= 1.into() {
                break;
            }
        }
        Some(y)
    }

    /// given token_out user want get and total tokens in pool and lp token supply,
    /// return <lp_amount_to_burn, lp_fees_part>
    /// all amounts are in c_amount (comparable amount)
    pub fn compute_lp_amount_for_withdraw(
        &self,
        withdraw_c_amounts: &Vec<Balance>, // withdraw tokens in comparable precision,
        old_c_amounts: &Vec<Balance>, // in-pool tokens comparable amounts vector, 
        pool_token_supply: Balance, // total share supply
        fees: &Fees,
    ) -> Option<(Balance, Balance)> {
        let n_coins = old_c_amounts.len();
        // Initial invariant, D0
        let d_0 = self.compute_d(old_c_amounts)?;

        // real invariant after withdraw, D1
        let mut new_balances = vec![0_u128; n_coins];
        for (index, value) in withdraw_c_amounts.iter().enumerate() {
            new_balances[index] = old_c_amounts[index].checked_sub(*value)?;
        }

        let d_1 = self.compute_d(&new_balances)?;

        // compare ideal token portions from D1 with withdraws, to calculate diff fee.
        if d_1 >= d_0 {
            None
        } else {
            // Recalculate the invariant accounting for fees
            for i in 0..new_balances.len() {
                let ideal_balance = d_1
                    .checked_mul(old_c_amounts[i].into())?
                    .checked_div(d_0)?
                    .as_u128();
                let difference = if ideal_balance > new_balances[i] {
                    ideal_balance.checked_sub(new_balances[i])?
                } else {
                    new_balances[i].checked_sub(ideal_balance)?
                };
                let fee = fees.normalized_trade_fee(n_coins as u32, difference);
                // new_balance is for calculation D2, the one with fee charged
                new_balances[i] = new_balances[i].checked_sub(fee)?;
            }

            let d_2 = self.compute_d(&new_balances)?;

            // d0 > d1 > d2, 
            // (d0-d2) => burn_shares (plus fee),
            // (d0-d1) => diff_shares (without fee),
            // (d1-d2) => fee part,
            // burn_shares = diff_shares + fee part
            let burn_shares = U256::from(pool_token_supply)
                .checked_mul(d_0.checked_sub(d_2)?)?
                .checked_div(d_0)?
                .as_u128();
            let diff_shares = U256::from(pool_token_supply)
                .checked_mul(d_0.checked_sub(d_1)?)?
                .checked_div(d_0)?
                .as_u128();

            Some((burn_shares, burn_shares-diff_shares))
        }

    }

    /// Compute SwapResult after an exchange
    /// all tokens in and out with comparable precision
    pub fn swap_to(
        &self,
        token_in_idx: usize, // token_in index in token vector,
        token_in_amount: Balance, // token_in amount in comparable precision (1e18),
        token_out_idx: usize, // token_out index in token vector,
        current_c_amounts: &Vec<Balance>, // in-pool tokens comparable amounts vector, 
        fees: &Fees,
    ) -> Option<SwapResult> {
        let y = self.compute_y(
            token_in_amount + current_c_amounts[token_in_idx], 
            current_c_amounts,
            token_in_idx,
            token_out_idx,
        )?.as_u128();

        let dy = current_c_amounts[token_out_idx].checked_sub(y)?;
        let trade_fee = fees.trade_fee(dy);
        let admin_fee = fees.admin_trade_fee(trade_fee);
        let amount_swapped = dy.checked_sub(trade_fee)?;

        let new_destination_amount = current_c_amounts[token_out_idx]
            .checked_sub(amount_swapped)?
            .checked_sub(admin_fee)?;
        let new_source_amount = current_c_amounts[token_in_idx]
            .checked_add(token_in_amount)?;

        Some(SwapResult {
            new_source_amount,
            new_destination_amount,
            amount_swapped,
            admin_fee,
            fee: trade_fee,
        })
    }
}

'''
'''--- ref-exchange/src/stable_swap/mod.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{env, AccountId, Balance, Timestamp};

use crate::admin_fee::AdminFees;
use crate::errors::*;
use crate::stable_swap::math::{
    Fees, StableSwap, SwapResult, MAX_AMP, MAX_AMP_CHANGE, MIN_AMP, MIN_RAMP_DURATION,
};
use crate::utils::{add_to_collection, SwapVolume, FEE_DIVISOR, U256};
use crate::StorageKey;

mod math;

pub const MIN_DECIMAL: u8 = 1;
pub const MAX_DECIMAL: u8 = 18;
pub const TARGET_DECIMAL: u8 = 18;
pub const MIN_RESERVE: u128 = 1_000_000_000_000_000_000;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct StableSwapPool {
    /// List of tokens in the pool.
    pub token_account_ids: Vec<AccountId>,
    /// Each decimals for tokens in the pool
    pub token_decimals: Vec<u8>,
    /// token amounts in comparable decimal.
    pub c_amounts: Vec<Balance>,
    /// Volumes accumulated by this pool.
    pub volumes: Vec<SwapVolume>,
    /// Fee charged for swap (gets divided by FEE_DIVISOR).
    pub total_fee: u32,
    /// Shares of the pool by liquidity providers.
    pub shares: LookupMap<AccountId, Balance>,
    /// Total number of shares.
    pub shares_total_supply: Balance,
    /// Initial amplification coefficient.
    pub init_amp_factor: u128,
    /// Target for ramping up amplification coefficient.
    pub target_amp_factor: u128,
    /// Initial amplification time.
    pub init_amp_time: Timestamp,
    /// Stop ramp up amplification time.
    pub stop_amp_time: Timestamp,
}

impl StableSwapPool {
    pub fn new(
        id: u32,
        token_account_ids: Vec<ValidAccountId>,
        token_decimals: Vec<u8>,
        amp_factor: u128,
        total_fee: u32,
    ) -> Self {
        for decimal in token_decimals.clone().into_iter() {
            assert!(decimal <= MAX_DECIMAL, "{}", ERR60_DECIMAL_ILLEGAL);
            assert!(decimal >= MIN_DECIMAL, "{}", ERR60_DECIMAL_ILLEGAL);
        }
        assert!(
            amp_factor >= MIN_AMP && amp_factor <= MAX_AMP,
            "{}",
            ERR61_AMP_ILLEGAL
        );
        assert!(total_fee < FEE_DIVISOR, "{}", ERR62_FEE_ILLEGAL);
        Self {
            token_account_ids: token_account_ids.iter().map(|a| a.clone().into()).collect(),
            token_decimals,
            c_amounts: vec![0u128; token_account_ids.len()],
            volumes: vec![SwapVolume::default(); token_account_ids.len()],
            total_fee,
            shares: LookupMap::new(StorageKey::Shares { pool_id: id }),
            shares_total_supply: 0,
            init_amp_factor: amp_factor,
            target_amp_factor: amp_factor,
            init_amp_time: 0,
            stop_amp_time: 0,
        }
    }

    pub fn get_amounts(&self) ->Vec<u128> {
        let mut amounts = self.c_amounts.clone();
        for (index, value) in self.token_decimals.iter().enumerate() {
            let factor = 10_u128
                .checked_pow((TARGET_DECIMAL - value) as u32)
                .unwrap();
            amounts[index] = amounts[index].checked_div(factor).unwrap();
        }
        amounts
    }

    fn amounts_to_c_amounts(&self, amounts: &Vec<u128>) ->Vec<u128> {
        let mut c_amounts = amounts.clone();
        for (index, value) in self.token_decimals.iter().enumerate() {
            let factor = 10_u128
                .checked_pow((TARGET_DECIMAL - value) as u32)
                .unwrap();
            c_amounts[index] = c_amounts[index].checked_mul(factor).unwrap();
        }
        c_amounts
    }

    fn amount_to_c_amount(&self, amount: u128, index: usize) -> u128 {
        let value = self.token_decimals.get(index).unwrap();
        let factor = 10_u128
                .checked_pow((TARGET_DECIMAL - value) as u32)
                .unwrap();
        amount.checked_mul(factor).unwrap()
    }

    fn c_amount_to_amount(&self, c_amount: u128, index: usize) -> u128 {
        let value = self.token_decimals.get(index).unwrap();
        let factor = 10_u128
                .checked_pow((TARGET_DECIMAL - value) as u32)
                .unwrap();
        c_amount.checked_div(factor).unwrap()
    }

    fn assert_min_reserve(&self, balance: u128) {
        assert!(
            balance >= MIN_RESERVE,
            "{}",
            ERR69_MIN_RESERVE
        );
    }

    pub fn get_amp(&self) -> u64 {
        if let Some(amp) = self.get_invariant().compute_amp_factor() {
            amp as u64
        } else {
            0
        }
    }

    fn get_invariant(&self) -> StableSwap {
        StableSwap::new(
            self.init_amp_factor,
            self.target_amp_factor,
            env::block_timestamp(),
            self.init_amp_time,
            self.stop_amp_time,
        )
    }

    /// Returns token index for given token account_id.
    fn token_index(&self, token_id: &AccountId) -> usize {
        self.token_account_ids
            .iter()
            .position(|id| id == token_id)
            .expect(ERR63_MISSING_TOKEN)
    }

    /// Returns given pool's total fee.
    pub fn get_fee(&self) -> u32 {
        self.total_fee
    }

    /// Returns volumes of the given pool.
    pub fn get_volumes(&self) -> Vec<SwapVolume> {
        self.volumes.clone()
    }

    /// Get per lp token price, with 1e8 precision
    pub fn get_share_price(&self) -> u128 {

        let sum_token = self.c_amounts.iter().sum::<u128>();

        U256::from(sum_token)
            .checked_mul(100000000.into())
            .unwrap()
            .checked_div(self.shares_total_supply.into())
            .unwrap()
            .as_u128()
    }

    /// caculate mint share and related fee for adding liquidity
    /// return (share, fee_part)
    fn calc_add_liquidity(
        &self, 
        amounts: &Vec<Balance>, 
        fees: &AdminFees,
    ) -> (Balance, Balance) {
        let invariant = self.get_invariant();

        // make amounts into comparable-amounts
        let c_amounts = self.amounts_to_c_amounts(amounts);

        if self.shares_total_supply == 0 {
            // Bootstrapping the pool, request providing all non-zero balances,
            // and all fee free.
            for c_amount in &c_amounts {
                assert!(*c_amount > 0, "{}", ERR65_INIT_TOKEN_BALANCE);
            }
            (
                invariant
                    .compute_d(&c_amounts)
                    .expect(ERR66_INVARIANT_CALC_ERR)
                    .as_u128(),
                0,
            )
        } else {
            // Subsequent add liquidity will charge fee according to difference with ideal balance portions
            invariant
                .compute_lp_amount_for_deposit(
                    &c_amounts,
                    &self.c_amounts,
                    self.shares_total_supply,
                    &Fees::new(self.total_fee, &fees),
                )
                .expect(ERR67_LPSHARE_CALC_ERR)
        }
    }

    pub fn predict_add_stable_liquidity(
        &self,
        amounts: &Vec<Balance>,
        fees: &AdminFees,
    ) -> Balance {

        let n_coins = self.token_account_ids.len();
        assert_eq!(amounts.len(), n_coins, "{}", ERR64_TOKENS_COUNT_ILLEGAL);

        let (new_shares, _) = self.calc_add_liquidity(amounts, fees);

        new_shares
    }

    /// Add liquidity into the pool.
    /// Allows to add liquidity of a subset of tokens,
    /// by set other tokens balance into 0.
    pub fn add_liquidity(
        &mut self,
        sender_id: &AccountId,
        amounts: &Vec<Balance>,
        min_shares: Balance,
        fees: &AdminFees,
    ) -> Balance {
        let n_coins = self.token_account_ids.len();
        assert_eq!(amounts.len(), n_coins, "{}", ERR64_TOKENS_COUNT_ILLEGAL);

        let (new_shares, fee_part) = self.calc_add_liquidity(amounts, fees);

        //slippage check on the LP tokens.
        assert!(new_shares >= min_shares, "{}", ERR68_SLIPPAGE);

        for i in 0..n_coins {
            self.c_amounts[i] = self.c_amounts[i].checked_add(self.amount_to_c_amount(amounts[i], i)).unwrap();
        }

        self.mint_shares(sender_id, new_shares);
        env::log(
            format!(
                "Mint {} shares for {}, fee is {} shares",
                new_shares, sender_id, fee_part,
            )
            .as_bytes(),
        );

        if fee_part > 0 {
            // referral fee
            if let Some(referral) = &fees.referral_id {
                if self.shares.get(referral).is_some() {
                    let referral_share = fee_part * fees.referral_fee as u128 / FEE_DIVISOR as u128;
                    self.mint_shares(referral, referral_share);
                    env::log(
                        format!("Referral {} got {} shares", referral, referral_share).as_bytes(),
                    );
                }
            }
            // exchange fee
            let exchange_share = fee_part * fees.exchange_fee as u128 / FEE_DIVISOR as u128;
            self.mint_shares(&fees.exchange_id, exchange_share);
            env::log(
                format!("Admin {} got {} shares", &fees.exchange_id, exchange_share).as_bytes(),
            );
        }
        new_shares
    }

    pub fn predict_remove_liquidity(
        &self,
        shares: Balance,
    ) -> Vec<Balance> {
        let n_coins = self.token_account_ids.len();
        let mut result = vec![0u128; n_coins];
        for i in 0..n_coins {
            result[i] = U256::from(self.c_amounts[i])
                .checked_mul(shares.into())
                .unwrap()
                .checked_div(self.shares_total_supply.into())
                .unwrap()
                .as_u128();
            result[i] = self.c_amount_to_amount(result[i], i);
        }
        result
    }

    /// balanced removal of liquidity would be free of charge.
    pub fn remove_liquidity_by_shares(
        &mut self,
        sender_id: &AccountId,
        shares: Balance,
        min_amounts: Vec<Balance>,
    ) -> Vec<Balance> {
        let n_coins = self.token_account_ids.len();
        assert_eq!(min_amounts.len(), n_coins, "{}", ERR64_TOKENS_COUNT_ILLEGAL);
        let prev_shares_amount = self.shares.get(&sender_id).expect(ERR13_LP_NOT_REGISTERED);
        assert!(
            prev_shares_amount >= shares,
            "{}",
            ERR34_INSUFFICIENT_LP_SHARES
        );
        let mut result = vec![0u128; n_coins];

        for i in 0..n_coins {
            result[i] = U256::from(self.c_amounts[i])
                .checked_mul(shares.into())
                .unwrap()
                .checked_div(self.shares_total_supply.into())
                .unwrap()
                .as_u128();
            self.c_amounts[i] = self.c_amounts[i].checked_sub(result[i]).unwrap();
            self.assert_min_reserve(self.c_amounts[i]);
            result[i] = self.c_amount_to_amount(result[i], i);
            assert!(result[i] >= min_amounts[i], "{}", ERR68_SLIPPAGE);
        }

        self.burn_shares(&sender_id, prev_shares_amount, shares);
        
        env::log(
            format!(
                "LP {} remove {} shares to gain tokens {:?}",
                sender_id, shares, result
            )
            .as_bytes(),
        );

        result
    }

    pub fn predict_remove_liquidity_by_tokens(
        &self,
        amounts: &Vec<Balance>,
        fees: &AdminFees,
    ) -> Balance {
        let n_coins = self.token_account_ids.len();
        let c_amounts = self.amounts_to_c_amounts(amounts);
        for i in 0..n_coins {
            self.assert_min_reserve(self.c_amounts[i].checked_sub(c_amounts[i]).unwrap_or(0));
        }

        let invariant = self.get_invariant();
        let trade_fee = Fees::new(self.total_fee, &fees);

        let (burn_shares, _) = invariant
            .compute_lp_amount_for_withdraw(
                &c_amounts,
                &self.c_amounts,
                self.shares_total_supply,
                &trade_fee,
            )
            .expect(ERR67_LPSHARE_CALC_ERR);

        burn_shares
    }

    /// Remove liquidity from the pool by fixed tokens-out,
    /// allows to remove liquidity of a subset of tokens, by providing 0 in `amounts`.
    /// Fee will be charged according to diff between ideal token portions.
    pub fn remove_liquidity_by_tokens(
        &mut self,
        sender_id: &AccountId,
        amounts: Vec<Balance>,
        max_burn_shares: Balance,
        fees: &AdminFees,
    ) -> Balance {
        let n_coins = self.token_account_ids.len();
        assert_eq!(amounts.len(), n_coins, "{}", ERR64_TOKENS_COUNT_ILLEGAL);
        let prev_shares_amount = self.shares.get(&sender_id).expect(ERR13_LP_NOT_REGISTERED);

        // make amounts into comparable-amounts
        let c_amounts = self.amounts_to_c_amounts(&amounts);
        for i in 0..n_coins {
            self.assert_min_reserve(self.c_amounts[i].checked_sub(c_amounts[i]).unwrap_or(0));
        }

        let invariant = self.get_invariant();
        let trade_fee = Fees::new(self.total_fee, &fees);

        let (burn_shares, fee_part) = invariant
            .compute_lp_amount_for_withdraw(
                &c_amounts,
                &self.c_amounts,
                self.shares_total_supply,
                &trade_fee,
            )
            .expect(ERR67_LPSHARE_CALC_ERR);

        assert!(
            burn_shares <= prev_shares_amount,
            "{}",
            ERR34_INSUFFICIENT_LP_SHARES
        );
        assert!(burn_shares <= max_burn_shares, "{}", ERR68_SLIPPAGE);

        for i in 0..n_coins {
            self.c_amounts[i] = self.c_amounts[i].checked_sub(c_amounts[i]).unwrap();
            self.assert_min_reserve(self.c_amounts[i]);
        }
        self.burn_shares(&sender_id, prev_shares_amount, burn_shares);
        env::log(
            format!(
                "LP {} removed {} shares by given tokens, and fee is {} shares",
                sender_id, burn_shares, fee_part
            )
            .as_bytes(),
        );

        if fee_part > 0 {
            // referral fee
            if let Some(referral) = &fees.referral_id {
                if self.shares.get(referral).is_some() {
                    let referral_share = fee_part * fees.referral_fee as u128 / FEE_DIVISOR as u128;
                    self.mint_shares(referral, referral_share);
                    env::log(
                        format!("Referral {} got {} shares", referral, referral_share).as_bytes(),
                    );
                }
            }
            // exchange fee
            let exchange_share = fee_part * fees.exchange_fee as u128 / FEE_DIVISOR as u128;
            self.mint_shares(&fees.exchange_id, exchange_share);
            env::log(
                format!("Admin {} got {} shares", &fees.exchange_id, exchange_share).as_bytes(),
            );
        }

        burn_shares
    }

    /// Returns number of tokens in outcome, given amount.
    /// Tokens are provided as indexes into token list for given pool.
    /// All tokens are comparable tokens
    fn internal_get_return(
        &self,
        token_in: usize,
        amount_in: Balance,
        token_out: usize,
        fees: &AdminFees,
    ) -> SwapResult {
        // make amounts into comparable-amounts
        let c_amount_in = self.amount_to_c_amount(amount_in, token_in);

        self.get_invariant()
            .swap_to(
                token_in,
                c_amount_in,
                token_out,
                &self.c_amounts,
                &Fees::new(self.total_fee, &fees),
            )
            .expect(ERR70_SWAP_OUT_CALC_ERR)

    }

    /// Returns how much token you will receive if swap `token_amount_in` of `token_in` for `token_out`.
    pub fn get_return(
        &self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
        fees: &AdminFees,
    ) -> Balance {
        assert_ne!(token_in, token_out, "{}", ERR71_SWAP_DUP_TOKENS);
        let c_amount_out = self.internal_get_return(
            self.token_index(token_in),
            amount_in,
            self.token_index(token_out),
            &fees,
        )
        .amount_swapped;
        self.c_amount_to_amount(c_amount_out, self.token_index(token_out))
    }

    /// Swap `token_amount_in` of `token_in` token into `token_out` and return how much was received.
    /// Assuming that `token_amount_in` was already received from `sender_id`.
    pub fn swap(
        &mut self,
        token_in: &AccountId,
        amount_in: Balance,
        token_out: &AccountId,
        min_amount_out: Balance,
        fees: &AdminFees,
    ) -> Balance {
        assert_ne!(token_in, token_out, "{}", ERR71_SWAP_DUP_TOKENS);
        let in_idx = self.token_index(token_in);
        let out_idx = self.token_index(token_out);
        let result = self.internal_get_return(in_idx, amount_in, out_idx, &fees);
        assert!(
            self.c_amount_to_amount(result.amount_swapped, out_idx) >= min_amount_out,
            "{}",
            ERR68_SLIPPAGE
        );
        env::log(
            format!(
                "Swapped {} {} for {} {}, total fee {}, admin fee {}",
                amount_in, token_in, 
                self.c_amount_to_amount(result.amount_swapped, out_idx), 
                token_out, 
                self.c_amount_to_amount(result.fee, out_idx), 
                self.c_amount_to_amount(result.admin_fee, out_idx)
            )
            .as_bytes(),
        );

        self.c_amounts[in_idx] = result.new_source_amount;
        self.c_amounts[out_idx] = result.new_destination_amount;
        self.assert_min_reserve(self.c_amounts[out_idx]);

        // Keeping track of volume per each input traded separately.
        self.volumes[in_idx].input.0 += amount_in;
        self.volumes[out_idx].output.0 += self.c_amount_to_amount(result.amount_swapped, out_idx);

        // handle admin / referral fee.
        if fees.referral_fee + fees.exchange_fee > 0 {
            let mut fee_token = 0_u128;
            // referral fee
            if let Some(referral) = &fees.referral_id {
                if self.shares.get(referral).is_some() {
                    fee_token = result.admin_fee * fees.referral_fee as u128
                        / (fees.referral_fee + fees.exchange_fee) as u128;
                    if fee_token > 0 {
                        let referral_share =
                            self.admin_fee_to_liquidity(referral, out_idx, fee_token);
                        env::log(
                            format!(
                                "Referral {} got {} shares from {} {}",
                                referral,
                                referral_share,
                                self.c_amount_to_amount(fee_token, out_idx),
                                self.token_account_ids[out_idx]
                            )
                            .as_bytes(),
                        );
                    }
                }
            }
            // exchange fee = admin_fee - referral_fee
            fee_token = result.admin_fee - fee_token;
            if fee_token > 0 {
                let exchange_share =
                    self.admin_fee_to_liquidity(&fees.exchange_id, out_idx, fee_token);
                env::log(
                    format!(
                        "Admin {} got {} shares from {} {}",
                        &fees.exchange_id,
                        exchange_share,
                        self.c_amount_to_amount(fee_token, out_idx),
                        self.token_account_ids[out_idx]
                    )
                    .as_bytes(),
                );
            }
        }

        self.c_amount_to_amount(result.amount_swapped, out_idx)
    }

    /// convert admin_fee into shares without any fee.
    /// return share minted this time for the admin/referrer.
    fn admin_fee_to_liquidity(
        &mut self,
        sender_id: &AccountId,
        token_id: usize,
        c_amount: Balance,
    ) -> Balance {
        let invariant = self.get_invariant();

        let mut c_amounts = vec![0_u128; self.c_amounts.len()];
        c_amounts[token_id] = c_amount;

        let (new_shares, _) = invariant
            .compute_lp_amount_for_deposit(
                &c_amounts,
                &self.c_amounts,
                self.shares_total_supply,
                &Fees::zero(),
            )
            .expect(ERR67_LPSHARE_CALC_ERR);
        self.c_amounts[token_id] += c_amount;

        self.mint_shares(sender_id, new_shares);
        new_shares
    }

    /// Mint new shares for given user.
    fn mint_shares(&mut self, account_id: &AccountId, shares: Balance) {
        if shares == 0 {
            return;
        }
        self.shares_total_supply += shares;
        add_to_collection(&mut self.shares, &account_id, shares);
    }

    /// Burn shares from given user's balance.
    fn burn_shares(
        &mut self,
        account_id: &AccountId,
        prev_shares_amount: Balance,
        shares: Balance,
    ) {
        if shares == 0 {
            return;
        }
        // Never remove shares from storage to allow to bring it back without extra storage deposit.
        self.shares_total_supply -= shares;
        self.shares
            .insert(&account_id, &(prev_shares_amount - shares));
    }

    /// Register given account with 0 balance in shares.
    /// Storage payment should be checked by caller.
    pub fn share_register(&mut self, account_id: &AccountId) {
        if self.shares.contains_key(account_id) {
            env::panic(ERR14_LP_ALREADY_REGISTERED.as_bytes());
        }
        self.shares.insert(account_id, &0);
    }

    /// Transfers shares from predecessor to receiver.
    pub fn share_transfer(&mut self, sender_id: &AccountId, receiver_id: &AccountId, amount: u128) {
        let balance = self.shares.get(&sender_id).expect(ERR13_LP_NOT_REGISTERED);
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.shares.insert(&sender_id, &new_balance);
        } else {
            env::panic(ERR34_INSUFFICIENT_LP_SHARES.as_bytes());
        }
        let balance_out = self
            .shares
            .get(&receiver_id)
            .expect(ERR13_LP_NOT_REGISTERED);
        self.shares.insert(&receiver_id, &(balance_out + amount));
    }

    /// Returns balance of shares for given user.
    pub fn share_balance_of(&self, account_id: &AccountId) -> Balance {
        self.shares.get(account_id).unwrap_or_default()
    }

    /// Returns total number of shares in this pool.
    pub fn share_total_balance(&self) -> Balance {
        self.shares_total_supply
    }

    /// Returns list of tokens in this pool.
    pub fn tokens(&self) -> &[AccountId] {
        &self.token_account_ids
    }

    /// [Admin function] increase the amplification factor.
    pub fn ramp_amplification(&mut self, future_amp_factor: u128, future_amp_time: Timestamp) {
        let current_time = env::block_timestamp();
        assert!(
            current_time >= self.init_amp_time + MIN_RAMP_DURATION,
            "{}",
            ERR81_AMP_IN_LOCK
        );
        assert!(
            future_amp_time >= current_time + MIN_RAMP_DURATION,
            "{}",
            ERR82_INSUFFICIENT_RAMP_TIME
        );
        let invariant = StableSwap::new(
            self.init_amp_factor,
            self.target_amp_factor,
            current_time,
            self.init_amp_time,
            self.stop_amp_time,
        );
        let amp_factor = invariant
            .compute_amp_factor()
            .expect(ERR66_INVARIANT_CALC_ERR);
        assert!(
            future_amp_factor > 0 && future_amp_factor < MAX_AMP,
            "{}",
            ERR83_INVALID_AMP_FACTOR
        );
        assert!(
            (future_amp_factor >= amp_factor && future_amp_factor <= amp_factor * MAX_AMP_CHANGE)
                || (future_amp_factor < amp_factor
                    && future_amp_factor * MAX_AMP_CHANGE >= amp_factor),
            "{}",
            ERR84_AMP_LARGE_CHANGE
        );
        self.init_amp_factor = amp_factor;
        self.init_amp_time = current_time;
        self.target_amp_factor = future_amp_factor;
        self.stop_amp_time = future_amp_time;
    }

    /// [Admin function] Stop increase of amplification factor.
    pub fn stop_ramp_amplification(&mut self) {
        let current_time = env::block_timestamp();
        let invariant = StableSwap::new(
            self.init_amp_factor,
            self.target_amp_factor,
            current_time,
            self.init_amp_time,
            self.stop_amp_time,
        );
        let amp_factor = invariant
            .compute_amp_factor()
            .expect(ERR65_INIT_TOKEN_BALANCE);
        self.init_amp_factor = amp_factor;
        self.target_amp_factor = amp_factor;
        self.init_amp_time = current_time;
        self.stop_amp_time = current_time;
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};
    use std::convert::TryInto;

    use super::*;

    fn swap(
        pool: &mut StableSwapPool,
        token_in: usize,
        amount_in: Balance,
        token_out: usize,
    ) -> Balance {
        pool.swap(
            accounts(token_in).as_ref(),
            amount_in,
            accounts(token_out).as_ref(),
            0,
            &AdminFees::zero(),
        )
    }

    #[test]
    fn test_stable_julia_01() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 1000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![100000000000, 100000000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 10000000000, 2);
        assert_eq!(out, 9999495232);
        assert_eq!(pool.c_amounts, vec![110000000000000000000000, 90000504767247802010004]);
    }

    #[test]
    fn test_stable_julia_02() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 1000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![100000000000, 100000000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 0, 2);
        assert_eq!(out, 0);
        assert_eq!(pool.c_amounts, vec![100000000000000000000000, 100000000000000000000000]);
    }

    #[test]
    fn test_stable_julia_03() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 1000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![100000000000, 100000000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 1, 2);
        assert_eq!(out, 1);
        assert_eq!(pool.c_amounts, vec![100000000001000000000000, 99999999999000000000000]);
    }

    #[test]
    fn test_stable_julia_04() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 1000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![100000000000, 100000000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 100000000000, 2);
        assert_eq!(out, 98443663539);
        assert_eq!(pool.c_amounts, vec![200000000000000000000000, 1556336460086846919343]);
    }

    #[test]
    fn test_stable_julia_05() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 1000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![100000000000, 100000000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 99999000000, 2);
        assert_eq!(out, 98443167413);
        assert_eq!(pool.c_amounts, vec![199999000000000000000000, 1556832586795864493703]);
    }

    #[test]
    fn test_stable_max() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(
            0, 
            vec![
                "aone.near".try_into().unwrap(),
                "atwo.near".try_into().unwrap(),
                "athree.near".try_into().unwrap(),
                "afour.near".try_into().unwrap(),
                "afive.near".try_into().unwrap(),
                "asix.near".try_into().unwrap(),
                "aseven.near".try_into().unwrap(),
                "aeight.near".try_into().unwrap(),
                "anine.near".try_into().unwrap(), 
            ], 
            vec![
                6, 
                6, 
                6, 
                6, 
                6, 
                6, 
                6, 
                6, 
                6,
            ], 
            1000, 
            0
        );
        assert_eq!(
            pool.tokens(),
            vec![
                "aone.near".to_string(),
                "atwo.near".to_string(),
                "athree.near".to_string(),
                "afour.near".to_string(),
                "afive.near".to_string(),
                "asix.near".to_string(),
                "aseven.near".to_string(),
                "aeight.near".to_string(),
                "anine.near".to_string(), 
            ]
        );

        let mut amounts = vec![
            100000000000_000000, 
            100000000000_000000, 
            100000000000_000000, 
            100000000000_000000, 
            100000000000_000000,
            100000000000_000000, 
            100000000000_000000, 
            100000000000_000000, 
            100000000000_000000,
        ];
        let share = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);
        assert_eq!(share, 900000000000_000000000000000000);
        let out = pool.swap(
            &String::from("aone.near"),
            99999000000,
            &String::from("atwo.near"),
            0,
            &AdminFees::zero(),
        );
        assert_eq!(out, 99998999999);
    }

    #[test]
    fn test_stable_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let fees = AdminFees::zero();
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 10000, 0);
        assert_eq!(
            pool.tokens(),
            vec![accounts(1).to_string(), accounts(2).to_string()]
        );

        let mut amounts = vec![5000000, 10000000];
        let _ = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let out = swap(&mut pool, 1, 1000000, 2);
        assert_eq!(out, 1000031);
        assert_eq!(pool.c_amounts, vec![6000000000000000000, 8999968751649207660]);
        let out2 = swap(&mut pool, 2, out, 1);
        assert_eq!(out2, 999999); // due to precision difference.
        assert_eq!(pool.c_amounts, vec![5000000248340316022, 9999999751649207660]);

        // Add only one side of the capital.
        let mut amounts2 = vec![5000000, 0];
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts2, 1, &fees);

        // Withdraw on same side of the capital.
        let shares_burned = pool.remove_liquidity_by_tokens(
            accounts(0).as_ref(),
            vec![5000000, 0],
            num_shares,
            &fees,
        );
        assert_eq!(shares_burned, num_shares);

        // Add only one side of the capital, and withdraw by share
        let mut amounts2 = vec![5000000, 0];
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts2, 1, &fees);

        let tokens = pool.remove_liquidity_by_shares(accounts(0).as_ref(), num_shares, vec![1, 1]);
        assert_eq!(tokens[0], 2500023);
        assert_eq!(tokens[1], 2500023);

        // Add only one side of the capital, and withdraw from another side
        let mut amounts2 = vec![5000000, 0];
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts2, 1, &fees);
        let shares_burned = pool.remove_liquidity_by_tokens(
            accounts(0).as_ref(),
            vec![0, 5000000 - 1200],
            num_shares,
            &fees,
        );
        // as imbalance withdraw, will lose a little amount token
        assert!(shares_burned < num_shares);
    }

    /// Test everything with fees.
    #[test]
    fn test_stable_with_fees() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let mut pool =
            StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 10000, 2000);
        let mut amounts = vec![5000000, 10000000];
        let fees = AdminFees::new(1000); // 10% exchange fee

        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);

        let amount_out = pool.swap(
            accounts(1).as_ref(),
            1000000,
            accounts(2).as_ref(),
            1,
            &fees,
        );
        println!("swap out: {}", amount_out);
        let tokens = pool.remove_liquidity_by_shares(accounts(0).as_ref(), num_shares/2, vec![1, 1]);
        assert_eq!(tokens[0], 2996052);
        assert_eq!(tokens[1], 4593934);
    }

    /// Test that adding and then removing all of the liquidity leaves the pool empty and with no shares.
    #[test]
    #[should_panic(expected = "E69: pool reserved token balance less than MIN_RESERVE")]
    fn test_stable_add_transfer_remove_liquidity() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 10000, 0);
        let mut amounts = vec![5000000, 10000000];
        let fees = AdminFees::zero();
        let num_shares = pool.add_liquidity(accounts(0).as_ref(), &mut amounts, 1, &fees);
        assert_eq!(amounts, vec![5000000, 10000000]);
        assert!(num_shares > 1);
        assert_eq!(num_shares, pool.share_balance_of(accounts(0).as_ref()));
        assert_eq!(pool.share_total_balance(), num_shares);

        // Move shares to another account.
        pool.share_register(accounts(3).as_ref());
        pool.share_transfer(accounts(0).as_ref(), accounts(3).as_ref(), num_shares);
        assert_eq!(pool.share_balance_of(accounts(0).as_ref()), 0);
        assert_eq!(pool.share_balance_of(accounts(3).as_ref()), num_shares);
        assert_eq!(pool.share_total_balance(), num_shares);

        // Remove all liquidity.
        testing_env!(context.predecessor_account_id(accounts(3)).build());
        pool.remove_liquidity_by_shares(accounts(3).as_ref(), num_shares, vec![1, 1]);
    }

    /// Test ramping up amplification factor, ramping it even more and then stopping.
    #[test]
    fn test_stable_ramp_amp() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let mut pool = StableSwapPool::new(0, vec![accounts(1), accounts(2)], vec![6, 6], 10000, 0);

        let start_ts = MIN_RAMP_DURATION + 1_000_000_000;
        testing_env!(context.block_timestamp(start_ts).build());
        pool.ramp_amplification(50000, start_ts + MIN_RAMP_DURATION * 10);
        testing_env!(context
            .block_timestamp(start_ts + MIN_RAMP_DURATION * 3)
            .build());
        pool.ramp_amplification(150000, start_ts + MIN_RAMP_DURATION * 20);
        testing_env!(context
            .block_timestamp(start_ts + MIN_RAMP_DURATION * 5)
            .build());
        pool.stop_ramp_amplification();
    }
}

'''
'''--- ref-exchange/src/storage_impl.rs ---
use crate::*;

/// Implements users storage management for the pool.
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        self.assert_contract_running();
        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let registration_only = registration_only.unwrap_or(false);
        let min_balance = self.storage_balance_bounds().min.0;
        let already_registered = self.accounts.contains_key(&account_id);
        if amount < min_balance && !already_registered {
            env::panic(b"ERR_DEPOSIT_LESS_THAN_MIN_STORAGE");
        }
        if registration_only {
            // Registration only setups the account but doesn't leave space for tokens.
            if already_registered {
                log!("ERR_ACC_REGISTERED");
                if amount > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(amount);
                }
            } else {
                self.internal_register_account(&account_id, min_balance);
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
            }
        } else {
            self.internal_register_account(&account_id, amount);
        }
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        self.assert_contract_running();
        let account_id = env::predecessor_account_id();
        let amount = amount.unwrap_or(U128(0)).0;
        let withdraw_amount = self.internal_storage_withdraw(&account_id, amount);
        Promise::new(account_id.clone()).transfer(withdraw_amount);
        self.storage_balance_of(account_id.try_into().unwrap())
            .unwrap()
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        self.assert_contract_running();
        let account_id = env::predecessor_account_id();
        if let Some(account_deposit) = self.internal_get_account(&account_id) {
            // TODO: figure out force option logic.
            assert!(
                account_deposit.tokens.is_empty(),
                "ERR_STORAGE_UNREGISTER_TOKENS_NOT_EMPTY"
            );
            self.accounts.remove(&account_id);
            Promise::new(account_id.clone()).transfer(account_deposit.near_amount);
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: Account::min_storage_usage().into(),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_get_account(account_id.as_ref())
            .map(|account| 
                { 
                    StorageBalance {
                        total: U128(account.near_amount),
                        available: U128(account.storage_available()),
                    } 
                })
    }
}

'''
'''--- ref-exchange/src/token_receiver.rs ---

use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{serde_json, PromiseOrValue};

use crate::*;

pub const VIRTUAL_ACC: &str = "@";

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
enum TokenReceiverMessage {
    /// Alternative to deposit + execute actions call.
    Execute {
        referral_id: Option<ValidAccountId>,
        /// List of sequential actions.
        actions: Vec<Action>,
    },
}

impl Contract {
    /// Executes set of actions on virtual account.
    /// Returns amounts to send to the sender directly.
    fn internal_direct_actions(
        &mut self,
        token_in: AccountId,
        amount_in: Balance,
        referral_id: Option<AccountId>,
        actions: &[Action],
    ) -> Vec<(AccountId, Balance)> {

        // let @ be the virtual account
        let mut account: Account = Account::new(&String::from(VIRTUAL_ACC));

        account.deposit(&token_in, amount_in);
        let _ = self.internal_execute_actions(
            &mut account,
            &referral_id,
            &actions,
            ActionResult::Amount(U128(amount_in)),
        );

        let mut result = vec![];
        for (token, amount) in account.tokens.to_vec() {
            if amount > 0 {
                result.push((token.clone(), amount));
            }
        }
        account.tokens.clear();

        result
    }

}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    /// `msg` format is either "" for deposit or `TokenReceiverMessage`.
    #[allow(unreachable_code)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        self.assert_contract_running();
        let token_in = env::predecessor_account_id();
        if msg.is_empty() {
            // Simple deposit.
            self.internal_deposit(sender_id.as_ref(), &token_in, amount.into());
            PromiseOrValue::Value(U128(0))
        } else {
            // instant swap
            let message =
                serde_json::from_str::<TokenReceiverMessage>(&msg).expect(ERR28_WRONG_MSG_FORMAT);
            match message {
                TokenReceiverMessage::Execute {
                    referral_id,
                    actions,
                } => {
                    let referral_id = referral_id.map(|x| x.to_string());
                    let out_amounts = self.internal_direct_actions(
                        token_in,
                        amount.0,
                        referral_id,
                        &actions,
                    );
                    for (token_out, amount_out) in out_amounts.into_iter() {
                        self.internal_send_tokens(sender_id.as_ref(), &token_out, amount_out);
                    }
                    // Even if send tokens fails, we don't return funds back to sender.
                    PromiseOrValue::Value(U128(0))
                }
            }
        }
    }
}
'''
'''--- ref-exchange/src/utils.rs ---
use std::collections::HashSet;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{ext_contract, AccountId, Balance, Gas};
use uint::construct_uint;

/// Attach no deposit.
pub const NO_DEPOSIT: u128 = 0;
/// hotfix_insuffient_gas_for_mft_resolve_transfer.
pub const GAS_FOR_RESOLVE_TRANSFER: Gas = 20_000_000_000_000;

pub const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

/// Amount of gas for fungible token transfers, increased to 20T to support AS token contracts.
pub const GAS_FOR_FT_TRANSFER: Gas = 20_000_000_000_000;

/// Fee divisor, allowing to provide fee in bps.
pub const FEE_DIVISOR: u32 = 10_000;

/// Initial shares supply on deposit of liquidity.
pub const INIT_SHARES_SUPPLY: u128 = 1_000_000_000_000_000_000_000_000;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Volume of swap on the given token.
#[derive(Clone, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapVolume {
    pub input: U128,
    pub output: U128,
}

impl Default for SwapVolume {
    fn default() -> Self {
        Self {
            input: U128(0),
            output: U128(0),
        }
    }
}

#[ext_contract(ext_self)]
pub trait RefExchange {
    fn exchange_callback_post_withdraw(
        &mut self,
        token_id: AccountId,
        sender_id: AccountId,
        amount: U128,
    );
}

/// Adds given value to item stored in the given key in the LookupMap collection.
pub fn add_to_collection(c: &mut LookupMap<AccountId, Balance>, key: &String, value: Balance) {
    let prev_value = c.get(key).unwrap_or(0);
    c.insert(key, &(prev_value + value));
}

/// Checks if there are any duplicates in the given list of tokens.
pub fn check_token_duplicates(tokens: &[ValidAccountId]) {
    let token_set: HashSet<_> = tokens.iter().map(|a| a.as_ref()).collect();
    assert_eq!(token_set.len(), tokens.len(), "ERR_TOKEN_DUPLICATES");
}

/// Newton's method of integer square root.
pub fn integer_sqrt(value: U256) -> U256 {
    let mut guess: U256 = (value + U256::one()) >> 1;
    let mut res = value;
    while guess < res {
        res = guess;
        guess = (value / guess + guess) >> 1;
    }
    res
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() {
        assert_eq!(integer_sqrt(U256::from(0)), 0.into());
        assert_eq!(integer_sqrt(U256::from(4)), 2.into());
        assert_eq!(
            integer_sqrt(U256::from(1_516_156_330_329u128)),
            U256::from(1_231_323)
        );
    }
}

'''
'''--- ref-exchange/src/views.rs ---
//! View functions for the contract.

use std::collections::HashMap;

use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId};

use crate::utils::SwapVolume;
use crate::*;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Deserialize, Debug))]
pub struct ContractMetadata {
    pub version: String,
    pub owner: AccountId,
    pub guardians: Vec<AccountId>,
    pub pool_count: u64,
    pub state: RunningState,
    pub exchange_fee: u32,
    pub referral_fee: u32,
}

#[derive(Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct RefStorageState {
    pub deposit: U128,
    pub usage: U128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct PoolInfo {
    /// Pool kind.
    pub pool_kind: String,
    /// List of tokens in the pool.
    pub token_account_ids: Vec<AccountId>,
    /// How much NEAR this contract has.
    pub amounts: Vec<U128>,
    /// Fee charged for swap.
    pub total_fee: u32,
    /// Total number of shares.
    pub shares_total_supply: U128,
    pub amp: u64,
}

impl From<Pool> for PoolInfo {
    fn from(pool: Pool) -> Self {
        let pool_kind = pool.kind();
        match pool {
            Pool::SimplePool(pool) => Self {
                pool_kind,
                amp: 0,
                token_account_ids: pool.token_account_ids,
                amounts: pool.amounts.into_iter().map(|a| U128(a)).collect(),
                total_fee: pool.total_fee,
                shares_total_supply: U128(pool.shares_total_supply),
            },
            Pool::StableSwapPool(pool) => Self {
                pool_kind,
                amp: pool.get_amp(),
                amounts: pool.get_amounts().into_iter().map(|a| U128(a)).collect(),
                token_account_ids: pool.token_account_ids,
                total_fee: pool.total_fee,
                shares_total_supply: U128(pool.shares_total_supply),
            },
        }
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct StablePoolInfo {
    /// List of tokens in the pool.
    pub token_account_ids: Vec<AccountId>,
    pub decimals: Vec<u8>,
    /// backend tokens.
    pub amounts: Vec<U128>,
    /// backend tokens in comparable precision
    pub c_amounts: Vec<U128>,
    /// Fee charged for swap.
    pub total_fee: u32,
    /// Total number of shares.
    pub shares_total_supply: U128,
    pub amp: u64,
}

impl From<Pool> for StablePoolInfo {
    fn from(pool: Pool) -> Self {
        match pool {
            Pool::SimplePool(_) => unimplemented!(),
            Pool::StableSwapPool(pool) => Self {
                amp: pool.get_amp(),
                amounts: pool.get_amounts().into_iter().map(|a| U128(a)).collect(),
                decimals: pool.token_decimals,
                c_amounts: pool.c_amounts.into_iter().map(|a| U128(a)).collect(),
                token_account_ids: pool.token_account_ids,
                total_fee: pool.total_fee,
                shares_total_supply: U128(pool.shares_total_supply),
            },
        }
    }
}

#[near_bindgen]
impl Contract {

    /// Return contract basic info
    pub fn metadata(&self) -> ContractMetadata {
        ContractMetadata {
            version: env!("CARGO_PKG_VERSION").to_string(),
            owner: self.owner_id.clone(),
            guardians: self.guardians.to_vec(),
            pool_count: self.pools.len(),
            state: self.state.clone(),
            exchange_fee: self.exchange_fee,
            referral_fee: self.referral_fee,
        }
    }

    /// Only get guardians info
    pub fn get_guardians(&self) -> Vec<AccountId> {
        self.guardians.to_vec()
    }
    
    /// Returns semver of this contract.
    pub fn version(&self) -> String {
        env!("CARGO_PKG_VERSION").to_string()
    }

    /// Returns number of pools.
    pub fn get_number_of_pools(&self) -> u64 {
        self.pools.len()
    }

    /// Returns list of pools of given length from given start index.
    pub fn get_pools(&self, from_index: u64, limit: u64) -> Vec<PoolInfo> {
        (from_index..std::cmp::min(from_index + limit, self.pools.len()))
            .map(|index| self.get_pool(index))
            .collect()
    }

    /// Returns information about specified pool.
    pub fn get_pool(&self, pool_id: u64) -> PoolInfo {
        self.pools.get(pool_id).expect("ERR_NO_POOL").into()
    }

    /// Returns stable pool information about specified pool.
    pub fn get_stable_pool(&self, pool_id: u64) -> StablePoolInfo {
        self.pools.get(pool_id).expect("ERR_NO_POOL").into()
    }

    /// Return total fee of the given pool.
    pub fn get_pool_fee(&self, pool_id: u64) -> u32 {
        self.pools.get(pool_id).expect("ERR_NO_POOL").get_fee()
    }

    /// Return volumes of the given pool.
    pub fn get_pool_volumes(&self, pool_id: u64) -> Vec<SwapVolume> {
        self.pools.get(pool_id).expect("ERR_NO_POOL").get_volumes()
    }

    pub fn get_pool_share_price(&self, pool_id: u64) -> U128 {
        self.pools.get(pool_id).expect("ERR_NO_POOL").get_share_price().into()
    }

    /// Returns number of shares given account has in given pool.
    pub fn get_pool_shares(&self, pool_id: u64, account_id: ValidAccountId) -> U128 {
        self.pools
            .get(pool_id)
            .expect("ERR_NO_POOL")
            .share_balances(account_id.as_ref())
            .into()
    }

    /// Returns total number of shares in the given pool.
    pub fn get_pool_total_shares(&self, pool_id: u64) -> U128 {
        self.pools
            .get(pool_id)
            .expect("ERR_NO_POOL")
            .share_total_balance()
            .into()
    }

    /// Returns balances of the deposits for given user outside of any pools.
    /// Returns empty list if no tokens deposited.
    pub fn get_deposits(&self, account_id: ValidAccountId) -> HashMap<AccountId, U128> {
        let wrapped_account = self.internal_get_account(account_id.as_ref());
        if let Some(account) = wrapped_account {
            account.get_tokens()
                .iter()
                .map(|token| (token.clone(), U128(account.get_balance(token).unwrap())))
                .collect()
        } else {
            HashMap::new()
        }
    }

    /// Returns balance of the deposit for given user outside of any pools.
    pub fn get_deposit(&self, account_id: ValidAccountId, token_id: ValidAccountId) -> U128 {
        self.internal_get_deposit(account_id.as_ref(), token_id.as_ref())
            .into()
    }

    /// Given specific pool, returns amount of token_out recevied swapping amount_in of token_in.
    pub fn get_return(
        &self,
        pool_id: u64,
        token_in: ValidAccountId,
        amount_in: U128,
        token_out: ValidAccountId,
    ) -> U128 {
        let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        pool.get_return(token_in.as_ref(), amount_in.into(), token_out.as_ref(), &AdminFees::new(self.exchange_fee))
            .into()
    }

    /// Get contract level whitelisted tokens.
    pub fn get_whitelisted_tokens(&self) -> Vec<AccountId> {
        self.whitelisted_tokens.to_vec()
    }

    /// Get specific user whitelisted tokens.
    pub fn get_user_whitelisted_tokens(&self, account_id: ValidAccountId) -> Vec<AccountId> {
        self.internal_get_account(account_id.as_ref())
            .map(|x| x.get_tokens())
            .unwrap_or_default()
    }

    /// Get user's storage deposit and needed in the account of current version
    pub fn get_user_storage_state(&self, account_id: ValidAccountId) -> Option<RefStorageState> {
        let acc = self.internal_get_account(account_id.as_ref());
        if let Some(account) = acc {
            Some(
                RefStorageState {
                    deposit: U128(account.near_amount),
                    usage: U128(account.storage_usage()),
                }
            )           
        } else {
            None
        }
    }

    pub fn predict_add_stable_liquidity(
        &self,
        pool_id: u64,
        amounts: &Vec<U128>,
    ) -> U128 {
        let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        pool.predict_add_stable_liquidity(&amounts.into_iter().map(|x| x.0).collect(), &AdminFees::new(self.exchange_fee))
            .into()
    }

    pub fn predict_remove_liquidity(
        &self,
        pool_id: u64,
        shares: U128,
    ) -> Vec<U128> {
        let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        pool.predict_remove_liquidity(shares.into()).into_iter().map(|x| U128(x)).collect()
    }

    pub fn predict_remove_liquidity_by_tokens(
        &self,
        pool_id: u64,
        amounts: &Vec<U128>,
    ) -> U128 {
        let pool = self.pools.get(pool_id).expect("ERR_NO_POOL");
        pool.predict_remove_liquidity_by_tokens(&amounts.into_iter().map(|x| x.0).collect(), &AdminFees::new(self.exchange_fee))
            .into()
    }
}

'''
'''--- ref-exchange/stable_swap.md ---
# Stable Swap Pool Instruction

## Logic
---
It is for swapping among stable coins.  

The stable swap pool can have more than 2 kinds of tokens (maximum 9 kinds of tokens with each 100 billion balances in simulation test ENV).  

The decimal of each token must in [1, 18].  

The most likely first stable pool in REF would be [nDAI, nUSDT, nUSDC].  

## Interfaces
---
### Create Stable Swap Pool
Only owner or guardians of the ref-exchange contract can create stable swap pool.
```Bash
near call ref-exchange.testnet add_stable_swap_pool '{"tokens": ["ndai.testnet", "nusdt.testnet", "nusdc.testnet"], "decimals": [18, 6, 6], "fee": 25, "amp_factor": 100000}' --account_id=owner.testnet --amount=1
# it will return pool_id
```

### Add Initial Liquidity
This interface is only for stable swap pools. Anyone can supply initial liquidity, but all tokens should be filled.
```Bash
# add 1 dai, 1 usdt and 1 usdc as initial liquidity with minimum 3 lpt shares
near call ref-exchange.testnet add_stable_liquidity '{"pool_id": 100, "amounts": ["1000000000000000000", "1000000", "1000000"], "min_shares": "3000000000000000000"}' --account_id=owner.testnet --amount=1
# will return actually minted lpt shares
```

### Add Subsequent Liquidity
This interface is only for stable swap pools. Anyone can supply subsequent liquidity with subset of tokens.
```Bash
# add 100 dai, 10 usdt and 0 usdc with minimum 103 lpt shares
near call ref-exchange.testnet add_stable_liquidity '{"pool_id": 100, "amounts": ["100000000000000000000", "10000000", "0"], "min_shares": "103000000000000000000"}' --account_id=user.testnet --amount=1
# will return actually minted lpt shares
```

### Withdraw Liquidity by Share
Anyone can withdraw liquidity by shares. the output less than `min_amounts` would cause TX failure.
```Bash
# withdraw 100 shares with min_amount 10 balance each
near call ref-exchange.testnet remove_liquidity '{"pool_id": 100, "shares": "100000000000000000000", "min_amounts": ["10000000000000000000", "10000000", "10000000"]}' --account_id=user.testnet --amount=0.000000000000000001
```

### Withdraw Liquidity by Tokens
This interface is only for stable swap pools. Anyone can withdraw liquidity by tokens. It will return designated tokens to user's inner account, but if burned shares more than `max_burn_shares` would cause TX failure.
```Bash
# withdraw 50 nUSDT with max_burn_shares 60 balance
near call ref-exchange.testnet remove_liquidity_by_tokens '{"pool_id": 100, "max_burn_shares": "60000000000000000000", "amounts": ["0", "50000000", "0"]}' --account_id=user.testnet --amount=0.000000000000000001
# will return actually burned lpt shares
```

### Swap in Stable Swap Pool
This interface is same as regular pool.
```Bash
# swap 1 nusdt to nusdc and if output is less than 0.99 the TX would failure
near call ref-exchange.testnet swap '{"actions": [{"pool_id": 100, "token_in": "nusdt.testnet", "amount_in": "1000000", "token_out": "nusdc.testnet", "min_amount_out": "990000"}], "referral_id": "referral.testnet"}' --account_id=user.testnet --amount=0.000000000000000001
```

'''
'''--- ref-exchange/tests/common/mod.rs ---
pub mod utils;
'''
'''--- ref-exchange/tests/common/utils.rs ---
use std::collections::HashMap;
use std::convert::TryFrom;

use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde_json::{Value, from_value};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};

use ref_exchange::{ContractContract as Exchange, PoolInfo, ContractMetadata};
use test_token::ContractContract as TestToken;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TEST_TOKEN_WASM_BYTES => "../res/test_token.wasm",
    PREV_EXCHANGE_WASM_BYTES => "../res/ref_exchange_131.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RefStorageState {
    pub deposit: U128,
    pub usage: U128,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// pub fn should_fail(r: ExecutionResult) {
//     println!("{:?}", r.status());
//     match r.status() {
//         ExecutionStatus::Failure(_) => {}
//         _ => panic!("Should fail"),
//     }
// }

pub fn show_promises(r: &ExecutionResult) {
    for promise in r.promise_results() {
        println!("{:?}", promise);
    }
}

pub fn get_logs(r: &ExecutionResult) -> Vec<String> {
    let mut logs: Vec<String> = vec![];
    r.promise_results().iter().map(
        |ex| ex.as_ref().unwrap().logs().iter().map(
            |x| logs.push(x.clone())
        ).for_each(drop)
    ).for_each(drop);
    logs
}

pub fn get_error_count(r: &ExecutionResult) -> u32 {
    r.promise_errors().len() as u32
}

pub fn get_error_status(r: &ExecutionResult) -> String {
    format!("{:?}", r.promise_errors()[0].as_ref().unwrap().status())
}

pub fn test_token(
    root: &UserAccount,
    token_id: AccountId,
    accounts_to_register: Vec<AccountId>,
) -> ContractAccount<TestToken> {
    let t = deploy!(
        contract: TestToken,
        contract_id: token_id,
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root
    );
    call!(root, t.new()).assert_success();
    call!(
        root,
        t.mint(to_va(root.account_id.clone()), to_yocto("1000000000").into())
    )
    .assert_success();
    for account_id in accounts_to_register {
        call!(
            root,
            t.storage_deposit(Some(to_va(account_id)), None),
            deposit = to_yocto("1")
        )
        .assert_success();
    }
    t
}

//*****************************
// View functions
//*****************************

/// tell a user if he has registered to given ft token
pub fn is_register_to_token(
    token: &ContractAccount<TestToken>, 
    account_id: ValidAccountId
) -> bool {
    let sb = view!(token.storage_balance_of(account_id)).unwrap_json_value();
    if let Value::Null = sb {
        false
    } else {
        true
    }
}

/// get user's ft balance of given token
pub fn balance_of(token: &ContractAccount<TestToken>, account_id: &AccountId) -> u128 {
    view!(token.ft_balance_of(to_va(account_id.clone()))).unwrap_json::<U128>().0
}

/// get ref-exchange's metadata
pub fn get_metadata(pool: &ContractAccount<Exchange>) -> ContractMetadata {
    view!(pool.metadata()).unwrap_json::<ContractMetadata>()
}

/// get ref-exchange's version
pub fn get_version(pool: &ContractAccount<Exchange>) -> String {
    view!(pool.version()).unwrap_json::<String>()
}

/// get ref-exchange's pool count
pub fn get_num_of_pools(pool: &ContractAccount<Exchange>) -> u64 {
    view!(pool.get_number_of_pools()).unwrap_json::<u64>()
}

/// get ref-exchange's all pool info
pub fn get_pools(pool: &ContractAccount<Exchange>) -> Vec<PoolInfo> {
    view!(pool.get_pools(0, 100)).unwrap_json::<Vec<PoolInfo>>()
}

/// get ref-exchange's pool info
pub fn get_pool(pool: &ContractAccount<Exchange>, pool_id: u64) -> PoolInfo {
    view!(pool.get_pool(pool_id))
        .unwrap_json::<PoolInfo>()
}

pub fn get_deposits(
    pool: &ContractAccount<Exchange>, 
    account_id: ValidAccountId
) -> HashMap<String, U128> {
    view!(pool.get_deposits(account_id)).unwrap_json::<HashMap<String, U128>>()
}

/// get ref-exchange's whitelisted tokens
pub fn get_whitelist(pool: &ContractAccount<Exchange>) -> Vec<String> {
    view!(pool.get_whitelisted_tokens()).unwrap_json::<Vec<String>>()
}

/// get ref-exchange's user whitelisted tokens
pub fn get_user_tokens(pool: &ContractAccount<Exchange>, account_id: ValidAccountId) -> Vec<String> {
    view!(pool.get_user_whitelisted_tokens(account_id)).unwrap_json::<Vec<String>>()
}

pub fn get_storage_balance(
    pool: &ContractAccount<Exchange>, 
    account_id: ValidAccountId
) -> Option<StorageBalance> {
    let sb = view!(pool.storage_balance_of(account_id)).unwrap_json_value();
    if let Value::Null = sb {
        None
    } else {
        // near_sdk::serde_json::
        let ret: StorageBalance = from_value(sb).unwrap();
        Some(ret)
    }
}

pub fn get_storage_state(
    pool: &ContractAccount<Exchange>, 
    account_id: ValidAccountId
) -> Option<RefStorageState> {
    let sb = view!(pool.get_user_storage_state(account_id)).unwrap_json_value();
    if let Value::Null = sb {
        None
    } else {
        let ret: RefStorageState = from_value(sb).unwrap();
        Some(ret)
    }
}

pub fn mft_balance_of(
    pool: &ContractAccount<Exchange>,
    token_or_pool: &str,
    account_id: &AccountId,
) -> u128 {
    view!(pool.mft_balance_of(token_or_pool.to_string(), to_va(account_id.clone())))
        .unwrap_json::<U128>()
        .0
}

pub fn mft_total_supply(
    pool: &ContractAccount<Exchange>,
    token_or_pool: &str,
) -> u128 {
    view!(pool.mft_total_supply(token_or_pool.to_string()))
        .unwrap_json::<U128>()
        .0
}

pub fn pool_share_price(
    pool: &ContractAccount<Exchange>,
    pool_id: u64,
) -> u128 {
    view!(pool.get_pool_share_price(pool_id))
        .unwrap_json::<U128>()
        .0
}

//************************************

pub fn dai() -> AccountId {
    "dai001".to_string()
}

pub fn eth() -> AccountId {
    "eth002".to_string()
}

pub fn usdt() -> AccountId {
    "usdt".to_string()
}

pub fn usdc() -> AccountId {
    "usdc".to_string()
}

pub fn swap() -> AccountId {
    "swap".to_string()
}

pub fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

pub fn setup_pool_with_liquidity() -> (
    UserAccount,
    UserAccount,
    ContractAccount<Exchange>,
    ContractAccount<TestToken>,
    ContractAccount<TestToken>,
    ContractAccount<TestToken>,
) {
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va("owner".to_string()), 4, 1)
    );
    let token1 = test_token(&root, dai(), vec![swap()]);
    let token2 = test_token(&root, eth(), vec![swap()]);
    let token3 = test_token(&root, usdt(), vec![swap()]);
    call!(
        owner,
        pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth()), to_va(usdt())])
    );
    call!(
        root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        root,
        pool.add_simple_pool(vec![to_va(eth()), to_va(usdt())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        root,
        pool.add_simple_pool(vec![to_va(usdt()), to_va(dai())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        owner,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        root,
        token1.ft_transfer_call(to_va(swap()), to_yocto("105").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        token2.ft_transfer_call(to_va(swap()), to_yocto("110").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        token3.ft_transfer_call(to_va(swap()), to_yocto("110").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        pool.add_liquidity(0, vec![U128(to_yocto("10")), U128(to_yocto("20"))], None),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    call!(
        root,
        pool.add_liquidity(1, vec![U128(to_yocto("20")), U128(to_yocto("10"))], None),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    call!(
        root,
        pool.add_liquidity(2, vec![U128(to_yocto("10")), U128(to_yocto("10"))], None),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    (root, owner, pool, token1, token2, token3)
}

pub fn setup_stable_pool_with_liquidity(
    tokens: Vec<String>,
    amounts: Vec<u128>,
    decimals: Vec<u8>,
    pool_fee: u32,
    amp: u64,
) -> (
    UserAccount,
    UserAccount,
    ContractAccount<Exchange>,
    Vec<ContractAccount<TestToken>>,
) {
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(owner.valid_account_id(), 1600, 400)
    );

    let mut token_contracts: Vec<ContractAccount<TestToken>> = vec![];
    for token_name in &tokens {
        token_contracts.push(test_token(&root, token_name.clone(), vec![swap()]));
    }

    call!(
        owner,
        pool.extend_whitelisted_tokens(
            (&token_contracts).into_iter().map(|x| x.valid_account_id()).collect()
        )
    );
    call!(
        owner,
        pool.add_stable_swap_pool(
            (&token_contracts).into_iter().map(|x| x.valid_account_id()).collect(), 
            decimals,
            pool_fee,
            amp
        ),
        deposit = to_yocto("1"))
    .assert_success();

    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        owner,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    for (idx, amount) in amounts.clone().into_iter().enumerate() {
        let c = token_contracts.get(idx).unwrap();
        call!(
            root,
            c.ft_transfer_call(
                pool.valid_account_id(), 
                U128(amount), 
                None, 
                "".to_string()
            ),
            deposit = 1
        )
        .assert_success();
    }

    call!(
        root,
        pool.add_stable_liquidity(0, amounts.into_iter().map(|x| U128(x)).collect(), U128(1)),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    (root, owner, pool, token_contracts)
}

pub fn mint_and_deposit_token(
    user: &UserAccount,
    token: &ContractAccount<TestToken>,
    ex: &ContractAccount<Exchange>,
    amount: u128,
) {
    call!(
        user,
        token.mint(user.valid_account_id(), U128(amount))
    )
    .assert_success();
    call!(
        user,
        ex.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        user,
        token.ft_transfer_call(
            ex.valid_account_id(), 
            U128(amount), 
            None, 
            "".to_string()
        ),
        deposit = 1
    )
    .assert_success();
}

pub fn setup_exchange(root: &UserAccount, exchange_fee: u32, referral_fee: u32) -> (
    UserAccount,
    ContractAccount<Exchange>,
) {
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va("owner".to_string()), exchange_fee, referral_fee)
    );
    (owner, pool)
}

pub fn whitelist_token(
    owner: &UserAccount, 
    ex: &ContractAccount<Exchange>,
    tokens: Vec<ValidAccountId>,
) {
    call!(
        owner,
        ex.extend_whitelisted_tokens(tokens)
    ).assert_success();
}

pub fn deposit_token(
    user: &UserAccount, 
    ex: &ContractAccount<Exchange>,
    tokens: Vec<&ContractAccount<TestToken>>,
    amounts: Vec<u128>,
) {
    for (idx, token) in tokens.into_iter().enumerate() {
        call!(
            user,
            ex.storage_deposit(None, None),
            deposit = to_yocto("0.1")
        )
        .assert_success();
        call!(
            user,
            token.ft_transfer_call(
                ex.valid_account_id(), 
                U128(amounts[idx]), 
                None, 
                "".to_string()
            ),
            deposit = 1
        )
        .assert_success();
    }
}
'''
'''--- ref-exchange/tests/fuzzy/constants.rs ---
#![allow(unused)] 
pub const TOKENS: [&str; 10] = ["ref", "dai", "usdt", "usdc", "weth", "wnear", "1inch", "grt", "oct", "uni"];

pub const EVERY_PREFERENCE_NUM: i32 = 1;
pub const INIT_ACCOUNT_FOR_TOKEN: u64 = 200;

pub const INIT_TOKEN_TO_SWAP_POOL_LIMIT: u64 = 100;
pub const ADD_LIQUIDITY_LIMIT: u64 = 20;
pub const REMOVE_LIQUIDITY_LIMIT: u64 = 20;
pub const FEE_LIMIT: i32 = 30;

pub const FUZZY_NUM: usize = 2;
pub const OPERATION_NUM: i32 = 10;
pub const AMOUNT_IN_LIMIT: u128 = 10;
pub const TRANSFER_AMOUNT_LIMIT: u128 = 20;

pub const LP_LIMIT: u128 = 10;
pub const STABLE_TOKENS: [&str; 3] = ["dai001", "usdt", "usdc"];
pub const DECIMALS: [u8; 3] = [18, 6, 6];
pub const TARGET_DECIMAL: u8 = 18;

pub const ONE_LPT: u128 = 1000000000000000000;
pub const ONE_DAI: u128 = 1000000000000000000;
pub const ONE_USDT: u128 = 1000000;
pub const ONE_USDC: u128 = 1000000;
'''
'''--- ref-exchange/tests/fuzzy/create_simple_pool.rs ---
#![allow(unused)] 
use near_sdk_sim::{
    call, to_yocto, view, ContractAccount, UserAccount,
};
use ref_exchange::{ContractContract as Exchange, PoolInfo};
use rand::Rng;
use rand_pcg::Pcg32;
use crate::fuzzy::types::*;
use crate::fuzzy::utils::*;
use crate::fuzzy::constants::*;

pub fn create_simple_pool(ctx: &mut OperationContext, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, pool :&ContractAccount<Exchange>){
    let (token1, token2) = get_token_pair(rng);

    if !ctx.token_contract_account.contains_key(&token1){
        let token_contract1 = test_token(root, token1.clone(), vec![swap()], vec![&operator.user]);
        ctx.token_contract_account.insert(token1.clone(), token_contract1);
    }
    if !ctx.token_contract_account.contains_key(&token2){
        let token_contract2 = test_token(root, token2.clone(), vec![swap()], vec![&operator.user]);
        ctx.token_contract_account.insert(token2.clone(), token_contract2);
    }

    let fee = rng.gen_range(5..FEE_LIMIT);
    let pool_id = call!(
        &operator.user,
        pool.add_simple_pool(vec![to_va(token1.clone()), to_va(token2.clone())], fee as u32),
        deposit = to_yocto("1")
    )
    .unwrap_json::<u64>();

    println!("user: {} ,pool_id: {}, pool_info: {:?}", operator.user.account_id.clone(), pool_id, view!(pool.get_pool(pool_id)).unwrap_json::<PoolInfo>());
}
'''
'''--- ref-exchange/tests/fuzzy/direct_swap.rs ---
#![allow(unused)] 
use near_sdk_sim::{
    call, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};
use near_sdk::json_types::U128;
use ref_exchange::{ContractContract as Exchange, PoolInfo};
use rand::Rng;
use rand_pcg::Pcg32;
use crate::fuzzy::{
    types::*,
    utils::*,
    liquidity_manage::*,
    constants::*
};

fn pack_action(
    pool_id: u64,
    token_in: &str,
    token_out: &str,
    amount_in: Option<u128>,
    min_amount_out: u128,
) -> String {
    if let Some(amount_in) = amount_in {
        format!(
            "{{\"pool_id\": {}, \"token_in\": \"{}\", \"amount_in\": \"{}\", \"token_out\": \"{}\", \"min_amount_out\": \"{}\"}}",
            pool_id, token_in, amount_in, token_out, min_amount_out
        )
    } else {
        format!(
            "{{\"pool_id\": {}, \"token_in\": \"{}\", \"token_out\": \"{}\", \"min_amount_out\": \"{}\"}}",
            pool_id, token_in, token_out, min_amount_out
        )
    }
}

fn direct_swap_action(
    ctx: &mut OperationContext,
    user: &UserAccount,
    token: &String,
    actions: Vec<String>,
    transfer_amount: u128
) -> ExecutionResult {
    let token_contract = ctx.token_contract_account.get(token).unwrap();
    let actions_str = actions.join(", ");
    let msg_str = format!("{{\"actions\": [{}]}}", actions_str);
    call!(
        user,
        token_contract.ft_transfer_call(to_va(swap()), transfer_amount.into(), None, msg_str),
        deposit = 1
    )
}

pub fn do_direct_swap(ctx: &mut OperationContext, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, pool :&ContractAccount<Exchange>, simple_pool_count: u64){
    let simple_pool_id = if simple_pool_count == 0 { 0 } else { rng.gen_range(0..simple_pool_count) };
    let simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();

    let tokens = &simple_pool_info.token_account_ids;

    let is_shuffle:i8 = rng.gen();

    let (token_in, token_out) = if is_shuffle % 2 == 1 {
        (tokens.get(0).unwrap(), tokens.get(1).unwrap())
    }else{
        (tokens.get(1).unwrap(), tokens.get(0).unwrap())
    };

    let amount_in = to_yocto("10");
    // let transfer_amount = rng.gen_range(1..TRANSFER_AMOUNT_LIMIT);
    let transfer_amount = to_yocto(&TRANSFER_AMOUNT_LIMIT.to_string());

    let min_amount_out = to_yocto("1");

    println!("amount_in: {}, transfer_amount:{}", amount_in, transfer_amount);

    let action = pack_action(
        simple_pool_id,
        token_in,
        token_out,
        Some(amount_in),
        min_amount_out,
    );

    loop {

        let simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();

        let token_in_pool_amount = get_token_amount_in_pool(&simple_pool_info, token_in);
        let token_out_pool_amount = get_token_amount_in_pool(&simple_pool_info, token_out);

        let test_token_in_amount = get_test_token_amount(ctx, operator, token_in);
        let test_token_out_amount = get_test_token_amount(ctx, operator, token_out);

        let mut scenario = DSScenario::Normal;
        if test_token_in_amount == 0{
            scenario = DSScenario::TokenInZero;
        }else if test_token_out_amount == 0{
            scenario = DSScenario::TokenOutZero;
        }else if token_in_pool_amount == 0 || token_out_pool_amount == 0 {
            scenario = DSScenario::LiquidityEmpty;
        } 

        println!("direct_swap scenario : {:?} begin!", scenario);
        
        match scenario {
            DSScenario::Normal => {

                let swap_amount_budget = view!(pool.get_return(simple_pool_id, to_va(token_in.clone()), U128(amount_in), to_va(token_out.clone()))).unwrap_json::<U128>().0;
                
                let out_come = direct_swap_action(ctx, &operator.user, token_in, vec![action.clone()], transfer_amount);
                out_come.assert_success();

                let test_token_in_amount_new = get_test_token_amount(ctx, operator, token_in);
                let test_token_out_amount_new = get_test_token_amount(ctx, operator, token_out);

                if swap_amount_budget < min_amount_out {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("ERR_MIN_AMOUNT"));
                    assert_eq!(test_token_in_amount, test_token_in_amount_new);
                    assert_eq!(test_token_out_amount, test_token_out_amount_new);
                }else{
                    assert_eq!(test_token_in_amount - amount_in, test_token_in_amount_new);
                    assert_eq!(test_token_out_amount + swap_amount_budget, test_token_out_amount_new);
                }
                
                let new_simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();
                println!("after pool swap current simple pool info {:?} ", new_simple_pool_info);
                break;
            },
            DSScenario::LiquidityEmpty => {
                let out_come = direct_swap_action(ctx, &operator.user, token_in, vec![action.clone()], transfer_amount);
                if amount_in > transfer_amount {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                } else {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                }
                do_add_liquidity(ctx, rng, root, operator, pool, simple_pool_count, Some(simple_pool_id));
            },

            DSScenario::TokenInZero => {
                let out_come = direct_swap_action(ctx, &operator.user, token_in, vec![action.clone()], transfer_amount);
                assert_eq!(get_error_count(&out_come), 1);
                assert!(get_error_status(&out_come).contains("Smart contract panicked: The account"));
                assert!(get_error_status(&out_come).contains("is not registered"));
                user_init_token_account(ctx, root, operator, token_in);
            },
            DSScenario::TokenOutZero => {
                user_init_token_account(ctx, root, operator, token_out);
            },
            
            
        }
        println!("direct_swap scenario : {:?} end!", scenario);
    }

}
'''
'''--- ref-exchange/tests/fuzzy/liquidity_manage.rs ---
#![allow(unused)] 
use near_sdk_sim::{
    call, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};
use test_token::ContractContract as TestToken;
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use std::collections::HashMap;
use ref_exchange::{ContractContract as Exchange, PoolInfo};
use rand::Rng;
use rand_pcg::Pcg32;
use crate::fuzzy::{
    types::*,
    utils::*,
    constants::*
};
use std::cmp::min;
use std::panic;

use uint::construct_uint;
construct_uint! {
    pub struct U256(4);
}

pub fn add_liquidity_action(pool :&ContractAccount<Exchange>, operator: &Operator, simple_pool_id: u64, liquidity1: u128, liquidity2: u128) -> ExecutionResult {
    call!(
        &operator.user,
        pool.add_liquidity(simple_pool_id, vec![U128(liquidity1), U128(liquidity2)], None),
        deposit = to_yocto("0.0009")// < 0.0009 ERR_STORAGE_DEPOSIT
    )
}

pub fn real_liquidity(pool :&ContractAccount<Exchange>, pool_id: u64, amounts: Vec<u128>) -> Option<(u128, u128)>{
    let mut res = (0, 0);
    let simple_pool_info = view!(pool.get_pool(pool_id)).unwrap_json::<PoolInfo>();

    if u128::from(simple_pool_info.shares_total_supply) > 0{
        let mut fair_supply = U256::max_value();
        for i in 0..simple_pool_info.token_account_ids.len() {
            fair_supply = min(
                fair_supply,
                U256::from(amounts[i]) * U256::from(simple_pool_info.shares_total_supply.0) / simple_pool_info.amounts[i].0,
            );
        }
        for i in 0..simple_pool_info.token_account_ids.len() {
            let amount = (U256::from(simple_pool_info.amounts[i].0) * fair_supply
                / U256::from(simple_pool_info.shares_total_supply.0))
            .as_u128();
            if i == 0 {
                res.0 = amount;
            }else{
                res.1 = amount;
            }
        }
    }else{
        return None;
    }
    Some(res)
}

pub fn do_add_liquidity(ctx: &mut OperationContext, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, pool :&ContractAccount<Exchange>, simple_pool_count: u64, specified: Option<u64>){
    let simple_pool_id = match specified{
        Some(id) => id,
        None => {
            if simple_pool_count == 0 { 0 } else { rng.gen_range(0..simple_pool_count) }
        }
    };
    
    let simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();

    let tokens = simple_pool_info.token_account_ids;

    let (liquidity1, liquidity2) = (to_yocto(&ADD_LIQUIDITY_LIMIT.to_string()), to_yocto(&ADD_LIQUIDITY_LIMIT.to_string()));

    loop{
        let (scenario, token1_account, token2_account, token1_deposit, token2_deposit) = 
            current_evn_info(ctx, pool, operator, &tokens);
        println!("add_liquidity scenario : {:?} begin!", scenario);
        
        match scenario {
            Scenario::Normal => {

                let (real_liquidity1, real_liquidity2) = match real_liquidity(pool, simple_pool_id, vec![liquidity1, liquidity2]){
                    Some((real_liquidity1, real_liquidity2)) => (real_liquidity1, real_liquidity2),
                    None => (liquidity1, liquidity2)
                };

                if token1_deposit <  real_liquidity1{
                    let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                    add_token_deposit(ctx, root, operator, tokens.get(0).unwrap(), token1_account, liquidity1, token1_deposit);
                }

                if token2_deposit < real_liquidity2 {
                    let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                    add_token_deposit(ctx, root, operator, tokens.get(1).unwrap(), token2_account, liquidity2, token2_deposit);
                }

                add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2).assert_success();

                println!("add_liquidity scenario : Normal end!");
                let new_simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();
                println!("after add liquidity current simple pool info {:?} ", new_simple_pool_info);
                break;
            },
            Scenario::Token1NoAccount => {
                let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                assert_eq!(get_error_count(&out_come), 1);
                assert!(get_error_status(&out_come).contains("token not registered"));

                user_init_token_account(ctx, root, operator,  tokens.get(0).unwrap());
            },
            Scenario::Token2NoAccount => {
                let (real_liquidity1, _) = match real_liquidity(pool, simple_pool_id, vec![liquidity1, liquidity2]){
                    Some((real_liquidity1, real_liquidity2)) => (real_liquidity1, real_liquidity2),
                    None => (liquidity1, liquidity2)
                };
                let token1_deposit = view!(pool.get_deposit(to_va(operator.user.account_id.clone()), to_va(tokens.get(0).unwrap().clone()))).unwrap_json::<U128>().0;
                let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                
                if token1_deposit != 0 && token1_deposit < real_liquidity1 {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                }else {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("token not registered"));
                }

                user_init_token_account(ctx, root, operator,  tokens.get(1).unwrap());
            },
            Scenario::Token1NotRegistered => {
                let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                assert_eq!(get_error_count(&out_come), 1);
                assert!(get_error_status(&out_come).contains("token not registered"));

                user_init_deposit_token(ctx, rng, operator, tokens.get(0).unwrap());
            },
            Scenario::Token2NotRegistered => {
                let (real_liquidity1, _) = match real_liquidity(pool, simple_pool_id, vec![liquidity1, liquidity2]){
                    Some((real_liquidity1, real_liquidity2)) => (real_liquidity1, real_liquidity2),
                    None => (liquidity1, liquidity2)
                };
                let token1_deposit = view!(pool.get_deposit(to_va(operator.user.account_id.clone()), to_va(tokens.get(0).unwrap().clone()))).unwrap_json::<U128>().0;
                let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);

                if token1_deposit != 0 && token1_deposit < real_liquidity1 {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                }else {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("token not registered"));
                }

                user_init_deposit_token(ctx, rng, operator, tokens.get(1).unwrap());
            },
            Scenario::NoStorageDeposit => {
                let out_come = add_liquidity_action(pool, operator, simple_pool_id, liquidity1, liquidity2);
                assert_eq!(get_error_count(&out_come), 1);
                assert!(get_error_status(&out_come).contains("token not registered"));
                user_storage_deposit(pool, operator);
            }
        }
        println!("add_liquidity scenario : {:?} end!", scenario);
    }
}

pub fn do_stable_add_liquidity(token_contracts: &Vec<ContractAccount<TestToken>>, rng: &mut Pcg32, root: &UserAccount, operator: &StableOperator, pool :&ContractAccount<Exchange>) -> u128{
    let mut scenario = StableScenario::Normal;
    
    let add_amounts = vec![U128(rng.gen_range(1..ADD_LIQUIDITY_LIMIT as u128) * ONE_DAI),
                                    U128(rng.gen_range(1..ADD_LIQUIDITY_LIMIT as u128) * ONE_USDT),
                                    U128(rng.gen_range(1..ADD_LIQUIDITY_LIMIT as u128) * ONE_USDC)];

    let min_shares = rng.gen_range(1..ADD_LIQUIDITY_LIMIT) as u128;

    let old_share = mft_balance_of(pool, ":0", &operator.user.account_id());

    println!("do_stable_add_liquidity add_amounts : {:?}", add_amounts);
    for (idx, amount) in add_amounts.clone().into_iter().enumerate() {
        let token_contract = token_contracts.get(idx).unwrap();
        add_and_deposit_token(root, &operator.user, token_contract, pool, amount.0);
    }

    let cal_share = view!(pool.predict_add_stable_liquidity(0, &add_amounts)).unwrap_json::<U128>().0;

    if min_shares > cal_share {
        scenario = StableScenario::Slippage;
    }

    let out_come = call!(
        operator.user,
        pool.add_stable_liquidity(0, add_amounts, U128(min_shares)),
        deposit = to_yocto("0.01")
    );

    let mut share = 0;
    match scenario {
        StableScenario::Normal => {
            share = out_come.unwrap_json::<U128>().0;
            assert_eq!(cal_share, share);
            assert_eq!(mft_balance_of(pool, ":0", &operator.user.account_id()), old_share + share);
        },
        StableScenario::Slippage => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E68: slippage error"));
        },
        StableScenario::InsufficientLpShares => {
        }
    }
    share
}

pub fn do_stable_remove_liquidity_by_shares(token_contracts: &Vec<ContractAccount<TestToken>>, rng: &mut Pcg32, root: &UserAccount, operator: &StableOperator, pool :&ContractAccount<Exchange>){
    let mut scenario = StableScenario::Normal;

    let min_amounts = vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)];
    let remove_lp_num = rng.gen_range(1..LP_LIMIT) * ONE_LPT * 10;

    let mut user_lpt =  mft_balance_of(&pool, ":0", &operator.user.account_id());

    while user_lpt == 0 {
        user_lpt = do_stable_add_liquidity(token_contracts, rng, root, operator, pool);
    }

    let old_balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();
    let old_share = mft_balance_of(pool, ":0", &operator.user.account_id());

    if user_lpt < remove_lp_num {
        scenario = StableScenario::InsufficientLpShares;
    }else{
        let total_supply = mft_total_supply(pool, ":0");
        let mut result = vec![0u128; STABLE_TOKENS.len()];
        let amounts  = view!(pool.get_pool(0)).unwrap_json::<PoolInfo>().amounts;
        for i in 0..STABLE_TOKENS.len() {
            result[i] = U256::from(amounts[i].0)
                .checked_mul(remove_lp_num.into())
                .unwrap()
                .checked_div(total_supply.into())
                .unwrap()
                .as_u128();
            if result[i] < min_amounts[i].0 {
                scenario = StableScenario::Slippage;
                break;
            }
        }
    }
    
    let mut increase_amounts = vec![];
    if scenario == StableScenario::Normal {
        increase_amounts = view!(pool.predict_remove_liquidity(0, U128(remove_lp_num))).unwrap_json::<Vec<U128>>();
    }

    println!("user has lpt : {}, remove : {}", user_lpt, remove_lp_num);

    let out_come = call!(
        operator.user,
        pool.remove_liquidity(0, U128(remove_lp_num), min_amounts),
        deposit = 1 
    );

    println!("do_stable_remove_liquidity_by_shares scenario : {:?} begin!", scenario);
    match scenario {
        StableScenario::Normal => {
            out_come.assert_success();
            let user_share = mft_balance_of(pool, ":0", &operator.user.account_id());
            let balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();
            assert_eq!(user_share, old_share - remove_lp_num);
            for (idx, item) in increase_amounts.iter().enumerate() {
                assert_eq!(balances.get(STABLE_TOKENS[idx]).unwrap().0, 
                old_balances.get(STABLE_TOKENS[idx]).unwrap().0 + item.0);
            }
        },
        StableScenario::Slippage => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E68: slippage error"));
        },
        StableScenario::InsufficientLpShares => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E34: insufficient lp shares"));
        }
    }
    println!("do_stable_remove_liquidity_by_shares scenario : {:?} end!", scenario);
}

pub fn do_stable_remove_liquidity_by_token(token_contracts: &Vec<ContractAccount<TestToken>>, rng: &mut Pcg32, root: &UserAccount, operator: &StableOperator, pool :&ContractAccount<Exchange>){

    let mut scenario = StableScenario::Normal;

    let remove_amounts = vec![ U128(rng.gen_range(1..REMOVE_LIQUIDITY_LIMIT as u128) * ONE_DAI),
                                        U128(rng.gen_range(1..REMOVE_LIQUIDITY_LIMIT as u128) * ONE_USDT),
                                        U128(rng.gen_range(1..REMOVE_LIQUIDITY_LIMIT as u128) * ONE_USDC)];
    let max_burn_shares = rng.gen_range(1..LP_LIMIT as u128) * ONE_LPT;
    let mut user_lpt =  mft_balance_of(&pool, ":0", &operator.user.account_id());

    while user_lpt == 0 {
        user_lpt = do_stable_add_liquidity(token_contracts, rng, root, operator, pool);
    }

    let old_balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();

    let remove_lpt = view!(pool.predict_remove_liquidity_by_tokens(0, &remove_amounts)).unwrap_json::<U128>().0;

    if remove_lpt > user_lpt{
        scenario = StableScenario::InsufficientLpShares;
    }else if remove_lpt > max_burn_shares{
        scenario = StableScenario::Slippage;
    }

    println!("remove tokens: {:?}", remove_amounts);
    println!("remove lpt: {} {} {}", user_lpt, remove_lpt, max_burn_shares);

    let out_come = call!(
        operator.user,
        pool.remove_liquidity_by_tokens(0, remove_amounts.clone(), U128(max_burn_shares)),
        deposit = 1 
    );

    println!("do_stable_remove_liquidity_by_token scenario : {:?} begin!", scenario);
    match scenario {
        StableScenario::Normal => {
            out_come.assert_success();
            let current_share = mft_balance_of(&pool, ":0", &operator.user.account_id());
            assert_eq!(current_share, user_lpt - remove_lpt);
            let balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();
            for (idx, item) in remove_amounts.iter().enumerate() {
                assert_eq!(balances.get(STABLE_TOKENS[idx]).unwrap().0, 
                old_balances.get(STABLE_TOKENS[idx]).unwrap().0 + item.0);
            }
        },
        StableScenario::Slippage => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E68: slippage error"));
        },
        StableScenario::InsufficientLpShares => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E34: insufficient lp shares"));
        }
    }
    
    println!("do_stable_remove_liquidity_by_token scenario : {:?} end!", scenario);
}
'''
'''--- ref-exchange/tests/fuzzy/mod.rs ---
pub mod create_simple_pool;
pub mod direct_swap;
pub mod pool_swap;
pub mod liquidity_manage;
pub mod types;
pub mod constants;
pub mod utils;

'''
'''--- ref-exchange/tests/fuzzy/pool_swap.rs ---
#![allow(unused)] 
use near_sdk_sim::{
    call, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};
use std::collections::HashMap;
use near_sdk::AccountId;
use near_sdk::json_types::U128;
use ref_exchange::{ContractContract as Exchange, PoolInfo, SwapAction};
use rand::Rng;
use rand_pcg::Pcg32;
use crate::fuzzy::{
    types::*,
    utils::*,
    liquidity_manage::*,
    constants::*
};
use test_token::ContractContract as TestToken;

pub fn swap_action(pool :&ContractAccount<Exchange>, operator: &Operator, token_in: AccountId, token_out: AccountId, amount_in: u128, simple_pool_id: u64) -> ExecutionResult{
    call!(
        &operator.user,
        pool.swap(
            vec![SwapAction {
                pool_id: simple_pool_id,
                token_in: token_in,
                amount_in: Some(U128(amount_in)),
                token_out: token_out,
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    )
}

pub fn do_pool_swap(ctx: &mut OperationContext, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, pool :&ContractAccount<Exchange>, simple_pool_count: u64){
    let simple_pool_id = if simple_pool_count == 0 { 0 } else { rng.gen_range(0..simple_pool_count) };
    let simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();

    let tokens = &simple_pool_info.token_account_ids;

    let is_shuffle:i8 = rng.gen();

    let (token_in, token_out) = if is_shuffle % 2 == 1 {
        (tokens.get(0).unwrap(), tokens.get(1).unwrap())
    }else{
        (tokens.get(1).unwrap(), tokens.get(0).unwrap())
    };

    let amount_in = to_yocto(&AMOUNT_IN_LIMIT.to_string());

    loop {

        let simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();

        let token_in_pool_amount = get_token_amount_in_pool(&simple_pool_info, token_in);
        let token_out_pool_amount = get_token_amount_in_pool(&simple_pool_info, token_out);

        let (scenario, token1_account, token2_account, token1_deposit, token2_deposit) = 
            current_evn_info(ctx, pool, operator, &tokens);

        let (token_in_amount, _token_out_amount, token_in_deposit, _token_out_deposit) = if is_shuffle % 2 == 1 {
            (token1_account, token2_account, token1_deposit, token2_deposit)
        }else{
            (token2_account, token1_account, token2_deposit, token1_deposit)
        };

        println!("pool_swap scenario : {:?} begin!", scenario);
        
        match scenario {
            Scenario::Normal => {
                if token_in_pool_amount == 0 || token_out_pool_amount == 0 {
                    let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                    assert_eq!(get_error_count(&out_come), 1);
                    if amount_in > token_in_deposit { 
                        assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                    }else {
                        assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                    }
                    do_add_liquidity(ctx, rng, root, operator, pool, simple_pool_count, Some(simple_pool_id));
                }
               
                let pool_deposits = view!(pool.get_deposits(to_va(operator.user.account_id.clone()))).unwrap_json::<HashMap<AccountId, U128>>();
                let token_in_deposit_old = pool_deposits.get(token_in).unwrap().0;
                let token_out_deposit_old = pool_deposits.get(token_out).unwrap().0;

                if amount_in > token_in_deposit_old {
                    let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
                    println!("token_amount: {} need_amount: {}  current_amount: {}", token_in_amount, amount_in, token_in_deposit_old);
                    add_token_deposit(ctx, root, operator, token_in, token_in_amount, amount_in, token_in_deposit_old);
                }
                
                let swap_amount_budget = view!(pool.get_return(simple_pool_id, to_va(token_in.clone()), U128(amount_in), to_va(token_out.clone()))).unwrap_json::<U128>().0;

                let swap_amount_string = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id).unwrap_json::<String>();
                let swap_amount = swap_amount_string.parse::<u128>().unwrap();
                
                let pool_deposits = view!(pool.get_deposits(to_va(operator.user.account_id.clone()))).unwrap_json::<HashMap<AccountId, U128>>();
                let token_out_deposit = pool_deposits.get(token_out).unwrap().0;
                
                assert_eq!(token_out_deposit, swap_amount + token_out_deposit_old);
                assert_eq!(swap_amount, swap_amount_budget);
                let new_simple_pool_info = view!(pool.get_pool(simple_pool_id)).unwrap_json::<PoolInfo>();
                println!("after pool swap current simple pool info {:?} ", new_simple_pool_info);
                break;
            },
            Scenario::Token1NoAccount => {
                if is_shuffle % 2 == 1 {
                    let account_tokens = view!(pool.get_user_whitelisted_tokens(to_va(operator.user.account_id.clone()))).unwrap_json::<Vec<AccountId>>();
                    let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                    if account_tokens.contains(token_in) {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                    }else {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("token not registered"));
                    }
                }
                
                user_init_token_account(ctx, root, operator,  tokens.get(0).unwrap());
            },
            Scenario::Token2NoAccount => {
                let account_tokens = view!(pool.get_user_whitelisted_tokens(to_va(operator.user.account_id.clone()))).unwrap_json::<Vec<AccountId>>();
                let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                if account_tokens.contains(token_in) {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                }else {
                    assert_eq!(get_error_count(&out_come), 1);
                    assert!(get_error_status(&out_come).contains("token not registered"));
                }

                user_init_token_account(ctx, root, operator,  tokens.get(1).unwrap());
            },
            Scenario::Token1NotRegistered => {
                if token_in_pool_amount == 0 || token_out_pool_amount == 0 {
                    let account_tokens = view!(pool.get_user_whitelisted_tokens(to_va(operator.user.account_id.clone()))).unwrap_json::<Vec<AccountId>>();
                    let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                    if account_tokens.contains(token_in) {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                    }else {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("token not registered"));
                    }
                }
                
                user_init_deposit_token(ctx, rng, operator, tokens.get(0).unwrap());
            },
            Scenario::Token2NotRegistered => {
                if token_in_pool_amount == 0 || token_out_pool_amount == 0 {
                    let account_tokens = view!(pool.get_user_whitelisted_tokens(to_va(operator.user.account_id.clone()))).unwrap_json::<Vec<AccountId>>();
                    let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                    if account_tokens.contains(token_in) {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("Smart contract panicked: panicked at 'ERR_INVALID'"));
                    }else {
                        assert_eq!(get_error_count(&out_come), 1);
                        assert!(get_error_status(&out_come).contains("token not registered"));
                    }
                }
                
                user_init_deposit_token(ctx, rng, operator, tokens.get(1).unwrap());
            },
            Scenario::NoStorageDeposit => {
                let out_come = swap_action(pool, operator, token_in.clone(), token_out.clone(), amount_in, simple_pool_id);
                assert_eq!(get_error_count(&out_come), 1);
                assert!(get_error_status(&out_come).contains("E10: account not registered"));
                user_storage_deposit(pool, operator);
            }
        }
        println!("pool_swap scenario : {:?} end!", scenario);
    }
    
}

pub fn get_swap_info(rng: &mut Pcg32) -> (AccountId, AccountId, u128, usize, usize){
    let amount_in_unit = vec![ONE_DAI, ONE_USDT, ONE_USDC];
    let amount_in = rng.gen_range(1..AMOUNT_IN_LIMIT);
    loop {
        let token_in_index = rng.gen_range(0..STABLE_TOKENS.len());
        let token_out_index = rng.gen_range(0..STABLE_TOKENS.len());
        if token_in_index == token_out_index {
            continue;
        }
        return (STABLE_TOKENS[token_in_index].to_string(), STABLE_TOKENS[token_out_index].to_string(), amount_in_unit[token_in_index] * amount_in,
        token_in_index, token_out_index)
    }
}

pub fn do_stable_pool_swap(token_contracts: &Vec<ContractAccount<TestToken>>, rng: &mut Pcg32, root: &UserAccount, operator: &StableOperator, pool :&ContractAccount<Exchange>){

    let mut scenario = StableScenario::Normal;

    let balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();
    println!("current user balance: {:?}", balances);
    
    let (token_in, token_out, amount_in, token_in_index, token_out_index) = get_swap_info(rng);

    let token_contract = token_contracts.get(token_in_index).unwrap();

    println!("swap  {} => {} : {}", token_in, token_out, amount_in);
    add_and_deposit_token(root, &operator.user, token_contract, pool, amount_in);
    let balances = view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>();
    println!("current user balance: {:?}", balances);
    let token_in_amount = balances.get(&token_in).unwrap().0;
    let token_out_amount = balances.get(&token_out).unwrap_or(&U128(0_u128)).0;

    let swap_out =  view!(pool.get_return(0, to_va(token_in.clone()), U128(amount_in), to_va(token_out.clone()))).unwrap_json::<U128>().0;
    if swap_out > view!(pool.get_pool(0)).unwrap_json::<PoolInfo>().amounts[token_out_index].0{
        scenario = StableScenario::Slippage;
    }

    let out_come = call!(
        operator.user,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: token_in.clone(),
                amount_in: Some(U128(amount_in)),
                token_out: token_out.clone(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    println!("do_stable_pool_swap scenario : {:?} begin!", scenario);
    match scenario {
        StableScenario::Normal => {
            out_come.assert_success();
            assert_eq!(view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>().get(&token_in).unwrap().0,
                            token_in_amount - amount_in
            );
            assert_eq!(view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>().get(&token_out).unwrap().0,
                            token_out_amount + swap_out
            );
        },
        StableScenario::Slippage => {
            assert_eq!(get_error_count(&out_come), 1);
            assert!(get_error_status(&out_come).contains("E34: insufficient lp shares"));
            assert_eq!(view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>().get(&token_in).unwrap().0,
                            token_in_amount
            );
            assert_eq!(view!(pool.get_deposits(operator.user.valid_account_id())).unwrap_json::<HashMap<AccountId, U128>>().get(&token_out).unwrap().0,
                            token_out_amount
            );
        }
        _ => {
            panic!("do_stable_pool_swap find new StableScenario {:?}", scenario);
        }
    }
    println!("do_stable_pool_swap scenario : {:?} end!", scenario);
}
'''
'''--- ref-exchange/tests/fuzzy/types.rs ---
#![allow(unused)] 
use near_sdk::serde::{Deserialize, Serialize};
use std::collections::HashMap;
use near_sdk::AccountId;
use near_sdk_sim::{
    ContractAccount, UserAccount,
};
use near_sdk::json_types::U128;
use test_token::ContractContract as TestToken;

#[derive(Default)]
pub struct OperationContext {
    pub token_contract_account: HashMap<AccountId, ContractAccount<TestToken>>
}

#[derive(Debug)]
pub enum Preference {
    CreateSamplePool, 
    DirectSwap,
    PoolSwap,
    AddLiquidity
}

#[derive(Debug)]
pub enum Scenario {
    Normal,
    Token1NotRegistered, 
    Token2NotRegistered, 
    Token1NoAccount,
    Token2NoAccount,
    NoStorageDeposit,
}

#[derive(Debug)]
pub enum DSScenario {
    Normal,
    LiquidityEmpty,
    TokenInZero,
    TokenOutZero,
}

#[derive(Debug)]
pub struct Operator {
    pub user: UserAccount,
    pub preference: Preference
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RefStorageState {
    pub deposit: U128,
    pub usage: U128,
}

/**
 * Related to stable swap
 */

#[derive(Debug)]
pub enum StablePreference {
    RemoveLiquidityByToken,
    RemoveLiquidityByShare,
    PoolSwap,
    AddLiquidity
}

#[derive(Debug)]
pub struct StableOperator {
    pub user: UserAccount,
    pub preference: StablePreference
}

#[derive(Debug, PartialEq, Eq)]
pub enum StableScenario {
    Normal,
    Slippage,
    InsufficientLpShares
}

'''
'''--- ref-exchange/tests/fuzzy/utils.rs ---
#![allow(unused)] 
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};
use std::collections::HashMap;
use near_sdk::serde_json::{Value, from_value};
use std::convert::TryFrom;
use rand::Rng;
use rand_pcg::Pcg32;
use near_sdk::json_types::{ValidAccountId, U128};
use ref_exchange::{ContractContract as Exchange, PoolInfo};
use test_token::ContractContract as TestToken;
use near_sdk::AccountId;
use crate::fuzzy::types::*;
use crate::fuzzy::constants::*;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TEST_TOKEN_WASM_BYTES => "../res/test_token.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
}

/**
 * Related to common
 */

pub fn get_operator<'a, T>(rng: &mut Pcg32, users: &'a Vec<T>) -> &'a T{
    let user_index = rng.gen_range(0..users.len());
    &users[user_index]
}

/**
 * Related to amm swap
 */

pub fn get_error_count(r: &ExecutionResult) -> u32 {
    r.promise_errors().len() as u32
}

pub fn get_error_status(r: &ExecutionResult) -> String {
    format!("{:?}", r.promise_errors()[0].as_ref().unwrap().status())
}

pub fn get_token_pair(rng: &mut Pcg32) -> (AccountId, AccountId){
    loop {
        let token1_index = rng.gen_range(0..TOKENS.len());
        let token2_index = rng.gen_range(0..TOKENS.len());
        if token1_index == token2_index {
            continue;
        }
        let token1 = TOKENS[token1_index];
        let token2 = TOKENS[token2_index];
        return (token1.to_string(), token2.to_string())
    }
}

pub fn test_token(
    root: &UserAccount,
    token_id: AccountId,
    accounts_to_register: Vec<AccountId>,
    accounts_to_mint: Vec<&UserAccount>
) -> ContractAccount<TestToken> {
    let t = deploy!(
        contract: TestToken,
        contract_id: token_id,
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root
    );
    call!(root, t.new()).assert_success();
    call!(
        root,
        t.mint(to_va(root.account_id.clone()), to_yocto(&format!("{}", INIT_ACCOUNT_FOR_TOKEN)).into())
    )
    .assert_success();
    
    for user in accounts_to_mint{
        call!(
            root,
            t.mint(to_va(user.account_id.clone()), to_yocto(&format!("{}", INIT_ACCOUNT_FOR_TOKEN)).into())
        )
        .assert_success();
    }

    for account_id in accounts_to_register {
        call!(
            root,
            t.storage_deposit(Some(to_va(account_id)), None),
            deposit = to_yocto("1")
        )
        .assert_success();
    }
    t
}

pub fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

pub fn swap() -> AccountId {
    "swap".to_string()
}

pub fn get_token_amount_in_pool(simple_pool_info: &PoolInfo, token_account_id: &AccountId) -> u128 {
    simple_pool_info.amounts[simple_pool_info.token_account_ids.iter().position(|id| id == token_account_id).unwrap()].0
}

pub fn user_storage_deposit(pool :&ContractAccount<Exchange>, operator: &Operator){
    call!(
        &operator.user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
}

pub fn user_init_deposit_token(ctx: &mut OperationContext, rng: &mut Pcg32, operator: &Operator, token: &AccountId) {
    let init_token = rng.gen_range(10..INIT_TOKEN_TO_SWAP_POOL_LIMIT);
    let token_contract2 = ctx.token_contract_account.get(token).unwrap();
    call!(
        &operator.user,
        token_contract2.ft_transfer_call(to_va(swap()), to_yocto(&init_token.to_string()).into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
}

pub fn user_init_token_account(ctx: &mut OperationContext, root: &UserAccount, operator: &Operator, token: &AccountId){
    let token_contract = ctx.token_contract_account.get(token).unwrap();
    call!(
        root,
        token_contract.mint(to_va(operator.user.account_id.clone()), to_yocto(&format!("{}", INIT_ACCOUNT_FOR_TOKEN)).into())
    )
    .assert_success();
}

pub fn add_token_deposit(ctx: &mut OperationContext, root: &UserAccount, operator: &Operator, token: &AccountId, token_amount: u128, need_value: u128, current_value: u128){
    println!("add_token_deposit");
    let token_contract = ctx.token_contract_account.get(token).unwrap();
    if token_amount < need_value - current_value {
        println!("mint {} {} to {}", INIT_ACCOUNT_FOR_TOKEN, token_contract.account_id(), operator.user.account_id);
        call!(
            root,
            token_contract.ft_transfer_call(to_va(operator.user.account_id.clone()), to_yocto(&format!("{}", INIT_ACCOUNT_FOR_TOKEN)).into(), None,  "".to_string()),
            deposit = 1
        )
        .assert_success();
    }
    println!("deposit {} {} to {}", INIT_ACCOUNT_FOR_TOKEN, token_contract.account_id(), operator.user.account_id);
    call!(
        &operator.user,
        token_contract.ft_transfer_call(to_va(swap()), (need_value - current_value).into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
}

pub fn current_evn_info(ctx: &mut OperationContext, pool :&ContractAccount<Exchange>, operator: &Operator, tokens: &Vec<String>) -> (Scenario, u128, u128, u128, u128){
    let storage_state = view!(pool.get_user_storage_state(operator.user.valid_account_id())).unwrap_json_value();
    if let Value::Null = storage_state {
        println!("{} has no user_storage_state", operator.user.account_id);
        return (Scenario::NoStorageDeposit, 0, 0, 0, 0);
    } else {
        let ret: RefStorageState = from_value(storage_state).unwrap();
        println!("{} user_storage_state: {:?}", operator.user.account_id, ret);
    }
    
    let token_contract1 = ctx.token_contract_account.get(tokens.get(0).unwrap()).unwrap();
    let token_contract2 = ctx.token_contract_account.get(tokens.get(1).unwrap()).unwrap();
    let token1_account = view!(token_contract1.ft_balance_of(to_va(operator.user.account_id.clone()))).unwrap_json::<U128>().0;
    println!("{} has {} balance : {}", operator.user.account_id, token_contract1.account_id(), token1_account);
    if token1_account == 0{
        return (Scenario::Token1NoAccount, 0, 0, 0, 0); 
    }
    let token2_account = view!(token_contract2.ft_balance_of(to_va(operator.user.account_id.clone()))).unwrap_json::<U128>().0;
    println!("{} has {} balance : {}", operator.user.account_id, token_contract2.account_id(), token2_account);
    if token2_account == 0{
        return (Scenario::Token2NoAccount, token1_account, 0, 0, 0); 
    }

    let pool_deposits = view!(pool.get_deposits(to_va(operator.user.account_id.clone()))).unwrap_json::<HashMap<AccountId, U128>>();

    let token1_deposit = match pool_deposits.get(&token_contract1.account_id()){
        Some(d) => {
            println!("{} deposits {} : {}", operator.user.account_id, token_contract1.account_id(), d.0);
            d.0
        },
        None => {
            println!("{} has no deposits {} !", operator.user.account_id, token_contract1.account_id());
            return (Scenario::Token1NotRegistered, token1_account, token2_account, 0, 0);
        }
    };
    let token2_deposit = match pool_deposits.get(&token_contract2.account_id()){
        Some(d) => {
            println!("{} deposits {} : {}", operator.user.account_id, token_contract2.account_id(), d.0);
            d.0
        },
        None => {
            println!("{} has no deposits {} !", operator.user.account_id, token_contract2.account_id());
            return (Scenario::Token2NotRegistered, token1_account, token2_account, token1_deposit, 0);
        }
    };
    
    (Scenario::Normal, token1_account, token2_account, token1_deposit, token2_deposit)
}

pub fn get_test_token_amount(ctx: &mut OperationContext, operator: &Operator, token: &String) -> u128 {
    let token_contract = ctx.token_contract_account.get(token).unwrap();
    let token_amount = view!(token_contract.ft_balance_of(to_va(operator.user.account_id.clone()))).unwrap_json::<U128>().0;
    println!("{} has {} balance : {}", operator.user.account_id, token_contract.account_id(), token_amount);
    token_amount
    
}

pub fn init_pool_env() -> (
    UserAccount,
    UserAccount,
    ContractAccount<Exchange>,
    Vec<Operator>
){
    
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va("owner".to_string()), 4, 1)
    );

    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        owner,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    let mut users = Vec::new();
    for user_id in 0..EVERY_PREFERENCE_NUM{
        let user = Operator{
            user: root.create_user(format!("user_create_sample_pool_{}", user_id), to_yocto("100")),
            preference: Preference::CreateSamplePool
        };
        users.push(user);
        let user = Operator{
            user: root.create_user(format!("user_direct_swap_{}", user_id), to_yocto("100")),
            preference: Preference::DirectSwap
        };
        users.push(user);
        let user = Operator{
            user: root.create_user(format!("user_pool_swap_{}", user_id), to_yocto("100")),
            preference: Preference::PoolSwap
        };
        users.push(user);
        let user = Operator{
            user: root.create_user(format!("user_add_liquidity_{}", user_id), to_yocto("100")),
            preference: Preference::AddLiquidity
        };
        users.push(user);
    }

    call!(
        owner,
        pool.extend_whitelisted_tokens(TOKENS.map(|v| to_va(v.to_string())).to_vec())
    );
    (root, owner, pool, users)
}

/**
 * Related to stable swap
 */

pub fn setup_stable_pool_with_liquidity_and_operators(
    tokens: Vec<String>,
    amounts: Vec<u128>,
    decimals: Vec<u8>,
    pool_fee: u32,
    amp: u64,
) -> (
    UserAccount,
    UserAccount,
    ContractAccount<Exchange>,
    Vec<ContractAccount<TestToken>>,
    Vec<StableOperator>
) {
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(owner.valid_account_id(), 1600, 0)
    );

    let mut users = Vec::new();
    for user_id in 0..EVERY_PREFERENCE_NUM{
        let user = root.create_user(format!("user_remove_stable_liquidity_by_share_{}", user_id), to_yocto("100"));
        call!(
            user,
            pool.storage_deposit(None, None),
            deposit = to_yocto("1")
        )
        .assert_success();
        users.push(StableOperator{
            user,
            preference: StablePreference::RemoveLiquidityByShare
        });

        let user = root.create_user(format!("user_remove_stable_liquidity_by_token_{}", user_id), to_yocto("100"));
        call!(
            user,
            pool.storage_deposit(None, None),
            deposit = to_yocto("1")
        )
        .assert_success();
        users.push(StableOperator{
            user,
            preference: StablePreference::RemoveLiquidityByToken
        });

        let user = root.create_user(format!("user_pool_stable_swap_{}", user_id), to_yocto("100"));
        call!(
            user,
            pool.storage_deposit(None, None),
            deposit = to_yocto("1")
        )
        .assert_success();
        users.push(StableOperator{
            user,
            preference: StablePreference::PoolSwap
        });
        
        let user = root.create_user(format!("user_add_stable_liquidity_{}", user_id), to_yocto("100"));
        call!(
            user,
            pool.storage_deposit(None, None),
            deposit = to_yocto("1")
        )
        .assert_success();
        users.push(StableOperator{
            user,
            preference: StablePreference::AddLiquidity
        });
    }

    let mut token_contracts: Vec<ContractAccount<TestToken>> = vec![];
    for token_name in &tokens {
        token_contracts.push(test_token(&root, token_name.clone(), vec![swap()], vec![]));
    }

    call!(
        owner,
        pool.extend_whitelisted_tokens(
            (&token_contracts).into_iter().map(|x| x.valid_account_id()).collect()
        )
    );
    call!(
        owner,
        pool.add_stable_swap_pool(
            (&token_contracts).into_iter().map(|x| x.valid_account_id()).collect(), 
            decimals,
            pool_fee,
            amp
        ),
        deposit = to_yocto("1"))
    .assert_success();

    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        owner,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    for (idx, amount) in amounts.clone().into_iter().enumerate() {
        let c = token_contracts.get(idx).unwrap();
        call!(
            root,
            c.ft_transfer_call(
                pool.valid_account_id(), 
                U128(amount), 
                None, 
                "".to_string()
            ),
            deposit = 1
        )
        .assert_success();
    }

    call!(
        root,
        pool.add_stable_liquidity(0, amounts.into_iter().map(|x| U128(x)).collect(), U128(1)),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    (root, owner, pool, token_contracts, users)
}

pub fn dai() -> AccountId {
    STABLE_TOKENS[0].to_string()
}

pub fn usdt() -> AccountId {
    STABLE_TOKENS[1].to_string()
}

pub fn usdc() -> AccountId {
    STABLE_TOKENS[2].to_string()
}
pub fn add_and_deposit_token(
    root: &UserAccount,
    user: &UserAccount,
    token: &ContractAccount<TestToken>,
    ex: &ContractAccount<Exchange>,
    amount: u128,
) {
    if 0 == view!(token.ft_balance_of(user.valid_account_id())).unwrap_json::<U128>().0{
        call!(
            user,
            token.mint(user.valid_account_id(), U128(10))
        )
        .assert_success();
    }
    
    call!(
        root,
        token.ft_transfer(user.valid_account_id(), U128(amount), None),
        deposit = 1
    )
    .assert_success();

    call!(
        user,
        ex.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        user,
        token.ft_transfer_call(
            ex.valid_account_id(), 
            U128(amount), 
            None,
            "".to_string()
        ),
        deposit = 1
    )
    .assert_success();   
}

pub fn mft_balance_of(
    pool: &ContractAccount<Exchange>,
    token_or_pool: &str,
    account_id: &AccountId,
) -> u128 {
    view!(pool.mft_balance_of(token_or_pool.to_string(), to_va(account_id.clone())))
        .unwrap_json::<U128>()
        .0
}

pub fn mft_total_supply(
    pool: &ContractAccount<Exchange>,
    token_or_pool: &str,
) -> u128 {
    view!(pool.mft_total_supply(token_or_pool.to_string()))
        .unwrap_json::<U128>()
        .0
}

pub fn pool_share_price(
    pool: &ContractAccount<Exchange>,
    pool_id: u64,
) -> u128 {
    view!(pool.get_pool_share_price(pool_id))
        .unwrap_json::<U128>()
        .0
}
'''
'''--- ref-exchange/tests/test_admin_fee.rs ---
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use std::collections::HashMap;
use near_sdk_sim::{
    call, view, to_yocto,
};

use ref_exchange::{PoolInfo, SwapAction};

use crate::common::utils::*;
pub mod common;

#[test]
fn modify_admin_fee() {
    let (root, owner, pool, _, _, _) = setup_pool_with_liquidity();
    // let new_user = root.create_user("new_user".to_string(), to_yocto("100"));

    // pool 0, 10 dai -> 20 eth; pool 1, 20 eth -> 10 usdt

    // make sure the exchange's initial admin fee is 4 & 1 bps
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.exchange_fee, 4);
    assert_eq!(metadata.referral_fee, 1);
    let pool_fee = view!(pool.get_pool_fee(0)).unwrap_json::<u32>();
    assert_eq!(pool_fee, 25);

    // make sure pool info, especially total_fee and share_total_supply
    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "SIMPLE_POOL".to_string(),
            amp: 0,
            token_account_ids: vec![dai(), eth()],
            amounts: vec![to_yocto("10").into(), to_yocto("20").into()],
            total_fee: 25,
            shares_total_supply: to_yocto("1").into(),
        }
    );

    // for a new pool, there is no lp token for the exchange
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), pool.valid_account_id()))
            .unwrap_json::<U128>()
            .0,
        to_yocto("0")
    );

    let mut prev_dai = to_yocto("85");
    let mut prev_eth = to_yocto("70");
    let mut prev_usdt = to_yocto("90");

    // swap in 1 dai to get eth
    call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(to_yocto("1"))),
                token_out: eth(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    )
    .assert_success();
    let balances = view!(pool.get_deposits(root.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances.get(&dai()).unwrap().0, prev_dai - to_yocto("1"));
    assert_eq!(balances.get(&eth()).unwrap().0, prev_eth + 1814048647419868151852693);
    prev_dai -= to_yocto("1");
    prev_eth += 1814048647419868151852693;
    // the exchange got some lp tokens as 4 bps in 25 bps.
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), pool.valid_account_id()))
            .unwrap_json::<U128>()
            .0,
        45457128392697592
    );

    // here, we modify admin_fee to more reasonable rate, 1600 bps in 25 bps
    // which is 4 bps (exchange fee) in total, 
    // and 1 bps (referal fee) in total.
    let out_come = call!(
        owner,
        pool.modify_admin_fee(1600, 400)
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);

    // make sure the modification succeed
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.exchange_fee, 1600);
    assert_eq!(metadata.referral_fee, 400);
    let pool_fee = view!(pool.get_pool_fee(0)).unwrap_json::<u32>();
    assert_eq!(pool_fee, 25);

    // swap in 1 usdt to get eth
    call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 1,
                token_in: usdt(),
                amount_in: Some(U128(to_yocto("1"))),
                token_out: eth(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    )
    .assert_success();
    let balances = view!(pool.get_deposits(root.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    
    assert_eq!(balances.get(&usdt()).unwrap().0, prev_usdt - to_yocto("1"));
    assert_eq!(balances.get(&eth()).unwrap().0, prev_eth + 1814048647419868151852693);
    prev_usdt -= to_yocto("1");
    prev_eth += 1814048647419868151852693;
    assert_eq!(
        view!(pool.mft_balance_of(":1".to_string(), pool.valid_account_id()))
            .unwrap_json::<U128>()
            .0,
        18182851357079036914
    );

    // here, we remove exchange_fee liquidity
    let balances = view!(pool.get_deposits(owner.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances.get(&usdt()).unwrap_or(&U128(0)).0, 0);
    assert_eq!(balances.get(&eth()).unwrap_or(&U128(0)).0, 0);
    assert_eq!(balances.get(&dai()).unwrap_or(&U128(0)).0, 0);
    
    // only owner can call, and withdraw liquidity to owner's inner account
    let out_come = call!(
        owner,
        pool.remove_exchange_fee_liquidity(0, U128(45457128392697592), vec![U128(1), U128(1)]),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), pool.valid_account_id()))
            .unwrap_json::<U128>()
            .0,
        0
    );
    let balances = view!(pool.get_deposits(owner.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances.get(&usdt()).unwrap_or(&U128(0)).0, 0);
    assert_eq!(balances.get(&eth()).unwrap_or(&U128(0)).0, 826681087999039131);
    assert_eq!(balances.get(&dai()).unwrap_or(&U128(0)).0, 500028389589818806);

    let out_come = call!(
        owner,
        pool.remove_exchange_fee_liquidity(1, U128(18182851357079036914), vec![U128(1), U128(1)]),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), pool.valid_account_id()))
            .unwrap_json::<U128>()
            .0,
        0
    );
    let balances = view!(pool.get_deposits(owner.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances.get(&usdt()).unwrap_or(&U128(0)).0, 200007728217076967880);
    assert_eq!(balances.get(&eth()).unwrap_or(&U128(0)).0, 331493118860347246997);
    assert_eq!(balances.get(&dai()).unwrap_or(&U128(0)).0, 500028389589818806);

    assert_eq!(prev_dai, to_yocto("84"));
    assert_eq!(prev_eth, 73628097294839736303705386);
    assert_eq!(prev_usdt, to_yocto("89"));
}

'''
'''--- ref-exchange/tests/test_errors.rs ---
/// Test for cases that should panic or throw an error
// ERR66 could not be tested with this approach
// ERR67 could not be tested with this approach
// ERR70 could not be tested with this approach
// ERR81 could not be tested with this approach

use near_sdk::json_types::{U128, U64};
use near_sdk_sim::{init_simulator, call, view, to_yocto, ExecutionResult, runtime};

use ref_exchange::SwapAction;
use crate::common::utils::*;
pub mod common;

const ONE_LPT: u128 = 1000000000000000000;
const ONE_DAI: u128 = 1000000000000000000;
const ONE_USDT: u128 = 1000000;
const ONE_USDC: u128 = 1000000;

fn assert_failure(outcome: ExecutionResult, error_message: &str) {
    assert!(!outcome.is_ok());
    let exe_status = format!("{:?}", outcome.promise_errors()[0].as_ref().unwrap().status());
    println!("{}", exe_status);
    assert!(exe_status.contains(error_message));
}

#[test]
fn sim_stable_e100 () {
    let root = init_simulator(None);
    let (_, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![swap()]);
    let token2 = test_token(&root, usdt(), vec![swap()]);
    let outcome = call!(
        root,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            1000
        ),
        deposit = to_yocto("1")
    );
    assert_failure(outcome, "E100: no permission to invoke this");
}

#[test]
fn sim_stable_e61 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![swap()]);
    let token2 = test_token(&root, usdt(), vec![swap()]);
    call!(
        owner,
        ex.extend_whitelisted_tokens(
            vec![token1.valid_account_id(), token2.valid_account_id()]
        )
    );

    // small amp
    let outcome = call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            0
        ),
        deposit = to_yocto("1")
    );
    assert_failure(outcome, "E61: illegal amp");

    // large amp
    let outcome = call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            100_000_000
        ),
        deposit = to_yocto("1")
    );
    assert_failure(outcome, "E61: illegal amp");
}

#[test]
fn sim_stable_e62 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![swap()]);
    let token2 = test_token(&root, usdt(), vec![swap()]);
    call!(
        owner,
        ex.extend_whitelisted_tokens(
            vec![token1.valid_account_id(), token2.valid_account_id()]
        )
    );

    // invalid fee
    let outcome = call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            100_000,
            10000
        ),
        deposit = to_yocto("1")
    );
    assert_failure(outcome, "E62: illegal fee");
}

#[test]
fn sim_stable_e63 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![1*ONE_DAI, 1*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI), U128(1*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let token3 = test_token(&root, usdc(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token3.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token3], vec![1*ONE_USDC]);

    let outcome = call!(
        root,
        ex.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: token3.account_id(),
                amount_in: Some(U128(100)),
                token_out: usdt(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    assert_failure(outcome, "E63: missing token");
}

#[test]
fn sim_stable_e64 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![1*ONE_DAI, 1*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    // invalid amount list length
    let outcome = call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(100000)], U128(1)),
        deposit = to_yocto("0.01")
    );
    assert_failure(outcome, "E64: illegal tokens count");
    let outcome = call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI)], U128(1)),
        deposit = to_yocto("0.01")
    );
    assert_failure(outcome, "E64: illegal tokens count");

    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI), U128(1*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let outcome = call!(
        root,
        ex.remove_liquidity(0, U128(1), vec![U128(1), U128(1), U128(1)]),
        deposit = 1
    );
    assert_failure(outcome, "E64: illegal tokens count");
    let outcome = call!(
        root,
        ex.remove_liquidity(0, U128(1), vec![U128(1)]),
        deposit = 1
    );
    assert_failure(outcome, "E64: illegal tokens count");

    let outcome = call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(1), U128(1), U128(1)], U128(1)),
        deposit = 1
    );
    assert_failure(outcome, "E64: illegal tokens count");
    let outcome = call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(1)], U128(1)),
        deposit = 1
    );
    assert_failure(outcome, "E64: illegal tokens count");
}

#[test]
fn sim_stable_e65 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![1*ONE_DAI, 1*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    // invalid amount list length
    let outcome = call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI), U128(0*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    );
    assert_failure(outcome, "E65: init token balance should be non-zero");

    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1*ONE_DAI), U128(1*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();
}

#[test]
fn sim_stable_e13 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![1*ONE_DAI, 1*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    let user = root.create_user("user".to_string(), to_yocto("100"));

    let outcome = call!(
        user,
        ex.remove_liquidity(0, U128(1), vec![U128(1), U128(1)]),
        deposit = 1
    );
    assert_failure(outcome, "E13: LP not registered");

    let outcome = call!(
        user,
        ex.remove_liquidity_by_tokens(0, vec![U128(1), U128(1)], U128(1)),
        deposit = 1
    );
    assert_failure(outcome, "E13: LP not registered");

    let outcome = call!(
        user,
        ex.mft_transfer(":0".to_string(), root.valid_account_id(), U128(1), None),
        deposit = 1
    );
    assert_failure(outcome, "E13: LP not registered");
}

#[test]
fn sim_stable_e34 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![1000*ONE_DAI, 1000*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();
    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(1000*ONE_DAI), U128(1000*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let lp_shares = view!(
        ex.mft_balance_of(":0".to_string(), root.valid_account_id())
    ).unwrap_json::<U128>();
    let lp_shares = lp_shares.0;

    let outcome = call!(
        root,
        ex.remove_liquidity(0, U128(lp_shares + 1), vec![U128(1), U128(1)]),
        deposit = 1
    );
    assert_failure(outcome, "E34: insufficient lp shares");

    call!(
        owner,
        ex.mft_register(":0".to_string(), owner.valid_account_id()),
        deposit = to_yocto("1")
    )
    .assert_success();

    // transfer all lp token to others
    call!(
        root,
        ex.mft_transfer(":0".to_string(), owner.valid_account_id(), U128(lp_shares), None),
        deposit = 1
    )
    .assert_success();

    let outcome = call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(1*ONE_DAI), U128(1*ONE_USDT)], U128(1)),
        deposit = 1
    );
    assert_failure(outcome, "E34: insufficient lp shares");

    let outcome = call!(
        root,
        ex.mft_transfer(":0".to_string(), owner.valid_account_id(), U128(2*ONE_LPT), None),
        deposit = 1
    );
    assert_failure(outcome, "E34: insufficient lp shares");
}

#[test]
fn sim_stable_e68 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();
    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(100*ONE_DAI), U128(100*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let outcome = call!(
        root,
        ex.remove_liquidity(0, U128(100*ONE_LPT), vec![U128(51*ONE_DAI), U128(50*ONE_USDT)]),
        deposit = 1
    );
    assert_failure(outcome, "E68: slippage error");

    let outcome = call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(50*ONE_DAI), U128(50*ONE_USDT)], U128(99*ONE_LPT)),
        deposit = 1
    );
    assert_failure(outcome, "E68: slippage error");

    let outcome = call!(
        root,
        ex.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdt(),
                min_amount_out: U128(2 * ONE_USDT)
            }],
            None
        ),
        deposit = 1
    );
    assert_failure(outcome, "E68: slippage error");
}

#[test]
fn sim_stable_e69 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();
    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(100*ONE_DAI), U128(100*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    // try to withdraw all from pool
    let outcome = call!(
        root,
        ex.remove_liquidity(0, U128(200*ONE_LPT), vec![U128(1), U128(1)]),
        deposit = 1
    );
    assert_failure(outcome, "E69: pool reserved token balance less than MIN_RESERVE");

    let outcome = call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(100*ONE_DAI), U128(100*ONE_USDT)], U128(200*ONE_LPT)),
        deposit = 1
    );
    assert_failure(outcome, "E69: pool reserved token balance less than MIN_RESERVE");

    // remove liquidity so that the pool is small enough
    call!(
        root,
        ex.remove_liquidity_by_tokens(0, vec![U128(99*ONE_DAI), U128(99*ONE_USDT)], U128(200*ONE_LPT)),
        deposit = 1
    )
    .assert_success();

    let outcome = call!(
        root,
        ex.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(99*ONE_DAI)),
                token_out: usdt(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    assert_failure(outcome, "E69: pool reserved token balance less than MIN_RESERVE");
}

#[test]
fn sim_stable_e71 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();
    call!(
        root,
        ex.add_stable_liquidity(0, vec![U128(100*ONE_DAI), U128(100*ONE_USDT)], U128(1)),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let outcome = call!(
        root,
        ex.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(1)),
                token_out: dai(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    assert_failure(outcome, "E71: illegal swap with duplicated tokens");
}

#[test]
fn sim_stable_e14 () {
    let root = init_simulator(None);
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    let outcome = call!(
        root,
        ex.mft_register(":0".to_string(), ex.valid_account_id()),
        deposit = to_yocto("1")
    );
    assert_failure(outcome, "E14: LP already registered");
}

#[test]
fn sim_stable_e82 () {
    let mut gc = runtime::GenesisConfig::default();
    gc.genesis_time = 86400 * 1_000_000_000;
    let root = init_simulator(Some(gc));
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    let outcome = call!(
        owner,
        ex.stable_swap_ramp_amp(0, 0, U64(0))
    );
    assert_failure(outcome, "E82: insufficient ramp time");
}

#[test]
fn sim_stable_e83 () {
    let mut gc = runtime::GenesisConfig::default();
    gc.genesis_time = 86400 * 1_000_000_000;
    let root = init_simulator(Some(gc));
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    let runtime = root.borrow_runtime().current_block().block_timestamp;
    println!("{}", runtime);

    let outcome = call!(
        owner,
        ex.stable_swap_ramp_amp(0, 0, U64(3 * 86400 * 1_000_000_000))
    );
    assert_failure(outcome, "E83: invalid amp factor");

    let outcome = call!(
        owner,
        ex.stable_swap_ramp_amp(0, 1_000_001, U64(3 * 86400 * 1_000_000_000))
    );
    assert_failure(outcome, "E83: invalid amp factor");
}

#[test]
fn sim_stable_e84 () {
    let mut gc = runtime::GenesisConfig::default();
    gc.genesis_time = 86400 * 1_000_000_000;
    let root = init_simulator(Some(gc));
    let (owner, ex) = setup_exchange(&root, 1600, 400);
    let token1 = test_token(&root, dai(), vec![ex.account_id()]);
    let token2 = test_token(&root, usdt(), vec![ex.account_id()]);
    whitelist_token(&owner, &ex, vec![token1.valid_account_id(), token2.valid_account_id()]);
    deposit_token(&root, &ex, vec![&token1, &token2], vec![101*ONE_DAI, 101*ONE_USDT]);

    call!(
        owner,
        ex.add_stable_swap_pool(
            vec![token1.valid_account_id(), token2.valid_account_id()], 
            vec![18, 6],
            25,
            10000
        ),
        deposit = to_yocto("1")
    ).assert_success();

    let outcome = call!(
        owner,
        ex.stable_swap_ramp_amp(0, 1, U64(3 * 86400 * 1_000_000_000))
    );
    assert_failure(outcome, "E84: amp factor change is too large");
}

'''
'''--- ref-exchange/tests/test_fuzz_amm.rs ---
use near_sdk_sim::{
    view, ContractAccount, UserAccount,
};

use ref_exchange::{ContractContract as Exchange};

use rand::{Rng, SeedableRng};
use rand_pcg::Pcg32;

mod fuzzy;
use fuzzy::{constants::*,
    create_simple_pool::*,
    direct_swap::*,
    liquidity_manage::*,
    pool_swap::*,
    types::*,
    utils::*
};

fn do_operation(ctx: &mut OperationContext, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, pool :&ContractAccount<Exchange>){
    let simple_pool_count = view!(pool.get_number_of_pools()).unwrap_json::<u64>();
    println!("current pool num : {}", simple_pool_count);

    if simple_pool_count == 0 {
        create_simple_pool(ctx, rng, root, operator, pool);
    }
    match operator.preference{
        Preference::CreateSamplePool => {
            const NEED_REPEAT_CREATE: i8 = 1;
            let repeat_create: i8 = rng.gen();
            if simple_pool_count != 0 && NEED_REPEAT_CREATE == repeat_create % 2{
                create_simple_pool(ctx, rng, root, operator, pool);
            }
        }, 
        Preference::DirectSwap => {
            do_direct_swap(ctx, rng, root, operator, pool, simple_pool_count);
        },
        Preference::PoolSwap => {
            do_pool_swap(ctx, rng, root, operator, pool, simple_pool_count);
        },
        Preference::AddLiquidity => {
            do_add_liquidity(ctx, rng, root, operator, pool, simple_pool_count, None);
        }
    }
}

fn generate_fuzzy_seed() -> Vec<u64>{
    let mut seeds:Vec<u64> = Vec::new();

    let mut rng = rand::thread_rng();
    for _ in 0..FUZZY_NUM {
        let seed: u64 = rng.gen();
        seeds.push(seed);
    }
    seeds
}

#[test]
fn test_fuzzy_amm(){

    let seeds = generate_fuzzy_seed();
    for seed in seeds {

        println!("*********************************************");
        println!("current seed : {}", seed);
        println!("*********************************************");

        let mut ctx = OperationContext::default();
        
        let mut rng = Pcg32::seed_from_u64(seed as u64);
        let (root, _owner, pool, users) = init_pool_env();

        for i in 0..OPERATION_NUM{
            let operator = get_operator(&mut rng, &users);
            println!("NO.{} : {:?}", i, operator);
            do_operation(&mut ctx, &mut rng, &root, operator, &pool);
        }
    }
}
'''
'''--- ref-exchange/tests/test_fuzzy_stable.rs ---
use near_sdk_sim::{
    view, ContractAccount, UserAccount,
};

use test_token::ContractContract as TestToken;
use ref_exchange::PoolInfo;
use ref_exchange::{ContractContract as Exchange};

use rand::{Rng, SeedableRng};
use rand_pcg::Pcg32;

mod fuzzy;
use fuzzy::{constants::*,
    liquidity_manage::*,
    pool_swap::*,
    types::*,
    utils::*,
};

fn do_operation(rng: &mut Pcg32, root: &UserAccount, operator: &StableOperator, pool :&ContractAccount<Exchange>, token_contracts: &Vec<ContractAccount<TestToken>>){
    println!("current stable pool info: {:?}", view!(pool.get_pool(0)).unwrap_json::<PoolInfo>());
    match operator.preference{
        StablePreference::RemoveLiquidityByToken => {
            do_stable_remove_liquidity_by_token(token_contracts, rng, root, operator, pool);
        },
        StablePreference::RemoveLiquidityByShare => {
            do_stable_remove_liquidity_by_shares(token_contracts, rng, root, operator, pool);
        },
        StablePreference::PoolSwap => {
            do_stable_pool_swap(token_contracts, rng, root, operator, pool);
        },
        StablePreference::AddLiquidity => {
            do_stable_add_liquidity(token_contracts, rng, root, operator, pool);
        }
    }
}

fn generate_fuzzy_seed() -> Vec<u64>{
    let mut seeds:Vec<u64> = Vec::new();

    let mut rng = rand::thread_rng();
    for _ in 0..FUZZY_NUM {
        let seed: u64 = rng.gen();
        seeds.push(seed);
    }
    seeds
}

#[test]
fn test_fuzzy_stable() {
    let seeds = generate_fuzzy_seed();

    for seed in seeds {

        println!("*********************************************");
        println!("current seed : {}", seed);
        println!("*********************************************");

        let mut rng = Pcg32::seed_from_u64(seed as u64);
        let (root, _owner, pool, token_contracts, operators) = 
        setup_stable_pool_with_liquidity_and_operators(
            STABLE_TOKENS.iter().map(|&v| v.to_string()).collect(),
            vec![100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC],
            DECIMALS.to_vec(),
            25,
            10000,
        );

        for i in 0..OPERATION_NUM{
            let operator = get_operator(&mut rng, &operators);
            println!("NO.{} : {:?}", i, operator);
            do_operation(&mut rng, &root, operator, &pool, &token_contracts);
        }
    }
}
'''
'''--- ref-exchange/tests/test_guardians.rs ---
use near_sdk::json_types::{U128};
use near_sdk_sim::{call, to_yocto};

use ref_exchange::{RunningState, SwapAction};
use crate::common::utils::*;
pub mod common;

#[test]
fn guardians_scenario_01() {
    let (root, owner, pool, token1, _, _) = setup_pool_with_liquidity();
    let guard1 = root.create_user("guard1".to_string(), to_yocto("100"));
    let guard2 = root.create_user("guard2".to_string(), to_yocto("100"));
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));

    println!("Guardians Case 0101: only owner can add guardians");
    let out_come = call!(
        root,
        pool.extend_guardians(vec![guard1.valid_account_id(), guard2.valid_account_id()])
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("ERR_NOT_ALLOWED"));
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.guardians.len(), 0);

    let out_come = call!(
        owner,
        pool.extend_guardians(vec![guard1.valid_account_id(), guard2.valid_account_id()])
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.guardians.len(), 2);
    assert_eq!(metadata.guardians.get(0).unwrap().clone(), guard1.account_id());
    assert_eq!(metadata.guardians.get(1).unwrap().clone(), guard2.account_id());

    println!("Guardians Case 0102: only owner and guardians can manage global whitelists");
    let out_come = call!(
        root,
        pool.remove_whitelisted_tokens(vec![to_va(eth()), to_va(dai())])
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("ERR_NOT_ALLOWED"));
    let wl = get_whitelist(&pool);
    assert_eq!(wl.len(), 3);
    assert_eq!(wl.get(0).unwrap().clone(), dai());
    assert_eq!(wl.get(1).unwrap().clone(), eth());
    assert_eq!(wl.get(2).unwrap().clone(), usdt());

    let out_come = call!(
        owner,
        pool.remove_whitelisted_tokens(vec![to_va(usdt()), to_va(eth()), to_va(dai())])
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let wl = get_whitelist(&pool);
    assert_eq!(wl.len(), 0);

    let out_come = call!(
        owner,
        pool.extend_whitelisted_tokens(vec![to_va(dai())])
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let wl = get_whitelist(&pool);
    assert_eq!(wl.len(), 1);
    assert_eq!(wl.get(0).unwrap().clone(), dai());

    let out_come = call!(
        guard1,
        pool.extend_whitelisted_tokens(vec![to_va(eth())])
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let wl = get_whitelist(&pool);
    assert_eq!(wl.len(), 2);
    assert_eq!(wl.get(0).unwrap().clone(), dai());
    assert_eq!(wl.get(1).unwrap().clone(), eth());

    let out_come = call!(
        guard2,
        pool.extend_whitelisted_tokens(vec![to_va(usdt())])
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let wl = get_whitelist(&pool);
    assert_eq!(wl.len(), 3);
    assert_eq!(wl.get(0).unwrap().clone(), dai());
    assert_eq!(wl.get(1).unwrap().clone(), eth());
    assert_eq!(wl.get(2).unwrap().clone(), usdt());

    println!("Guardians Case 0103: only owner and guardians can pause the contract");
    let out_come = call!(
        root,
        pool.change_state(RunningState::Paused),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("ERR_NOT_ALLOWED"));
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.state, RunningState::Running);

    let out_come = call!(
        guard1,
        pool.change_state(RunningState::Paused),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.state, RunningState::Paused);

    // register user would fail
    let out_come = call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // add pool would fail
    let out_come = call!(
        root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // deposit token would fail
    let out_come = call!(
        root,
        token1.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // add liquidity would fail
    let out_come = call!(
        root,
        pool.add_liquidity(0, vec![U128(to_yocto("10")), U128(to_yocto("20"))], None),
        deposit = to_yocto("0.0007")
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // swap would fail
    let out_come = call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(to_yocto("1"))),
                token_out: eth(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // // instant swap would fail
    // call!(
    //     new_user,
    //     token2.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    // )
    // .assert_success();
    // let msg = format!(
    //     "{{\"pool_id\": {}, \"token_in\": \"{}\", \"token_out\": \"{}\", \"min_amount_out\": \"{}\"}}",
    //     0, token2.account_id(), token1.account_id(), 1
    // );
    // let msg_str = format!("{{\"force\": 0, \"actions\": [{}]}}", msg);
    // let out_come = call!(
    //     new_user,
    //     token2.ft_transfer_call(to_va(swap()), to_yocto("1").into(), None, msg_str.clone()),
    //     deposit = 1
    // );
    // out_come.assert_success();
    // assert_eq!(get_error_count(&out_come), 1);
    // assert!(get_error_status(&out_come).contains("E51: contract paused"));

    // withdraw token would fail
    let out_come = call!(
        root,
        pool.withdraw(to_va(eth()), U128(to_yocto("1")), None),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E51: contract paused"));

    println!("Guardians Case 0104: only owner can resume the contract");
    let out_come = call!(
        root,
        pool.change_state(RunningState::Running),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("ERR_NOT_ALLOWED"));
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.state, RunningState::Paused);

    let out_come = call!(
        guard2,
        pool.change_state(RunningState::Running),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("ERR_NOT_ALLOWED"));
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.state, RunningState::Paused);

    let out_come = call!(
        owner,
        pool.change_state(RunningState::Running),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    let metadata = get_metadata(&pool);
    assert_eq!(metadata.state, RunningState::Running);

    let out_come = call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
} 

'''
'''--- ref-exchange/tests/test_instant_swap.rs ---
use near_sdk::json_types::U128;
use near_sdk_sim::{
    call, to_yocto, ContractAccount, ExecutionResult, UserAccount,
};

use test_token::ContractContract as TestToken;

use crate::common::utils::*;
pub mod common;

fn pack_action(
    pool_id: u32,
    token_in: &str,
    token_out: &str,
    amount_in: Option<u128>,
    min_amount_out: u128,
) -> String {
    if let Some(amount_in) = amount_in {
        format!(
            "{{\"pool_id\": {}, \"token_in\": \"{}\", \"amount_in\": \"{}\", \"token_out\": \"{}\", \"min_amount_out\": \"{}\"}}",
            pool_id, token_in, amount_in, token_out, min_amount_out
        )
    } else {
        format!(
            "{{\"pool_id\": {}, \"token_in\": \"{}\", \"token_out\": \"{}\", \"min_amount_out\": \"{}\"}}",
            pool_id, token_in, token_out, min_amount_out
        )
    }
}

fn direct_swap(
    user: &UserAccount,
    contract: &ContractAccount<TestToken>,
    actions: Vec<String>,
    amount: u128,
) -> ExecutionResult {
    // {{\"pool_id\": 0, \"token_in\": \"dai\", \"token_out\": \"eth\", \"min_amount_out\": \"1\"}}
    let actions_str = actions.join(", ");
    let msg_str = format!("{{\"actions\": [{}]}}", actions_str);
    // println!("{}", msg_str);
    call!(
        user,
        contract.ft_transfer_call(to_va(swap()), amount.into(), None, msg_str),
        deposit = 1
    )
}

#[test]
fn instant_swap_scenario_01() {
    let (root, owner, pool, token1, token2, _) = setup_pool_with_liquidity();
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));
    call!(
        new_user,
        token1.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();

    println!("Case 0101: wrong msg");
    let out_come = direct_swap(&new_user, &token1, vec!["wrong".to_string()], to_yocto("1"));
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come).contains("E28: Illegal msg in ft_transfer_call"));
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("10"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("0"));

    println!("Case 0102: less then min_amount_out");
    let action = pack_action(
        0,
        &token1.account_id(),
        &token2.account_id(),
        None,
        to_yocto("1.9"),
    );
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: panicked at 'ERR_MIN_AMOUNT'"));
    assert!(get_storage_balance(&pool, new_user.valid_account_id()).is_none());
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("10"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("0"));

    println!("Case 0103: non-registered user swap but not registered in token2");
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: The account new_user is not registered"));
    // println!("total logs: {:#?}", get_logs(&out_come));
    // assert!(get_logs(&out_come)[2].contains("Account new_user is not registered. Depositing to owner."));
    assert!(get_storage_balance(&pool, new_user.valid_account_id()).is_none());
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("9"));
    assert!(
        get_deposits(&pool, owner.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0
            > to_yocto("1.8")
    );

    call!(
        new_user,
        token2.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    println!("Case 0104: non-registered user swap");
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    // println!("{:#?}", out_come.promise_results());
    // println!("total logs: {:#?}", get_logs(&out_come));
    assert!(get_storage_balance(&pool, new_user.valid_account_id()).is_none());
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("8"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("1.5"));
}

#[test]
fn instant_swap_scenario_02() {
    let (root, owner, pool, token1, token2, token3) = setup_pool_with_liquidity();
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));
    call!(
        new_user,
        token1.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();

    println!("Case 0201: registered user without any deposits and non-registered to token2");
    call!(
        new_user,
        pool.storage_deposit(None, Some(true)),
        deposit = to_yocto("1")
    )
    .assert_success();
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .available
            .0,
        to_yocto("0")
    );
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .total
            .0,
        to_yocto("0.00102")
    );
    // println!("{:#?}", get_storage_balance(&pool, new_user.valid_account_id()).unwrap());
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    // println!("swap one logs: {:#?}", get_logs(&out_come));
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: The account new_user is not registered"));
    // println!("total logs: {:#?}", get_logs(&out_come));
    assert!(get_logs(&out_come)[2].contains("Account new_user has not enough storage. Depositing to owner."));
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .available
            .0,
        to_yocto("0")
    );
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .total
            .0,
        to_yocto("0.00102")
    );
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("9"));
    assert!(
        get_deposits(&pool, owner.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0
            > to_yocto("1.8")
    );
    assert!(get_deposits(&pool, new_user.valid_account_id())
        .get(&token1.account_id())
        .is_none());
    assert!(get_deposits(&pool, new_user.valid_account_id())
        .get(&token2.account_id())
        .is_none());

    println!("Case 0202: registered user without any deposits");
    call!(
        new_user,
        token2.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("9"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("10"));
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    // println!("total logs: {:#?}", get_logs(&out_come));
    assert_eq!(get_error_count(&out_come), 0);
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .available
            .0,
        0
    );
    assert_eq!(
        get_storage_balance(&pool, new_user.valid_account_id())
            .unwrap()
            .total
            .0,
        to_yocto("0.00102")
    );
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("8"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("11.5"));

    println!("Case 0203: registered user with token already deposited");
    call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        new_user,
        token1.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        new_user,
        token2.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token1.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action], to_yocto("1"));
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token1.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("2"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("7.7"));

    println!("Case 0204: deposit token is not in action");
    call!(
        new_user,
        token3.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();
    let action = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token3, vec![action], to_yocto("1"));
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 1);
    // println!("{}", get_error_status(&out_come));
    assert!(get_error_status(&out_come).contains("E21: token not registered"));
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token1.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
    assert_eq!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0,
        to_yocto("5")
    );
}

#[test]
fn instant_swap_scenario_03() {
    let (root, owner, pool, token1, token2, token3) = setup_pool_with_liquidity();
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));
    call!(
        new_user,
        token1.mint(to_va(new_user.account_id.clone()), U128(to_yocto("5")))
    )
    .assert_success();
    call!(
        new_user,
        token2.mint(to_va(new_user.account_id.clone()), U128(to_yocto("5")))
    )
    .assert_success();
    call!(
        new_user,
        token3.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();
    call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        new_user,
        token3.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        new_user,
        pool.storage_withdraw(None),
        deposit = 1
    )
    .assert_success();

    println!("Case 0301: two actions with one output token");
    let action1 = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let action2 = pack_action(1, &token2.account_id(), &token3.account_id(), None, 1);
    let out_come = direct_swap(&new_user, &token1, vec![action1, action2], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 0);

    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("4"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("5"));
    // println!("token3 {}", balance_of(&token3, &new_user.account_id));
    assert!(balance_of(&token3, &new_user.account_id) > to_yocto("5.8"));

    println!("Case 0302: two actions with tow output token");
    let action1 = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let action2 = pack_action(1, &token2.account_id(), &token3.account_id(), Some(to_yocto("1")), 1);
    let out_come = direct_swap(&new_user, &token1, vec![action1, action2], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 0);

    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("3"));
    // println!("token2 {}", balance_of(&token2, &new_user.account_id));
    // println!("token3 {}", balance_of(&token3, &new_user.account_id));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("5.5"));
    assert!(balance_of(&token3, &new_user.account_id) > to_yocto("6.2"));

    println!("Case 0303: two actions with two output token and send back token#2 fail");
    call!(new_user, token2.storage_unregister(Some(true)), deposit = 1).assert_success();
    assert!(!is_register_to_token(&token2, new_user.valid_account_id()));
    let action1 = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let action2 = pack_action(1, &token2.account_id(), &token3.account_id(), Some(to_yocto("1")), 1);
    let out_come = direct_swap(&new_user, &token1, vec![action1, action2], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: The account new_user is not registered"));
    
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("2"));
    assert!(
        get_deposits(&pool, owner.valid_account_id())
            .get(&token2.account_id())
            .unwrap()
            .0 
            > to_yocto("0.27")
    );
    // println!("token3 {}", balance_of(&token3, &new_user.account_id));
    assert!(balance_of(&token3, &new_user.account_id) > to_yocto("6.598"));

    println!("Case 0304: two actions with two output token and send back token#3 fail");
    call!(
        new_user,
        token2.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();
    call!(new_user, token3.storage_unregister(Some(true)), deposit = 1).assert_success();
    assert!(!is_register_to_token(&token3, new_user.valid_account_id()));
    let action1 = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let action2 = pack_action(
        1,
        &token2.account_id(),
        &token3.account_id(),
        Some(to_yocto("1")),
        1,
    );
    let out_come = direct_swap(&new_user, &token1, vec![action1, action2], to_yocto("1"));
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: The account new_user is not registered"));

    assert!(
        get_deposits(&pool, new_user.valid_account_id())
            .get(&token3.account_id())
            .unwrap()
            .0
            > to_yocto("5.33")
    );
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("1"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("10.09"));

    println!("Case 0305: two actions with the second one insurfficent");
    let action1 = pack_action(0, &token1.account_id(), &token2.account_id(), None, 1);
    let action2 = pack_action(
        1,
        &token2.account_id(),
        &token3.account_id(),
        Some(to_yocto("1.2")),
        1,
    );
    let out_come = direct_swap(&new_user, &token1, vec![action1, action2], to_yocto("1"));
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 1);
    // println!("{}", get_error_status(&out_come));
    assert!(get_error_status(&out_come).contains("E22: not enough tokens in deposit"));
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("1"));
}

#[test]
fn instant_swap_scenario_04() {
    const ONE_DAI: u128 = 1000000000000000000;
    const ONE_USDT: u128 = 1000000;
    const ONE_USDC: u128 = 1000000;
    let (root, owner, pool, tokens) = 
        setup_stable_pool_with_liquidity(
            vec![dai(), usdt(), usdc()],
            vec![100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC],
            vec![18, 6, 6],
            25,
            10000,
        );
    let tokens = &tokens;
    let user = root.create_user("user".to_string(), to_yocto("100"));
    let token_in = &tokens[0];
    let token_out = &tokens[1];
    call!(user, token_in.mint(user.valid_account_id(), U128(10*ONE_DAI))).assert_success();

    println!("Case 0401: non-registered user stable swap but not registered in token2");
    let action = pack_action(0, &tokens[0].account_id(), &tokens[1].account_id(), None, 1);
    let out_come = direct_swap(&user, &tokens[0], vec![action], 1*ONE_DAI);
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 1);
    assert!(get_error_status(&out_come)
        .contains("Smart contract panicked: The account user is not registered"));
    assert!(get_storage_balance(&pool, user.valid_account_id()).is_none());
    assert_eq!(balance_of(&tokens[0], &user.account_id), 9*ONE_DAI);

    assert_eq!(
        get_deposits(&pool, owner.valid_account_id())
            .get(&token_out.account_id())
            .unwrap()
            .0,
            997499
    );

    println!("Case 0402: non-registered user stable swap");
    call!(
        user,
        token_out.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    let action = pack_action(0, &tokens[0].account_id(), &tokens[1].account_id(), None, 1);
    let out_come = direct_swap(&user, &tokens[0], vec![action], 1*ONE_DAI);
    out_come.assert_success();
    assert_eq!(get_error_count(&out_come), 0);
    assert!(get_storage_balance(&pool, user.valid_account_id()).is_none());
    assert_eq!(balance_of(&token_in, &user.account_id), 8*ONE_DAI);
    assert_eq!(balance_of(&token_out, &user.account_id), 997499);
}
'''
'''--- ref-exchange/tests/test_migrate.rs ---
use std::convert::TryFrom;

use near_sdk::json_types::{ValidAccountId};
use near_sdk_sim::{deploy, init_simulator, to_yocto};

use ref_exchange::{ContractContract as Exchange, RunningState};

use crate::common::utils::*;
pub mod common;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    PREV_EXCHANGE_WASM_BYTES => "../res/ref_exchange_131.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
}

#[test]
fn test_upgrade() {
    let root = init_simulator(None);
    let test_user = root.create_user("test".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: "swap".to_string(),
        bytes: &PREV_EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(ValidAccountId::try_from(root.account_id.clone()).unwrap(), 4, 1)
    );
    // Failed upgrade with no permissions.
    let result = test_user
        .call(
            pool.user_account.account_id.clone(),
            "upgrade",
            &EXCHANGE_WASM_BYTES,
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .status();
    assert!(format!("{:?}", result).contains("ERR_NOT_ALLOWED"));

    root.call(
        pool.user_account.account_id.clone(),
        "upgrade",
        &EXCHANGE_WASM_BYTES,
        near_sdk_sim::DEFAULT_GAS,
        0,
    )
    .assert_success();
    let metadata = get_metadata(&pool);
    // println!("{:#?}", metadata);
    assert_eq!(metadata.version, "1.4.1".to_string());
    assert_eq!(metadata.exchange_fee, 1600);
    assert_eq!(metadata.referral_fee, 400);
    assert_eq!(metadata.state, RunningState::Running);

    // Upgrade to the same code migration is skipped.
    root.call(
        pool.user_account.account_id.clone(),
        "upgrade",
        &EXCHANGE_WASM_BYTES,
        near_sdk_sim::DEFAULT_GAS,
        0,
    )
    .assert_success();
}
'''
'''--- ref-exchange/tests/test_stable_pool.rs ---
use std::collections::HashMap;

use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::json_types::{U128};
use near_sdk::AccountId;
use near_sdk_sim::{
    call, view, to_yocto
};

use ref_exchange::{PoolInfo, SwapAction};
use crate::common::utils::*;
pub mod common;

const ONE_LPT: u128 = 1000000000000000000;
const ONE_DAI: u128 = 1000000000000000000;
const ONE_USDT: u128 = 1000000;
const ONE_USDC: u128 = 1000000;

#[test]
fn sim_stable_swap() {
    let (root, _owner, pool, tokens) = 
        setup_stable_pool_with_liquidity(
            vec![dai(), usdt(), usdc()],
            vec![100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC],
            vec![18, 6, 6],
            25,
            10000,
        );
    let tokens = &tokens;
    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "STABLE_SWAP".to_string(),
            amp: 10000,
            token_account_ids: tokens.into_iter().map(|x| x.account_id()).collect(),
            amounts: vec![U128(100000*ONE_DAI), U128(100000*ONE_USDT), U128(100000*ONE_USDC)],
            total_fee: 25,
            shares_total_supply: U128(300000*ONE_LPT),
        }
    );
    assert_eq!(
        view!(pool.mft_metadata(":0".to_string()))
            .unwrap_json::<FungibleTokenMetadata>()
            .name,
        "ref-pool-0"
    );
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), to_va(root.account_id.clone())))
            .unwrap_json::<U128>()
            .0,
        300000*ONE_LPT
    );
    let balances = view!(pool.get_deposits(root.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    let balances = balances.values().cloned().collect::<Vec<_>>();
    assert_eq!(balances, vec![U128(0), U128(0), U128(0)]);

    let c = tokens.get(0).unwrap();
    call!(
        root,
        c.ft_transfer_call(pool.valid_account_id(), U128(2 * ONE_DAI), None, "".to_string()),
        deposit = 1
    )
    .assert_success();

    let out_come = call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdc(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));

    let out_come = call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdt(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));

    let balances = view!(pool.get_deposits(root.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances[&dai()].0, 0);
    assert_eq!(balances[&usdt()].0, 997499);
    assert_eq!(balances[&usdc()].0, 997499);

    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "STABLE_SWAP".to_string(),
            amp: 10000,
            token_account_ids: tokens.into_iter().map(|x| x.account_id()).collect(),
            amounts: vec![U128(100002*ONE_DAI), U128(99999*ONE_USDT+2500), U128(99999*ONE_USDC+2500)],
            total_fee: 25,
            shares_total_supply: U128(300000*ONE_LPT + 499999996666583 + 499999993277742),
        }
    );
}

#[test]
fn sim_stable_lp() {
    let (root, _owner, pool, tokens) = 
        setup_stable_pool_with_liquidity(
            vec![dai(), usdt(), usdc()],
            vec![100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC],
            vec![18, 6, 6],
            25,
            10000,
        );
    let tokens = &tokens;
    let last_share_price = pool_share_price(&pool, 0);
    let last_lpt_supply = mft_total_supply(&pool, ":0");

    // add more liquidity with balanced tokens
    let user1 = root.create_user("user1".to_string(), to_yocto("100"));
    mint_and_deposit_token(&user1, &tokens[0], &pool, 500*ONE_DAI);
    mint_and_deposit_token(&user1, &tokens[1], &pool, 500*ONE_USDT);
    mint_and_deposit_token(&user1, &tokens[2], &pool, 500*ONE_USDC);
    let out_come = call!(
        user1,
        pool.add_stable_liquidity(0, vec![U128(500*ONE_DAI), U128(500*ONE_USDT), U128(500*ONE_USDC)], U128(1)),
        deposit = to_yocto("0.0007")
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply + 1500*ONE_LPT);
    let last_lpt_supply = last_lpt_supply + 1500*ONE_LPT;

    // remove by shares
    let out_come = call!(
        user1,
        pool.remove_liquidity(0, U128(300*ONE_LPT), vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)]),
        deposit = 1 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1200*ONE_LPT);
    let balances = view!(pool.get_deposits(user1.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances[&dai()].0, 100*ONE_DAI);
    assert_eq!(balances[&usdt()].0, 100*ONE_USDT);
    assert_eq!(balances[&usdc()].0, 100*ONE_USDC);
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply - 300*ONE_LPT);
    let last_lpt_supply = last_lpt_supply - 300*ONE_LPT;

    // add more liquidity with imba tokens
    let user2 = root.create_user("user2".to_string(), to_yocto("100"));
    mint_and_deposit_token(&user2, &tokens[0], &pool, 100*ONE_DAI);
    mint_and_deposit_token(&user2, &tokens[1], &pool, 200*ONE_USDT);
    mint_and_deposit_token(&user2, &tokens[2], &pool, 400*ONE_USDC);
    let out_come = call!(
        user2,
        pool.add_stable_liquidity(0, vec![U128(100*ONE_DAI), U128(200*ONE_USDT), U128(400*ONE_USDC)], U128(1)),
        deposit = to_yocto("0.0014")  // 0.0007 for one lp and double it for admin fee
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));

    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "STABLE_SWAP".to_string(),
            amp: 10000,
            token_account_ids: tokens.into_iter().map(|x| x.account_id()).collect(),
            amounts: vec![U128(100500*ONE_DAI), U128(100600*ONE_USDT), U128(100800*ONE_USDC)],
            total_fee: 25,
            shares_total_supply: U128(301200*ONE_LPT+699699997426210330025+47999999735823255),
        }
    );
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1200*ONE_LPT);
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 699699997426210330025);
    assert!(pool_share_price(&pool, 0) > last_share_price);
    let last_share_price = pool_share_price(&pool, 0);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply + 699699997426210330025 + 47999999735823255);
    let last_lpt_supply = last_lpt_supply + 699699997426210330025 + 47999999735823255;

    // remove by tokens
    let out_come = call!(
        user1,
        pool.remove_liquidity_by_tokens(0, vec![U128(1*ONE_DAI), U128(500*ONE_USDT), U128(1*ONE_USDC)], U128(550*ONE_LPT)),
        deposit = 1 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 697401508719920229455);
    let balances = view!(pool.get_deposits(user1.valid_account_id()))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances[&dai()].0, 101*ONE_DAI);
    assert_eq!(balances[&usdt()].0, 600*ONE_USDT);
    assert_eq!(balances[&usdc()].0, 101*ONE_USDC);
    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "STABLE_SWAP".to_string(),
            amp: 10000,
            token_account_ids: tokens.into_iter().map(|x| x.account_id()).collect(),
            amounts: vec![U128(100499*ONE_DAI), U128(100100*ONE_USDT), U128(100799*ONE_USDC)],
            total_fee: 25,
            shares_total_supply: U128(last_lpt_supply-502598491280079770545+95823884420348155),
        }
    );
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1200*ONE_LPT-502598491280079770545);
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 699699997426210330025);
    assert!(pool_share_price(&pool, 0) > last_share_price);
    let last_share_price = pool_share_price(&pool, 0);
    let last_lpt_supply = last_lpt_supply - 502598491280079770545 + 95823884420348155;

    // tansfer some to other
    let out_come = call!(
        user1,
        pool.mft_transfer(":0".to_string(), user2.valid_account_id(), U128(100*ONE_LPT), None),
        deposit = 1 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1100*ONE_LPT-502598491280079770545);
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 799699997426210330025);
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply);

    // other remove by shares trigger slippage
    let out_come = call!(
        user2,
        pool.remove_liquidity(0, U128(300*ONE_LPT), vec![U128(1*ONE_DAI), U128(298*ONE_USDT), U128(1*ONE_USDC)]),
        deposit = 1 
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E68: slippage error"));
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply);

    // other remove by tokens trigger slippage
    let out_come = call!(
        user2,
        pool.remove_liquidity_by_tokens(0, vec![U128(1*ONE_DAI), U128(298*ONE_USDT), U128(1*ONE_USDC)], U128(300*ONE_LPT)),
        deposit = 1 
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E68: slippage error"));
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply);

    // user2 remove by share
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1100*ONE_LPT-502598491280079770545);
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 799699997426210330025);
    let out_come = call!(
        user2,
        pool.remove_liquidity(0, U128(300*ONE_LPT), vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)]),
        deposit = 1 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1100*ONE_LPT-502598491280079770545);
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 499699997426210330025);
    assert_eq!(pool_share_price(&pool, 0), last_share_price);
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply-300*ONE_LPT);
    let last_lpt_supply = last_lpt_supply - 300*ONE_LPT;
    
    // user2 remove by tokens
    let out_come = call!(
        user2,
        pool.remove_liquidity_by_tokens(0, vec![U128(498*ONE_DAI), U128(0*ONE_USDT), U128(0*ONE_USDC)], U128(499*ONE_LPT)),
        deposit = 1 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user1.account_id()), 1100*ONE_LPT-502598491280079770545);
    // previous lpt - removed lpt
    assert_eq!(mft_balance_of(&pool, ":0", &user2.account_id()), 499699997426210330025-498596260777261245961);
    // last_lpt_supply - removed lpt + admin_fee_to_lpt
    let last_lpt_supply = last_lpt_supply - 498596260777261245961 + 95600058313712936;
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply);
    assert!(pool_share_price(&pool, 0) > last_share_price);
    let last_share_price = pool_share_price(&pool, 0);
    println!("share_price: {}", last_share_price);

    // add massive liquidity (100 billion)
    let user3 = root.create_user("user3".to_string(), to_yocto("100"));
    mint_and_deposit_token(&user3, &tokens[0], &pool, 100_000_000_000*ONE_DAI);
    mint_and_deposit_token(&user3, &tokens[1], &pool, 100_000_000_000*ONE_USDT);
    mint_and_deposit_token(&user3, &tokens[2], &pool, 100_000_000_000*ONE_USDC);
    let out_come = call!(
        user3,
        pool.add_stable_liquidity(0, vec![U128(100_000_000_000*ONE_DAI), U128(100_000_000_000*ONE_USDT), U128(100_000_000_000*ONE_USDC)], U128(1)),
        deposit = to_yocto("0.0007") 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    // minted_user_lpt
    assert_eq!(mft_balance_of(&pool, ":0", &user3.account_id()), 299997852137498188726149828936);
    // last_lpt_supply + minted_user_lpt + admin_fee_to_lpt
    let last_lpt_supply = last_lpt_supply + 299997852137498188726149828936 + 143329282015797902428349;
    assert_eq!(mft_total_supply(&pool, ":0"), last_lpt_supply);
    let last_share_price = pool_share_price(&pool, 0);
    println!("share_price: {}", last_share_price);
}

#[test]
fn sim_stable_max_liquidity() {
    let (root, _owner, pool, tokens) = 
        setup_stable_pool_with_liquidity(
            vec![dai(), usdt(), usdc(), 
                "dai1".to_string(), "usdt1".to_string(), "usdc1".to_string(), 
                "dai2".to_string(), "usdt2".to_string(), "usdc2".to_string(),
                ],
            vec![
                100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC, 
                100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC, 
                100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC
            ],
            vec![18, 6, 6, 18, 6, 6, 18, 6, 6],
            25,
            10000,
        );
    let tokens = &tokens;

    // add massive liquidity (100 billion)
    let user = root.create_user("user".to_string(), to_yocto("100"));
    mint_and_deposit_token(&user, &tokens[0], &pool, 100_000_000_000*ONE_DAI);
    mint_and_deposit_token(&user, &tokens[1], &pool, 100_000_000_000*ONE_USDT);
    mint_and_deposit_token(&user, &tokens[2], &pool, 100_000_000_000*ONE_USDC);
    mint_and_deposit_token(&user, &tokens[3], &pool, 100_000_000_000*ONE_DAI);
    mint_and_deposit_token(&user, &tokens[4], &pool, 100_000_000_000*ONE_USDT);
    mint_and_deposit_token(&user, &tokens[5], &pool, 100_000_000_000*ONE_USDC);
    mint_and_deposit_token(&user, &tokens[6], &pool, 100_000_000_000*ONE_DAI);
    mint_and_deposit_token(&user, &tokens[7], &pool, 100_000_000_000*ONE_USDT);
    mint_and_deposit_token(&user, &tokens[8], &pool, 100_000_000_000*ONE_USDC);
    let out_come = call!(
        user,
        pool.add_stable_liquidity(0, vec![
            U128(100_000_000_000*ONE_DAI), U128(100_000_000_000*ONE_USDT), U128(100_000_000_000*ONE_USDC),
            U128(100_000_000_000*ONE_DAI), U128(100_000_000_000*ONE_USDT), U128(100_000_000_000*ONE_USDC),
            U128(100_000_000_000*ONE_DAI), U128(100_000_000_000*ONE_USDT), U128(100_000_000_000*ONE_USDC)
            ], U128(1)),
        deposit = to_yocto("0.0007") 
    );
    out_come.assert_success();
    println!("{:#?}", get_logs(&out_come));
    assert_eq!(mft_balance_of(&pool, ":0", &user.account_id()), 900000000000000000000000000000);
    assert_eq!(mft_total_supply(&pool, ":0"), 900000900000000000000000000000);
    let last_share_price = pool_share_price(&pool, 0);
    println!("share_price: {}", last_share_price);
}

'''
'''--- ref-exchange/tests/test_storage.rs ---
/// The storage in REF consists of inner-account storage (A storage) and LP-token storage (T storage).
/// For A storage:
///   Basic cost is 0.00102 Near (102 bytes),
///   Each token cost is 0.00148 Near (148 bytes),
///   Following actions will examine A storage:
///     ft::ft_transfer_call to deposit token into,
///     [withdraw], [register_tokens], [unregister_tokens],
/// For T storage:
///   Each pool has its own LP token, 
///   Each lp as a token holder would do storage_register, in REF, that is,
///     lp can call explicitly [mft_register], suggested deposit amount is 0.005, unused part would refund,
///     lp can call [add_liquidity], suggested deposit amount is 0.005, unused part would refund,
///   The contract self would be registered by pool creator 
///     when [add_simple_pool] and [add_stable_swap_pool], 
///     suggested deposit amount is 0.01, unused part would refund
use near_sdk::json_types::{U128};
use near_sdk_sim::{call, to_yocto};

use ref_exchange::SwapAction;
use crate::common::utils::*;
pub mod common;

const ONE_LPT: u128 = 1000000000000000000;
const ONE_DAI: u128 = 1000000000000000000;
const ONE_USDT: u128 = 1000000;
const ONE_USDC: u128 = 1000000;

#[test]
fn storage_scenario_01() {
    let (root, _, pool, token1, _, _) = setup_pool_with_liquidity();
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));

    println!("Storage Case 0101: withdraw MAX using None");
    call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    let sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(sb.total.0, to_yocto("1"));
    assert_eq!(sb.total.0 - sb.available.0, to_yocto("0.00102"));
    let orig_user_balance = new_user.account().unwrap().amount;

    // withdraw as much storage near as he can
    let out_come = call!(
        new_user,
        pool.storage_withdraw(None),
        deposit = 1
    );
    out_come.assert_success();

    let sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(sb.total.0, to_yocto("0.00102"));
    assert_eq!(sb.available.0, to_yocto("0"));
    // println!("{}", new_user.account().unwrap().amount - orig_user_balance);
    assert!(
        new_user.account().unwrap().amount - orig_user_balance > 
        to_yocto("0.998")
    );

    println!("Storage Case 0102: deposit token would fail with insufficient storage deposit");
    call!(
        new_user,
        token1.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();
    let out_come = call!(
        new_user,
        token1.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));

    println!("Storage Case 0103: deposit token would success with enough storage deposit");
    call!(
        new_user,
        pool.storage_deposit(None, Some(false)),
        deposit = to_yocto("1")
    )
    .assert_success();
    let out_come = call!(
        new_user,
        token1.ft_transfer_call(to_va(swap()), to_yocto("5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    assert_eq!(out_come.promise_errors().len(), 0);

    println!("Storage Case 0104: storage withdraw more than available");
    let prev_sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    let orig_user_balance = new_user.account().unwrap().amount;
    // println!("{:#?}", prev_sb);

    let out_come = call!(
        new_user,
        pool.storage_withdraw(Some(U128(to_yocto("1")))),
        deposit = 1
    );
    assert!(!out_come.is_ok());

    let sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(sb.total.0, prev_sb.total.0);
    assert_eq!(sb.available.0, prev_sb.available.0);
    assert!(new_user.account().unwrap().amount < orig_user_balance);

    println!("Storage Case 0105: storage withdraw specific amount");
    let prev_sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    let orig_user_balance = new_user.account().unwrap().amount;

    let out_come = call!(
        new_user,
        pool.storage_withdraw(Some(U128(to_yocto("0.5")))),
        deposit = 1
    );
    out_come.assert_success();

    let sb = get_storage_balance(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(sb.total.0, prev_sb.total.0 - to_yocto("0.5"));
    assert_eq!(sb.available.0, prev_sb.available.0 - to_yocto("0.5"));
    assert!(new_user.account().unwrap().amount - orig_user_balance > to_yocto("0.499"));

}

#[test]
fn storage_scenario_02() {
    let (root, _owner, pool, tokens) = 
        setup_stable_pool_with_liquidity(
            vec![dai(), usdt(), usdc()],
            vec![100000*ONE_DAI, 100000*ONE_USDT, 100000*ONE_USDC],
            vec![18, 6, 6],
            25,
            10000,
        );
    let tokens = &tokens;

    // prepare a new user with 3 tokens storage 102 + 3 * 148 = 102 + 444 = 546
    let new_user = root.create_user("new_user1".to_string(), to_yocto("100"));
    mint_and_deposit_token(&new_user, &tokens[0], &pool, 500*ONE_DAI);
    mint_and_deposit_token(&new_user, &tokens[1], &pool, 500*ONE_USDT);
    mint_and_deposit_token(&new_user, &tokens[2], &pool, 500*ONE_USDC);
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    // appending balanced liquidity with basic lp register storage fee
    println!("Storage Case 0201: appending balanced liquidity need deposit storage");
    call!(
        new_user,
        pool.add_stable_liquidity(0, vec![U128(10*ONE_DAI), U128(10*ONE_USDT), U128(10*ONE_USDC)], U128(1)),
        deposit = to_yocto("0.00074")
    )
    .assert_success();
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    // appending imba liquidity with extra storage fee for exchange share
    println!("Storage Case 0202: appending imba liquidity need deposit storage");
    let out_come = call!(
        new_user,
        pool.add_stable_liquidity(0, vec![U128(5*ONE_DAI), U128(10*ONE_USDT), U128(15*ONE_USDC)], U128(1)),
        deposit = to_yocto("0.00074")
    );
    out_come.assert_success();
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    // remove liquidity by share
    println!("Storage Case 0203: remove liquidity by share");
    let out_come = call!(
        new_user,
        pool.remove_liquidity(0, U128(10*ONE_LPT), vec![U128(3*ONE_DAI), U128(3*ONE_USDT), U128(3*ONE_USDC)]),
        deposit = 1
    );
    out_come.assert_success();
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    // remove liquidity by token
    println!("Storage Case 0204: remove liquidity by token");
    let out_come = call!(
        new_user,
        pool.remove_liquidity_by_tokens(0, vec![U128(10*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)], U128(13*ONE_LPT)),
        deposit = 1
    );
    out_come.assert_success();
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    // swap 
    println!("Storage Case 0205: swap would fail if storage insufficient");
    let out_come = call!(
        new_user,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdc(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", get_logs(&out_come));
    let ss = get_storage_state(&pool, new_user.valid_account_id()).unwrap();
    assert_eq!(ss.usage.0, to_yocto("0.00546"));

    let user2 = root.create_user("user2".to_string(), to_yocto("100"));
    mint_and_deposit_token(&user2, &tokens[0], &pool, 500*ONE_DAI);

    let out_come = call!(
        user2,
        pool.storage_withdraw(None),
        deposit = 1
    );
    out_come.assert_success();

    let ss = get_storage_state(&pool, user2.valid_account_id()).unwrap();
    assert_eq!(ss.deposit.0, to_yocto("0.00250"));
    assert_eq!(ss.usage.0, to_yocto("0.00250"));

    let out_come = call!(
        user2,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdc(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("{}", ex_status);
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));

    call!(
        user2,
        pool.storage_deposit(None, Some(false)),
        deposit = to_yocto("0.00148")
    )
    .assert_success();
    let ss = get_storage_state(&pool, user2.valid_account_id()).unwrap();
    assert_eq!(ss.deposit.0, to_yocto("0.00398"));
    assert_eq!(ss.usage.0, to_yocto("0.00250"));

    let out_come = call!(
        user2,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(ONE_DAI)),
                token_out: usdc(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    );
    out_come.assert_success();
    let ss = get_storage_state(&pool, user2.valid_account_id()).unwrap();
    assert_eq!(ss.deposit.0, to_yocto("0.00398"));
    assert_eq!(ss.usage.0, to_yocto("0.00398"));

    println!("Storage Case 0206: transfer lp would fail if receiver not registered");
    let user3 = root.create_user("user3".to_string(), to_yocto("100"));
    let out_come = call!(
        new_user,
        pool.mft_transfer(":0".to_string(), user3.valid_account_id(), U128(5*ONE_LPT), None),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E13: LP not registered"));
    
    println!("Storage Case 0207: remove liquidity would fail if not enough storage for received token");
    let out_come = call!(
        new_user,
        pool.mft_register(":0".to_string(), user3.valid_account_id()),
        deposit = to_yocto("0.00074")
    );
    out_come.assert_success();
    let out_come = call!(
        new_user,
        pool.mft_transfer(":0".to_string(), user3.valid_account_id(), U128(5*ONE_LPT), None),
        deposit = 1
    );
    out_come.assert_success();
    let out_come = call!(
        user3,
        pool.remove_liquidity(0, U128(5*ONE_LPT), vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)]),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
    assert!(get_storage_state(&pool, user3.valid_account_id()).is_none());

    call!(
        user3,
        pool.storage_deposit(None, None),
        deposit = to_yocto("0.00546")
    )
    .assert_success();

    let out_come = call!(
        user3,
        pool.remove_liquidity(0, U128(5*ONE_LPT), vec![U128(1*ONE_DAI), U128(1*ONE_USDT), U128(1*ONE_USDC)]),
        deposit = 1
    );
    out_come.assert_success();
    let ss = get_storage_state(&pool, user3.valid_account_id()).unwrap();
    assert_eq!(ss.deposit.0, to_yocto("0.00546"));
    assert_eq!(ss.usage.0, to_yocto("0.00546"));
}

'''
'''--- ref-exchange/tests/test_swap.rs ---
use std::collections::HashMap;
use std::convert::TryFrom;

use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::AccountId;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
};

use ref_exchange::{ContractContract as Exchange, PoolInfo, SwapAction};
use test_token::ContractContract as TestToken;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TEST_TOKEN_WASM_BYTES => "../res/test_token.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
}

pub fn should_fail(r: ExecutionResult) {
    println!("{:?}", r.status());
    match r.status() {
        ExecutionStatus::Failure(_) => {}
        _ => panic!("Should fail"),
    }
}

pub fn show_promises(r: ExecutionResult) {
    for promise in r.promise_results() {
        println!("{:?}", promise);
    }
}

fn test_token(
    root: &UserAccount,
    token_id: AccountId,
    accounts_to_register: Vec<AccountId>,
) -> ContractAccount<TestToken> {
    let t = deploy!(
        contract: TestToken,
        contract_id: token_id,
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root
    );
    call!(root, t.new()).assert_success();
    call!(
        root,
        t.mint(to_va(root.account_id.clone()), to_yocto("1000").into())
    )
    .assert_success();
    for account_id in accounts_to_register {
        call!(
            root,
            t.storage_deposit(Some(to_va(account_id)), None),
            deposit = to_yocto("1")
        )
        .assert_success();
    }
    t
}

fn balance_of(token: &ContractAccount<TestToken>, account_id: &AccountId) -> u128 {
    view!(token.ft_balance_of(to_va(account_id.clone())))
        .unwrap_json::<U128>()
        .0
}

fn mft_balance_of(
    pool: &ContractAccount<Exchange>,
    token_or_pool: &str,
    account_id: &AccountId,
) -> u128 {
    view!(pool.mft_balance_of(token_or_pool.to_string(), to_va(account_id.clone())))
        .unwrap_json::<U128>()
        .0
}

fn dai() -> AccountId {
    "dai".to_string()
}

fn eth() -> AccountId {
    "eth".to_string()
}

fn swap() -> AccountId {
    "swap".to_string()
}

fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

fn setup_pool_with_liquidity() -> (
    UserAccount,
    UserAccount,
    ContractAccount<Exchange>,
    ContractAccount<TestToken>,
    ContractAccount<TestToken>,
) {
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va("owner".to_string()), 4, 1)
    );
    let token1 = test_token(&root, dai(), vec![swap()]);
    let token2 = test_token(&root, eth(), vec![swap()]);
    call!(
        owner,
        pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth())])
    );
    call!(
        root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        owner,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        root,
        token1.ft_transfer_call(to_va(swap()), to_yocto("105").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        token2.ft_transfer_call(to_va(swap()), to_yocto("110").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        pool.add_liquidity(0, vec![U128(to_yocto("5")), U128(to_yocto("10"))], None),
        deposit = to_yocto("0.0007")
    )
    .assert_success();
    (root, owner, pool, token1, token2)
}

#[test]
fn test_swap() {
    let (root, _owner, pool, token1, token2) = setup_pool_with_liquidity();
    assert_eq!(
        view!(pool.get_pool(0)).unwrap_json::<PoolInfo>(),
        PoolInfo {
            pool_kind: "SIMPLE_POOL".to_string(),
            amp: 0,
            token_account_ids: vec![dai(), eth()],
            amounts: vec![to_yocto("5").into(), to_yocto("10").into()],
            total_fee: 25,
            shares_total_supply: to_yocto("1").into(),
        }
    );
    assert_eq!(
        view!(pool.mft_metadata(":0".to_string()))
            .unwrap_json::<FungibleTokenMetadata>()
            .name,
        "ref-pool-0"
    );
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), to_va(root.account_id.clone())))
            .unwrap_json::<U128>()
            .0,
        to_yocto("1")
    );
    let balances = view!(pool.get_deposits(to_va(root.account_id.clone())))
        .unwrap_json::<HashMap<AccountId, U128>>();
    let balances = balances.values().cloned().collect::<Vec<_>>();
    assert_eq!(balances, vec![U128(to_yocto("100")), U128(to_yocto("100"))]);

    call!(
        root,
        pool.swap(
            vec![SwapAction {
                pool_id: 0,
                token_in: dai(),
                amount_in: Some(U128(to_yocto("1"))),
                token_out: eth(),
                min_amount_out: U128(1)
            }],
            None
        ),
        deposit = 1
    )
    .assert_success();

    let balances = view!(pool.get_deposits(to_va(root.account_id.clone())))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(
        balances.get(&eth()).unwrap(),
        &U128(to_yocto("100") + 1663192997082117548978741)
    );
    assert_eq!(balances.get(&dai()).unwrap(), &U128(to_yocto("99")));

    call!(
        root,
        pool.withdraw(to_va(eth()), U128(to_yocto("101")), None),
        deposit = 1
    );
    call!(
        root,
        pool.withdraw(to_va(dai()), U128(to_yocto("99")), None),
        deposit = 1
    );

    let balance1 = view!(token1.ft_balance_of(to_va(root.account_id.clone())))
        .unwrap_json::<U128>()
        .0;
    assert_eq!(balance1, to_yocto("994"));
    let balance2 = view!(token2.ft_balance_of(to_va(root.account_id.clone())))
        .unwrap_json::<U128>()
        .0;
    assert_eq!(balance2, to_yocto("991"));
}

#[test]
fn test_withdraw_failure() {
    let root = init_simulator(None);
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    // Deploy exchange contract and call init method setting owner to "owner"
    let pool = deploy!(
        contract: Exchange,
        contract_id: swap(),
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va("owner".to_string()), 4, 1)
    );
    // Deploy DAI and wETH fungible tokens
    let dai_contract = test_token(&root, dai(), vec![swap()]);
    let weth_contract = test_token(&root, eth(), vec![swap()]);
    // Add DAI and ETH to token whitelist
    call!(
        owner,
        pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth())])
    );
    call!(
        root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();

    // Deposit 1 NEAR storage balance for root account
    call!(
        root,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();

    call!(
        root,
        dai_contract.ft_transfer_call(to_va(swap()), to_yocto("105").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        root,
        weth_contract.ft_transfer_call(to_va(swap()), to_yocto("110").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();

    // Check exchange balance before user unregisters from fungible token
    let balances_before = view!(pool.get_deposits(to_va(root.account_id.clone())))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(
        balances_before.get(&dai()).unwrap(),
        &to_yocto("105").into()
    );

    // See how much root account has on each fungible token
    let mut dai_amount: U128 =
        view!(dai_contract.ft_balance_of(to_va("root".to_string()))).unwrap_json();
    assert_eq!(dai_amount, to_yocto("895").into());

    // User (perhaps accidentally) unregisters account from fungible token.
    call!(
        root,
        dai_contract.storage_unregister(Some(true)),
        deposit = 1
    )
    .assert_success();

    // Now DAI balance for root is now 0, with no storage either
    dai_amount = view!(dai_contract.ft_balance_of(to_va("root".to_string()))).unwrap_json();
    assert_eq!(dai_amount, U128(0));

    // Root tries to withdraw and the transfer fails
    let withdrawal_result = call!(
        root,
        pool.withdraw(to_va(dai()), to_yocto("30").into(), None),
        deposit = 1
    );

    let promise_errors = withdrawal_result.promise_errors();
    assert_eq!(promise_errors.clone().len(), 1, "Expected 1 failed promise when withdrawing to a fungible token to an unregistered account.");
    let promise_failure_opt = promise_errors.get(0).unwrap();

    let promise_failure = promise_failure_opt.as_ref().unwrap();

    if let ExecutionStatus::Failure(err) = promise_failure.status() {
        // At this time, this is the way to check for error messages.
        // This error comes from the fungible token contract.
        assert_eq!(
            err.to_string(),
            "Action #0: Smart contract panicked: The account root is not registered"
        );
    } else {
        panic!("Expected failure when withdrawing to unregistered account.");
    }

    // Check the exchange balances after this failure and ensure it's the same.
    let balances_after = view!(pool.get_deposits(to_va(root.account_id.clone())))
        .unwrap_json::<HashMap<AccountId, U128>>();
    assert_eq!(balances_after.get(&dai()).unwrap(), &to_yocto("105").into());
}

fn direct_swap(user: &UserAccount, contract: &ContractAccount<TestToken>) {
    call!(
        user,
        contract.ft_transfer_call(
            to_va(swap()),
            to_yocto("1").into(),
            None,
            format!("{{\"actions\": [{{\"pool_id\": 0, \"token_in\": \"dai\", \"token_out\": \"eth\", \"min_amount_out\": \"1\"}}]}}")
        ),
        deposit = 1
    ).assert_success();
}

/// Test swap without deposit/withdraw.
#[test]
fn test_direct_swap() {
    let (root, owner, pool, token1, token2) = setup_pool_with_liquidity();
    let new_user = root.create_user("new_user".to_string(), to_yocto("100"));
    call!(
        new_user,
        token1.mint(to_va(new_user.account_id.clone()), U128(to_yocto("10")))
    )
    .assert_success();

    // Test wrong format and that it returns all tokens back.
    call!(
        new_user,
        token1.ft_transfer_call(to_va(swap()), to_yocto("10").into(), None, "{}".to_string()),
        deposit = 1
    )
    .assert_success();
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("10"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("0"));

    // Test that token2 account doesn't exist, the balance of token1 is taken, owner received token2.
    direct_swap(&new_user, &token1);
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("9"));
    assert_eq!(balance_of(&token2, &new_user.account_id), to_yocto("0"));
    assert!(mft_balance_of(&pool, &token2.account_id(), &owner.account_id) > to_yocto("1"));

    // Test that token2 account exists, everything works.
    call!(
        new_user,
        token2.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    direct_swap(&new_user, &token1);
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("8"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("1"));

    // Test that account in pool and token2 account exist, everything works.
    call!(
        new_user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    direct_swap(&new_user, &token1);
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("7"));
    assert!(balance_of(&token2, &new_user.account_id) > to_yocto("2"));

    // Test that account in pool exists but token2 account doesn't exist, final balance is in the pool.
    call!(new_user, token2.storage_unregister(Some(true)), deposit = 1).assert_success();
    direct_swap(&new_user, &token1);
    assert_eq!(balance_of(&token1, &new_user.account_id), to_yocto("6"));
    assert_eq!(balance_of(&token2, &new_user.account_id), 0);
    assert!(mft_balance_of(&pool, &token2.account_id(), &new_user.account_id) > to_yocto("0.5"));
}

'''
'''--- ref-farming/Cargo.toml ---
[package]
name = "ref_farming"
version = "1.0.2"
authors = ["Marco Sun <sun.dsk1@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint = { version = "0.9.0", default-features = false }
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"
test-token = { path = "../test-token" }
ref-exchange = { path = "../ref-exchange" }
rand = "0.8"
rand_pcg = "0.3"
'''
'''--- ref-farming/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_ref_farming"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/ref-farming \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2020-10-08;rustup default stable-2020-10-08;rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/../target/wasm32-unknown-unknown/release/ref_farming.wasm $DIR/../res/ref_farming_release.wasm

'''
'''--- ref-farming/build_local.sh ---
#!/bin/bash
set -e
rustup target add wasm32-unknown-unknown
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
# RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/ref_farming.wasm ./res/ref_farming_local.wasm

'''
'''--- ref-farming/how_does_it_work.md ---
# ref-farming

## Terminology

|word|meaning|notes|
|-|-|-|
|Farm|A place to farming on|A farm has one seed and one reward|
|Seed|Farming-Token|User stakes seed to this contract to gain various reward token from all running farms using this seed|
|Reward|Reward-Token|A standard NEP-141 token that deposited to some farm as reward to farmers|
|SeedId|String|Token contract_id for ft token, token contract_id + "@" + inner_id for mft token|
|FarmId|String|SeedId + "#" + farm_index in that seed|
|RPS|Reward-Per-Seed|The key concept to distribute rewards between farmers in a farm, see next chapter for details|
|RR|Reward Round in num|The rewards are released by round, and round starts from 1, see next chapter for details|

## features
* Multi-farming, staking one seed token can gain multiple rewards on multiple farm;
* Farm creation is free and open;
* Both FT and multi-FT are supported as seed;

## Logic

### Basic Concept
**Farmer** deposit/stake **Seed** token to farming on all **farms** that accept that seed, and gains **reward** token back.   

different farm can (not must) has different reward token.  

### Farm Creation
To create a farm, we should settle five params:
* seed, which seed token this farm accepts;
* reward, which reward token this farm gives;
* when to start, in block height, if 0 is given, then imediately starts when reward token deposits in;
* round interval, each round lasts in block counts;  
* total reward per round;

And then transfer reward token into the farm using ft_transfer_call interface to bring farm_id information in.

### Reward Distribution
Every running farm would release reward per reward round. Those released reward would exist in a form of `user_unclaimed_reward` for each user.  

User has to explicit invoke `claim` action to fetch those reward into his inner account, and invoke `withdraw` to get those assets in inner account into his own near account. Although there are two txs here, the frontend could combine those actions to make it look like a one stop action.

Deep into reward distribution, it is caculated independently among farms and according to this logic:  

`user_unclaimed_reward = user_staked_seed * [RPS(farm) - RPS(user)]`  
where,   
`RPS(farm) = prev_RPS(farm) + to_be_distribute_reward / total_staked_seed`  
and,  
`RPS(user) = RPS(farm)` after user claims reward each time.

To figure out how many reward are waiting for distribution, we use RR to record the last distribution time. Then it turns to:  
`to_be_distribute_reward = reward_per_round * [RR(current) - RR(last)]`

the RR, RPS(farm) and RPS(user) will be updated after following actions are invoked:
* user claim reward;
* user stake seed (imbed a user claim process);
* user unstake seed(imbed a user claim process);

Note: to get detailed implement of that distribution logic, please refer to the contract readme.

### Farm status

* Created, A farm that has been created but either no reward token is deposited in or start time is not reached;
* Running, A farm that is in working and release reward per round;
* Ended, A farm with all reward has been distributed (user may still have unclaimed reward);
* Cleared, A farm that has ended and no unclaimed reward, can be removed from the contract. After removal, this farm is in this Cleared status. (You can never get this status from contract);

### Storage Management
Each user would have a place to store his reward tokens balance, staked seed tokens balance, and last time RPS for each farm he involves. So, user storage management is needed.

Although the frontend would take care all of the storage details for users, it is still not bad to understand the core logic behind, especially there is kind of post-pay style exists in our storage management.  

Almost all NEAR contract require a pre-pay style to deal wtih the user storage cost. In that style, users do `storage_register` and deposit a fixed storage fee before invoking any business interfaces.

But take our logic model into consideration, the pre-pay style couldn't have a 100 percent fit. Cause the user storage size would expand even shrink during farming. More involved farms more user storage needs, and even worse, farm management beyonds users scope. User couldn't know exactly how many storage he would need in advance. 

So, we combine traditional storage strategy with kind of pre-pay amendment. When user does his first `storage_register`, we requrie him to deposit a storage fee that can support 5 reward tokens, 5 seed tokens and 10 farms. And then, with the running of farming, if at some point the storage fee exceeds, we keep the farming going but disable user's critical calls, such as stake/un-stake seed, claim rewards. In those critical calls, we would notify user with `insufficient storage` msg through panic, In that case, user then need to add more storage fee through the same `storage_register` interface with `only_register` param set to `false`.  

Complex eh? But no worry, as we said above, the frontend would take care all of this for you.
'''
'''--- ref-farming/readme.md ---
# ref-farming

## Interface Structure

```rust
/// metadata and the  whole statistics of the contract
pub struct Metadata {
    pub version: String,
    pub owner_id: AccountId,
    pub farmer_count: U64,
    pub farm_count: U64,
    pub seed_count: U64,
    pub reward_count: U64,
}

/// seed info
pub struct SeedInfo {
    pub seed_id: SeedId,
    pub seed_type: String, // FT, MFT
    pub farms: Vec<FarmId>,
    pub next_index: u32,
    pub amount: U128,
    pub min_deposit: U128,
}

/// used to create a farm
pub struct HRSimpleFarmTerms {
    pub seed_id: SeedId,
    pub reward_token: ValidAccountId,
    pub start_at: U64,
    pub reward_per_session: U128,
    pub session_interval: U64, 
}

/// Farm Status
pub struct FarmInfo {
    pub farm_id: FarmId,
    pub farm_kind: String,
    pub farm_status: String,  // Created, Running, Ended
    pub seed_id: SeedId,
    pub reward_token: AccountId,
    pub start_at: U64,
    pub reward_per_session: U128,
    pub session_interval: U64, 
    // total_reward = distributed + undistributed
    // distributed = claimed + unclaimed
    pub total_reward: U128,
    pub cur_round: U64,
    pub last_round: U64,
    pub claimed_reward: U128,
    pub unclaimed_reward: U128,
}

```

## Interface methods

***view functions***  
```rust

/// whole contract
pub fn get_metadata(&self) -> Metadata;

//***********************************
//************* about Farms *********
//***********************************

/// total number of farms.
pub fn get_number_of_farms(&self) -> u64;

/// batch get farm info by seed;
/// Cause farms are organized under Seed(ie. Farming-Token) in the contract
pub fn list_farms_by_seed(&self, seed_id: SeedId) -> Vec<FarmInfo>;

/// Get single farm's status
pub fn get_farm(&self, farm_id: FarmId) -> Option<FarmInfo>;

//***********************************
//*********** about Rewards *********
//***********************************

/// get all rewards and its supply
pub fn list_rewards_info(&self, from_index: u64, limit: u64) -> HashMap<AccountId, U128>;

/// claimed rewards of given user
pub fn list_rewards(&self, account_id: ValidAccountId) -> HashMap<AccountId, U128>;

/// claimed reward of given user and given reward token.
pub fn get_reward(&self, account_id: ValidAccountId, token_id: ValidAccountId) -> U128;

/// unclaimed reward of given user and given farm
pub fn get_unclaimed_reward(&self, account_id: ValidAccountId, farm_id: FarmId) -> U128;

//***********************************
//*********** about Seeds ***********
//***********************************

/// all staked seeds and its info
pub fn get_seed_info(&self, seed_id: SeedId) -> Option<SeedInfo>;

/// all staked seeds of given user
pub fn list_seeds_info(&self, from_index: u64, limit: u64) -> HashMap<SeedId, SeedInfo>;

```

***Storage functions***  
User of farming contract should register first and keep their storage fee valid.  
```rust

/// total can bigger than available, which means farmer owes storage fee, 
/// and before he storage_deposit more fee, all changeable method invoke 
/// would fail with ERR11_INSUFFICIENT_STORAGE
pub struct StorageBalance {
    pub total: U128, // here we redefine total to locked amount for storage fee.
    pub available: U128,  // here we redefine it to the user pre-deposited to cover the fee.
}

/// Only farmer need to register for storage, 
/// the attached should more than a suggested minimum storage fee, 
/// which can cover storage fee for 5 seeds, 5 rewards and 10 farms, 
/// registration_only true means to refund exceeded amount back to user. 
/// Farmer also use this method to add storage fee, with registration_only set to false.
#[payable]
fn storage_deposit(&mut self, account_id: 
    Option<ValidAccountId>, 
    registration_only: Option<bool>,
) -> StorageBalance;

/// Withdraw unlocked amount of storage fee
#[payable]
fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

/// to completely quit from this contract, 
/// should unstake all seeds and withdraw all rewards before call this one
fn storage_unregister(&mut self, force: Option<bool>) -> bool;

/// get current storage fee info
fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
```

***Manage farms***  
```rust
/// FarmId is like this:
let farm_id: FarmId = format!("{}#{}", seed_id, index);

/// create farm and pay for its storage fee
/// terms defines farm rules in type of HRSimpleFarmTerms,
/// min_deposit will set the minimum stake balance of seed token 
/// if this farm is the first farm in that seed, and 
/// if None is given, the default MIN_SEED_DEPOSIT will be used, 
/// that is 10**24.
#[payable]
pub fn create_simple_farm(&mut self, terms: HRSimpleFarmTerms, min_deposit: Option<U128>) -> FarmId;
```

***Manage seeds***  
```rust
/// SeedId is like this:
/// receiver_id@pool_id for MFT
/// receiver_id for FT

/// stake action is invoked outside this contract, 
/// actually by MFT's mft_on_transfer or FT's ft_on_transfer, 
/// with msg field left to empty string.

/// unstake, with amount is 0, means to unstake all.
#[payable]
pub fn withdraw_seed(&mut self, seed_id: SeedId, amount: U128);
```

***Manage rewards***  
```rust
/// claim reward from single farm
#[payable]
pub fn claim_reward_by_farm(&mut self, farm_id: FarmId);

/// batch claim from farms with same seeds
#[payable]
pub fn claim_reward_by_seed(&mut self, seed_id: SeedId);

/// All claimed rewards goes to farmer's inner account in this contract,
/// So, farmer can withdraw given reward token back to his own account.
#[payable]
pub fn withdraw_reward(&mut self, token_id: ValidAccountId, amount: Option<U128>);
```

***Owner methods***  
```rust
pub fn set_owner(&mut self, owner_id: ValidAccountId);

/// those farm with Ended status and zero unclaimed reward, 
/// can be cleaned to save storage.
pub fn clean_farm_by_seed(&mut self, seed_id: String);

/// owner can modify min_deposit of given seed.
pub fn modify_seed_min_deposit(&mut self, seed_id: String, min_deposit: Balance);

/// upgrade the contract
pub fn upgrade(
        &self,
        #[serializer(borsh)] code: Vec<u8>,
        #[serializer(borsh)] migrate: bool,
    ) -> Promise;
```

## contract core structure

```rust
pub struct Contract {

    // owner of this contract
    owner_id: AccountId,
    
    // record seeds and the farms under it.
    seeds: UnorderedMap::<SeedId, FarmSeed>,

    // each farmer has a structure to describe
    farmers: LookupMap<AccountId, Farmer>,

    // for statistic
    farmer_count: u64,
    farm_count: u64,
    reward_info: UnorderedMap::<AccountId, Balance>,
}

/// used to store U256 in contract storage
pub type RPS = [u8; 32];

pub struct Farmer {
    /// Native NEAR amount sent to this contract.
    /// Used for storage.
    pub amount: Balance,
    /// Amounts of various reward tokens the farmer claimed.
    pub rewards: HashMap<AccountId, Balance>,
    /// Amounts of various seed tokens the farmer staked.
    pub seeds: HashMap<SeedId, Balance>,
    /// record user_last_rps of farms
    pub farm_rps: HashMap<FarmId, RPS>,
}

pub struct FarmSeed {
    /// The Farming Token this FarmSeed represented for
    pub seed_id: SeedId,
    /// The seed is a FT or MFT
    pub seed_type: SeedType,
    /// all farms that accepted this seed
    /// may change to HashMap<GlobalIndex, Farm> 
    /// to enable whole life-circle (especially for removing of farm). 
    pub farms: Vec<Farm>,
    /// total (staked) balance of this seed (Farming Token)
    pub amount: Balance,
}
```
### Reward distribution implementation
Each simple farm has a terms `SimpleFarmTerms` to define how to distribute reward,  
And a Status `SimpleFarmStatus` to mark the life-circle,  
And the key last-distribution record - `SimpleFarmRewardDistribution`.  
```rust
pub struct SimpleFarmTerms {
    pub seed_id: SeedId,
    pub reward_token: AccountId,
    pub start_at: BlockHeight,
    pub reward_per_session: Balance,
    pub session_interval: BlockHeight,
}

pub enum SimpleFarmStatus {
    Created, Running, Ended, Cleared
}

pub struct SimpleFarmRewardDistribution {
    /// unreleased reward
    pub undistributed: Balance,
    /// the total rewards distributed but not yet claimed by farmers.
    pub unclaimed: Balance,
    /// Reward_Per_Seed
    /// rps(cur) = rps(prev) + distributing_reward / total_seed_staked
    pub rps: RPS,
    /// Reward_Round
    /// rr = (cur_block_height - start_at) / session_interval
    pub rr: u64,
}
```
Then, the whole farm is built as
```rust
pub struct SimpleFarm {

    pub farm_id: FarmId,
    
    pub terms: SimpleFarmTerms,

    pub status: SimpleFarmStatus,

    pub last_distribution: SimpleFarmRewardDistribution,

    /// total reward send into this farm by far, 
    /// every time reward deposited in, add to this field
    pub amount_of_reward: Balance,
    /// reward token has been claimed by farmer by far
    pub amount_of_claimed: Balance,

}
``` 

As designed that way, we can calculate farmers unclaimed reward like this:  

```rust
// 1. get current reward round CRR
let crr = (env::block_index() - self.terms.start_at) / self.terms.session_interval;
// 2. get reward to distribute this time
let reward_added = (crr - self.last_distribution.rr) as u128 * self.terms.reward_per_session;
// 3. get current RPS
let crps = self.last_distribution.rps + reward_added / total_seeds;
// 4. get user unclaimed by multiple user_staked_seed with rps diff.
let unclaimed_reward = user_staked_seed * (crps - user_last_rps);
```
This logic is sealed in 
```rust
pub(crate) fn view_farmer_unclaimed_reward(
        &self,
        user_rps: &RPS,
        user_seeds: &Balance,
        total_seeds: &Balance,
    ) -> Balance
```
which, based on 
```rust
pub(crate) fn try_distribute(&self, total_seeds: &Balance) -> Option<SimpleFarmRewardDistribution>
```
to calculate cur RPS and RR of the farm without modifying the storage (means not really update the farm)

And when farmer actually claims his reward, the whole logic is sealed in 
```rust
pub(crate) fn claim_user_reward(
        &mut self, 
        user_rps: &RPS,
        user_seeds: &Balance, 
        total_seeds: &Balance
    ) -> Option<(Balance, Balance)>
```
which, based on 
```rust
pub(crate) fn distribute(&mut self, total_seeds: &Balance)
```
to calculate and update the farm.

# Things need to explain
## Storage fee in this contract
As each farmer would have a place to record his rps in each farm he involved, the storage belongs to a farmer may increase out of his notice.  

For example, when a new farm established and running, which accepts the farmer's seed that has been staked in the contract, then at the following action such as claim_reward, or deposit/withdraw seeds invoked by the farmer, his storage would expand to record the new rps related to that farm.  

Consider that, and also to improve farmer's user-experience, we have a `suggested_min_storage_usage()` which covers 5 seed, 5 reward and 10 farms as one shot. When farmer register for the first time, we will force him to deposit more or equal to that amount, which is about 1,688 bytes, 0.0134 near. 
```rust
const MAX_ACCOUNT_LENGTH: u128 = 64;
const MIN_FARMER_LENGTH: u128 = MAX_ACCOUNT_LENGTH + 16 + 4 * 3;
/// Returns minimal storage usage possible.
/// 5 reward tokens, 5 seed tokens, 10 farms as assumption.
pub(crate) fn suggested_min_storage_usage() -> Balance {
    (
        MIN_FARMER_LENGTH 
        + 2_u128 * 5_u128 * (MAX_ACCOUNT_LENGTH + 16)
        + 10_u128 * (MAX_ACCOUNT_LENGTH + 32)
    ) * env::storage_byte_cost()
}
```
And when a farmer owes storage fee, then before he storage_deposit more fee,  
all changeable method would fail with ERR11_INSUFFICIENT_STORAGE.

'''
'''--- ref-farming/release_notes.md ---
# Release Notes

### Version 1.0.2
1. 80T gas for seed withdraw resolve, 10T gas for reward withdraw resolve;
2. add get_user_storage_state interface;

### Version 1.0.1
1. Increase estimate gas for resolve transfer to 20T;
'''
'''--- ref-farming/src/actions_of_farm.rs ---

use near_sdk::{env, near_bindgen, Promise};
use near_sdk::json_types::{U128};
use simple_farm::{SimpleFarm, HRSimpleFarmTerms};
use crate::utils::{gen_farm_id, MIN_SEED_DEPOSIT, parse_farm_id};
use crate::errors::*;
use crate::*;

#[near_bindgen]
impl Contract {
    /// create farm and pay for its storage fee
    #[payable]
    pub fn create_simple_farm(&mut self, terms: HRSimpleFarmTerms, min_deposit: Option<U128>) -> FarmId {

        self.assert_owner();
        
        let prev_storage = env::storage_usage();

        let min_deposit: u128 = min_deposit.unwrap_or(U128(MIN_SEED_DEPOSIT)).0;

        let farm_id = self.internal_add_farm(&terms, min_deposit);

        // Check how much storage cost and refund the left over back.
        let storage_needed = env::storage_usage() - prev_storage;
        let storage_cost = storage_needed as u128 * env::storage_byte_cost();
        assert!(
            storage_cost <= env::attached_deposit(),
            "{}: {}", ERR11_INSUFFICIENT_STORAGE, storage_needed
        );

        let refund = env::attached_deposit() - storage_cost;
        if refund > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }

        farm_id
    }
}

impl Contract {
    /// Adds given farm to the vec and returns it's id.
    /// If there is not enough attached balance to cover storage, fails.
    /// If too much attached - refunds it back.
    fn internal_add_farm(&mut self, terms: &HRSimpleFarmTerms, min_deposit: Balance) -> FarmId {
        
        // let mut farm_seed = self.get_seed_default(&terms.seed_id, min_deposit);
        let mut farm_seed: VersionedFarmSeed;
        if let Some(fs) = self.get_seed_wrapped(&terms.seed_id) {
            farm_seed = fs;
            env::log(
                format!(
                    "New farm created In seed {}, with existed min_deposit {}",
                    terms.seed_id, farm_seed.get_ref().min_deposit
                )
                .as_bytes(),
            );
        } else {
            farm_seed = VersionedFarmSeed::new(&terms.seed_id, min_deposit);
            env::log(
                format!(
                    "The first farm created In seed {}, with min_deposit {}",
                    terms.seed_id, farm_seed.get_ref().min_deposit
                )
                .as_bytes(),
            );
        }

        let farm_id: FarmId = gen_farm_id(&terms.seed_id, farm_seed.get_ref().next_index as usize);

        let farm = Farm::SimpleFarm(SimpleFarm::new(
            farm_id.clone(),
            terms.into(),
        ));
        
        farm_seed.get_ref_mut().farms.insert(farm_id.clone());
        farm_seed.get_ref_mut().next_index += 1;
        self.data_mut().seeds.insert(&terms.seed_id, &farm_seed);
        self.data_mut().farms.insert(&farm_id.clone(), &farm);
        farm_id
    }

    pub(crate) fn internal_remove_farm_by_farm_id(&mut self, farm_id: &FarmId) -> bool {
        let (seed_id, _) = parse_farm_id(farm_id);
        let mut removable = false;
        if let Some(mut farm_seed) = self.get_seed_wrapped(&seed_id) {
            let seed_amount = farm_seed.get_ref().amount;
            if let Some(farm) = self.data().farms.get(farm_id) {
                if farm.can_be_removed(&seed_amount) {
                    removable = true;
                }
            }
            if removable {
                let mut farm = self.data_mut().farms.remove(farm_id).expect(ERR41_FARM_NOT_EXIST);
                farm.move_to_clear(&seed_amount);
                self.data_mut().outdated_farms.insert(farm_id, &farm);
                farm_seed.get_ref_mut().farms.remove(farm_id);
                self.data_mut().seeds.insert(&seed_id, &farm_seed);
                return true;
            }
        }
        false
    }
}

'''
'''--- ref-farming/src/actions_of_reward.rs ---

use std::convert::TryInto;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{assert_one_yocto, env, near_bindgen, AccountId, Balance, PromiseResult};

use crate::utils::{ext_fungible_token, ext_self, GAS_FOR_FT_TRANSFER, GAS_FOR_RESOLVE_TRANSFER, parse_farm_id};
use crate::errors::*;
use crate::*;
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[near_bindgen]
impl Contract {

    /// Clean invalid rps,
    /// return false if the rps is still valid.
    pub fn remove_user_rps_by_farm(&mut self, farm_id: FarmId) -> bool {
        let sender_id = env::predecessor_account_id();
        let mut farmer = self.get_farmer(&sender_id);
        let (seed_id, _) = parse_farm_id(&farm_id);
        let farm_seed = self.get_seed(&seed_id);
        if !farm_seed.get_ref().farms.contains(&farm_id) {
            farmer.get_ref_mut().remove_rps(&farm_id);
            self.data_mut().farmers.insert(&sender_id, &farmer);
            true
        } else {
            false
        }
    }

    pub fn claim_reward_by_farm(&mut self, farm_id: FarmId) {
        let sender_id = env::predecessor_account_id();
        self.internal_claim_user_reward_by_farm_id(&sender_id, &farm_id);
        self.assert_storage_usage(&sender_id);
    }

    pub fn claim_reward_by_seed(&mut self, seed_id: SeedId) {
        let sender_id = env::predecessor_account_id();
        self.internal_claim_user_reward_by_seed_id(&sender_id, &seed_id);
        self.assert_storage_usage(&sender_id);
    }

    /// Withdraws given reward token of given user.
    #[payable]
    pub fn withdraw_reward(&mut self, token_id: ValidAccountId, amount: Option<U128>) {
        assert_one_yocto();

        let token_id: AccountId = token_id.into();
        let amount: u128 = amount.unwrap_or(U128(0)).into(); 

        let sender_id = env::predecessor_account_id();

        let mut farmer = self.get_farmer(&sender_id);

        // Note: subtraction, will be reverted if the promise fails.
        let amount = farmer.get_ref_mut().sub_reward(&token_id, amount);
        self.data_mut().farmers.insert(&sender_id, &farmer);
        ext_fungible_token::ft_transfer(
            sender_id.clone().try_into().unwrap(),
            amount.into(),
            None,
            &token_id,
            1,
            GAS_FOR_FT_TRANSFER,
        )
        .then(ext_self::callback_post_withdraw_reward(
            token_id,
            sender_id,
            amount.into(),
            &env::current_account_id(),
            0,
            GAS_FOR_RESOLVE_TRANSFER,
        ));
    }

    #[private]
    pub fn callback_post_withdraw_reward(
        &mut self,
        token_id: AccountId,
        sender_id: AccountId,
        amount: U128,
    ) -> U128 {
        assert_eq!(
            env::promise_results_count(),
            1,
            "{}",
            ERR25_CALLBACK_POST_WITHDRAW_INVALID
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {
                env::log(
                    format!(
                        "{} withdraw reward {} amount {}, Succeed.",
                        sender_id, token_id, amount.0,
                    )
                    .as_bytes(),
                );
                amount.into()
            }
            PromiseResult::Failed => {
                env::log(
                    format!(
                        "{} withdraw reward {} amount {}, Callback Failed.",
                        sender_id, token_id, amount.0,
                    )
                    .as_bytes(),
                );
                // This reverts the changes from withdraw function.
                let mut farmer = self.get_farmer(&sender_id);
                farmer.get_ref_mut().add_reward(&token_id, amount.0);
                self.data_mut().farmers.insert(&sender_id, &farmer);
                0.into()
            }
        }
    }
}

fn claim_user_reward_from_farm(
    farm: &mut Farm, 
    farmer: &mut Farmer, 
    total_seeds: &Balance,
    silent: bool,
) {
    let user_seeds = farmer.seeds.get(&farm.get_seed_id()).unwrap_or(&0_u128);
    let user_rps = farmer.get_rps(&farm.get_farm_id());
    let (new_user_rps, reward_amount) = farm.claim_user_reward(&user_rps, user_seeds, total_seeds, silent);
    if !silent {
        env::log(
            format!(
                "user_rps@{} increased to {}",
                farm.get_farm_id(), U256::from_little_endian(&new_user_rps),
            )
            .as_bytes(),
        );
    }
        
    farmer.set_rps(&farm.get_farm_id(), new_user_rps);
    if reward_amount > 0 {
        farmer.add_reward(&farm.get_reward_token(), reward_amount);
        if !silent {
            env::log(
                format!(
                    "claimed {} {} as reward from {}",
                    reward_amount, farm.get_reward_token() , farm.get_farm_id(),
                )
                .as_bytes(),
            );
        }
    }
}

impl Contract {

    pub(crate) fn internal_claim_user_reward_by_seed_id(
        &mut self, 
        sender_id: &AccountId,
        seed_id: &SeedId) {
        let mut farmer = self.get_farmer(sender_id);
        if let Some(mut farm_seed) = self.get_seed_wrapped(seed_id) {
            let amount = farm_seed.get_ref().amount;
            for farm_id in &mut farm_seed.get_ref_mut().farms.iter() {
                let mut farm = self.data().farms.get(farm_id).unwrap();
                claim_user_reward_from_farm(
                    &mut farm, 
                    farmer.get_ref_mut(),  
                    &amount,
                    true,
                );
                self.data_mut().farms.insert(farm_id, &farm);
            }
            self.data_mut().seeds.insert(seed_id, &farm_seed);
            self.data_mut().farmers.insert(sender_id, &farmer);
        }
    }

    pub(crate) fn internal_claim_user_reward_by_farm_id(
        &mut self, 
        sender_id: &AccountId, 
        farm_id: &FarmId) {
        let mut farmer = self.get_farmer(sender_id);

        let (seed_id, _) = parse_farm_id(farm_id);

        if let Some(farm_seed) = self.get_seed_wrapped(&seed_id) {
            let amount = farm_seed.get_ref().amount;
            if let Some(mut farm) = self.data().farms.get(farm_id) {
                claim_user_reward_from_farm(
                    &mut farm, 
                    farmer.get_ref_mut(), 
                    &amount,
                    false,
                );
                self.data_mut().farms.insert(farm_id, &farm);
                self.data_mut().farmers.insert(sender_id, &farmer);
            }
        }
    }

    #[inline]
    pub(crate) fn get_farmer(&self, from: &AccountId) -> VersionedFarmer {
        let orig = self.data().farmers
            .get(from)
            .expect(ERR10_ACC_NOT_REGISTERED);
        if orig.need_upgrade() {
                orig.upgrade()
            } else {
                orig
            }
    }

    #[inline]
    pub(crate) fn get_farmer_default(&self, from: &AccountId) -> VersionedFarmer {
        let orig = self.data().farmers.get(from).unwrap_or(VersionedFarmer::new(from.clone(), 0));
        if orig.need_upgrade() {
            orig.upgrade()
        } else {
            orig
        }
    }

    #[inline]
    pub(crate) fn get_farmer_wrapped(&self, from: &AccountId) -> Option<VersionedFarmer> {
        if let Some(farmer) = self.data().farmers.get(from) {
            if farmer.need_upgrade() {
                Some(farmer.upgrade())
            } else {
                Some(farmer)
            }
        } else {
            None
        }
    }

    /// Returns current balance of given token for given user. 
    /// If there is nothing recorded, returns 0.
    pub(crate) fn internal_get_reward(
        &self,
        sender_id: &AccountId,
        token_id: &AccountId,
    ) -> Balance {
        self.get_farmer_default(sender_id)
            .get_ref().rewards.get(token_id).cloned()
            .unwrap_or_default()
    }
}

'''
'''--- ref-farming/src/actions_of_seed.rs ---

use std::convert::TryInto;
use near_sdk::json_types::{U128};
use near_sdk::{AccountId, Balance, PromiseResult};

use crate::utils::{
    assert_one_yocto, ext_multi_fungible_token, ext_fungible_token, 
    ext_self, wrap_mft_token_id, parse_seed_id, GAS_FOR_FT_TRANSFER, GAS_FOR_RESOLVE_WITHDRAW_SEED
};
use crate::errors::*;
use crate::farm_seed::SeedType;
use crate::*;

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn withdraw_seed(&mut self, seed_id: SeedId, amount: U128) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();

        let amount: Balance = amount.into();

        // update inner state
        let seed_type = self.internal_seed_withdraw(&seed_id, &sender_id, amount);

        match seed_type {
            SeedType::FT => {
                ext_fungible_token::ft_transfer(
                    sender_id.clone().try_into().unwrap(),
                    amount.into(),
                    None,
                    &seed_id,
                    1,  // one yocto near
                    GAS_FOR_FT_TRANSFER,
                )
                .then(ext_self::callback_post_withdraw_ft_seed(
                    seed_id,
                    sender_id,
                    amount.into(),
                    &env::current_account_id(),
                    0,
                    GAS_FOR_RESOLVE_WITHDRAW_SEED,
                ));
            }
            SeedType::MFT => {
                let (receiver_id, token_id) = parse_seed_id(&seed_id);
                ext_multi_fungible_token::mft_transfer(
                    wrap_mft_token_id(&token_id),
                    sender_id.clone().try_into().unwrap(),
                    amount.into(),
                    None,
                    &receiver_id,
                    1,  // one yocto near
                    GAS_FOR_FT_TRANSFER,
                )
                .then(ext_self::callback_post_withdraw_mft_seed(
                    seed_id,
                    sender_id,
                    amount.into(),
                    &env::current_account_id(),
                    0,
                    GAS_FOR_RESOLVE_WITHDRAW_SEED,
                ));
            }
        }
        
    }

    #[private]
    pub fn callback_post_withdraw_ft_seed(
        &mut self,
        seed_id: SeedId,
        sender_id: AccountId,
        amount: U128,
    ) -> U128 {
        assert_eq!(
            env::promise_results_count(),
            1,
            "{}",
            ERR25_CALLBACK_POST_WITHDRAW_INVALID
        );
        let amount: Balance = amount.into();
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {
                env::log(
                    format!(
                        "{} withdraw {} ft seed with amount {}, Callback Failed.",
                        sender_id, seed_id, amount,
                    )
                    .as_bytes(),
                );
                // revert withdraw, equal to deposit, claim reward to update user reward_per_seed
                self.internal_claim_user_reward_by_seed_id(&sender_id, &seed_id);
                let mut farm_seed = self.get_seed(&seed_id);
                let mut farmer = self.get_farmer(&sender_id);

                farm_seed.get_ref_mut().seed_type = SeedType::FT;
                farm_seed.get_ref_mut().add_amount(amount);
                farmer.get_ref_mut().add_seed(&seed_id, amount);
                self.data_mut().seeds.insert(&seed_id, &farm_seed);
                self.data_mut().farmers.insert(&sender_id, &farmer);
                0.into()
            },
            PromiseResult::Successful(_) => {
                env::log(
                    format!(
                        "{} withdraw {} ft seed with amount {}, Succeed.",
                        sender_id, seed_id, amount,
                    )
                    .as_bytes(),
                );
                amount.into()
            }
        }
    }

    #[private]
    pub fn callback_post_withdraw_mft_seed(
        &mut self,
        seed_id: SeedId,
        sender_id: AccountId,
        amount: U128,
    ) -> U128 {
        assert_eq!(
            env::promise_results_count(),
            1,
            "{}",
            ERR25_CALLBACK_POST_WITHDRAW_INVALID
        );
        let amount: Balance = amount.into();
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {
                env::log(
                    format!(
                        "{} withdraw {} mft seed with amount {}, Callback Failed.",
                        sender_id, seed_id, amount,
                    )
                    .as_bytes(),
                );
                // revert withdraw, equal to deposit, claim reward to update user reward_per_seed
                self.internal_claim_user_reward_by_seed_id(&sender_id, &seed_id);
                let mut farm_seed = self.get_seed(&seed_id);
                let mut farmer = self.get_farmer(&sender_id);

                farm_seed.get_ref_mut().seed_type = SeedType::MFT;
                farm_seed.get_ref_mut().add_amount(amount);
                farmer.get_ref_mut().add_seed(&seed_id, amount);
                self.data_mut().seeds.insert(&seed_id, &farm_seed);
                self.data_mut().farmers.insert(&sender_id, &farmer);
                0.into()
            },
            PromiseResult::Successful(_) => {
                env::log(
                    format!(
                        "{} withdraw {} mft seed with amount {}, Succeed.",
                        sender_id, seed_id, amount,
                    )
                    .as_bytes(),
                );
                amount.into()
            }
        }
    }
}

/// Internal methods implementation.
impl Contract {

    #[inline]
    pub(crate) fn get_seed(&self, seed_id: &String) -> VersionedFarmSeed {
        let orig = self.data().seeds.get(seed_id).expect(&format!("{}", ERR31_SEED_NOT_EXIST));
        if orig.need_upgrade() {
            orig.upgrade()
        } else {
            orig
        } 
    }

    #[inline]
    pub(crate) fn get_seed_wrapped(&self, seed_id: &String) -> Option<VersionedFarmSeed> {
        if let Some(farm_seed) = self.data().seeds.get(seed_id) {
            if farm_seed.need_upgrade() {
                Some(farm_seed.upgrade())
            } else {
                Some(farm_seed)
            }
        } else {
            None
        }
    }

    pub(crate) fn internal_seed_deposit(
        &mut self, 
        seed_id: &String, 
        sender_id: &AccountId, 
        amount: Balance, 
        seed_type: SeedType) {

        // first claim all reward of the user for this seed farms 
        // to update user reward_per_seed in each farm 
        self.internal_claim_user_reward_by_seed_id(sender_id, seed_id);

        // **** update seed (new version)
        let mut farm_seed = self.get_seed(seed_id);
        farm_seed.get_ref_mut().seed_type = seed_type;
        farm_seed.get_ref_mut().add_amount(amount);
        self.data_mut().seeds.insert(&seed_id, &farm_seed);

        let mut farmer = self.get_farmer(sender_id);
        farmer.get_ref_mut().add_seed(&seed_id, amount);
        self.data_mut().farmers.insert(sender_id, &farmer);
    }

    fn internal_seed_withdraw(
        &mut self, 
        seed_id: &SeedId, 
        sender_id: &AccountId, 
        amount: Balance) -> SeedType {
        
        // first claim all reward of the user for this seed farms 
        // to update user reward_per_seed in each farm
        self.internal_claim_user_reward_by_seed_id(sender_id, seed_id);

        let mut farm_seed = self.get_seed(seed_id);
        let mut farmer = self.get_farmer(sender_id);

        // Then update user seed and total seed of this LPT
        let farmer_seed_remain = farmer.get_ref_mut().sub_seed(seed_id, amount);
        let _seed_remain = farm_seed.get_ref_mut().sub_amount(amount);

        if farmer_seed_remain == 0 {
            // remove farmer rps of relative farm
            for farm_id in farm_seed.get_ref().farms.iter() {
                farmer.get_ref_mut().remove_rps(farm_id);
            }
        }
        self.data_mut().farmers.insert(sender_id, &farmer);
        self.data_mut().seeds.insert(seed_id, &farm_seed);
        farm_seed.get_ref().seed_type.clone()
    }
}

'''
'''--- ref-farming/src/errors.rs ---
// Storage errors //
pub const ERR10_ACC_NOT_REGISTERED: &str = "E10: account not registered";
pub const ERR11_INSUFFICIENT_STORAGE: &str = "E11: insufficient $NEAR storage deposit";
pub const ERR12_STORAGE_UNREGISTER_REWARDS_NOT_EMPTY: &str = "E12: still has rewards when unregister";
pub const ERR13_STORAGE_UNREGISTER_SEED_NOT_EMPTY: &str = "E13: still has staked seed when unregister";
pub const ERR14_ACC_ALREADY_REGISTERED: &str = "E14: account already registered";

// Reward errors //
pub const ERR21_TOKEN_NOT_REG: &str = "E21: token not registered";
pub const ERR22_NOT_ENOUGH_TOKENS: &str = "E22: not enough tokens in deposit";

pub const ERR25_CALLBACK_POST_WITHDRAW_INVALID: &str = "E25: expected 1 promise result from withdraw";

// Seed errors //
pub const ERR31_SEED_NOT_EXIST: &str = "E31: seed not exist";
pub const ERR32_NOT_ENOUGH_SEED: &str = "E32: not enough amount of seed";
pub const ERR33_INVALID_SEED_ID: &str = "E33: invalid seed id";
pub const ERR34_BELOW_MIN_SEED_DEPOSITED: &str = "E34: below min_deposit of this seed";
pub const ERR35_ILLEGAL_TOKEN_ID: &str = "E35: illegal token_id in mft_transfer_call";

// farm errors //
pub const ERR41_FARM_NOT_EXIST: &str = "E41: farm not exist";
pub const ERR42_INVALID_FARM_ID: &str = "E42: invalid farm id";
pub const ERR43_INVALID_FARM_STATUS: &str = "E43: invalid farm status";
pub const ERR44_INVALID_FARM_REWARD: &str = "E44: invalid reward token for this farm";

pub const ERR500: &str = "E500: Internal ERROR!";
'''
'''--- ref-farming/src/farm.rs ---
//! Wrapper of different types of farms 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId, Balance};

use crate::simple_farm::{SimpleFarm, RPS};
use crate::SeedId;

pub(crate) type FarmId = String;

/// Generic Farm, providing wrapper around different implementations of farms.
/// Allows to add new types of farms just by adding extra item in the enum 
/// without needing to migrate the storage.
#[derive(BorshSerialize, BorshDeserialize)]
pub enum Farm {
    SimpleFarm(SimpleFarm),
}

impl Farm {
    /// Returns farm kind.
    pub fn kind(&self) -> String {
        match self {
            Farm::SimpleFarm(_) => "SIMPLE_FARM".to_string(),
        }
    }

    /// return None if the farm can not accept reward anymore
    /// else return amount of undistributed reward 
    pub fn add_reward(&mut self, amount: &Balance) -> Option<Balance> {
        match self {
            Farm::SimpleFarm(farm) => farm.add_reward(amount),
        }
    }

    /// Returns seed id this farm accepted.
    pub fn get_seed_id(&self) -> SeedId {
        match self {
            Farm::SimpleFarm(farm) => farm.terms.seed_id.clone(),
        }
    }

    /// Returns token contract id this farm used for reward.
    pub fn get_reward_token(&self) -> AccountId {
        match self {
            Farm::SimpleFarm(farm) => farm.terms.reward_token.clone(),
        }
    }

    pub fn get_farm_id(&self) -> FarmId {
        match self {
            Farm::SimpleFarm(farm) => farm.farm_id.clone(),
        }
    }

    /// Returns how many reward tokens can given farmer claim.
    pub fn view_farmer_unclaimed_reward(
        &self,
        user_rps: &RPS,
        user_seeds: &Balance,
        total_seeds: &Balance,
    ) -> Balance {
        match self {
            Farm::SimpleFarm(farm) 
                => farm.view_farmer_unclaimed_reward(user_rps, user_seeds, total_seeds),
        }
    }

    /// return the new user reward per seed 
    /// and amount of reward as (user_rps, reward_amount) 
    pub fn claim_user_reward(&mut self, 
        user_rps: &RPS,
        user_seeds: &Balance, 
        total_seeds: &Balance, 
        silent: bool,
    ) -> (RPS, Balance) {
        match self {
            Farm::SimpleFarm(farm) 
                => farm.claim_user_reward(user_rps, user_seeds, total_seeds, silent),
        }
    }

    pub fn can_be_removed(&self, total_seeds: &Balance) -> bool {
        match self {
            Farm::SimpleFarm(farm) => farm.can_be_removed(total_seeds),
        }
    }

    pub fn move_to_clear(&mut self, total_seeds: &Balance) -> bool {
        match self {
            Farm::SimpleFarm(farm) => farm.move_to_clear(total_seeds),
        }
    }

}

'''
'''--- ref-farming/src/farm_seed.rs ---
//! FarmSeed stores information per seed about 
//! staked seed amount and farms under it.

use std::collections::HashSet;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{Balance};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{U128};
use crate::errors::*;
use crate::farm::FarmId;
use crate::utils::parse_seed_id;

/// For MFT, SeedId composes of token_contract_id 
/// and token's inner_id in that contract. 
/// For FT, SeedId is the token_contract_id.
pub(crate) type SeedId = String;

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum SeedType {
    FT,
    MFT,
}

#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "test", derive(Clone))]
pub struct FarmSeed {
    /// The Farming Token this FarmSeed represented for
    pub seed_id: SeedId,
    /// The seed is a FT or MFT, enum size is 2 bytes?
    pub seed_type: SeedType,
    /// all farms that accepted this seed
    /// FarmId = {seed_id}#{next_index}
    pub farms: HashSet<FarmId>,
    pub next_index: u32,
    /// total (staked) balance of this seed (Farming Token)
    pub amount: Balance,
    pub min_deposit: Balance,
}

impl FarmSeed {
    pub fn new(seed_id: &SeedId, min_deposit: Balance) -> Self {
        let (token_id, token_index) = parse_seed_id(seed_id);
        let seed_type: SeedType;
        if token_id == token_index {
            seed_type = SeedType::FT;
        } else {
            seed_type = SeedType::MFT;
        }
        Self {
            seed_id: seed_id.clone(),
            seed_type,
            farms: HashSet::new(),
            next_index: 0,
            amount: 0,
            min_deposit,
        }
    }

    pub fn add_amount(&mut self, amount: Balance) {
        self.amount += amount;
    }

    /// return seed amount remains.
    pub fn sub_amount(&mut self, amount: Balance) -> Balance {
        assert!(self.amount >= amount, "{}", ERR500);
        self.amount -= amount;
        self.amount
    }

}

/// Versioned FarmSeed, used for lazy upgrade.
/// Which means this structure would upgrade automatically when used.
/// To achieve that, each time the new version comes in, 
/// each function of this enum should be carefully re-code!
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedFarmSeed {
    V101(FarmSeed),
}

impl VersionedFarmSeed {

    pub fn new(seed_id: &SeedId, min_deposit: Balance) -> Self {
        VersionedFarmSeed::V101(FarmSeed::new(seed_id, min_deposit))
    }

    /// Upgrades from other versions to the currently used version.
    pub fn upgrade(self) -> Self {
        match self {
            VersionedFarmSeed::V101(farm_seed) => VersionedFarmSeed::V101(farm_seed),
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn need_upgrade(&self) -> bool {
        match self {
            VersionedFarmSeed::V101(_) => false,
            _ => true,
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn get_ref(&self) -> &FarmSeed {
        match self {
            VersionedFarmSeed::V101(farm_seed) => farm_seed,
            _ => unimplemented!(),
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn get_ref_mut(&mut self) -> &mut FarmSeed {
        match self {
            VersionedFarmSeed::V101(farm_seed) => farm_seed,
            _ => unimplemented!(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SeedInfo {
    pub seed_id: SeedId,
    pub seed_type: String,
    pub farms: Vec<FarmId>,
    pub next_index: u32,
    pub amount: U128,
    pub min_deposit: U128,
}

impl From<&FarmSeed> for SeedInfo {
    fn from(fs: &FarmSeed) -> Self {

        let seed_type = match fs.seed_type {
            SeedType::FT => "FT".to_string(),
            SeedType::MFT => "MFT".to_string(),
        };
        Self {
            seed_id: fs.seed_id.clone(),
            seed_type,
            next_index: fs.next_index,
            amount: fs.amount.into(),
            min_deposit: fs.min_deposit.into(),
            farms: fs.farms.iter().map(|key| key.clone()).collect(),
        }
    }
}

'''
'''--- ref-farming/src/farmer.rs ---
//! Farmer records a farmer's 
//! * all claimed reward tokens, 
//! * all seeds he staked,
//! * user_rps per farm,
//! and the deposited near amount prepaid as storage fee

use std::collections::HashMap;
use near_sdk::collections::LookupMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, AccountId, Balance};
use crate::{SeedId, FarmId, RPS};
use crate::errors::*;
use crate::utils::MAX_ACCOUNT_LENGTH;
use crate::StorageKeys;
/// each entry cost MAX_ACCOUNT_LENGTH bytes, 
/// amount: Balance cost 16 bytes
/// each empty hashmap cost 4 bytes
pub const MIN_FARMER_LENGTH: u128 = MAX_ACCOUNT_LENGTH + 16 + 4 * 3;

/// Account deposits information and storage cost.
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "test", derive(Clone))]
pub struct Farmer {
    /// Native NEAR amount sent to this contract.
    /// Used for storage.
    pub amount: Balance,
    /// Amounts of various reward tokens the farmer claimed.
    pub rewards: HashMap<AccountId, Balance>,
    /// Amounts of various seed tokens the farmer staked.
    pub seeds: HashMap<SeedId, Balance>,
    /// record user_last_rps of farms
    pub user_rps: LookupMap<FarmId, RPS>,
    pub rps_count: u32,
}

impl Farmer {

    /// Adds amount to the balance of given token
    pub(crate) fn add_reward(&mut self, token: &AccountId, amount: Balance) {
        if let Some(x) = self.rewards.get_mut(token) {
            *x = *x + amount;
        } else {
            self.rewards.insert(token.clone(), amount);
        }
    }

    /// Subtract from `reward` balance.
    /// if amount == 0, subtract all reward balance.
    /// Panics if `amount` is bigger than the current balance.
    /// return actual subtract amount
    pub(crate) fn sub_reward(&mut self, token: &AccountId, amount: Balance) -> Balance {
        let value = *self.rewards.get(token).expect(ERR21_TOKEN_NOT_REG);
        assert!(value >= amount, "{}", ERR22_NOT_ENOUGH_TOKENS);
        if amount == 0 {
            self.rewards.remove(&token.clone());
            value
        } else {
            self.rewards.insert(token.clone(), value - amount);
            amount
        }
    }

    pub fn add_seed(&mut self, seed_id: &SeedId, amount: Balance) {
        if amount > 0 {
            self.seeds.insert(
                seed_id.clone(), 
                amount + self.seeds.get(seed_id).unwrap_or(&0_u128)
            );
        }
        
    }

    /// return seed remained.
    pub fn sub_seed(&mut self, seed_id: &SeedId, amount: Balance) -> Balance {
        let prev_balance = self.seeds.get(seed_id).expect(&format!("{}", ERR31_SEED_NOT_EXIST));
        assert!(prev_balance >= &amount, "{}", ERR32_NOT_ENOUGH_SEED);
        let cur_balance = prev_balance - amount;
        if cur_balance > 0 {
            self.seeds.insert(seed_id.clone(), cur_balance);
        } else {
            self.seeds.remove(seed_id);
        }
        cur_balance
    }

    pub fn get_rps(&self, farm_id: &FarmId) -> RPS {
        self.user_rps.get(farm_id).unwrap_or(RPS::default()).clone()
    }

    pub fn set_rps(&mut self, farm_id: &FarmId, rps: RPS) {
        if !self.user_rps.contains_key(farm_id) {
            self.rps_count += 1;
        } 
        self.user_rps.insert(farm_id, &rps);
    }

    pub fn remove_rps(&mut self, farm_id: &FarmId) {
        if self.user_rps.contains_key(farm_id) {
            self.user_rps.remove(farm_id);
            self.rps_count -= 1;
        }
    }

    /// Returns amount of yocto near necessary to cover storage used by this data structure.
    pub fn storage_usage(&self) -> Balance {
        (
            MIN_FARMER_LENGTH 
            + self.rewards.len() as u128 * (4 + MAX_ACCOUNT_LENGTH + 16)
            + self.seeds.len() as u128 * (4 + MAX_ACCOUNT_LENGTH + 16)
            + self.rps_count as u128 * (4 + 1 + 2 * MAX_ACCOUNT_LENGTH + 32)
        )
        * env::storage_byte_cost()
    }
}

/// Versioned Farmer, used for lazy upgrade.
/// Which means this structure would upgrade automatically when used.
/// To achieve that, each time the new version comes in, 
/// each function of this enum should be carefully re-code!
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedFarmer {
    V101(Farmer),
}

impl VersionedFarmer {

    pub fn new(farmer_id: AccountId, amount: Balance) -> Self {
        VersionedFarmer::V101(Farmer {
            amount: amount,
            rewards: HashMap::new(),
            seeds: HashMap::new(),
            user_rps: LookupMap::new(StorageKeys::UserRps {
                account_id: farmer_id.clone(),
            }),
            rps_count: 0,
        })
    }

    /// Upgrades from other versions to the currently used version.
    pub fn upgrade(self) -> Self {
        match self {
            VersionedFarmer::V101(farmer) => VersionedFarmer::V101(farmer),
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn need_upgrade(&self) -> bool {
        match self {
            VersionedFarmer::V101(_) => false,
            _ => true,
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn get_ref(&self) -> &Farmer {
        match self {
            VersionedFarmer::V101(farmer) => farmer,
            _ => unimplemented!(),
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn get(self) -> Farmer {
        match self {
            VersionedFarmer::V101(farmer) => farmer,
            _ => unimplemented!(),
        }
    }

    #[inline]
    #[allow(unreachable_patterns)]
    pub fn get_ref_mut(&mut self) -> &mut Farmer {
        match self {
            VersionedFarmer::V101(farmer) => farmer,
            _ => unimplemented!(),
        }
    }
}

'''
'''--- ref-farming/src/lib.rs ---
/*!
* Ref-Farming
*
* lib.rs is the main entry point.
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::{env, near_bindgen, Balance, AccountId, PanicOnDefault};
use near_sdk::BorshStorageKey;

use crate::farm::{Farm, FarmId};
use crate::simple_farm::{RPS};
use crate::farm_seed::{VersionedFarmSeed, SeedId};
use crate::farmer::{VersionedFarmer, Farmer};

// for simulator test
pub use crate::simple_farm::HRSimpleFarmTerms;
pub use crate::view::FarmInfo;

mod utils;
mod errors;
mod farmer;
mod token_receiver;
mod farm_seed;
mod farm;
mod simple_farm;
mod storage_impl;

mod actions_of_farm;
mod actions_of_seed;
mod actions_of_reward;
mod view;

mod owner;

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Seed,
    Farm,
    OutdatedFarm,
    Farmer,
    RewardInfo,
    UserRps { account_id: AccountId },
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ContractData {

    // owner of this contract
    owner_id: AccountId,
    
    // record seeds and the farms under it.
    // seeds: UnorderedMap<SeedId, FarmSeed>,
    seeds: UnorderedMap<SeedId, VersionedFarmSeed>,

    // each farmer has a structure to describe
    // farmers: LookupMap<AccountId, Farmer>,
    farmers: LookupMap<AccountId, VersionedFarmer>,

    farms: UnorderedMap<FarmId, Farm>,
    outdated_farms: UnorderedMap<FarmId, Farm>,

    // for statistic
    farmer_count: u64,
    reward_info: UnorderedMap<AccountId, Balance>,
}

/// Versioned contract data. Allows to easily upgrade contracts.
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VersionedContractData {
    Current(ContractData),
}

impl VersionedContractData {}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {

    data: VersionedContractData,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            data: VersionedContractData::Current(ContractData {
                owner_id: owner_id.into(),
                farmer_count: 0,
                seeds: UnorderedMap::new(StorageKeys::Seed),
                farmers: LookupMap::new(StorageKeys::Farmer),
                farms: UnorderedMap::new(StorageKeys::Farm),
                outdated_farms: UnorderedMap::new(StorageKeys::OutdatedFarm),
                reward_info: UnorderedMap::new(StorageKeys::RewardInfo),
            }),
        }
    }
}

impl Contract {
    fn data(&self) -> &ContractData {
        match &self.data {
            VersionedContractData::Current(data) => data,
        }
    }

    fn data_mut(&mut self) -> &mut ContractData {
        match &mut self.data {
            VersionedContractData::Current(data) => data,
        }
    }
}

#[cfg(test)]
mod tests {

    use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, Balance, MockedBlockchain};
    use near_sdk::json_types::{ValidAccountId, U128};
    use simple_farm::{HRSimpleFarmTerms};
    use near_contract_standards::storage_management::{StorageBalance, StorageManagement};

    use super::utils::*;
    use super::*;

    fn setup_contract() -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let contract = Contract::new(accounts(0));
        (context, contract)
    }

    fn create_farm(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        seed: ValidAccountId,
        reward: ValidAccountId,
        session_amount: Balance,
        session_interval: u32,
    ) -> FarmId {
        // storage needed: 341
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .attached_deposit(env::storage_byte_cost() * 559)
            .build());
        contract.create_simple_farm(HRSimpleFarmTerms {
            seed_id: seed.into(),
            reward_token: reward.into(),
            start_at: 0,
            reward_per_session: U128(session_amount),
            session_interval: session_interval,
        }, Some(U128(10)))
    }

    fn deposit_reward(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        amount: u128,
        time_stamp: u32,
    ) {
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .block_timestamp(to_nano(time_stamp))
            .attached_deposit(1)
            .build());
        contract.ft_on_transfer(accounts(0), U128(amount), String::from("bob#0"));
    }

    fn register_farmer(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
    ) -> StorageBalance {
        testing_env!(context
            .predecessor_account_id(farmer.clone())
            .is_view(false)
            .attached_deposit(env::storage_byte_cost() * 1852)
            .build());
        contract.storage_deposit(Some(farmer), Some(true))
    }

    fn storage_withdraw(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
    ) -> StorageBalance {
        testing_env!(context
            .predecessor_account_id(farmer.clone())
            .is_view(false)
            .attached_deposit(1)
            .build());
        contract.storage_withdraw(None)
    }

    fn deposit_seed(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
        time_stamp: u32,
        amount: Balance,
    ) {
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .attached_deposit(1)
            .build());
        contract.ft_on_transfer(farmer, U128(amount), String::from(""));
    }    

    fn withdraw_seed(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
        time_stamp: u32,
        amount: Balance,
    ) {
        testing_env!(context
            .predecessor_account_id(farmer)
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .attached_deposit(1)
            .build());
        contract.withdraw_seed(accounts(1).into(), U128(amount));
    } 

    fn claim_reward(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
        time_stamp: u32
    ) {
        testing_env!(context
            .predecessor_account_id(farmer)
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .attached_deposit(1)
            .build());
        contract.claim_reward_by_farm(String::from("bob#0"));
    }

    fn claim_reward_by_seed(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        farmer: ValidAccountId,
        time_stamp: u32
    ) {
        testing_env!(context
            .predecessor_account_id(farmer)
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .attached_deposit(1)
            .build());
        contract.claim_reward_by_seed(String::from("bob"));
    }

    fn remove_farm(context: &mut VMContextBuilder, contract: &mut Contract, time_stamp: u32) {
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .build());
        contract.force_clean_farm(String::from("bob#0"));
    }

    fn remove_user_rps(context: &mut VMContextBuilder, contract: &mut Contract, farmer: ValidAccountId, farm_id: String, time_stamp: u32) -> bool {
        testing_env!(context
            .predecessor_account_id(farmer)
            .is_view(false)
            .block_timestamp(to_nano(time_stamp))
            .build());
        contract.remove_user_rps_by_farm(farm_id)
    }

    fn to_yocto(value: &str) -> u128 {
        let vals: Vec<_> = value.split('.').collect();
        let part1 = vals[0].parse::<u128>().unwrap() * 10u128.pow(24);
        if vals.len() > 1 {
            let power = vals[1].len() as u32;
            let part2 = vals[1].parse::<u128>().unwrap() * 10u128.pow(24 - power);
            part1 + part2
        } else {
            part1
        }
    }

    #[test]
    fn test_basics() {

        let (mut context, mut contract) = setup_contract();
        // seed is bob, reward is charlie
        let farm_id = create_farm(&mut context, &mut contract,
            accounts(1), accounts(2), 5000, 50);
        assert_eq!(farm_id, String::from("bob#0"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.farm_kind, String::from("SIMPLE_FARM"));
        assert_eq!(farm_info.farm_status, String::from("Created"));
        assert_eq!(farm_info.seed_id, String::from("bob"));
        assert_eq!(farm_info.reward_token, String::from("charlie"));
        assert_eq!(farm_info.reward_per_session, U128(5000));
        assert_eq!(farm_info.session_interval, 50);

        // deposit 50k, can last 10 rounds from 0 to 9
        deposit_reward(&mut context, &mut contract, 50000, 100);
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.farm_status, String::from("Running"));
        assert_eq!(farm_info.start_at, 100);

        // Farmer accounts(0) come in round 1
        register_farmer(&mut context, &mut contract, accounts(0));
        deposit_seed(&mut context, &mut contract, accounts(0), 160, 10);
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.beneficiary_reward, U128(5000));
        assert_eq!(farm_info.cur_round, 1);
        assert_eq!(farm_info.last_round, 1);

        // move to round 2, 5k unclaimed for accounts(0)
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(210))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(5000));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 2);
        assert_eq!(farm_info.last_round, 1);

        // Farmer accounts(3) come in 
        register_farmer(&mut context, &mut contract, accounts(3));
        // deposit seed
        deposit_seed(&mut context, &mut contract, accounts(3), 260, 10);
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(10000));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 3);
        assert_eq!(farm_info.last_round, 3);

        // move to round 4, 
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(320))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(12500));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(2500));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 4);
        assert_eq!(farm_info.last_round, 3);

        // remove all seeds at round 5
        println!("----> remove all seeds at round 5");
        withdraw_seed(&mut context, &mut contract, accounts(0), 360, 10);
        withdraw_seed(&mut context, &mut contract, accounts(3), 370, 10);
        testing_env!(context.predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(380)).is_view(true).build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let rewarded = contract.get_reward(accounts(0), accounts(2));
        assert_eq!(rewarded, U128(15000));
        let rewarded = contract.get_reward(accounts(3), accounts(2));
        assert_eq!(rewarded, U128(5000));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 5);
        assert_eq!(farm_info.last_round, 5);

        // move to round 7, account3 come in again
        println!("----> move to round 7, account3 come in again");
        deposit_seed(&mut context, &mut contract, accounts(3), 460, 10);
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.beneficiary_reward, U128(15000));
        assert_eq!(farm_info.cur_round, 7);
        assert_eq!(farm_info.last_round, 7);

        // move to round 8, account0 come in again
        println!("----> move to round 8, account0 come in again");
        deposit_seed(&mut context, &mut contract, accounts(0), 520, 10);
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(5000));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 8);
        assert_eq!(farm_info.last_round, 8);

        // move to round 9,
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(580))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(2500));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(7500));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 9);
        assert_eq!(farm_info.last_round, 8);
        assert_eq!(farm_info.farm_status, String::from("Running"));

        // move to round 10,
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(610))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(5000));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(10000));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 10);
        assert_eq!(farm_info.last_round, 8);
        assert_eq!(farm_info.farm_status, String::from("Ended"));

        // claim reward 
        println!("----> accounts(0) and accounts(3) claim reward");
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(710))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(5000));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(10000));
        claim_reward(&mut context, &mut contract, accounts(0), 720);
        claim_reward(&mut context, &mut contract, accounts(3), 730);
        testing_env!(context.predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(740)).is_view(true).build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let rewarded = contract.get_reward(accounts(0), accounts(2));
        assert_eq!(rewarded, U128(20000));
        let rewarded = contract.get_reward(accounts(3), accounts(2));
        assert_eq!(rewarded, U128(15000));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 10);
        assert_eq!(farm_info.last_round, 10);

        // clean farm
        println!("----> clean farm");
        remove_farm(&mut context, &mut contract, 750);
        assert!(contract.get_farm(farm_id.clone()).is_none());

        // remove user rps
        println!("----> remove user rps");
        testing_env!(context.predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(760)).is_view(true).build());
        let prev_available = contract.storage_balance_of(accounts(0)).expect("Error").available.0;
        let ret = remove_user_rps(&mut context, &mut contract, accounts(0).into(), String::from("bob#0"), 770);
        assert!(ret);
        testing_env!(context.predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(780)).is_view(true).build());
        let post_available = contract.storage_balance_of(accounts(0)).expect("Error").available.0;
        assert_eq!(post_available - prev_available, 165*10_u128.pow(19));

        // withdraw seed
        println!("----> accounts(0) and accounts(3) withdraw seed");
        withdraw_seed(&mut context, &mut contract, accounts(0), 800, 10);
        withdraw_seed(&mut context, &mut contract, accounts(3), 810, 10);
        testing_env!(context.predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(820)).is_view(true).build());
        let rewarded = contract.get_reward(accounts(0), accounts(2));
        assert_eq!(rewarded, U128(20000));
        let rewarded = contract.get_reward(accounts(3), accounts(2));
        assert_eq!(rewarded, U128(15000));
        
    }

    #[test]
    fn test_unclaimed_rewards() {

        let (mut context, mut contract) = setup_contract();
        // seed is bob, reward is charlie
        let farm_id = create_farm(&mut context, &mut contract,
            accounts(1), accounts(2), to_yocto("1"), 50);
        assert_eq!(farm_id, String::from("bob#0"));

        // deposit 10, can last 10 rounds from 0 to 9
        deposit_reward(&mut context, &mut contract, to_yocto("10"), 100);

        // Farmer1 accounts(0) come in round 0
        register_farmer(&mut context, &mut contract, accounts(0));
        deposit_seed(&mut context, &mut contract, accounts(0), 110, to_yocto("1"));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed, U128(0));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 0);
        assert_eq!(farm_info.last_round, 0);
        assert_eq!(farm_info.claimed_reward.0, 0);
        assert_eq!(farm_info.unclaimed_reward.0, 0);

        // move to round 1,
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(160))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("1"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 1);
        assert_eq!(farm_info.last_round, 0);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("0"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("1"));

        // Farmer2 accounts(3) come in round 1
        register_farmer(&mut context, &mut contract, accounts(3));
        // deposit seed
        deposit_seed(&mut context, &mut contract, accounts(3), 180, to_yocto("1"));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("1"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));

        // move to round 2,
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(210))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("1.5"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0.5"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 2);
        assert_eq!(farm_info.last_round, 1);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("0"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("2"));

        // farmer1 claim reward by farm_id at round 3
        claim_reward(&mut context, &mut contract, accounts(0), 260);
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("1"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 3);
        assert_eq!(farm_info.last_round, 3);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("2"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("1"));

        // farmer2 claim reward by seed_id at round 4
        claim_reward_by_seed(&mut context, &mut contract, accounts(3), 310);
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0.5"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 4);
        assert_eq!(farm_info.last_round, 4);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("3.5"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("0.5"));

        // farmer1 unstake half lpt at round 5
        withdraw_seed(&mut context, &mut contract, accounts(0), 360, to_yocto("0.4"));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0.5"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 5);
        assert_eq!(farm_info.last_round, 5);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("4.5"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("0.5"));

        // farmer2 unstake all his lpt at round 6
        withdraw_seed(&mut context, &mut contract, accounts(3), 410, to_yocto("1"));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0.375"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 6);
        assert_eq!(farm_info.last_round, 6);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("5.625"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("0.375"));

        // move to round 7
        testing_env!(context
            .predecessor_account_id(accounts(0))
            .block_timestamp(to_nano(460))
            .is_view(true)
            .build());
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("1.374999999999999999999999"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 7);
        assert_eq!(farm_info.last_round, 6);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("5.625"));
        assert_eq!(farm_info.unclaimed_reward.0, to_yocto("1.375"));
        withdraw_seed(&mut context, &mut contract, accounts(0), 470, to_yocto("0.6"));
        let unclaimed = contract.get_unclaimed_reward(accounts(0), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let unclaimed = contract.get_unclaimed_reward(accounts(3), farm_id.clone());
        assert_eq!(unclaimed.0, to_yocto("0"));
        let farm_info = contract.get_farm(farm_id.clone()).expect("Error");
        assert_eq!(farm_info.cur_round, 7);
        assert_eq!(farm_info.last_round, 7);
        assert_eq!(farm_info.claimed_reward.0, to_yocto("6.999999999999999999999999"));
        assert_eq!(farm_info.unclaimed_reward.0, 1);
        
    }

    #[test]
    #[should_panic(expected = "E11: insufficient $NEAR storage deposit")]
    fn test_storage_withdraw() {
        let (mut context, mut contract) = setup_contract();
        // Farmer1 accounts(0) come in round 0
        register_farmer(&mut context, &mut contract, accounts(0));
        // println!("locked: {}, deposited: {}", sb.total.0, sb.available.0);
        let sb = storage_withdraw(&mut context, &mut contract, accounts(0));
        // println!("locked: {}, deposited: {}", sb.total.0, sb.available.0);
        assert_eq!(sb.total.0, 920000000000000000000);
        assert_eq!(sb.available.0, 0);

        let farm_id = create_farm(&mut context, &mut contract,
            accounts(1), accounts(2), 5000, 50);
        assert_eq!(farm_id, String::from("bob#0"));

        deposit_seed(&mut context, &mut contract, accounts(0), 60, 10);
    }
}
'''
'''--- ref-farming/src/owner.rs ---
use crate::*;

use near_sdk::json_types::U128;

#[near_bindgen]
impl Contract {
    pub fn set_owner(&mut self, owner_id: ValidAccountId) {
        self.assert_owner();
        self.data_mut().owner_id = owner_id.into();
    }

    /// force clean 
    pub fn force_clean_farm(&mut self, farm_id: String) -> bool {
        self.assert_owner();
        self.internal_remove_farm_by_farm_id(&farm_id)
    }

    pub fn modify_seed_min_deposit(&mut self, seed_id: String, min_deposit: U128) {
        self.assert_owner();
        let mut farm_seed = self.get_seed(&seed_id);
        farm_seed.get_ref_mut().min_deposit = min_deposit.into();
    }

    /// Migration function between versions.
    /// For next version upgrades, change this function.
    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "ERR_NOT_ALLOWED"
        );
        let contract: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");
        contract
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.data().owner_id,
            "ERR_NOT_ALLOWED"
        );
    }
}

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::env::BLOCKCHAIN_INTERFACE;
    use near_sdk::Gas;

    use super::*;

    const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

    /// Gas for calling migration call.
    pub const GAS_FOR_MIGRATE_CALL: Gas = 10_000_000_000_000;

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub extern "C" fn upgrade() {
        env::setup_panic_hook();
        env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));
        let contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_owner();
        let current_id = env::current_account_id().into_bytes();
        let method_name = "migrate".as_bytes().to_vec();
        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input into register 0.
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
                let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_MIGRATE_CALL;
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        attached_gas,
                    );
            });
        }
    }
}
'''
'''--- ref-farming/src/simple_farm.rs ---
//!   The SimpleFarm provide a way to gain farming rewards periodically and 
//! proportionally.
//!   The creator first wrap his reward distribution schema with 
//! `SimpleFarmRewardTerms`, and create the farm with it, attached enough near 
//! for storage fee.
//!   But to enable farming, the creator or someone else should deposit reward 
//! token to the farm, after it was created.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};

use crate::{SeedId, FarmId};
use crate::errors::*;
use crate::utils::*;
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

pub type RPS = [u8; 32];

// to ensure precision, all reward_per_seed would be multiplied by this DENOM
// this value should be carefully choosen, now is 10**24.
pub const DENOM: u128 = 1_000_000_000_000_000_000_000_000;

///   The terms defines how the farm works.
///   In this version, we distribute reward token with a start height, a reward 
/// session interval, and reward amount per session.  
///   In this way, the farm will take the amount from undistributed reward to  
/// unclaimed reward each session. And all farmers would got reward token pro  
/// rata of their seeds.
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct SimpleFarmTerms {
    pub seed_id: SeedId,
    pub reward_token: AccountId,
    pub start_at: TimestampSec,
    pub reward_per_session: Balance,
    pub session_interval: TimestampSec,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct HRSimpleFarmTerms {
    pub seed_id: SeedId,
    pub reward_token: ValidAccountId,
    pub start_at: u32,
    pub reward_per_session: U128,
    pub session_interval: u32, 
}

impl From<&HRSimpleFarmTerms> for SimpleFarmTerms {
    fn from(terms: &HRSimpleFarmTerms) -> Self {
        SimpleFarmTerms {
            seed_id: terms.seed_id.clone(),
            reward_token: terms.reward_token.clone().into(),
            start_at: terms.start_at,
            reward_per_session: terms.reward_per_session.into(),
            session_interval: terms.session_interval,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum SimpleFarmStatus {
    Created, Running, Ended, Cleared
}

impl From<&SimpleFarmStatus> for String {
    fn from(status: &SimpleFarmStatus) -> Self {
        match *status {
            SimpleFarmStatus::Created => { String::from("Created") },
            SimpleFarmStatus::Running => { String::from("Running") },
            SimpleFarmStatus::Ended => { String::from("Ended") },
            SimpleFarmStatus::Cleared => { String::from("Cleared") },
        }
    }
}

/// Reward Distribution Record
#[derive(BorshSerialize, BorshDeserialize, Clone, Default)]
pub struct SimpleFarmRewardDistribution {
    /// unreleased reward
    pub undistributed: Balance,
    /// the total rewards distributed but not yet claimed by farmers.
    pub unclaimed: Balance,
    /// Reward_Per_Seed
    /// rps(cur) = rps(prev) + distributing_reward / total_seed_staked
    pub rps: RPS,
    /// Reward_Round
    /// rr = (cur_block_timestamp in sec - start_at) / session_interval
    pub rr: u32,
}

///   Implementation of simple farm, Similar to the design of "berry farm".
///   Farmer stake their seed to farming on multiple farm accept that seed.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct SimpleFarm {

    pub farm_id: FarmId,
    
    pub terms: SimpleFarmTerms,

    pub status: SimpleFarmStatus,

    pub last_distribution: SimpleFarmRewardDistribution,

    /// total reward send into this farm by far, 
    /// every time reward deposited in, add to this field
    pub amount_of_reward: Balance,
    /// reward token has been claimed by farmer by far
    pub amount_of_claimed: Balance,
    /// when there is no seed token staked, reward goes to beneficiary
    pub amount_of_beneficiary: Balance,

}

impl SimpleFarm {
    pub(crate) fn new(
        id: FarmId,
        terms: SimpleFarmTerms,
    ) -> Self {
        Self {
            farm_id: id.clone(),
            amount_of_reward: 0,
            amount_of_claimed: 0,
            amount_of_beneficiary: 0,

            status: SimpleFarmStatus::Created,
            last_distribution: SimpleFarmRewardDistribution::default(),
            terms,
        }
    }

    /// return None if the farm can not accept reward anymore
    /// else return amount of undistributed reward 
    pub(crate) fn add_reward(&mut self, amount: &Balance) -> Option<Balance> {

        match self.status {
            SimpleFarmStatus::Created => {
                // When a farm gots first deposit of reward, it turns to Running state,
                // but farming or not depends on `start_at` 
                self.status = SimpleFarmStatus::Running;
                if self.terms.start_at == 0 {
                    // for a farm without start time, the first deposit of reward 
                    // would trigger the farming
                    self.terms.start_at = to_sec(env::block_timestamp());
                }
                self.amount_of_reward += amount;
                self.last_distribution.undistributed += amount;
                Some(self.last_distribution.undistributed)
            },
            SimpleFarmStatus::Running => {
                if let Some(dis) = self.try_distribute(&DENOM) {
                    if dis.undistributed == 0 {
                        // farm has ended actually
                        return None;
                    }
                }
                // For a running farm, can add reward to extend duration
                self.amount_of_reward += amount;
                self.last_distribution.undistributed += amount;
                Some(self.last_distribution.undistributed)
            },
            _ => {None},
        }
        
    }

    /// Try to distribute reward according to current timestamp
    /// return None if farm is not in Running state or haven't start farming yet;
    /// return new dis :SimpleFarmRewardDistribution 
    /// Note, if total_seed is 0, the rps in new dis would be reset to 0 too.
    pub(crate) fn try_distribute(&self, total_seeds: &Balance) -> Option<SimpleFarmRewardDistribution> {

        if let SimpleFarmStatus::Running = self.status {
            if env::block_timestamp() < to_nano(self.terms.start_at) {
                // a farm haven't start yet
                return None;
            }
            let mut dis = self.last_distribution.clone();
            // calculate rr according to cur_timestamp
            dis.rr = (to_sec(env::block_timestamp()) - self.terms.start_at) / self.terms.session_interval;
            let mut reward_added = (dis.rr - self.last_distribution.rr) as u128 
                * self.terms.reward_per_session;
            if self.last_distribution.undistributed < reward_added {
                // all undistribution would be distributed this time
                reward_added = self.last_distribution.undistributed;
                // recalculate rr according to undistributed
                let increased_rr = (reward_added / self.terms.reward_per_session) as u32;
                dis.rr = self.last_distribution.rr + increased_rr;
                let reward_caculated = increased_rr as u128 * self.terms.reward_per_session;
                if reward_caculated < reward_added {
                    // add the tail round
                    dis.rr += 1;

                }
                // env::log(
                //     format!(
                //         "Farm ends at Round #{}, unclaimed reward: {}.",
                //         dis.rr, reward_added + dis.unclaimed
                //     )
                //     .as_bytes(),
                // );
            }
            dis.unclaimed += reward_added;
            dis.undistributed -= reward_added;

            // calculate rps
            if total_seeds == &0 {
                U256::from(0).to_little_endian(&mut dis.rps);
            } else {
                (
                    U256::from_little_endian(&self.last_distribution.rps) + 
                    U256::from(reward_added) 
                    * U256::from(DENOM) 
                    / U256::from(*total_seeds)
                ).to_little_endian(&mut dis.rps);
            }
            Some(dis)
        } else {
            None
        }

    }

    /// Return how many reward token that the user hasn't claimed yet.
    /// return (cur_rps - last_user_rps) * user_seeds / DENOM
    pub(crate) fn view_farmer_unclaimed_reward(
        &self,
        user_rps: &RPS,
        user_seeds: &Balance,
        total_seeds: &Balance,
    ) -> Balance {
        if total_seeds == &0 {
            return 0;
        }
        if user_seeds == &0 {
            return 0;
        }
        if let Some(dis) = self.try_distribute(total_seeds) {
            (U256::from(*user_seeds) 
            * (U256::from_little_endian(&dis.rps) - U256::from_little_endian(user_rps))
            / U256::from(DENOM)).as_u128()
        } else {
            (U256::from(*user_seeds) 
            * (U256::from_little_endian(&self.last_distribution.rps) - U256::from_little_endian(user_rps))
            / U256::from(DENOM)).as_u128()
        }
    }

    /// Distribute reward generated from previous distribution to now,
    /// only works for farm in Running state and has reward deposited in,
    /// Note 1, if undistribute equals 0, the farm goes to Ended state;
    /// Note 2, if total_seed is 0, reward is claimed directly by beneficiary
    pub(crate) fn distribute(&mut self, total_seeds: &Balance, silent: bool) {
        if let Some(dis) = self.try_distribute(total_seeds) {
            if self.last_distribution.rr != dis.rr {
                self.last_distribution = dis.clone();
                if total_seeds == &0 {
                    // if total_seeds == &0, reward goes to beneficiary,
                    self.amount_of_claimed += self.last_distribution.unclaimed;
                    self.amount_of_beneficiary += self.last_distribution.unclaimed;
                    self.last_distribution.unclaimed = 0;
                }   
                if !silent {
                    env::log(
                        format!(
                            "{} RPS increased to {} and RR update to #{}",
                            self.farm_id, U256::from_little_endian(&dis.rps), dis.rr,
                        )
                        .as_bytes(),
                    );
                }
                
            }
            if self.last_distribution.undistributed == 0 {
                self.status = SimpleFarmStatus::Ended;
            }
        } 
    }

    /// Claim user's unclaimed reward in this farm,
    /// return the new user RPS (reward per seed),  
    /// and amount of reward 
    pub(crate) fn claim_user_reward(
        &mut self, 
        user_rps: &RPS,
        user_seeds: &Balance, 
        total_seeds: &Balance, 
        silent: bool,
    ) -> (RPS, Balance) {

        self.distribute(total_seeds, silent);
        // if user_seeds == &0 {
        //     return (self.last_distribution.rps, 0);
        // }

        let claimed = (
            U256::from(*user_seeds) 
            * (U256::from_little_endian(&self.last_distribution.rps) - U256::from_little_endian(user_rps))
            / U256::from(DENOM)
        ).as_u128();

        if claimed > 0 {
            assert!(
                self.last_distribution.unclaimed >= claimed, 
                "{} unclaimed:{}, cur_claim:{}", 
                ERR500, self.last_distribution.unclaimed, claimed
            );
            self.last_distribution.unclaimed -= claimed;
            self.amount_of_claimed += claimed;
        }

        (self.last_distribution.rps, claimed)
    }

    /// Move an Ended farm to Cleared, if any unclaimed reward exists, go to beneficiary
    pub(crate) fn move_to_clear(&mut self, total_seeds: &Balance) -> bool {
        if let SimpleFarmStatus::Running = self.status {
            self.distribute(total_seeds, true);
        }
        if let SimpleFarmStatus::Ended = self.status {
            if self.last_distribution.unclaimed > 0 {
                self.amount_of_claimed += self.last_distribution.unclaimed;
                self.amount_of_beneficiary += self.last_distribution.unclaimed;
                self.last_distribution.unclaimed = 0;
            }
            self.status = SimpleFarmStatus::Cleared;
            true
        } else {
            false
        }
    }

    pub fn can_be_removed(&self, total_seeds: &Balance) -> bool {
        match self.status {
            SimpleFarmStatus::Ended => true,
            SimpleFarmStatus::Running => {
                if let Some(dis) = self.try_distribute(total_seeds) {
                    if dis.undistributed == 0 {
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            },
            _ => false,
        }
    }

}

'''
'''--- ref-farming/src/storage_impl.rs ---
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};

use std::convert::TryInto;

use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{assert_one_yocto, env, near_bindgen, Promise, Balance};

use crate::errors::*;
use crate::*;
use crate::farmer::MIN_FARMER_LENGTH;
use crate::utils::MAX_ACCOUNT_LENGTH;

/// Implements users storage management for the pool.
#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {

        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let registration_only = registration_only.unwrap_or(false);

        let (locked, deposited) = self.internal_farmer_storage(&account_id);
        if deposited == 0 {  // new account register
            if amount < Contract::suggested_min_storage_usage() {
                env::panic(format!("{}", ERR11_INSUFFICIENT_STORAGE).as_bytes());
            }
            if registration_only {
                self.internal_register_account(&account_id, Contract::suggested_min_storage_usage());
                let refund = amount - Contract::suggested_min_storage_usage();
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
            } else {
                self.internal_register_account(&account_id, amount);
            }
        } else {  // old account, only can complement storage fee
            if registration_only {
                env::panic(format!("{}", ERR14_ACC_ALREADY_REGISTERED).as_bytes());
            } else {
                if amount+deposited < locked {
                    env::panic(format!("{}", ERR11_INSUFFICIENT_STORAGE).as_bytes());
                }
                self.internal_register_account(&account_id, amount);
            }
        }
        self.storage_balance_of(account_id.try_into().unwrap()).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();

        let account_id = env::predecessor_account_id();        
        let (locked, deposited) = self.internal_farmer_storage(&account_id);
        if deposited > 0 {
            if deposited < locked {
                env::panic(format!("{}", ERR11_INSUFFICIENT_STORAGE).as_bytes());
            }
            let amount = amount.map(|a| a.0).unwrap_or(deposited - locked);
            assert!(deposited >= locked + amount, "{}", ERR11_INSUFFICIENT_STORAGE);
            // TODO: should make sure tranfer is OK with a callback
            let mut farmer = self.get_farmer(&account_id);
            farmer.get_ref_mut().amount -= amount;
            self.data_mut().farmers.insert(&account_id, &farmer);
            Promise::new(account_id.clone()).transfer(amount);
            self.storage_balance_of(account_id.try_into().unwrap()).unwrap()
        } else {
            env::panic(format!("{}", ERR10_ACC_NOT_REGISTERED).as_bytes());
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();

        // force option is useless, leave it for compatible consideration.
        // User should withdraw all his rewards and seeds token before unregister!

        let account_id = env::predecessor_account_id();
        if let Some(farmer) = self.get_farmer_wrapped(&account_id) {
            
            assert!(
                farmer.get_ref().rewards.is_empty(),
                "{}", ERR12_STORAGE_UNREGISTER_REWARDS_NOT_EMPTY
            );
            assert!(
                farmer.get_ref().seeds.is_empty(),
                "{}", ERR13_STORAGE_UNREGISTER_SEED_NOT_EMPTY
            );
            self.data_mut().farmers.remove(&account_id);
            self.data_mut().farmer_count -= 1;
            // TODO: should make sure tranfer is OK with a callback
            Promise::new(account_id.clone()).transfer(farmer.get_ref().amount);
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: Contract::suggested_min_storage_usage().into(),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        let (locked, deposited) = self.internal_farmer_storage(account_id.as_ref()); 
        if locked > 0 {
            Some(StorageBalance {
                total: U128(deposited),
                available: U128(deposited.saturating_sub(locked)),
            })
        } else {
           None
        }
    }
}

impl Contract {

    /// return storage used by given account, and his deposited storage fee 
    /// return [actual_locked, actual_deposit]
    pub(crate) fn internal_farmer_storage(
        &self, 
        account_id: &AccountId
    ) -> (Balance, Balance) {
        let farmer = self.get_farmer_wrapped(account_id);
        if let Some(farmer) = farmer {
            (farmer.get_ref().storage_usage(), farmer.get_ref().amount)
        } else {
           (0, 0)
        }
    }

    pub(crate) fn assert_storage_usage(&self, account_id: &AccountId) {
        let (locked, deposited) = self.internal_farmer_storage(account_id);
        assert!(
            deposited > 0,
            "{}",
            ERR10_ACC_NOT_REGISTERED
        );
        assert!(
            locked <= deposited,
            "{}",
            ERR11_INSUFFICIENT_STORAGE
        );
    }

    /// Returns minimal storage usage possible.
    /// 5 reward tokens, 5 seed tokens, 10 farms as assumption.
    pub(crate) fn suggested_min_storage_usage() -> Balance {
        (
            MIN_FARMER_LENGTH 
            + 2_u128 * 5_u128 * (MAX_ACCOUNT_LENGTH + 16)
            + 10_u128 * (MAX_ACCOUNT_LENGTH + 32)
        ) * env::storage_byte_cost()
    }

    /// add balance to user deposited storage balance, if not registered, auto register.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId, amount: Balance) {

        if let Some(mut farmer) = self.get_farmer_wrapped(&account_id) {
            farmer.get_ref_mut().amount += amount;
            self.data_mut().farmers.insert(&account_id, &farmer);
        } else {
            self.data_mut().farmers.insert(&account_id, &VersionedFarmer::new(account_id.clone(), amount));
            self.data_mut().farmer_count += 1;
        }
    }

}

'''
'''--- ref-farming/src/token_receiver.rs ---
use crate::*;
use crate::errors::*;
use near_sdk::PromiseOrValue;
use near_sdk::json_types::{U128};
use crate::utils::MFT_TAG;
use crate::farm_seed::SeedType;

use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    /// transfer reward token with specific msg indicate 
    /// which farm to be deposited to.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {

        let sender: AccountId = sender_id.into();
        let amount: u128 = amount.into();
        if msg.is_empty() {
            // ****** seed Token deposit in ********

            // if seed not exist, it will panic
            let seed_farm = self.get_seed(&env::predecessor_account_id());
            if amount < seed_farm.get_ref().min_deposit {
                env::panic(
                    format!(
                        "{} {}", 
                        ERR34_BELOW_MIN_SEED_DEPOSITED, 
                        seed_farm.get_ref().min_deposit
                    )
                    .as_bytes()
                )
            }

            self.internal_seed_deposit(
                &env::predecessor_account_id(), 
                &sender, 
                amount.into(), 
                SeedType::FT
            );
            
            self.assert_storage_usage(&sender);

            env::log(
                format!(
                    "{} deposit FT seed {} with amount {}.",
                    sender, env::predecessor_account_id(), amount,
                )
                .as_bytes(),
            );
            PromiseOrValue::Value(U128(0))

        } else {  
            // ****** reward Token deposit in ********
            let farm_id = msg.parse::<FarmId>().expect(&format!("{}", ERR42_INVALID_FARM_ID));
            let mut farm = self.data().farms.get(&farm_id).expect(ERR41_FARM_NOT_EXIST);

            // update farm
            assert_eq!(farm.get_reward_token(), env::predecessor_account_id(), "{}", ERR44_INVALID_FARM_REWARD);
            if let Some(cur_remain) = farm.add_reward(&amount) {
                self.data_mut().farms.insert(&farm_id, &farm);
                let old_balance = self.data().reward_info.get(&env::predecessor_account_id()).unwrap_or(0);
                self.data_mut().reward_info.insert(&env::predecessor_account_id(), &(old_balance + amount));
                
                env::log(
                    format!(
                        "{} added {} Reward Token, Now has {} left",
                        sender, amount, cur_remain
                    )
                    .as_bytes(),
                );
                PromiseOrValue::Value(U128(0))
            } else {
                env::panic(format!("{}", ERR43_INVALID_FARM_STATUS).as_bytes())
            }
        }
        
    }
}

pub trait MFTTokenReceiver {
    fn mft_on_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

enum TokenOrPool {
    Token(AccountId),
    Pool(u64),
}

/// a sub token would use a format ":<u64>"
fn try_identify_sub_token_id(token_id: &String) ->Result<u64, &'static str> {
    if token_id.starts_with(":") {
        if let Ok(pool_id) = str::parse::<u64>(&token_id[1..token_id.len()]) {
            Ok(pool_id)
        } else {
            Err("Illegal pool id")
        }
    } else {
        Err("Illegal pool id")
    }
}

fn parse_token_id(token_id: String) -> TokenOrPool {
    if let Ok(pool_id) = try_identify_sub_token_id(&token_id) {
        TokenOrPool::Pool(pool_id)
    } else {
        TokenOrPool::Token(token_id)
    }
}

/// seed token deposit
#[near_bindgen]
impl MFTTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    fn mft_on_transfer(
        &mut self,
        token_id: String,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
 
        let seed_id: String;
        match parse_token_id(token_id.clone()) {
            TokenOrPool::Pool(pool_id) => {
                seed_id = format!("{}{}{}", env::predecessor_account_id(), MFT_TAG, pool_id);
            }
            TokenOrPool::Token(_) => {
                // for seed deposit, using mft to transfer 'root' token is not supported.
                env::panic(ERR35_ILLEGAL_TOKEN_ID.as_bytes());
            }
        }

        assert!(msg.is_empty(), "ERR_MSG_INCORRECT");

        // if seed not exist, it will panic
        let amount: u128 = amount.into();
        let seed_farm = self.get_seed(&seed_id);
        if amount < seed_farm.get_ref().min_deposit {
            env::panic(
                format!(
                    "{} {}", 
                    ERR34_BELOW_MIN_SEED_DEPOSITED, 
                    seed_farm.get_ref().min_deposit
                )
                .as_bytes()
            )
        }
        
        self.internal_seed_deposit(&seed_id, &sender_id, amount, SeedType::MFT);

        self.assert_storage_usage(&sender_id);

        env::log(
            format!(
                "{} deposit MFT seed {} with amount {}.",
                sender_id, seed_id, amount,
            )
            .as_bytes(),
        );

        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- ref-farming/src/utils.rs ---

use near_sdk::json_types::{U128};
use near_sdk::{env, ext_contract, Gas, Timestamp};
use uint::construct_uint;
use crate::{SeedId, FarmId};
use crate::errors::*;

pub type TimestampSec = u32;

pub const MIN_SEED_DEPOSIT: u128 = 1_000_000_000_000_000_000;
pub const MAX_ACCOUNT_LENGTH: u128 = 64;
/// Amount of gas for fungible token transfers.
pub const GAS_FOR_FT_TRANSFER: Gas = 10_000_000_000_000;
/// Amount of gas for reward token transfers resolve.
pub const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
/// Amount of gas for seed token transfers resolve.
pub const GAS_FOR_RESOLVE_WITHDRAW_SEED: Gas = 80_000_000_000_000;
pub const MFT_TAG: &str = "@";

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// TODO: this should be in the near_standard_contracts
#[ext_contract(ext_fungible_token)]
pub trait FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

/// TODO: this should be in the near_standard_contracts
#[ext_contract(ext_multi_fungible_token)]
pub trait MultiFungibleToken {
    fn mft_transfer(&mut self, token_id: String, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[ext_contract(ext_self)]
pub trait TokenPostActions {
    fn callback_post_withdraw_reward(
        &mut self,
        token_id: AccountId,
        sender_id: AccountId,
        amount: U128,
    );

    fn callback_post_withdraw_ft_seed(
        &mut self,
        seed_id: SeedId,
        sender_id: AccountId,
        amount: U128,
    );

    fn callback_post_withdraw_mft_seed(
        &mut self,
        seed_id: SeedId,
        sender_id: AccountId,
        amount: U128,
    );
}

/// Assert that 1 yoctoNEAR was attached.
pub fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR")
}

/// wrap token_id into correct format in MFT standard
pub fn wrap_mft_token_id(token_id: &str) -> String {
    format!(":{}", token_id)
}

// return receiver_id, token_id
pub fn parse_seed_id(lpt_id: &str) -> (String, String) {
    let v: Vec<&str> = lpt_id.split(MFT_TAG).collect();
    if v.len() == 2 { // receiver_id@pool_id
        (v[0].to_string(), v[1].to_string())
    } else if v.len() == 1 { // receiver_id
        (v[0].to_string(), v[0].to_string())
    } else {
        env::panic(format!("{}", ERR33_INVALID_SEED_ID).as_bytes())
    }
}

pub fn parse_farm_id(farm_id: &FarmId) -> (String, usize) {
    let v: Vec<&str> = farm_id.split("#").collect();
    if v.len() != 2 {
        env::panic(format!("{}", ERR42_INVALID_FARM_ID).as_bytes())
    }
    (v[0].to_string(), v[1].parse::<usize>().unwrap())
}

pub fn gen_farm_id(seed_id: &SeedId, index: usize) -> FarmId {
    format!("{}#{}", seed_id, index)
}

pub(crate) fn to_nano(timestamp: TimestampSec) -> Timestamp {
    Timestamp::from(timestamp) * 10u64.pow(9)
}

pub(crate) fn to_sec(timestamp: Timestamp) -> TimestampSec {
    (timestamp / 10u64.pow(9)) as u32
}

'''
'''--- ref-farming/src/view.rs ---
//! View functions for the contract.

use std::collections::HashMap;

use near_sdk::json_types::{ValidAccountId, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId};

use crate::farm_seed::SeedInfo;
use crate::utils::parse_farm_id;
use crate::simple_farm::DENOM;
use crate::*;

use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Metadata {
    pub version: String,
    pub owner_id: AccountId,
    pub farmer_count: U64,
    pub farm_count: U64,
    pub seed_count: U64,
    pub reward_count: U64,
}

#[derive(Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct StorageState {
    pub deposit: U128,
    pub usage: U128,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FarmInfo {
    pub farm_id: FarmId,
    pub farm_kind: String,
    pub farm_status: String,
    pub seed_id: SeedId,
    pub reward_token: AccountId,
    pub start_at: u32,
    pub reward_per_session: U128,
    pub session_interval: u32,

    pub total_reward: U128,
    pub cur_round: u32,
    pub last_round: u32,
    pub claimed_reward: U128,
    pub unclaimed_reward: U128,
    pub beneficiary_reward: U128,
}

impl From<&Farm> for FarmInfo {
    fn from(farm: &Farm) -> Self {
        let farm_kind = farm.kind();
        match farm {
            Farm::SimpleFarm(farm) => {
                if let Some(dis) = farm.try_distribute(&DENOM) {
                    let mut farm_status: String = (&farm.status).into();
                    if farm_status == "Running".to_string()
                        && dis.undistributed == 0
                    {
                        farm_status = "Ended".to_string();
                    }
                    Self {
                        farm_id: farm.farm_id.clone(),
                        farm_kind,
                        farm_status,
                        seed_id: farm.terms.seed_id.clone(),
                        reward_token: farm.terms.reward_token.clone(),
                        start_at: farm.terms.start_at,
                        reward_per_session: farm.terms.reward_per_session.into(),
                        session_interval: farm.terms.session_interval,

                        total_reward: farm.amount_of_reward.into(),
                        cur_round: dis.rr.into(),
                        last_round: farm.last_distribution.rr.into(),
                        claimed_reward: farm.amount_of_claimed.into(),
                        unclaimed_reward: dis.unclaimed.into(),
                        beneficiary_reward: farm.amount_of_beneficiary.into(),
                    }
                } else {
                    Self {
                        farm_id: farm.farm_id.clone(),
                        farm_kind,
                        farm_status: (&farm.status).into(),
                        seed_id: farm.terms.seed_id.clone(),
                        reward_token: farm.terms.reward_token.clone(),
                        start_at: farm.terms.start_at.into(),
                        reward_per_session: farm.terms.reward_per_session.into(),
                        session_interval: farm.terms.session_interval.into(),
    
                        total_reward: farm.amount_of_reward.into(),
                        cur_round: farm.last_distribution.rr.into(),
                        last_round: farm.last_distribution.rr.into(),
                        claimed_reward: farm.amount_of_claimed.into(),
                        // unclaimed_reward: (farm.amount_of_reward - farm.amount_of_claimed).into(),
                        unclaimed_reward: farm.last_distribution.unclaimed.into(),
                        beneficiary_reward: farm.amount_of_beneficiary.into(),
                    }
                }                
            }
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_metadata(&self) -> Metadata {
        Metadata {
            owner_id: self.data().owner_id.clone(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            farmer_count: self.data().farmer_count.into(),
            farm_count: self.data().farms.len().into(),
            seed_count: self.data().seeds.len().into(),
            reward_count: self.data().reward_info.len().into(),
        }
    }

    /// Returns number of farms.
    pub fn get_number_of_farms(&self) -> u64 {
        self.data().farms.len()
    }

    pub fn get_number_of_outdated_farms(&self) -> u64 {
        self.data().outdated_farms.len()
    }

    /// Returns list of farms of given length from given start index.
    pub fn list_farms(&self, from_index: u64, limit: u64) -> Vec<FarmInfo> {
        let keys = self.data().farms.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| 
                (&self.data().farms.get(&keys.get(index).unwrap()).unwrap()).into()
            )
            .collect()
    }

    pub fn list_outdated_farms(&self, from_index: u64, limit: u64) -> Vec<FarmInfo> {
        let keys = self.data().outdated_farms.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| 
                (&self.data().outdated_farms.get(&keys.get(index).unwrap()).unwrap()).into()
            )
            .collect()
    }

    pub fn list_farms_by_seed(&self, seed_id: SeedId) -> Vec<FarmInfo> {
        self.get_seed(&seed_id)
            .get_ref()
            .farms
            .iter()
            .map(|farm_id| 
                (&self.data().farms.get(&farm_id).unwrap()).into()
            )
            .collect()
    }

    /// Returns information about specified farm.
    pub fn get_farm(&self, farm_id: FarmId) -> Option<FarmInfo> {
        if let Some(farm) = self.data().farms.get(&farm_id) {
            Some((&farm).into())
        } else {
            None
        }
    }

    pub fn get_outdated_farm(&self, farm_id: FarmId) -> Option<FarmInfo> {
        if let Some(farm) = self.data().outdated_farms.get(&farm_id) {
            Some((&farm).into())
        } else {
            None
        }
    }

    pub fn list_rewards_info(&self, from_index: u64, limit: u64) -> HashMap<AccountId, U128> {
        let keys = self.data().reward_info.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                (
                    keys.get(index).unwrap(),
                    self.data()
                        .reward_info
                        .get(&keys.get(index).unwrap())
                        .unwrap_or(0)
                        .into(),
                )
            })
            .collect()
    }

    /// Returns reward token claimed for given user outside of any farms.
    /// Returns empty list if no rewards claimed.
    pub fn list_rewards(&self, account_id: ValidAccountId) -> HashMap<AccountId, U128> {
        self.get_farmer_default(account_id.as_ref())
            .get()
            .rewards
            .into_iter()
            .map(|(acc, bal)| (acc, U128(bal)))
            .collect()
    }

    /// Returns balance of amount of given reward token that ready to withdraw.
    pub fn get_reward(&self, account_id: ValidAccountId, token_id: ValidAccountId) -> U128 {
        self.internal_get_reward(account_id.as_ref(), token_id.as_ref())
            .into()
    }

    pub fn get_unclaimed_reward(&self, account_id: ValidAccountId, farm_id: FarmId) -> U128 {
        let (seed_id, _) = parse_farm_id(&farm_id);

        if let (Some(farmer), Some(farm_seed)) = (
            self.get_farmer_wrapped(account_id.as_ref()),
            self.get_seed_wrapped(&seed_id),
        ) {
            if let Some(farm) = self.data().farms.get(&farm_id) {
                let reward_amount = farm.view_farmer_unclaimed_reward(
                    &farmer.get_ref().get_rps(&farm.get_farm_id()),
                    farmer.get_ref().seeds.get(&seed_id).unwrap_or(&0_u128),
                    &farm_seed.get_ref().amount,
                );
                reward_amount.into()
            } else {
                0.into()
            }
        } else {
            0.into()
        }
    }

    /// return all seed and its amount staked in this contract in a hashmap
    pub fn list_seeds(&self, from_index: u64, limit: u64) -> HashMap<SeedId, U128> {
        let keys = self.data().seeds.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                (
                    keys.get(index).unwrap(),
                    self.get_seed(&keys.get(index).unwrap())
                        .get_ref()
                        .amount
                        .into(),
                )
            })
            .collect()
    }

    /// return user staked seeds and its amount in a hashmap
    pub fn list_user_seeds(&self, account_id: ValidAccountId) -> HashMap<SeedId, U128> {
        if let Some(farmer) = self.get_farmer_wrapped(account_id.as_ref()) {
            farmer
                .get()
                .seeds
                .into_iter()
                .map(|(seed, bal)| (seed.clone(), U128(bal)))
                .collect()
        } else {
            HashMap::new()
        }
    }

    pub fn get_seed_info(&self, seed_id: SeedId) -> Option<SeedInfo> {
        if let Some(farm_seed) = self.get_seed_wrapped(&seed_id) {
            Some(farm_seed.get_ref().into())
        } else {
            None
        }
    }

    pub fn list_seeds_info(&self, from_index: u64, limit: u64) -> HashMap<SeedId, SeedInfo> {
        let keys = self.data().seeds.keys_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                (
                    keys.get(index).unwrap(),
                    self.get_seed(&keys.get(index).unwrap()).get_ref().into(),
                )
            })
            .collect()
    }

    pub fn get_user_rps(&self, account_id: ValidAccountId, farm_id: FarmId) -> String {
        let farmer = self.get_farmer(account_id.as_ref());
        if let Some(rps) = farmer.get().user_rps.get(&farm_id) {
            format!("{}", U256::from_little_endian(&rps))
        } else {
            String::from("0")
        }
    }

    /// Get farmer's storage deposit and needed in the account of current version
    pub fn get_user_storage_state(&self, account_id: ValidAccountId) -> Option<StorageState> {
        let (locked, deposited) = self.internal_farmer_storage(account_id.as_ref()); 
        if locked > 0 {
            Some(StorageState {
                deposit: U128(deposited),
                usage: U128(locked),
            })
        } else {
           None
        }
    }
}

'''
'''--- ref-farming/tests/common/actions.rs ---

use near_sdk::json_types::{U128};
use near_sdk::{Balance};
use near_sdk_sim::{call, to_yocto, ContractAccount, UserAccount};

// use near_sdk_sim::transaction::ExecutionStatus;
use ref_exchange::{ContractContract as TestRef};
use test_token::ContractContract as TestToken;
use ref_farming::{ContractContract as Farming};
use ref_farming::{HRSimpleFarmTerms};
use near_sdk::serde_json::Value;

use super::init::*;
use super::utils::*;

#[allow(dead_code)]
pub(crate) fn prepair_pool_and_liquidity(
    root: &UserAccount, 
    owner: &UserAccount,
    farming_id: String,
    lps: Vec<&UserAccount>,
) -> (ContractAccount<TestRef>, ContractAccount<TestToken>, ContractAccount<TestToken>) {
    let pool = deploy_pool(&root, swap(), owner.account_id());
    let token1 = deploy_token(&root, dai(), vec![swap()]);
    let token2 = deploy_token(&root, eth(), vec![swap()]);
    call!(owner, pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth())]))
    .assert_success();
    call!(root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    ).assert_success();
    call!(root, pool.mft_register(":0".to_string(), to_va(farming_id)), deposit = to_yocto("1"))
    .assert_success();
    for lp in lps {
        add_liquidity(lp, &pool, &token1, &token2, 0);
    }
    (pool,token1, token2)
}

#[allow(dead_code)]
pub(crate) fn prepair_pool(
    root: &UserAccount, 
    owner: &UserAccount, 
) -> (ContractAccount<TestRef>, ContractAccount<TestToken>, ContractAccount<TestToken>) {
    let pool = deploy_pool(&root, swap(), owner.account_id());
    let token1 = deploy_token(&root, dai(), vec![swap()]);
    let token2 = deploy_token(&root, eth(), vec![swap()]);
    call!(
        owner,
        pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth())])
    );
    call!(
        root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    )
    .assert_success();
    (pool, token1, token2)
}

#[allow(dead_code)]
pub(crate) fn prepair_farm(
    root: &UserAccount, 
    owner: &UserAccount,
    token: &ContractAccount<TestToken>,
    total_reward: Balance,
) -> (ContractAccount<Farming>, String) {
    // create farm
    
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", swap()),
            reward_token: to_va(token.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, Some(U128(1000000000000000000))),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    let farm_id: String;
    if let Value::String(farmid) = out_come.unwrap_json_value() {
        farm_id = farmid.clone();
    } else {
        farm_id = String::from("N/A");
    }
    // println!("    Farm {} created at Height#{}", farm_id.clone(), root.borrow_runtime().current_block().block_height);
    
    // deposit reward token
    call!(
        root,
        token.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token, &root, total_reward.into());
    call!(
        root,
        token.ft_transfer_call(to_va(farming_id()), total_reward.into(), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    // println!("    Farm running at Height#{}", root.borrow_runtime().current_block().block_height);

    (farming, farm_id)
}

#[allow(dead_code)]
pub(crate) fn prepair_multi_farms(
    root: &UserAccount, 
    owner: &UserAccount,
    token: &ContractAccount<TestToken>,
    total_reward: Balance,
    farm_count: u32,
) -> (ContractAccount<Farming>, Vec<String>) {
    // create farms
    
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    let mut farm_ids: Vec<String> = vec![];

    // register farming contract to reward token
    call!(
        root,
        token.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();

    mint_token(&token, &root, to_yocto("100000"));

    for _ in 0..farm_count {
        let out_come = call!(
            owner,
            farming.create_simple_farm(HRSimpleFarmTerms{
                seed_id: format!("{}@0", swap()),
                reward_token: to_va(token.account_id()),
                start_at: 0,
                reward_per_session: to_yocto("1").into(),
                session_interval: 60,
            }, Some(U128(1000000000000000000))),
            deposit = to_yocto("1")
        );
        out_come.assert_success();
        let farm_id: String;
        if let Value::String(farmid) = out_come.unwrap_json_value() {
            farm_id = farmid.clone();
        } else {
            farm_id = String::from("N/A");
        }
        call!(
            root,
            token.ft_transfer_call(to_va(farming_id()), total_reward.into(), None, farm_id.clone()),
            deposit = 1
        )
        .assert_success();

        farm_ids.push(farm_id.clone());

        println!("  Farm {} created and running at Height#{}", farm_id.clone(), root.borrow_runtime().current_block().block_height);
    }
    
    (farming, farm_ids)
}

pub(crate) fn add_liquidity(
    user: &UserAccount, 
    pool: &ContractAccount<TestRef>, 
    token1: &ContractAccount<TestToken>, 
    token2: &ContractAccount<TestToken>, 
    pool_id: u64,
) {
    mint_token(&token1, user, to_yocto("105"));
    mint_token(&token2, user, to_yocto("105"));
    call!(
        user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        user,
        token1.ft_transfer_call(to_va(swap()), to_yocto("100").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        user,
        token2.ft_transfer_call(to_va(swap()), to_yocto("100").into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        user,
        pool.add_liquidity(pool_id, vec![U128(to_yocto("100")), U128(to_yocto("100"))], None),
        deposit = to_yocto("0.01")
    )
    .assert_success();
}

pub(crate) fn mint_token(token: &ContractAccount<TestToken>, user: &UserAccount, amount: Balance) {
    // call!(
    //     user,
    //     token.storage_deposit(None, None),
    //     deposit = to_yocto("1")
    // )
    // .assert_success();
    call!(
        user,
        token.mint(to_va(user.account_id.clone()), amount.into())
    ).assert_success();
}

'''
'''--- ref-farming/tests/common/init.rs ---

use super::utils::to_va;

use near_sdk::{AccountId};
use near_sdk_sim::{call, deploy, to_yocto, ContractAccount, UserAccount};

// use near_sdk_sim::transaction::ExecutionStatus;
use ref_exchange::{ContractContract as TestRef};

use test_token::ContractContract as TestToken;
use ref_farming::{ContractContract as Farming};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TEST_TOKEN_WASM_BYTES => "../res/test_token.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
    FARM_WASM_BYTES => "../res/ref_farming_release.wasm",
}

pub fn deploy_farming(root: &UserAccount, farming_id: AccountId, owner_id: AccountId) -> ContractAccount<Farming> {
    let farming = deploy!(
        contract: Farming,
        contract_id: farming_id,
        bytes: &FARM_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va(owner_id))
    );
    farming
}

pub fn deploy_pool(root: &UserAccount, contract_id: AccountId, owner_id: AccountId) -> ContractAccount<TestRef> {
    let pool = deploy!(
        contract: TestRef,
        contract_id: contract_id,
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va(owner_id), 4, 1)
    );
    pool
}

pub fn deploy_token(
    root: &UserAccount,
    token_id: AccountId,
    accounts_to_register: Vec<AccountId>,
) -> ContractAccount<TestToken> {
    let t = deploy!(
        contract: TestToken,
        contract_id: token_id,
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root
    );
    call!(root, t.new()).assert_success();
    // call!(
    //     root,
    //     t.mint(to_va(root.account_id.clone()), to_yocto("10000").into())
    // )
    // .assert_success();
    for account_id in accounts_to_register {
        call!(
            root,
            t.storage_deposit(Some(to_va(account_id)), None),
            deposit = to_yocto("1")
        )
        .assert_success();
    }
    t
}

'''
'''--- ref-farming/tests/common/mod.rs ---
pub mod init;
pub mod utils;
pub mod views;
pub mod actions;

'''
'''--- ref-farming/tests/common/utils.rs ---
use std::convert::TryFrom;
use near_sdk::{AccountId};
use near_sdk::json_types::{ValidAccountId};

pub(crate) fn dai() -> AccountId {
    "dai".to_string()
}

pub(crate) fn eth() -> AccountId {
    "eth".to_string()
}

pub(crate) fn swap() -> AccountId {
    "swap".to_string()
}

pub(crate) fn farming_id() -> AccountId {
    "farming".to_string()
}

pub(crate) fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

'''
'''--- ref-farming/tests/common/views.rs ---
use near_sdk::json_types::{U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk_sim::{view, ContractAccount};

use super::utils::to_va;
use ref_farming::{ContractContract as Farming, FarmInfo};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SeedInfo {
    pub seed_id: String,
    pub seed_type: String,
    pub farms: Vec<String>,
    pub next_index: u32,
    pub amount: U128,
    pub min_deposit: U128,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

#[allow(dead_code)]
pub(crate) fn show_farms_by_seed(
    farming: &ContractAccount<Farming>,
    seed_id: String,
    show_print: bool,
) -> Vec<FarmInfo> {
    let farms_info = view!(farming.list_farms_by_seed(seed_id)).unwrap_json::<Vec<FarmInfo>>();
    if show_print {
        println!("Farms Info has {} farms ===>", farms_info.len());
        for farm_info in farms_info.iter() {
            println!(
                "  ID:{}, Status:{}, Seed:{}, Reward:{}",
                farm_info.farm_id, farm_info.farm_status, farm_info.seed_id, farm_info.reward_token
            );
            println!(
                "  StartAt:{}, SessionReward:{}, SessionInterval:{}",
                farm_info.start_at, farm_info.reward_per_session.0, farm_info.session_interval
            );
            println!(
                "  TotalReward:{}, Claimed:{}, Unclaimed:{}, LastRound:{}, CurRound:{}",
                farm_info.total_reward.0,
                farm_info.claimed_reward.0,
                farm_info.unclaimed_reward.0,
                farm_info.last_round,
                farm_info.cur_round
            );
        }
    }
    farms_info
}

#[allow(dead_code)]
pub(crate) fn show_farminfo(
    farming: &ContractAccount<Farming>,
    farm_id: String,
    show_print: bool,
) -> FarmInfo {
    let farm_info = get_farminfo(farming, farm_id);
    if show_print {
        println!("Farm Info ===>");
        println!(
            "  ID:{}, Status:{}, Seed:{}, Reward:{}",
            farm_info.farm_id, farm_info.farm_status, farm_info.seed_id, farm_info.reward_token
        );
        println!(
            "  StartAt:{}, SessionReward:{}, SessionInterval:{}",
            farm_info.start_at, farm_info.reward_per_session.0, farm_info.session_interval
        );
        println!(
            "  TotalReward:{}, Claimed:{}, Unclaimed:{}, LastRound:{}, CurRound:{}",
            farm_info.total_reward.0,
            farm_info.claimed_reward.0,
            farm_info.unclaimed_reward.0,
            farm_info.last_round,
            farm_info.cur_round
        );
    }
    farm_info
}

#[allow(dead_code)]
pub(crate) fn show_outdated_farminfo(
    farming: &ContractAccount<Farming>,
    farm_id: String,
    show_print: bool,
) -> FarmInfo {
    let farm_info = get_outdated_farminfo(farming, farm_id);
    if show_print {
        println!("Farm Info ===>");
        println!(
            "  ID:{}, Status:{}, Seed:{}, Reward:{}",
            farm_info.farm_id, farm_info.farm_status, farm_info.seed_id, farm_info.reward_token
        );
        println!(
            "  StartAt:{}, SessionReward:{}, SessionInterval:{}",
            farm_info.start_at, farm_info.reward_per_session.0, farm_info.session_interval
        );
        println!(
            "  TotalReward:{}, Claimed:{}, Unclaimed:{}, LastRound:{}, CurRound:{}",
            farm_info.total_reward.0,
            farm_info.claimed_reward.0,
            farm_info.unclaimed_reward.0,
            farm_info.last_round,
            farm_info.cur_round
        );
    }
    farm_info
}

#[allow(dead_code)]
pub(crate) fn show_seedsinfo(
    farming: &ContractAccount<Farming>,
    show_print: bool,
) -> HashMap<String, SeedInfo> {
    let ret = view!(farming.list_seeds_info(0, 100)).unwrap_json::<HashMap<String, SeedInfo>>();
    if show_print {
        for (k, v) in &ret {
            println!("FarmSeed=>  {}: {:#?}", k, v);
        }
    }
    ret
}

#[allow(dead_code)]
pub(crate) fn show_userseeds(
    farming: &ContractAccount<Farming>,
    user_id: String,
    show_print: bool,
) -> HashMap<String, U128> {
    let ret = view!(farming.list_user_seeds(to_va(user_id.clone())))
        .unwrap_json::<HashMap<String, U128>>();
    if show_print {
        println!("User Seeds for {}: {:#?}", user_id, ret);
    }
    ret
}

#[allow(dead_code)]
pub(crate) fn show_unclaim(
    farming: &ContractAccount<Farming>,
    user_id: String,
    farm_id: String,
    show_print: bool,
) -> U128 {
    let farm_info = get_farminfo(farming, farm_id.clone());
    let ret = view!(farming.get_unclaimed_reward(to_va(user_id.clone()), farm_id.clone()))
        .unwrap_json::<U128>();
    if show_print {
        println!(
            "User Unclaimed for {}@{}:[CRR:{}, LRR:{}] {}",
            user_id, farm_id, farm_info.cur_round, farm_info.last_round, ret.0
        );
    }
    ret
}

#[allow(dead_code)]
pub(crate) fn show_reward(
    farming: &ContractAccount<Farming>,
    user_id: String,
    reward_id: String,
    show_print: bool,
) -> U128 {
    let ret = view!(farming.get_reward(to_va(user_id.clone()), to_va(reward_id.clone())))
        .unwrap_json::<U128>();
    if show_print {
        println!("Reward {} for {}: {}", reward_id, user_id, ret.0);
    }
    ret
}

#[allow(dead_code)]
pub(crate) fn show_storage_balance(farming: &ContractAccount<Farming>, farmer: String, show_print: bool) -> StorageBalance {
    let ret = view!(farming.storage_balance_of(to_va(farmer.clone()))).unwrap_json::<StorageBalance>();
    if show_print {
        println!("total {}, available {}", ret.total.0, ret.available.0);
    }
    ret
}

// =============  Assertions  ===============
#[allow(dead_code)]
pub(crate) fn assert_farming(
    farm_info: &FarmInfo,
    farm_status: String,
    total_reward: u128,
    cur_round: u32,
    last_round: u32,
    claimed_reward: u128,
    unclaimed_reward: u128,
    beneficiary_reward: u128,
) {
    assert_eq!(farm_info.farm_status, farm_status);
    assert_eq!(farm_info.total_reward.0, total_reward);
    assert_eq!(farm_info.cur_round, cur_round);
    assert_eq!(farm_info.last_round, last_round);
    assert_eq!(farm_info.claimed_reward.0, claimed_reward);
    assert_eq!(farm_info.unclaimed_reward.0, unclaimed_reward);
    assert_eq!(farm_info.beneficiary_reward.0, beneficiary_reward);
}

// =============  internal methods ================
fn get_farminfo(farming: &ContractAccount<Farming>, farm_id: String) -> FarmInfo {
    view!(farming.get_farm(farm_id)).unwrap_json::<FarmInfo>()
}

fn get_outdated_farminfo(farming: &ContractAccount<Farming>, farm_id: String) -> FarmInfo {
    view!(farming.get_outdated_farm(farm_id)).unwrap_json::<FarmInfo>()
}

'''
'''--- ref-farming/tests/fuzzy/claim.rs ---
use near_sdk_sim::{call, to_yocto, ContractAccount, UserAccount};
use ref_farming::{ContractContract as Farming, FarmInfo};
use ref_exchange::{ContractContract as TestRef};
use rand_pcg::Pcg32;
use crate::fuzzy::{
    constant::*,
    utils::*,
    types::*,
};

pub fn do_claim(ctx: &mut FarmInfo, _rng: &mut Pcg32, root: &UserAccount, operator: &Operator, farming :&ContractAccount<Farming>, pool :&ContractAccount<TestRef>){
    let farm_id = FARM_ID.to_string();
    let stake_count = match show_userseeds(&farming, operator.user.account_id(), false).get(&String::from("swap@0")){
        Some(r) => r.0,
        None => 0
    };
    println!("current farmer stake : {}", stake_count);
    
    if stake_count != 0 {
        let unclaim = show_unclaim(&farming, operator.user.account_id(), farm_id.clone(), false);
        ctx.claimed_reward.0 += unclaim.0;
        ctx.unclaimed_reward.0 -= unclaim.0;
        let out_come = call!(
            operator.user,
            farming.claim_reward_by_farm(farm_id.clone()),
            deposit = 0
        );
        out_come.assert_success();
    } else {
        println!("----->> {} staking lpt.", operator.user.account_id());
        let out_come = call!(
            operator.user,
            pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
            deposit = 1
        );
        out_come.assert_success();
        println!("<<----- {} staked liquidity at #{}, ts:{}.", 
        operator.user.account_id(),
        root.borrow_runtime().current_block().block_height, 
        root.borrow_runtime().current_block().block_timestamp);
    }
    ctx.last_round = ctx.cur_round;
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto(&OPERATION_NUM.to_string()), ctx.cur_round, ctx.last_round, ctx.claimed_reward.0, ctx.unclaimed_reward.0, ctx.beneficiary_reward.0);
    ctx.cur_round += 1;

}
'''
'''--- ref-farming/tests/fuzzy/constant.rs ---
pub const FUZZY_NUM: usize = 2;
pub const OPERATION_NUM: u32 = 10;
pub const FARM_ID: &str = "swap@0#0";
'''
'''--- ref-farming/tests/fuzzy/mod.rs ---
pub mod utils;
pub mod types;
pub mod stake;
pub mod unstake;
pub mod claim;
pub mod constant;
'''
'''--- ref-farming/tests/fuzzy/stake.rs ---
use near_sdk_sim::{call, to_yocto, ContractAccount, UserAccount};
use ref_farming::{ContractContract as Farming, FarmInfo};
use ref_exchange::{ContractContract as TestRef};
use rand_pcg::Pcg32;
use crate::fuzzy::{
    constant::*,
    utils::*,
    types::*,
};

pub fn do_stake(ctx: &mut FarmInfo, _rng: &mut Pcg32, root: &UserAccount, operator: &Operator, farming :&ContractAccount<Farming>, pool :&ContractAccount<TestRef>){
    let farm_id = FARM_ID.to_string();
    let unclaim = show_unclaim(&farming, operator.user.account_id(), farm_id.clone(), false);
    println!("----->> {} staking lpt.", operator.user.account_id());
    let out_come = call!(
        operator.user,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- {} staked liquidity at #{}, ts:{}.", 
    operator.user.account_id(),
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    ctx.claimed_reward.0 += unclaim.0;
    ctx.unclaimed_reward.0 -= unclaim.0;
    ctx.last_round = ctx.cur_round;
    
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto(&OPERATION_NUM.to_string()), ctx.cur_round, ctx.last_round, ctx.claimed_reward.0, ctx.unclaimed_reward.0, ctx.beneficiary_reward.0);
    ctx.cur_round += 1;
}
'''
'''--- ref-farming/tests/fuzzy/types.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk_sim::UserAccount;
use near_sdk::json_types::U128;
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[derive(Debug)]
pub enum Preference {
    Stake,
    Unstake,
    Claim,
}

#[derive(Debug)]
pub struct Operator {
    pub user: UserAccount,
    pub preference: Preference
}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SeedInfo {
    pub seed_id: String,
    pub seed_type: String,
    pub farms: Vec<String>,
    pub next_index: u32,
    pub amount: U128,
    pub min_deposit: U128,
}
'''
'''--- ref-farming/tests/fuzzy/unstake.rs ---
use near_sdk_sim::{call, to_yocto, ContractAccount, UserAccount};
use ref_farming::{ContractContract as Farming, FarmInfo};
use ref_exchange::{ContractContract as TestRef};
use rand_pcg::Pcg32;
use crate::fuzzy::{
    constant::*,
    utils::*,
    types::*,
};

pub fn do_unstake(ctx: &mut FarmInfo, _rng: &mut Pcg32, root: &UserAccount, operator: &Operator, farming :&ContractAccount<Farming>, pool :&ContractAccount<TestRef>){
    let farm_id = FARM_ID.to_string();
    let stake_count = match show_userseeds(&farming, operator.user.account_id(), false).get(&String::from("swap@0")){
        Some(r) => r.0,
        None => 0
    };
    println!("current farmer stake : {}", stake_count);
    if stake_count != 0 {
        let unclaim = show_unclaim(&farming, operator.user.account_id(), farm_id.clone(), false);
        ctx.claimed_reward.0 += unclaim.0;
        ctx.unclaimed_reward.0 -= unclaim.0;
        
        let farm_info = show_farminfo(&farming, farm_id.clone(), false);
        let out_come = call!(
            operator.user,
            farming.withdraw_seed(farm_info.seed_id.clone(), to_yocto("1").into()),
            deposit = 1
        );
        out_come.assert_success();
    } else {
        println!("----->> {} staking lpt.", operator.user.account_id());
        let out_come = call!(
            operator.user,
            pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
            deposit = 1
        );
        out_come.assert_success();
        println!("<<----- {} staked liquidity at #{}, ts:{}.", 
        operator.user.account_id(),
        root.borrow_runtime().current_block().block_height, 
        root.borrow_runtime().current_block().block_timestamp);
    }
    ctx.last_round = ctx.cur_round;
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto(&OPERATION_NUM.to_string()), ctx.cur_round, ctx.last_round, ctx.claimed_reward.0, ctx.unclaimed_reward.0, ctx.beneficiary_reward.0);
    ctx.cur_round += 1;
}
'''
'''--- ref-farming/tests/fuzzy/utils.rs ---
use near_sdk::json_types::{U128};
use near_sdk::{Balance, AccountId};
use near_sdk_sim::{call, deploy, view, init_simulator, to_yocto, ContractAccount, UserAccount};
// use near_sdk_sim::transaction::ExecutionStatus;
use ref_exchange::{ContractContract as TestRef};
use test_token::ContractContract as TestToken;
use ref_farming::{HRSimpleFarmTerms, ContractContract as Farming, FarmInfo};
use near_sdk::serde_json::Value;
use near_sdk::json_types::{ValidAccountId};
use std::convert::TryFrom;
use std::collections::HashMap;
use crate::fuzzy::{
    constant::*,
    types::*,
};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TEST_TOKEN_WASM_BYTES => "../res/test_token.wasm",
    EXCHANGE_WASM_BYTES => "../res/ref_exchange_release.wasm",
    FARM_WASM_BYTES => "../res/ref_farming_release.wasm",
}

pub fn deploy_farming(root: &UserAccount, farming_id: AccountId, owner_id: AccountId) -> ContractAccount<Farming> {
    let farming = deploy!(
        contract: Farming,
        contract_id: farming_id,
        bytes: &FARM_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va(owner_id))
    );
    farming
}

pub fn deploy_pool(root: &UserAccount, contract_id: AccountId, owner_id: AccountId) -> ContractAccount<TestRef> {
    let pool = deploy!(
        contract: TestRef,
        contract_id: contract_id,
        bytes: &EXCHANGE_WASM_BYTES,
        signer_account: root,
        init_method: new(to_va(owner_id), 4, 1)
    );
    pool
}

pub fn deploy_token(
    root: &UserAccount,
    token_id: AccountId,
    accounts_to_register: Vec<AccountId>,
) -> ContractAccount<TestToken> {
    let t = deploy!(
        contract: TestToken,
        contract_id: token_id,
        bytes: &TEST_TOKEN_WASM_BYTES,
        signer_account: root
    );
    call!(root, t.new()).assert_success();
    for account_id in accounts_to_register {
        call!(
            root,
            t.storage_deposit(Some(to_va(account_id)), None),
            deposit = to_yocto("1")
        )
        .assert_success();
    }
    t
}

pub fn dai() -> AccountId {
    "dai".to_string()
}

pub fn eth() -> AccountId {
    "eth".to_string()
}

pub fn swap() -> AccountId {
    "swap".to_string()
}

pub fn farming_id() -> AccountId {
    "farming".to_string()
}

pub fn to_va(a: AccountId) -> ValidAccountId {
    ValidAccountId::try_from(a).unwrap()
}

pub fn prepair_env(
) -> (UserAccount, UserAccount, ContractAccount<Farming>, ContractAccount<TestRef>, Vec<Operator>) {

    let root = init_simulator(None);

    println!("----->> Prepare accounts.");
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer_stake = root.create_user("farmer_stake".to_string(), to_yocto("100"));
    let farmer_unstake = root.create_user("farmer_unstake".to_string(), to_yocto("100"));
    let farmer_claim = root.create_user("farmer_claim".to_string(), to_yocto("100"));
    println!("<<----- owner and 3 farmers prepared.");

    println!("----->> Deploy farming and register farmers.");
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer_stake, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    call!(farmer_unstake, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    call!(farmer_claim, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    println!("<<----- farming deployed, farmers registered.");

    let pool = deploy_pool(&root, swap(), owner.account_id());
    let token1 = deploy_token(&root, dai(), vec![swap()]);
    let token2 = deploy_token(&root, eth(), vec![swap()]);
    call!(owner, pool.extend_whitelisted_tokens(vec![to_va(dai()), to_va(eth())]))
    .assert_success();

    call!(root,
        pool.add_simple_pool(vec![to_va(dai()), to_va(eth())], 25),
        deposit = to_yocto("1")
    ).assert_success();

    call!(root, pool.mft_register(":0".to_string(), to_va(farming_id())), deposit = to_yocto("1"))
    .assert_success();

    add_liqudity(&farmer_stake, &pool, &token1, &token2, 0);
    add_liqudity(&farmer_unstake, &pool, &token1, &token2, 0);
    add_liqudity(&farmer_claim, &pool, &token1, &token2, 0);
    call!(
        farmer_stake,
        pool.add_liquidity(0, vec![to_yocto(&(10 * OPERATION_NUM).to_string()).into(), to_yocto(&(10 * OPERATION_NUM).to_string()).into()], None),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    println!("----->> Create farm.");
    let farm_id = FARM_ID.to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    assert_eq!(Value::String(farm_id.clone()), out_come.unwrap_json_value());
    println!("<<----- Farm {} created at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> Deposit reward to turn farm Running.");
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto(&OPERATION_NUM.to_string()));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto(&OPERATION_NUM.to_string())), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    show_farminfo(&farming, farm_id.clone(), true);
    println!("<<----- Farm {} deposit reward at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    (root, owner, farming, pool, vec![Operator{user: farmer_stake, preference: Preference::Stake}, Operator{user: farmer_unstake, preference: Preference::Unstake}, Operator{user: farmer_claim, preference: Preference::Claim}])
}

pub fn add_liqudity(
    user: &UserAccount, 
    pool: &ContractAccount<TestRef>, 
    token1: &ContractAccount<TestToken>, 
    token2: &ContractAccount<TestToken>, 
    pool_id: u64,
) {
    mint_token(&token1, user, to_yocto(&(100 * OPERATION_NUM).to_string()));
    mint_token(&token2, user, to_yocto(&(100 * OPERATION_NUM).to_string()));
    call!(
        user,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        user,
        token1.ft_transfer_call(to_va(swap()), to_yocto(&(100 * OPERATION_NUM).to_string()).into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        user,
        token2.ft_transfer_call(to_va(swap()), to_yocto(&(100 * OPERATION_NUM).to_string()).into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        user,
        pool.add_liquidity(pool_id, vec![U128(to_yocto("10")), U128(to_yocto("10"))], None),
        deposit = to_yocto("0.01")
    )
    .assert_success();
}

pub fn mint_token(token: &ContractAccount<TestToken>, user: &UserAccount, amount: Balance) {
    call!(
        user,
        token.mint(to_va(user.account_id.clone()), amount.into())
    ).assert_success();
}

pub fn show_farminfo(
    farming: &ContractAccount<Farming>,
    farm_id: String,
    show_print: bool,
) -> FarmInfo {
    let farm_info = get_farminfo(farming, farm_id);
    if show_print {
        println!("Farm Info ===>");
        println!(
            "  ID:{}, Status:{}, Seed:{}, Reward:{}",
            farm_info.farm_id, farm_info.farm_status, farm_info.seed_id, farm_info.reward_token
        );
        println!(
            "  StartAt:{}, SessionReward:{}, SessionInterval:{}",
            farm_info.start_at, farm_info.reward_per_session.0, farm_info.session_interval
        );
        println!(
            "  TotalReward:{}, Claimed:{}, Unclaimed:{}, LastRound:{}, CurRound:{}",
            farm_info.total_reward.0,
            farm_info.claimed_reward.0,
            farm_info.unclaimed_reward.0,
            farm_info.last_round,
            farm_info.cur_round
        );
    }
    farm_info
}

fn get_farminfo(farming: &ContractAccount<Farming>, farm_id: String) -> FarmInfo {
    view!(farming.get_farm(farm_id)).unwrap_json::<FarmInfo>()
}

pub fn show_userseeds(
    farming: &ContractAccount<Farming>,
    user_id: String,
    show_print: bool,
) -> HashMap<String, U128> {
    let ret = view!(farming.list_user_seeds(to_va(user_id.clone())))
        .unwrap_json::<HashMap<String, U128>>();
    if show_print {
        println!("User Seeds for {}: {:#?}", user_id, ret);
    }
    ret
}

pub(crate) fn show_unclaim(
    farming: &ContractAccount<Farming>,
    user_id: String,
    farm_id: String,
    show_print: bool,
) -> U128 {
    let farm_info = get_farminfo(farming, farm_id.clone());
    let ret = view!(farming.get_unclaimed_reward(to_va(user_id.clone()), farm_id.clone()))
        .unwrap_json::<U128>();
    if show_print {
        println!(
            "User Unclaimed for {}@{}:[CRR:{}, LRR:{}] {}",
            user_id, farm_id, farm_info.cur_round, farm_info.last_round, ret.0
        );
    }
    ret
}

pub fn assert_farming(
    farm_info: &FarmInfo,
    farm_status: String,
    total_reward: u128,
    cur_round: u32,
    last_round: u32,
    claimed_reward: u128,
    unclaimed_reward: u128,
    beneficiary_reward: u128,
) {
    assert_eq!(farm_info.farm_status, farm_status);
    assert_eq!(farm_info.total_reward.0, total_reward);
    assert_eq!(farm_info.cur_round, cur_round);
    assert_eq!(farm_info.last_round, last_round);
    assert_eq!(farm_info.claimed_reward.0, claimed_reward);
    assert_eq!(farm_info.unclaimed_reward.0, unclaimed_reward);
    assert_eq!(farm_info.beneficiary_reward.0, beneficiary_reward);
}
'''
'''--- ref-farming/tests/test_failures.rs ---
use near_sdk_sim::{call, init_simulator, to_yocto};
use near_sdk::json_types::{U128};
use ref_farming::{HRSimpleFarmTerms};

use crate::common::utils::*;
use crate::common::init::deploy_farming;
use crate::common::views::*;
use crate::common::actions::*;

mod common;

#[test]
fn failure_e10_stake_before_register() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), U128(to_yocto("0.5")), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E10: account not registered"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());
}

#[test]
fn failure_e10_unstake_before_register() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        farming.withdraw_seed("swap@0".to_string(), to_yocto("0.6").into()),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E10: account not registered"));
}

#[test]
fn failure_e10_claim_before_register() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E10: account not registered"));

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm("swap@0#0".to_string()),
        deposit = 0
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E10: account not registered"));
}

#[test]
fn failure_e10_storage_withdraw_before_register() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    // let (pool, token1, token2) = prepair_pool_and_liquidity(
    //     &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    let out_come = call!(
        farmer1,
        farming.storage_withdraw(None),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E10: account not registered"));
}

#[test]
fn failure_e11_create_farm() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("0.00001")
    );
    assert!(!out_come.is_ok());
    // println!("{:#?}", out_come.promise_results());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
}

#[test]
fn failure_e11_register_new() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    // let (pool, token1, token2) = prepair_pool_and_liquidity(
    //     &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    let out_come = call!(farmer1, farming.storage_deposit(None, Some(true)), deposit = to_yocto("0.0001"));
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
}

#[test]
fn failure_e11_stake() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    call!(farmer1, farming.storage_withdraw(None), deposit = 1).assert_success();
    // call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());
}

#[test]
fn failure_e11_claim() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    

    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    call!(farmer1, farming.storage_withdraw(None), deposit = 1).assert_success();

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("0"));

    let out_come = call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1"));
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("1.00341"));
    assert_eq!(sb.available.0, to_yocto("1"));
    
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    out_come.assert_success();
}

#[test]
fn failure_e12_e13() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    

    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    let out_come = call!(farmer1, farming.storage_unregister(None), deposit = 1);
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E13: still has staked seed when unregister"));

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    out_come.assert_success();

    let out_come = call!(farmer1, farming.storage_unregister(None), deposit = 1);
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E12: still has rewards when unregister"));

    show_storage_balance(&farming, farmer1.account_id(), false);
}

#[test]
fn failure_e14() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    
    let out_come = call!(farmer1, farming.storage_deposit(None, Some(true)), deposit = to_yocto("1"));
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E14: account already registered"));

    call!(farmer1, farming.storage_deposit(None, Some(false)), deposit = to_yocto("1")).assert_success();

    let sb = show_storage_balance(&farming, farmer1.account_id(), false);
    assert_eq!(sb.total.0, to_yocto("2"));
}

#[test]
fn failure_e21_e22() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    

    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());

    let out_come = call!(
        farmer1,
        farming.withdraw_reward(token1.valid_account_id(), None),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E21: token not registered"));

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    out_come.assert_success();

    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("1"));

    let out_come = call!(
        farmer1,
        farming.withdraw_reward(token1.valid_account_id(), Some(U128(to_yocto("1.1")))),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E22: not enough tokens in deposit"));

    let out_come = call!(
        farmer1,
        farming.withdraw_reward(token1.valid_account_id(), None),
        deposit = 1
    );
    out_come.assert_success();

    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("0"));

}

#[test]
fn failure_e25_withdraw_reward() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    

    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed("swap@0".to_string()),
        deposit = 0
    );
    out_come.assert_success();

    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("1"));

    call!(farmer1, token1.storage_unregister(Some(true)), deposit = 1).assert_success();

    let out_come = call!(
        farmer1,
        farming.withdraw_reward(token1.valid_account_id(), None),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("The account farmer1 is not registered"));

    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("1"));
}

#[test]
fn failure_e25_withdraw_seed_ft() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (_, token1, token2) = prepair_pool(&root, &owner);

    call!(
        root, token2.mint(farmer1.valid_account_id(), to_yocto("10000").into())
    )
    .assert_success();

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    call!(farming.user_account, token2.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}", token2.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, Some(U128(100))),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        token2.ft_transfer_call(to_va(farming_id()), U128(500), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    call!(farmer1, token2.storage_unregister(Some(true)), deposit = 1).assert_success();

    let out_come = call!(
        farmer1,
        farming.withdraw_seed(token2.account_id(), U128(100)),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("The account farmer1 is not registered"));

    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&format!("{}", token2.account_id())).unwrap().0, 500);
}

#[test]
fn failure_e31_unstake_seed() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        farming.withdraw_seed(format!("{}@1", pool.account_id()), to_yocto("0.5").into()),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E31: seed not exist"));
}

#[test]
fn failure_e31_stake_seed() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, _, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E31: seed not exist"));
}

#[test]
fn failure_e32_unstake_over_balance() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), U128(to_yocto("0.5")), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let out_come = call!(
        farmer1,
        farming.withdraw_seed("swap@0".to_string(), to_yocto("0.6").into()),
        deposit = 1
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E32: not enough amount of seed"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("0.5"));
}

#[test]
fn failure_e33() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0@3", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    assert!(!out_come.is_ok());
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E33: invalid seed id"));
}

#[test]
fn failure_e34_stake_below_minimum() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.0000001").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    // println!("ex_status: {}", ex_status);
    assert!(ex_status.contains("E34: below min_deposit of this seed"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());
}

#[test]
fn failure_e41_when_deposit_reward_token() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit reward
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    // call with INVALID farm id
    mint_token(&token1, &root, to_yocto("10"));
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, "swap@0#1".to_string().clone()),
        deposit = 1
    );
    calldata.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E41: farm not exist"));
}

#[test]
fn failure_e42_when_force_clean_farm() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farm_id = "swap@0#0".to_string();
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit reward
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();

    // farmer1 staking lpt 
    println!("----->> Farmer1 staking lpt.");
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    // move to 90 seconds later
    assert!(root.borrow_runtime_mut().produce_blocks(90).is_ok());

    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("1"), 1, 0, 0, to_yocto("1"), 0);

    let out_come = call!(
        owner,
        farming.force_clean_farm("swap".to_string().clone()),
        deposit = 0
    );
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E42: invalid farm id"));
}

#[test]
fn failure_e42_when_claim_reward() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farm_id = "swap@0#0".to_string();
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit reward
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();

    // farmer1 staking lpt 
    println!("----->> Farmer1 staking lpt.");
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm("swap".to_string().clone()),
        deposit = 0
    );
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E42: invalid farm id"));
}

#[test]
fn failure_e42_when_remove_user_rps_and_view_unclaim_reward() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farm_id = "swap@0#0".to_string();
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit reward
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();

    // farmer1 staking lpt 
    println!("----->> Farmer1 staking lpt.");
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    // should panic when remove_user_rps_by_farm
    let out_come = call!(
        farmer1,
        farming.remove_user_rps_by_farm("swap".to_string().clone()),
        deposit = 0
    );
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E42: invalid farm id"));

    // should panic when get_unclaim_reward
    let out_come = call!(
        farmer1,
        farming.get_unclaimed_reward(to_va(farmer1.account_id()), "swap".to_string().clone()),
        deposit = 0
    );
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E42: invalid farm id"));
}

#[test]
fn failure_e43() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farm_id = "swap@0#0".to_string();
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit reward
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();

    // farmer1 staking lpt 
    println!("----->> Farmer1 staking lpt.");
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();

    // move to 90 seconds later
    assert!(root.borrow_runtime_mut().produce_blocks(90).is_ok());

    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("1"), 1, 0, 0, to_yocto("1"), 0);

    // should panic when trying to deposit again
    let calldata = call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();
    let ex_status = format!("{:?}", calldata.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E43: invalid farm status"));
}

#[test]
fn failure_e44() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, token2) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farm_id = "swap@0#0".to_string();
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: to_va(token1.account_id()),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    // deposit wrong reward
    mint_token(&token2, &root, to_yocto("10"));
    call!(
        root,
        token2.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    let calldata = call!(
        root,
        token2.ft_transfer_call(to_va(farming_id()), U128(to_yocto("1")), None, farm_id.clone()),
        deposit = 1
    );
    calldata.assert_success();
    let ex_status = format!("{:?}", calldata.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E44: invalid reward token for this farm"));
}

'''
'''--- ref-farming/tests/test_fuzzy.rs ---
use near_sdk_sim::{
    view, call, ContractAccount, UserAccount,to_yocto
};
use rand::{Rng, SeedableRng};
use rand_pcg::Pcg32;
use ref_farming::{ContractContract as Farming, FarmInfo};
use ref_exchange::{ContractContract as TestRef};
mod fuzzy;
use fuzzy::{
    utils::*,
    types::*,
    stake::*,
    unstake::*,
    claim::*,
    constant::*
};

pub fn get_operator<'a>(rng: &mut Pcg32, users: &'a Vec<Operator>) -> &'a Operator{
    let user_index = rng.gen_range(0..users.len());
    &users[user_index]
}

pub fn do_operation(ctx: &mut FarmInfo, rng: &mut Pcg32, root: &UserAccount, operator: &Operator, farming :&ContractAccount<Farming>, pool :&ContractAccount<TestRef>){
    println!("seedinfo -- {:?}", view!(farming.get_seed_info(format!("{}@0", pool.account_id()))).unwrap_json::<SeedInfo>());
    println!("farminfo -- {:?}", view!(farming.get_farm(FARM_ID.to_string())).unwrap_json::<FarmInfo>());
    match operator.preference{
        Preference::Stake => {
            do_stake(ctx, rng, root, operator, farming, pool);
        },
        Preference::Unstake => {
            do_unstake(ctx, rng, root, operator, farming, pool);
        },
        Preference::Claim => {
            do_claim(ctx, rng, root, operator, farming, pool);
        },
    }
    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    
    if view!(farming.get_seed_info(format!("{}@0", pool.account_id()))).unwrap_json::<SeedInfo>().amount.0 == 0{
        ctx.claimed_reward.0 += to_yocto("1");
        ctx.beneficiary_reward.0 += to_yocto("1");
    }else{
        ctx.unclaimed_reward.0 += to_yocto("1");
    }
}

fn generate_fuzzy_seed() -> Vec<u64>{
    let mut seeds:Vec<u64> = Vec::new();

    let mut rng = rand::thread_rng();
    for _ in 0..FUZZY_NUM {
        let seed: u64 = rng.gen();
        seeds.push(seed);
    }
    seeds
}

#[test]
fn test_fuzzy(){

    let seeds = generate_fuzzy_seed();
    for seed in seeds {

        println!("*********************************************");
        println!("current seed : {}", seed);
        println!("*********************************************");

        let (root, owner, farming, pool, users) = prepair_env();

        let mut rng = Pcg32::seed_from_u64(seed as u64);
        let mut ctx = view!(farming.get_farm(FARM_ID.to_string())).unwrap_json::<FarmInfo>().clone();
        for i in 0..OPERATION_NUM{
            let operator = get_operator(&mut rng, &users);
            println!("NO.{} : {:?}", i, operator);
            do_operation(&mut ctx, &mut rng, &root, operator, &farming, &pool);
        }
        let farm_info = show_farminfo(&farming, FARM_ID.to_string(), false);
        assert_farming(&farm_info, "Ended".to_string(), to_yocto(&OPERATION_NUM.to_string()), ctx.cur_round, ctx.last_round, ctx.claimed_reward.0, ctx.unclaimed_reward.0, ctx.beneficiary_reward.0);
        let out_come = call!(
            owner,
            farming.force_clean_farm(FARM_ID.to_string()),
            deposit = 0
        );
        out_come.assert_success();
        assert_farming(&farm_info, "Ended".to_string(), to_yocto(&OPERATION_NUM.to_string()), ctx.cur_round, ctx.last_round, ctx.claimed_reward.0, ctx.unclaimed_reward.0, ctx.beneficiary_reward.0);
    }
}
'''
'''--- ref-farming/tests/test_migrate.rs ---
use std::convert::TryFrom;

use near_sdk::json_types::ValidAccountId;
use near_sdk_sim::{deploy, init_simulator, to_yocto};

use ref_farming::ContractContract as Farming;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    PREV_FARMING_WASM_BYTES => "../res/ref_farming_local.wasm",
    FARMING_WASM_BYTES => "../res/ref_farming_release.wasm",
}

#[test]
fn test_upgrade() {
    let root = init_simulator(None);
    let test_user = root.create_user("test".to_string(), to_yocto("100"));
    let farming = deploy!(
        contract: Farming,
        contract_id: "farming".to_string(),
        bytes: &PREV_FARMING_WASM_BYTES,
        signer_account: root,
        init_method: new(ValidAccountId::try_from(root.account_id.clone()).unwrap())
    );

    // Failed upgrade with no permissions.
    let result = test_user
        .call(
            farming.user_account.account_id.clone(),
            "upgrade",
            &PREV_FARMING_WASM_BYTES,
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .status();
    assert!(format!("{:?}", result).contains("ERR_NOT_ALLOWED"));

    // Upgrade with calling migration. Should fail as currently migration not implemented
    root.call(
        farming.user_account.account_id.clone(),
        "upgrade",
        &FARMING_WASM_BYTES,
        near_sdk_sim::DEFAULT_GAS,
        0,
    )
    .assert_success();

    // Upgrade to the same code without migration is successful.
    root.call(
        farming.user_account.account_id.clone(),
        "upgrade",
        &FARMING_WASM_BYTES,
        near_sdk_sim::DEFAULT_GAS,
        0,
    )
    .assert_success();
}

'''
'''--- ref-farming/tests/test_multi_farms.rs ---
use near_sdk_sim::{call, init_simulator, to_yocto, view};
use near_sdk::json_types::{U128};
use near_sdk::serde_json::Value;

use ref_farming::{HRSimpleFarmTerms};

use crate::common::utils::*;
use crate::common::views::*;
use crate::common::actions::*;
use crate::common::init::deploy_farming;

mod common;

#[test]
fn multi_farm_in_single_seed() {
    let root = init_simulator(None);

    // prepair users
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer = root.create_user("farmer".to_string(), to_yocto("100"));
    println!("----->> owner and farmer prepaired.");

    // prepair pool and tokens
    let(pool, token1, token2) = prepair_pool(&root, &owner);
    println!("----->> The pool prepaired.");

    // farmer add liqidity 
    add_liquidity(&farmer, &pool, &token1, &token2, 0);
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), to_va(farmer.account_id.clone())))
            .unwrap_json::<U128>()
            .0,
        to_yocto("1")
    );
    println!("----->> Liquidity added by farmer.");

    // create farm with token1
    let (farming, farm_ids) = prepair_multi_farms(&root, &owner, &token1, to_yocto("10"), 32);
    let farm_id = farm_ids[farm_ids.len() - 1].clone();
    println!("----->> Farm till {} is ready.", farm_id.clone());

    // register LP token to farming contract
    call!(root, pool.mft_register(":0".to_string(), to_va(farming_id())), deposit = to_yocto("1"))
    .assert_success();
    println!("----->> Registered LP 0 to {}.", farming_id());
    // register farmer to farming contract and stake liquidity token
    call!(farmer, farming.storage_deposit(None, None), deposit = to_yocto("1"))
    .assert_success();
    println!("----->> Registered farmer to {}.", farming_id());
    let out_come = call!(
        farmer,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 0, 0, 0, 0, 0);
    let user_seeds = show_userseeds(&farming, farmer.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("0.5"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    show_seedsinfo(&farming, false);
    println!("----->> Farmer staked liquidity at #{}.", root.borrow_runtime().current_block().block_height);

    // chain goes for 60 blocks
    if root.borrow_runtime_mut().produce_blocks(60).is_ok() {
        println!();
        println!("*** Chain goes for 60 blocks *** now height: {}", 
            root.borrow_runtime().current_block().block_height,
        );
        let farm_info = show_farminfo(&farming, farm_id.clone(), false);
        assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 1, 0, 0, to_yocto("1"), 0);
        let unclaim = show_unclaim(&farming, farmer.account_id(), farm_id.clone(), false);
        assert_eq!(unclaim.0, to_yocto("1"));
    }

    // farmer claim reward
    println!();
    println!("********** Farmer claim reward by seed_id ************");

    let out_come = call!(
        farmer,
        farming.claim_reward_by_seed(String::from("swap@0")),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    // println!(
    //     "profile_data: {:#?} \n\ntokens_burnt: {} Near", 
    //     out_come.profile_data(), 
    //     (out_come.tokens_burnt()) as f64 / 1e24
    // );
    println!("\ntokens_burnt: {} Near", (out_come.tokens_burnt()) as f64 / 1e24);
    println!("Gas_burnt: {} TGas \n", (out_come.gas_burnt()) as f64 / 1e12);
    // make sure the total gas is less then 300T
    assert!(out_come.gas_burnt() < 300 * u64::pow(10, 12));

    // println!("profile_data: {:#?} \n", out_come.profile_data());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 1, 1, to_yocto("1"), 0, 0);
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    println!("----->> Farmer claimed reward at #{}.", root.borrow_runtime().current_block().block_height);

    // chain goes for 60 blocks
    if root.borrow_runtime_mut().produce_blocks(60).is_ok() {
        println!();
        println!("*** Chain goes for 60 blocks *** now height: {}", 
            root.borrow_runtime().current_block().block_height,
        );
        let farm_info = show_farminfo(&farming, farm_id.clone(), false);
        assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 2, 1, to_yocto("1"), to_yocto("1"), 0);
        let unclaim = show_unclaim(&farming, farmer.account_id(), farm_id.clone(), false);
        assert_eq!(unclaim.0, to_yocto("1"));
    }

    // add lptoken
    println!();
    println!("********** Farmer add seed ************");
    let out_come = call!(
        farmer,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("\ntokens_burnt: {} Near", (out_come.tokens_burnt()) as f64 / 1e24);
    println!("Gas_burnt: {} TGas \n", (out_come.gas_burnt()) as f64 / 1e12);

    let user_seeds = show_userseeds(&farming, farmer.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 2, 2, to_yocto("2"), 0, 0);
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    println!("----->> Farmer added seed at #{}.", root.borrow_runtime().current_block().block_height);

}

#[test]
fn multi_farm_with_different_state() {
    let root = init_simulator(None);

    // prepair users
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer = root.create_user("farmer".to_string(), to_yocto("100"));
    println!("----->> owner and farmer prepaired.");

    // prepair pool and tokens
    let(pool, token1, token2) = prepair_pool(&root, &owner);
    println!("----->> The pool prepaired.");

    // farmer add liqidity 
    add_liquidity(&farmer, &pool, &token1, &token2, 0);
    assert_eq!(
        view!(pool.mft_balance_of(":0".to_string(), to_va(farmer.account_id.clone())))
            .unwrap_json::<U128>()
            .0,
        to_yocto("1")
    );
    println!("----->> Liquidity added by farmer.");

    println!("----->> Deploying farming contract.");
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();

    println!("----->> Creating farm0.");
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", swap()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 50,
        }, Some(U128(1000000000000000000))),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    let farm0_id: String;
    if let Value::String(farmid) = out_come.unwrap_json_value() {
        farm0_id = farmid.clone();
    } else {
        farm0_id = String::from("N/A");
    }
    println!("    Farm {} created at Height#{}", farm0_id.clone(), root.borrow_runtime().current_block().block_height);
    mint_token(&token1, &root, to_yocto("5000"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), to_yocto("500").into(), None, farm0_id.clone()),
        deposit = 1
    )
    .assert_success();
    println!("    Farm {} running at Height#{}", farm0_id.clone(), root.borrow_runtime().current_block().block_height);

    println!("----->> Creating farm1.");
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", swap()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 50,
        }, Some(U128(1000000000000000000))),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    let farm1_id: String;
    if let Value::String(farmid) = out_come.unwrap_json_value() {
        farm1_id = farmid.clone();
    } else {
        farm1_id = String::from("N/A");
    }
    println!("    Farm {} created at Height#{}", farm1_id.clone(), root.borrow_runtime().current_block().block_height);
    
    println!("----->> Creating farm2.");
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", swap()),
            reward_token: token1.valid_account_id(),
            start_at: 300,
            reward_per_session: to_yocto("1").into(),
            session_interval: 50,
        }, Some(U128(1000000000000000000))),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    let farm2_id: String;
    if let Value::String(farmid) = out_come.unwrap_json_value() {
        farm2_id = farmid.clone();
    } else {
        farm2_id = String::from("N/A");
    }
    println!("    Farm {} created at Height#{}", farm2_id.clone(), root.borrow_runtime().current_block().block_height);
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), to_yocto("500").into(), None, farm2_id.clone()),
        deposit = 1
    )
    .assert_success();
    println!("    Farm {} deposit reward at Height#{}", farm2_id.clone(), root.borrow_runtime().current_block().block_height);

    println!("---->> Registering LP 0 for {}.", farming_id());
    call!(root, pool.mft_register(":0".to_string(), to_va(farming_id())), deposit = to_yocto("1"))
    .assert_success();

    println!("---->> Step01: Farmer register and stake liquidity token.");
    call!(farmer, farming.storage_deposit(None, None), deposit = to_yocto("1"))
    .assert_success();
    let out_come = call!(
        farmer,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 0, 0, 0, 0, 0);
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Created".to_string(), to_yocto("0"), 0, 0, 0, 0, 0);
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    println!("  Farmer staked liquidity at #{}.", root.borrow_runtime().current_block().block_height);

    println!("----->> Step02: Farmer claiming reward by seed_id after 50 blocks ************");
    assert!(root.borrow_runtime_mut().produce_blocks(50).is_ok());
    println!("  Chain goes for 50 blocks *** now height: {}", root.borrow_runtime().current_block().block_height);
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 0, to_yocto("0"), to_yocto("1"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Created".to_string(), to_yocto("0"), 0, 0, to_yocto("0"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let out_come = call!(
        farmer,
        farming.claim_reward_by_seed(format!("{}@0", swap())),
        deposit = 0
    );
    out_come.assert_success();
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 1, to_yocto("1"), 0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Created".to_string(), to_yocto("0"), 0, 0, to_yocto("0"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    println!("  Farmer claimed reward at #{}.", root.borrow_runtime().current_block().block_height);

    println!("----->> Step03: Active farm1 after 50 blocks ************");
    assert!(root.borrow_runtime_mut().produce_blocks(50).is_ok());
    println!("  Chain goes for 50 blocks *** now height: {}", root.borrow_runtime().current_block().block_height);
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 2, 1, to_yocto("1"), to_yocto("1"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Created".to_string(), to_yocto("0"), 0, 0, to_yocto("0"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), to_yocto("500").into(), None, farm1_id.clone()),
        deposit = 1
    )
    .assert_success();
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 0, 0, to_yocto("0"), to_yocto("0"), to_yocto("0"));
    println!("    Farm {} running at Height#{}", farm1_id.clone(), root.borrow_runtime().current_block().block_height);

    println!("----->> Step04: Farmer claiming reward by seed_id after 50 blocks ************");
    assert!(root.borrow_runtime_mut().produce_blocks(50).is_ok());
    println!("  Chain goes for 50 blocks *** now height: {}", root.borrow_runtime().current_block().block_height);
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 3, 1, to_yocto("1"), to_yocto("2"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 0, to_yocto("0"), to_yocto("1"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let out_come = call!(
        farmer,
        farming.claim_reward_by_seed(format!("{}@0", swap())),
        deposit = 0
    );
    out_come.assert_success();
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 3, 3, to_yocto("3"), 0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 1, to_yocto("1"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    println!("  Farmer claimed reward at #{}.", root.borrow_runtime().current_block().block_height);

    println!("----->> Step05: Farmer claiming reward by seed_id after 100 blocks ************");
    assert!(root.borrow_runtime_mut().produce_blocks(100).is_ok());
    println!("  Chain goes for 100 blocks *** now height: {}", root.borrow_runtime().current_block().block_height);
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 5, 3, to_yocto("3"), to_yocto("2"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 3, 1, to_yocto("1"), to_yocto("2"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));
    let farm_info = show_farminfo(&farming, farm2_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 0, to_yocto("0"), to_yocto("1"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm2_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let out_come = call!(
        farmer,
        farming.claim_reward_by_seed(format!("{}@0", swap())),
        deposit = 0
    );
    out_come.assert_success();
    let farm_info = show_farminfo(&farming, farm0_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 5, 5, to_yocto("5"), 0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm0_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let farm_info = show_farminfo(&farming, farm1_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 3, 3, to_yocto("3"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm1_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let farm_info = show_farminfo(&farming, farm2_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 1, 1, to_yocto("1"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer.account_id(), farm2_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    println!("  Farmer claimed reward at #{}.", root.borrow_runtime().current_block().block_height);

}
'''
'''--- ref-farming/tests/test_seed_amount.rs ---
use near_sdk_sim::{call, init_simulator, to_yocto, view};
use near_sdk::json_types::{U128};
use near_sdk::serde_json::Value;

use ref_farming::{HRSimpleFarmTerms};

use crate::common::utils::*;
use crate::common::init::{deploy_farming, deploy_token};
use crate::common::views::*;
use crate::common::actions::*;

mod common;

#[test]
/// reward: 10.pow(33), seed: 10.pow(0)
/// rps: 10.pow(57)
fn seed_amount_little() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1000000000").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10000000000"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10000000000")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(farm_info.seed_id.clone(), to_yocto("0.999999999999999999999999").into()),
        deposit = 1
    );
    out_come.assert_success();

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10000000000"), 1, 0, 0, to_yocto("1000000000"), 0);
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, 1);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1000000000"));

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10000000000"), 2, 0, to_yocto("0"), to_yocto("2000000000"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2000000000"));
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10000000000"), 2, 2, to_yocto("2000000000"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("2000000000"));
    let user_rps = view!(farming.get_user_rps(farmer1.valid_account_id(), farm_id)).unwrap_json::<String>();
    assert_eq!(user_rps, String::from("2000000000000000000000000000000000000000000000000000000000"));
}

#[test]
/// reward 10.pow(17), seed: 10.pow(38) 
/// rps 10.pow(3) 
fn seed_amount_huge() {
    // println!("{}", u128::MAX);
    // 340282366920938.463463374607431768211455

    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, token2) = prepair_pool(&root, &owner);
    call!(root, pool.mft_register(":0".to_string(), to_va(farming_id())), deposit = to_yocto("1"))
    .assert_success();

    mint_token(&token1, &farmer1, u128::MAX);
    mint_token(&token2, &farmer1, u128::MAX);
    call!(
        farmer1,
        pool.storage_deposit(None, None),
        deposit = to_yocto("1")
    )
    .assert_success();
    call!(
        farmer1,
        token1.ft_transfer_call(to_va(swap()), U128(to_yocto("1")), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        farmer1,
        token2.ft_transfer_call(to_va(swap()), U128(to_yocto("1")), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        farmer1,
        pool.add_liquidity(0, vec![U128(to_yocto("1")), U128(to_yocto("1"))], None),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    call!(
        farmer1,
        token1.ft_transfer_call(to_va(swap()), U128(to_yocto("340282366920937")), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        farmer1,
        token2.ft_transfer_call(to_va(swap()), U128(to_yocto("340282366920937")), None, "".to_string()),
        deposit = 1
    )
    .assert_success();
    call!(
        farmer1,
        pool.add_liquidity(0, vec![U128(to_yocto("340282366920937")), U128(to_yocto("340282366920937"))], None),
        deposit = to_yocto("0.01")
    )
    .assert_success();

    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();

    let token3 = deploy_token(&root, String::from("rft"), vec![farming_id()]);
    mint_token(&token3, &farmer1, to_yocto("10"));

    let farm_id = "swap@0#0".to_string();
    let single_reward = 100000000000000000_u128;
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token3.valid_account_id(),
            start_at: 0,
            reward_per_session: U128(single_reward),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    call!(
        farmer1,
        token3.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), U128(to_yocto("340282366920938")), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 1, 0, 0, single_reward, 0);
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("340282366920938"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    // println!("unclaim.0 {}", unclaim.0);
    assert!(unclaim.0 > 99000000000000000);

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 2, 0, to_yocto("0"), 2 * single_reward, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    // println!("unclaim.0 {}", unclaim.0);
    assert!(unclaim.0 > 199000000000000000);
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    // show_farminfo(&farming, farm_id.clone(), false);
    // assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 2, 2, to_yocto("2"), to_yocto("0"), to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let reward = show_reward(&farming, farmer1.account_id(), token3.account_id(), false);
    // println!("reward.0 {}", reward.0);
    assert!(reward.0 > 199000000000000000);
    let user_rps = view!(farming.get_user_rps(farmer1.valid_account_id(), farm_id)).unwrap_json::<String>();
    // println!("user_rps: {}", user_rps);
    assert_eq!(user_rps, String::from("587"));
}

'''
'''--- ref-farming/tests/test_single_farm.rs ---
use near_sdk_sim::{call, init_simulator, to_yocto, view};
use near_sdk::json_types::{U128};
use near_sdk::serde_json::Value;

use ref_farming::{HRSimpleFarmTerms};

use crate::common::utils::*;
use crate::common::init::deploy_farming;
use crate::common::views::*;
use crate::common::actions::*;

mod common;

#[test]
fn single_farm_startat_0() {
    let root = init_simulator(None);

    println!("----->> Prepare accounts.");
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));
    let farmer2 = root.create_user("farmer2".to_string(), to_yocto("100"));
    println!("<<----- owner and 2 farmers prepared.");

    println!("----->> Prepare ref-exchange and swap pool.");
    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1, &farmer2]);
    println!("<<----- The pool prepaired.");

    // deploy farming contract and register user
    println!("----->> Deploy farming and register farmers.");
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    call!(farmer2, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    println!("<<----- farming deployed, farmers registered.");

    // create farm
    println!("----->> Create farm.");
    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    assert_eq!(Value::String(farm_id.clone()), out_come.unwrap_json_value());
    println!("<<----- Farm {} created at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    // deposit reward
    println!("----->> Deposit reward to turn farm Running.");
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("10")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    show_farminfo(&farming, farm_id.clone(), true);
    println!("<<----- Farm {} deposit reward at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    // farmer1 staking lpt 
    println!("----->> Farmer1 staking lpt.");
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- Farmer1 staked liquidity at #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 0, 0, 0, 0, 0);
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 1, 0, 0, to_yocto("1"), 0);
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));

    // farmer2 staking lpt 
    println!("----->> Farmer2 staking lpt.");
    let out_come = call!(
        farmer2,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- Farmer2 staked liquidity at #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 1, 1, 0, to_yocto("1"), 0);
    let user_seeds = show_userseeds(&farming, farmer2.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 2, 1, 0, to_yocto("2"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.5"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));

    println!("----->> move to 60 secs later and farmer1 claim reward by farm_id.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 3, 1, 0, to_yocto("3"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 3, 3, to_yocto("2"), to_yocto("1"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("2"));
    println!("<<----- Farmer1 claimed reward by farmid, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later and farmer2 claim reward by seed_id.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 4, 3, to_yocto("2"), to_yocto("2"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.5"));
    let out_come = call!(
        farmer2,
        farming.claim_reward_by_seed(farm_info.seed_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 4, 4, to_yocto("3.5"), to_yocto("0.5"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let reward = show_reward(&farming, farmer2.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("1.5"));
    println!("<<----- Farmer2 claimed reward by seedid, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later and farmer1 unstake half lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 5, 4, to_yocto("3.5"), to_yocto("1.5"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(farm_info.seed_id.clone(), to_yocto("0.4").into()),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 5, 5, to_yocto("4.5"), to_yocto("0.5"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("3"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&farm_info.seed_id.clone()).unwrap().0, to_yocto("0.6"));
    println!("<<----- Farmer1 unstake half lpt, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later and farmer2 unstake all his lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 6, 5, to_yocto("4.5"), to_yocto("1.5"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.375"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.125"));
    let out_come = call!(
        farmer2,
        farming.withdraw_seed(farm_info.seed_id.clone(), to_yocto("1").into()),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 6, 6, to_yocto("5.625"), to_yocto("0.375"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.375"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let reward = show_reward(&farming, farmer2.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("2.625"));
    let user_seeds = show_userseeds(&farming, farmer2.account_id(), false);
    assert!(user_seeds.get(&farm_info.seed_id.clone()).is_none());
    println!("<<----- Farmer2 unstake all his lpt, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later and farmer1 unstake the other half lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 7, 6, to_yocto("5.625"), to_yocto("1.375"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.374999999999999999999999"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(farm_info.seed_id.clone(), to_yocto("0.6").into()),
        deposit = 1
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 7, 7, to_yocto("6.999999999999999999999999"), 1, 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("4.374999999999999999999999"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&farm_info.seed_id.clone()).is_none());
    println!("<<----- Farmer1 unstake the other half lpt, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later and farmer1 restake lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 8, 7, to_yocto("6.999999999999999999999999"), 1 + to_yocto("1"), 0);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- Farmer1 staked liquidity at #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 8, 8, to_yocto("8"), to_yocto("0"), to_yocto("1") + 1);
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let out_come = call!(
        owner,
        farming.force_clean_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    assert_eq!(Value::Bool(false), out_come.unwrap_json_value());

    println!("----->> move to 40 secs later and farmer2 restake lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(40).is_ok());
    println!("        Chain goes 40 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 9, 8, to_yocto("8"), to_yocto("1"), to_yocto("1") + 1);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));
    let out_come = call!(
        farmer2,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- Farmer2 staked liquidity at #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("10"), 9, 9, to_yocto("8"), to_yocto("1"), to_yocto("1") + 1);
    let user_seeds = show_userseeds(&farming, farmer2.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0"));

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("10"), 10, 9, to_yocto("8"), to_yocto("2"), to_yocto("1") + 1);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.5"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));

    println!("----->> move to 60 secs later, and force remove farm");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("10"), 10, 9, to_yocto("8"), to_yocto("2"), to_yocto("1") + 1);
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1.5"));
    let unclaim = show_unclaim(&farming, farmer2.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("0.5"));
    let out_come = call!(
        owner,
        farming.force_clean_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    assert_eq!(Value::Bool(true), out_come.unwrap_json_value());
    assert_eq!(view!(farming.get_number_of_farms()).unwrap_json::<u64>(), 0);
    assert_eq!(view!(farming.get_number_of_outdated_farms()).unwrap_json::<u64>(), 1);
    let farm_info = show_outdated_farminfo(&farming, farm_id.clone(), true);
    assert_farming(&farm_info, "Cleared".to_string(), to_yocto("10"), 10, 10, to_yocto("10"), to_yocto("0"), to_yocto("3") + 1);
}

#[test]
fn single_farm_startat_180() {
    let root = init_simulator(None);

    println!("----->> Prepare accounts.");
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));
    println!("<<----- owner and farmer prepared.");

    println!("----->> Prepare ref-exchange and swap pool.");
    let (pool, token1, _) = prepair_pool_and_liquidity(
        &root, &owner, farming_id(), vec![&farmer1]);
    println!("<<----- The pool prepaired.");

    // deploy farming contract and register user
    println!("----->> Deploy farming and register farmers.");
    let farming = deploy_farming(&root, farming_id(), owner.account_id());
    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1")).assert_success();
    println!("<<----- farming deployed, farmers registered.");

    // create farm
    println!("----->> Create farm.");
    let farm_id = "swap@0#0".to_string();
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 180,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();
    assert_eq!(Value::String(farm_id.clone()), out_come.unwrap_json_value());
    println!("<<----- Farm {} created at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    // deposit reward
    println!("----->> Deposit reward to turn farm Running.");
    call!(
        root,
        token1.storage_deposit(Some(to_va(farming_id())), None),
        deposit = to_yocto("1")
    )
    .assert_success();
    mint_token(&token1, &root, to_yocto("10"));
    call!(
        root,
        token1.ft_transfer_call(to_va(farming_id()), U128(to_yocto("5.1")), None, farm_id.clone()),
        deposit = 1
    )
    .assert_success();
    println!("<<----- Farm {} deposit reward at #{}, ts:{}.", 
    farm_id,
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 110 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(110).is_ok());
    println!("<<----- Chain goes 110 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 0, 0, 0, to_yocto("0"), 0);

    println!("----->> move to 60 secs later, and farmer1 staking lpt.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 1, 0, 0, to_yocto("1"), 0);
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    println!("<<----- Farmer1 staked liquidity at #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 1, 1, to_yocto("1"), 0, to_yocto("1"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 2, 1, to_yocto("1"), to_yocto("1"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));

    println!("----->> move to 60 secs later and farmer1 claim reward by farm_id.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 3, 1, to_yocto("1"), to_yocto("2"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 3, 3, to_yocto("3"), to_yocto("0"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("2"));
    println!("<<----- Farmer1 claimed reward by farmid, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 4, 3, to_yocto("3"), to_yocto("1"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("5.1"), 5, 3, to_yocto("3"), to_yocto("2"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2"));

    println!("----->> move to 60 secs later.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("<<----- Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("5.1"), 6, 3, to_yocto("3"), to_yocto("2.1"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2.1"));

    println!("----->> move to 60 secs later and farmer1 claim reward by seed_id.");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("5.1"), 6, 3, to_yocto("3"), to_yocto("2.1"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("2.1"));
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_seed(farm_info.seed_id),
        deposit = 0
    );
    out_come.assert_success();
    // println!("{:#?}", out_come.promise_results());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("5.1"), 6, 6, to_yocto("5.1"), to_yocto("0"), to_yocto("1"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
    let reward = show_reward(&farming, farmer1.account_id(), token1.account_id(), false);
    assert_eq!(reward.0, to_yocto("4.1"));
    println!("<<----- Farmer1 claimed reward by seedid, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);

    println!("----->> move to 60 secs later, and force remove farm");
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    println!("        Chain goes 60 blocks, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Ended".to_string(), to_yocto("5.1"), 6, 6, to_yocto("5.1"), to_yocto("0"), to_yocto("1"));
    let out_come = call!(
        owner,
        farming.force_clean_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    assert_eq!(Value::Bool(true), out_come.unwrap_json_value());
    assert_eq!(view!(farming.get_number_of_farms()).unwrap_json::<u64>(), 0);
    assert_eq!(view!(farming.get_number_of_outdated_farms()).unwrap_json::<u64>(), 1);
    let farm_info = show_outdated_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Cleared".to_string(), to_yocto("5.1"), 6, 6, to_yocto("5.1"), to_yocto("0"), to_yocto("1"));
    println!("<<----- Farm cleaned, now #{}, ts:{}.", 
    root.borrow_runtime().current_block().block_height, 
    root.borrow_runtime().current_block().block_timestamp);
}
'''
'''--- ref-farming/tests/test_stake_unstake.rs ---
use near_sdk_sim::{call, init_simulator, to_yocto};

use crate::common::utils::*;
use crate::common::views::*;
use crate::common::actions::*;

mod common;

/// staking, unstaking, staking again, half unstaking
/// append staking
#[test]
fn lpt_stake_unstake() {
    let root = init_simulator(None);

    // prepair users
    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));

    let (pool, token1, _) = prepair_pool_and_liquidity(&root, &owner, farming_id(), vec![&farmer1]);

    let (farming, farm_id) = prepair_farm(&root, &owner, &token1, to_yocto("500"));
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 0, 0, 0, 0, 0);

    call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1"))
    .assert_success();
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(format!("{}@0", swap()), to_yocto("1").into()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());
    
    assert!(root.borrow_runtime_mut().produce_blocks(120).is_ok());
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("0.5"));
    
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(format!("{}@0", swap()), to_yocto("0.5").into()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("0.5"));
    
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let out_come = call!(
        farmer1,
        farming.withdraw_seed(format!("{}@0", swap()), to_yocto("0.5").into()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());

    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("1").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("1"));
    
    assert!(root.borrow_runtime_mut().produce_blocks(60).is_ok());
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 8, 7, to_yocto("7"), to_yocto("1"), to_yocto("3"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, to_yocto("1"));
    let out_come = call!(
        farmer1,
        farming.claim_reward_by_farm(farm_id.clone()),
        deposit = 0
    );
    out_come.assert_success();
    let farm_info = show_farminfo(&farming, farm_id.clone(), false);
    assert_farming(&farm_info, "Running".to_string(), to_yocto("500"), 8, 8, to_yocto("8"), 0, to_yocto("3"));
    let unclaim = show_unclaim(&farming, farmer1.account_id(), farm_id.clone(), false);
    assert_eq!(unclaim.0, 0_u128);
}

'''
'''--- ref-farming/tests/test_storage.rs ---
use near_sdk_sim::{view, call, init_simulator, to_yocto};
// use near_sdk::json_types::{U128};
use near_sdk::serde_json::Value;
use ref_farming::{HRSimpleFarmTerms};

use crate::common::utils::*;
use crate::common::init::deploy_farming;
use crate::common::views::*;
use crate::common::actions::*;

mod common;

#[test]
fn storage_stake() {
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let farmer1 = root.create_user("farmer1".to_string(), to_yocto("100"));
    let farmer2 = root.create_user("farmer2".to_string(), to_yocto("100"));

    let farming = deploy_farming(&root, farming_id(), owner.account_id());

    // farmer1 register with only_register set to false
    let out_come = call!(farmer1, farming.storage_deposit(None, None), deposit = to_yocto("1"));
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("1"));
    assert_eq!(sb.available.0, to_yocto("0.99908"));
    assert!(farmer1.account().unwrap().amount < to_yocto("99"));

    // farmer1 withdraw storage
    let out_come = call!(farmer1, farming.storage_withdraw(None), deposit = 1);
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("0.00092"));
    assert_eq!(sb.available.0, to_yocto("0"));
    assert!(farmer1.account().unwrap().amount > to_yocto("99.9"));

    // farmer1 unregister storage
    let out_come = call!(farmer1, farming.storage_unregister(None), deposit = 1);
    out_come.assert_success();
    let ret = out_come.unwrap_json_value();
    assert_eq!(ret, Value::Bool(true));
    let ret = view!(farming.storage_balance_of(farmer1.valid_account_id())).unwrap_json_value();
    assert_eq!(ret, Value::Null);
    assert!(farmer1.account().unwrap().amount > to_yocto("99.99"));

    // farmer1 register with only_register set to true
    let out_come = call!(farmer1, farming.storage_deposit(None, Some(true)), deposit = to_yocto("1"));
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    // println!("{:#?}", sb);
    assert_eq!(sb.total.0, to_yocto("0.01852"));
    assert_eq!(sb.available.0, to_yocto("0.01760"));

    // farmer1 help farmer2 register with only_register set to false
    let out_come = call!(farmer1, farming.storage_deposit(Some(to_va(farmer2.account_id())), Some(false)), deposit = to_yocto("1"));
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("1"));
    assert_eq!(sb.available.0, to_yocto("0.99908"));
    let sb = show_storage_balance(&farming, farmer2.account_id(), false);
    assert_eq!(sb.total.0, to_yocto("1"));
    assert_eq!(sb.available.0, to_yocto("0.99908"));
    let sb = show_storage_balance(&farming, farmer1.account_id(), false);
    assert_eq!(sb.total.0, to_yocto("0.01852"));
    assert_eq!(sb.available.0, to_yocto("0.01760"));
    assert!(farmer1.account().unwrap().amount < to_yocto("99"));
    assert_eq!(farmer2.account().unwrap().amount, to_yocto("100"));
    
    // insurfficent storage and deposit more
    let out_come = call!(farmer1, farming.storage_withdraw(None), deposit = 1);
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("0.00092"));
    assert_eq!(sb.available.0, to_yocto("0"));

    let (pool, token1, _) = prepair_pool_and_liquidity(&root, &owner, farming_id(), vec![&farmer1]);
    let out_come = call!(
        owner,
        farming.create_simple_farm(HRSimpleFarmTerms{
            seed_id: format!("{}@0", pool.account_id()),
            reward_token: token1.valid_account_id(),
            start_at: 0,
            reward_per_session: to_yocto("1").into(),
            session_interval: 60,
        }, None),
        deposit = to_yocto("1")
    );
    out_come.assert_success();

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let ex_status = format!("{:?}", out_come.promise_errors()[0].as_ref().unwrap().status());
    assert!(ex_status.contains("E11: insufficient $NEAR storage deposit"));
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert!(user_seeds.get(&String::from("swap@0")).is_none());

    let out_come = call!(farmer1, farming.storage_deposit(None, Some(false)), deposit = to_yocto("1"));
    out_come.assert_success();
    let sb = out_come.unwrap_json::<StorageBalance>();
    assert_eq!(sb.total.0, to_yocto("1.00092"));
    assert_eq!(sb.available.0, to_yocto("1"));

    let out_come = call!(
        farmer1,
        pool.mft_transfer_call(":0".to_string(), to_va(farming_id()), to_yocto("0.5").into(), None, "".to_string()),
        deposit = 1
    );
    out_come.assert_success();
    let user_seeds = show_userseeds(&farming, farmer1.account_id(), false);
    assert_eq!(user_seeds.get(&String::from("swap@0")).unwrap().0, to_yocto("0.5"));
}
'''
'''--- test-token/Cargo.toml ---
[package]
name = "test-token"
version = "0.1.0"
authors = ["Illia Polosukhin <illia.polosukhin@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
# near-sdk = { git = "https://github.com/near/near-sdk-rs", rev = "9d99077" }
# near-contract-standards = { git = "https://github.com/near/near-sdk-rs", rev = "9d99077" }
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
'''
'''--- test-token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/test_token.wasm res/

'''
'''--- test-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            token: FungibleToken::new(b"t".to_vec()),
        }
    }

    pub fn mint(&mut self, account_id: ValidAccountId, amount: U128) {
        self.token.internal_register_account(account_id.as_ref());
        self.token
            .internal_deposit(account_id.as_ref(), amount.into());
    }

    pub fn burn(&mut self, account_id: ValidAccountId, amount: U128) {
        self.token
            .internal_withdraw(account_id.as_ref(), amount.into());
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env, MockedBlockchain};

    use super::*;

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Contract::new();
        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.mint(accounts(0), 1_000_000.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000.into());

        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.storage_deposit(Some(accounts(1)), None);
        testing_env!(context
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.ft_transfer(accounts(1), 1_000.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000.into());

        contract.burn(accounts(1), 500.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500.into());
    }
}

'''