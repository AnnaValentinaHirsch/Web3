*GitHub Repository "kursaderduhan/Project_Book"*

'''--- README.md ---
# Near-Project-Book

This project is a simple projectstore on Near blockchain. Users can post their ideas, review ideas and donate to the owner if they want. <br/>

You can watch this video for use. [loom video](https://www.loom.com/share/f279ccd9fe6d4022b80cb66c85ce7980)

## Installation 

```bash
git clone https://github.com/kursaderduhan/Project_Book.git
cd Project_Book
yarn
```

## How to Use Projectbook Smart Contract

First login to your account using near cli.

```bash
near login
```

Build and deploy the smart contract.

```bash
yarn build:release
near dev-deploy ./build/release/singleton.wasm
````

Export the development account to the $CONTRACT

```bash
export CONTRACT=<YOUR_DEV_ACCOUNT_HERE>
```
---

Create a Idea.

```bash
near call $CONTRACT addIdea '{"idea": "Car_Rental"}' --accountId <Your_Testnet_Account_Here>
```

List All Ideas.

```bash
near view $CONTRACT getIdeas
```

Call Idea With Id.

```bash
near view $CONTRACT getIdea '{"id": "<Project_ID_here>"}'
```

Donate To The Owner Of The Idea.

```bash
near call $CONTRACT donation '{"idea": "<project_id_here>"}' --accountId <your_testnet_account_here> --amount 2

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# uncomment out the line below to deploy the other example contract
# near dev-deploy ./build/debug/simple.wasm

# comment the line below to deploy the other example contract
near dev-deploy ./build/debug/singleton.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
echo 'export NEAR_ACCOUNT=<Your_Near_Account>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.run.sh ---
#!/usr/bin/env bash

echo ---------------------------------------------------------
echo "Step 1: addIdea"
echo ---------------------------------------------------------

IDEAID=$(near call $CONTRACT addIdea '{"idea": "Project_Control1"}' --account_id $NEAR_ACCOUNT | tail -c 8 | sed "s/'//")

echo $IDEAID
echo
echo ---------------------------------------------------------
echo "Step 2: Donate"
echo ---------------------------------------------------------
echo
argument="'{\"idea\":\"${IDEAID}\"}'"
echo $argument
near call $CONTRACT donation $argument --account_id $NEAR_ACCOUNT --amount 1 

echo ---------------------------------------------------------
echo "Step 3: Returns added a idea via id parameter."
echo ---------------------------------------------------------
argument1="'{\"id\":\"${IDEAID}\"}'"
near view $CONTRACT getIdea $argument1

echo ---------------------------------------------------------
echo "Step 4: Returns all ideas that addedto blockchain."
echo ---------------------------------------------------------

near view $CONTRACT getIdeas 
exit 0

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("ðŸš« Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("âœ… Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/assembly/index.ts ---
import { storage, Context } from "near-sdk-as"

// return the string 'hello world'
export function helloWorld(): string {
  const predecessor = Context.predecessor
  return 'hello ' + predecessor
}

// read the given key from account (contract) storage
export function read(key: string): string {
  if (storage.hasKey(key)) {
    return `âœ… Key [ ${key} ] has value [ ${storage.getString(key)!} ]`
  } else {
    return `ðŸš« Key [ ${key} ] not found in storage. ( ${storageReport()} )`
  }
}

// write the given value at the given key to account (contract) storage
export function write(key: string, value: string): string {
  storage.set(key, value)
  return `âœ… Data saved. ( ${storageReport()} )`
}

// private helper method used by read() and write() above
function storageReport(): string {
  return `storage [ ${Context.storageUsage} bytes ]`
}

'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("ðŸš« Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("âœ… Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { projectsStorage, ProjectIdea } from './model'

// donate to the owner of the idea
export function donation(idea: string): void {
  ProjectIdea.donation(idea);
} 

// idea - to add a idea to blockchain.
export function addIdea(idea: string): string{
  return ProjectIdea.addIdea(idea);
}

// returns added a idea via id parameter.
export function getIdea(id: string): ProjectIdea | null{
  return ProjectIdea.getIdea(id);
}

// returns all ideas that addedto blockchain.
export function getIdeas(): Array<ProjectIdea> {
  return projectsStorage.values();
}

'''
'''--- src/singleton/assembly/model.ts ---
import {context, PersistentUnorderedMap, ContractPromiseBatch, logging} from "near-sdk-as";

const IDEA_LIMIT = 25;

@nearBindgen
export class ProjectIdea{
    id: string;
    idea: string;
    ideaOwner: string;
    
    constructor(idea: string){
        this.id = context.blockIndex.toString().slice(2, 8);
        this.idea = idea;
        this.ideaOwner = context.sender;    
    }
    static addIdea(idea: string): string {
        assert(projectsStorage.length < IDEA_LIMIT, "IDEA_LIMIT");
        assert(idea.length > 0, "Idea must not be empty!");
        let projectIdea = new ProjectIdea(idea);
        projectsStorage.set(projectIdea.id, projectIdea);
        return projectIdea.id;
    }
    static getIdea(id: string): ProjectIdea | null {
        return projectsStorage.get(id);
    }
    static donation(ideaId: string): void {
        const idea = ProjectIdea.getIdea(ideaId);
        assert(idea != null, "idea not found"); 
        ContractPromiseBatch.create(idea!.ideaOwner).transfer(context.attachedDeposit);
        logging.log("Donation succesfull");
    }
}

export const projectsStorage = new PersistentUnorderedMap<string, ProjectIdea>("ps");
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''