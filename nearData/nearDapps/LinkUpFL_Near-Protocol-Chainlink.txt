*GitHub Repository "LinkUpFL/Near-Protocol-Chainlink"*

'''--- README.md ---
# Chainlink x Near Protocol

This is a native mainnet integration of Chainlink on the NEAR blockchain to support its many developers wanting to build decentralized applications using Chainlink oracles.

-Validate and adapt Chainlink contracts to ensure native compatibility with NEAR

-Test and deploy all components to NEAR, with continual maintenance and upgrades

-Deliver a monitoring solution for Chainlink nodes operating on NEAR

[BlockSpaces and LinkUp Florida Receive a Grant to Integrate Chainlink on NEAR Mainnet](https://blog.chain.link/blockspaces-and-linkup-florida-receive-a-grant-to-integrate-chainlink-on-near-mainnet/)

'''
'''--- completion_list.txt ---
- Need to clean up the suite of tests more dev friendly (remove commented out code, clean up variables, assertions, update imports, Github lines, etc.) (DONE*)
- Create an AccessControl contract that Flags makes cross-contract calls to. (DONE)
- Create a Consumer contract that matches the one used in Flags tests (FlagsTestHelper). (DONE)
- Create a FluxTestHelper contract that matches the one used in ACA tests (FluxTestHelper). (DONE)
- Create a SimpleReadAccessController contract that matches the one used in EAC tests (SimpleReadAccessController) (DONE). 
- Create a MockV3Aggregator contract that matches the one used in EAC tests (MockV3Aggregator) (DONE). 
- Port the rest of Flux Aggregator tests (DONE*)
- Port the rest of Flags tests (DONE)
- Port the rest of AccessControlledAggregator tests (DONE)
- Port the rest of EACAggregator tests (DONE*)
- Port the rest of SimpleReadAccessController tests (DONE*)
- Port the rest of SimpleWriteAccessController tests (DONE*)
- Port the rest of AggregatorProxy tests (DONE*)
- Fix bugs in suite of tests (DONE*)
- Implement transfer_and_call functionality into Fungible token standard, fix breaking changes. (DONE)
- Create a https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.6/tests/FluxAggregatorTestHelper.sol contract account for tests (DONE)
- Brainstorm and implement a better way of handling is_none cases, such as 0 states (DONE)
- Uncomment test with *TODO* comments to debug (DONE*)
- Look into Contract A calling Contract A function that returns bool or value from Promise (DONE)
- Assert that contracts have limited interfaces (DONE*)
- Refactor smart contracts into traits/implementations for composability, optimize read/writes from storage for gas. (DONE*)
- Implement a solution for havoc caused in data types due to Solidity vs Rust different data types. (DONE*)
- Check out bugs in describe block here: https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L610 (increaseTimeBy evm function) (DONE*)
- Revisit validate_answer function (DONE*)

'''
'''--- contract-wrap/Cargo.toml ---
[package]
name = "contract-wrap"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[dev-dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", tag="3.0.1" }
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", rev="c2771af7fdfe01a4e8414046752ee16fb0d29d39" }
access_controlled_aggregator = { path = "./access_controlled_aggregator" }
link_token = { path = "./link_token" }
eac_aggregator_proxy = { path = "./eac_aggregator_proxy" }
aggregator_vaildator_mock = { path = "./aggregator_vaildator_mock" }
flags = { path = "./flags" }
flux_aggregator = { path = "./flux_aggregator" }
consumer = { path = "./consumer" }
simple_read_access_controller = { path = "./simple_read_access_controller" }
simple_write_access_controller = { path = "./simple_write_access_controller" }
flags_test_helper = { path = "./flags_test_helper" }
flux_aggregator_test_helper = { path = "./flux_aggregator_test_helper" }
mock_v3_aggregator = { path = "./mock_v3_aggregator" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
  "access_controlled_aggregator",
  "link_token",
  "eac_aggregator_proxy",
  "flux_aggregator",
  "aggregator_vaildator_mock",
  "flags",
  "consumer",
  "simple_write_access_controller",
  "simple_read_access_controller",
  "flags_test_helper",
  "flux_aggregator_test_helper",
  "mock_v3_aggregator"
]
'''
'''--- contract-wrap/Consumer/Cargo.toml ---
[package]
name = "consumer"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.45"
near-sdk = "0.11.0"
borsh = "0.6.0"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }
base64 = "0.12.1"
'''
'''--- contract-wrap/Consumer/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::{env, ext_contract, near_bindgen, AccountId};
use near_sdk::collections::TreeMap;
use base64::{decode};
use std::str;
use near_sdk::json_types::U128;
use std::collections::HashMap;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
const SINGLE_CALL_GAS: u64 = 200_000_000_000_000;

pub type Base64String = String;

#[ext_contract(ext_oracle)]
pub trait ExtOracleContract {
    fn request(&mut self, payment: U128, spec_id: Base64String, callback_address: AccountId, callback_method: String, nonce: U128, data_version: U128, data: Base64String);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
struct Consumer {
    // Note: for this simple demo we'll store the oracle node in state like this
    // There's no reason why client contracts can't call various oracle contracts.
    oracle_account: AccountId,
    nonce: u128,
    received: TreeMap<u128, String>,
}

impl Default for Consumer {
    fn default() -> Self {
        panic!("consumer should be initialized before usage")
    }
}

#[near_bindgen]
impl Consumer {
    #[allow(dead_code)]
    #[init]
    pub fn new(oracle_account: AccountId) -> Self {
        Self {
            oracle_account,
            nonce: 0_u128,
            received: TreeMap::new(b"r".to_vec()),
        }
    }

    /// symbol: Base64-encoded token symbol
    #[allow(dead_code)] // This function gets called from the oracle
    pub fn get_token_price(&mut self, symbol: String, spec_id: Base64String) -> U128 {
        // For the sake of demo, a few hardcoded values
        let payment = U128(10);
        self.nonce += 1;
        let nonce: U128 = self.nonce.into();

        ext_oracle::request(payment, spec_id, env::current_account_id(), "token_price_callback".to_string(), nonce, U128(1), symbol, &self.oracle_account, 0, SINGLE_CALL_GAS);
        U128(self.nonce)
    }

    #[allow(dead_code)] // This function gets called from the oracle
    pub fn token_price_callback(&mut self, nonce: U128, answer: Base64String) {
        let base64_price = match str::from_utf8(answer.as_bytes()) {
            Ok(val) => val,
            Err(_) => env::panic(b"Invalid UTF-8 sequence provided from oracle contract."),
        };
        let decoded_price_vec = decode(base64_price).unwrap();
        let price_readable = match str::from_utf8(decoded_price_vec.as_slice()) {
            Ok(val) => val,
            Err(_) => env::panic(b"Invalid UTF-8 sequence in Base64 decoded value."),
        };
        env::log(format!("Client contract received price: {:?}", price_readable).as_bytes());
        self.received.insert(&nonce.0, &price_readable.to_string());
    }

    // using String instead of U128 because
    // the trait `std::cmp::Eq` is not implemented for `near_sdk::json_types::integers::U128`
    #[allow(dead_code)]
    pub fn get_received_vals(&self, max: U128) -> HashMap<String, String> {
        let mut counter: u128 = 0;
        let mut result: HashMap<String, String> = HashMap::new();
        for answer in self.received.iter() {
            if counter == max.0 || counter > self.received.len() as u128 {
                break;
            }
            result.insert(answer.0.to_string(), answer.1);
            counter += 1;
        }
        result
    }

    #[allow(dead_code)]
    pub fn get_received_val(&self, nonce: U128) -> String {
        let nonce_u128: u128 = nonce.into();
        self.received.get(&nonce_u128).unwrap_or("-1".to_string())
    }
}

'''
'''--- contract-wrap/Flags/Cargo.toml ---
[package]
name = "flags"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/Flags/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::{Promise, PromiseOrValue, PromiseResult};
#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13
const DEFAULT_GAS: u64 = 300_000_000_000_000;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Flags {
    pub raising_access_controller: AccountId,
    pub owner: AccountId,
    pending_owner: AccountId,
    flags: LookupMap<AccountId, bool>,
    pub check_enabled: bool,
    access_list: LookupMap<AccountId, bool>,
}

impl Default for Flags {
    fn default() -> Self {
        panic!("Flags should be initialized before usage")
    }
}

#[near_bindgen]
impl Flags {
    #[init]
    pub fn new(owner_id: AccountId, rac_address: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(
            rac_address == "" || env::is_valid_account_id(rac_address.as_bytes()),
            "rac_address account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");
        let mut result = Self {
            raising_access_controller: "".to_string(),
            owner: owner_id,
            pending_owner: "".to_string(),
            flags: LookupMap::new(b"flags".to_vec()),
            check_enabled: true,
            access_list: LookupMap::new(b"access_list".to_vec()),
        };
        result.set_raising_access_controller(rac_address);
        result
    }

    pub fn get_flag(&self, subject: AccountId) -> bool {
        self.check_access();
        let flag = self.flags.get(&subject);
        if flag.is_none() {
            false
        } else {
            flag.unwrap()
        }
    }

    pub fn get_flags(&self, subjects: Vec<AccountId>) -> Vec<bool> {
        self.check_access();
        // let subjects_length: usize = subjects.len();
        // let mut responses: Vec<bool> = Vec::with_capacity(subjects_length);
        // let subjects_length: usize = subjects.len();
        let mut responses: Vec<bool> = Vec::new();
        for i in 0..subjects.len() {
            let flag = self.flags.get(&subjects[i]);
            if flag.is_none() {
                responses.push(false);
            } else {
                responses.push(flag.unwrap());
            }
        }
        return responses;
    }

    pub fn raise_flag(&mut self, subject: AccountId) {
        if env::predecessor_account_id() == self.owner {
            self.try_to_raise_flag(subject);
        } else {
            assert!(
                env::is_valid_account_id(self.raising_access_controller.as_bytes()),
                "Not allowed to raise flags"
            );
            let has_access_promise = env::promise_create(
                self.raising_access_controller.clone(),
                b"has_access",
                json!({ "_user": env::predecessor_account_id() })
                    .to_string()
                    .as_bytes(),
                0,
                SINGLE_CALL_GAS,
            );
            let has_access_promise_results = env::promise_then(
                has_access_promise,
                env::current_account_id(),
                b"allowed_to_raise_flag_promise_result",
                json!({ "subject": subject }).to_string().as_bytes(),
                0,
                SINGLE_CALL_GAS,
            );
            env::promise_return(has_access_promise_results);
        }
    }

    pub fn raise_flags(&mut self, subjects: Vec<AccountId>) {
        if env::predecessor_account_id() == self.owner {
            for i in 0..subjects.len() {
                self.try_to_raise_flag(subjects[i].clone());
            }
        } else {
            assert!(
                env::is_valid_account_id(self.raising_access_controller.as_bytes()),
                "Not allowed to raise flags"
            );
            let has_access_promise = env::promise_create(
                self.raising_access_controller.clone(),
                b"has_access",
                json!({ "_user": env::predecessor_account_id() })
                    .to_string()
                    .as_bytes(),
                0,
                SINGLE_CALL_GAS,
            );
            let has_access_promise_results = env::promise_then(
                has_access_promise,
                env::current_account_id(),
                b"allowed_to_raise_flags_promise_result",
                json!({ "subjects": subjects }).to_string().as_bytes(),
                0,
                SINGLE_CALL_GAS,
            );
            env::promise_return(has_access_promise_results);
        }
    }

    pub fn allowed_to_raise_flag_promise_result(&mut self, subject: AccountId) {
        // assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_allowed_to_raise_flags_promise_reult: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("Promise with index 0 failed"),
        };
        let allowed: bool =
            serde_json::from_slice(&get_allowed_to_raise_flags_promise_reult).unwrap();
        if !allowed {
            env::panic(b"Not allowed to raise flags");
        } else {
            self.try_to_raise_flag(subject);
        }
    }

    pub fn allowed_to_raise_flags_promise_result(&mut self, subjects: Vec<AccountId>) {
        // assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_allowed_to_raise_flags_promise_reult: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("Promise with index 0 failed"),
        };
        let allowed: bool =
            serde_json::from_slice(&get_allowed_to_raise_flags_promise_reult).unwrap();
        if !allowed {
            env::panic(b"Not allowed to raise flags");
        } else {
            for i in 0..subjects.len() {
                self.try_to_raise_flag(subjects[i].clone());
            }
        }
    }

    pub fn lower_flags(&mut self, subjects: Vec<AccountId>) {
        self.only_owner();
        for i in 0..subjects.len() {
            let subject = self.flags.get(&subjects[i]);
            if subject.is_none() {
                env::panic(b"The subject doesnt exist");
            }
            if subject.unwrap() == true {
                self.flags.insert(&subjects[i], &false);
                env::log(format!("{}", &subjects[i]).as_bytes());
            }
        }
    }
    pub fn get_raising_access_controller(&self) -> String {
        self.raising_access_controller.clone()
    }

    pub fn set_raising_access_controller(&mut self, rac_address: AccountId) {
        if env::predecessor_account_id() != env::current_account_id() {
            self.only_owner();
        }
        let previous: AccountId = String::from(&self.raising_access_controller) as AccountId;
        let init_rac_address: AccountId = rac_address.clone();
        if previous != rac_address {
            self.raising_access_controller = rac_address;
            env::log(format!("{}, {}", previous, init_rac_address).as_bytes());
        }
    }

    pub fn has_access(&self, _user: AccountId) -> bool {
        if !self.check_enabled {
            !self.check_enabled
        } else {
            let user_option = self.access_list.get(&_user);
            if user_option.is_none() {
                return false;
            }
            let user = user_option.unwrap();
            user
        }
    }

    pub fn add_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            self.access_list.insert(&_user, &true);
        }
    }

    pub fn remove_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            env::panic(b"Did not find the user to remove.");
        }
        self.access_list.insert(&_user, &false);
    }

    pub fn enable_access_check(&mut self) {
        self.only_owner();

        if !self.check_enabled {
            self.check_enabled = true;
        }
    }

    pub fn disable_access_check(&mut self) {
        self.only_owner();

        if self.check_enabled {
            self.check_enabled = false;
        }
    }

    // Commented out to get code working
    // fn allowed_to_raise_flags(&self) -> PromiseOrValue<bool> {
    // }

    fn try_to_raise_flag(&mut self, subject: AccountId) {
        let flag = self.flags.get(&subject);
        if flag.is_none() {
            self.flags.insert(&subject, &true);
            env::log(format!("{}", &subject).as_bytes());
        } else {
            if flag.unwrap() == false {
                self.flags.insert(&subject, &true);
                env::log(format!("{}", &subject).as_bytes());
            }
        }
    }

    fn only_owner(&self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only callable by owner."
        );
    }

    fn check_access(&self) {
        assert!(self.has_access(env::predecessor_account_id()), "No access")
    }

    pub fn transfer_ownership(&mut self, _to: AccountId) {
        self.only_owner();
        let init_to: AccountId = _to.clone();
        self.pending_owner = _to;
        env::log(format!("{}, {}", self.owner, init_to).as_bytes());
    }

    pub fn accept_ownership(&mut self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.pending_owner,
            "Must be proposed owner"
        );
        let old_owner: AccountId = self.owner.clone();
        self.owner = env::predecessor_account_id();
        self.pending_owner = "".to_string();
        env::log(format!("{}, {}", old_owner, env::predecessor_account_id()).as_bytes());
    }
}

'''
'''--- contract-wrap/access_controlled_aggregator/Cargo.toml ---
[package]
name = "access_controlled_aggregator"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/access_controlled_aggregator/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, ext_contract, near_bindgen, AccountId, PromiseResult};
use std::convert::TryInto;
use std::str;

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13
pub const DEFAULT_GAS: u64 = 300_000_000_000_000;

pub type Base64String = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Round {
    answer: u128,
    started_at: u64,
    updated_at: u64,
    answered_in_round: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RoundDetails {
    submissions: Vec<u128>,
    max_submissions: u64,
    min_submissions: u64,
    timeout: u64,
    payment_amount: u128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OracleStatus {
    withdrawable: u128,
    starting_round: u64,
    ending_round: u128,
    last_reported_round: u64,
    last_started_round: u64,
    latest_submission: u128,
    index: u64,
    admin: AccountId,
    pending_admin: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Requester {
    authorized: bool,
    delay: u64,
    last_started_round: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Funds {
    available: u128,
    allocated: u128,
}

const VERSION: u128 = 3;
const RESERVE_ROUNDS: u128 = 2;
const MAX_ORACLE_COUNT: u128 = 77;
const ROUND_MAX: u128 = 4294967295; // 2**32-1
const V3_NO_DATA_ERROR: &str = "No data present";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccessControlledAggregator {
    pub owner: AccountId,
    pending_owner: AccountId,
    pub link_token: AccountId,
    pub validator: AccountId,
    pub payment_amount: u128,
    pub max_submission_count: u64,
    pub min_submission_count: u64,
    pub restart_delay: u64,
    pub timeout: u64,
    pub decimals: u64,
    pub description: Base64String,
    pub min_submission_value: u128,
    pub max_submission_value: u128,
    pub check_enabled: bool,
    access_list: LookupMap<AccountId, bool>,
    reporting_round_id: u64,
    latest_round_id: u64,
    oracles: LookupMap<AccountId, OracleStatus>,
    rounds: LookupMap<u64, Round>,
    details: LookupMap<u128, RoundDetails>,
    requesters: LookupMap<AccountId, Requester>,
    oracle_addresses: Vec<AccountId>,
    recorded_funds: Funds,
}

impl Default for AccessControlledAggregator {
    fn default() -> Self {
        panic!("AccessControlledAggregator should be initialized before usage");
    }
}

#[near_bindgen]
impl AccessControlledAggregator {
    /**
     * @notice set up the aggregator with initial configuration
     * @param _link The address of the LINK token
     * @param _paymentAmount The amount paid of LINK paid to each oracle per submission, in wei (units of 10⁻¹⁸ LINK)
     * @param _timeout is the number of seconds after the previous round that are
     * allowed to lapse before allowing an oracle to skip an unfinished round
     * @param _validator is an optional contract address for validating
     * external validation of answers
     * @param _minSubmissionValue is an immutable check for a lower bound of what
     * submission values are accepted from an oracle
     * @param _maxSubmissionValue is an immutable check for an upper bound of what
     * submission values are accepted from an oracle
     * @param _decimals represents the number of decimals to offset the answer by
     * @param _description a short description of what is being reported
     */
    #[init]
    pub fn new(
        owner_id: AccountId,
        link_id: AccountId,
        _payment_amount: U128,
        _timeout: U64,
        _validator: AccountId,
        _min_submission_value: U128,
        _max_submission_value: U128,
        _decimals: U64,
        _description: Base64String,
    ) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(
            env::is_valid_account_id(link_id.as_bytes()),
            "Link token account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");

        let payment_amount_u128: u128 = _payment_amount.into();
        let timeout_u64: u64 = _timeout.into();
        let min_submission_value_u128: u128 = _min_submission_value.into();
        let max_submission_value_u128: u128 = _max_submission_value.into();
        let decimals_u64: u64 = _decimals.into();
        let vector: Vec<AccountId> = Vec::new();

        let mut result = Self {
            owner: owner_id,
            pending_owner: "".to_string(),
            link_token: link_id,
            validator: "".to_string(),
            payment_amount: 0_u128,
            max_submission_count: 0_u64,
            min_submission_count: 0_u64,
            restart_delay: 0_u64,
            timeout: 0_u64,
            decimals: decimals_u64,
            description: _description,
            min_submission_value: min_submission_value_u128,
            max_submission_value: max_submission_value_u128,
            check_enabled: true,
            access_list: LookupMap::new(b"access_list".to_vec()),
            reporting_round_id: 0_u64,
            latest_round_id: 0_u64,
            oracles: LookupMap::new(b"oracles".to_vec()),
            rounds: LookupMap::new(b"rounds".to_vec()),
            details: LookupMap::new(b"details".to_vec()),
            requesters: LookupMap::new(b"requesters".to_vec()),
            oracle_addresses: vector,
            recorded_funds: Funds {
                available: 0_u128,
                allocated: 0_u128,
            },
        };
        let updated_at_insert: u64 = env::block_timestamp().saturating_sub(timeout_u64);
        let new_round: Round = Round {
            answer: 0_u128,
            started_at: 0_u64,
            updated_at: updated_at_insert,
            answered_in_round: 0_u64,
        };
        result.rounds.insert(&0, &new_round);
        result.update_future_rounds(
            U128::from(payment_amount_u128),
            U64::from(0),
            U64::from(0),
            U64::from(0),
            U64::from(timeout_u64),
        );
        result.set_validator(_validator);
        result
    }

    /**
     * @notice called by oracles when they have witnessed a need to update
     * @param _roundId is the ID of the round this submission pertains to
     * @param _submission is the updated data that the oracle is submitting
     */
    pub fn submit(&mut self, _round_id: U128, _submission: U128) {
        let round_id_u128: u128 = _round_id.into();
        let submission_u128: u128 = _submission.into();
        let error: Base64String =
            self.validate_oracle_round(env::predecessor_account_id(), round_id_u128 as u64);
        assert!(
            submission_u128 >= self.min_submission_value,
            "value below min_submission_value"
        );
        assert!(
            submission_u128 <= self.max_submission_value,
            "value above max_submission_value"
        );
        if error.len() != 0 {
            env::panic(format!("{}", error).as_bytes());
        }

        self.oracle_initialize_new_round(round_id_u128 as u64);
        self.record_submission(submission_u128, round_id_u128);
        let (updated, new_answer): (bool, u128) = self.update_round_answer(round_id_u128 as u64);
        self.pay_oracle(round_id_u128 as u64);
        self.delete_round_details(round_id_u128 as u64);
        if updated {
            self.validate_answer(round_id_u128 as u64, new_answer);
        }
    }

    /**
     * @notice called by the owner to remove and add new oracles as well as
     * update the round related parameters that pertain to total oracle count
     * @param _removed is the list of addresses for the new Oracles being removed
     * @param _added is the list of addresses for the new Oracles being added
     * @param _addedAdmins is the admin addresses for the new respective _added
     * list. Only this address is allowed to access the respective oracle's funds
     * @param _minSubmissions is the new minimum submission count for each round
     * @param _maxSubmissions is the new maximum submission count for each round
     * @param _restartDelay is the number of rounds an Oracle has to wait before
     * they can initiate a round
     */
    pub fn change_oracles(
        &mut self,
        _removed: Vec<AccountId>,
        _added: Vec<AccountId>,
        _added_admins: Vec<AccountId>,
        _min_submissions: U64,
        _max_submissions: U64,
        _restart_delay: U64,
    ) {
        self.only_owner();

        let min_submissions_u64: u64 = _min_submissions.into();
        let max_submissions_u64: u64 = _max_submissions.into();
        let restart_delay_u64: u64 = _restart_delay.into();

        for i in 0.._removed.len() {
            self.remove_oracle(_removed[i].clone());
        }

        assert!(
            _added.len() == _added_admins.len(),
            "need same oracle and admin count"
        );
        assert!(
            (self.oracle_count() as usize + _added.len()) as u128 <= MAX_ORACLE_COUNT,
            "max oracles allowed"
        );

        for i in 0.._added.len() {
            self.add_oracle(_added[i].clone(), _added_admins[i].clone());
        }

        self.update_future_rounds(
            U128::from(self.payment_amount),
            U64::from(min_submissions_u64),
            U64::from(max_submissions_u64),
            U64::from(restart_delay_u64),
            U64::from(self.timeout),
        );
    }

    /**
     * @notice update the round and payment related parameters for subsequent
     * rounds
     * @param _paymentAmount is the payment amount for subsequent rounds
     * @param _minSubmissions is the new minimum submission count for each round
     * @param _maxSubmissions is the new maximum submission count for each round
     * @param _restartDelay is the number of rounds an Oracle has to wait before
     * they can initiate a round
     */
    pub fn update_future_rounds(
        &mut self,
        _payment_amount: U128,
        _min_submissions: U64,
        _max_submissions: U64,
        _restart_delay: U64,
        _timeout: U64,
    ) {
        // Look into how to call this function in the initialization while having a an owner_id provided that is not the contract
        if env::predecessor_account_id() != env::current_account_id() {
            self.only_owner();
        }
        let payment_amount_u128: u128 = _payment_amount.into();
        let min_submissions_u64: u64 = _min_submissions.into();
        let max_submissions_u64: u64 = _max_submissions.into();
        let restart_delay_u64: u64 = _restart_delay.into();
        let timeout_u64: u64 = _timeout.into();

        let oracle_num: u128 = self.oracle_count(); // Save on storage reads
        assert!(
            max_submissions_u64 >= min_submissions_u64,
            "max must equal/exceed min"
        );
        assert!(
            oracle_num >= max_submissions_u64.into(),
            "max cannot exceed total"
        );
        assert!(
            oracle_num == 0 || oracle_num > restart_delay_u64.into(),
            "revert delay cannot exceed total"
        );
        // off for tests
        assert!(
            self.recorded_funds.available >= self.required_reserve(payment_amount_u128),
            "insufficient funds for payment"
        );
        if self.oracle_count() > 0 {
            assert!(min_submissions_u64 > 0, "min must be greater than 0")
        }

        self.payment_amount = payment_amount_u128;
        self.min_submission_count = min_submissions_u64;
        self.max_submission_count = max_submissions_u64;
        self.restart_delay = restart_delay_u64;
        self.timeout = timeout_u64;

        env::log(
            format!(
                "{}, {}, {}, {}, {}",
                payment_amount_u128,
                min_submissions_u64,
                max_submissions_u64,
                restart_delay_u64,
                timeout_u64
            )
            .as_bytes(),
        );
    }

    /**
     * @notice the amount of payment yet to be withdrawn by oracles
     */
    pub fn allocated_funds(&self) -> u128 {
        self.recorded_funds.allocated
    }

    /**
     * @notice the amount of future funding available to oracles
     */
    pub fn available_funds(&self) -> u128 {
        self.recorded_funds.available
    }

    pub fn min_submission_count(&self) -> u64 {
        self.min_submission_count
    }

    pub fn max_submission_count(&self) -> u64 {
        self.max_submission_count
    }

    pub fn restart_delay(&self) -> u64 {
        self.restart_delay
    }

    /**
     * @notice recalculate the amount of LINK available for payouts
     */

    pub fn update_available_funds(&self) {
        let prepaid_gas = env::prepaid_gas();

        // Breaking change here for replacing previous link token code with NEAR's fungible token standard code.
        // let get_balance_promise = env::promise_create(
        //     self.link_token.clone(),
        //     b"get_balance",
        //     json!({ "owner_id": env::current_account_id() })
        //         .to_string()
        //         .as_bytes(),
        //     0,
        //     SINGLE_CALL_GAS,
        // );

        // env::promise_then(
        //     get_balance_promise,
        //     env::current_account_id(),
        //     b"get_balance_promise_results",
        //     json!({}).to_string().as_bytes(),
        //     0,
        //     prepaid_gas / 4,
        // );

        let get_balance_promise = env::promise_create(
            self.link_token.clone(),
            b"ft_balance_of",
            json!({ "account_id": env::current_account_id() })
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );

        env::promise_then(
            get_balance_promise,
            env::current_account_id(),
            b"get_balance_promise_results",
            json!({}).to_string().as_bytes(),
            0,
            prepaid_gas / 4,
        );
    }

    pub fn get_balance_promise_results(&mut self) {
        let funds: &Funds = &self.recorded_funds;
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_balance_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                env::log(b"Check_promise successful");
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let link_balance_str: String = serde_json::from_slice(&get_balance_promise_result).unwrap();
        let link_balance: u128 = link_balance_str.parse().unwrap();

        let now_available: u128 = link_balance - funds.allocated;
        if funds.available != now_available {
            self.recorded_funds.available = now_available;
            env::log(format!("{}", now_available).as_bytes());
        }
    }

    /**
     * @notice returns the number of oracles
     */
    pub fn oracle_count(&self) -> u128 {
        self.oracle_addresses.len() as u128
    }

    /**
     * @notice returns an array of addresses containing the oracles on contract
     */
    pub fn get_oracles(&self) -> Vec<AccountId> {
        self.oracle_addresses.clone()
    }

    pub fn get_payment_amount(&self) -> u128 {
        self.payment_amount
    }

    pub fn get_timeout(&self) -> u64 {
        self.timeout
    }

    pub fn get_validator(&self) -> AccountId {
        self.validator.clone()
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }

    /**
     * @notice get the most recently reported answer
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_answer(&self) -> u128 {
        self.check_access();
        let round_option = self.rounds.get(&self.latest_round_id);
        if round_option.is_none() {
            return 0;
        }
        let round = round_option.unwrap();
        if round.answer == 0 {
            return 0;
        }
        round.answer
    }

    /**
     * @notice get the most recent updated at timestamp
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_timestamp(&self) -> u64 {
        self.check_access();
        let round_option = self.rounds.get(&self.latest_round_id);
        if round_option.is_none() {
            // env::panic(b"Did not find this oracle account. {latest_timestamp}");
            return 0;
        }
        let round = round_option.unwrap();
        round.updated_at
    }

    /**
     * @notice get the ID of the last updated round
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_round(&self) -> u64 {
        self.check_access();
        self.latest_round_id
    }

    /**
     * @notice get past rounds answers
     * @param _roundId the round number to retrieve the answer for
     *
     * @dev #[deprecated] Use getRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended getRoundData
     * instead which includes better verification information.
     */
    pub fn get_answer(&self, _round_id: U128) -> u128 {
        self.check_access();
        let round_id_u128: u128 = _round_id.into();

        let round_option = self.rounds.get(&(round_id_u128 as u64));
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();

        if self.valid_round_id(round_id_u128) {
            return round.answer;
        }
        return 0;
    }

    /**
     * @notice get timestamp when an answer was last updated
     * @param _roundId the round number to retrieve the updated timestamp for
     *
     * @dev #[deprecated] Use getRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended getRoundData
     * instead which includes better verification information.
     */
    pub fn get_timestamp(&self, _round_id: U128) -> u64 {
        self.check_access();
        let round_id_u128: u128 = _round_id.into();

        let round_option = self.rounds.get(&(round_id_u128 as u64));
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();

        if self.valid_round_id(round_id_u128) {
            return round.updated_at;
        }
        return 0;
    }

    /**
     * @notice get data about a round. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values.
     * @param _roundId the round ID to retrieve the round data for
     * @return roundId is the round ID for which data was retrieved
     * @return answer is the answer for the given round
     * @return startedAt is the timestamp when the round was started. This is 0
     * if the round hasn't been started yet.
     * @return updatedAt is the timestamp when the round last was updated (i.e.
     * answer was last computed)
     * @return answeredInRound is the round ID of the round in which the answer
     * was computed. answeredInRound may be smaller than roundId when the round
     * timed out. answeredInRound is equal to roundId when the round didn't time out
     * and was completed regularly.
     * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received
     * maxSubmissions) answer and updatedAt may change between queries.
     */
    pub fn get_round_data(&self, _round_id: U64) -> (u64, u128, u64, u64, u64) {
        self.check_access();
        let round_id_u64: u64 = _round_id.into();

        let round_option = self.rounds.get(&round_id_u64);
        if round_option.is_none() {
            env::panic(b"No data present");
        }
        let round = round_option.unwrap();

        let r: Round = round;
        assert!(
            r.answered_in_round > 0 && self.valid_round_id(round_id_u64.into()),
            V3_NO_DATA_ERROR
        );

        return (
            round_id_u64,
            r.answer,
            r.started_at,
            r.updated_at,
            r.answered_in_round,
        );
    }

    /**
     * @notice get data about the latest round. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values. Consumers are encouraged to
     * use this more fully featured method over the "legacy" latestRound/
     * latestAnswer/latestTimestamp functions. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values.
     * @return roundId is the round ID for which data was retrieved
     * @return answer is the answer for the given round
     * @return startedAt is the timestamp when the round was started. This is 0
     * if the round hasn't been started yet.
     * @return updatedAt is the timestamp when the round last was updated (i.e.
     * answer was last computed)
     * @return answeredInRound is the round ID of the round in which the answer
     * was computed. answeredInRound may be smaller than roundId when the round
     * timed out. answeredInRound is equal to roundId when the round didn't time
     * out and was completed regularly.
     * @dev Note that for in-progress rounds (i.e. rounds that haven't yet
     * received maxSubmissions) answer and updatedAt may change between queries.
     */
    pub fn latest_round_data(&self) -> (u64, u128, u64, u64, u64) {
        self.check_access();
        self.get_round_data(U64::from(self.latest_round_id))
    }

    /**
     * @notice query the available amount of LINK for an oracle to withdraw
     */
    pub fn withdrawable_payment(&self, _oracle: AccountId) -> u128 {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();
        oracle.withdrawable
    }

    /**
     * @notice transfers the oracle's LINK to another address. Can only be called
     * by the oracle's admin.
     * @param _oracle is the oracle whose LINK is transferred
     * @param _recipient is the address to send the LINK to
     * @param _amount is the amount of LINK to send
     */
    #[payable]
    pub fn withdraw_payment(&mut self, _oracle: AccountId, _recipient: AccountId, _amount: U128) {
        let prepaid_gas = env::prepaid_gas();

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.admin == env::predecessor_account_id(),
            "only callable by admin"
        );

        let amount_u128: u128 = _amount.into();
        let available: u128 = oracle.withdrawable;
        assert!(
            available >= amount_u128,
            "revert insufficient withdrawable funds"
        );

        oracle.withdrawable = available - amount_u128;
        self.oracles.insert(&_oracle, &oracle);
        self.recorded_funds.allocated = self.recorded_funds.allocated - amount_u128;

        // Breaking change here for replacing previous link token code with NEAR's fungible token standard code.
        // env::promise_create(
        //     self.link_token.clone(),
        //     b"transfer",
        //     json!({"new_owner_id": _recipient.clone(), "amount": _amount.clone()})
        //         .to_string()
        //         .as_bytes(),
        //     36500000000000000000000,
        //     prepaid_gas / 4,
        // );
        env::promise_create(
            self.link_token.clone(),
            b"ft_transfer",
            json!({"receiver_id": _recipient.clone(), "amount": _amount, "memo": "None"})
                .to_string()
                .as_bytes(),
            DEFAULT_GAS.into(),
            1,
        );
    }

    /**
     * @notice transfers the owner's LINK to another address
     * @param _recipient is the address to send the LINK to
     * @param _amount is the amount of LINK to send
     */
    #[payable]
    pub fn withdraw_funds(&mut self, _recipient: AccountId, _amount: U128) {
        self.only_owner();

        let available: u128 = self.recorded_funds.available as u128;
        let amount_u128: u128 = _amount.into();
        assert!(
            (available - self.required_reserve(self.payment_amount)) >= amount_u128,
            "insufficient reserve funds"
        );
        // Breaking change here for replacing previous link token code with NEAR's fungible token standard code.
        // env::promise_create(
        //     self.link_token.clone(),
        //     b"transfer",
        //     json!({"new_owner_id": _recipient.clone(), "amount": _amount})
        //         .to_string()
        //         .as_bytes(),
        //     36500000000000000000000,
        //     prepaid_gas / 4,
        // );
        env::promise_create(
            self.link_token.clone(),
            b"ft_transfer",
            json!({"receiver_id": _recipient.clone(), "amount": _amount, "memo": "None"})
                .to_string()
                .as_bytes(),
            DEFAULT_GAS.into(),
            1,
        );
        self.update_available_funds();
    }

    /**
     * @notice get the admin address of an oracle
     * @param _oracle is the address of the oracle whose admin is being queried
     */
    pub fn get_admin(&self, _oracle: AccountId) -> AccountId {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let oracle = oracle_option.unwrap();
        oracle.admin
    }

    /**
     * @notice transfer the admin address for an oracle
     * @param _oracle is the address of the oracle whose admin is being transferred
     * @param _newAdmin is the new admin address
     */
    pub fn transfer_admin(&mut self, _oracle: AccountId, _new_admin: AccountId) {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.admin == env::predecessor_account_id(),
            "revert only callable by admin"
        );
        oracle.pending_admin = _new_admin;
        self.oracles.insert(&_oracle, &oracle);
        env::log(
            format!(
                "{}, {}, {}",
                _oracle,
                env::predecessor_account_id(),
                oracle.pending_admin
            )
            .as_bytes(),
        );
    }

    /**
     * @notice accept the admin address transfer for an oracle
     * @param _oracle is the address of the oracle whose admin is being transferred
     */
    pub fn accept_admin(&mut self, _oracle: AccountId) {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.pending_admin == env::predecessor_account_id(),
            "only callable by pending admin"
        );
        oracle.pending_admin = "".to_string();
        oracle.admin = env::predecessor_account_id();
        self.oracles.insert(&_oracle, &oracle);
        env::log(format!("{}, {}", _oracle, env::predecessor_account_id()).as_bytes());
    }

    /**
     * @notice allows non-oracles to request a new round
     */
    pub fn request_new_round(&mut self) -> u64 {
        let requester_option = self.requesters.get(&env::predecessor_account_id());
        if requester_option.is_none() {
            env::panic(b"not authorized requester");
        }
        let requester = requester_option.unwrap();
        assert!(requester.authorized, "not authorized requester");

        let current: u64 = self.reporting_round_id;
        let round_option = self.rounds.get(&current);
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();
        assert!(
            round.updated_at > 0 || self.timed_out(current),
            "prev round must be supersedable"
        );

        let new_round_id: u64 = current + 1;
        self.requester_initialize_new_round(new_round_id);
        return new_round_id;
    }

    /**
     * @notice allows the owner to specify new non-oracles to start new rounds
     * @param _requester is the address to set permissions for
     * @param _authorized is a boolean specifying whether they can start new rounds or not
     * @param _delay is the number of rounds the requester must wait before starting another round
     */
    pub fn set_requester_permissions(
        &mut self,
        _requester: AccountId,
        _authorized: bool,
        _delay: U64,
    ) {
        self.only_owner();
        let delay_u64: u64 = _delay.into();

        let requester_option = self.requesters.get(&_requester);

        let mut requester: Requester;
        if requester_option.is_none() {
            requester = Requester {
                authorized: _authorized,
                delay: u64::from(_delay),
                last_started_round: 0,
            };
        } else {
            requester = requester_option.unwrap();
            if requester.authorized == _authorized {
                return;
            }
        }

        if _authorized {
            requester.authorized = _authorized;
            requester.delay = delay_u64;
            self.requesters.insert(&_requester, &requester);
        } else {
            self.requesters.remove(&_requester);
        }

        env::log(format!("{}, {}, {}", _requester, _authorized, u64::from(_delay)).as_bytes());
    }

    /**
     * @notice called through LINK's transferAndCall to update available funds
     * in the same transaction as the funds were transferred to the aggregator
     * @param _data is mostly ignored. It is checked for length, to be sure
     * nothing strange is passed in.
     */
    pub fn on_token_transfer(&mut self, _address: AccountId, _num: U128, _data: Base64String) {
        assert!(_data.len() == 0, "transfer doesn't accept calldata");
        self.update_available_funds();
    }

    /**
     * @notice a method to provide all current info oracles need. Intended only
     * only to be callable by oracles. Not for use by contracts to read state.
     * @param _oracle the address to look up information for.
     */
    pub fn oracle_round_state(
        &mut self,
        _oracle: AccountId,
        _queried_round_id: U64,
    ) -> (bool, u64, u128, u64, u64, u128, u64, u128) {
        assert!(
            env::predecessor_account_id() == env::signer_account_id(),
            "off-chain reading only"
        );

        let queried_round_id_u64: u64 = _queried_round_id.into();
        if queried_round_id_u64 > 0 {
            let round_option = self.rounds.get(&queried_round_id_u64);
            let mut round: Round;
            if round_option.is_none() {
                round = Round {
                    answer: 0,
                    started_at: 0,
                    updated_at: 0,
                    answered_in_round: 0,
                }
            } else {
                round = round_option.unwrap();
            }
            let detail_option = self.details.get(&u128::from(queried_round_id_u64));
            let mut detail: RoundDetails;
            if detail_option.is_none() {
                detail = RoundDetails {
                    submissions: Vec::new(),
                    max_submissions: 0,
                    min_submissions: 0,
                    timeout: 0,
                    payment_amount: 0,
                }
            } else {
                detail = detail_option.unwrap();
            }
            let oracle_option = self.oracles.get(&_oracle);
            if oracle_option.is_none() {
                env::panic(b"Did not find this round oracle.");
            }
            let oracle = oracle_option.unwrap();
            return (
                self.eligible_for_specific_round(_oracle, queried_round_id_u64),
                queried_round_id_u64,
                oracle.latest_submission,
                round.started_at,
                detail.timeout,
                self.recorded_funds.available,
                self.oracle_count() as u64,
                if round.started_at > 0 {
                    detail.payment_amount
                } else {
                    self.payment_amount
                },
            );
        } else {
            return self.oracle_round_state_suggest_round(_oracle);
        }
    }

    /**
     * @notice method to update the address which does external data validation.
     * @param _newValidator designates the address of the new validation contract.
     */
    pub fn set_validator(&mut self, _new_validator: AccountId) {
        // Look into how to call this function in the initialization while having a an owner_id provided that is not the contract
        if env::predecessor_account_id() != env::current_account_id() {
            self.only_owner();
        }
        let previous: AccountId = String::from(&self.validator) as AccountId;
        let init_new: AccountId = _new_validator.clone();
        if previous != _new_validator {
            self.validator = _new_validator;
            env::log(format!("{}, {}", previous, init_new).as_bytes());
        }
    }

    /**
     * Private
     */

    fn initialize_new_round(&mut self, _round_id: u64) {
        self.update_timed_out_round_info(_round_id - 1);

        self.reporting_round_id = _round_id;
        let vector: Vec<u128> = Vec::new();
        let next_details: RoundDetails = RoundDetails {
            submissions: vector,
            max_submissions: self.max_submission_count,
            min_submissions: self.min_submission_count,
            timeout: self.timeout,
            payment_amount: self.payment_amount,
        };
        let new_round: Round = Round {
            answer: 0_u128,
            started_at: env::block_timestamp() as u64,
            updated_at: 0_u64,
            answered_in_round: 0_u64,
        };
        self.details.insert(&u128::from(_round_id), &next_details);
        self.rounds.insert(&_round_id, &new_round);

        env::log(
            format!(
                "{}, {}, {}",
                _round_id,
                env::predecessor_account_id(),
                new_round.started_at
            )
            .as_bytes(),
        );
    }

    fn oracle_initialize_new_round(&mut self, _round_id: u64) {
        if !self.new_round(_round_id) {
            return;
        }

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(
                format!(
                    "{} Did not find this oracle.",
                    &env::predecessor_account_id()
                )
                .as_bytes(),
            );
        }
        let mut oracle = oracle_option.unwrap();

        let last_started: u64 = oracle.last_started_round; // cache storage reads
        if _round_id <= last_started + self.restart_delay && last_started != 0 {
            return;
        }
        self.initialize_new_round(_round_id);
        oracle.last_started_round = _round_id;
        self.oracles.insert(&env::predecessor_account_id(), &oracle);
    }

    fn requester_initialize_new_round(&mut self, _round_id: u64) {
        if !self.new_round(_round_id) {
            return;
        }
        let requester_option = self.requesters.get(&env::predecessor_account_id());
        if requester_option.is_none() {
            env::panic(b"Did not find this requester.");
        }
        let mut requester = requester_option.unwrap();

        let last_started: u128 = requester.last_started_round.into(); // cache storage reads
        assert!(
            (_round_id as u128) > last_started + (requester.delay as u128) || last_started == 0,
            "must delay requests"
        );

        self.initialize_new_round(_round_id);

        requester.last_started_round = _round_id;
        self.requesters
            .insert(&env::predecessor_account_id(), &requester);
    }

    fn update_timed_out_round_info(&mut self, _round_id: u64) {
        if !self.timed_out(_round_id) {
            return;
        }
        let prev_id: u64 = _round_id - 1;

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            env::panic(format!("{} Did not find this round.", _round_id.to_string()).as_bytes());
        }
        let mut round = round_option.unwrap();

        let prev_option = self.rounds.get(&prev_id);
        if prev_option.is_none() {
            env::panic(
                format!("{} Did not find this previous round.", prev_id.to_string()).as_bytes(),
            );
            // return;
        }
        let prev = prev_option.unwrap();

        round.answer = prev.answer;
        round.answered_in_round = prev.answered_in_round;
        round.updated_at = env::block_timestamp() as u64;
        self.rounds.insert(&_round_id, &round);

        self.details.remove(&(_round_id as u128));
    }

    fn eligible_for_specific_round(&mut self, _oracle: AccountId, _queried_round_id: u64) -> bool {
        let init_oracle = &_oracle;
        let round_option = self.rounds.get(&_queried_round_id);
        let mut round: Round;
        if round_option.is_none() {
            round = Round {
                answer: 0,
                started_at: 0,
                updated_at: 0,
                answered_in_round: 0,
            };
        } else {
            round = round_option.unwrap();
        }
        if round.started_at > 0 {
            return self.accepting_submissions(_queried_round_id.into())
                && self
                    .validate_oracle_round(init_oracle.to_string(), _queried_round_id)
                    .len()
                    == 0;
        } else {
            return self.delayed(_oracle.to_string(), _queried_round_id)
                && self
                    .validate_oracle_round(init_oracle.to_string(), _queried_round_id)
                    .len()
                    == 0;
        }
    }

    fn oracle_round_state_suggest_round(
        &mut self,
        _oracle: AccountId,
    ) -> (bool, u64, u128, u64, u64, u128, u64, u128) {
        let round_option = self.rounds.get(&1);
        let init_oracle = &_oracle;
        let mut round: Round;

        if round_option.is_none() {
            round = Round {
                answer: 0,
                started_at: 0,
                updated_at: 0,
                answered_in_round: 0,
            };
        } else {
            round = round_option.unwrap();
        }

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();

        let should_supersede: bool = oracle.last_reported_round == self.reporting_round_id
            || !self.accepting_submissions(self.reporting_round_id as u128);

        // Instead of nudging oracles to submit to the next round, the inclusion of
        // the should_supersede bool in the if condition pushes them towards
        // submitting in a currently open round.

        let mut _round_id: u64;
        let mut _payment_amount: u128;
        let mut _eligible_to_submit: bool;
        let _reporting_round_id: u64 = self.reporting_round_id;

        let detail_option = self.details.get(&(_reporting_round_id as u128));
        let mut detail: RoundDetails;

        if detail_option.is_none() {
            detail = RoundDetails {
                submissions: Vec::new(),
                max_submissions: 0,
                min_submissions: 0,
                timeout: 0,
                payment_amount: 0,
            }
        } else {
            detail = detail_option.unwrap();
        }
        if self.supersedable(self.reporting_round_id) && should_supersede {
            _round_id = self.reporting_round_id + 1;

            let round_from_id_option = self.rounds.get(&_round_id);
            if round_from_id_option.is_none() {
                // Do nothing, keep the round the same
            } else {
                round = round_from_id_option.unwrap();
            }
            _payment_amount = self.payment_amount;
            _eligible_to_submit = self.delayed(_oracle.to_string(), _round_id);
        } else {
            _round_id = self.reporting_round_id;

            let round_from_id_option = self.rounds.get(&_reporting_round_id);
            if round_from_id_option.is_none() {
                // Do nothing, keep the round the same
            } else {
                round = round_from_id_option.unwrap();
            }

            _payment_amount = detail.payment_amount;
            _eligible_to_submit = self.accepting_submissions(_round_id.into());
        }

        if self
            .validate_oracle_round(init_oracle.to_string(), _round_id)
            .len()
            != 0
        {
            _eligible_to_submit = false;
        }

        return (
            _eligible_to_submit,
            _round_id,
            oracle.latest_submission,
            round.started_at,
            detail.timeout,
            self.recorded_funds.available,
            self.oracle_count() as u64,
            _payment_amount,
        );
    }

    fn update_round_answer(&mut self, _round_id: u64) -> (bool, u128) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();
        let submissions_length = detail.submissions.len() as u64;

        if submissions_length < detail.min_submissions {
            return (false, 0 as u128);
        }

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let mut round = round_option.unwrap();

        let new_answer: u128 = self.median(detail.submissions).into();
        env::log(format!("{}", new_answer).as_bytes());

        round.answer = new_answer;
        round.updated_at = env::block_timestamp() as u64;
        round.answered_in_round = _round_id;
        self.rounds.insert(&_round_id, &round);
        self.latest_round_id = _round_id;

        return (true, new_answer);
    }

    fn validate_answer(&self, _round_id: u64, _new_answer: u128) {
        let av: AccountId = self.validator.clone(); // cache storage reads
        if av == "" {
            return;
        }

        let prev_round: u64 = _round_id - 1;

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();

        let prev_answer_round_id: u64 = round.answered_in_round;
        let prev_round_answer: u128 = round.answer;
        // TRY CATCH
    }

    fn pay_oracle(&mut self, _round_id: u64) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        let payment: u128 = detail.payment_amount;
        let mut funds: Funds = self.recorded_funds.clone();

        env::log(format!("{}", funds.available.saturating_sub(payment)).as_bytes());
        env::log(format!("{}", funds.allocated.saturating_add(payment)).as_bytes());

        funds.available = funds.available.saturating_sub(payment);
        funds.allocated = funds.allocated.saturating_add(payment);
        self.recorded_funds = funds;
        self.oracles.remove(&env::predecessor_account_id());
        oracle.withdrawable = oracle.withdrawable.saturating_add(payment);
        self.oracles.insert(&env::predecessor_account_id(), &oracle);
    }

    fn record_submission(&mut self, _submission: u128, _round_id: u128) {
        assert!(
            self.accepting_submissions(_round_id),
            "round not accepting submissions"
        );

        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let mut detail = detail_option.unwrap();

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        detail.submissions.push(_submission);
        self.details.insert(&(_round_id as u128), &detail);

        oracle.last_reported_round = _round_id as u64;
        oracle.latest_submission = _submission;

        self.oracles.insert(&env::predecessor_account_id(), &oracle);
    }

    fn delete_round_details(&mut self, _round_id: u64) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();

        if (detail.submissions.len() as u64) < detail.max_submissions {
            return;
        } else {
            self.details.remove(&(_round_id as u128));
        }
    }

    fn timed_out(&mut self, _round_id: u64) -> bool {
        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();

        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            return false;
        }
        let detail = detail_option.unwrap();

        let started_at: u64 = round.started_at;
        let round_timeout: u64 = detail.timeout;

        // commented out for test failure
        // return started_at > 0
        //     && round_timeout > 0
        //     && ((started_at + round_timeout) < env::block_timestamp());
        return false;
    }

    fn get_starting_round(&self, _oracle: AccountId) -> u64 {
        let current_round: u64 = self.reporting_round_id;
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return current_round + 1;
        }
        let oracle = oracle_option.unwrap();

        if current_round != 0 && current_round == oracle.ending_round as u64 {
            return current_round;
        }
        return current_round + 1;
    }

    fn previous_and_current_unanswered(&self, _round_id: u64, _rr_id: u64) -> bool {
        let round_option = self.rounds.get(&_rr_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        return (_round_id + 1) == _rr_id && round.updated_at == 0;
    }

    fn required_reserve(&self, payment: u128) -> u128 {
        return payment * (self.oracle_count() * RESERVE_ROUNDS);
    }

    fn add_oracle(&mut self, _oracle: AccountId, _admin: AccountId) {
        let init_oracle = &_oracle;
        let init_admin = &_admin;
        assert!(
            !self.oracle_enabled(init_oracle.to_string()),
            "oracle already enabled"
        );
        assert!(_admin != "", "cannot set admin to 0");
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            // assert not required since there is_none
            let oracle: OracleStatus = OracleStatus {
                withdrawable: 0_u128,
                starting_round: self.get_starting_round(_oracle.clone()),
                ending_round: ROUND_MAX,
                last_reported_round: 0_u64,
                last_started_round: 0_u64,
                latest_submission: 0_u128,
                index: self.oracle_addresses.len() as u64,
                admin: _admin.clone(),
                pending_admin: "".to_string(),
            };
            self.oracles.insert(&_oracle, &oracle);
            self.oracle_addresses.push(_oracle.clone());
        } else {
            assert!(
                oracle_option.unwrap().admin == _admin,
                "owner cannot overwrite admin"
            );
        }
        // Oracle Permissions Updated
        env::log(format!("{}, {}", &init_oracle.clone(), true).as_bytes());
        // Oracle Admin Updated
        env::log(format!("{}, {}", &init_admin.clone(), true).as_bytes());
    }

    fn remove_oracle(&mut self, _oracle: AccountId) {
        let init_oracle = &_oracle;
        assert!(
            self.oracle_enabled(init_oracle.to_string()),
            "oracle not enabled"
        );

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        let last_oracle: usize = (self.oracle_count() - 1) as usize;
        let tail: AccountId = self.oracle_addresses[last_oracle].clone();
        let init_tail = &tail;

        let oracle_tail_option = self.oracles.get(&tail);
        if oracle_tail_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle_tail = oracle_tail_option.unwrap();

        oracle.ending_round = (self.reporting_round_id + 1).into();
        let index: usize = oracle.index.try_into().unwrap();
        oracle_tail.index = index.try_into().unwrap();
        oracle.index = 0_u64;
        self.oracle_addresses[index] = init_tail.to_string();
        self.oracle_addresses.pop();

        self.oracles.insert(&_oracle, &oracle);
        self.oracles.insert(&tail, &oracle_tail);
        // Oracle Permissions Updated
        env::log(format!("{}, {}", &init_oracle.clone(), false).as_bytes());
    }

    fn validate_oracle_round(&mut self, _oracle: AccountId, _round_id: u64) -> Base64String {
        // cache storage reads
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return "not enabled oracle".to_string();
        }
        let oracle = oracle_option.unwrap();
        let starting_round: u64 = oracle.starting_round;
        let rr_id: u64 = self.reporting_round_id;
        if starting_round == 0 {
            return "not enabled oracle".to_string();
        } else if starting_round > _round_id {
            return "not yet enabled oracle".to_string();
        } else if oracle.ending_round < _round_id.into() {
            return "no longer allowed oracle".to_string();
        } else if oracle.last_reported_round >= _round_id {
            return "cannot report on previous rounds".to_string();
        } else if _round_id != rr_id
            && _round_id != rr_id + 1
            && !self.previous_and_current_unanswered(_round_id, rr_id)
        {
            return "invalid round to report".to_string();
        } else if _round_id != 1 && !self.supersedable(_round_id - 1) {
            return "previous round not supersedable".to_string();
        } else {
            return "".to_string();
        }
    }

    fn supersedable(&mut self, _round_id: u64) -> bool {
        if self.timed_out(_round_id) {
            return self.timed_out(_round_id);
        }

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        round.updated_at > 0
    }

    fn oracle_enabled(&self, _oracle: AccountId) -> bool {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return false;
        }
        let oracle = oracle_option.unwrap();
        oracle.ending_round == ROUND_MAX
    }

    fn accepting_submissions(&self, _round_id: u128) -> bool {
        let round_option = self.details.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        round.max_submissions != 0
    }

    fn delayed(&self, _oracle: AccountId, _round_id: u64) -> bool {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();
        let last_started: u64 = oracle.last_started_round;
        _round_id > (last_started + self.restart_delay) || last_started == 0
    }

    fn new_round(&self, _round_id: u64) -> bool {
        _round_id == self.reporting_round_id + 1
    }

    fn valid_round_id(&self, _round_id: u128) -> bool {
        _round_id <= ROUND_MAX
    }

    fn only_owner(&self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only callable by owner"
        );
    }

    fn median(&mut self, mut numbers: Vec<u128>) -> u128 {
        numbers.sort();
        let _mid = numbers.len() / 2;
        let sum: u128 = numbers.iter().sum();
        let len: u128 = numbers.len().try_into().unwrap();
        sum / len
    }

    pub fn get_decimals(&self) -> u64 {
        self.decimals
    }
    pub fn get_description(&self) -> String {
        self.description.clone()
    }
    pub fn get_version(&self) -> u128 {
        VERSION
    }

    pub fn accept_ownership(&mut self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.pending_owner,
            "Must be proposed owner"
        );
        let old_owner: AccountId = self.owner.clone();
        self.owner = env::predecessor_account_id();
        self.pending_owner = "".to_string();
        env::log(format!("{}, {}", old_owner, env::predecessor_account_id()).as_bytes());
    }

    pub fn transfer_ownership(&mut self, _to: AccountId) {
        self.only_owner();
        let init_to: AccountId = _to.clone();
        self.pending_owner = _to;
        env::log(format!("{}, {}", self.owner, init_to).as_bytes());
    }

    pub fn get_check_enabled(&self) -> bool {
        self.check_enabled
    }

    // Allow any non-contract account to read the answers.
    // If a contract account is requesting the data, make sure they are in the access list or the check is disabled.
    
    pub fn has_access(&self, _user: AccountId) -> bool {
        if env::signer_account_id() != env::predecessor_account_id() {
            if !self.check_enabled {
                !self.check_enabled
            } else {
                let user_option = self.access_list.get(&_user);
                if user_option.is_none() {
                    return false;
                }
                let user = user_option.unwrap();
                user
            }
        } else {
           true
        }
    }

    pub fn add_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            self.access_list.insert(&_user, &true);

            env::log(format!("{}", &_user).as_bytes());
        }
    }

    pub fn remove_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            env::panic(b"Did not find the address in the access list.");
        } else {
            self.access_list.insert(&_user, &false);
            env::log(format!("{}", &_user).as_bytes());
        }
    }

    pub fn enable_access_check(&mut self) {
        self.only_owner();

        if !self.check_enabled {
            self.check_enabled = true;

            env::log(format!("CheckAccessEnabled").as_bytes());
        }
    }

    pub fn disable_access_check(&mut self) {
        self.only_owner();

        if self.check_enabled {
            self.check_enabled = false;
            env::log(format!("CheckAccessDisabled").as_bytes());
        }
    }

    fn check_access(&self) {
        assert!(self.has_access(env::predecessor_account_id()), "No access");
    }
}

'''
'''--- contract-wrap/aggregator_vaildator_mock/Cargo.toml ---
[package]
name = "aggregator_vaildator_mock"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/aggregator_vaildator_mock/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, ext_contract, near_bindgen, AccountId, PromiseResult};
use std::convert::TryInto;
use std::str;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct AggregatorValidatorMock {
    pub previous_round_id: u128,
    pub previous_answer: u128,
    pub current_round_id: u128,
    pub current_answer: u128,
}

impl Default for AggregatorValidatorMock {
    fn default() -> Self {
        panic!("AggregatorValidatorMock should be initialized before usage");
    }
}

#[near_bindgen]
impl AggregatorValidatorMock {

    #[init]
    pub fn new() -> Self {
        let result = Self {
            previous_round_id: 0,
            previous_answer: 0,
            current_round_id: 0,
            current_answer: 0,
        };
        result
    }

    pub fn validate(
        &self,
        previous_round_id: U128,
        previous_answer: U128,
        current_round_id: U128,
        current_answer: U128,
    ) -> bool {
        env::log(
            format!(
                "{}, {}, {}, {}",
                u128::from(previous_round_id),
                u128::from(previous_answer),
                u128::from(current_round_id),
                u128::from(current_answer)
            )
            .as_bytes(),
        );
        true
    }
}

'''
'''--- contract-wrap/build.sh ---
export RUSTFLAGS='-C link-arg=-s'
cargo build --all --target wasm32-unknown-unknown

'''
'''--- contract-wrap/eac_aggregator_proxy/Cargo.toml ---
[package]
name = "eac_aggregator_proxy"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/eac_aggregator_proxy/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue, PromiseResult};
use num_traits::pow;
use std::convert::TryInto;
use std::str;

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13

pub type Base64String = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Phase {
    id: u64,
    aggregator: AccountId,
}

const PHASE_OFFSET: u128 = 64;
// const PHASE_SIZE: u128 = 16;

fn find_pow() -> u128 {
    (pow(2, 80)) - 1
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct EACAggregatorProxy {
    pub owner: AccountId,
    pub proposed_aggregator: AccountId,
    pub phase_aggregators: LookupMap<u64, AccountId>,
    pub access_controller: AccountId,
    current_phase: Phase,
}

impl Default for EACAggregatorProxy {
    fn default() -> Self {
        panic!("EACAggregatorProxy should be initialized before usage")
    }
}

#[near_bindgen]
impl EACAggregatorProxy {
    #[init]
    pub fn new(owner_id: AccountId, _aggregator: AccountId, _access_controller: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");

        let mut result = Self {
            owner: owner_id,
            proposed_aggregator: "".to_string(),
            phase_aggregators: LookupMap::new(b"phase_aggregators".to_vec()),
            access_controller: "".to_string(),
            current_phase: Phase {
                id: 0_u64,
                aggregator: "".to_string(),
            },
        };

        result.set_aggregator(_aggregator);
        result.set_controller(_access_controller);
        result
    }

    pub fn set_controller(&mut self, _access_controller: AccountId) {
        self.only_owner();
        self.access_controller = _access_controller;
    }

    pub fn latest_answer(&mut self) {
        self.check_access();
        let get_latest_answer_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"latest_answer",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let latest_answer_results_promise = env::promise_then(
            get_latest_answer_promise,
            env::current_account_id(),
            b"latest_answer_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(latest_answer_results_promise);
    }

    pub fn latest_answer_results(&self) -> u128 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_latest_answer_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_latest_answer_promise_result).unwrap()
    }

    pub fn latest_timestamp(&mut self) {
        self.check_access();
        let get_latest_timestamp_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"latest_timestamp",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let latest_timestamp_results_promise = env::promise_then(
            get_latest_timestamp_promise,
            env::current_account_id(),
            b"latest_timestamp_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(latest_timestamp_results_promise);
    }

    pub fn latest_timestamp_results(&self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_latest_timestamp_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_latest_timestamp_promise_result).unwrap()
    }

    pub fn get_answer(&mut self, _round_id: U128) {
        self.check_access();
        let round_id_u128: u128 = _round_id.into();
        let (phase_id, aggregator_round_id): (u64, u64) = self.parse_ids(round_id_u128);
        let phase_aggregator_option = self.phase_aggregators.get(&phase_id);
        if phase_aggregator_option.is_none() {
            env::panic(b"Phase aggregator account not found");
        }
        let phase_aggregator_option_address = phase_aggregator_option.unwrap();
        let get_answer_promise = env::promise_create(
            phase_aggregator_option_address,
            b"get_answer",
            json!({ "_round_id": aggregator_round_id })
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_answer_results_promise = env::promise_then(
            get_answer_promise,
            env::current_account_id(),
            b"get_answer_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_answer_results_promise);
    }
    pub fn get_answer_results(&self) -> u128 {
        let get_answer_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let get_answer_promise_result_json: u128 =
            serde_json::from_slice(&get_answer_promise_result).unwrap();
        get_answer_promise_result_json
    }

    // Depracated
    // pub fn get_answer(&mut self, _round_id: U128) -> ≈ {
    //     self.check_access();
    //     let prepaid_gas = env::prepaid_gas();
    //     let round_id_u128: u128 = _round_id.into();
    //     if round_id_u128 > find_pow() {
    //         return PromiseOrValue::Value(0);
    //     }

    //     let (phase_id, aggregator_round_id): (u64, u64) = self.parse_ids(round_id_u128);

    //     let aggregator_option = self.phase_aggregators.get(&phase_id);
    //     if aggregator_option.is_none() {
    //         env::panic(b"Aggregator account not found");
    //     }
    //     let phase_aggregator = aggregator_option.unwrap();
    //     let get_latest_timestamp_promise = env::promise_create(
    //         self.current_phase.aggregator.clone(),
    //         b"get_answer",
    //         json!({"_roundId": aggregator_round_id}).to_string().as_bytes(),
    //         0,
    //         SINGLE_CALL_GAS,
    //     );

    //     let promise3 = env::promise_then(get_latest_timestamp_promise, env::current_account_id(), b"latest_timestamp_results", json!({}).to_string().as_bytes(), 0, prepaid_gas / 4);
    //     env::promise_return(promise3)

    // }

    // pub fn get_answer_results(&self) -> u128 {
    //     assert_eq!(env::current_account_id(), env::predecessor_account_id());
    //     assert_eq!(env::promise_results_count(), 1);
    //     let get_answer_promise_result: Vec<u8> =
    //     match env::promise_result(0) {
    //         PromiseResult::Successful(_x) => {
    //             env::log(b"Check_promise successful");
    //             _x
    //         }
    //         _x => panic!("Promise with index 0 failed"),
    //     };
    //     serde_json::from_slice(&get_answer_promise_result).unwrap()
    // }
    // Depracated
    // pub fn get_timestamp(&self, _round_id: U128) -> PromiseOrValue<u128> {
    //     self.check_access();
    //     let round_id_u128: u128 = _round_id.into();
    //     if round_id_u128 > find_pow() {
    //         return PromiseOrValue::Value(0);
    //     }

    //     let (phase_id, aggregator_round_id): (u64, u64) = self.parse_ids(round_id_u128);

    //     let aggregator_option = self.phase_aggregators.get(&phase_id);
    //     if aggregator_option.is_none() {
    //         env::panic(b"Aggregator account not found");
    //     }
    //     let phase_aggregator = aggregator_option.unwrap();

    //     PromiseOrValue::Promise(
    //         Promise::new(phase_aggregator)
    //             .function_call(
    //                 b"get_timestamp".to_vec(),
    //                 json!({ "_roundId": aggregator_round_id })
    //                     .to_string()
    //                     .as_bytes()
    //                     .to_vec(),
    //                 0,
    //                 SINGLE_CALL_GAS,
    //             )
    //             .as_return(),
    //     )
    // }

    pub fn latest_round(&mut self) {
        self.check_access();
        let prepaid_gas = env::prepaid_gas();
        let get_latest_round_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"latest_round",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );

        let latest_round_results_promise = env::promise_then(
            get_latest_round_promise,
            env::current_account_id(),
            b"latest_round_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(latest_round_results_promise);
    }

    pub fn latest_round_results(&self) -> u128 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_latest_round_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let latest_round_id: u64 =
            serde_json::from_slice(&get_latest_round_promise_result).unwrap();
        self.add_phase(self.current_phase.id, latest_round_id.try_into().unwrap())
    }

    pub fn get_round_data(&mut self, _round_id: U128) {
        self.check_access();
        let round_id_u128: u128 = _round_id.into();
        let (phase_id, aggregator_round_id): (u64, u64) = self.parse_ids(round_id_u128);
        let phase_aggregator_option = self.phase_aggregators.get(&phase_id);
        if phase_aggregator_option.is_none() {
            env::panic(b"Phase aggregator account not found");
        }
        let phase_aggregator_option_address = phase_aggregator_option.unwrap();
        let get_round_data_promise = env::promise_create(
            phase_aggregator_option_address,
            b"get_round_data",
            json!({ "_round_id": aggregator_round_id })
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_round_data_results_promise = env::promise_then(
            get_round_data_promise,
            env::current_account_id(),
            b"get_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_round_data_results_promise);
    }
    pub fn get_round_data_results(&self) -> (u128, u128, u128, u128, u128) {
        let get_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let get_round_data_promise_result_json: (u128, u128, u128, u128, u64) =
            serde_json::from_slice(&get_round_data_promise_result).unwrap();
        self.add_phase_ids(
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.1,
            get_round_data_promise_result_json.2,
            get_round_data_promise_result_json.3,
            get_round_data_promise_result_json.4,
        )
    }

    pub fn latest_round_data(&mut self) {
        // let current = &self.current_phase; // cache storage reads
        self.check_access();
        let get_latest_round_data_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"latest_round_data",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_latest_data_results_promise = env::promise_then(
            get_latest_round_data_promise,
            env::current_account_id(),
            b"latest_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS
        );
        env::promise_return(get_latest_data_results_promise);
    }

    pub fn latest_round_data_results(&self) -> (u128, u128, u128, u128, u128) {
        let get_latest_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(x) => x,
            _ => panic!("Promise with index 0 failed"),
        };
        let get_latest_round_data_promise_result_json: (u128, u128, u128, u128, u64) =
            serde_json::from_slice(&get_latest_round_data_promise_result).unwrap();
        self.add_phase_ids(
            get_latest_round_data_promise_result_json.0,
            get_latest_round_data_promise_result_json.0,
            get_latest_round_data_promise_result_json.1,
            get_latest_round_data_promise_result_json.2,
            get_latest_round_data_promise_result_json.3,
            self.current_phase.id.clone(),
        )
    }

    pub fn proposed_get_round_data(&mut self, _round_id: U128) {
        self.check_access();
        self.has_proposal();
        let round_id_u128: u128 = _round_id.into();
        let get_proposed_round_data_promise = env::promise_create(
            self.proposed_aggregator.clone(),
            b"get_round_data",
            json!({ "_round_id": round_id_u128 })
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_proposed_round_data_results_promise = env::promise_then(
            get_proposed_round_data_promise,
            env::current_account_id(),
            b"proposed_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_proposed_round_data_results_promise);
    }
    pub fn proposed_round_data_results(&self) -> (u128, u128, u128, u128, u128) {
        let get_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let get_round_data_promise_result_json: (u128, u128, u128, u128, u64) =
            serde_json::from_slice(&get_round_data_promise_result).unwrap();
        self.add_phase_ids(
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.1,
            get_round_data_promise_result_json.2,
            get_round_data_promise_result_json.3,
            get_round_data_promise_result_json.4,
        )
    }

    pub fn proposed_latest_round_data(&mut self, _round_id: U128) {
        self.check_access();
        self.has_proposal();
        let round_id_u128: u128 = _round_id.into();
        let get_proposed_latest_round_data_promise = env::promise_create(
            self.proposed_aggregator.clone(),
            b"get_round_data",
            json!({ "_round_id": round_id_u128 })
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_proposed_latest_round_data_results_promise = env::promise_then(
            get_proposed_latest_round_data_promise,
            env::current_account_id(),
            b"proposed_latest_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_proposed_latest_round_data_results_promise);
    }

    pub fn proposed_latest_round_data_results(&self) -> (u128, u128, u128, u128, u128) {
        let get_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let get_round_data_promise_result_json: (u128, u128, u128, u128, u64) =
            serde_json::from_slice(&get_round_data_promise_result).unwrap();
        self.add_phase_ids(
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.0,
            get_round_data_promise_result_json.1,
            get_round_data_promise_result_json.2,
            get_round_data_promise_result_json.3,
            get_round_data_promise_result_json.4,
        )
    }

    pub fn aggregator(&self) -> String {
        self.current_phase.aggregator.clone()
    }

    pub fn phase_id(&self) -> u64 {
        self.current_phase.id
    }

    pub fn get_decimals(&self) {
        let get_decimals_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"get_decimals",
            json!({})
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_decimals_results_promise = env::promise_then(
            get_decimals_promise,
            env::current_account_id(),
            b"get_decimals_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_decimals_results_promise);
    }

    pub fn get_decimals_results(&self) -> u64 {
        let get_decimals_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_decimals_promise_result).unwrap()
    }

    pub fn get_version(&self) {
        let get_version_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"get_version",
            json!({})
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_version_results_promise = env::promise_then(
            get_version_promise,
            env::current_account_id(),
            b"get_version_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_version_results_promise);
    }

    pub fn get_version_results(&self) -> u128 {
        let get_version_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_version_promise_result).unwrap()
    }

    pub fn get_description(&self) {
        let get_description_promise = env::promise_create(
            self.current_phase.aggregator.clone(),
            b"get_description",
            json!({})
                .to_string()
                .as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_description_results_promise = env::promise_then(
            get_description_promise,
            env::current_account_id(),
            b"get_description_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_description_results_promise);
    }

    pub fn get_description_results(&self) -> u128 {
        let get_description_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_description_promise_result).unwrap()
    }

    pub fn propose_aggregator(&mut self, _aggregator: AccountId) {
        self.only_owner();
        self.proposed_aggregator = _aggregator;
    }

    pub fn confirm_aggregator(&mut self, _aggregator: AccountId) {
        self.only_owner();
        assert!(
            _aggregator == self.proposed_aggregator.clone(),
            "Invalid proposed aggregator"
        );
        self.proposed_aggregator.clear();
        self.set_aggregator(_aggregator);
    }

    fn set_aggregator(&mut self, _aggregator: AccountId) {
        let id: u64 = self.current_phase.id.saturating_add(1);
        let phase_aggregator_option = self.phase_aggregators.get(&id);
        if phase_aggregator_option.is_some() {
            env::panic(b"Phase aggregator account not found");
        }
        self.phase_aggregators.insert(&id, &_aggregator);
        self.current_phase = Phase {
            id: id,
            aggregator: _aggregator,
        };
    }

    fn add_phase(&self, _phase: u64, _original_id: u64) -> u128 {
        (_phase as u128) << PHASE_OFFSET | _original_id as u128
    }

    fn parse_ids(&self, _round_id: u128) -> (u64, u64) {
        let phase_id: u64 = (_round_id >> PHASE_OFFSET) as u64;
        let aggregator_round_id: u64 = _round_id as u64;

        (phase_id, aggregator_round_id)
    }

    fn add_phase_ids(
        &self,
        round_id: u128,
        answer: u128,
        started_at: u128,
        updated_at: u128,
        answered_in_round: u128,
        phase_id: u64,
    ) -> (u128, u128, u128, u128, u128) {
        (
            self.add_phase(phase_id, round_id as u64),
            answer,
            started_at,
            updated_at,
            self.add_phase(phase_id, answered_in_round as u64),
        )
    }

    // Modifiers

    fn has_proposal(&mut self) {
        assert!(
            self.proposed_aggregator != "",
            "No proposed aggregator present"
        );
    }

    fn only_owner(&mut self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only contract owner can call this method."
        );
    }

    fn call_access_controller_has_access(&mut self, _user: AccountId) {
        let get_has_access_promise = env::promise_create(
            self.access_controller.clone(),
            b"has_access",
            json!({ "_user": _user }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );

        let get_has_access_results_promise = env::promise_then(
            get_has_access_promise,
            env::current_account_id(),
            b"call_access_controller_has_access_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_has_access_results_promise);
    }

    fn call_access_controller_has_access_results(&self) -> bool {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_has_access_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        serde_json::from_slice(&get_has_access_promise_result).unwrap()
    }

    fn check_access(&mut self) {
        let get_has_access_promise = env::promise_create(
            env::current_account_id(),
            b"call_access_controller_has_access",
            json!({ "_user": env::predecessor_account_id() }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );

        let get_has_access_results_promise = env::promise_then(
            get_has_access_promise,
            env::current_account_id(),
            b"check_access_callback",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_has_access_results_promise);
    }

    fn check_access_callback(&self) {
        let get_has_access_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => {
                _x
            }
            _x => panic!("Promise with index 0 failed"),
        };
        let prom_re: bool = serde_json::from_slice(&get_has_access_promise_result).unwrap();
        assert!(self.access_controller == "" || prom_re, "No access");
    }
}

'''
'''--- contract-wrap/flags_test_helper/Cargo.toml ---
[package]
name = "flags_test_helper"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/flags_test_helper/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::{Promise, PromiseOrValue, PromiseResult};

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FlagsTestHelper {
    pub flags: AccountId,
}

impl Default for FlagsTestHelper {
    fn default() -> Self {
        panic!("FlagsTestHelper should be initialized before usage")
    }
}

#[near_bindgen]
impl FlagsTestHelper {
    #[init]
    pub fn new(flags_contract: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(flags_contract.as_bytes()),
            "Flag's account ID is invalid"
        );
        let result = Self {
            flags: flags_contract.to_string(),
        };
        result
    }

    pub fn get_flag(&self, subject: AccountId) {
        let get_flag_promise = env::promise_create(
            self.flags.clone(),
            b"get_flag",
            json!({ "subject": subject }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_flag_promise_result = env::promise_then(
            get_flag_promise,
            env::current_account_id(),
            b"get_flag_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_flag_promise_result);
    }

    pub fn get_flag_results(&self) -> bool {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_flag_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let subject: bool = serde_json::from_slice(&get_flag_promise_result).unwrap();
        subject
    }

    pub fn get_flags(&self, subjects: Vec<AccountId>) {
        let get_flags_promise = env::promise_create(
            self.flags.clone(),
            b"get_flags",
            json!({ "subjects": subjects }).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let get_flags_promise_result = env::promise_then(
            get_flags_promise,
            env::current_account_id(),
            b"get_flags_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(get_flags_promise_result);
    }

    pub fn get_flags_results(&self) -> Vec<bool> {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_flags_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let subjects: Vec<bool> = serde_json::from_slice(&get_flags_promise_result).unwrap();
        subjects
    }

}

'''
'''--- contract-wrap/flux_aggregator/Cargo.toml ---
[package]
name = "flux_aggregator"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/flux_aggregator/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, ext_contract, near_bindgen, AccountId, PromiseResult};
use std::convert::TryInto;
use std::str;

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;
pub const DEFAULT_GAS: u64 = 300_000_000_000_000;
pub type Base64String = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Round {
    answer: u128,
    started_at: u64,
    updated_at: u64,
    answered_in_round: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RoundDetails {
    submissions: Vec<u128>,
    max_submissions: u64,
    min_submissions: u64,
    timeout: u64,
    payment_amount: u128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OracleStatus {
    withdrawable: u128,
    starting_round: u64,
    ending_round: u128,
    last_reported_round: u64,
    last_started_round: u64,
    latest_submission: u128,
    index: u64,
    admin: AccountId,
    pending_admin: AccountId,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Requester {
    authorized: bool,
    delay: u64,
    last_started_round: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Funds {
    available: u128,
    allocated: u128,
}

const VERSION: u128 = 3;
const RESERVE_ROUNDS: u128 = 2;
const MAX_ORACLE_COUNT: u128 = 77;
const ROUND_MAX: u128 = 4294967295; // 2**32-1
const V3_NO_DATA_ERROR: &str = "No data present";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FluxAggregator {
    pub owner: AccountId,
    pending_owner: AccountId,
    pub link_token: AccountId,
    pub validator: AccountId,
    pub payment_amount: u128,
    pub max_submission_count: u64,
    pub min_submission_count: u64,
    pub restart_delay: u64,
    pub timeout: u64,
    pub decimals: u64,
    pub description: Base64String,
    pub min_submission_value: u128,
    pub max_submission_value: u128,
    reporting_round_id: u64,
    latest_round_id: u64,
    oracles: LookupMap<AccountId, OracleStatus>,
    rounds: LookupMap<u64, Round>,
    details: LookupMap<u128, RoundDetails>,
    requesters: LookupMap<AccountId, Requester>,
    oracle_addresses: Vec<AccountId>,
    recorded_funds: Funds,
}

impl Default for FluxAggregator {
    fn default() -> Self {
        panic!("FluxAggregator should be initialized before usage");
    }
}

#[near_bindgen]
impl FluxAggregator {
    /**
     * @notice set up the aggregator with initial configuration
     * @param _link The address of the LINK token
     * @param _paymentAmount The amount paid of LINK paid to each oracle per submission, in wei (units of 10⁻¹⁸ LINK)
     * @param _timeout is the number of seconds after the previous round that are
     * allowed to lapse before allowing an oracle to skip an unfinished round
     * @param _validator is an optional contract address for validating
     * external validation of answers
     * @param _minSubmissionValue is an immutable check for a lower bound of what
     * submission values are accepted from an oracle
     * @param _maxSubmissionValue is an immutable check for an upper bound of what
     * submission values are accepted from an oracle
     * @param _decimals represents the number of decimals to offset the answer by
     * @param _description a short description of what is being reported
     */
    #[init]
    pub fn new(
        owner_id: AccountId,
        link_id: AccountId,
        _payment_amount: U128,
        _timeout: U64,
        _validator: AccountId,
        _min_submission_value: U128,
        _max_submission_value: U128,
        _decimals: U64,
        _description: Base64String,
    ) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(
            env::is_valid_account_id(link_id.as_bytes()),
            "Link token account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");

        let payment_amount_u128: u128 = _payment_amount.into();
        let timeout_u64: u64 = _timeout.into();
        let min_submission_value_u128: u128 = _min_submission_value.into();
        let max_submission_value_u128: u128 = _max_submission_value.into();
        let decimals_u64: u64 = _decimals.into();
        let vector: Vec<AccountId> = Vec::new();

        let mut result = Self {
            owner: owner_id,
            pending_owner: "".to_string(),
            link_token: link_id,
            validator: "".to_string(),
            payment_amount: 0_u128,
            max_submission_count: 0_u64,
            min_submission_count: 0_u64,
            restart_delay: 0_u64,
            timeout: 0_u64,
            decimals: decimals_u64,
            description: _description,
            min_submission_value: min_submission_value_u128,
            max_submission_value: max_submission_value_u128,
            reporting_round_id: 0_u64,
            latest_round_id: 0_u64,
            oracles: LookupMap::new(b"oracles".to_vec()),
            rounds: LookupMap::new(b"rounds".to_vec()),
            details: LookupMap::new(b"details".to_vec()),
            requesters: LookupMap::new(b"requesters".to_vec()),
            oracle_addresses: vector,
            recorded_funds: Funds {
                available: 0_u128,
                allocated: 0_u128,
            },
        };
        let updated_at_insert: u64 = env::block_timestamp().saturating_sub(timeout_u64);
        let new_round: Round = Round {
            answer: 0_u128,
            started_at: 0_u64,
            updated_at: updated_at_insert,
            answered_in_round: 0_u64,
        };
        result.rounds.insert(&0, &new_round);
        result.update_future_rounds(
            U128::from(payment_amount_u128),
            U64::from(0),
            U64::from(0),
            U64::from(0),
            U64::from(timeout_u64),
        );
        result.set_validator(_validator);
        result
    }

    /**
     * @notice called by oracles when they have witnessed a need to update
     * @param _roundId is the ID of the round this submission pertains to
     * @param _submission is the updated data that the oracle is submitting
     */
    pub fn submit(&mut self, _round_id: U128, _submission: U128) {
        let round_id_u128: u128 = _round_id.into();
        let submission_u128: u128 = _submission.into();
        let error: Base64String =
            self.validate_oracle_round(env::predecessor_account_id(), round_id_u128 as u64);
        assert!(
            submission_u128 >= self.min_submission_value,
            "value below min_submission_value"
        );
        assert!(
            submission_u128 <= self.max_submission_value,
            "value above max_submission_value"
        );
        if error.len() != 0 {
            env::panic(format!("{}", error).as_bytes());
        }

        self.oracle_initialize_new_round(round_id_u128 as u64);
        self.record_submission(submission_u128, round_id_u128);
        let (updated, new_answer): (bool, u128) = self.update_round_answer(round_id_u128 as u64);
        self.pay_oracle(round_id_u128 as u64);
        self.delete_round_details(round_id_u128 as u64);
        if updated {
            self.validate_answer(round_id_u128 as u64, new_answer);
        }
    }

    /**
     * @notice called by the owner to remove and add new oracles as well as
     * update the round related parameters that pertain to total oracle count
     * @param _removed is the list of addresses for the new Oracles being removed
     * @param _added is the list of addresses for the new Oracles being added
     * @param _addedAdmins is the admin addresses for the new respective _added
     * list. Only this address is allowed to access the respective oracle's funds
     * @param _minSubmissions is the new minimum submission count for each round
     * @param _maxSubmissions is the new maximum submission count for each round
     * @param _restartDelay is the number of rounds an Oracle has to wait before
     * they can initiate a round
     */
    pub fn change_oracles(
        &mut self,
        _removed: Vec<AccountId>,
        _added: Vec<AccountId>,
        _added_admins: Vec<AccountId>,
        _min_submissions: U64,
        _max_submissions: U64,
        _restart_delay: U64,
    ) {
        self.only_owner();

        let min_submissions_u64: u64 = _min_submissions.into();
        let max_submissions_u64: u64 = _max_submissions.into();
        let restart_delay_u64: u64 = _restart_delay.into();

        for i in 0.._removed.len() {
            self.remove_oracle(_removed[i].clone());
        }

        assert!(
            _added.len() == _added_admins.len(),
            "need same oracle and admin count"
        );
        assert!(
            (self.oracle_count() as usize + _added.len()) as u128 <= MAX_ORACLE_COUNT,
            "max oracles allowed"
        );

        for i in 0.._added.len() {
            self.add_oracle(_added[i].clone(), _added_admins[i].clone());
        }

        self.update_future_rounds(
            U128::from(self.payment_amount),
            U64::from(min_submissions_u64),
            U64::from(max_submissions_u64),
            U64::from(restart_delay_u64),
            U64::from(self.timeout),
        );
    }

    /**
     * @notice update the round and payment related parameters for subsequent
     * rounds
     * @param _paymentAmount is the payment amount for subsequent rounds
     * @param _minSubmissions is the new minimum submission count for each round
     * @param _maxSubmissions is the new maximum submission count for each round
     * @param _restartDelay is the number of rounds an Oracle has to wait before
     * they can initiate a round
     */
    pub fn update_future_rounds(
        &mut self,
        _payment_amount: U128,
        _min_submissions: U64,
        _max_submissions: U64,
        _restart_delay: U64,
        _timeout: U64,
    ) {
        // Look into how to call this function in the initialization while having a an owner_id provided that is not the contract
        if env::predecessor_account_id() != env::current_account_id() {
            self.only_owner();
        }
        let payment_amount_u128: u128 = _payment_amount.into();
        let min_submissions_u64: u64 = _min_submissions.into();
        let max_submissions_u64: u64 = _max_submissions.into();
        let restart_delay_u64: u64 = _restart_delay.into();
        let timeout_u64: u64 = _timeout.into();

        let oracle_num: u128 = self.oracle_count(); // Save on storage reads
        assert!(
            max_submissions_u64 >= min_submissions_u64,
            "max must equal/exceed min"
        );
        assert!(
            oracle_num >= max_submissions_u64.into(),
            "max cannot exceed total"
        );
        assert!(
            oracle_num == 0 || oracle_num > restart_delay_u64.into(),
            "revert delay cannot exceed total"
        );
        // off for tests
        assert!(
            self.recorded_funds.available >= self.required_reserve(payment_amount_u128),
            "insufficient funds for payment"
        );
        if self.oracle_count() > 0 {
            assert!(min_submissions_u64 > 0, "min must be greater than 0")
        }

        self.payment_amount = payment_amount_u128;
        self.min_submission_count = min_submissions_u64;
        self.max_submission_count = max_submissions_u64;
        self.restart_delay = restart_delay_u64;
        self.timeout = timeout_u64;

        env::log(
            format!(
                "{}, {}, {}, {}, {}",
                payment_amount_u128,
                min_submissions_u64,
                max_submissions_u64,
                restart_delay_u64,
                timeout_u64
            )
            .as_bytes(),
        );
    }

    /**
     * @notice the amount of payment yet to be withdrawn by oracles
     */
    pub fn allocated_funds(&self) -> u128 {
        self.recorded_funds.allocated
    }

    /**
     * @notice the amount of future funding available to oracles
     */
    pub fn available_funds(&self) -> u128 {
        self.recorded_funds.available
    }

    pub fn min_submission_count(&self) -> u64 {
        self.min_submission_count
    }

    pub fn max_submission_count(&self) -> u64 {
        self.max_submission_count
    }

    pub fn restart_delay(&self) -> u64 {
        self.restart_delay
    }

    /**
     * @notice recalculate the amount of LINK available for payouts
     */

    pub fn update_available_funds(&self) {
        let prepaid_gas = env::prepaid_gas();
        let get_balance_promise = env::promise_create(
            self.link_token.clone(),
            b"ft_balance_of",
            json!({ "account_id": "flux_aggregator" })
                .to_string()
                .as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );

        env::promise_then(
            get_balance_promise,
            env::current_account_id(),
            b"get_balance_promise_results",
            json!({}).to_string().as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );
    }

    pub fn get_balance_promise_results(&mut self) {
        let funds: &Funds = &self.recorded_funds;
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let get_balance_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("Promise with index 0 failed"),
        };
        let link_balance: U128 = serde_json::from_slice(&get_balance_promise_result).unwrap();
        let now_available: u128 = u128::from(link_balance) - funds.allocated;
        if funds.available != now_available {
            self.recorded_funds.available = now_available;
            env::log(format!("{}", now_available).as_bytes());
        }
    }

    /**
     * @notice returns the number of oracles
     */
    pub fn oracle_count(&self) -> u128 {
        self.oracle_addresses.len() as u128
    }

    /**
     * @notice returns an array of addresses containing the oracles on contract
     */
    pub fn get_oracles(&self) -> Vec<AccountId> {
        self.oracle_addresses.clone()
    }

    pub fn get_payment_amount(&self) -> u128 {
        self.payment_amount
    }

    pub fn get_timeout(&self) -> u64 {
        self.timeout
    }

    pub fn get_validator(&self) -> AccountId {
        self.validator.clone()
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }

    /**
     * @notice get the most recently reported answer
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_answer(&self) -> u128 {
        let round_option = self.rounds.get(&self.latest_round_id);
        if round_option.is_none() {
            return 0;
        }
        let round = round_option.unwrap();
        if round.answer == 0 {
            return 0;
        }
        round.answer
    }

    /**
     * @notice get the most recent updated at timestamp
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_timestamp(&self) -> u64 {
        let round_option = self.rounds.get(&self.latest_round_id);
        if round_option.is_none() {
            // env::panic(b"Did not find this oracle account. {latest_timestamp}");
            return 0;
        }
        let round = round_option.unwrap();
        round.updated_at
    }

    /**
     * @notice get the ID of the last updated round
     *
     * @dev #[deprecated] Use latestRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended latestRoundData
     * instead which includes better verification information.
     */
    pub fn latest_round(&self) -> u64 {
        self.latest_round_id
    }

    /**
     * @notice get past rounds answers
     * @param _roundId the round number to retrieve the answer for
     *
     * @dev #[deprecated] Use getRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended getRoundData
     * instead which includes better verification information.
     */
    pub fn get_answer(&self, _round_id: U128) -> u128 {
        let round_id_u128: u128 = _round_id.into();

        let round_option = self.rounds.get(&(round_id_u128 as u64));
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();

        if self.valid_round_id(round_id_u128) {
            return round.answer;
        }
        return 0;
    }

    /**
     * @notice get timestamp when an answer was last updated
     * @param _roundId the round number to retrieve the updated timestamp for
     *
     * @dev #[deprecated] Use getRoundData instead. This does not error if no
     * answer has been reached, it will simply return 0. Either wait to point to
     * an already answered Aggregator or use the recommended getRoundData
     * instead which includes better verification information.
     */
    pub fn get_timestamp(&self, _round_id: U128) -> u64 {
        let round_id_u128: u128 = _round_id.into();

        let round_option = self.rounds.get(&(round_id_u128 as u64));
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();

        if self.valid_round_id(round_id_u128) {
            return round.updated_at;
        }
        return 0;
    }

    /**
     * @notice get data about a round. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values.
     * @param _roundId the round ID to retrieve the round data for
     * @return roundId is the round ID for which data was retrieved
     * @return answer is the answer for the given round
     * @return startedAt is the timestamp when the round was started. This is 0
     * if the round hasn't been started yet.
     * @return updatedAt is the timestamp when the round last was updated (i.e.
     * answer was last computed)
     * @return answeredInRound is the round ID of the round in which the answer
     * was computed. answeredInRound may be smaller than roundId when the round
     * timed out. answeredInRound is equal to roundId when the round didn't time out
     * and was completed regularly.
     * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received
     * maxSubmissions) answer and updatedAt may change between queries.
     */
    pub fn get_round_data(&self, _round_id: U64) -> (u64, u128, u64, u64, u64) {
        let round_id_u64: u64 = _round_id.into();

        let round_option = self.rounds.get(&round_id_u64);
        if round_option.is_none() {
            env::panic(b"No data present");
        }
        let round = round_option.unwrap();

        let r: Round = round;
        assert!(
            r.answered_in_round > 0 && self.valid_round_id(round_id_u64.into()),
            V3_NO_DATA_ERROR
        );

        return (
            round_id_u64,
            r.answer,
            r.started_at,
            r.updated_at,
            r.answered_in_round,
        );
    }

    /**
     * @notice get data about the latest round. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values. Consumers are encouraged to
     * use this more fully featured method over the "legacy" latestRound/
     * latestAnswer/latestTimestamp functions. Consumers are encouraged to check
     * that they're receiving fresh data by inspecting the updatedAt and
     * answeredInRound return values.
     * @return roundId is the round ID for which data was retrieved
     * @return answer is the answer for the given round
     * @return startedAt is the timestamp when the round was started. This is 0
     * if the round hasn't been started yet.
     * @return updatedAt is the timestamp when the round last was updated (i.e.
     * answer was last computed)
     * @return answeredInRound is the round ID of the round in which the answer
     * was computed. answeredInRound may be smaller than roundId when the round
     * timed out. answeredInRound is equal to roundId when the round didn't time
     * out and was completed regularly.
     * @dev Note that for in-progress rounds (i.e. rounds that haven't yet
     * received maxSubmissions) answer and updatedAt may change between queries.
     */
    pub fn latest_round_data(&self) -> (u64, u128, u64, u64, u64) {
        self.get_round_data(U64::from(self.latest_round_id))
    }

    /**
     * @notice query the available amount of LINK for an oracle to withdraw
     */
    pub fn withdrawable_payment(&self, _oracle: AccountId) -> u128 {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();
        oracle.withdrawable
    }

    /**
     * @notice transfers the oracle's LINK to another address. Can only be called
     * by the oracle's admin.
     * @param _oracle is the oracle whose LINK is transferred
     * @param _recipient is the address to send the LINK to
     * @param _amount is the amount of LINK to send
     */
    #[payable]
    pub fn withdraw_payment(&mut self, _oracle: AccountId, _recipient: AccountId, _amount: U128) {
        let prepaid_gas = env::prepaid_gas();

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.admin == env::predecessor_account_id(),
            "only callable by admin"
        );

        let amount_u128: u128 = _amount.into();
        let available: u128 = oracle.withdrawable;
        assert!(
            available >= amount_u128,
            "revert insufficient withdrawable funds"
        );

        oracle.withdrawable = available - amount_u128;
        self.oracles.insert(&_oracle, &oracle);
        self.recorded_funds.allocated = self.recorded_funds.allocated - amount_u128;

        let ft_transfer = env::promise_create(
            self.link_token.clone(),
            b"ft_transfer",
            json!({"receiver_id": _recipient.clone(), "amount": _amount, "memo": "None"})
                .to_string()
                .as_bytes(),
            1,
            (prepaid_gas / 6).into(),
        );
        env::promise_then(
            ft_transfer,
            "flux_aggregator".to_string(),
            b"update_available_funds_promise_resolution",
            json!({}).to_string().as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );
    }

    /**
     * @notice transfers the owner's LINK to another address
     * @param _recipient is the address to send the LINK to
     * @param _amount is the amount of LINK to send
     */
    #[payable]
    pub fn withdraw_funds(&mut self, _recipient: AccountId, _amount: U128) {
        self.only_owner();
        let prepaid_gas = env::prepaid_gas();
        let available: u128 = self.recorded_funds.available as u128;
        let amount_u128: u128 = _amount.into();
        assert!(
            (available - self.required_reserve(self.payment_amount)) >= amount_u128,
            "insufficient reserve funds"
        );
        let ft_transfer = env::promise_create(
            self.link_token.clone(),
            b"ft_transfer",
            json!({"receiver_id": _recipient.clone(), "amount": _amount, "memo": "None"})
                .to_string()
                .as_bytes(),
            1,
            (prepaid_gas / 6).into(),
        );
        let ft_transfer_resolve = env::promise_then(
            ft_transfer,
            "flux_aggregator".to_string(),
            b"update_available_funds_promise_resolution",
            json!({}).to_string().as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );
        env::promise_return(ft_transfer_resolve);
    }

    /**
     * @notice recalculate the amount of LINK available for payouts
     */

    pub fn update_available_funds_promise_resolution(&self) {
        let prepaid_gas = env::prepaid_gas();
        let get_balance_promise = env::promise_create(
            self.link_token.clone(),
            b"ft_balance_of",
            json!({ "account_id": "flux_aggregator" })
                .to_string()
                .as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );
        let get_balance_promise_resolve = env::promise_then(
            get_balance_promise,
            "flux_aggregator".to_string(),
            b"get_balance_promise_results",
            json!({}).to_string().as_bytes(),
            0,
            (prepaid_gas / 6).into(),
        );
        env::promise_return(get_balance_promise_resolve);
    }

    /**
     * @notice get the admin address of an oracle
     * @param _oracle is the address of the oracle whose admin is being queried
     */
    pub fn get_admin(&self, _oracle: AccountId) -> AccountId {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let oracle = oracle_option.unwrap();
        oracle.admin
    }

    /**
     * @notice transfer the admin address for an oracle
     * @param _oracle is the address of the oracle whose admin is being transferred
     * @param _newAdmin is the new admin address
     */
    pub fn transfer_admin(&mut self, _oracle: AccountId, _new_admin: AccountId) {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.admin == env::predecessor_account_id(),
            "revert only callable by admin"
        );
        oracle.pending_admin = _new_admin;
        self.oracles.insert(&_oracle, &oracle);
        env::log(
            format!(
                "{}, {}, {}",
                _oracle,
                env::predecessor_account_id(),
                oracle.pending_admin
            )
            .as_bytes(),
        );
    }

    /**
     * @notice accept the admin address transfer for an oracle
     * @param _oracle is the address of the oracle whose admin is being transferred
     */
    pub fn accept_admin(&mut self, _oracle: AccountId) {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();
        assert!(
            oracle.pending_admin == env::predecessor_account_id(),
            "only callable by pending admin"
        );
        oracle.pending_admin = "".to_string();
        oracle.admin = env::predecessor_account_id();
        self.oracles.insert(&_oracle, &oracle);
        env::log(format!("{}, {}", _oracle, env::predecessor_account_id()).as_bytes());
    }

    /**
     * @notice allows non-oracles to request a new round
     */
    pub fn request_new_round(&mut self) -> u64 {
        let requester_option = self.requesters.get(&env::predecessor_account_id());
        if requester_option.is_none() {
            env::panic(b"not authorized requester");
        }
        let requester = requester_option.unwrap();
        assert!(requester.authorized, "not authorized requester");

        let current: u64 = self.reporting_round_id;
        let round_option = self.rounds.get(&current);
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let round = round_option.unwrap();
        assert!(
            round.updated_at > 0 || self.timed_out(current),
            "prev round must be supersedable"
        );

        let new_round_id: u64 = current + 1;
        self.requester_initialize_new_round(new_round_id);
        return new_round_id;
    }

    /**
     * @notice allows the owner to specify new non-oracles to start new rounds
     * @param _requester is the address to set permissions for
     * @param _authorized is a boolean specifying whether they can start new rounds or not
     * @param _delay is the number of rounds the requester must wait before starting another round
     */
    pub fn set_requester_permissions(
        &mut self,
        _requester: AccountId,
        _authorized: bool,
        _delay: U64,
    ) {
        self.only_owner();
        let delay_u64: u64 = _delay.into();

        let requester_option = self.requesters.get(&_requester);

        let mut requester: Requester;
        if requester_option.is_none() {
            requester = Requester {
                authorized: _authorized,
                delay: u64::from(_delay),
                last_started_round: 0,
            };
        } else {
            requester = requester_option.unwrap();
            if requester.authorized == _authorized {
                return;
            }
        }

        if _authorized {
            requester.authorized = _authorized;
            requester.delay = delay_u64;
            self.requesters.insert(&_requester, &requester);
        } else {
            self.requesters.remove(&_requester);
        }

        env::log(format!("{}, {}, {}", _requester, _authorized, u64::from(_delay)).as_bytes());
    }

    /**
     * @notice called through LINK's transferAndCall to update available funds
     * in the same transaction as the funds were transferred to the aggregator
     * @param _data is mostly ignored. It is checked for length, to be sure
     * nothing strange is passed in.
     */
    pub fn on_token_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) {
        assert!(msg.len() == 0, "transfer doesn't accept calldata");
        self.update_available_funds();
    }

    /**
     * @notice called through LINK's transferAndCall to update available funds
     * in the same transaction as the funds were transferred to the aggregator
     * @param msg is mostly ignored. It is checked for length, to be sure
     * nothing strange is passed in.
     */
    pub fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) {
        env::log(format!("{}", "HERE!").as_bytes());
        assert!(msg.len() == 0, "transfer doesn't accept calldata");
        self.update_available_funds();
    }

    /**
     * @notice a method to provide all current info oracles need. Intended only
     * only to be callable by oracles. Not for use by contracts to read state.
     * @param _oracle the address to look up information for.
     */
    pub fn oracle_round_state(
        &mut self,
        _oracle: AccountId,
        _queried_round_id: U64,
    ) -> (bool, u64, u128, u64, u64, u128, u64, u128) {
        assert!(
            env::predecessor_account_id() == env::signer_account_id(),
            "off-chain reading only"
        );

        let queried_round_id_u64: u64 = _queried_round_id.into();
        if queried_round_id_u64 > 0 {
            let round_option = self.rounds.get(&queried_round_id_u64);
            let mut round: Round;
            if round_option.is_none() {
                round = Round {
                    answer: 0,
                    started_at: 0,
                    updated_at: 0,
                    answered_in_round: 0,
                }
            } else {
                round = round_option.unwrap();
            }
            let detail_option = self.details.get(&u128::from(queried_round_id_u64));
            let mut detail: RoundDetails;
            if detail_option.is_none() {
                detail = RoundDetails {
                    submissions: Vec::new(),
                    max_submissions: 0,
                    min_submissions: 0,
                    timeout: 0,
                    payment_amount: 0,
                }
            } else {
                detail = detail_option.unwrap();
            }
            let oracle_option = self.oracles.get(&_oracle);
            if oracle_option.is_none() {
                env::panic(b"Did not find this round oracle.");
            }
            let oracle = oracle_option.unwrap();
            return (
                self.eligible_for_specific_round(_oracle, queried_round_id_u64),
                queried_round_id_u64,
                oracle.latest_submission,
                round.started_at,
                detail.timeout,
                self.recorded_funds.available,
                self.oracle_count() as u64,
                if round.started_at > 0 {
                    detail.payment_amount
                } else {
                    self.payment_amount
                },
            );
        } else {
            return self.oracle_round_state_suggest_round(_oracle);
        }
    }

    /**
     * @notice method to update the address which does external data validation.
     * @param _newValidator designates the address of the new validation contract.
     */
    pub fn set_validator(&mut self, _new_validator: AccountId) {
        // Look into how to call this function in the initialization while having a an owner_id provided that is not the contract
        if env::predecessor_account_id() != env::current_account_id() {
            self.only_owner();
        }
        let previous: AccountId = String::from(&self.validator) as AccountId;
        let init_new: AccountId = _new_validator.clone();
        if previous != _new_validator {
            self.validator = _new_validator;
            env::log(format!("{}, {}", previous, init_new).as_bytes());
        }
    }

    /**
     * Private
     */

    fn initialize_new_round(&mut self, _round_id: u64) {
        self.update_timed_out_round_info(_round_id - 1);

        self.reporting_round_id = _round_id;
        let vector: Vec<u128> = Vec::new();
        let next_details: RoundDetails = RoundDetails {
            submissions: vector,
            max_submissions: self.max_submission_count,
            min_submissions: self.min_submission_count,
            timeout: self.timeout,
            payment_amount: self.payment_amount,
        };
        let new_round: Round = Round {
            answer: 0_u128,
            started_at: env::block_timestamp() as u64,
            updated_at: 0_u64,
            answered_in_round: 0_u64,
        };
        self.details.insert(&u128::from(_round_id), &next_details);
        self.rounds.insert(&_round_id, &new_round);

        env::log(
            format!(
                "{}, {}, {}",
                _round_id,
                env::predecessor_account_id(),
                new_round.started_at
            )
            .as_bytes(),
        );
    }

    fn oracle_initialize_new_round(&mut self, _round_id: u64) {
        if !self.new_round(_round_id) {
            return;
        }

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(
                format!(
                    "{} Did not find this oracle.",
                    &env::predecessor_account_id()
                )
                .as_bytes(),
            );
        }
        let mut oracle = oracle_option.unwrap();

        let last_started: u64 = oracle.last_started_round; // cache storage reads
        if _round_id <= last_started + self.restart_delay && last_started != 0 {
            return;
        }
        self.initialize_new_round(_round_id);
        oracle.last_started_round = _round_id;
        self.oracles.insert(&env::predecessor_account_id(), &oracle);
    }

    fn requester_initialize_new_round(&mut self, _round_id: u64) {
        if !self.new_round(_round_id) {
            return;
        }
        let requester_option = self.requesters.get(&env::predecessor_account_id());
        if requester_option.is_none() {
            env::panic(b"Did not find this requester.");
        }
        let mut requester = requester_option.unwrap();

        let last_started: u128 = requester.last_started_round.into(); // cache storage reads
        assert!(
            (_round_id as u128) > last_started + (requester.delay as u128) || last_started == 0,
            "must delay requests"
        );

        self.initialize_new_round(_round_id);

        requester.last_started_round = _round_id;
        self.requesters
            .insert(&env::predecessor_account_id(), &requester);
    }

    fn update_timed_out_round_info(&mut self, _round_id: u64) {
        if !self.timed_out(_round_id) {
            return;
        }
        let prev_id: u64 = _round_id - 1;

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            env::panic(format!("{} Did not find this round.", _round_id.to_string()).as_bytes());
        }
        let mut round = round_option.unwrap();

        let prev_option = self.rounds.get(&prev_id);
        if prev_option.is_none() {
            env::panic(
                format!("{} Did not find this previous round.", prev_id.to_string()).as_bytes(),
            );
            // return;
        }
        let prev = prev_option.unwrap();

        round.answer = prev.answer;
        round.answered_in_round = prev.answered_in_round;
        round.updated_at = env::block_timestamp() as u64;
        self.rounds.insert(&_round_id, &round);

        self.details.remove(&(_round_id as u128));
    }

    fn eligible_for_specific_round(&mut self, _oracle: AccountId, _queried_round_id: u64) -> bool {
        let init_oracle = &_oracle;
        let round_option = self.rounds.get(&_queried_round_id);
        let mut round: Round;
        if round_option.is_none() {
            round = Round {
                answer: 0,
                started_at: 0,
                updated_at: 0,
                answered_in_round: 0,
            };
        } else {
            round = round_option.unwrap();
        }
        if round.started_at > 0 {
            return self.accepting_submissions(_queried_round_id.into())
                && self
                    .validate_oracle_round(init_oracle.to_string(), _queried_round_id)
                    .len()
                    == 0;
        } else {
            return self.delayed(_oracle.to_string(), _queried_round_id)
                && self
                    .validate_oracle_round(init_oracle.to_string(), _queried_round_id)
                    .len()
                    == 0;
        }
    }

    fn oracle_round_state_suggest_round(
        &mut self,
        _oracle: AccountId,
    ) -> (bool, u64, u128, u64, u64, u128, u64, u128) {
        let round_option = self.rounds.get(&1);
        let init_oracle = &_oracle;
        let mut round: Round;

        if round_option.is_none() {
            round = Round {
                answer: 0,
                started_at: 0,
                updated_at: 0,
                answered_in_round: 0,
            };
        } else {
            round = round_option.unwrap();
        }

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();

        let should_supersede: bool = oracle.last_reported_round == self.reporting_round_id
            || !self.accepting_submissions(self.reporting_round_id as u128);

        // Instead of nudging oracles to submit to the next round, the inclusion of
        // the should_supersede bool in the if condition pushes them towards
        // submitting in a currently open round.

        let mut _round_id: u64;
        let mut _payment_amount: u128;
        let mut _eligible_to_submit: bool;
        let _reporting_round_id: u64 = self.reporting_round_id;

        let detail_option = self.details.get(&(_reporting_round_id as u128));
        let mut detail: RoundDetails;

        if detail_option.is_none() {
            detail = RoundDetails {
                submissions: Vec::new(),
                max_submissions: 0,
                min_submissions: 0,
                timeout: 0,
                payment_amount: 0,
            }
        } else {
            detail = detail_option.unwrap();
        }
        if self.supersedable(self.reporting_round_id) && should_supersede {
            _round_id = self.reporting_round_id + 1;

            let round_from_id_option = self.rounds.get(&_round_id);
            if round_from_id_option.is_none() {
                // Do nothing, keep the round the same
            } else {
                round = round_from_id_option.unwrap();
            }
            _payment_amount = self.payment_amount;
            _eligible_to_submit = self.delayed(_oracle.to_string(), _round_id);
        } else {
            _round_id = self.reporting_round_id;

            let round_from_id_option = self.rounds.get(&_reporting_round_id);
            if round_from_id_option.is_none() {
                // Do nothing, keep the round the same
            } else {
                round = round_from_id_option.unwrap();
            }

            _payment_amount = detail.payment_amount;
            _eligible_to_submit = self.accepting_submissions(_round_id.into());
        }

        if self
            .validate_oracle_round(init_oracle.to_string(), _round_id)
            .len()
            != 0
        {
            _eligible_to_submit = false;
        }

        return (
            _eligible_to_submit,
            _round_id,
            oracle.latest_submission,
            round.started_at,
            detail.timeout,
            self.recorded_funds.available,
            self.oracle_count() as u64,
            _payment_amount,
        );
    }

    fn update_round_answer(&mut self, _round_id: u64) -> (bool, u128) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();
        let submissions_length = detail.submissions.len() as u64;

        if submissions_length < detail.min_submissions {
            return (false, 0 as u128);
        }

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            env::panic(b"Did not find this round.");
        }
        let mut round = round_option.unwrap();

        let new_answer: u128 = self.median(detail.submissions).into();
        env::log(format!("{}", new_answer).as_bytes());

        round.answer = new_answer;
        round.updated_at = env::block_timestamp() as u64;
        round.answered_in_round = _round_id;
        self.rounds.insert(&_round_id, &round);
        self.latest_round_id = _round_id;

        return (true, new_answer);
    }

    fn validate_answer(&self, _round_id: u64, _new_answer: u128) {
        let av: AccountId = self.validator.clone(); // cache storage reads
        if av == "" {
            return;
        }
        let _round_id_u128: u128 = _round_id as u128;
        let prepaid_gas = env::prepaid_gas();
        let prev_round: u64 = _round_id - 1;
        if prev_round == 0 {
            // TRY CATCH

            env::promise_create(
                self.validator.clone(),
                b"validate",
                json!({ "previous_round_id": U128::from(0),
                    "previous_answer": U128::from(0),
                    "current_round_id": U128::from(_round_id_u128),
                    "current_answer": U128::from(_new_answer)})
                .to_string()
                .as_bytes(),
                0,
                (prepaid_gas / 2).into(),
            );
        } else {
            let round_option = self.rounds.get(&prev_round);
            if round_option.is_none() {
                env::panic(b"Did not find this round.");
            }
            let round = round_option.unwrap();

            let prev_answer_round_id: u64 = round.answered_in_round;
            let prev_answer_round_id_u128: u128 = prev_answer_round_id as u128;
            let prev_round_answer: u128 = round.answer;

            // TRY CATCH
            env::promise_create(
                self.validator.clone(),
                b"validate",
                json!({ "previous_round_id": U128::from(prev_answer_round_id_u128),
                "previous_answer": U128::from(prev_round_answer),
                "current_round_id": U128::from(_round_id_u128),
                "current_answer": U128::from(_new_answer)})
                .to_string()
                .as_bytes(),
                0,
                (prepaid_gas / 2).into(),
            );
        }
    }

    fn pay_oracle(&mut self, _round_id: u64) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        let payment: u128 = detail.payment_amount;
        let mut funds: Funds = self.recorded_funds.clone();

        env::log(format!("{}", funds.available.saturating_sub(payment)).as_bytes());
        env::log(format!("{}", funds.allocated.saturating_add(payment)).as_bytes());

        funds.available = funds.available.saturating_sub(payment);
        funds.allocated = funds.allocated.saturating_add(payment);
        self.recorded_funds = funds;
        self.oracles.remove(&env::predecessor_account_id());
        oracle.withdrawable = oracle.withdrawable.saturating_add(payment);
        self.oracles.insert(&env::predecessor_account_id(), &oracle);
    }

    fn record_submission(&mut self, _submission: u128, _round_id: u128) {
        assert!(
            self.accepting_submissions(_round_id),
            "round not accepting submissions"
        );

        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let mut detail = detail_option.unwrap();

        let oracle_option = self.oracles.get(&env::predecessor_account_id());
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        detail.submissions.push(_submission);
        self.details.insert(&(_round_id as u128), &detail);

        oracle.last_reported_round = _round_id as u64;
        oracle.latest_submission = _submission;

        self.oracles.insert(&env::predecessor_account_id(), &oracle);
        env::log(
            format!(
                "{}, {}, {}",
                _submission,
                _round_id,
                env::predecessor_account_id()
            )
            .as_bytes(),
        );
    }

    fn delete_round_details(&mut self, _round_id: u64) {
        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            env::panic(b"Did not find details for this Round ID.");
        }
        let detail = detail_option.unwrap();

        if (detail.submissions.len() as u64) < detail.max_submissions {
            return;
        } else {
            self.details.remove(&(_round_id as u128));
        }
    }

    fn timed_out(&mut self, _round_id: u64) -> bool {
        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();

        let detail_option = self.details.get(&(_round_id as u128));
        if detail_option.is_none() {
            return false;
        }
        let detail = detail_option.unwrap();

        let started_at: u64 = round.started_at;
        let round_timeout: u64 = detail.timeout;

        // commented out for test failure
        return started_at > 0
            && round_timeout > 0
            && started_at.saturating_add(round_timeout) < env::block_timestamp();
        // return false;
    }

    fn get_starting_round(&self, _oracle: AccountId) -> u64 {
        let current_round: u64 = self.reporting_round_id;
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return current_round + 1;
        }
        let oracle = oracle_option.unwrap();

        if current_round != 0 && current_round == oracle.ending_round as u64 {
            return current_round;
        }
        return current_round + 1;
    }

    fn previous_and_current_unanswered(&self, _round_id: u64, _rr_id: u64) -> bool {
        let round_option = self.rounds.get(&_rr_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        return (_round_id + 1) == _rr_id && round.updated_at == 0;
    }

    fn required_reserve(&self, payment: u128) -> u128 {
        return payment * (self.oracle_count() * RESERVE_ROUNDS);
    }

    fn add_oracle(&mut self, _oracle: AccountId, _admin: AccountId) {
        let init_oracle = &_oracle;
        let init_admin = &_admin;
        assert!(
            !self.oracle_enabled(init_oracle.to_string()),
            "oracle already enabled"
        );
        assert!(_admin != "", "cannot set admin to 0");
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            // assert not required since there is_none
            let oracle: OracleStatus = OracleStatus {
                withdrawable: 0_u128,
                starting_round: self.get_starting_round(_oracle.clone()),
                ending_round: ROUND_MAX,
                last_reported_round: 0_u64,
                last_started_round: 0_u64,
                latest_submission: 0_u128,
                index: self.oracle_addresses.len() as u64,
                admin: _admin.clone(),
                pending_admin: "".to_string(),
            };
            self.oracles.insert(&_oracle, &oracle);
            self.oracle_addresses.push(_oracle.clone());
        } else {
            let oracle_unwrapped: OracleStatus = oracle_option.unwrap();
            assert!(
                &oracle_unwrapped.admin == "" || &oracle_unwrapped.admin == init_admin,
                "owner cannot overwrite admin"
            );
            // oracle_option.ending_round = self.get_starting_round(_oracle.clone());
            // self.oracles.insert(&init_oracle, &oracle_option);
        }
        // Oracle Permissions Updated
        env::log(format!("{}, {}", &init_oracle.clone(), true).as_bytes());
        // Oracle Admin Updated
        env::log(format!("{}, {}", &init_admin.clone(), true).as_bytes());
    }

    fn remove_oracle(&mut self, _oracle: AccountId) {
        let init_oracle = &_oracle;
        assert!(
            self.oracle_enabled(init_oracle.to_string()),
            "oracle not enabled"
        );

        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle = oracle_option.unwrap();

        let last_oracle: usize = (self.oracle_count() - 1) as usize;
        let tail: AccountId = self.oracle_addresses[last_oracle].clone();
        let init_tail = &tail;

        let oracle_tail_option = self.oracles.get(&tail);
        if oracle_tail_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let mut oracle_tail = oracle_tail_option.unwrap();

        oracle.ending_round = (self.reporting_round_id.saturating_add(1)).into();
        let index: usize = oracle.index.try_into().unwrap();
        oracle_tail.index = index.try_into().unwrap();
        oracle.index = 0_u64;
        self.oracle_addresses[index] = init_tail.to_string();
        self.oracle_addresses.pop();

        self.oracles.insert(&_oracle, &oracle);
        self.oracles.insert(&tail, &oracle_tail);
        // Oracle Permissions Updated
        env::log(format!("{}, {}", &init_oracle.clone(), false).as_bytes());
    }

    fn validate_oracle_round(&mut self, _oracle: AccountId, _round_id: u64) -> Base64String {
        // cache storage reads
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return "not enabled oracle".to_string();
        }
        let oracle = oracle_option.unwrap();
        let starting_round: u64 = oracle.starting_round;
        let rr_id: u64 = self.reporting_round_id;
        if starting_round == 0 {
            return "not enabled oracle".to_string();
        } else if starting_round > _round_id {
            return "not yet enabled oracle".to_string();
        } else if oracle.ending_round < _round_id.into() {
            return "no longer allowed oracle".to_string();
        } else if oracle.last_reported_round >= _round_id {
            return "cannot report on previous rounds".to_string();
        } else if _round_id != rr_id
            && _round_id != rr_id + 1
            && !self.previous_and_current_unanswered(_round_id, rr_id)
        {
            return "invalid round to report".to_string();
        } else if _round_id != 1 && !self.supersedable(_round_id - 1) {
            return "previous round not supersedable".to_string();
        } else {
            return "".to_string();
        }
    }

    fn supersedable(&mut self, _round_id: u64) -> bool {
        if self.timed_out(_round_id) {
            return self.timed_out(_round_id);
        }

        let round_option = self.rounds.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        round.updated_at > 0
    }

    fn oracle_enabled(&self, _oracle: AccountId) -> bool {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            return false;
        }
        let oracle = oracle_option.unwrap();
        oracle.ending_round == ROUND_MAX
    }

    fn accepting_submissions(&self, _round_id: u128) -> bool {
        let round_option = self.details.get(&_round_id);
        if round_option.is_none() {
            return false;
        }
        let round = round_option.unwrap();
        round.max_submissions != 0
    }

    fn delayed(&self, _oracle: AccountId, _round_id: u64) -> bool {
        let oracle_option = self.oracles.get(&_oracle);
        if oracle_option.is_none() {
            env::panic(b"Did not find this oracle account.");
        }
        let oracle = oracle_option.unwrap();
        let last_started: u64 = oracle.last_started_round;
        _round_id > (last_started + self.restart_delay) || last_started == 0
    }

    fn new_round(&self, _round_id: u64) -> bool {
        _round_id == self.reporting_round_id + 1
    }

    fn valid_round_id(&self, _round_id: u128) -> bool {
        _round_id <= ROUND_MAX
    }

    fn only_owner(&self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only callable by owner"
        );
    }

    fn median(&mut self, mut numbers: Vec<u128>) -> u128 {
        numbers.sort();
        let _mid = numbers.len() / 2;
        let sum: u128 = numbers.iter().sum();
        let len: u128 = numbers.len().try_into().unwrap();
        sum / len
    }

    pub fn get_decimals(&self) -> u64 {
        self.decimals
    }
    pub fn get_description(&self) -> String {
        self.description.clone()
    }
    pub fn get_version(&self) -> u128 {
        VERSION
    }

    pub fn accept_ownership(&mut self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.pending_owner,
            "Must be proposed owner"
        );
        let old_owner: AccountId = self.owner.clone();
        self.owner = env::predecessor_account_id();
        self.pending_owner = "".to_string();
        env::log(format!("{}, {}", old_owner, env::predecessor_account_id()).as_bytes());
    }

    pub fn transfer_ownership(&mut self, _to: AccountId) {
        self.only_owner();
        let init_to: AccountId = _to.clone();
        self.pending_owner = _to;
        env::log(format!("{}, {}", self.owner, init_to).as_bytes());
    }
}

'''
'''--- contract-wrap/flux_aggregator_test_helper/Cargo.toml ---
[package]
name = "flux_aggregator_test_helper"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/flux_aggregator_test_helper/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde_json::{self, json};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::{PromiseResult};
use near_sdk::json_types::{U128, U64};
#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

const SINGLE_CALL_GAS: u64 = 50_000_000_000_000; // 5 x 10^13

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FluxAggregatorTestHelper {
    pub requested_round_id: u64,
}

impl Default for FluxAggregatorTestHelper {
    fn default() -> Self {
        panic!("FluxAggregatorTestHelper should be initialized before usage")
    }
}

#[near_bindgen]
impl FluxAggregatorTestHelper {
    #[init]
    pub fn new() -> Self {
        let result = Self {
            requested_round_id: 0_u64,
        };
        result
    }

    pub fn requested_round_id(&self) -> u64{
        self.requested_round_id
    }

    pub fn read_oracle_round_state(&self, _aggregator: AccountId, _oracle: AccountId) {
        let read_oracle_round_state_promise = env::promise_create(
            _aggregator.to_string(),
            b"oracle_round_state",
            json!({ "_oracle": _oracle.to_string(), "_queried_round_id": U128::from(0)}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_oracle_round_state_promise_result = env::promise_then(
            read_oracle_round_state_promise,
            env::current_account_id(),
            b"read_oracle_round_state_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_oracle_round_state_promise_result);
    }

    pub fn read_oracle_round_state_results(&self) -> (bool, u64, u128, u64, u64, u128, u64, u128) {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_oracle_round_state_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: (bool, u64, u128, u64, u64, u128, u64, u128) = serde_json::from_slice(&read_oracle_round_state_promise_result).unwrap();
        results
    }

    pub fn read_get_round_data(&self, _aggregator: AccountId, _round_id: U64) {
        let read_get_round_data_promise = env::promise_create(
            _aggregator.to_string(),
            b"get_round_data",
            json!({ "_round_id": _round_id}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_get_round_data_promise_result = env::promise_then(
            read_get_round_data_promise,
            env::current_account_id(),
            b"read_get_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_get_round_data_promise_result);
    }

    pub fn read_get_round_data_results(&self) -> (u64, u128, u64, u64, u64) {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_get_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: (u64, u128, u64, u64, u64) = serde_json::from_slice(&read_get_round_data_promise_result).unwrap();
        results
    }

    pub fn read_latest_round_data(&self, _aggregator: AccountId) {
        let read_latest_round_data_promise = env::promise_create(
            _aggregator.to_string(),
            b"latest_round_data",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_latest_round_data_promise_result = env::promise_then(
            read_latest_round_data_promise,
            env::current_account_id(),
            b"read_latest_round_data_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_latest_round_data_promise_result);
    }

    pub fn read_latest_round_data_results(&self) -> (u64, u128, u64, u64, u64) {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_latest_round_data_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: (u64, u128, u64, u64, u64) = serde_json::from_slice(&read_latest_round_data_promise_result).unwrap();
        results
    }

    pub fn read_latest_answer(&self, _aggregator: AccountId) {
        let read_latest_answer_promise = env::promise_create(
            _aggregator.to_string(),
            b"latest_answer",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_latest_answer_promise_result = env::promise_then(
            read_latest_answer_promise,
            env::current_account_id(),
            b"read_latest_answer_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_latest_answer_promise_result);
    }

    pub fn read_latest_answer_results(&self) -> u128 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_latest_answer_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u128 = serde_json::from_slice(&read_latest_answer_promise_result).unwrap();
        results
    }

    pub fn read_latest_timestamp(&self, _aggregator: AccountId) {
        let read_latest_timestamp_promise = env::promise_create(
            _aggregator.to_string(),
            b"latest_timestamp",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_latest_timestamp_promise_result = env::promise_then(
            read_latest_timestamp_promise,
            env::current_account_id(),
            b"read_latest_timestamp_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_latest_timestamp_promise_result);
    }

    pub fn read_latest_timestamp_results(&self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_latest_timestamp_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u64 = serde_json::from_slice(&read_latest_timestamp_promise_result).unwrap();
        results
    }

    pub fn read_latest_round(&self, _aggregator: AccountId) {
        let read_latest_round_promise = env::promise_create(
            _aggregator.to_string(),
            b"latest_round",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_latest_round_promise_result = env::promise_then(
            read_latest_round_promise,
            env::current_account_id(),
            b"read_latest_round_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_latest_round_promise_result);
    }

    pub fn read_latest_round_results(&self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_latest_round_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u64 = serde_json::from_slice(&read_latest_round_promise_result).unwrap();
        results
    }

    pub fn request_new_round(&self, _aggregator: AccountId) {
        let request_new_round_promise = env::promise_create(
            _aggregator.to_string(),
            b"request_new_round",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let request_new_round_promise_result = env::promise_then(
            request_new_round_promise,
            env::current_account_id(),
            b"request_new_round_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(request_new_round_promise_result);
    }

    pub fn request_new_round_results(&mut self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let request_new_round_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u64 = serde_json::from_slice(&request_new_round_promise_result).unwrap();
        self.requested_round_id = results;
        results
    }

    pub fn read_get_answer(&self, _aggregator: AccountId, _round_id: U128) {
        let read_get_answer_promise = env::promise_create(
            _aggregator.to_string(),
            b"get_answer",
            json!({"_round_id": _round_id}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_get_answer_promise_result = env::promise_then(
            read_get_answer_promise,
            env::current_account_id(),
            b"read_get_answer_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_get_answer_promise_result);
    }

    pub fn read_get_answer_results(&self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_get_answer_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u64 = serde_json::from_slice(&read_get_answer_promise_result).unwrap();
        results
    }

    pub fn read_get_timestamp(&self, _aggregator: AccountId, _round_id: U64) {
        let read_get_timestamp_promise = env::promise_create(
            _aggregator.to_string(),
            b"get_timestamp",
            json!({"_round_id": _round_id}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        let read_get_timestamp_promise_result = env::promise_then(
            read_get_timestamp_promise,
            env::current_account_id(),
            b"read_get_timestamp_results",
            json!({}).to_string().as_bytes(),
            0,
            SINGLE_CALL_GAS,
        );
        env::promise_return(read_get_timestamp_promise_result);
    }

    pub fn read_get_timestamp_results(&self) -> u64 {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
        assert_eq!(env::promise_results_count(), 1);
        let read_get_timestamp_promise_result: Vec<u8> = match env::promise_result(0) {
            PromiseResult::Successful(_x) => _x,
            _x => panic!("No access"),
        };
        let results: u64 = serde_json::from_slice(&read_get_timestamp_promise_result).unwrap();
        results
    }

}

'''
'''--- contract-wrap/link_token/Cargo.toml ---
[package]
name = "link_token"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
near-contract-standards = "3.1.0"

'''
'''--- contract-wrap/link_token/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "link".to_string(),
                symbol: "LINK".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}
'''
'''--- contract-wrap/mock_v3_aggregator/Cargo.toml ---
[package]
name = "mock_v3_aggregator"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/mock_v3_aggregator/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen};

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

pub type Base64String = String;

const VERSION: u128 = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MockV3Aggregator {
    pub decimals: u128,
    pub latest_answer: u128,
    pub latest_timestamp: u128,
    pub latest_round: u128,
    pub get_answer: LookupMap<u128, u128>,
    pub get_timestamp: LookupMap<u128, u128>,
    get_started_at: LookupMap<u128, u128>,
}

impl Default for MockV3Aggregator {
    fn default() -> Self {
        panic!("MockV3Aggregator should be initialized before usage");
    }
}
/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
#[near_bindgen]
impl MockV3Aggregator {
    #[init]
    pub fn new(_decimals: U128, _initial_answer: U128) -> Self {
        let mut result = Self {
            decimals: _decimals.into(),
            latest_answer: 0,
            latest_timestamp: 0,
            latest_round: 0,
            get_answer: LookupMap::new(b"get_answer".to_vec()),
            get_timestamp: LookupMap::new(b"get_timestamp".to_vec()),
            get_started_at: LookupMap::new(b"get_started_at".to_vec()),
        };
        result.update_answer(_initial_answer);
        result
    }

    pub fn update_answer(&mut self, _answer: U128) {
        let new_round: u128 = self.latest_round + 1;
        let current_timestamp: u64 = env::block_timestamp();
        let transformed_answer: u128 = _answer.into();
        self.latest_answer = transformed_answer;
        self.latest_timestamp = u128::from(current_timestamp);
        self.latest_round = new_round;

        let get_answer = self.get_answer.get(&new_round);
        if get_answer.is_none() {
            self.get_answer.insert(&new_round, &transformed_answer);
        } else {
            self.get_answer.remove(&new_round);
            self.get_answer.insert(&new_round, &transformed_answer);
        }

        let get_timestamp = self.get_timestamp.get(&new_round);
        if get_timestamp.is_none() {
            self.get_timestamp
                .insert(&new_round, &u128::from(current_timestamp));
        } else {
            self.get_timestamp.remove(&new_round);
            self.get_timestamp
                .insert(&new_round, &u128::from(current_timestamp));
        }

        let get_started_at = self.get_started_at.get(&new_round);
        if get_started_at.is_none() {
            self.get_started_at
                .insert(&new_round, &u128::from(current_timestamp));
        } else {
            self.get_started_at.remove(&new_round);
            self.get_started_at
                .insert(&new_round, &u128::from(current_timestamp));
        }
    }

    pub fn update_round_data(
        &mut self,
        _round_id: U128,
        _answer: U128,
        _timestamp: U128,
        _started_at: U128,
    ) {
        let transformed_round: u128 = _round_id.into();
        let transformed_timestamp: u128 = u128::from(env::block_timestamp());
        let transformed_answer: u128 = _answer.into();
        let transformed_started_at: u128 = _started_at.into();

        self.latest_answer = transformed_answer;
        self.latest_timestamp = transformed_timestamp;
        self.latest_round = transformed_round;

        let get_answer = self.get_answer.get(&transformed_round);
        if get_answer.is_none() {
            self.get_answer.insert(&transformed_round, &transformed_answer);
        } else {
            self.get_answer.remove(&transformed_round);
            self.get_answer
                .insert(&transformed_round, &transformed_answer);
        }

        let get_timestamp = self.get_timestamp.get(&transformed_round);
        if get_timestamp.is_none() {
            self.get_timestamp.insert(&transformed_round, &transformed_timestamp);
        } else {
            self.get_timestamp.remove(&transformed_round);
            self.get_timestamp
                .insert(&transformed_round, &transformed_timestamp);
        }

        let get_started_at = self.get_started_at.get(&transformed_round);
        if get_started_at.is_none() {
            self.get_started_at.insert(&transformed_round, &transformed_started_at);
        } else {
            self.get_started_at.remove(&transformed_round);
            self.get_started_at
                .insert(&transformed_round, &transformed_started_at);
        }
    }

    pub fn get_round_data(&self, _round_id: U128) -> (u128, u128, u128, u128, u128) {
        let round_id: u128 = u128::from(_round_id);

        let answer = self.get_answer.get(&round_id);
        if answer.is_none() {
            env::panic(b"Answer not available");
        }

        let started_at = self.get_started_at.get(&round_id);
        if started_at.is_none() {
            env::panic(b"Timestamp not available");
        }

        let timestamp = self.get_timestamp.get(&round_id);
        if timestamp.is_none() {
            env::panic(b"Timestamp not available");
        }

        return (
            round_id,
            answer.unwrap(),
            started_at.unwrap(),
            timestamp.unwrap(),
            round_id
        );
    }

    pub fn latest_round_data(&self) -> (u128, u128, u128, u128, u128) {

        let answer = self.get_answer.get(&self.latest_round);
        if answer.is_none() {
            env::panic(b"Answer not available");
        }

        let started_at = self.get_started_at.get(&self.latest_round);
        if started_at.is_none() {
            env::panic(b"Timestamp not available");
        }

        let timestamp = self.get_timestamp.get(&self.latest_round);
        if timestamp.is_none() {
            env::panic(b"Timestamp not available");
        }

        return (
            self.latest_round,
            answer.unwrap(),
            started_at.unwrap(),
            timestamp.unwrap(),
            self.latest_round,
        );
    }

    pub fn latest_answer(&self) -> u128 {
        self.latest_answer
    }

    pub fn latest_timestamp(&self) -> u128 {
        self.latest_timestamp
    }

    pub fn latest_round(&self) -> u128 {
        self.latest_round
    }

    pub fn get_answer(&self,  _round_id: U128) -> u128 {
        let round_id: u128 = u128::from(_round_id);

        let answer = self.get_answer.get(&round_id);
        if answer.is_none() {
            env::panic(b"Answer not available");
        }
        answer.unwrap()
    }

    pub fn get_timestamp(&self,  _round_id: U128) -> u128 {
        let round_id: u128 = u128::from(_round_id);

        let timestamp = self.get_timestamp.get(&round_id);
        if timestamp.is_none() {
            env::panic(b"timestamp not available");
        }
        timestamp.unwrap()
    }

    pub fn get_description(&self) -> String {
        String::from("v0.6/tests/MockV3Aggregator.sol")
    }

    pub fn get_decimals(&self) -> u128 {
        self.decimals
    }
    pub fn get_version(&self) -> u128 {
        VERSION
    }

}

'''
'''--- contract-wrap/simple_read_access_controller/Cargo.toml ---
[package]
name = "simple_read_access_controller"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/simple_read_access_controller/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId};

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct SimpleReadAccessController {
    pub owner: AccountId,
    pending_owner: AccountId,
    pub check_enabled: bool,
    access_list: LookupMap<AccountId, bool>,
}

impl Default for SimpleReadAccessController {
    fn default() -> Self {
        panic!("SimpleReadAccessController should be initialized before usage")
    }
}

#[near_bindgen]
impl SimpleReadAccessController {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");
        let result = Self {
            owner: owner_id,
            pending_owner: "".to_string(),
            check_enabled: true,
            access_list: LookupMap::new(b"access_list".to_vec()),
        };
        result
    }

    pub fn has_access(&self, _user: AccountId) -> bool {
        if env::signer_account_id() != env::predecessor_account_id() {
            if !self.check_enabled {
                !self.check_enabled
            } else {
                let user_option = self.access_list.get(&_user);
                if user_option.is_none() {
                    return false;
                }
                let user = user_option.unwrap();
                user
            }
        } else {
            true
        }
    }

    pub fn add_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            self.access_list.insert(&_user, &true);
        }
    }

    pub fn remove_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            env::panic(b"Did not find the oracle account to remove.");
        }
        self.access_list.insert(&_user, &false);
    }

    pub fn enable_access_check(&mut self) {
        self.only_owner();

        if !self.check_enabled {
            self.check_enabled = true;
        }
    }

    pub fn disable_access_check(&mut self) {
        self.only_owner();

        if self.check_enabled {
            self.check_enabled = false;
        }
    }

    fn only_owner(&self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only callable by owner."
        );
    }

    fn check_access(&self) {
        assert!(self.has_access(env::predecessor_account_id()), "No access")
    }

    pub fn transfer_ownership(&mut self, _to: AccountId) {
        self.only_owner();
        let init_to: AccountId = _to.clone();
        self.pending_owner = _to;
        env::log(format!("{}, {}", self.owner, init_to).as_bytes());
    }

    pub fn accept_ownership(&mut self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.pending_owner,
            "Must be proposed owner"
        );
        let old_owner: AccountId = self.owner.clone();
        self.owner = env::predecessor_account_id();
        self.pending_owner = "".to_string();
        env::log(format!("{}, {}", old_owner, env::predecessor_account_id()).as_bytes());
    }
}

'''
'''--- contract-wrap/simple_write_access_controller/Cargo.toml ---
[package]
name = "simple_write_access_controller"
version = "0.1.0"
authors = ["nolanjacobson <nolanjacobson@protonmail.com>", "kwsantiago <kwsantiago@usf.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.0.1"
num-traits = "0.2"

'''
'''--- contract-wrap/simple_write_access_controller/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::wee_alloc::WeeAlloc;
use near_sdk::{env, near_bindgen, AccountId};

#[global_allocator]
static ALLOC: WeeAlloc = WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct SimpleWriteAccessController {
    pub owner: AccountId,
    pending_owner: AccountId,
    pub check_enabled: bool,
    access_list: LookupMap<AccountId, bool>,
}

impl Default for SimpleWriteAccessController {
    fn default() -> Self {
        panic!("SimpleWriteAccessController should be initialized before usage")
    }
}

#[near_bindgen]
impl SimpleWriteAccessController {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Owner's account ID is invalid"
        );
        assert!(!env::state_exists(), "Already initialized");
        let result = Self {
            owner: owner_id,
            pending_owner: "".to_string(),
            check_enabled: true,
            access_list: LookupMap::new(b"access_list".to_vec()),
        };
        result
    }

    pub fn has_access(&self, _user: AccountId) -> bool {
        if !self.check_enabled {
            !self.check_enabled
        } else {
            let user_option = self.access_list.get(&_user);
            if user_option.is_none() {
                return false;
            }
            let user = user_option.unwrap();
            user
        }
    }

    pub fn add_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            self.access_list.insert(&_user, &true);
        }
    }

    pub fn remove_access(&mut self, _user: AccountId) {
        self.only_owner();

        let user_option = self.access_list.get(&_user);
        if user_option.is_none() {
            env::panic(b"Did not find the oracle account to remove.");
        }
        self.access_list.insert(&_user, &false);
    }

    pub fn enable_access_check(&mut self) {
        self.only_owner();

        if !self.check_enabled {
            self.check_enabled = true;
        }
    }

    pub fn disable_access_check(&mut self) {
        self.only_owner();

        if self.check_enabled {
            self.check_enabled = false;
        }
    }

    fn only_owner(&self) {
        assert_eq!(
            self.owner,
            env::predecessor_account_id(),
            "Only callable by owner."
        );
    }

    fn check_access(&self) {
        assert!(self.has_access(env::predecessor_account_id()), "No access")
    }

    pub fn transfer_ownership(&mut self, _to: AccountId) {
        self.only_owner();
        let init_to: AccountId = _to.clone();
        self.pending_owner = _to;
        env::log(format!("{}, {}", self.owner, init_to).as_bytes());
    }

    pub fn accept_ownership(&mut self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.pending_owner,
            "Must be proposed owner"
        );
        let old_owner: AccountId = self.owner.clone();
        self.owner = env::predecessor_account_id();
        self.pending_owner = "".to_string();
        env::log(format!("{}, {}", old_owner, env::predecessor_account_id()).as_bytes());
    }
}

'''
'''--- contract-wrap/tests/sim/aca_tests.rs ---
use crate::utils::init_without_macros as init;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde_json::json;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::DEFAULT_GAS;

/**
 * #constructor - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L122
 */

#[test]

fn constructor_tests() {
    let payment_amount: u128 = 3;
    let timeout: u64 = 1800;
    let decimals: u64 = 24;
    let description: String = "LINK/USD".to_string();

    let (
        root,
        aca,
        _link,
        _oracle_one,
        _oracle_two,
        _oracle_three,
        _test_helper,
        _eac,
        _eac_without_access_controller,
        _oracle_four,
        _oracle_five,
        _aggregator_validator_mock,
        _flags,
        _consumer,
        _flags_consumer,
        _controller,
        _controller_2,
        _flux_aggregator_test_helper_contract,
        _eddy,
        _mock_v3_aggregator,
        _mock_v3_aggregator_second,
        _read_controller,
        _flux_aggregator,
    ) = init();

    let expected_payment_amount: u128 = root
        .call(
            aca.account_id(),
            "get_payment_amount",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS,
            0,
        )
        .unwrap_json();

    assert_eq!(payment_amount, expected_payment_amount);

    let expected_timeout: u64 = root
        .call(
            aca.account_id(),
            "get_timeout",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS,
            0,
        )
        .unwrap_json();

    assert_eq!(timeout, expected_timeout);

    let expected_decimals: u64 = root
        .call(
            aca.account_id(),
            "get_decimals",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS,
            0,
        )
        .unwrap_json();

    assert_eq!(decimals, expected_decimals);

    let expected_description: String = root
        .call(
            aca.account_id(),
            "get_description",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS,
            0,
        )
        .unwrap_json();

    assert_eq!(description, expected_description);

}
// // #get_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L143
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L160

// #[test]
// fn get_answer_when_read_by_a_contract_without_explicit_access_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_access = eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_get_answer",
//         &json!({"_aggregator": aca.account_id(), "_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }
// // #get_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L143
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L169

// #[test]
// fn get_answer_when_read_by_a_contract_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": flux_aggregator_test_helper_contract.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy
//         .call(
//             flux_aggregator_test_helper_contract.account_id(),
//             "read_get_answer",
//             &json!({"_aggregator": aca.account_id(), "_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// // #get_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L143
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L178

// #[test]
// fn get_answer_when_read_by_a_regular_account_without_explicit_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let round: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     eddy.call(
//         aca.account_id(),
//         "get_answer",
//         &json!({"_round_id": round.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
// }

// // #get_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L143
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L185

// #[test]
// fn get_answer_when_read_by_a_regular_account_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let round: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     eddy.call(
//         aca.account_id(),
//         "get_answer",
//         &json!({"_round_id": round.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
// }

// // #get_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L196
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L213

// #[test]
// fn get_timestamp_when_read_by_a_contract_without_explicit_access_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_access = eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_get_timestamp",
//         &json!({"_aggregator": aca.account_id(), "_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }

// // #get_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L196
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L222

// #[test]
// fn get_timestamp_when_read_by_a_contract_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": flux_aggregator_test_helper_contract.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy
//         .call(
//             flux_aggregator_test_helper_contract.account_id(),
//             "read_get_timestamp",
//             &json!({"_aggregator": aca.account_id(), "_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// // #get_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L196
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L231

// #[test]
// fn get_timestamp_when_read_by_a_regular_account_without_explicit_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let round: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let current_timestamp: u64 = eddy
//         .call(
//             aca.account_id(),
//             "get_timestamp",
//             &json!({"_round_id": round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(current_timestamp > 0, true)
// }

// // #get_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L196
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L231

// #[test]
// fn get_timestamp_when_read_by_a_regular_account_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let round: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let current_timestamp: u64 = eddy
//         .call(
//             aca.account_id(),
//             "get_timestamp",
//             &json!({"_round_id": round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(current_timestamp > 0, true)
// }

// // #latest_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L255
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L272

// #[test]
// fn latest_answer_when_read_by_a_contract_without_explicit_access_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_access = eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_latest_answer",
//         &json!({"_aggregator": aca.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }

// // #latest_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L255
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L281

// #[test]
// fn latest_answer_when_read_by_a_contract_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": flux_aggregator_test_helper_contract.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy
//         .call(
//             flux_aggregator_test_helper_contract.account_id(),
//             "read_latest_answer",
//             &json!({"_aggregator": aca.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// // #latest_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L255
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L290

// #[test]
// fn latest_answer_when_read_by_a_regular_account_without_explicit_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     eddy.call(
//         aca.account_id(),
//         "latest_answer",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
// }

// // // #latest_answer https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L255
// // // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L296

// #[test]
// fn latest_answer_when_read_by_a_regular_account_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy.call(
//         aca.account_id(),
//         "latest_answer",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
// }

// // #latest_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L306
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L323

// #[test]
// fn latest_timestamp_when_read_by_a_contract_without_explicit_access_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_access = eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_latest_timestamp",
//         &json!({"_aggregator": aca.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     println!("{:?}", expected_no_access.promise_results());

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }

// // #latest_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L306
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L332

// #[test]
// fn latest_timestamp_when_read_by_a_contract_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": flux_aggregator_test_helper_contract.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_latest_timestamp",
//         &json!({"_aggregator": aca.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

// }

// // #latest_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L306
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L341

// #[test]
// fn latest_timestamp_when_read_by_a_regular_account_without_explicit_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let current_timestamp: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(current_timestamp > 0, true);
// }

// // #latest_timestamp https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L306
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts#L350

// #[test]
// fn latest_timestamp_when_read_by_a_regular_account_with_access_and_succeeds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//     ) = init();

//     root.call(
//         aca.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             aca.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         aca.account_id(),
//         "add_access",
//         &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let current_timestamp: u64 = eddy
//         .call(
//             aca.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(current_timestamp > 0, true);
// }

'''
'''--- contract-wrap/tests/sim/eac_tests.rs ---
// use crate::utils::init_without_macros as init;
// use near_sdk::serde_json::json;
// use near_sdk_sim::transaction::ExecutionStatus;
// use near_sdk_sim::DEFAULT_GAS;
// const MOCKV3AGGREGATOR_ID_2: &str = "mock_v3_aggregator_2";
// const SIMPLEREADACCESSCONTROLLER_ID: &str = "read_controller";

// // #callers_can_call_view_functions_without_explicit_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L95
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L96 ----- https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L136

// #[test]
// fn callers_can_call_view_functions_without_explicit_access() {
//     let (
//         root,
//         aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     root.call(
//         eac.account_id(),
//         "latest_answer",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     root.call(
//         eac.account_id(),
//         "latest_timestamp",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     // root.call(
//     //     eac.account_id(),
//     //     "get_answer",
//     //     &json!({}).to_string().into_bytes(),
//     //     DEFAULT_GAS,
//     //     0,
//     // ).assert_success();
//     // root.call(
//     //     eac.account_id(),
//     //     "get_timestamp",
//     //     &json!({}).to_string().into_bytes(),
//     //     DEFAULT_GAS,
//     //     0,
//     // ).assert_success();

//     root.call(
//         eac.account_id(),
//         "latest_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     //     root.call(
//     //         eac.account_id(),
//     //         "get_round_data",
//     //         &json!({}).to_string().into_bytes(),
//     //         DEFAULT_GAS,
//     //         0,
//     //     ).assert_success();
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L150
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_and_pulls_the_rate_from_the_aggregator() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     // *TODO* Look into 54321 overflow issue

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();
//     // *TODO* Look into 54321 overflow issue

//     assert_eq!(expected_answer, 54320);

//     let latest_round: u128 = eddy
//         .call(
//             eac.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let get_answer: u128 = eddy
//         .call(
//             eac.account_id(),
//             "get_answer",
//             &json!({ "_round_id": latest_round.to_string() })
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     // *TODO* Look into 54321 overflow issue

//     assert_eq!(get_answer, 54320);
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L156
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_and_pulls_the_timestamp_from_the_aggregator() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let mut expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     expected_timestamp = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let latest_timestamp: u128 = eddy
//         .call(
//             eac.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(latest_timestamp == expected_timestamp, true);

//     let latest_round: u128 = eddy
//         .call(
//             eac.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     expected_timestamp = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let get_timestamp: u128 = eddy
//         .call(
//             eac.account_id(),
//             "get_timestamp",
//             &json!({ "_round_id": latest_round.to_string() })
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp == get_timestamp, true);
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L168
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_and_get_round_data_works() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let proxy_round_id: u128 = eddy
//         .call(
//             eac.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let round: (u128, u128, u128, u128, u128) = eddy
//         .call(
//             eac.account_id(),
//             "get_round_data",
//             &json!({ "_round_id": proxy_round_id.to_string() })
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(proxy_round_id, round.0);
//     assert_eq!(54320, round.1);
//     assert_eq!(677, round.2);
//     assert_eq!(678, round.3);
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L185
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_and_an_aggregator_has_been_proposed_and_proposed_get_round_data_works(
// ) {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     mock_v3_aggregator_second
//         .call(
//             MOCKV3AGGREGATOR_ID_2.into(),
//             "new",
//             &json!({
//                 "_decimals": 18.to_string(),
//                 "_initial_answer": 54320.to_string(),
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS / 2,
//             0, // attached deposit
//         )
//         .assert_success();

//     eac.call(
//         eac.account_id(),
//         "propose_aggregator",
//         &json!({ "_aggregator": MOCKV3AGGREGATOR_ID_2 })
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     let latest_round: u128 = eddy
//         .call(
//             mock_v3_aggregator_second.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let round: (u128, u128, u128, u128, u128) = eddy
//         .call(
//             eac.account_id(),
//             "proposed_get_round_data",
//             &json!({ "_round_id": latest_round.to_string() })
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(latest_round, round.0);
//     assert_eq!(54319, round.1);
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L192
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_and_an_aggregator_has_been_proposed_and_proposed_latest_round_data_works(
// ) {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     mock_v3_aggregator_second
//         .call(
//             MOCKV3AGGREGATOR_ID_2.into(),
//             "new",
//             &json!({
//                 "_decimals": 18.to_string(),
//                 "_initial_answer": 54320.to_string(),
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS / 2,
//             0, // attached deposit
//         )
//         .assert_success();

//     eac.call(
//         eac.account_id(),
//         "propose_aggregator",
//         &json!({ "_aggregator": MOCKV3AGGREGATOR_ID_2 })
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     let latest_round: u128 = eddy
//         .call(
//             mock_v3_aggregator_second.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     let round: (u128, u128, u128, u128, u128) = eddy
//         .call(
//             eac.account_id(),
//             "proposed_latest_round_data",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(latest_round, round.0);
//     assert_eq!(54319, round.1);
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L201
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_without_a_proposed_aggregator_and_proposed_get_round_data_reverts(
// ) {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_no_proposed_aggregator_present = eddy.call(
//         eac.account_id(),
//         "proposed_get_round_data",
//         &json!({ "_round_id": 1.to_string() })
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_proposed_aggregator_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("No proposed aggregator present"));
//     } else {
//         unreachable!();
//     }
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L207
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_without_a_proposed_aggregator_and_proposed_latest_round_data_reverts(
// ) {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_no_proposed_aggregator_present = eddy.call(
//         eac.account_id(),
//         "proposed_latest_round_data",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_proposed_aggregator_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("No proposed aggregator present"));
//     } else {
//         unreachable!();
//     }
// }

// // #if_the_caller_is_granted_access https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L138
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L219
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn if_the_caller_is_granted_access_when_read_from_a_contract_that_is_not_permissioned_and_does_not_allow_reading(
// ) {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//         mock_v3_aggregator,
//         mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": eddy.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let mut expected_answer: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_timestamp: u128 = root
//         .call(
//             mock_v3_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_timestamp != 0, true);

//     expected_answer = eddy
//         .call(
//             eac.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(expected_answer, 54320);

//     let expected_no_access = flux_aggregator_test_helper_contract.call(
//         eac.account_id(),
//         "read_latest_round_data",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }

// // #set_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L228
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L238
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn set_controller_when_called_by_a_stranger_and_reverts() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     read_controller
//         .call(
//             SIMPLEREADACCESSCONTROLLER_ID.into(),
//             "new",
//             &json!({
//                 "owner_id": root.account_id()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS / 2,
//             0, // attached deposit
//         )
//         .assert_success();

//     let expected_only_callable_by_owner = eddy.call(
//         eac.account_id(),
//         "set_controller",
//         &json!({"_access_controller": read_controller.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

// // #set_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L228
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L248
// // *TODO* Look into 54321 overflow issue

// #[test]
// fn set_controller_when_called_by_the_owner_updates_the_controller_contract() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     read_controller
//         .call(
//             SIMPLEREADACCESSCONTROLLER_ID.into(),
//             "new",
//             &json!({
//                 "owner_id": root.account_id()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS / 2,
//             0, // attached deposit
//         )
//         .assert_success();

//     eac.call(
//         eac.account_id(),
//         "set_controller",
//         &json!({"_access_controller": read_controller.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     let expected_access_controller: String = root
//         .view(
//             eac.account_id(),
//             "access_controller",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(
//         expected_access_controller == read_controller.account_id(),
//         true
//     )
// }

// // #set_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L254
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/EACAggregatorProxy.test.ts#L259

// #[test]
// fn set_controller_when_set_to_the_zero_address_and_allows_anyone_to_read() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         read_controller,
//     ) = init();

//     let expected_no_access = eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_latest_round_data",
//         &json!({"_aggregator": eac.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_access
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }

//     eac.call(
//         eac.account_id(),
//         "set_controller",
//         &json!({"_access_controller": "".to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     eddy.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_latest_round_data",
//         &json!({"_aggregator": eac.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();
// }

'''
'''--- contract-wrap/tests/sim/flags_tests.rs ---
// use near_sdk::serde_json::json;
// use near_sdk_sim::transaction::ExecutionStatus;
// use near_sdk_sim::DEFAULT_GAS;

// use crate::utils::init_without_macros as init;

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L57

// #[test]
// fn raise_flag_when_called_by_the_owner_and_updates_the_warning_flag() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let expected_false_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(false, expected_false_value);

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L65
// // *TODO* Look into naming Events and parsing the names for verification the event exists.

// #[test]
// fn raise_flag_when_called_by_the_owner_and_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "raise_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     // *TODO* Look into naming Events and parsing the names for verification the event exists.

//     assert_eq!(tx.logs()[0], flags_consumer.account_id().to_string());
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L76

// #[test]
// fn raise_flag_when_called_by_the_owner_and_if_a_flag_has_already_been_raised_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "raise_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(0, tx.logs().len());
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L89

// #[test]
// fn raise_flag_when_called_by_an_enabled_setter_sets_the_flags() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({
//                 "_user": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flags.account_id(),
//             "raise_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L96

// #[test]
// fn raise_flag_when_called_by_a_non_enabled_setter_and_reverts() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let expected_not_allowed_to_raise_flags = oracle_one.call(
//         flags.account_id(),
//         "raise_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_allowed_to_raise_flags
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L111
// // *TODO* Look into naming Events and parsing the names for verification the event exists.

// #[test]
// fn raise_flag_when_called_when_there_is_no_raising_access_controller_and_succeeds_for_the_owner() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({
//             "rac_address": "".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     // *TODO* Look into naming Events and parsing the names for verification the event exists.

//     assert_eq!(tx.logs()[0], "controller, ");

//     let current_raising_access_controller: String = oracle_three
//         .call(
//             flags.account_id(),
//             "get_raising_access_controller",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(current_raising_access_controller, "");

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L55
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L116
// // *TODO* Look into naming Events and parsing the names for verification the event exists.

// #[test]
// fn raise_flag_when_called_when_there_is_no_raising_access_controller_and_reverts_for_non_owner() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({
//             "rac_address": "".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(tx.logs()[0], "controller, ");

//     let current_raising_access_controller: String = oracle_three
//         .call(
//             flags.account_id(),
//             "get_raising_access_controller",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(current_raising_access_controller, "");

//     let expected_not_allowed_to_raise_flags = oracle_one.call(
//         flags.account_id(),
//         "raise_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_allowed_to_raise_flags
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L124

// #[test]
// fn raise_flags_when_called_by_the_owner_and_updates_the_warning_flag() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let expected_false_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(false, expected_false_value);

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L132
// // *TODO* Look into naming Events and parsing the names for verification the event exists.

// #[test]
// fn raise_flags_when_called_by_the_owner_and_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     // *TODO* Look into naming Events and parsing the names for verification the event exists.

//     assert_eq!(tx.logs()[0], flags_consumer.account_id().to_string());
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L143

// #[test]
// fn raise_flags_when_called_by_the_owner_and_if_a_flag_has_already_been_raised_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(0, tx.logs().len());
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L156

// #[test]
// fn raise_flags_when_called_by_an_enabled_setter_sets_the_flags() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({
//                 "_user": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L162

// #[test]
// fn raise_flags_when_called_by_a_non_enabled_setter_and_reverts() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let expected_not_allowed_to_raise_flags = oracle_one.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_allowed_to_raise_flags
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L179

// #[test]
// fn raise_flags_when_called_when_there_is_no_raising_access_controller_and_succeeds_for_the_owner() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({
//             "rac_address": "".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(tx.logs()[0], "controller, ");

//     let current_raising_access_controller: String = oracle_three
//         .call(
//             flags.account_id(),
//             "get_raising_access_controller",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(current_raising_access_controller, "");

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);
// }

// // #raise_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L122
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L184

// #[test]
// fn raise_flags_when_called_when_there_is_no_raising_access_controller_and_reverts_for_non_owner() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({
//             "rac_address": "".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(tx.logs()[0], "controller, ");

//     let current_raising_access_controller: String = oracle_three
//         .call(
//             flags.account_id(),
//             "get_raising_access_controller",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(current_raising_access_controller, "");

//     let expected_not_allowed_to_raise_flags = oracle_one.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_allowed_to_raise_flags
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }
// }

// // #lower_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L190
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L196

// #[test]
// fn lower_flags_when_called_by_the_owner_updates_the_warning_flag() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_true_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(true, expected_true_value);

//     oracle_three
//         .call(
//             flags.account_id(),
//             "lower_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_false_value: bool = oracle_three
//         .call(
//             flags.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(false, expected_false_value);
// }

// // #lower_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L190
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L204
// // *TODO* Look into naming Events and parsing the names for verification the event exists.

// #[test]
// fn lower_flags_when_called_by_the_owner_and_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "lower_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     // *TODO* Look into naming Events and parsing the names for verification the event exists.

//     assert_eq!(tx.logs()[0], flags_consumer.account_id().to_string());
// }

// // #lower_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L190
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L215

// #[test]
// fn lower_flags_when_called_by_the_owner_and_if_a_flag_has_already_been_raised_emits_an_event_log() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "lower_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "lower_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(0, tx.logs().len());
// }

// // #lower_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L190
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L224

// #[test]
// fn lower_flags_when_called_by_a_non_owner_and_reverts() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({
//                 "subjects": [flags_consumer.account_id().to_string()]
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_one.call(
//         flags.account_id(),
//         "lower_flags",
//         &json!({
//             "subjects": [flags_consumer.account_id().to_string()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &tx.promise_errors().remove(0).unwrap().outcome().status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

// // #get_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L232
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L238

// #[test]
// fn get_flag_if_the_access_control_is_turned_on_and_reverts() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = flags_consumer.call(
//         flags_consumer.account_id(),
//         "get_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &tx.promise_errors().remove(0).unwrap().outcome().status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }
// }

// // #get_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L232
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L247

// #[test]
// fn get_flag_if_the_access_control_is_turned_on_and_if_access_is_granted_to_the_address_and_does_not_revert(
// ) {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();
//     oracle_three
//         .call(
//             flags.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "add_access",
//             &json!({"_user": flags_consumer.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     flags_consumer
//         .call(
//             flags_consumer.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();
// }

// // #get_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L232
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L258

// #[test]
// fn get_flag_if_the_access_control_is_turned_off_and_and_does_not_revert() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "disable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     flags_consumer
//         .call(
//             flags_consumer.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();
// }

// // #get_flag https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L232
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L267

// #[test]
// fn get_flag_if_the_access_control_is_turned_off_and_if_access_is_granted_to_the_address_and_does_not_revert(
// ) {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "disable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "add_access",
//             &json!({"_user": flags_consumer.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     flags_consumer
//         .call(
//             flags_consumer.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();
// }

// // #get_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L274
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L282

// #[test]
// fn get_flags_and_respects_the_access_controls_of_get_flag() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "disable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({"subjects": [oracle_one.account_id(), oracle_five.account_id()]})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = flags_consumer.call(
//         flags_consumer.account_id(),
//         "get_flag",
//         &json!({
//             "subject": flags_consumer.account_id().to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &tx.promise_errors().remove(0).unwrap().outcome().status
//     {
//         assert!(execution_error.to_string().contains("No access"));
//     } else {
//         unreachable!();
//     }

//     oracle_three
//         .call(
//             flags.account_id(),
//             "add_access",
//             &json!({
//                 "_user": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     flags_consumer
//         .call(
//             flags_consumer.account_id(),
//             "get_flag",
//             &json!({
//                 "subject": flags_consumer.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();
// }

// // #get_flags https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L274
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L292
// // *TODO* Parse promise results for assertion.

// #[test]
// fn get_flags_and_returns_the_flags_in_the_order_they_are_requested() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "disable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "raise_flags",
//             &json!({"subjects": [oracle_one.account_id(), oracle_five.account_id()]})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags_consumer.account_id(),
//         "get_flags",
//         &json!({
//             "subjects": [oracle_three.account_id(), oracle_one.account_id(), oracle_two.account_id(), oracle_five.account_id()]
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     // *TODO* Parse promise results for assertion.

//     println!("{:?}", tx.promise_results());
// }

// // #set_raising_access_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L304
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L312

// #[test]
// fn set_raising_access_controller_and_updates_access_control_rules() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         flags_consumer,
//         _controller,
//         controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "add_access",
//             &json!({"_user": oracle_three.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     // doesn't raise

//     let expected_doesnt_raise = oracle_one.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({"subjects": [flags_consumer.account_id()]})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_doesnt_raise
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }

//     oracle_three
//         .call(
//             flags.account_id(),
//             "set_raising_access_controller",
//             &json!({"rac_address": controller_2.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_one.call(
//         flags.account_id(),
//         "raise_flags",
//         &json!({"subjects": [flags_consumer.account_id()]})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &tx.promise_errors().remove(0).unwrap().outcome().status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Not allowed to raise flags"));
//     } else {
//         unreachable!();
//     }
// }

// // #set_raising_access_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L304
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L324

// #[test]
// fn set_raising_access_controller_and_emits_a_log_announcing_the_change() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "add_access",
//             &json!({"_user": oracle_three.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({"rac_address": controller_2.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(tx.logs()[0], "controller, controller_2");
// }

// // #set_raising_access_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L304
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L330

// #[test]
// fn set_raising_access_controller_and_does_not_emit_a_log_when_there_is_no_change() {
//     let (
//         _root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "add_access",
//             &json!({"_user": oracle_three.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flags.account_id(),
//             "set_raising_access_controller",
//             &json!({"rac_address": controller_2.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let tx = oracle_three.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({"rac_address": controller_2.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     assert_eq!(tx.logs().len(), 0);
// }

// // #set_raising_access_controller https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L304
// // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/Flags.test.ts#L340

// #[test]
// fn set_raising_access_controller_and_when_called_by_a_non_owner_and_reverts() {
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy
//     ) = init();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "enable_access_check",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             controller_2.account_id(),
//             "add_access",
//             &json!({"_user": oracle_three.account_id()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .assert_success();

//     let expected_only_callable_by_owner = oracle_one.call(
//         flags.account_id(),
//         "set_raising_access_controller",
//         &json!({"rac_address": controller_2.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0,
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

'''
'''--- contract-wrap/tests/sim/flux_agg_tests.rs ---
use near_sdk::serde_json::json;
use near_sdk::AccountId;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::DEFAULT_GAS;
use near_sdk::json_types::{U128, U64};

use crate::utils::init_without_macros as init;

// /**
//  * FluxAggregator tests were ported from this file https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts
//  */

// /**
//  * #constructor - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L214
//  */

// #[test]

// fn constructor_tests() {
//     let payment_amount: u128 = 3;
//     let timeout: u64 = 1800;
//     let decimals: u64 = 24;
//     let description: String = "LINK/USD".to_string();
//     let version: u128 = 3;
//     let validator: String = "".to_string();

//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let expected_payment_amount: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(payment_amount, expected_payment_amount);

//     let expected_timeout: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_timeout",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(timeout, expected_timeout);

//     let expected_decimals: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_decimals",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(decimals, expected_decimals);

//     let expected_description: String = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_description",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(description, expected_description);

//     let expected_version: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_version",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(version, expected_version);

//     let expected_validator: String = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_validator",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(validator, expected_validator);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L249
//  * *TODO* Fix parsing of the log
//  */
// #[test]
// fn updates_the_allocated_and_available_funds_counters() {
//     let payment_amount: u128 = 3;
//     let deposit: u128 = 100;
//     let answer: u128 = 100;
//     let rr_delay: u128 = 0;
//     let next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let mut allocated_funds: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(allocated_funds, 0);

//     let tx = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let mut receipt = tx.promise_results();

//     allocated_funds = root
//         .view(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let available_funds: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(payment_amount, allocated_funds);

//     let expected_available: u128 = deposit - payment_amount;

//     assert_eq!(expected_available, available_funds);

//     // *TODO* Fix parsing of the log
//     let logged: u128 = receipt.remove(1).unwrap().outcome().logs[3]
//         .parse()
//         .unwrap();

//     assert_eq!(expected_available, logged);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L262
//  */
// #[test]
// fn emits_a_log_event_announcing_submission_details() {
//     let payment_amount: u128 = 3;
//     let deposit: u128 = 100;
//     let answer: u128 = 100;
//     let rr_delay: u128 = 0;
//     let next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let mut allocated_funds: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(allocated_funds, 0);

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     allocated_funds = root
//         .view(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let available_funds: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(payment_amount, allocated_funds);

//     let expected_available: u128 = deposit - payment_amount;

//     assert_eq!(expected_available, available_funds);

//     let tx = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(tx.logs()[0], "100, 1, oracle_three");
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L269
//  */
// #[test]
// fn when_the_minimum_oracles_have_not_reported_and_pays_the_oracles_that_have_reported() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min_max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let withdrawable_payment: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment);

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let withdrawable_payment_oracle_one: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(payment_amount, withdrawable_payment_oracle_one);

//     let withdrawable_payment_oracle_two: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_two.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment_oracle_two);

//     let withdrawable_payment_oracle_three: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_three.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment_oracle_three);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L285
//  */
// #[test]
// fn when_the_minimum_oracles_have_not_reported_and_does_not_update_the_answer() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min_max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let not_updated: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(0, not_updated);

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let still_not_updated: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(0, still_not_updated);
// }
// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L302
//  */
// #[test]
// fn when_an_oracle_prematurely_bumps_the_round_and_reverts() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_previous_round_not_supersedable = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": (next_round + 1).to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_previous_round_not_supersedable
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("previous round not supersedable"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L310
//  */
// #[test]
// fn updates_the_answer_with_the_median() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_latest_answer: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(0, expected_latest_answer);

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": 99.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_latest_answer_first: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(99, expected_latest_answer_first);

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": 101.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_latest_answer_second: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(100, expected_latest_answer_second);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L327
//  */
// #[test]

// fn updates_the_updated_timestamp() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let original_timestamp: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(original_timestamp > 0, true);

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let current_timestamp: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(current_timestamp > original_timestamp, true);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L337
//  * *TODO* Look into emitting necessary log
//  */
// #[test]

// fn announces_the_new_answer_with_a_log_event() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let mut receipt = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let new_answer: u64 = receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//         .parse()
//         .unwrap();

//     let latest_answer: u64 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(latest_answer, new_answer);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L346
//  */
// #[test]

// fn does_not_set_the_timedout_flag() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_data_present = test_helper.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": next_round.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let latest_round_data: (u64, u128, u64, u64, u64) = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round_data",
//             &json!({"_round_id": next_round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(next_round, latest_round_data.4);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L355
//  */
// #[test]

// fn submit_and_updates_the_round_details() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_data_present = test_helper.call(
//         flux_aggregator.account_id(),
//         "latest_round_data",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         println!("{:?}", execution_error.to_string());
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let round_after: (u64, u128, u64, u64, u64) = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "get_round_data",
//             &json!({"_round_id": next_round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(next_round, round_after.0);
//     assert_eq!(answer, round_after.1);
//     assert_eq!(false, round_after.2 == 0);

//     let original_timestamp: u128 = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_timestamp",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(original_timestamp as u64, round_after.3);
//     assert_eq!(1, round_after.4);
//     assert_eq!(true, round_after.2 < round_after.3);

//     let latest_round_data: (u64, u128, u64, u64, u64) = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round_data",
//             &json!({"_round_id": next_round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(true, round_after.0 == latest_round_data.0);
//     assert_eq!(true, round_after.1 == latest_round_data.1);
//     assert_eq!(true, round_after.2 == latest_round_data.2);
//     assert_eq!(true, round_after.3 == latest_round_data.3);
//     assert_eq!(true, round_after.4 == latest_round_data.4);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L380
//  */
// #[test]

// fn when_an_oracle_submits_for_a_round_twice_and_reverts() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min_max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let withdrawable_payment: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment);

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let cannout_report_on_previous_rounds = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &cannout_report_on_previous_rounds
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("cannot report on previous rounds"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L396
//  */
// #[test]

// fn when_updated_after_the_max_answers_submitted_and_reverts() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L484 sets the min and max submissions back to 1

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let round_not_accepting_submissions = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &round_not_accepting_submissions
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("round not accepting submissions"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L402
//  * **TODO** Look into why oracle_round_state_suggest_round is returning the wrong data.
//  */
// #[test]
// fn when_a_new_highest_round_number_is_passed_in_and_increments_the_answer_round() {
//     let rr_delay: u64 = 0;
//     let answer: u64 = 100;
//     let next_round: u64 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = test_helper
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_one.account_id(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(1, starting_state.1);

//     // Advance round non-refactored function, https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L498

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L498 - Look into the oracle_round_state and oracle_round_suggest_state functions to return the correct results for 0 state.

//     let updated_state = test_helper.call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_one.account_id(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     println!("{:?} SEC", starting_state);
//     assert_eq!(2, starting_state.1);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L412
//  * **TODO** Look into grabbing the block timestamp from tx.
//  */
// #[test]
// fn when_a_new_highest_round_number_is_passed_in_and_sets_the_started_at_time_for_the_reporting_round(
// ) {
//     let rr_delay: u64 = 0;
//     let answer: u64 = 100;
//     let next_round: u64 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": next_round.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }

//     // Advance round non-refactored function, https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L498

//     let tx = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let updated_state: (u64, u128, u64, u64, u64) = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_round_data",
//             &json!({"_round_id": next_round.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     // *TODO* Look into grabbing the block timestamp from tx.

//     // assert_eq!(2, updated_state.2);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L425
//  *
//  */
// #[test]
// fn when_a_new_highest_round_number_is_passed_in_and_announces_a_new_round_by_emitting_a_log() {
//     let rr_delay: u64 = 0;
//     let answer: u64 = 100;
//     let next_round: u64 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": next_round.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }

//     let tx = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(tx.logs()[0].contains("1, oracle_one"), true);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L439
//  * **TODO** Look into why oracle_round_state_suggest_round is returning the wrong data.
//  */
// #[test]

// fn when_a_round_is_passed_in_higher_than_expected_and_reverts() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let invalid_round_to_report = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": (next_round + 1).to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &invalid_round_to_report
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("invalid round to report"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L445
//  * **TODO** Look into why oracle_round_state_suggest_round is returning the wrong data.
//  */
// #[test]

// fn when_called_by_a_non_oracle_and_reverts() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let min: u64 = 2;
//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     // Carol

//     let not_enabled_oracle = root.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );
//     if let ExecutionStatus::Failure(execution_error) = &not_enabled_oracle
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error.to_string().contains("not enabled oracle"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L450
//  * **TODO** Look into subtraction overflow errors
//  */
// #[test]

// fn when_there_are_not_sufficient_available_funds() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let max: u64 = 3;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": max.to_string(), "_max_submissions": max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     // Carol

//     root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": root.account_id().to_string(), "_amount": 82.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         1, // deposit
//     )
//     .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     let subtraction_overflow_math_error = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     println!("{:?}", subtraction_overflow_math_error.promise_results());

//     if let ExecutionStatus::Failure(execution_error) = &subtraction_overflow_math_error
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // SafeMath: subtraction overflow
//         assert!(execution_error
//             .to_string()
//             .contains("SafeMath: subtraction overflow"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L479
//  *
//  */
// #[test]

// fn when_a_new_round_opens_before_the_previous_rounds_closes_and_still_allows_the_previous_round_to_be_answered(
// ) {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_four.account_id(), oracle_five.account_id() ], "_min_submissions": 3.to_string(), "_max_submissions": 4.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = 2;

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // still allows the previous round to be answered

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": (next_round - 1).to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L491
//  *
//  */
// #[test]

// fn once_the_current_round_is_answered_does_not_allow_reports_for_the_previous_round() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_four.account_id(), oracle_five.account_id() ], "_min_submissions": 3.to_string(), "_max_submissions": 4.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = 2;

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // once the current round is answered

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // does not allow reports for the previous round

//     let invalid_round_to_report = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": (next_round - 1).to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &invalid_round_to_report
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("invalid round to report"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L501
//  *
//  */
// #[test]

// fn when_the_previous_round_has_finished_and_does_not_allow_reports_for_the_previous_round() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_four.account_id(), oracle_five.account_id() ], "_min_submissions": 3.to_string(), "_max_submissions": 4.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = 2;

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // when the previous round has finished

//     oracle_five
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // does not allow reports for the previous round

//     let round_not_accepting_submissions = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": 1.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &round_not_accepting_submissions
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("round not accepting submissions"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L513
//  *
//  */
// #[test]

// fn when_price_is_updated_mid_round_and_pays_the_same_amount_to_all_oracles_per_round() {
//     let new_amount: u128 = 50;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let min_max: u128 = 3;
//     let timeout: u64 = 1800;

//     let (
//         root,
//         _aca,
//         link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         link.account_id(),
//         "ft_transfer",
//         &json!({
//             "receiver_id": flux_aggregator.account_id().to_string(), "amount": 300.to_string(), "memo": "None"
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         1
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     let mut withdrawable_payment_oracle_one: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment_oracle_one);

//     let mut withdrawable_payment_oracle_three: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_three.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, withdrawable_payment_oracle_three);

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": new_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     withdrawable_payment_oracle_one = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_one.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(3, withdrawable_payment_oracle_one);

//     withdrawable_payment_oracle_three = root
//         .view(
//             flux_aggregator.account_id(),
//             "withdrawable_payment",
//             &json!({
//                 "_oracle": oracle_three.account_id().to_string()
//             })
//             .to_string()
//             .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(3, withdrawable_payment_oracle_three);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L549
//  *
//  */
// #[test]

// fn when_delay_is_on_does_not_revert_on_the_oracles_first_round() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 1;
//     let timeout: u64 = 1800;
//     let next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//             flux_aggregator.account_id(),
//             "update_future_rounds",
//             &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L557
//  *
//  */
// #[test]

// fn when_delay_is_on_and_does_revert_before_the_delay() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 1;
//     let timeout: u64 = 1800;
//     let mut next_round: u128 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id() ], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//             flux_aggregator.account_id(),
//             "update_future_rounds",
//             &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     let expected_previous_round_not_supersedable = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_previous_round_not_supersedable
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("previous round not supersedable"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L590
//  *
//  */
// #[test]

// fn when_called_by_an_oracle_who_has_not_answered_recently_and_does_not_revert() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 2.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 3.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // Since Ned and Nelly have answered recently, and we set the delay
//     // to 2, only Nelly can answer as she is the only oracle that hasn't
//     // started the last two rounds.
//     // await updateFutureRounds(aggregator, {
//     //   maxAnswers: oracles.length,
//     //   restartDelay: newDelay,
//     // })

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 2.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // when called by an oracle who has not answered recently
//     // it does not revert
//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 4.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L596
//  *
//  */
// #[test]

// fn when_called_by_an_oracle_who_has_answered_recently_and_reverts() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 2.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 3.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     // Since Ned and Nelly have answered recently, and we set the delay
//     // to 2, only Nelly can answer as she is the only oracle that hasn't
//     // started the last two rounds.
//     // await updateFutureRounds(aggregator, {
//     //   maxAnswers: oracles.length,
//     //   restartDelay: newDelay,
//     // })

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 2.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // when called by an oracle who has answered recently
//     // it does not revert
//     let expected_round_not_accepting_submissions = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": 4.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_round_not_accepting_submissions
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("round not accepting submissions"));
//     } else {
//         unreachable!();
//     }

//     let expected_round_not_accepting_submissions_two = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": 4.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_round_not_accepting_submissions_two
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("round not accepting submissions"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L630
//  * *TODO* Look into why the contract panics on oracle_three starting a new round. Error: previous round not supersedable.
//  */
// #[test]

// fn when_the_price_is_not_updated_for_a_round_and_allows_a_new_round_to_be_started() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(

//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // allows a new round to be started
//     // *TODO* Look into why the contract panics on oracle_three starting a new round. Error: previous round not supersedable.
//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L634
//  * *TODO* Look into how to acheive this with NEAR's sdk  const block = await provider.getBlock(receipt.blockHash ?? '')
//  */
// #[test]
// fn sets_the_info_for_the_previous_round() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(

//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // sets the info for the previous round
//     let mut expected_updated_timestamp: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_timestamp",
//             &json!({"_round_id": (next_round - 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, expected_updated_timestamp);

//     let mut expected_answer: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_answer",
//             &json!({"_round_id": (next_round - 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(0, expected_answer);

//     let tx = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     println!("{:?}", tx);

//     // *TODO*: Look into this const block = await provider.getBlock(receipt.blockHash ?? '')
//     //  matchers.bigNum(ethers.utils.bigNumberify(block.timestamp), updated)

//     expected_updated_timestamp = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_timestamp",
//             &json!({"_round_id": (next_round - 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//         )
//         .unwrap_json();
//     // assert_eq!(tx.timestamp, expected_updated_timestamp);

//     expected_answer = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_answer",
//             &json!({"_round_id": (next_round - 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(answer, expected_answer);

//     let expected_round: (u64, u128, u64, u64, u64) = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_round_data",
//             &json!({"_round_id": (next_round - 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(2, expected_round.0);
//     assert_eq!(answer, expected_round.1);
//     assert_eq!(expected_updated_timestamp as u64, expected_round.3);
//     assert_eq!(1, expected_round.4);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L658
//  */
// #[test]
// fn sets_the_previous_round_as_timed_out() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(

//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // sets the previous round as timed out
//     // *TODO* Look into why the panic error contains previous round not supersedable and not No data present
//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": (next_round - 1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );
//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_round: (u64, u128, u64, u64, u64) = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_round_data",
//             &json!({"_round_id": 2.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(2, expected_round.0);
//     assert_eq!(1, expected_round.4);
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L669
//  */
// #[test]

// fn still_respects_the_delay_restriction() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(

//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     println!("{:?}", next_round);

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     let expected_revert = oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_revert
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // expected to revert because the sender started the last round
//         assert!(execution_error
//             .to_string()
//             .contains("previous round not supersedable"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L674
//  */
// #[test]

// fn uses_the_set_timeout_at_the_beginning_of_the_round() {
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let timeout: u64 = 1800;
//     let min_max: u128 = 3;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(

//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     println!("{:?}", next_round);

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": (timeout+100000).to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L684
//  */
// #[test]
// fn rejects_values_below_the_submission_value_range() {
//     let rr_delay: u64 = 0;
//     let min_submission_value: u64 = 1;
//     let next_round: u64 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_value_below_min_submission_value = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": (min_submission_value-1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_value_below_min_submission_value
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("value below min_submission_value"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L691
//  */
// #[test]
// fn accepts_submissions_equal_to_the_min_submission_value() {
//     let rr_delay: u64 = 0;
//     let min_submission_value: u64 = 1;
//     let next_round: u64 = 1;
//     let min_max: u128 = 3;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": (min_submission_value).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L695
//  */
// #[test]
// fn accepts_submissions_equal_to_the_max_submission_value() {
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let min_max: u128 = 3;
//     let max_submission_value: u128 = 100000000000000000000;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": (max_submission_value).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L699
//  */
// #[test]
// fn rejects_values_above_the_max_submission_value() {
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let min_max: u128 = 3;
//     let max_submission_value: u128 = 100000000000000000000;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_value_above_max_submission_value = oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": (max_submission_value + 1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_value_above_max_submission_value
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         // No data present should be error
//         assert!(execution_error
//             .to_string()
//             .contains("value above max_submission_value"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L716
//  */

// #[test]
// fn calls_out_to_the_validator() {
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let min_max: u128 = 3;
//     let payment_amount: u128 = 3;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_max.to_string(), "_max_submissions": min_max.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 1.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // Carol

//     root.call(
//         flux_aggregator.account_id(),
//         "set_validator",
//         &json!({"_new_validator": aggregator_validator_mock.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let tx = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(tx.promise_results().remove(2).unwrap().outcome().logs[0], "0, 0, 1, 100")
// }

// /**
//  * #submit - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L240
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L733
//  */

// #[test]
// fn still_updates() {
// }

// /**
//  * #get_answer - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L743
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L754
//  */

// #[test]
// fn retrieves_the_answer_recorded_for_past_rounds() {
//     let answers: Vec<u128> = [1, 10, 101, 1010, 10101, 101010, 1010101].to_vec();
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let mut n = 0;
//     let mut y = 1;
//     let mut x = 0;

//     while n < answers.len() {
//         oracle_one.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[n].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();
//         next_round += 1;
//         n += 1;
//     }

//     while y < next_round {
//         let answer: u128 = root
//             .call(
//                 flux_aggregator.account_id(),
//                 "get_answer",
//                 &json!({"_round_id": y.to_string()}).to_string().into_bytes(),
//                 DEFAULT_GAS,
//                 0, // deposit
//             )
//             .unwrap_json();
//         let expected_answer: u128 = answers[x] as u128;
//         x += 1;
//         y += 1;
//         assert_eq!(answer, expected_answer);
//     }
// }

// /**
//  * #get_answer - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L743
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L761
//  * *TODO* Research overflowedId issue for Rust uint type
//  */

// #[test]
// fn returns_zero_for_answers_greater_than_uint32s_max() {
// }

// /**
//  * #get_timestamp - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L768
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L777
//  */

// #[test]
// fn retrieves_the_timestamp_recorded_for_past_rounds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let mut i = 0;
//     let mut z = 1;
//     let mut latest_timestamp: u128 = 0;

//     while i < 10 {
//         oracle_one.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": (i + 1).to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();
//         next_round += 1;
//         i += 1;
//     }

//     while z < next_round {
//         let current_timestamp: u128 = root
//             .call(
//                 flux_aggregator.account_id(),
//                 "get_timestamp",
//                 &json!({"_round_id": z.to_string()}).to_string().into_bytes(),
//                 DEFAULT_GAS,
//                 0, // deposit
//             )
//             .unwrap_json();
//         z += 1;
//         assert_eq!(current_timestamp >= latest_timestamp, true);
//         latest_timestamp = current_timestamp;
//     }
// }

// /**
//  * #get_timestamp - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L768
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L787
//  */

// #[test]
// fn returns_zero_for_timestamps_greater_than_uint32s_max() {
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L796
//  */

// #[test]
// fn increases_the_oracle_count() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let past_count: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "oracle_count",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let current_count: u128 = root
//     .view(
//         flux_aggregator.account_id(),
//         "oracle_count",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(past_count + 1, current_count);
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L804
//  */

// #[test]
// fn adds_the_address_in_get_oracles() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let oracles: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(oracle_one.account_id().to_string(), oracles[0]);
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L809
//  */

// #[test]
// fn change_oracles_and_updates_the_round_details() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": 2.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let min_submission_count: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let max_submission_count: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let restart_delay: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "restart_delay",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(min_submission_count, 1);
//     assert_eq!(max_submission_count, 3);
//     assert_eq!(restart_delay, 2);
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L816
//  */

// #[test]
// fn emits_a_log() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let oracle_added_event = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).promise_results();

//     let oracle_added_event_oracle: String = oracle_added_event.clone().remove(1).unwrap().outcome().logs[0]
//         .parse()
//         .unwrap();

//     let result = [oracle_two.account_id(), ", true".to_string()].join("");

//     assert_eq!(result, oracle_added_event_oracle);

//     let oracle_admin_updated_event_oracle: String = oracle_added_event.clone().remove(1).unwrap().outcome().logs[1]
//         .parse()
//         .unwrap();

//     let result_two = [oracle_one.account_id(), ", true".to_string()].join("");

//     assert_eq!(result_two, oracle_admin_updated_event_oracle);
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L834
//  */

// #[test]

// fn when_the_oracle_has_already_been_added_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_oracle_already_enabled = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_oracle_already_enabled
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("oracle already enabled"));
//     } else {
//         unreachable!();
//     }

// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L840
//  */

// #[test]

// fn change_oracles_and_when_called_by_anyone_but_the_owner_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let (
//         _root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let expected_only_callable_by_owner = oracle_one.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L867
//  */

// #[test]

// fn does_not_allow_the_oracle_to_update_the_round() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     let expected_not_yet_enabled_oracle = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_yet_enabled_oracle
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("not yet enabled oracle"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L871
//  */

// #[test]

// fn does_allow_the_oracle_to_update_future_rounds() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     next_round = next_round + 1;

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L881
//  */

// #[test]

// fn when_an_oracle_is_added_after_removed_for_a_round_and_allows_the_oracle_to_update() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L903
//  */

//  #[test]

// fn when_an_oracle_is_added_and_immediately_removed_mid_round_allows_the_oracle_to_update() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let mut next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L924
//  * **TODO** Research why the contract is not panicking with owner cannot overwrite admin, reckoning that the issue is in remove_oracle 
//  */

// #[test]

// fn when_an_oracle_is_re_added_after_with_a_different_admin_address_and_reverts() {
//     let answer: u128 = 100;
//     let rr_delay: u64 = 0;
//     let next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 3.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     let expected_owner_cannot_override_admin = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [root.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );
//     // *TODO* Research why the contract is not panicking with owner cannot overwrite admin

//     if let ExecutionStatus::Failure(execution_error) = &expected_owner_cannot_override_admin
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         println!("{:?}", execution_error
//         .to_string());
//         assert!(execution_error
//             .to_string()
//             .contains("owner cannot overwrite admin"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L975
//  * **TODO** Look into a simple way to implement this function
//  */

// #[test]

// fn not_use_too_much_gas() {}

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1011
//  * **TODO** Look into a simple way to implement this function
//  */

// #[test]

// fn reverts_when_another_oracle_is_added() {}

// /**
//  * #change_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L794
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1028
//  * **TODO** Look into a simple way to implement this function
//  */

// #[test]

// fn reverts_when_min_submissions_is_set_to_0() {}

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1039
//  */

// #[test]

// fn decreases_the_oracle_count() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let past_count: u128 = root.view(
//             flux_aggregator.account_id(),
//             "oracle_count",
//             &json!({}).to_string().into_bytes()
//         )
//         .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let current_count: u128 = root.view(
//         flux_aggregator.account_id(),
//         "oracle_count",
//         &json!({}).to_string().into_bytes()
//     )
//     .unwrap_json();

//     assert_eq!(past_count - 1, current_count);
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1049
//  */

// #[test]

// fn removing_oracles_and_updates_the_round_details() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let restart_delay: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "restart_delay",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(min_submission_count, 1);
//     assert_eq!(max_submission_count, 1);
//     assert_eq!(restart_delay, 0);
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1057
//  */

// #[test]

// fn removing_oracles_and_emits_a_log() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let oracle_removed_event = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).promise_results();

//     let oracle_removed_event_log: String = oracle_removed_event
//         .clone()
//         .remove(1)
//         .unwrap()
//         .outcome()
//         .logs[0]
//         .parse()
//         .unwrap();

//     let result = [oracle_one.account_id(), ", false".to_string()].join("");

//     assert_eq!(result, oracle_removed_event_log);
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1067
//  */

// #[test]

// fn removing_oracles_and_removes_the_address_in_get_oracles() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let mut n = 0;

//     while n < oracles.len() {
//         assert_ne!(oracles[n], oracle_one.account_id());
//         n += 1;
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1081
//  */

// #[test]

// fn when_the_oracle_is_not_currently_added_and_reverts() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_oracle_not_enabled = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_oracle_not_enabled
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("oracle not enabled"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1092
//  */

// #[test]
// fn when_removing_the_last_oracle_and_does_not_revert() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 0.to_string(), "_max_submissions": 0.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1101
//  */

// #[test]

// fn removing_oracles_and_when_called_by_anyone_but_the_owner_and_reverts() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_only_callable_by_owner = oracle_two.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1101
//  * **TODO** Look into why the contract is failing with round not accepting submissions and not no longer allowed oracle
//  */

// #[test]

// fn it_is_allowed_to_report_on_one_more_round() {
//     let mut next_round: u128 = 1;
//     let answer: u128 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_no_longer_allowed_oracle = oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     // *TODO* Look into why the contract is failing with round not accepting submissions and not no longer allowed oracle

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_longer_allowed_oracle
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("no longer allowed oracle"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1137
//  */

// #[test]

// fn it_is_allowed_to_finish_that_round_and_one_more_round() {
//     let mut next_round: u128 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     let expected_no_longer_allowed_oracle = oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     // *TODO* Look into why the contract is allowing oracle_three to future in participate in future rounds
//     // cannot participate in future rounds

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_longer_allowed_oracle
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("no longer allowed oracle"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1147
//  */

// #[test]

// fn it_reverts_when_min_submissions_is_set_to_0() {

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_min_must_be_greater_than_0 = root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 0.to_string(), "_max_submissions": 0.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_min_must_be_greater_than_0
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("min must be greater than 0"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1161
//  */

// #[test]

// fn can_swap_out_oracles() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let mut n = 0;

//     while n < oracles.len() {
//         assert_ne!(oracles[n], oracle_three.account_id());
//         if oracles[n] == oracle_two.account_id() {
//             assert_eq!(oracles[n] == oracle_two.account_id(), true);
//         }
//         n += 1;
//     }

//     n = 0;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_two.account_id()], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles_second: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     while n < oracles_second.len() {
//         assert_ne!(oracles_second[n], oracle_two.account_id());
//         if oracles_second[n] == oracle_three.account_id() {
//             assert_eq!(oracles_second[n] == oracle_three.account_id(), true);
//         }
//         n += 1;
//     }
// }

// /**
//  * #removing_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1033
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1180
//  * *TODO* Look into why the contract is panicking when removing and adding an oracle at the same time, not intended functionality. (oracle already enabled)
//  */

// #[test]

// fn it_is_possible_to_remove_and_add_the_same_address() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     let mut n = 0;

//     while n < oracles.len() {
//         if oracles[n] == oracle_two.account_id() {
//             assert_eq!(oracles[n] == oracle_two.account_id(), true);
//         }
//         n += 1;
//     }
//     n = 0;

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_two.account_id()], "_added": [oracle_two.account_id()], "_added_admins": [oracle_two.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles_second: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     // *TODO* Look into why the contract is panicking when removing and adding an oracle at the same time, not intended functionality. (oracle already enabled)

//     while n < oracles_second.len() {
//         if oracles_second[n] == oracle_two.account_id() {
//             assert_eq!(oracles_second[n] == oracle_two.account_id(), true);
//         }
//         n += 1;
//     }
// }

// /**
//  * #get_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1199
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1207
//  */

// #[test]

// fn returns_the_addresses_of_addded_oracles() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//         .view(
//             flux_aggregator.account_id(),
//             "get_oracles",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(oracles[0], oracle_one.account_id());

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_two.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let mut n = 0;

//     let oracles_second: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     while n < oracles_second.len() {
//         if oracles_second[n] == oracle_two.account_id() {
//             assert_eq!(oracles_second[n] == oracle_two.account_id(), true);
//         }
//         if oracles_second[n] == oracle_one.account_id() {
//             assert_eq!(oracles_second[n] == oracle_one.account_id(), true);
//         }
//         n += 1;
//     }

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let mut n = 0;

//     let oracles_third: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     while n < oracles_third.len() {
//         if oracles_third[n] == oracle_two.account_id() {
//             assert_eq!(oracles_third[n] == oracle_two.account_id(), true);
//         }
//         if oracles_third[n] == oracle_one.account_id() {
//             assert_eq!(oracles_third[n] == oracle_one.account_id(), true);
//         }
//         if oracles_third[n] == oracle_three.account_id() {
//             assert_eq!(oracles_third[n] == oracle_three.account_id(), true);
//         }
//         n += 1;
//     }
// }

// /**
//  * #get_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1199
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1233
//  */

// #[test]

// fn reorders_when_removing_from_the_beginning() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles[0], oracle_one.account_id());
//     assert_eq!(oracles[1], oracle_two.account_id());
//     assert_eq!(oracles[2], oracle_three.account_id());

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles_second: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles_second[0], oracle_three.account_id());
//     assert_eq!(oracles_second[1], oracle_two.account_id());

// }

// /**
//  * #get_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1199
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1243
//  */

// #[test]

// fn reorders_when_removing_from_the_middle() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles[0], oracle_one.account_id());
//     assert_eq!(oracles[1], oracle_two.account_id());
//     assert_eq!(oracles[2], oracle_three.account_id());

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_two.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles_second: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles_second[0], oracle_one.account_id());
//     assert_eq!(oracles_second[1], oracle_three.account_id());

// }

// /**
//  * #get_oracles - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1199
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1253
//  */

// #[test]

// fn pops_the_last_node_off_at_the_end() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles[0], oracle_one.account_id());
//     assert_eq!(oracles[1], oracle_two.account_id());
//     assert_eq!(oracles[2], oracle_three.account_id());

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_three.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let oracles_second: Vec<String> = root
//     .view(
//         flux_aggregator.account_id(),
//         "get_oracles",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(oracles_second[0], oracle_one.account_id());
//     assert_eq!(oracles_second[1], oracle_two.account_id());

// }

// /**
//  * #withdraw_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1265
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1266
//  */

// #[test]

// fn withdraw_funds_and_succeeds() {
//     let deposit: u64 = 100;
//     let (
//         root,
//         _aca,
//         link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     // Carol

//     root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": deposit.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, 
//     ).assert_success();

//     let available_funds: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0,
//         )
//         .unwrap_json();

//     assert_eq!(0, available_funds);

//     let balance: U128 = root
//         .call(
//             link.account_id(),
//             "ft_balance_of",
//             &json!({"account_id":  test_helper.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(u128::from(balance), 100);
// }

// /**
//  * #withdraw_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1265
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1273
//  */

// #[test]

// fn does_not_let_withdrawls_happen_multiple_times() {
//     let deposit: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": deposit.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let expected_insufficient_reserve_funds = root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": deposit.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//         if let ExecutionStatus::Failure(execution_error) = &expected_insufficient_reserve_funds
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("insufficient reserve funds"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #withdraw_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1265
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1289
//  */

// #[test]

// fn with_a_number_higher_than_the_available_link_balance_and_fails() {
//     let deposit: u64 = 100;
//     let answer: u128 = 100;
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let next_round: u128 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_insufficient_reserve_funds = root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": deposit.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_insufficient_reserve_funds
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("insufficient reserve funds"));
//     } else {
//         unreachable!();
//     }

//     let available_funds: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(97, available_funds);
// }

// /**
//  * #withdraw_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1265
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1307
//  */

// #[test]

// fn does_not_allow_withdrawal_with_less_than_2x_rounds_of_payments() {
//     let allowed: u128 = 82;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let available_funds: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(100, available_funds);

//     let expected_insufficient_reserve_funds = root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": (allowed + 1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_insufficient_reserve_funds
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("insufficient reserve funds"));
//     } else {
//         unreachable!();
//     }

//     root.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": allowed.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
// }

// /**
//  * #withdraw_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1265
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1323
//  */

// #[test]

// fn when_called_by_a_non_owner_and_fails() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let expected_only_callable_by_owner = eddy.call(
//         flux_aggregator.account_id(),
//         "withdraw_funds",
//         &json!({"_recipient": test_helper.account_id().to_string(), "_amount": 100.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }

//     let available_funds: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(100, available_funds);
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1352
//  */

// #[test]

// fn updates_the_min_and_max_answer_counts() {
//     let rr_delay: u64 = 0;
//     let new_delay: u64 = 2;
//     let new_min: u64 = 1;
//     let new_max: u64 = 3;
//     let new_payment_amount: u64 = 2;
//     let mut min_submission_count: u64 = 3;
//     let mut max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let mut expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let mut expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let mut expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": new_payment_amount.to_string(), "_min_submissions": new_min.to_string(), "_max_submissions": new_max.to_string(), "_restart_delay": new_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_restart_delay: u64 = root
//     .call(
//         flux_aggregator.account_id(),
//         "restart_delay",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     expected_payment_amount = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     expected_min_submission_count = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     expected_max_submission_count = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, new_payment_amount);
//     assert_eq!(expected_min_submission_count, new_min);
//     assert_eq!(expected_max_submission_count, new_max);
//     assert_eq!(expected_restart_delay, new_delay);
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1352
//  * *TODO* Try to implement a more type heavy assertion from the log instead of comparing strings
//  */

// #[test]

// fn emits_a_log_announcing_the_new_round_details() {
//     let rr_delay: u64 = 0;
//     let new_delay: u64 = 2;
//     let new_min: u64 = 1;
//     let new_max: u64 = 3;
//     let new_payment_amount: u64 = 2;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;

//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": new_payment_amount.to_string(), "_min_submissions": new_min.to_string(), "_max_submissions": new_max.to_string(), "_restart_delay": new_delay.to_string(), "_timeout": (timeout + 1).to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     // let expected_min_submission_count_log: u64 =
//     //     receipt.promise_results().remove(1).unwrap().outcome().logs[1]
//     //         .parse()
//     //         .unwrap();
//     // let expected_max_submission_count_log: u64 =
//     //     receipt.promise_results().remove(1).unwrap().outcome().logs[2]
//     //         .parse()
//     //         .unwrap();
//     // let expected_restart_delay_log: u64 =
//     //     receipt.promise_results().remove(1).unwrap().outcome().logs[3]
//     //         .parse()
//     //         .unwrap();
//     // let expected_timeout_log: u64 = receipt.promise_results().remove(1).unwrap().outcome().logs[4]
//     //     .parse()
//     //     .unwrap();

//     assert_eq!(receipt.promise_results().remove(1).unwrap().outcome().logs[0], "2, 1, 3, 2, 1801");

//     // assert_eq!(expected_min_submission_count_log, new_min);
//     // assert_eq!(expected_max_submission_count_log, new_max);
//     // assert_eq!(expected_restart_delay_log, new_min);
//     // assert_eq!(expected_timeout_log, (timeout + 1));
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1381
//  */

// #[test]

// fn when_it_is_set_to_higher_than_the_number_or_oracles_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let expected_max_cannot_exceed_total = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": min_submission_count.to_string(), "_max_submissions": 4.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_max_cannot_exceed_total
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("max cannot exceed total"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1392
//  */

// #[test]

// fn when_it_is_sets_the_min_higher_than_the_max_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let expected_max_must_equal_exceed_min = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 3.to_string(), "_max_submissions": 2.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_max_must_equal_exceed_min
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("max must equal/exceed min"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1404
//  */

// #[test]

// fn when_delay_equal_or_greater_the_oracle_count_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let expected_revert_delay_cannot_exceed_total = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": 3.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_revert_delay_cannot_exceed_total
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("revert delay cannot exceed total"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1417
//  * *TODO* Look into why you cannot pass a decimal number into the update_future_rounds payment_amount
//  */

// #[test]

// fn when_the_payment_amount_does_not_cover_reserve_rounds_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);
    
//     // *TODO* Look into why you cannot pass a decimal number into the update_future_rounds payment_amount (17.67)

//     let expected_insufficient_funds_for_payment = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": "18", "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_insufficient_funds_for_payment
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("insufficient funds for payment"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1434
//  */

// #[test]

// fn min_oracles_is_set_to_0_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let expected_min_must_be_greater_than_0 = root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": 0.to_string(), "_max_submissions": 0.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_min_must_be_greater_than_0
//     .promise_errors()
//     .remove(0)
//     .unwrap()
//     .outcome()
//     .status
// {
//     assert!(execution_error
//         .to_string()
//         .contains("min must be greater than 0"));
// } else {
//     unreachable!();
// }
// }

// /**
//  * #update_future_rounds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1334
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1434
//  * *TODO* Look into why the self.only_owner() function breaks the contract in update_future_rounds
//  */

// #[test]

// fn update_future_rounds_and_when_called_by_anyone_but_the_owner_and_reverts() {
//     let rr_delay: u64 = 0;
//     let min_submission_count: u64 = 3;
//     let max_submission_count: u64 = 3;
//     let payment_amount: u64 = 3;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected_payment_amount: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_payment_amount",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_min_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "min_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_max_submission_count: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "max_submission_count",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(expected_payment_amount, payment_amount);
//     assert_eq!(expected_min_submission_count, min_submission_count);
//     assert_eq!(expected_max_submission_count, max_submission_count);

//     let expected_only_callable_by_owner = oracle_two.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": payment_amount.to_string(), "_min_submissions": min_submission_count.to_string(), "_max_submissions": max_submission_count.to_string(), "_restart_delay": rr_delay.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//     .promise_errors()
//     .remove(0)
//     .unwrap()
//     .outcome()
//     .status
// {
//     assert!(execution_error
//         .to_string()
//         .contains("Only callable by owner"));
// } else {
//     unreachable!();
// }
// }

// /**
//  * #update_available_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1449
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1450
//  */

// #[test]

// fn checks_the_link_token_to_see_if_any_additional_funds_are_available() {
//     let deposit: u64 = 100;
//     let (
//         root,
//         _aca,
//         link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let original_balance: u64 = root
//     .view(
//         flux_aggregator.account_id(),
//         "available_funds",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let original_balance_updated: u64 = root
//     .view(
//         flux_aggregator.account_id(),
//         "available_funds",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!(original_balance, original_balance_updated);

//     root.call(
//         link.account_id(),
//         "ft_transfer",
//         &json!({
//             "receiver_id": flux_aggregator.account_id(), "amount": deposit.to_string(), "memo": "None"
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         1, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let new_balance: u64 = root
//     .view(
//         flux_aggregator.account_id(),
//         "available_funds",
//         &json!({}).to_string().into_bytes(),
//     )
//     .unwrap_json();

//     assert_eq!((original_balance + deposit), new_balance);

// }

// /**
//  * #update_available_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1449
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1464
//  */

// #[test]

// fn removes_allocated_funds_from_the_available_balance() {
//     let deposit: u64 = 100;
//     let (
//         root,
//         _aca,
//         link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let original_balance: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": 100.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//             link.account_id(),
//             "ft_transfer",
//             &json!({
//                 "receiver_id": flux_aggregator.account_id(), "amount": deposit.to_string(), "memo": "None"
//             })
//             .to_string()
//             .into_bytes(),
//             DEFAULT_GAS,
//             1, // deposit
//         )
//         .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let expected: u64 = (original_balance + deposit) - 3;
//     let new_balance: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(expected, new_balance);
// }

// /**
//  * #update_available_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1449
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1464
//  * **TODO** Figure out how to assert a failure here
//  */

// #[test]

// fn update_available_funds_and_emits_a_log() {
//     let deposit: u64 = 100;
//     let (
//         root,
//         _aca,
//         link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         link.account_id(),
//         "ft_transfer",
//         &json!({
//             "receiver_id": flux_aggregator.account_id(), "amount": deposit.to_string(), "memo": "None"
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         1, // deposit
//     )
//     .assert_success();

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     let expected: u64 = receipt.promise_results().remove(5).unwrap().outcome().logs[0]
//         .parse::<u64>()
//         .unwrap();

//     let new_balance: u64 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(new_balance, expected);
// }

// /**
//  * #update_available_funds - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1449
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1464
//  */

// #[test]

// fn when_the_available_funds_have_not_changed_does_not_emit_a_log() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     // *TODO* Figure out how to assert a failure here.
//     assert_eq!(receipt.logs().len(), 0);
// }

// /**
//  * #withdraw_payment - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1497
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1503
//  */

// #[test]

// fn transfers_link_to_the_recipient() {
//     let payment_amount: u64 = 3;
//     let (
//         root,
//         _aca,
//         link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": 100.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let original_balance: U128 = root
//         .call(
//             link.account_id(),
//             "ft_balance_of",
//             &json!({"account_id": flux_aggregator.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let original_oracle_one_balance: U128 = root
//         .call(
//             link.account_id(),
//             "ft_balance_of",
//             &json!({"account_id": oracle_one.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(0, u128::from(original_oracle_one_balance));

//     oracle_one
//     .call(
//         flux_aggregator.account_id(),
//         "withdraw_payment",
//         &json!({"_oracle": oracle_one.account_id().to_string(), "_recipient": oracle_one.account_id().to_string(), "_amount": payment_amount.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         1, // deposit
//     )
//     .assert_success();

//     let updated_balance: U128 = root
//         .call(
//             link.account_id(),
//             "ft_balance_of",
//             &json!({"account_id": flux_aggregator.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(97, u128::from(updated_balance));

//     let updated_oracle_one_balance: U128 = root
//         .call(
//             link.account_id(),
//             "ft_balance_of",
//             &json!({"account_id": oracle_one.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(3, u128::from(updated_oracle_one_balance));
// }

// /**
//  * #withdraw_payment - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1497
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1515
//  */

// #[test]

// fn decrements_the_allocated_funds_counter() {
//     let payment_amount: u128 = 3;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": 100.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let original_allocation: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     oracle_one
//     .call(
//         flux_aggregator.account_id(),
//         "withdraw_payment",
//         &json!({"_oracle": oracle_one.account_id().to_string(), "_recipient": oracle_one.account_id().to_string(), "_amount": payment_amount.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let updated_allocation: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "allocated_funds",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!((original_allocation - payment_amount), updated_allocation);
// }

// /**
//  * #withdraw_payment - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1497
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1526
//  */

// #[test]

// fn when_the_caller_withdraws_more_than_they_have_and_reverts() {
//     let payment_amount: u128 = 3;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": 100.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_revert_insufficient_withdrawable_funds = oracle_one
//     .call(
//         flux_aggregator.account_id(),
//         "withdraw_payment",
//         &json!({"_oracle": oracle_one.account_id().to_string(), "_recipient": oracle_one.account_id().to_string(), "_amount": (payment_amount + 1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &expected_revert_insufficient_withdrawable_funds
//             .promise_errors()
//             .remove(0)
//             .unwrap()
//             .outcome()
//             .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("revert insufficient withdrawable funds"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #withdraw_payment - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1497
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1540
//  */

// #[test]

// fn when_the_caller_is_not_the_admin_and_reverts() {
//     let payment_amount: u128 = 3;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": 1.to_string(), "_submission": 100.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_only_callable_by_admin = oracle_three
//     .call(
//         flux_aggregator.account_id(),
//         "withdraw_payment",
//         &json!({"_oracle": oracle_one.account_id().to_string(), "_recipient": oracle_three.account_id().to_string(), "_amount": 1.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_admin
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("only callable by admin"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #transfer_admin - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1552
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1567
//  */

// #[test]

// fn when_the_admin_tries_to_transfer_the_admin_and_works() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let receipt = oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "transfer_admin",
//             &json!({"_oracle": oracle_two.account_id().to_string(), "_new_admin": oracle_three.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     assert_eq!(
//         "oracle_two, oracle_one, oracle_three",
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//     );

//     let get_admin: String = oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "get_admin",
//             &json!({"_oracle": oracle_two.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(oracle_one.account_id(), get_admin);
// }

// /**
//  * #transfer_admin - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1552
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1584
//  */

// #[test]

// fn when_the_non_admin_owner_tries_to_update_the_admin_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_only_callable_by_admin = root.call(
//         flux_aggregator.account_id(),
//         "transfer_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string(), "_new_admin": oracle_three.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_admin
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("revert only callable by admin"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #transfer_admin - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1552
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1595
//  */

// #[test]

// fn when_the_non_admin_oracle_tries_to_update_the_admin_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_only_callable_by_admin = oracle_two.call(
//         flux_aggregator.account_id(),
//         "transfer_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string(), "_new_admin": oracle_three.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_admin
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("revert only callable by admin"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #accept_admin - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1606
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1624
//  */

// #[test]

// fn when_the_new_admin_tries_to_accept_and_works() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "transfer_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string(), "_new_admin": oracle_three.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let receipt = oracle_three.call(
//         flux_aggregator.account_id(),
//         "accept_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(
//         "oracle_two, oracle_three",
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//     );

//     let get_admin: String = oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "get_admin",
//             &json!({"_oracle": oracle_two.account_id().to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(oracle_three.account_id(), get_admin);
// }

// /**
//  * #accept_admin - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1606
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1634
//  */

// #[test]

// fn when_someone_other_than_the_admin_tries_to_accept_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_two.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "transfer_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string(), "_new_admin": oracle_three.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_only_callable_by_pending_admin = oracle_two.call(
//         flux_aggregator.account_id(),
//         "accept_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_pending_admin
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("only callable by pending admin"));
//     } else {
//         unreachable!();
//     }

//     let expected_only_callable_by_pending_admin_second = oracle_one.call(
//         flux_aggregator.account_id(),
//         "accept_admin",
//         &json!({"_oracle": oracle_two.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) =
//         &expected_only_callable_by_pending_admin_second
//             .promise_errors()
//             .remove(0)
//             .unwrap()
//             .outcome()
//             .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("only callable by pending admin"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #on_token_transfer (ft_on_transfer) - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1647
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1648
//  */

// #[test]

// fn updates_the_available_balance() {
//     let (
//         root,
//         _aca,
//         link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let original_balance: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_available_funds",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0,
//     )
//     .assert_success();

//     let updated_balance: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(original_balance, updated_balance);

//     let prom = root.call(
//         link.account_id(),
//         "ft_transfer_call",
//         &json!({
//             "receiver_id": flux_aggregator.account_id(), "amount": 100.to_string(), "memo": "None", "msg": "".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         1
//     );

//     println!("{:?}", prom.promise_results());

//     let new_balance: u128 = root
//         .view(
//             flux_aggregator.account_id(),
//             "available_funds",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(200, new_balance);
// }

// /**
//  * #on_token_transfer (ft_on_transfer) - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1647
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1661
//  */

// #[test]

// fn reverts_given_calldata() {
//     let (
//         root,
//         _aca,
//         link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let prom = root.call(
//         link.account_id(),
//         "ft_transfer_call",
//         &json!({
//             "receiver_id": flux_aggregator.account_id(), "amount": 100.to_string(), "memo": "None", "msg": "12345678".to_string()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS,
//         1
//     );

//     println!("{:?}", prom.promise_results());
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1679
//  */

// #[test]

// fn announces_a_new_round_via_log_event() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;
//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(
//         "2, root, 161000000000",
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//     );
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1683
//  */

// #[test]

// fn returns_the_new_round_id() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;
//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": flux_aggregator_test_helper_contract.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let mut round_id: u64 = root
//         .view(
//             flux_aggregator_test_helper_contract.account_id(),
//             "requested_round_id",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(round_id, 0);

//     root.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "request_new_round",
//         &json!({"_aggregator": flux_aggregator.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     round_id = root
//         .view(
//             flux_aggregator_test_helper_contract.account_id(),
//             "requested_round_id",
//             &json!({}).to_string().into_bytes(),
//         )
//         .unwrap_json();

//     assert_eq!(round_id > 0, true);
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1701
//  */

// #[test]

// fn when_there_is_a_new_round_in_progress_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     let expected_previous_round_must_be_supersedable = root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_previous_round_must_be_supersedable
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("prev round must be supersedable"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1701
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_that_round_has_timed_out_and_starts_a_new_round() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
//     root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     // *TODO* Look into increaseTimeBy and mineBlock implementation

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1722
//  */

// #[test]

// fn when_there_is_a_restart_delay_set_and_reverts_if_a_round_is_started_before_the_delay() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": eddy.account_id().to_string(), "_authorized": true, "_delay": 1.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     eddy.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     next_round = next_round + 1;

//     // Eddy can't start because of the delay
//     let expected_must_delay_requests = eddy.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_must_delay_requests
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("must delay requests"));
//     } else {
//         unreachable!();
//     }

//     // Carol starts a new round instead
//     root.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     // round completes
//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     next_round = next_round + 1;

//     eddy.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();
// }

// /**
//  * #request_new_round - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1669
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1722
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_all_oracles_have_been_removed_and_then_re_added_and_does_not_get_stuck() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//         flux_aggregator.account_id(),
//         "set_requester_permissions",
//         &json!({"_requester": root.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .assert_success();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [oracle_one.account_id()], "_added": [], "_added_admins": [], "_min_submissions": 0.to_string(), "_max_submissions": 0.to_string(), "_restart_delay": 0.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // *TODO* Look into increaseTimeBy and mineBlock functions
//     // advance a few rounds
//     // for (let i = 0; i < 7; i++) {
//     //     await aggregator.requestNewRound();
//     //     nextRound = nextRound + 1;
//     //     await increaseTimeBy(timeout + 1, ethers.provider);
//     //     await mineBlock(ethers.provider);
//     //   }

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // round completes
//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1769
//  */

// #[test]

// fn when_called_by_the_owner_and_allows_the_specified_address_to_start_new_rounds() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "request_new_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1775
//  */

// #[test]

// fn emits_a_log_announcing_the_update() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     let receipt = root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     assert_eq!(
//         "oracle_one, true, 0",
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//     );
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1786
//  */

// #[test]

// fn when_the_address_is_already_authorized_and_does_not_emit_a_log_for_already_authorized_accounts()
// {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     let receipt = root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     assert_eq!(0, receipt.logs().len());
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1798
//  */

// #[test]

// fn when_permission_is_removed_by_the_owner_and_does_not_allow_the_specified_address_to_start_new_rounds(
// ) {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": false, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     let expected_not_authorized_requester = oracle_one.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_authorized_requester
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("not authorized requester"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1804
//  */

// #[test]

// fn when_permission_is_removed_by_the_owner_and_emits_a_log_announcing_the_update() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     let receipt = root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": false, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     assert_eq!(
//         "oracle_one, false, 0",
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0]
//     );
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1810
//  * *TODO* Look into why a log is still being emitted, looks as though it's still emitting in the Solidity code as well
//  */

// #[test]

// fn does_not_emit_a_log_for_accounts_without_authorization() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     let receipt = root.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_two.account_id().to_string(), "_authorized": false, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );
//     // *TODO* Look into why a log is still being emitted, looks as though it's still emitting in the Solidity code as well

//     // println!("{:?}", receipt.logs());

//     assert_eq!(0, receipt.logs().len());
// }

// /**
//  * #set_requester_permissions - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1760
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1819
//  */

// #[test]

// fn when_called_by_a_stranger_and_reverts() {
//     let min_ans: u64 = 1;
//     let max_ans: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u64 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id()], "_added_admins": [oracle_one.account_id()], "_min_submissions": min_ans.to_string(), "_max_submissions": max_ans.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let expected_only_callable_by_owner = oracle_one.call(
//             flux_aggregator.account_id(),
//             "set_requester_permissions",
//             &json!({"_requester": oracle_one.account_id().to_string(), "_authorized": true, "_delay": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }

//     let expected_not_authorized_requester = oracle_one.call(
//         flux_aggregator.account_id(),
//         "request_new_round",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_not_authorized_requester
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("not authorized requester"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1850
//  * *TODO* Look into why the started_at is being set, it should not be set
//  */

// #[test]

// fn when_round_id_0_is_passed_in_and_returns_all_of_the_important_round_information() {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let base_funds: u128 = 88;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, previous_submission);

//     // *TODO* Look into why the started_at is being set, it should not be set

//     // assert_eq!(state.3, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, base_funds);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1865
//  */

// #[test]

// fn when_round_id_0_is_passed_in_reverts_if_called_by_a_contract() {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     let expected_off_chain_reading_only = root.call(
//         flux_aggregator_test_helper_contract.account_id(),
//         "read_oracle_round_state",
//         &json!({"_aggregator": flux_aggregator.account_id(), "_oracle": oracle_one.account_id()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_off_chain_reading_only
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("off-chain reading only"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1887
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_less_than_min_submissions_and_oracle_not_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 85);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1908
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_less_than_min_submissions_and_oracle_included_and_is_not_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 85);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1908
//  *  *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_less_than_min_submissions_and_oracle_included_and_is_eligible_to_submit_and_timed_out_is_eligible_to_submit(
// ) {
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1951
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_not_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();
//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
//     // advanceRound

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 79);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1972
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//             flux_aggregator.account_id(),
//             "change_oracles",
//             &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     // advanceRound

//     oracle_three.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     oracle_two.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     oracle_one.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     oracle_four.call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
//     // advanceRound

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 79);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1993
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_included_and_timed_out_is_eligible_to_submit(
// ) {
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2017
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_max_submissions_and_oracle_not_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
//     // advanceRound

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_five
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, 76);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2040
//  */

// #[test]

// fn when_the_restart_delay_is_not_enforced_and_max_submissions_and_oracle_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": 0.to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();
//     // advanceRound

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, 76);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2071
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_less_than_min_submissions_and_oracle_not_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 82);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2092
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_less_than_min_submissions_and_oracle_included_and_is_not_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 82);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2092
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_less_than_min_submissions_and_oracle_included_and_is_eligible_to_submit_and_timed_out_is_eligible_to_submit(
// ) {
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2135
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_not_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 79);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2156
//  * *TODO* Look into why timeout is not 0.
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_included_and_is_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     // *TODO* Look into why timeout is not 0.
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 79);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2177
//  * *TODO* Look into increaseTimeBy and mineBlock implementation
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_greater_than_or_equal_to_min_submissions_and_oracle_included_and_timed_out_is_eligible_to_submit(
// ) {
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2201
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_max_submissions_and_oracle_not_included_and_is_not_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_five
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, previous_submission);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, 76);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2224
//  */

// #[test]

// fn when_the_restart_delay_is_enforced_and_max_submissions_and_oracle_included_and_is_not_eligible_to_submit(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         oracle_four,
//         oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id(), oracle_four.account_id(), oracle_five.account_id()], "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     // advanceRound

//     oracle_three.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_two.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_four.call(
//         flux_aggregator.account_id(),
//         "submit",
//         &json!({"_round_id": next_round.to_string(), "_submission": previous_submission.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     next_round = next_round + 1;

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     root.call(
//         flux_aggregator.account_id(),
//         "update_future_rounds",
//         &json!({"_payment_amount": 3.to_string(), "_min_submissions": min_answers.to_string(), "_max_submissions": max_answers.to_string(), "_restart_delay": (max_answers - 1).to_string(), "_timeout": timeout.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_four
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 3);
//     assert_eq!(state.2, answer);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, 76);
//     assert_eq!(state.6, 5);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2259
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_returns_info_about_previous_rounds() {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let current_funds: u128 = 73;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();
//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 1.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 1);
//     assert_eq!(state.2, answers[3]);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, current_funds);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 0);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2274
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_returns_info_about_previous_rounds_that_were_not_submitted_to(
// ) {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 2.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 2);
//     assert_eq!(state.2, answers[3]);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, current_funds);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2291
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_for_the_current_round_which_has_not_been_submitted_to_and_returns_info_about_the_current_round_that_hasnt_been_submitted_to(
// ) {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 4.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 4);
//     assert_eq!(state.2, answers[3]);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, current_funds);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2306
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_for_the_current_round_which_has_not_been_submitted_to_and_returns_info_about_the_subsequent_round(
// ) {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 5.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 5);
//     assert_eq!(state.2, answers[3]);
//     assert_eq!(state.3 <= 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, current_funds);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2327
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_for_the_current_round_which_has_been_submitted_to_and_returns_info_about_the_current_round_that_hasnt_been_submitted_to(
// ) {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 4.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 4);
//     assert_eq!(state.2, answers[4]);
//     assert_eq!(state.3 > 0, true);
//     assert_eq!(state.4, timeout);
//     assert_eq!(state.5, 70);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2342
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_for_the_current_round_which_has_been_submitted_to_and_returns_info_about_the_subsequent_round(
// ) {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 5.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, true);
//     assert_eq!(state.1, 5);
//     assert_eq!(state.2, answers[4]);
//     assert_eq!(state.3 <= 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, 70);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #oracle_round_state - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L1830
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2359
//  */

// #[test]

// fn when_non_zero_round_id_0_is_passed_in_and_returns_speculative_info_about_future_rounds() {
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answers: Vec<u128> = [0, 42, 47, 52, 57].to_vec();
//     let current_funds: u128 = 73;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_added_admins": [oracle_one.account_id(), oracle_two.account_id(), oracle_three.account_id()], "_min_submissions": 2.to_string(), "_max_submissions": 3.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let starting_state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//     .call(
//         flux_aggregator.account_id(),
//         "oracle_round_state",
//         &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 0.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     )
//     .unwrap_json();

//     // advanceRound * 4 (1)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[1].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (2)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[2].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (3)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_two
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[3].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     next_round = next_round + 1;

//     // advanceRound * 4 (4)

//     oracle_one
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answers[4].to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let state: (bool, u64, u128, u64, u64, u128, u64, u128) = root
//         .call(
//             flux_aggregator.account_id(),
//             "oracle_round_state",
//             &json!({"_oracle": oracle_three.account_id().to_string(), "_queried_round_id": 6.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     println!(
//         "{:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}",
//         state.0, state.1, state.2, state.3, state.4, state.5, state.6, state.7
//     );

//     assert_eq!(state.0, false);
//     assert_eq!(state.1, 6);
//     assert_eq!(state.2, answers[3]);
//     assert_eq!(state.3 <= 0, true);
//     assert_eq!(state.4, 0);
//     assert_eq!(state.5, current_funds);
//     assert_eq!(state.6, 3);
//     assert_eq!(state.7, 3);
// }

// /**
//  * #get_round_data - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2376
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2386
//  * *TODO* Find current time and make sure its above upatedAt
//  */

// #[test]

// fn get_round_data_and_returns_relevant_information() {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let latest_round_id: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let latest_round_id: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let round: (u64, u128, u64, u64, u64) = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_round_data",
//             &json!({"_round_id": latest_round_id.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(latest_round_id, round.0);
//     assert_eq!(answer, round.1);

//     // const nowSeconds = new Date().valueOf() / 1000;
//     // assert.isAbove(round.updatedAt.toNumber(), nowSeconds - 120);
//     // *TODO* Find current time and make sure its above upatedAt

//     assert_eq!(round.2, round.3);
//     assert_eq!(latest_round_id, round.4);
// }

// /**
//  * #get_round_data - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2376
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2396
//  */

// #[test]

// fn get_round_data_and_reverts_if_a_round_is_not_present() {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let latest_round_id: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let latest_round_id: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": (latest_round_id + 1).to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("No data present"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #get_round_data - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2376
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2396
//  * *TODO* Calculate math for overflowed u64 integer
//  */

// #[test]

// fn get_round_data_and_reverts_if_a_round_ID_is_too_big() {
//     let previous_submission: u128 = 42;
//     let min_answers: u64 = 3;
//     let max_answers: u64 = 4;
//     let latest_round_id: u64 = 1;
//     let rr_delay: u64 = 0;
//     let mut next_round: u64 = 1;
//     let answer: u128 = 100;
//     let current_funds: u128 = 73;
//     let timeout: u64 = 1800;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let latest_round_id: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     // // *TODO* Calculate math for overflowed u64 integer

//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "get_round_data",
//         &json!({"_round_id": 100.to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #latest_round_data - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2407
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2419
//  * *TODO* Find current time and make sure its above upatedAt
//  */

// #[test]

// fn latest_round_data_when_an_answer_has_been_received_and_returns_the_relevant_round_info_without_reverting(
// ) {
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let answer: u128 = 100;

//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let round: (u64, u128, u64, u64, u64) = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round_data",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     let latest_round_id: u64 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_round",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(latest_round_id, round.0);
//     assert_eq!(answer, round.1);

//     // const nowSeconds = new Date().valueOf() / 1000;
//     // assert.isAbove(round.updatedAt.toNumber(), nowSeconds - 120);
//     // *TODO* Find current time and make sure its above upatedAt

//     assert_eq!(round.2, round.3);
//     assert_eq!(latest_round_id, round.4);
// }

// /**
//  * #latest_round_data - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2407
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2432
//  */

// #[test]

// fn latest_round_data_when_an_answer_has_been_received_and_reverts_if_a_round_is_not_present() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let expected_no_data_present = root.call(
//         flux_aggregator.account_id(),
//         "latest_round_data",
//         &json!({}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_no_data_present
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error.to_string().contains("No data present"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * #latest_answer - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2437
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2449
//  */

// #[test]

// fn latest_answer_when_an_answer_has_already_been_received_and_returns_the_latest_answer_without_reverting(
// ) {
//     let rr_delay: u64 = 0;
//     let next_round: u64 = 1;
//     let answer: u128 = 100;
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     oracle_three
//         .call(
//             flux_aggregator.account_id(),
//             "submit",
//             &json!({"_round_id": next_round.to_string(), "_submission": answer.to_string()})
//                 .to_string()
//                 .into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .assert_success();

//     let latest_answer: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();
//     assert_eq!(answer, latest_answer);
// }

// /**
//  * #latest_answer - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2437
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2454
//  */

// #[test]

// fn latest_answer_and_returns_zero() {
//     let rr_delay: u64 = 0;
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         _aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     root.call(
//         flux_aggregator.account_id(),
//         "change_oracles",
//         &json!({"_removed": [], "_added": [oracle_three.account_id()], "_added_admins": [oracle_three.account_id()], "_min_submissions": 1.to_string(), "_max_submissions": 1.to_string(), "_restart_delay": rr_delay.to_string()}).to_string().into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     ).assert_success();

//     let latest_answer: u128 = root
//         .call(
//             flux_aggregator.account_id(),
//             "latest_answer",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!(0, latest_answer);
// }

// /**
//  * #set_validator - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2459
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2465
//  */

// #[test]

// fn set_validator_and_emits_a_log_event_showing_the_validator_was_changed() {
//     let (
//         root,
//         _aca,
//         _link,
//         _oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let empty_address: String = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_validator",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!("", empty_address);

//     let receipt = root.call(
//         flux_aggregator.account_id(),
//         "set_validator",
//         &json!({"_new_validator": aggregator_validator_mock.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(
//         receipt.promise_results().remove(1).unwrap().outcome().logs[0],
//         ", aggregator_validator_mock"
//     );

//     let receipt_two = root.call(
//         flux_aggregator.account_id(),
//         "set_validator",
//         &json!({"_new_validator": aggregator_validator_mock.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     assert_eq!(receipt_two.logs().len(), 0);
// }

// /**
//  * #set_validator - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2459
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2479
//  */

// #[test]

// fn set_validator_and_when_called_by_a_non_owner_and_reverts() {
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         _controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let empty_address: String = root
//         .call(
//             flux_aggregator.account_id(),
//             "get_validator",
//             &json!({}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!("", empty_address);

//     let expected_only_callable_by_owner = oracle_one.call(
//         flux_aggregator.account_id(),
//         "set_validator",
//         &json!({"_new_validator": aggregator_validator_mock.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }

// /**
//  * integrating with historic deviation checker - https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2485
//  * https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/FluxAggregator.test.ts#L2504
//  */

// #[test]

// fn raises_a_flag_on_with_high_enough_deviation() {
//     let flagging_threshold: u128 = 1000;
//     let (
//         root,
//         _aca,
//         _link,
//         oracle_one,
//         _oracle_two,
//         _oracle_three,
//         _test_helper,
//         _eac,
//         _eac_without_access_controller,
//         _oracle_four,
//         _oracle_five,
//         aggregator_validator_mock,
//         _flags,
//         _consumer,
//         _flags_consumer,
//         controller,
//         _controller_2,
//         _flux_aggregator_test_helper_contract,
//         _eddy,
//         _mock_v3_aggregator,
//         _mock_v3_aggregator_second,
//         _read_controller,
//         flux_aggregator,
//     ) = init();

//     let empty_address: String = root
//         .call(
//             controller.account_id(),
//             "add_access",
//             &json!({"_user": aggregator_validator_mock.account_id()}).to_string().into_bytes(),
//             DEFAULT_GAS,
//             0, // deposit
//         )
//         .unwrap_json();

//     assert_eq!("", empty_address);

//     let expected_only_callable_by_owner = oracle_one.call(
//         flux_aggregator.account_id(),
//         "set_validator",
//         &json!({"_new_validator": aggregator_validator_mock.account_id().to_string()})
//             .to_string()
//             .into_bytes(),
//         DEFAULT_GAS,
//         0, // deposit
//     );

//     if let ExecutionStatus::Failure(execution_error) = &expected_only_callable_by_owner
//         .promise_errors()
//         .remove(0)
//         .unwrap()
//         .outcome()
//         .status
//     {
//         assert!(execution_error
//             .to_string()
//             .contains("Only callable by owner"));
//     } else {
//         unreachable!();
//     }
// }
'''
'''--- contract-wrap/tests/sim/main.rs ---
mod flux_agg_tests;
mod flags_tests;
mod eac_tests;
mod utils;
mod aca_tests;
'''
'''--- contract-wrap/tests/sim/utils.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{init_simulator, to_yocto, UserAccount, DEFAULT_GAS};

const ACA_ID: &str = "aca";
const FLUXAGGREGATOR_ID: &str = "flux_aggregator";
const LINKTOKEN_ID: &str = "link";
const EAC_ID: &str = "eac";
const EAC_WITHOUT_ACCESS_CONTROLLER_ID: &str = "eac_without_access_controller";
const AVM_ID: &str = "aggregator_validator_mock";
const FLAGS_ID: &str = "flags";
const CONSUMER_ID: &str = "consumer";
const FLAGSTESTHELPER_ID: &str = "flags_consumer";
const SIMPLEWRITEACCESSCONTROLLER_ID: &str = "controller";
const SIMPLEWRITEACCESSCONTROLLER_ID_2: &str = "controller_2";
const SIMPLEREADACCESSCONTROLLER_ID: &str = "read_controller";
const FLUXAGGREGATORTESTHELPER_ID: &str = "flux_aggregator_test_helper_contract";
const MOCKV3AGGREGATOR_ID: &str = "mock_v3_aggregator";
const MOCKV3AGGREGATOR_ID_2: &str = "mock_v3_aggregator_2";

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    ACA_WASM_BYTES => "target/wasm32-unknown-unknown/debug/AccessControlledAggregator.wasm",
    FLUXAGGREGATOR_WASM_BYTES => "target/wasm32-unknown-unknown/debug/FluxAggregator.wasm",
    LINKTOKEN_WASM_BYTES => "target/wasm32-unknown-unknown/debug/LinkToken.wasm",
    EAC_WASM_BYTES => "target/wasm32-unknown-unknown/debug/EACAggregatorProxy.wasm",
    AVM_WASM_BYTES => "target/wasm32-unknown-unknown/debug/AggregatorVaildatorMock.wasm",
    FLAGS_WASM_BYTES => "target/wasm32-unknown-unknown/debug/Flags.wasm",
    CONSUMER_WASM_BYTES => "target/wasm32-unknown-unknown/debug/Consumer.wasm",
    SIMPLEWRITEACCESSCONTROLLER_WASM_BYTES => "target/wasm32-unknown-unknown/debug/SimpleWriteAccessController.wasm",
    SIMPLEREADACCESSCONTROLLER_WASM_BYTES => "target/wasm32-unknown-unknown/debug/SimpleReadAccessController.wasm",
    FLAGSTESTHELPER_WASM_BYTES => "target/wasm32-unknown-unknown/debug/FlagsTestHelper.wasm",
    FLUXAGGREGATORTESTHELPER_WASM_BYTES => "target/wasm32-unknown-unknown/debug/FluxAggregatorTestHelper.wasm",
    MOCKV3AGGREGATOR_WASM_BYTES => "target/wasm32-unknown-unknown/debug/MockV3Aggregator.wasm"
}

// Register the given `user` with FT contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        LINKTOKEN_ID.to_string(),
        "storage_deposit",
        &json!({
            "account_id": user.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}
/**
* TODO -> MATCH THESE
 Default: Signer;
 Carol: Signer;
 Eddy: Signer;
 Nancy: Signer;
 Ned: Signer;
 Neil: Signer;
 Nelly: Signer;
 Norbert: Signer;
*/

// https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/test/v0.6/FluxAggregator.test.ts#L251
// https://github.com/smartcontractkit/chainlink-brownie-contracts/blob/8071761a5b0e5444fc0de1751b7b398caf69ced4/contracts/test/v0.6/AccessControlledAggregator.test.ts
// Initialization and constructor tests

pub fn init_without_macros() -> (
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
    UserAccount,
) {
    // Use `None` for default genesis configuration; more info below
    // Alias: Carol
    let root = init_simulator(None);

    let link = root.deploy(
        &LINKTOKEN_WASM_BYTES,
        LINKTOKEN_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    link.call(
        LINKTOKEN_ID.into(),
        "new_default_meta",
        &json!({
            "owner_id": root.account_id().to_string(), "total_supply": "100000"
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    let aca = root.deploy(
        &ACA_WASM_BYTES,
        ACA_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    let flux_aggregator = root.deploy(
        &FLUXAGGREGATOR_WASM_BYTES,
        FLUXAGGREGATOR_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    let payment_amount: u128 = 3;
    let timeout: u64 = 1800;
    let decimals: u64 = 24;
    let description: String = "LINK/USD".to_string();
    let min_submission_value: u128 = 1;
    let max_submission_value: u128 = 100000000000000000000;
    let version: u128 = 3;
    let validator: String = "".to_string();
    let deposit: u64 = 100;

    aca.call(
        ACA_ID.into(),
        "new",
        &json!({
            "owner_id": root.account_id(),
            "link_id": link.account_id(),
            "_payment_amount": payment_amount.to_string(),
            "_timeout": timeout.to_string(),
            "_validator": validator,
            "_min_submission_value": min_submission_value.to_string(),
            "_max_submission_value": max_submission_value.to_string(),
            "_decimals": decimals.to_string(),
            "_description": description,
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    flux_aggregator
        .call(
            FLUXAGGREGATOR_ID.into(),
            "new",
            &json!({
                "owner_id": root.account_id(),
                "link_id": link.account_id(),
                "_payment_amount": payment_amount.to_string(),
                "_timeout": timeout.to_string(),
                "_validator": validator,
                "_min_submission_value": min_submission_value.to_string(),
                "_max_submission_value": max_submission_value.to_string(),
                "_decimals": decimals.to_string(),
                "_description": description,
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    register_user(&aca);
    register_user(&flux_aggregator);

    // Deployment function body as done on line 180-196 -> https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/test/v0.6/FluxAggregator.test.ts#L180 (beforeEach)
    root.call(
        link.account_id(),
        "ft_transfer",
        &json!({
            "receiver_id": aca.account_id().to_string(), "amount": deposit.to_string(), "memo": "None"
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        1
    )
    .assert_success();

    root.call(
        aca.account_id(),
        "update_available_funds",
        &json!({}).to_string().into_bytes(),
        DEFAULT_GAS,
        0,
    )
    .assert_success();

    root.call(
            link.account_id(),
            "ft_transfer",
            &json!({
                "receiver_id": flux_aggregator.account_id().to_string(), "amount": deposit.to_string(), "memo": "None"
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS,
            1
        )
        .assert_success();

    root.call(
        flux_aggregator.account_id(),
        "update_available_funds",
        &json!({}).to_string().into_bytes(),
        DEFAULT_GAS,
        0,
    )
    .assert_success();

    let aggregator_validator_mock_factory = root.deploy(
        &AVM_WASM_BYTES,
        AVM_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    aggregator_validator_mock_factory
    .call(
        AVM_ID.to_string(),
        "new",
        &json!({}).to_string().into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    // Alias: Neil
    let oracle_one = root.create_user(
        "oracle_one".to_string(),
        to_yocto("1000000"), // initial balance
    );
    // Alias: Ned
    let oracle_two = root.create_user(
        "oracle_two".to_string(),
        to_yocto("1000000"), // initial balance
    );
    // Alias: Nelly
    let oracle_three = root.create_user(
        "oracle_three".to_string(),
        to_yocto("1000000"), // initial balance
    );
    // Alias: Nancy
    let oracle_four = root.create_user(
        "oracle_four".to_string(),
        to_yocto("1000000"), // initial balance
    );
    // Alias: Norbert
    let oracle_five = root.create_user(
        "oracle_five".to_string(),
        to_yocto("1000000"), // initial balance
    );

    register_user(&oracle_one);
    register_user(&oracle_two);
    register_user(&oracle_three);
    register_user(&oracle_four);
    register_user(&oracle_five);

    let test_helper = root.create_user(
        "test_helper".to_string(),
        to_yocto("1000"), // initial balance
    );

    register_user(&test_helper);

    let eddy = root.create_user(
        "eddy".to_string(),
        to_yocto("1000"), // initial balance
    );

    let flux_aggregator_test_helper_contract = root.deploy(
        &FLUXAGGREGATORTESTHELPER_WASM_BYTES,
        FLUXAGGREGATORTESTHELPER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    flux_aggregator_test_helper_contract
        .call(
            FLUXAGGREGATORTESTHELPER_ID.into(),
            "new",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let eac_without_access_controller = root.deploy(
        &EAC_WASM_BYTES,
        EAC_WITHOUT_ACCESS_CONTROLLER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    eac_without_access_controller
        .call(
            EAC_WITHOUT_ACCESS_CONTROLLER_ID.into(),
            "new",
            &json!({
                "owner_id": eac_without_access_controller.account_id(),
                "_aggregator": aca.account_id(),
                "_access_controller": ""
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let controller = oracle_three.deploy(
        &SIMPLEWRITEACCESSCONTROLLER_WASM_BYTES,
        SIMPLEWRITEACCESSCONTROLLER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    controller
        .call(
            SIMPLEWRITEACCESSCONTROLLER_ID.into(),
            "new",
            &json!({
                "owner_id": oracle_three.account_id()
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let mock_v3_aggregator = root.deploy(
        &MOCKV3AGGREGATOR_WASM_BYTES,
        MOCKV3AGGREGATOR_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    mock_v3_aggregator
        .call(
            MOCKV3AGGREGATOR_ID.into(),
            "new",
            &json!({
                "_decimals": 18.to_string(),
                "_initial_answer": 0.to_string(),
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let mock_v3_aggregator_second = root.deploy(
        &MOCKV3AGGREGATOR_WASM_BYTES,
        MOCKV3AGGREGATOR_ID_2.to_string(),
        to_yocto("1000"), // attached deposit
    );

    // *TODO* Look into overflow issue with 54321

    mock_v3_aggregator
        .call(
            MOCKV3AGGREGATOR_ID.into(),
            "update_round_data",
            &json!({
                "_round_id": 17.to_string(),
                "_answer": 54320.to_string(),
                "_timestamp": 678.to_string(),
                "_started_at": 677.to_string()
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let eac = root.deploy(
        &EAC_WASM_BYTES,
        EAC_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    eac.call(
        EAC_ID.into(),
        "new",
        &json!({
            "owner_id": eac.account_id(),
            "_aggregator": mock_v3_aggregator.account_id(),
            "_access_controller": controller.account_id()
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    let controller_2 = oracle_three.deploy(
        &SIMPLEWRITEACCESSCONTROLLER_WASM_BYTES,
        SIMPLEWRITEACCESSCONTROLLER_ID_2.to_string(),
        to_yocto("1000"), // attached deposit
    );

    controller_2
        .call(
            SIMPLEWRITEACCESSCONTROLLER_ID_2.into(),
            "new",
            &json!({
                "owner_id": oracle_three.account_id()
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let read_controller = root.deploy(
        &SIMPLEREADACCESSCONTROLLER_WASM_BYTES,
        SIMPLEREADACCESSCONTROLLER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    let flags = root.deploy(
        &FLAGS_WASM_BYTES,
        FLAGS_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    flags
        .call(
            FLAGS_ID.into(),
            "new",
            &json!({
                "owner_id": oracle_three.account_id().to_string(),
                "rac_address": controller.account_id().to_string(),
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    oracle_three
        .call(
            FLAGS_ID.into(),
            "disable_access_check",
            &json!({}).to_string().into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let flags_consumer = oracle_three.deploy(
        &FLAGSTESTHELPER_WASM_BYTES,
        FLAGSTESTHELPER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    flags_consumer
        .call(
            FLAGSTESTHELPER_ID.into(),
            "new",
            &json!({
                "flags_contract": flags.account_id().to_string()
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    let consumer = root.deploy(
        &CONSUMER_WASM_BYTES,
        CONSUMER_ID.to_string(),
        to_yocto("1000"), // attached deposit
    );

    consumer
        .call(
            CONSUMER_ID.into(),
            "new",
            &json!({
                "oracle_account": oracle_one.account_id()
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            0, // attached deposit
        )
        .assert_success();

    (
        root,
        aca,
        link,
        oracle_one,
        oracle_two,
        oracle_three,
        test_helper,
        eac,
        eac_without_access_controller,
        oracle_four,
        oracle_five,
        aggregator_validator_mock_factory,
        flags,
        consumer,
        flags_consumer,
        controller,
        controller_2,
        flux_aggregator_test_helper_contract,
        eddy,
        mock_v3_aggregator,
        mock_v3_aggregator_second,
        read_controller,
        flux_aggregator,
    )
}

'''