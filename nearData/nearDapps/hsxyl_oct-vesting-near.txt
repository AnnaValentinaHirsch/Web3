*GitHub Repository "hsxyl/oct-vesting-near"*

'''--- Cargo.toml ---
[package]
name = "oct-vesting-in-near"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- README.md ---
# 简介

- 这是一个基于near开发的旨在提供通用的vesting功能的合约.
- 本合约对Vesting的定义是: 权益所有者(Owner)将权益(token)分发(Schedule)给受益人(Beneficiary)。
- 合约里面有如下概念:
    - `Owner`: 权益所有者，是一个near账号。
    - `Beneficiary`: 受益人，是一个near账号。
    - `Vesting`: 权益分发合同。
      ```rust
      struct Vesting {
          owner: AccountId,
          beneficiary: AccountId,
          schedules: HashMap<ScheduleId, Schedule>,
          title: String,
          description: String
      }
      ```
    - `Schedule`: 权益分发计划(一个Vesting中可能会有多个Schedule)。
    - `OwnerAction`: `Owner`可以对 `Vesting` 或 `Schedule`执行的操作。
    - `BeneficiaryAction`: `Beneficiary`可以对 `Vesting`或 `Schedule`执行的操作。

# 图示
![](imgs/vesting.png)

# Schedule
- vesting的通用性在Schedule上体现，Schedule是不同权益分发方式的集合:
```rust
pub enum Schedule {
    NaturalTimeLinearRelease
}
```
- 针对已有的一些项目，对于权益分发过程，首先总结一些trait：
  - 权益总量相关：
  ```rust
  pub trait VestingAmount {
    fn get_released_amount(&self)->Amount {
        assert!(self.get_total_amount()>=self.get_unreleased_amount(),"total amount should ge released amount.");
        self.get_total_amount()-self.get_unreleased_amount()
    }
    // 优先实现unreleased amount
    fn get_unreleased_amount(&self)->Amount;
    fn get_total_amount(&self)->Amount;
    fn get_claimable_amount(&self)->Amount {
        self.get_balance()-self.get_unreleased_amount()
    }
  }
  ```
  - 权益发放时间相关:
  ```rust
  // 自然时间
  pub trait NaturalTime {
    fn get_start_time(&self)->SecondTimeStamp;
    fn get_end_time(&self)->SecondTimeStamp;
    fn get_period(&self)->SecondTimeStamp {
        self.get_end_time()-self.get_start_time()+1
    }
  }
  ```
  or
  ```rust
   pub trait Period {
    fn get_remain_period(&self)->SecondTimeStamp;
    fn set_remain_period(&self, seconds: SecondTimeStamp);
  }
  ```
  - claim权益:
  ```rust
  pub trait Claimable {
    fn claim(&mut self);
  }
  ```
- 不同的Schedule Type实质上是不同的过程的trait的组合。

# OwnerAction & BeneficiaryAction
- Action对应权益所有者和权益受益人两方实际的需求。
- 目前已知的一些action:
  - Beneficiary可以更改Beneficiary.
  - Owner可以终止，暂停Vesting.
  。。。
- 假如有新的未满足的Action，那新增功能的一个流程: 
![](imgs/new_action.png)

  - 以Owner暂停Vesting这个新的需求举例: 
 
  1. 首先在Schedule级别需要定义新的trait: Period ，只有实现了Period这种trait类型的Schedule才能暂停
  ```rust
  pub trait Period {
    fn get_remain_period(&self)->SecondTimeStamp;
    fn set_remain_period(&mut self, seconds: SecondTimeStamp);
  }
  pub trait Stop {
    fn stop(&mut self);
  }
  ```
  2. 使用定义新的Schedule Type,并实现Period和claim，stop:
  ```rust
  pub struct ReleaseByPeriod {
    remain_period: Seconds,
    token_id: AccountId,
    token_balance: Amount,
    total_amount: Amount,
  }
  impl Period for ReleaseByPeriod {
      
  }
  
  impl Claim for ReleaseByPeriod {
  }
  
  impl Stop for ReleaseByPeriod {
  }
  ```
  3. 最后在合约层实现OwnerAction trait的暂停的新函数`stop`. 对所有能暂停的Schedule进行暂停：
  首先在`OwnerAction trait`里新增stop函数让外部调用:
  ```rust
  pub trait OwnerAction {
    fn stop(&mut self);
  }
  
  impl OwnerAction for Contract {
      
  }
  ```
'''
'''--- src/account.rs ---
use std::collections::{HashMap, HashSet};
use near_sdk::Balance;
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub enum VAccount {
    Current(Account),
}

impl VAccount {
    /// Upgrades from other versions to the currently used version.
    pub fn into_current(self) -> Account {
        match self {
            VAccount::Current(account) => account,
        }
    }
}

impl From<Account> for VAccount {
    fn from(account: Account) -> Self {
        VAccount::Current(account)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub fts: HashMap<ContractId, Balance>,
    pub vestings: HashSet<VestingId>
}

impl OctVesting {

}
'''
'''--- src/interfaces.rs ---
use crate::types::{ScheduleId, SecondTimeStamp};
use crate::VestingId;

pub trait VestingOwnerAction {

}

pub trait VestingBeneficiaryAction {
   fn claim(&mut self, vesting_id: VestingId, schedule: Option<Vec<Se>>);

}

pub trait VestingView {
   fn view_claim_at(&self, time: SecondTimeStamp, schedule: ScheduleId);
}
'''
'''--- src/lib.rs ---
mod account;
mod vesting;
mod types;
mod utils;
mod interfaces;

use std::collections::HashSet;
use near_sdk::{AccountId, near_bindgen, PanicOnDefault};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use crate::account::VAccount;
use crate::types::VestingId;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OctVesting {
    pub accounts: LookupMap<AccountId, VAccount>,
    pub vesting: UnorderedMap<VestingId, Vesting>,
}

'''
'''--- src/types.rs ---
use near_sdk::json_types::U128;

pub type SecondTimeStamp = u64;
pub type MilliTimeStamp = u64;

pub type Day = u64;

pub type Amount = u128;
pub type VestingId = u64;
pub type ScheduleId = u64;

'''
'''--- src/utils.rs ---
use near_sdk::env;
use crate::types::SecondTimeStamp;

pub fn get_block_second_time() -> SecondTimeStamp {
    return env::block_timestamp()/1000_000_000;
}
'''
'''--- src/vesting/beneficiary.rs ---
use near_sdk::AccountId;
use crate::vesting::schedule::traits::VestingAmount;
use crate::vesting::schedule::VestingAmount;

'''
'''--- src/vesting/eth_interface/interfaces.rs ---
// impl old vesting contract in eth: https://github.com/octopus-network/oct-token-eth/tree/main/contracts

use near_sdk::json_types::U128;
use crate::AccountId;
use crate::types::{Amount, Day, SecondTimeStamp};

// old vesting contract in eth: https://github.com/octopus-network/oct-token-eth/blob/main/contracts/UnsupervisedTimelock.sol
pub trait UnsupervisedTimeLock
{
    /**
     * @return the beneficiary address
     */
    fn beneficiary() -> AccountId;

    /**
     * @return the total balance of benefit
     */
    fn total_benefit()-> Amount;

    /**
     * @return the balance to release for the beneficiary at the moment
     */
    fn released_balance() -> Amount;

    /**
     * @return the unreleased balance of the beneficiary at the moment
     */
    fn unreleased_balance() -> Amount;

    /**
     * @return the withdrawed balance of beneficiary
     */
    fn withdraw_balance() -> Amount;

    /**
     * @notice Withdraws tokens to beneficiary
     */
    fn withdraw();
}

trait SupervisedTimeLock: UnsupervisedTimeLock {
    /**
     * @notice Teminate this contract and withdraw all amount of unreleased balance to the owner.
     * After the contract is terminated, the beneficiary can still withdraw all amount of
     * released balance.
     */
    fn terminate();
}

pub trait SupervisedMultiTimeLock {

    /**
     * @return the issued benefit of a beneficiary
     */
    fn issued_benefit_of(account: AccountId)->Amount;

    /**
     * @return the amount which can be withdrawn by a beneficiary at the moment
     */
    fn released_amount_of(account: AccountId)->Amount;

    /**
     * @return the unreleased amount of a beneficiary at the moment
     */
    fn unreleased_amount_of(account: AccountId)->Amount;

    /**
     * @return the withdrawn amount of a beneficiary at the moment
     */
    fn withdrawn_amount_of(account: AccountId)->Amount;

    /**
     * @notice Issue a certain amount benefit to a beneficiary.
     * An address of a beneficiary can only be used once.
     */
    fn issue_benefit_to(
        account: AccountId,
        total_amount: Amount,
        release_start_time: SecondTimeStamp,
        days_of_time_lock: Day
    );

    /**
     * @notice Withdraws benefit of a beneficiary.
     * This function can be called by any account.
     */
    fn withdraw_benefit_of(account: AccountId);

    /**
     * @notice Remove a certain beneficiary from this contract.
     * The removed beneficiary can not withdraw benefit from this contract any more.
     */
    fn terminate_benefit_of(account: AccountId);

    /**
     * @notice Withdraw a certain amount of remaining benefit to the owner.
     */
    fn withdraw_remaining_benefit(amount: Amount);
}
'''
'''--- src/vesting/eth_interface/mod.rs ---
mod interfaces;
mod models;
'''
'''--- src/vesting/eth_interface/models.rs ---

'''
'''--- src/vesting/interfaces.rs ---
use near_sdk::json_types::U128;
use crate::types::{Amount, SecondTimeStamp};
use crate::vesting::schedule::VestingAmount;

pub trait Owner {
    fn get_owner(self);
}

pub trait OwnerAction {

}

pub trait BeneficiaryAction {

}

pub trait Claimable<T> where T: VestingAmount {
    fn claim(t:&mut T)->Amount {
        let claimable_amount = t.get_claimable_amount();
        assert!(t.get_balance()>=claimable_amount);
        t.set_balance(t.get_balance()-claimable_amount);
        claimable_amount
    }
}
'''
'''--- src/vesting/mod.rs ---
pub mod interfaces;
pub mod eth_interface;
pub mod schedule;
pub mod beneficiary;
pub mod vesting;

enum VestingType {
    UnsupervisedTimeLock,
    SupervisedTimeLock,
    SupervisedMultiTimeLock
}

struct UnsupervisedTimeLockVesting {

}

'''
'''--- src/vesting/schedule/mod.rs ---
pub mod natural_time_linear_release;

use crate::AccountId;
use crate::types::{Amount, SecondTimeStamp};

pub enum Schedule {
    NaturalTimeLinearRelease
}

pub trait NaturalTime {
    fn get_start_time(&self)->SecondTimeStamp;
    fn get_end_time(&self)->SecondTimeStamp;
    fn get_period(&self)->SecondTimeStamp {
        self.get_end_time()-self.get_start_time()+1
    }
}

pub trait VestingAmount {
    fn get_released_amount(&self)->Amount {
        assert!(self.get_total_amount()>=self.get_unreleased_amount(),"total amount should ge released amount.");
        self.get_total_amount()-self.get_unreleased_amount()
    }
    fn get_unreleased_amount(&self)->Amount;
    fn get_total_amount(&self)->Amount;
    fn get_claimable_amount(&self)->Amount {
        self.get_balance()-self.get_unreleased_amount()
    }
}

pub trait IBalance {
    fn get_token_id(&self)-> &AccountId;
    fn get_balance(&self)-> Amount;
    fn set_balance(&mut self, balance: Amount);
}

impl<T:NaturalTime+IBalance> VestingAmount for T {
    fn get_unreleased_amount(&self) -> Amount {

    }
    fn get_total_amount(&self) -> Amount {
        return self.
    }
}

pub trait Claimable: VestingAmount {

}
'''
'''--- src/vesting/schedule/natural_time_linear_release.rs ---
use near_sdk::json_types::U128;
use crate::AccountId;
use crate::types::{Amount, SecondTimeStamp};
use crate::vesting::schedule::{IBalance, NaturalTime, VestingAmount};
use crate::vesting::schedule::traits::{NaturalTime, VestingAmount};
use crate::vesting::*;
use crate::vesting::schedule::Schedule::NaturalTimeLinearRelease;

pub struct NaturalTimeLinearRelease {
    start_time: SecondTimeStamp,
    end_time: SecondTimeStamp,
    token_id: AccountId,
    token_balance: Amount,
    total_amount: Amount,
}

impl NaturalTime for NaturalTimeLinearRelease {
    fn get_start_time(&self) -> SecondTimeStamp {
        self.start_time
    }

    fn get_end_time(&self) -> SecondTimeStamp {
        self.end_time
    }
}

impl IBalance for NaturalTimeLinearRelease {
    fn get_token_id(&self) -> &AccountId {
        &self.token_id
    }

    fn get_balance(&self) -> Amount {
        self.token_balance
    }

    fn set_balance(&mut self, balance: Amount) {
        self.token_balance = balance
    }
}

impl VestingAmount for NaturalTimeLinearRelease {
    fn get_unreleased_amount(&self) -> Amount {
        u64::try_from(self.get_total_amount()) self.get_total_amount()
        todo!()
    }

    fn get_total_amount(&self) -> Amount {
        self.total_amount
    }
}
'''
'''--- src/vesting/vesting.rs ---
use std::collections::HashMap;
use near_sdk::AccountId;
use crate::types::ScheduleId;
use crate::vesting::beneficiary::Beneficiary;
use crate::vesting::interfaces::Owner;
use crate::vesting::schedule::models::Schedule;
use crate::vesting::schedule::Schedule;

struct Vesting {
    owner: AccountId,
    beneficiary: AccountId,
    schedules: HashMap<ScheduleId, Schedule>,
    title: String,
    description: String
}
'''