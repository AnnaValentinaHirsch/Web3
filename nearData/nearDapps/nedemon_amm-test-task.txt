*GitHub Repository "nedemon/amm-test-task"*

'''--- README.md ---
## Abstract
AMM working with the ratio of 2 fungible tokens

The user can transfer a number of tokens A to the AMM contract and in return receive a certain number of tokens B (similarly in the other direction).The contract supports a certain ratio of tokens A and B. $X * Y = K$ ( $K$ is some constant value, $X$ and $Y$ are the number of tokens A and B respectively)

## Create Accounts

```bash
owner_id=whatever.testnet
a_id=a.$owner_id
b_id=b.$owner_id
amm_id=amm.$owner_id
sim_id=sim.$owner_id

near="near --nodeUrl https://rpc.testnet.near.org"

$near login
$near create-account $a_id --masterAccount $owner_id
$near create-account $b_id --masterAccount $owner_id
$near create-account $amm_id --masterAccount $owner_id
$near create-account $sim_id --masterAccount $owner_id
```
Create the accounts using NEAR CLI. 

## Deploy and Initialize
```bash
near deploy $a_id --wasmFile="./token_contract.wasm"
near deploy $b_id --wasmFile="./token_contract.wasm"
near deploy $amm_id --wasmFile="./amm_contract.wasm"

near call $a_id new '{"owner_id":"'$owner_id'", "name":"A Token Contract", "symbol":"A", "total_supply":1000000000000, "decimals": 18}' --accountId=$owner_id
near call $b_id new '{"owner_id":"'$owner_id'", "name":"B Token Contract", "symbol":"B", "total_supply":20000000000000, "decimals": 15}' --accountId=$owner_id
near call $amm_id new '{"owner_id":"'$owner_id'", "a_contract_id":"'$a_id'", "b_contract_id":"'$b_id'"}' --accountId=$owner_id --gas=55000000000000
```
Use `near call` command to initialize them.

## Test AMM Functionality
```base
sim_id=b.whatever.testnet

near call $a_id storage_deposit '{"account_id": "'$sim_id'"}' --accountId=$owner_id --deposit=1
near call $a_id ft_transfer '{"receiver_id": "'$sim_id'","amount":"1000000000000000000000"}' --accountId=$owner_id --deposit=0.000000000000000000000001
near view $a_id ft_balance_of '{"account_id": "'$sim_id'"}'
```
First we use `b.whatever.testnet` account to simulate an AMM user. We register a A wallet for him and give him 1,000 tokens.
```bash
near call $amm_id deposit_a '{"amount":111}' --accountId=$sim_id --gas=55000000000000
```
```bash
near view $a_id ft_balance_of '{"account_id": "'$sim_id'"}'
near view $b_id ft_balance_of '{"account_id": "'$sim_id'"}'
near view $a_id ft_balance_of '{"account_id": "'$amm_id'"}'
near view $b_id ft_balance_of '{"account_id": "'$amm_id'"}'
near view $amm_id get_info
near view $amm_id get_ratio
```

'''
'''--- amm-contract/.cargo/config.toml ---
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]
'''
'''--- amm-contract/Cargo.toml ---
[package]
name = "amm-contract"
version = "0.1.1"
authors = ["S T"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../near-sdk-rs/near-sdk" }
near-contract-standards = { path = "../near-sdk-rs/near-contract-standards" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- amm-contract/src/lib.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    assert_self, env, ext_contract, log, near_bindgen, require, AccountId, Balance, PanicOnDefault,
    Promise, PromiseOrValue, PromiseResult,
};

#[ext_contract(ext_token)]
trait ExtToken {
    fn get_info(&self) -> (String, u8);
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128);
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn callback_get_info(&mut self, contract_id: AccountId, #[callback] val: (String, u8));
    fn callback_update_balances(&mut self, a_balance_after: Balance, b_balance_after: Balance);
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct TokenMeta {
    account_id: AccountId,
    ticker: String,
    decimal: u32,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    owner_id: AccountId,
    ratio: u128,
    //total A token number
    a_balance: u128,
    a_meta: TokenMeta,
    //total B token number
    b_balance: u128,
    b_meta: TokenMeta,
}

#[near_bindgen]
impl Contract {
    /// Input are the address of the contract owner and the addresses of two tokens (hereinafter token A and token B).
    /// requests and stores the metadata of tokens (name, decimals)
    #[init]
    pub fn new(owner_id: AccountId, a_contract_id: AccountId, b_contract_id: AccountId) -> Self {
        require!(!env::state_exists(), "The contract has been initialized");

        // The method requests and stores the metadata of tokens (name, decimals)
        ext_token::ext(a_contract_id.clone()).get_info().then(
            ext_self::ext(env::current_account_id()).callback_get_info(a_contract_id.clone()),
        );
        ext_token::ext(b_contract_id.clone()).get_info().then(
            ext_self::ext(env::current_account_id()).callback_get_info(b_contract_id.clone()),
        );

        Self {
            owner_id,
            ratio: 0,
            a_balance: 0,
            a_meta: TokenMeta {
                account_id: a_contract_id,
                ticker: "".into(),
                decimal: 1,
            },
            b_balance: 0,
            b_meta: TokenMeta {
                account_id: b_contract_id,
                ticker: "".into(),
                decimal: 1,
            },
        }
    }

    pub fn callback_update_balances(
        &mut self,
        a_balance_after: Balance,
        b_balance_after: Balance,
    ) -> PromiseOrValue<U128> {
        assert_self();

        match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(_) => {
                self.update_balances(a_balance_after, b_balance_after);
                PromiseOrValue::Value(0.into())
            }
            PromiseResult::Failed => env::panic_str("fail!"),
        }
    }

    pub fn callback_get_info(&mut self, contract_id: AccountId, #[callback] val: (String, u8)) {
        assert_self();

        log!("Fill additional info for {}", val.0);
        if contract_id == self.a_meta.account_id {
            self.a_meta.ticker = val.0;
            self.a_meta.decimal = val.1 as u32;
        } else if contract_id == self.b_meta.account_id {
            self.b_meta.ticker = val.0;
            self.b_meta.decimal = val.1 as u32;
        }
        self.calc_ratio();
    }

    pub fn get_info(
        &self,
    ) -> (
        (AccountId, String, Balance, u32),
        (AccountId, String, Balance, u32),
    ) {
        (
            (
                self.a_meta.account_id.clone(),
                self.a_meta.ticker.clone(),
                self.a_balance,
                self.a_meta.decimal,
            ),
            (
                self.b_meta.account_id.clone(),
                self.b_meta.ticker.clone(),
                self.b_balance,
                self.b_meta.decimal,
            ),
        )
    }

    pub fn get_ratio(&self) -> u128 {
        self.ratio
    }

    pub fn calc_ratio(&mut self) {
        let a_num = self.a_balance / 10_u128.pow(self.a_meta.decimal);
        let b_num = self.b_balance / 10_u128.pow(self.b_meta.decimal);
        //X * Y = K , K is some constant value
        self.ratio = a_num * b_num;
    }

    fn deposit_a(&mut self, sender_id: AccountId, a_amount: Balance) -> Promise {
        let decimal = 10_u128.pow(self.a_meta.decimal);
        let a_balance_after = a_amount + self.a_balance;
        let b_balance_after = ((self.ratio * decimal / a_balance_after) as f64
            * 10_u128.pow(self.b_meta.decimal) as f64) as u128;
        let b_amount = self.b_balance - b_balance_after;
        let next_contract = self.b_meta.account_id.clone();
        ext_token::ext(next_contract)
            .with_attached_deposit(1)
            .ft_transfer(sender_id, b_amount.into())
            .then(
                ext_self::ext(env::current_account_id())
                    .callback_update_balances(a_balance_after, b_balance_after),
            )
    }

    fn deposit_a_by_owner(&mut self, a_amount: Balance) {
        let a_balance_after = a_amount + self.a_balance;
        let b_balance_after = self.b_balance;

        self.update_balances(a_balance_after, b_balance_after);
    }

    /// in the opposite direction
    fn deposit_b(&mut self, sender_id: AccountId, b_amount: Balance) -> Promise {
        let decimal = 10_u128.pow(self.b_meta.decimal);
        let b_balance_after = b_amount + self.b_balance;
        let a_balance_after = ((self.ratio * decimal / b_balance_after) as f64
            * 10_u128.pow(self.a_meta.decimal) as f64) as u128;
        let a_amount = self.a_balance - a_balance_after;
        let next_contract = self.a_meta.account_id.clone();
        ext_token::ext(next_contract)
            .with_attached_deposit(1)
            .ft_transfer(sender_id, a_amount.into())
            .then(
                ext_self::ext(env::current_account_id())
                    .callback_update_balances(a_balance_after, b_balance_after),
            )
    }

    fn deposit_b_by_owner(&mut self, b_amount: Balance) {
        let b_balance_after = b_amount + self.b_balance;
        let a_balance_after = self.a_balance;

        self.update_balances(a_balance_after, b_balance_after);
    }

    fn update_balances(&mut self, a_balance_after: Balance, b_balance_after: Balance) {
        self.a_balance = a_balance_after;
        self.b_balance = b_balance_after;
        self.calc_ratio();
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// The user can transfer a certain number of tokens A to the contract account and
    /// in return must receive a certain number of tokens B (similarly in the other direction).
    /// The contract supports a certain ratio of tokens A and B. X * Y = K
    /// K is some constant value, X and Y are the number of tokens A and B respectively.
    /// The owner of the contract can transfer a certain amount of tokens A or B to the contract account,
    /// thereby changing the ratio K.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let _ = msg;
        let predecessor_id = env::predecessor_account_id();
        if predecessor_id == self.a_meta.account_id && sender_id != self.owner_id {
            self.deposit_a(sender_id, amount.into()).into()
        } else if predecessor_id == self.a_meta.account_id && sender_id == self.owner_id {
            self.deposit_a_by_owner(amount.into());
            PromiseOrValue::Value(0.into())
        } else if predecessor_id == self.b_meta.account_id && sender_id != self.owner_id {
            self.deposit_b(sender_id, amount.into()).into()
        } else if predecessor_id == self.b_meta.account_id && sender_id == self.owner_id {
            self.deposit_b_by_owner(amount.into());
            PromiseOrValue::Value(0.into())
        } else {
            env::panic_str("invalid call");
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        let name = "AMM Contract";
        let symbol = "AMM Contract";
        let total_supply:Balance = 10000000000000000000000;
        let decimals = 18;

        testing_env!(context.build());
        let mut contract = Contract::new(
             accounts(1).into(),
             accounts(2).into(),
             accounts(3).into(),
        );

        contract.update_balances(100, 200);

        testing_env!(context.is_view(true).build());
        assert_eq!(contract.get_info().0.2, 100);
        assert_eq!(contract.get_info().1.2, 200);
        assert_eq!(contract.get_ratio(), 200);
    }
}

'''
'''--- res/deploy.sh ---
owner_id=stsv.testnet
a_id=a.$owner_id
b_id=b.$owner_id
amm_id=amm.$owner_id
sim_id=sim.$owner_id

#40000
amm_a_balance=(40000000000000000000000)
#300000
amm_b_balance=(  300000000000000000000)
#1000
sim_a_balance=( 1000000000000000000000)
#111
sim_a_exchange=(    111000000000000000)

near="near --nodeUrl https://rpc.testnet.near.org"

$near delete $a_id $owner_id
$near delete $b_id $owner_id
$near delete $amm_id $owner_id
$near delete $sim_id $owner_id
$near create-account $a_id --masterAccount $owner_id
$near create-account $b_id --masterAccount $owner_id
$near create-account $amm_id --masterAccount $owner_id
$near create-account $sim_id --masterAccount $owner_id
$near deploy $a_id --wasmFile="./token_contract.wasm"
$near deploy $b_id --wasmFile="./token_contract.wasm"
$near deploy $amm_id --wasmFile="./amm_contract.wasm"

$near call $a_id new '{"owner_id":"'$owner_id'", "name":"A Token Contract", "symbol":"A", "total_supply":1000000000000, "decimals": 18}' --accountId=$owner_id
$near call $b_id new '{"owner_id":"'$owner_id'", "name":"B Token Contract", "symbol":"B", "total_supply":20000000000000, "decimals": 15}' --accountId=$owner_id
$near call $amm_id new '{"owner_id":"'$owner_id'", "a_contract_id":"'$a_id'", "b_contract_id":"'$b_id'"}' --accountId=$owner_id --gas=55000000000000

$near call $a_id storage_deposit '{"account_id": "'$amm_id'"}' --accountId=$owner_id --deposit=1
$near call $b_id storage_deposit '{"account_id": "'$amm_id'"}' --accountId=$owner_id --deposit=1
$near call $a_id storage_deposit '{"account_id": "'$sim_id'"}' --accountId=$owner_id --deposit=1
$near call $b_id storage_deposit '{"account_id": "'$sim_id'"}' --accountId=$owner_id --deposit=1

$near call $a_id ft_transfer_call '{"receiver_id": "'$amm_id'","amount":"'$amm_a_balance'","msg":""}' --accountId=$owner_id --deposit=0.000000000000000000000001 --gas=55000000000000
$near call $b_id ft_transfer_call '{"receiver_id": "'$amm_id'","amount":"'$amm_b_balance'","msg":""}' --accountId=$owner_id --deposit=0.000000000000000000000001 --gas=55000000000000
$near call $a_id ft_transfer '{"receiver_id": "'$sim_id'","amount":"'$sim_a_balance'"}' --accountId=$owner_id --deposit=0.000000000000000000000001 --gas=55000000000000

#1000
$near view $a_id ft_balance_of '{"account_id": "'$sim_id'"}'
#0
$near view $b_id ft_balance_of '{"account_id": "'$sim_id'"}'
#40000
$near view $a_id ft_balance_of '{"account_id": "'$amm_id'"}'
#300000
$near view $b_id ft_balance_of '{"account_id": "'$amm_id'"}'
$near view $amm_id get_info
#12000000000
$near view $amm_id get_ratio

$near call $a_id ft_transfer_call '{"receiver_id": "'$amm_id'","amount":"'$sim_a_exchange'","msg":""}' --accountId=$sim_id --deposit=0.000000000000000000000001 --gas=55000000000000

#1000-111=889
$near view $a_id ft_balance_of '{"account_id": "'$sim_id'"}'
#x
$near view $b_id ft_balance_of '{"account_id": "'$sim_id'"}'
#40000+111=40111
$near view $a_id ft_balance_of '{"account_id": "'$amm_id'"}'
#300000-x
$near view $b_id ft_balance_of '{"account_id": "'$amm_id'"}'
$near view $amm_id get_info
#12000000000
$near view $amm_id get_ratio

'''
'''--- token-contract/.cargo/config.toml ---
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]
'''
'''--- token-contract/Cargo.toml ---
[package]
name = "token-contract"
version = "0.1.1"
authors = ["S T"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../near-sdk-rs/near-sdk" }
near-contract-standards = { path = "../near-sdk-rs/near-contract-standards" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- token-contract/src/lib.rs ---
use near_contract_standards;
use near_contract_standards::fungible_token::metadata::{FungibleTokenMetadata, FT_METADATA_SPEC};
use near_contract_standards::fungible_token::FungibleToken;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{
    env, log, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    PromiseOrValue,
};

/// a fungible token template
/// we can deploy to multiple accounts and init with different parameters to create different tokens
/// there is a amm_id attribute which reffers to the AMM Contract
/// we use this attribute to authorize and verify transfer_from method
/// this is not a proper way when using in production
#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    meta: FungibleTokenMetadata,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    T,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        owner_id: AccountId,
        name: String,
        symbol: String,
        total_supply: Balance,
        decimals: u8,
    ) -> Self {
        require!(!env::state_exists(), "The contract has initialized!");
        let mut this = Self {
            token: FungibleToken::new(StorageKey::T),
            meta: FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name,
                symbol,
                icon: None,
                reference: None,
                reference_hash: None,
                decimals,
            },
        };

        this.token.internal_register_account(&owner_id);
        this.token
            //.internal_deposit(&owner_id, total_supply * 10_u128.pow(decimals as u32));
            .internal_deposit(&owner_id, total_supply);
        this
    }

    pub fn get_info(self) -> (String, u8) {
        (self.meta.symbol, self.meta.decimals)
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        let name = "A Token Contract";
        let symbol = "A Token Contract";
        let total_supply = 10000000000000000000000;
        let decimals = 18;

        testing_env!(context.build());
        let contract = Contract::new(
            accounts(1).into(),
            name.into(),
            symbol.into(),
            total_supply,
            decimals,
        );
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, total_supply);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, total_supply);
        assert_eq!(contract.get_info(), (name.into(), decimals));
    }
}

'''