*GitHub Repository "galactic3/ft-lockup-contract-frontend"*

'''--- .github/workflows/node.js.yml ---
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions

name: Node.js CI

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    - uses: actions/checkout@v2
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v2
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'yarn'
    - run: yarn
    - run: yarn build    
    - run: yarn test --watchAll=false

'''
'''--- .idea/codeStyles/codeStyleConfig.xml ---
<component name="ProjectCodeStyleConfiguration">
  <state>
    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
  </state>
</component>
'''
'''--- .idea/inspectionProfiles/Project_Default.xml ---
<component name="InspectionProjectProfileManager">
  <profile version="1.0">
    <option name="myName" value="Project Default" />
    <inspection_tool class="CssInvalidAtRule" enabled="false" level="ERROR" enabled_by_default="false" />
    <inspection_tool class="Eslint" enabled="true" level="WARNING" enabled_by_default="true" />
    <inspection_tool class="HtmlUnknownAttribute" enabled="true" level="WARNING" enabled_by_default="true">
      <option name="myValues">
        <value>
          <list size="2">
            <item index="0" class="java.lang.String" itemvalue="open" />
            <item index="1" class="java.lang.String" itemvalue="sx" />
          </list>
        </value>
      </option>
      <option name="myCustomValuesEnabled" value="true" />
    </inspection_tool>
    <inspection_tool class="TsLint" enabled="true" level="WARNING" enabled_by_default="true" />
  </profile>
</component>
'''
'''--- .idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/ft-lockup-contract-frontend.iml" filepath="$PROJECT_DIR$/.idea/ft-lockup-contract-frontend.iml" />
    </modules>
  </component>
</project>
'''
'''--- .idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>
'''
'''--- README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `yarn test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

'''
'''--- README.old.md ---
# ft-lockup-contract-frontend
'''
'''--- backlog.md ---
fix `any` casting hacks
use api and not near as context value

'''
'''--- package.json ---
{
  "name": "ft-lockup-contract-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.8.2",
    "@emotion/styled": "^11.8.1",
    "@mui/icons-material": "^5.5.1",
    "@mui/lab": "^5.0.0-alpha.83",
    "@mui/material": "^5.5.3",
    "@mui/styles": "^5.8.6",
    "@mui/x-date-pickers": "^5.0.0-alpha.0",
    "@reach/router": "^1.3.4",
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@testing-library/user-event": "^13.2.1",
    "@types/big.js": "^6.1.3",
    "@types/bn.js": "^5.1.0",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.13",
    "@types/reach__router": "^1.3.10",
    "@types/react": "^17.0.20",
    "@types/react-dom": "^17.0.9",
    "big.js": "^6.1.1",
    "bn.js": "^5.2.0",
    "date-fns": "^2.28.0",
    "echarts": "^5.3.2",
    "echarts-for-react": "^3.0.2",
    "gh-pages": "^3.2.3",
    "near-api-js": "^0.44.2",
    "notistack": "^2.0.5",
    "react": "^17.0.2",
    "react-copy-to-clipboard": "^5.1.0",
    "react-dom": "^17.0.2",
    "react-router-dom": "^6.2.1",
    "react-scripts": "4.0.3",
    "react-use": "^17.4.0",
    "sass": "^1.52.3",
    "typescript": "^4.4.2",
    "web-vitals": "^2.1.0"
  },
  "resolutions": {
    "react-error-overlay": "6.0.9"
  },
  "scripts": {
    "predeploy": "yarn build",
    "deploy": "gh-pages -d build -r https://github.com/ft-lockup/ft-lockup.github.io.git",
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "eslintConfig": {
    "extends": [
      "airbnb",
      "airbnb/hooks",
      "airbnb-typescript",
      "plugin:react/jsx-runtime"
    ],
    "rules": {
      "no-await-in-loop": "off",
      "no-console": "off",
      "no-debugger": "off",
      "no-mixed-operators": [
        "error",
        {
          "groups": [
            [
              "&",
              "|",
              "^",
              "~",
              "<<",
              ">>",
              ">>>"
            ],
            [
              "==",
              "!=",
              "===",
              "!==",
              ">",
              ">=",
              "<",
              "<="
            ],
            [
              "in",
              "instanceof"
            ]
          ],
          "allowSamePrecedence": true
        }
      ],
      "no-nested-ternary": "off",
      "max-len": [
        "error",
        {
          "code": 200
        }
      ],
      "@typescript-eslint/naming-convention": [
        "error",
        {
          "selector": "variable",
          "format": [
            "camelCase",
            "PascalCase",
            "UPPER_CASE"
          ]
        },
        {
          "selector": "function",
          "format": [
            "camelCase",
            "PascalCase"
          ]
        },
        {
          "selector": "typeLike",
          "format": [
            "PascalCase"
          ]
        },
        {
          "selector": "variable",
          "modifiers": [
            "unused"
          ],
          "format": [
            "camelCase",
            "PascalCase",
            "UPPER_CASE"
          ],
          "leadingUnderscore": "require"
        }
      ],
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          "varsIgnorePattern": "^_"
        }
      ],
      "react/jsx-props-no-spreading": "off"
    },
    "parserOptions": {
      "project": "./tsconfig.json"
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@types/react-copy-to-clipboard": "^5.0.3",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint-config-airbnb": "19.0.4",
    "eslint-config-airbnb-typescript": "16.1.0",
    "eslint-plugin-import": "^2.25.3",
    "eslint-plugin-jsx-a11y": "^6.5.1",
    "eslint-plugin-react": "^7.28.0",
    "eslint-plugin-react-hooks": "^4.3.0"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>ft-lockup</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/assets/images/arrow.svg ---
<svg width="27" height="24" viewBox="0 0 27 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M26.0607 13.0607C26.6464 12.4749 26.6464 11.5251 26.0607 10.9393L16.5147 1.3934C15.9289 0.807612 14.9792 0.807612 14.3934 1.3934C13.8076 1.97918 13.8076 2.92893 14.3934 3.51472L22.8787 12L14.3934 20.4853C13.8076 21.0711 13.8076 22.0208 14.3934 22.6066C14.9792 23.1924 15.9289 23.1924 16.5147 22.6066L26.0607 13.0607ZM0 13.5H25V10.5H0V13.5Z" fill="white"/>
</svg>

'''
'''--- src/assets/images/near.svg ---
<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M20.0333 1.22667L14.8169 8.66669C14.4561 9.17333 15.1498 9.78667 15.6492 9.36L20.7824 5.06669C20.9212 4.95998 21.1154 5.04 21.1154 5.22667V18.64C21.1154 18.8267 20.8657 18.9067 20.7547 18.7733L5.2164 0.906667C4.71698 0.32 3.99556 0 3.1909 0H2.63596C1.19312 0 0 1.14667 0 2.56V21.44C0 22.8533 1.19312 24 2.6637 24C3.57936 24 4.43951 23.5467 4.93895 22.7733L10.1554 15.3333C10.5161 14.8267 9.82243 14.2133 9.32298 14.64L4.18979 18.9067C4.05105 19.0133 3.85682 18.9333 3.85682 18.7467V5.36002C3.85682 5.17334 4.10654 5.09333 4.21753 5.22667L19.7558 23.0933C20.2553 23.68 21.0044 24 21.7813 24H22.3363C23.8069 24 25 22.8533 25 21.44V2.56C24.9722 1.14667 23.7791 0 22.3085 0C21.3929 0 20.5327 0.453333 20.0333 1.22667Z" fill="#00B988"/>
</svg>

'''
'''--- src/components/Snackbars/index.ts ---
import Big from 'big.js';

import success from './SuccessPartials';
import failure from './FailurePartials';
import { enqueueCustomSnackbar } from './Snackbar';
import { txLinkInExplorer, nearTo } from '../../utils';

export const SUCCESS_DEFAULT_OPTIONS = { autoHideDuration: 60_000 };

const parseAmount = (unpacked: string, decimals: any): any => new Big(unpacked).div(new Big(10).pow(decimals)).round(2, Big.roundDown);

const claimSnack = (enqueueSnackbar: any, unpacked: any, txHash: string, token: any) => {
  if (unpacked && unpacked !== '0') {
    const amount = parseAmount(unpacked, token.decimals);

    return enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(`Claimed ${amount} ${token.symbol}`),
      success.header('Success'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  return enqueueCustomSnackbar(
    enqueueSnackbar,
    failure.body(`${txLinkInExplorer(txHash)}`),
    failure.header('Claim failed'),
  );
};

const storageDepositSnack = (enqueueSnackbar: any, unpacked: any, txHash: string, token: any, accountId: any) => {
  if (unpacked) {
    const amount = parseFloat(nearTo(unpacked.total, 9)).toString();

    return enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(`Successfully paid ${amount}NEAR for ${accountId}'s storage of ${token.symbol}`),
      success.header('Success'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  return enqueueCustomSnackbar(
    enqueueSnackbar,
    failure.body(`${txLinkInExplorer(txHash)}`),
    failure.header('Payment for deposit storage failed'),
  );
};

const createLockupSnack = (enqueueSnackbar: any, unpacked: any, txHash: string, token: any, txMsg: any) => {
  if (unpacked) {
    const totalBalance = txMsg.schedule[txMsg.schedule.length - 1].balance;

    if (totalBalance === unpacked) {
      const amount = parseAmount(unpacked, token.decimals);

      return enqueueCustomSnackbar(
        enqueueSnackbar,
        success.body(`${txMsg.account_id} now has a lockup of ${amount} ${token.symbol}`),
        success.header('Lockup created'),
        SUCCESS_DEFAULT_OPTIONS,
      );
    }
  }

  return enqueueCustomSnackbar(
    enqueueSnackbar,
    failure.body(`${txLinkInExplorer(txHash)}`),
    failure.header('Lockup creation failed'),
  );
};

const fundDraftGroupSnack = (enqueueSnackbar: any, unpacked: any, txHash: string, token: any, txMsg: any) => {
  if (unpacked && unpacked !== '0') {
    const amount = parseAmount(unpacked, token.decimals);

    return enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(`Draft group ${txMsg.draft_group_id} funded with amount ${amount} ${token.symbol}`),
      success.header('Draft group funded'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  return enqueueCustomSnackbar(
    enqueueSnackbar,
    failure.body(`${txLinkInExplorer(txHash)}`),
    failure.header('Draft group fund failed'),
  );
};

const terminateLockupSnack = (enqueueSnackbar: any, unpacked: any, txHash: string, token: any, lockup_index: any) => {
  if (unpacked) {
    const amount = parseAmount(unpacked, token.decimals);

    return enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(`Lockup #${lockup_index} was terminated. Unvested amount: ${amount} ${token.symbol}`),
      success.header('Lockup terminated'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  return enqueueCustomSnackbar(
    enqueueSnackbar,
    failure.body(`${txLinkInExplorer(txHash)}`),
    failure.header('Lockup termination failed'),
  );
};

const deleteDraftGroupSnack = (enqueueSnackbar: any, message: { positive?: string, negative?: string }) => {
  if (message.positive) {
    enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(message.positive),
      success.header('Success'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  if (message.negative) {
    enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(message.negative),
      failure.header('Failure'),
    );
  }
};

const discardDraftGroupSnack = (enqueueSnackbar: any, message: { positive?: string, negative?: string }) => {
  if (message.positive) {
    enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(message.positive),
      success.header('Success'),
      SUCCESS_DEFAULT_OPTIONS,
    );
  }

  if (message.negative) {
    enqueueCustomSnackbar(
      enqueueSnackbar,
      success.body(message.negative),
      failure.header('Failure'),
    );
  }
};

export {
  claimSnack,
  storageDepositSnack,
  createLockupSnack,
  fundDraftGroupSnack,
  terminateLockupSnack,
  deleteDraftGroupSnack,
  discardDraftGroupSnack,
};

'''
'''--- src/config.ts ---
export interface INearConfig {
  networkId: string,
  nodeUrl: string,
  contractName: string,
  walletUrl: string,
  helperUrl: string,
  explorerUrl: string,
  factoryContractName: string,
}

export const DEFAULT_CONTRACT_NAME = process.env.REACT_APP_DEFAULT_CONTRACT_NAME as string;
export const FACTORY_CONTRACT_NAME = process.env.REACT_APP_FACTORY_CONTRACT_NAME as string;
export const TRY_CONVERT = true;

const getCurrentContractName = (): string => {
  const contractNameFromUrl = window.location.hash.split('/')[1];
  if (contractNameFromUrl === 'new_lockup_contract') return FACTORY_CONTRACT_NAME;

  return contractNameFromUrl;
};

export const CONTRACT_NAME = getCurrentContractName();

console.log(CONTRACT_NAME);

// TODO: move these data to envs
function getConfig(): INearConfig {
  const env = process.env.REACT_APP_ENVIRONMENT || 'development';
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
        explorerUrl: 'https://explorer.betanet.near.org',
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    case 'local':
      return {
        explorerUrl: '',
        helperUrl: '',
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME,
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    case 'test':
    case 'ci':
      return {
        explorerUrl: '',
        helperUrl: '',
        walletUrl: '',
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    case 'ci-betanet':
      return {
        explorerUrl: '',
        helperUrl: '',
        walletUrl: '',
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        factoryContractName: FACTORY_CONTRACT_NAME,
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

export const config = getConfig();

'''
'''--- src/hooks/useLocalStorage.ts ---
import { useState, useEffect } from 'react';

function getStorageValue(key: string, defaultValue: any) {
  const value = localStorage.getItem(key);
  if (value) {
    return JSON.parse(value);
  }
  return defaultValue;
}

function useLocalStorage(key: string, defaultValue: any) {
  const [value, setValue] = useState(() => getStorageValue(key, defaultValue));

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

export default useLocalStorage;

'''
'''--- src/index.css ---
@import-normalize;

:root {
  --bg: #F4F7FC;
  --white: #FFF;
  --main: #272A34;
  --gray: #808689;
  --light-gray: #D0D6D9;
  --primary: #242F57;
  --green: #00B988;
  --red: #FF594E;
  --yellow: #E9AF1C;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--primary);
  font-family: 'Inter', 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body, #root { height: 100%;}

h1, h2 {
  font-weight: 700;
}

h3, h4 {
  font-weight: 500;
}

h1 {
  margin: 1em 0;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.container {
  width: 100%;
  padding-right: 32px;
  padding-left: 32px;
  margin-right: auto;
  margin-left: auto;
  max-width: min(1440px, calc(100vw - 64px));
  min-width: 720px;
  padding-bottom: 50px;
}

.lockup-row {
  padding: 20px;
  display: flex;
  gap: 20px;
}

.lockup-row-column {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.terminate {
  width: 270px;
  margin: auto 10px 0 auto;
}

.terminate .button {
  width: 100%;
  border: 1px solid var(--red);
  background: var(--white);
  color: var(--red);
}

.terminate .button:hover {
  background: var(--red);
  color: var(--white);
}

.terminate span {
  color: var(--gray);
  display: block;
  margin: 10px 0 0;
  font-size: 12px;
  font-weight: 500;
  line-height: 20px;
}

.header {
  height: 82px;
  background: var(--white);
  margin: 0 0 50px;
}

.logo {
  font-size: 24px;
  line-height: 82px;
  font-weight: 800;
  margin-right: 50px;
  color: var(--primary);
  text-decoration: none;
}

.nav {
  display: flex;
  margin-right: auto;
}

.account-name {
  margin-right: 12px;
  font-weight: 500;
}

.nav-link {
  display: block;
  font-size: 16px;
  color: var(--primary);
  font-weight: 500;
  text-decoration: none;
  text-transform: uppercase;
  height: 82px;
  line-height: 82px;
  margin: 0 12px;
  padding: 0 7px;
}

.new-lockup-contract p {
  margin-bottom: 48px;
}

.new-lockup-contract .form-wrapper {
  background-color: var(--white);
  border-radius: 12px;
  padding: 32px;
}

.new-lockup-contract .form-row {
  margin: 24px 0;
}

.new-lockup-contract .form-row_group {
  position: relative;
  display: inline-block;
}

.new-lockup-contract .form-row_error {
  position: absolute;
  font-size: 10px;
  line-height: 20px;
  left: 0;
  top: 100%;
}

.form-row .button {
  display: block;
  padding: 8px 32px;
}

.form-row .form-row_title {
  display: inline-block;
  vertical-align: top;
  font-weight: 500;
  width: 256px;
  line-height: 40px;
  margin-right: 52px;
}

.form-row strong {
  display: inline-block;
  width: 340px;
  line-height: 40px;
  margin-bottom: 5px;
}

.form-row input {
  width: 300px;
  height: 38px;
  border: 1px solid var(--light-gray);
  border-radius: 4px;
  font-size: 16px;
  padding: 0 12px;
}

.add-remove-input .form-group {
  position: relative;
}

.add-remove-input .form-group:not(:first-child) {
  margin-top: 24px;
}

.add-remove-input .form-group input {
  margin-right: 8px;
}

.process-log {
  border-radius: 10px;
  border: 1px solid var(--gray);
  padding: 10px 20px;
  background-color: var(--white);
  font-size: 16px;
  font-family: monospace;
  line-height: 32px;
}

.import-draft-group-wrapper {
  border-radius: 16px;
  padding: 32px;
  background: var(--white);
}

.import-draft-group-wrapper {
  font-weight: 500;
  font-size: 18px;
  margin-bottom: 10px;
}

.import-draft-group-textarea {
  min-width: 100%;
  border: 1px solid var(--light-gray);
  border-radius: 4px;
}

.draft-group-preview-wrapper {
  display: flex;
  align-items: flex-end;
  padding: 24px;
  border-radius: 16px;
  background: var(--white);
  margin-bottom: 20px;
}

.draft-group-preview-info {
  display: flex;
  flex-direction: column;
}

.draft-group-preview-inner h5 {
  font-size: 16px;
  font-weight: 400;
  margin: 0 0 12px;
}

.draft-group-fund-button-wrapper {
  display: flex;
  margin-left: auto;
}

.draft-group-preview-inner .button {
  height: 48px;
  width: 180px;
  font-weight: 700;
  margin: 20px 0 0 24px;
}

.claim-wrapper {
  display: flex;
  align-items: flex-end;
  padding: 24px;
  border-radius: 16px;
  background: var(--white);
  margin-bottom: 2em;
}

.claim-preview-info {
  display: flex;
  flex-direction: column;
}

.claim-wrapper h5 {
  font-size: 16px;
  font-weight: 400;
  margin: 0 0 12px;
}

.claim-button-wrapper {
  display: flex;
  margin-left: auto;
}

.claim-wrapper .claim-button-wrapper .button {
  height: 48px;
  width: 180px;
  font-weight: 700;
  margin: 20px 0 0 24px;
}

.token-info {
  display: flex;
  align-items: center;
}

.token-amount {
  font-size: 28px;
  line-height: 40px;
  font-weight: 700;
  text-align: right;
  margin-right: 10px;
}

.main-table {
  background: #fff;
}

table.MuiTable-root.main-table {
  border-collapse: separate;
  border-spacing: 0;
}

table.MuiTable-root.main-table thead th {
  border-bottom: none;
}

table.MuiTable-root.main-table {
  background-color: transparent;
}

table.MuiTable-root.main-table tbody tr {
  box-shadow: 0 2px 4px rgb(28 41 90 / 5%);
}

table.MuiTable-root.main-table tbody tr:not(.expanded) td {
  background-color: var(--white);
}

table.MuiTable-root.main-table tbody tr:first-child td {
  border-top: 1px solid var(--bg);
  /* border-bottom: 1px solid var(--light-gray); */
}

table.MuiTable-root.main-table tbody tr:first-child td:first-child {
  border-top-left-radius: 10px;
}

table.MuiTable-root.main-table tbody tr:first-child td:last-child {
  border-top-right-radius: 10px;
}

table.MuiTable-root.main-table tbody tr:last-child td:first-child {
  border-bottom-left-radius: 10px;
}

table.MuiTable-root.main-table tbody tr:last-child td:last-child {
  border-bottom-right-radius: 10px;
}

table.MuiTable-root.main-table tbody tr.exp-row td {
  border-bottom: 1px solid var(--bg);
}

table.MuiTable-root.main-table tbody tr.exp-row + tr.expanded td {
  border-bottom: 0;
}

table.MuiTable-root.main-table tbody tr.exp-row.expanded + tr.expanded td {
  border-bottom: 1px solid var(--bg);
}

table.MuiTable-root.main-table tbody tr.exp-row:not(.expanded):nth-last-child(2) td:first-child {
  border-bottom-left-radius: 10px;
}

table.MuiTable-root.main-table tbody tr.exp-row:not(.expanded):nth-last-child(2) td:last-child {
  border-bottom-right-radius: 10px;
}

td.MuiTableCell-root {
  padding: 16px 12px;
}

th.MuiTableCell-root {
  padding: 8px 12px;
}

.table-head .MuiTableCell-head {
  color: var(--primary);
  background: var(--bg);
  text-transform: uppercase;
  font-weight: 700;
  font-size: 10px;
}

.main-table tr .MuiTableCell-head:first-child {
  /*border-left: 1px solid var(--bg);*/
}

.main-table tr .MuiTableCell-head:last-child {
  /*border-right: 1px solid var(--bg);*/
}

.main-table .MuiTableCell-head,
.main-table .MuiTableCell-body {
  border-bottom-color: var(--bg);
}

.main-table .MuiTableCell-body {
  color: var(--primary);
}

.main-table .MuiTableCell-body a {
  color: var(--primary);
}

.main-table .exp-row .MuiTableCell-body {
  border-bottom: unset;
  background: var(--white);
}

.inner-table_wrapper {
  background: var(--white);
  width: 350px;
  height: 500px;
  overflow-y: auto;
  padding: 10px 0 10px 0;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(28, 41, 90, 0.05);
}

.inner-table_wrapper h5 {
  font-size: 14px;
  font-weight: 700;
  margin: 10px 0;
  padding: 0 12px;
}

.inner-table {
  font-weight: 700;
}

.inner-table .MuiTableCell-head {
  color: #97A0C3;
  font-weight: 700;
  font-size: 10px;
}
.inner-table .MuiTableCell-body {
  font-size: 12px;
}

table.MuiTable-root.inner-table tbody tr {
  box-shadow: none;
}

.progress-bar-outer {
  padding: 10px 0;
  width: 200px;
  margin: 0 auto;
}

.progress-bar {
  display: flex;
  height: 8px;
  border-radius: 4px;
  overflow: hidden;
  text-align: center;
}

.progress-bar span {
  display: block;
  color: #fff;
  font-size: 10px;
  line-height: 16px;
}

.progress-bar__tooltip {
  display: flex;
  justify-content: space-between;
  flex-wrap: wrap;
}

.progress-bar__tooltip span {
  display: block;
  width: 100%;
}

.progress-bar__tooltip span {
  display: block;
  width: calc(50% - 2px);
  font-size: 12px;
  margin: 5px 1px;
}

.progress-bar__tooltip span i {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 5px;
}

.progress-bar__tooltip span b {
  font-weight: 600;
}

.MuiTooltip-popper .MuiTooltip-tooltip {
  border-radius: 8px;
}

.claimed {
  background: var(--yellow);
}

.available {
  background: var(--green);
}

.vested {
  background: #0069D1;
}

.unvested {
  background: #F45800;
}

.button, .MuiLoadingButton-root.button {
  background: var(--green);
  font-size: 16px;
  line-height: 24px;
  font-weight: 700;
  border-radius: 8px;
  color: var(--white);
  border: unset;
  padding: 12px 32px;
  cursor: pointer;
  box-shadow: none;
  min-width: 120px;
  text-transform: none;
  transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
}

.button:hover:not(:disabled) {
  box-shadow: 0 2px 4px -1px rgb(0 0 0 / 20%), 0 4px 5px 0 rgb(0 0 0 / 14%), 0 1px 10px 0 rgb(0 0 0 / 12%);
}

.MuiLoadingButton-root .MuiLoadingButton-loadingIndicator {
  color: var(--white);
}

.MuiLoadingButton-root.Mui-disabled.button {
  color: var(--white);
}

.MuiLoadingButton-root.Mui-disabled.MuiLoadingButton-loading {
  color: transparent;
}

.MuiLoadingButton-root.button:hover {
  background: var(--green);
}

.MuiLoadingButton-root.button.red:hover {
  background: var(--red);
}

.MuiDialog-container .MuiDialogActions-root>:not(:first-of-type) {
  margin-left: 24px;
}

.submit {
  margin-top: 24px;
}

.main .button {
  margin: 20px 0;
}

.main .home .button {
  font-size: 20px;
  padding: 16px 32px;
  margin: 0;
}

.button.large {
  padding: 16px 32px;
}

.header .button {
  padding: 8px 32px;
}

.link-button {
  display: inline-block;
  text-decoration: none;
}

.button[disabled] {
  background: var(--light-gray)!important;
}

.button.fullWidth {
  width: 100%;
}

.button.red {
  background: var(--red);
}

.MuiFormControl-root .MuiFormHelperText-root.Mui-error {
  color: var(--red);
}

.MuiInputBase-root.MuiOutlinedInput-root {
  color: var(--primary);
  background-color: var(--white);
}

.MuiInputBase-root.MuiOutlinedInput-root.Mui-error .MuiOutlinedInput-notchedOutline {
  border-color: var(--red);
}

.MuiInputBase-root.MuiOutlinedInput-root .MuiOutlinedInput-notchedOutline {
  border-color: var(--light-gray);
  border-radius: 8px;
}

.MuiInputBase-root.MuiOutlinedInput-root:hover .MuiOutlinedInput-notchedOutline {
  border-color: var(--gray);
}

.search-container .MuiInputAdornment-root {
  height: 1.4em;
}

.input {
  border: 1px solid var(--light-gray);
  border-radius: 8px;
  color: var(--gray);
}

.input.large {
  width: 800px;
  margin-right: 32px;
}

.input.fullWidth {
  width: calc(100% - 152px);
  margin-right: 32px;
}

.home-list {
  margin: 0 0 60px;
  padding: 0;
  display: flex;
  justify-content: space-between;
}

.home-list li {
  width: 300px;
  display: flex;
  border-radius: 12px;
  margin: 0 10px;
  padding: 18px 24px;
  border: 1px solid var(--light-gray);
}

.home-list li div {
  margin-left: 24px;
  text-align: left;
}

.home-list li span {
  display: block;
  font-weight: 400;
  line-height: 24px;
}

.home-list li b {
  display: block;
  font-size: 28px;
  font-weight: 700;
  line-height: 38px;
}

svg {
  margin: auto;
}

.home {
  text-align: center;
  width: 980px;
  padding: 100px 0 0;
}

.line {
  border-bottom: 1px solid var(--light-gray);
  margin: 60px 0;
}

.home h2 {
  font-size: 56px;
  line-height: 1;
  margin: 20px 0;
}

.home h5 {
  font-size: 24px;
  font-weight: 500;
  margin-bottom: 40px;
}

.block {
  margin: 32px 0;
  background-color: var(--white);
  padding: 32px;
  display: flex;
  align-items: center;
  border-radius: 12px;
}

.left_part {
  margin-left: auto;
}

.main button.button.compact {
  margin: 0;
}

.discarded-marker {
  font-weight: 800;
  background-color: var(--light-gray);
  border-radius: 10px;
  padding: 3px 10px;
}

.row-error {
  background: #ffefee;
  padding: 16px 32px;
  line-height: 34px;
  font-size: 16px;
  font-weight: 700;
  color: var(--red);
}

.new-draft-count-text {
  line-height: 30px;
  font-size: 16px;
}

p.standard-text-style {
  font-size: 16px;
  font-weight: 300;
}

.parse-error-label {
  font-weight: 800;
  background-color: #ffefee;
  color: var(--red);
  border-radius: 10px;
  padding: 5px 10px;
  display: inline-block;
}

.code {
  font-family: monospace;
  background-color: var(--light-gray);
  padding: 0 5px;
  border-radius: 4px;
}

.nowrap {
  white-space: nowrap;
}

.login {
  margin: 100px auto;
  text-align: center;
}

.login .MuiAlert-root {
  margin: 2em auto;
  width: 380px;
}

.login .button {
  width: 150px;
  margin: 20px;
}

span.red {
  color: var(--red);
}

span.green {
  color: var(--green);
}

span.gray {
  color: var(--gray);
}

.vested-amount-info {
  display: flex;
  justify-content: space-between;
  vertical-align: middle;
}

'''
'''--- src/react-app-env.d.ts ---
/// <reference types="react-scripts" />

'''
'''--- src/reportWebVitals.ts ---
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({
      getCLS, getFID, getFCP, getLCP, getTTFB,
    }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- src/services/DAOs/astroDAO/api.ts ---
import {
  Contract, WalletConnection,
} from 'near-api-js';

const FUNCTION_CALL_CREATE_PROPOSAL_PERMISSIONS = ['call:AddProposal', '*:AddProposal'];

const DAO_VIEW_METHODS = [
  'get_policy',
];

type TAstroDaoViewMethods = {
  'get_policy': any,
};

type TAstroDaoContract = Contract & TAstroDaoViewMethods;

class AstroDaoApi {
  private contract: TAstroDaoContract;

  constructor(walletConnection: WalletConnection, contractId: string) {
    this.contract = new Contract(
      walletConnection.account(),
      contractId,
      { viewMethods: DAO_VIEW_METHODS, changeMethods: [] },
    ) as TAstroDaoContract;
  }

  getContract(): TAstroDaoContract {
    return this.contract;
  }

  async getCouncilMembers(): Promise<string[]> {
    const policy = await this.contract.get_policy();
    const canProposalRoles = policy.roles.filter(
      (role: any) => role?.permissions?.includes(FUNCTION_CALL_CREATE_PROPOSAL_PERMISSIONS[0]) || role?.permissions?.includes(FUNCTION_CALL_CREATE_PROPOSAL_PERMISSIONS[1]),
    );

    if (canProposalRoles.length === 0) {
      return [];
    }

    const canProposalGroups = canProposalRoles.map((role: any) => role?.kind?.Group);

    return canProposalGroups.flat().filter((member: any) => member);
  }
}

export default AstroDaoApi;

'''
'''--- src/services/DAOs/astroDAO/utils.ts ---
import {
  WalletConnection,
} from 'near-api-js';
import { TRY_CONVERT } from '../../../config';

import AstroDaoApi from './api';

// TODO move to the .env
const ASTRO_DAO_HOST = 'https://testnet.app.astrodao.com';

export const MAX_GAS = '300';
export const ONE_YOKTO = '0.000000000000000000000001';

export const buildProposalFormLink = (
  contractAddress: string,
  action: string,
  variant: string,
  details: string,
  smartContractAddress: string,
  methodName: string,
  json: any,
  actionsGas: string,
  actionDeposit: string,
  gas: string,
): string => {
  const params = {
    details,
    smartContractAddress,
    methodName,
    json,
    actionsGas,
    gas,
    deposit: actionDeposit,
  };

  return `${ASTRO_DAO_HOST}/dao/${contractAddress}/proposals?action=${action}&variant=${variant}&params=${JSON.stringify(params)}`;
};

export const customFunctionCallProposalFormLink = (
  contractAddress: string,
  details: string,
  smartContractAddress: string,
  methodName: string,
  json: any,
  actionsGas: string,
  actionDeposit: string,
  gas: string = MAX_GAS,
): string => buildProposalFormLink(
  contractAddress,
  'create_proposal',
  'ProposeCustomFunctionCall',
  details,
  smartContractAddress,
  methodName,
  json,
  actionsGas,
  actionDeposit,
  gas,
);

export const daoCouncilMembers = async (walletConnection: WalletConnection, accountAddress: string): Promise<any> => {
  try {
    const api = new AstroDaoApi(walletConnection, accountAddress);
    const councilsMembers = await api.getCouncilMembers();

    return { [accountAddress]: councilsMembers };
  } catch (e) {
    console.log('isDAO ERROR:', e);
    return undefined;
  }
};

export const buildFundDraftGroupProposalLink = (
  description: string,
  lockupContractAddress: string,
  tokenContractAddress: string,
  amountValue: string,
  draftGroupIndex: number,
  daoContractAddress: string,
): string => {
  const details = encodeURIComponent(description);
  const methodName = 'ft_transfer_call';
  const json = {
    receiver_id: lockupContractAddress,
    amount: amountValue,
    msg: JSON.stringify({ draft_group_id: draftGroupIndex, try_convert: TRY_CONVERT }),
  };
  const actionsGas = '100'; // with this amount transaction completes in one go (without resubmit with additional gas)
  const actionDeposit = ONE_YOKTO;

  return customFunctionCallProposalFormLink(
    daoContractAddress,
    details,
    tokenContractAddress,
    methodName,
    json,
    actionsGas,
    actionDeposit,
  );
};

export const buildTerminateLockupProposalLink = (
  description: string,
  lockupContractAddress: string,
  lockupIndex: number,
  timestamp: number | null,
  daoContractAddress: string,
): string => {
  const details = encodeURIComponent(description);
  const methodName = 'terminate';
  const json = {
    lockup_index: lockupIndex,
    termination_timestamp: timestamp,
  };
  const actionsGas = '100'; // with this amount transaction completes in one go (without resubmit with additional gas)
  const actionDeposit = ONE_YOKTO;

  return customFunctionCallProposalFormLink(
    daoContractAddress,
    details,
    lockupContractAddress,
    methodName,
    json,
    actionsGas,
    actionDeposit,
  );
};

const utils = {
  buildProposalFormLink,
  customFunctionCallProposalFormLink,
  daoCouncilMembers,
  buildFundDraftGroupProposalLink,
  buildTerminateLockupProposalLink,
};

export default utils;

'''
'''--- src/services/NoLoginTokenApi.ts ---
import {
  Near, Contract, WalletConnection,
} from 'near-api-js';
import { MAX_GAS, dumpLocalStorage } from '../utils';
import getFirstFullAccessKey from './noLogInUsage';

const TOKEN_VIEW_METHODS = [''];
const TOKEN_CHANGE_METHODS = ['storage_deposit'];

type TChangeMethods = {
  'storage_deposit': any,
};

type TTokenContract = Contract & TChangeMethods;

class NoLoginTokenApi {
  private near: Near;

  constructor(near: Near) {
    this.near = near;
  }

  async storageDeposit(tokenAccountId: string, accountId: string, amount: string): Promise<void> {
    dumpLocalStorage();

    await this.setWalletAndContractWithAuth(accountId);

    await this.buildContract(tokenAccountId).storage_deposit({
      args: { account_id: accountId },
      gas: MAX_GAS,
      amount,
    });

    this.near.config.keyStore.clean();
  }

  async setWalletAndContractWithAuth(
    accountId: string,
    contractName: string = this.near.config.contractName,
  ): Promise<any> {
    const firstFullAccessKey = await getFirstFullAccessKey(
      this.near.connection.provider,
      accountId,
    );

    localStorage.setItem(
      `${contractName}_wallet_auth_key`,
      JSON.stringify({ accountId, allKeys: [firstFullAccessKey.public_key] }),
    );
  }

  buildContract(contractName: string): TTokenContract {
    return new Contract(
      (new WalletConnection(this.near, this.near.config.contractName)).account(),
      contractName,
      { viewMethods: TOKEN_VIEW_METHODS, changeMethods: TOKEN_CHANGE_METHODS },
    ) as TTokenContract;
  }
}

export default NoLoginTokenApi;

'''
'''--- src/services/SuggestContext.ts ---
import { createContext } from 'react';

export type TSuggestContext = {
  open: boolean,
  setOpen: (newValue: boolean) => any,
};

export const SuggestContext = createContext<TSuggestContext>({
  open: false,
  setOpen: () => null,
});

'''
'''--- src/services/api.ts ---
import {
  Near, Account, Contract, WalletConnection, utils,
} from 'near-api-js';
import { MAX_GAS, ONE_YOCTO } from '../utils';

export const fromNear = (amount: string): number => parseFloat(utils.format.formatNearAmount(amount || '0'));
export const toYoctoNear = (amount: number): string => utils.format.parseNearAmount(String(amount)) || '0';

const LOCKUP_VIEW_METHODS = [
  'get_draft_group',
  'get_draft_groups_paged',
  'get_drafts',
  'get_lockups_paged',
  'get_token_account_id',
  'get_deposit_whitelist',
  'get_draft_operators_whitelist',
];

const LOCKUP_CHANGE_METHODS = [
  'create_draft',
  'create_drafts',
  'create_draft_group',
  'convert_draft',
  'convert_drafts',
  'terminate',
  'discard_draft_group',
  'delete_drafts',
];

type TViewMethods = {
  'get_draft_group': any,
  'get_draft_groups_paged': any,
  'get_drafts': any,
  'get_lockups_paged': any,
  'get_token_account_id': any,
  'get_deposit_whitelist': any,
  'get_draft_operators_whitelist': any,
};

type TChangeMethods = {
  'create_draft': any,
  'create_drafts': any,
  'create_draft_group': any,
  'convert_draft': any,
  'convert_drafts': any,
  'terminate': any,
  'discard_draft_group': any,
  'delete_drafts': any,
};

export type TNearAmount = string;
export type TNearTimestamp = number;

export type TCheckpoint = {
  timestamp: TNearTimestamp,
  balance: TNearAmount,
};

export type TCheckpointWithIndex = {
  timestamp: TNearTimestamp,
  balance: TNearAmount,
  index: number;
};

export type TSchedule = TCheckpoint[];

export type TTerminationConfig = {
  beneficiary_id: TNearAmount,
  vesting_schedule: {
    Schedule: TSchedule,
  },
};

export type TLockup = {
  id: number,
  account_id: string,
  claimed_balance: TNearAmount,
  schedule: TSchedule,
  timestamp: TNearTimestamp,
  total_balance: TNearAmount,
  unclaimed_balance: TNearAmount,
  termination_config: TTerminationConfig | null,
};

export type TLockupContract = Contract & TViewMethods & TChangeMethods;

type Balance = string;
type DraftIndex = number;
type DraftGroupIndex = number;
type LockupIndex = number;

type DraftGroupView = {
  total_amount: Balance,
  funded: boolean,
  draft_indices: DraftIndex[],
};

type DraftView = {
  draft_group_id: DraftGroupIndex,
  lockup_id: LockupIndex | null,
  lockup: TLockup,
};

class NearApi {
  private near: Near;

  private contract: TLockupContract;

  private walletConnection: WalletConnection;

  constructor(near: Near) {
    this.near = near;
    this.walletConnection = new WalletConnection(near, near.config.contractName);
    this.contract = new Contract(
      this.walletConnection.account(),
      this.near.config.contractName,
      { viewMethods: LOCKUP_VIEW_METHODS, changeMethods: LOCKUP_CHANGE_METHODS },
    ) as TLockupContract;
  }

  async getDraftGroupsAll(): Promise<[DraftGroupView]> {
    const result = await this.contract.get_draft_groups_paged();
    return result.map(([draftIndex, draft]: [any, any]) => Object.assign(draft, { id: draftIndex }));
  }

  async getDraftGroup(index: number): Promise<DraftGroupView | null> {
    const result = await this.contract.get_draft_group({ index });
    if (result) {
      result.id = index;
    }

    return result;
  }

  async getDrafts(indices: number[]): Promise<Array<[DraftIndex, DraftView]>> {
    const result = await this.contract.get_drafts({ indices });

    return result;
  }

  async createDraftGroup(): Promise<DraftGroupIndex> {
    const result = await this.contract.create_draft_group();
    return result;
  }

  async createDraft(draft: any): Promise<DraftIndex> {
    const result = await this.contract.create_draft({ draft });

    return result;
  }

  async createDrafts(drafts: any[]): Promise<DraftIndex> {
    const result = await this.contract.create_drafts({ args: { drafts }, gas: '300000000000000' });

    return result;
  }

  async convertDrafts(indices: DraftIndex[]): Promise<LockupIndex[]> {
    const result = await this.contract.convert_drafts({ args: { draft_ids: indices }, gas: '300000000000000' });

    return result;
  }

  async discardDraftGroup(draftGroupId: number): Promise<any> {
    const result = await this.contract.discard_draft_group({ args: { draft_group_id: draftGroupId } });

    return result;
  }

  async deleteDrafts(draftIds: number[]): Promise<any> {
    const result = await this.contract.delete_drafts({ args: { draft_ids: draftIds } });

    return result;
  }

  async terminate(lockupIndex: number, timestamp: number | null): Promise<void> {
    try {
      const result = await this.contract.terminate({
        args: { lockup_index: lockupIndex, termination_timestamp: timestamp },
        gas: MAX_GAS,
        amount: ONE_YOCTO,
      });
      return result;
    } catch (e) {
      console.log(e);
      throw Error('Cannot terminate lockup');
    }
  }

  getNear(): Near {
    return this.near;
  }

  getWalletConnection(): WalletConnection {
    return this.walletConnection;
  }

  getContract(): TLockupContract {
    return this.contract as TLockupContract;
  }

  getTokenAccountId(): Promise<string> {
    return (this.contract as TLockupContract).get_token_account_id();
  }

  getDepositWhitelist(): Promise<Array<string>> {
    return (this.contract as TLockupContract).get_deposit_whitelist();
  }

  getDraftOperatorsWhitelist(): Promise<Array<string>> {
    return this.contract.get_draft_operators_whitelist();
  }

  loadAllLockups(): Promise<TLockup[]> {
    return (this.contract as TLockupContract).get_lockups_paged().then(
      (response: any) => response.map(([id, data]: [number, any]) => Object.assign(data, { id })),
    );
  }

  signIn(): void {
    const successUrl = `${window.location.href}`;
    const contractName = this.near.config.contractName !== 'lockup_contract_none'
      ? this.near.config.contractName
      : this.near.config.factoryContractName;
    this.walletConnection.requestSignIn(contractName, undefined, successUrl);
  }

  signOut(): void {
    this.walletConnection.signOut();
    this.near.config.keyStore.clear();
  }

  get_account_id(): string {
    return this.walletConnection.getAccountId();
  }

  async account(acc_id: string): Promise<Account> {
    return this.near.account(acc_id);
  }

  async get_balance(acc_id: string): Promise<number | null> {
    const account = await this.account(acc_id);
    let balance = null;
    try {
      const b = await account.getAccountBalance();
      balance = fromNear(b.total);
    } catch (e) {
      console.error('Account not exist');
    }
    return balance;
  }
}

export default NearApi;

'''
'''--- src/services/chartHelpers.ts ---
import { Big } from 'big.js';

import {
  TSchedule, TNearTimestamp, TNearAmount, TCheckpoint,
} from './api';
import { formatTokenAmount } from '../utils';
import { sumSchedules, terminateScheduleAtAmount, shatterSchedule } from './scheduleHelpers';

const buildVestedSchedule = (from: TNearTimestamp, balance: TNearAmount) => [
  { timestamp: from - 1, balance: '0' },
  { timestamp: from, balance },
];

export const chartData = (lockupsList: any[], tokenDecimals: number): any => {
  const startTime = new Date();
  console.log(`chartData([${lockupsList.length}]): start ${startTime}`);

  const lockupSchedules = Array.from(
    lockupsList.map((x) => x.schedule),
  ) as TSchedule[];

  const now = Math.round(new Date().getTime() / 1000);
  const minTimestampsLockup = lockupsList.map((x) => x.schedule[0].timestamp);
  const minTimestampsVesting = lockupsList.map((x) => x?.termination_config?.vesting_schedule[0]?.timestamp).filter((x) => x);

  const minTimestamp = Math.min(...minTimestampsLockup, ...minTimestampsVesting, now);

  const vestingSchedules = Array.from(
    lockupsList.map((x) => {
      // for lockups and drafts
      const result = x?.termination_config?.vesting_schedule?.Schedule
        || x?.vesting_schedule?.Schedule;
      if (result) return result;
      return result || buildVestedSchedule(minTimestamp, x.schedule[x.schedule.length - 1].balance);
    }),
  ) as TSchedule[];

  let sumVesting = sumSchedules(vestingSchedules);
  let sumLockup = sumSchedules(lockupSchedules);

  if (sumVesting.length > 0) {
    if (sumVesting[sumVesting.length - 1].timestamp < sumLockup[sumLockup.length - 1].timestamp) {
      sumVesting.push(sumLockup[sumLockup.length - 1]);
    }
    if (sumVesting[sumVesting.length - 1].timestamp > sumLockup[sumLockup.length - 1].timestamp) {
      sumLockup.push(sumVesting[sumVesting.length - 1]);
    }
  }

  const convertSchedule = (schedule: TSchedule, decimals: number) => schedule.map((s: TCheckpoint) => [s.timestamp * 1000, formatTokenAmount(s.balance, decimals)]);

  const totalClaimed = lockupsList.map((x) => x.claimed_balance || '0').reduce((acc, x) => new Big(acc).add(new Big(x)).toFixed(), '0');

  // trim lockup schedule at claimed amount
  let sumClaimed = terminateScheduleAtAmount(sumLockup, totalClaimed, 0);

  if (sumClaimed[sumClaimed.length - 1]?.timestamp !== sumLockup[sumLockup.length - 1].timestamp) {
    sumClaimed.push({
      timestamp: sumLockup[sumLockup.length - 1].timestamp,
      balance: sumClaimed[sumClaimed.length - 1].balance,
    });
  }

  const existingCheckpoints = [sumLockup, sumVesting, sumClaimed]
    .flatMap((schedule) => schedule.map((x) => x.timestamp));

  const realMinTimestamp = Math.min(...existingCheckpoints);
  const maxTimestamp = Math.max(...existingCheckpoints);

  const dailyCheckpoints = [];
  for (let i = ((realMinTimestamp - 1) / (60 * 60 * 24) + 1) * (60 * 60 * 24); i < maxTimestamp; i += (60 * 60 * 24)) {
    dailyCheckpoints.push(i);
  }
  const allCheckpoints = [...existingCheckpoints, ...dailyCheckpoints];

  sumClaimed = shatterSchedule(sumClaimed, allCheckpoints);
  sumLockup = shatterSchedule(sumLockup, allCheckpoints);
  sumVesting = shatterSchedule(sumVesting, allCheckpoints);

  const finishTime = new Date();
  console.log(`chartData([${lockupsList.length}]): finish ${startTime} duration ${(finishTime.getTime() - startTime.getTime()) / 1000}`);

  return {
    unlocked: lockupsList.length ? convertSchedule(sumLockup, tokenDecimals) : [],
    vested: lockupsList.length ? convertSchedule(sumVesting, tokenDecimals) : [],
    claimed: lockupsList.length ? convertSchedule(sumClaimed, tokenDecimals) : [],
  };
};

export default chartData;

'''
'''--- src/services/factoryApi.ts ---
import Big from 'big.js';

import {
  Contract, WalletConnection,
} from 'near-api-js';

const MAX_GAS = 300_000_000_000_000;
const DEPLOY_DEPOSIT = new Big(10).mul(new Big(10).pow(24)).toString();

const FACTORY_CHANGE_METHODS = [
  'create',
];

type TFactoryChangeMethods = {
  'create': (opts: {
    args: { name: string, init_function: string, init_args: string },
    callbackUrl: string,
    amount: string | number,
    gas: string | number
  }) => any,
};

type TFactoryContract = Contract & TFactoryChangeMethods;

class FactoryApi {
  private contract: TFactoryContract;

  constructor(walletConnection: WalletConnection, contractId: string) {
    this.contract = new Contract(
      walletConnection.account(),
      contractId,
      { viewMethods: [], changeMethods: FACTORY_CHANGE_METHODS },
    ) as TFactoryContract;
  }

  getContract(): TFactoryContract {
    return this.contract;
  }

  async create(
    name: string,
    tokenAccountId: string,
    depositWhitelist: string[],
    draftOperatorsWhitelist: string[],
    callbackUrl: string,
  ): Promise<void> {
    const argsRaw = {
      token_account_id: tokenAccountId,
      deposit_whitelist: depositWhitelist,
      draft_operators_whitelist: draftOperatorsWhitelist,
    };
    const argsPacked = JSON.stringify(argsRaw);
    const result = await this.contract.create({
      args: {
        name,
        init_function: 'new',
        init_args: argsPacked,
      },
      callbackUrl,
      gas: MAX_GAS,
      amount: DEPLOY_DEPOSIT,
    });

    console.log(result);

    return result;
  }
}

export default FactoryApi;

'''
'''--- src/services/near.ts ---
import * as nearAPI from 'near-api-js';
import { createContext } from 'react';
import { config as configTemplate } from '../config';
import { restoreLocalStorage } from '../utils';
import NearApi from './api';
import NoLoginApi from './noLoginApi';
import NoLoginTokenApi from './NoLoginTokenApi';
import TokenApi from './tokenApi';
import FactoryApi from './factoryApi';
import { daoCouncilMembers } from './DAOs/astroDAO/utils';

export interface INearConfig {
  contractName: string,
  networkId: string,
  nodeUrl: string,
  walletUrl: string,
  helperUrl: string,
  explorerUrl: string,
  factoryContractName: string,
}

export interface INearProps {
  config: INearConfig;
  api: NearApi;
  noLoginApi: NoLoginApi
  currentUser: {
    signedIn: boolean;
    isAdmin: boolean;
    isDraftOperator: boolean;
    isCouncilMember: boolean;
    signedAccountId: string | null;
    daos: string[];
  }
  tokenContractId: string;
  lockupContractId: string;
  lockupContractFound: boolean;
  lockupContractNone: boolean;
  tokenApi: TokenApi;
  noLoginTokenApi: NoLoginTokenApi;
  factoryApi: FactoryApi;
  rpcProvider: nearAPI.providers.JsonRpcProvider;
  isContractFtStoragePaid: boolean;
  near: nearAPI.Near;
  suggestConvertDialog: {
    open: boolean,
    setOpen: (newValue: boolean) => any,
  }
}

export const NearContext = createContext<any>(null);

export const connectNear = async (): Promise<INearProps> => {
  if (localStorage.getItem('dump')) {
    restoreLocalStorage();
  }

  let lockupContractId = window.location.hash.split('/')[1] || '';
  if (['', 'terms', 'privacy', 'about', 'new_lockup_contract'].some((x) => lockupContractId === x)) {
    lockupContractId = 'lockup_contract_none';
  }
  const config: INearConfig = { ...configTemplate, contractName: lockupContractId };

  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
  const near = await nearAPI.connect({ headers: {}, keyStore, ...config });
  const api = new NearApi(near);

  const noLoginKeyStore = new nearAPI.keyStores.InMemoryKeyStore();
  const noLoginNear = await nearAPI.connect({ headers: {}, keyStore: noLoginKeyStore, ...config });
  const noLoginApi = new NoLoginApi(noLoginNear);
  const noLoginTokenApi = new NoLoginTokenApi(noLoginNear);

  const walletConnection = new nearAPI.WalletConnection(near, config.contractName);
  const signedAccountId = walletConnection.getAccountId();
  let tokenContractId: string = 'lockup_contract_not_found';
  let isAdmin: boolean = false;
  let isDraftOperator: boolean = false;
  let depositWhitelist: string[] = [];
  let draftOperatorsWhitelist: string[] = [];
  let daos: string[] = [];
  let lockupContractFound = false;
  try {
    tokenContractId = await api.getTokenAccountId();
    depositWhitelist = await api.getDepositWhitelist();
    draftOperatorsWhitelist = await api.getDraftOperatorsWhitelist();
    console.log('depositWhitelist', depositWhitelist);
    isAdmin = depositWhitelist.includes(signedAccountId);
    console.log('isAdmin', isAdmin);
    isDraftOperator = draftOperatorsWhitelist.includes(signedAccountId);
    console.log('isDraftOperator', isDraftOperator);
    const dcm = daoCouncilMembers;
    console.log(dcm);
    const daosCouncilMembers = (await Promise.all(depositWhitelist.map((dwID): Promise<any[]> => daoCouncilMembers(walletConnection, dwID)))).filter((value) => !!value);
    console.log(daosCouncilMembers);
    const userDaosCouncils = daosCouncilMembers.filter((daoCMs) => Object.values(daoCMs).pop().includes(signedAccountId));
    if (userDaosCouncils?.length > 0) {
      daos = userDaosCouncils.map((daoCMs) => Object.keys(daoCMs).pop() || '');
    }
    console.log('userDaosCouncils', userDaosCouncils);
    console.log('councilMembers', daosCouncilMembers);
    console.log('daos', daos);
  } catch (e) {
    console.log(e);
    const nearConnectionError: any = e;
    if (nearConnectionError.type === 'AccountDoesNotExist') {
      console.log('contract not found');
    } else {
      console.log(`UNKNOWN ERROR: ${e}`);
    }
  }
  const tokenApi = new TokenApi(walletConnection, tokenContractId);

  let isContractFtStoragePaid = false;

  try {
    const storageBalance = await tokenApi.storageBalanceOf(lockupContractId);
    // successful read of data from token contract AND lockup contract
    lockupContractFound = true;
    isContractFtStoragePaid = (storageBalance !== null) && true;
    console.log(isContractFtStoragePaid);
  } catch (e) {
    console.log(e);
  }

  const factoryApi = new FactoryApi(
    walletConnection,
    config.factoryContractName,
  );

  const rpcProvider = new nearAPI.providers.JsonRpcProvider(
    config.nodeUrl,
  );

  return {
    config,
    api,
    tokenContractId,
    noLoginApi,
    tokenApi,
    factoryApi,
    currentUser: {
      signedIn: !!signedAccountId,
      isAdmin,
      isDraftOperator,
      isCouncilMember: daos.length > 0,
      signedAccountId,
      daos,
    },
    noLoginTokenApi,
    rpcProvider,
    isContractFtStoragePaid,
    lockupContractId,
    lockupContractFound,
    lockupContractNone: lockupContractId === 'lockup_contract_none',
    near,
    suggestConvertDialog: {
      open: false,
      setOpen: () => null,
    },
  };
};

'''
'''--- src/services/noLogInUsage.ts ---
const getFirstFullAccessKey = async (provider: any, accountId: String): Promise<any> => {
  const allAccessKeys = await provider.query({
    request_type: 'view_access_key_list',
    account_id: accountId,
    finality: 'optimistic',
  });

  if (!allAccessKeys.keys?.length) {
    throw Error('None of access keys was founded');
  }

  const allFullAccessKeys = allAccessKeys.keys.filter((key: any) => (typeof key?.access_key?.permission === 'string') && key?.access_key?.permission === 'FullAccess');

  if (!allFullAccessKeys?.length) {
    throw Error('None of full access keys was founded');
  }

  return allFullAccessKeys[0];
};

export default getFirstFullAccessKey;

'''
'''--- src/services/noLoginApi.ts ---
import {
  Near, Contract, WalletConnection,
} from 'near-api-js';
import { MAX_GAS, dumpLocalStorage } from '../utils';
import getFirstFullAccessKey from './noLogInUsage';

const LOCKUP_VIEW_METHODS = [''];
const LOCKUP_CHANGE_METHODS = ['claim'];

type TChangeMethods = {
  'claim': any,
};

type TLockupContract = Contract & TChangeMethods;

class NoLoginApi {
  private near: Near;

  constructor(near: Near) {
    this.near = near;
  }

  async claim(accountId: string): Promise<void> {
    dumpLocalStorage();

    await this.setWalletAndContractWithAuth(accountId);

    await this.buildContract().claim({}, MAX_GAS);

    this.near.config.keyStore.clean();
  }

  async claimSpecificLockups(accountId: string, lockupIds: number[]): Promise<void> {
    dumpLocalStorage();

    await this.setWalletAndContractWithAuth(accountId);

    await this.buildContract().claim({ amounts: lockupIds.map((x) => [x, null]) }, MAX_GAS);

    this.near.config.keyStore.clean();
  }

  async setWalletAndContractWithAuth(
    accountId: string,
    contractName: string = this.near.config.contractName,
  ): Promise<any> {
    const firstFullAccessKey = await getFirstFullAccessKey(
      this.near.connection.provider,
      accountId,
    );

    localStorage.setItem(
      `${contractName}_wallet_auth_key`,
      JSON.stringify({ accountId, allKeys: [firstFullAccessKey.public_key] }),
    );
  }

  buildContract(): TLockupContract {
    return new Contract(
      (new WalletConnection(this.near, this.near.config.contractName)).account(),
      this.near.config.contractName,
      { viewMethods: LOCKUP_VIEW_METHODS, changeMethods: LOCKUP_CHANGE_METHODS },
    ) as TLockupContract;
  }
}

export default NoLoginApi;

'''
'''--- src/services/scheduleHelpers.test.ts ---
import {
  interpolate, interpolateRaw, interpolateSchedule, sumSchedules,
  assertValidTerminationSchedule, terminateSchedule, interpolateRawAtY,
  interpolateAtY, terminateScheduleAtAmount, shatterSchedule,
} from './scheduleHelpers';

describe('interpolateRaw test', () => {
  it('test interpolate doesn\'t throw', () => {
    interpolateRaw(1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), 1_550_000_000);
  });
  it('raises error if invalid input', () => {
    expect(() => interpolateRaw(
      1_800_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      1_550_000_000,
    )).toThrow('invalid range');
    expect(() => interpolateRaw(
      1_500_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      1_450_000_000,
    )).toThrow('xM out of bound');
    expect(() => interpolateRaw(
      1_500_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      1_750_000_000,
    )).toThrow('xM out of bound');
  });
  it('returns starting value at the beginning of range', () => {
    expect(interpolateRaw(1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), 1_500_000_000))
      .toStrictEqual((10_000).toString());
  });
  it('returns valid intermediate value', () => {
    expect(interpolateRaw(1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), 1_550_000_000))
      .toStrictEqual((11_000).toString());
  });

  it('doesnt round less significant digits', () => {
    expect(
      interpolateRaw(
        1_500_000_000, (0).toString(),
        1_800_000_000, (1_000_000_000_000_000_000_000_000).toString(),
        1_700_000_000,
      )
    )
      .toStrictEqual(('666_666_666_666_666_666_666_666'.replaceAll('_', '')).toString());
  });
});

describe('interpolateRawAtY test', () => {
  it('test interpolate doesnt throw', () => {
    interpolateRawAtY(1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), (11_000).toString());
  });
  it('raises error if invalid input', () => {
    expect(() => interpolateRawAtY(
      1_800_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      (11_000).toString(),
    )).toThrow('invalid range');
    expect(() => interpolateRawAtY(
      1_500_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      (9_000).toString(),
    )).toThrow('yM out of bound');
    expect(() => interpolateRawAtY(
      1_500_000_000,
      (10_000).toString(),
      1_700_000_000,
      (14_000).toString(),
      (15_000).toString(),
    )).toThrow('yM out of bound');
  });
  it('returns starting value at the beginning of range', () => {
    expect(interpolateRawAtY(
      1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), (10_000).toString())
    ).toStrictEqual(1_500_000_000);
  });
  it('returns valid intermediate value', () => {
    expect(interpolateRawAtY(
      1_500_000_000, (10_000).toString(), 1_700_000_000, (14_000).toString(), (11_000).toString())
    ).toStrictEqual(1_550_000_000);
  });

  it('doesnt round less significant digits', () => {
    expect(
      interpolateRawAtY(
        1_500_000_000, (0).toString(),
        1_600_000_000, '3_000_000_000_000_000_000_000_000'.replaceAll('_', ''),
        '1_000_000_000_000_000_000_000_000'.replaceAll('_', ''),
      )
    )
      .toStrictEqual(1_533_333_334);
  });
});

describe('interpolate test', () => {
  it('returns valid intermediate value', () => {
    expect(interpolate(
      { timestamp: 1_500_000_000, balance: '10000' },
      { timestamp: 1_700_000_000, balance: '14000' },
      1_550_000_000,
    )).toStrictEqual({ timestamp: 1_550_000_000, balance: '11000' });
  });
});

describe('interpolateAtY test', () => {
  it('returns valid intermediate value', () => {
    expect(interpolateAtY(
      { timestamp: 1_500_000_000, balance: '10000' },
      { timestamp: 1_700_000_000, balance: '14000' },
      '11000',
    )).toStrictEqual({ timestamp: 1_550_000_000, balance: '11000' });
  });
});

describe('interpolateSchedule test', () => {
  const schedule = [
    { timestamp: 1_500_000_000, balance: '0' },
    { timestamp: 1_599_999_999, balance: '0' },
    { timestamp: 1_600_000_000, balance: '15000' },
    { timestamp: 1_900_000_000, balance: '60000' },
  ];
  it('handles empty schedule', () => {
    // if schedule is empty throw error
    expect(() => interpolateSchedule(
      [],
      1_550_000_000,
    )).toThrow('empty schedule');
  });
  // if timestamp before schedule stamp returns first checkpoint
  it('handles timestamp before schedule', () => {
    const timestamp1 = 1_450_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp1,
    )).toStrictEqual({ timestamp: timestamp1, balance: '0' });
    const timestamp2 = 1_500_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp2,
    )).toStrictEqual({ timestamp: timestamp2, balance: '0' });
  });
  // if timestamp after schedule stamp returns last checkpoint
  it('handles timestamp after schedule', () => {
    const timestamp1 = 1_950_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp1,
    )).toStrictEqual({ timestamp: timestamp1, balance: '60000' });
    const timestamp2 = 1_900_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp2,
    )).toStrictEqual({ timestamp: timestamp2, balance: '60000' });
  });
  // if timestamp matches checkpoint from schedule return checkpoint from schedule
  it('handles timestamp that matches checkpoint from schedule', () => {
    const timestamp0 = 1_599_999_999;
    expect(interpolateSchedule(
      schedule,
      timestamp0,
    )).toStrictEqual({ timestamp: timestamp0, balance: '0' });
    const timestamp1 = 1_600_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp1,
    )).toStrictEqual({ timestamp: timestamp1, balance: '15000' });
  });
  // if between two checkpoints returns interpolated value
  it('handles timestamp between two checkpoints', () => {
    const timestamp0 = 1_550_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp0,
    )).toStrictEqual({ timestamp: timestamp0, balance: '0' });
    const timestamp1 = 1_700_000_000;
    expect(interpolateSchedule(
      schedule,
      timestamp1,
    )).toStrictEqual({ timestamp: timestamp1, balance: '30000' });
  });
});
describe('sumSchedules', () => {
  it('doesnt throw', () => {
    const schedule1 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_900_000_000, balance: '60000' },
    ];
    const schedule2 = [
      { timestamp: 1_600_000_000, balance: '0' },
      { timestamp: 1_700_000_000, balance: '20000' },
    ];
    sumSchedules([schedule1, schedule2]);
  });
  // should return expected
  it('should return expected1', () => {
    const schedule1 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_900_000_000, balance: '60000' },
    ];
    const schedule2 = [
      { timestamp: 1_600_000_000, balance: '0' },
      { timestamp: 1_700_000_000, balance: '20000' },
    ];
    const expected1 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '15000' },
      { timestamp: 1_700_000_000, balance: '50000' },
      { timestamp: 1_900_000_000, balance: '80000' },
    ];
    expect(sumSchedules([schedule1, schedule2])).toStrictEqual(expected1);
  });
  it('should return expected2', () => {
    const schedule3 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_700_000_000, balance: '20000' },
    ];
    const schedule4 = [
      { timestamp: 1_600_000_000, balance: '0' },
      { timestamp: 1_900_000_000, balance: '60000' },
    ];
    const expected2 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '10000' },
      { timestamp: 1_700_000_000, balance: '40000' },
      { timestamp: 1_900_000_000, balance: '80000' },
    ];
    expect(sumSchedules([schedule3, schedule4])).toStrictEqual(expected2);
  });
  it('should return expected3', () => {
    const schedule5 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
    ];
    const schedule6 = [
      { timestamp: 1_700_000_000, balance: '0' },
      { timestamp: 1_900_000_000, balance: '60000' },
    ];
    const expected3 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '20000' },
      { timestamp: 1_900_000_000, balance: '80000' },
    ];
    expect(sumSchedules([schedule5, schedule6])).toStrictEqual(expected3);
  });
  it('should return expected4', () => {
    const schedule7 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];
    const schedule8 = [
      { timestamp: 1_550_000_000, balance: '0' },
      { timestamp: 1_650_000_000, balance: '20000' },
      { timestamp: 1_750_000_000, balance: '30000' },
    ];
    const expected4 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_550_000_000, balance: '10000' },
      { timestamp: 1_600_000_000, balance: '30000' },
      { timestamp: 1_650_000_000, balance: '45000' },
      { timestamp: 1_700_000_000, balance: '55000' },
      { timestamp: 1_750_000_000, balance: '60000' },
    ];
    expect(sumSchedules([schedule7, schedule8])).toStrictEqual(expected4);
  });
  it('should return expected5', () => {
    const schedule09 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '10000' },
      { timestamp: 1_700_000_000, balance: '10000' },
      { timestamp: 1_800_000_000, balance: '20000' },
    ];
    const schedule10 = [
      { timestamp: 1_600_000_000, balance: '0' },
      { timestamp: 1_700_000_000, balance: '20000' },
      { timestamp: 1_800_000_000, balance: '20000' },
      { timestamp: 1_900_000_000, balance: '40000' },
    ];
    const expected5 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '10000' },
      { timestamp: 1_700_000_000, balance: '30000' },
      { timestamp: 1_800_000_000, balance: '40000' },
      { timestamp: 1_900_000_000, balance: '60000' },
    ];
    expect(sumSchedules([schedule09, schedule10])).toStrictEqual(expected5);
  });
  it('should return expected6', () => {
    const expected6 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '60000' },
      { timestamp: 1_700_000_000, balance: '90000' },
    ];
    const schedule7 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];
    expect(sumSchedules([schedule7, schedule7, schedule7])).toStrictEqual(expected6);
  });
  // if schedule1 passed returns this schedule
  it('handles schedule1 passed return schedule2', () => {
    const schedule2 = [
      { timestamp: 1_600_000_000, balance: '0' },
      { timestamp: 1_700_000_000, balance: '20000' },
    ];
    expect(sumSchedules([schedule2])).toStrictEqual(schedule2);
  });
});

describe('assertValidTerminationSchedule', () => {
  it('doesnt fail on same lockup schedule', () => {
    const schedule = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];
    expect(() => assertValidTerminationSchedule(schedule, schedule)).not.toThrow();
  });
  it('doesnt fail on lagging vesting schedule', () => {
    const lockupSchedule = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];
    let buildVestingSchedule = (offset: number) => {
      return [
        { timestamp: 1_500_000_000 + offset, balance: '0' },
        { timestamp: 1_600_000_000 + offset, balance: '20000' },
        { timestamp: 1_700_000_000 + offset, balance: '30000' },
      ];
    };
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(-1))).not.toThrow();
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(-50_000_000))).not.toThrow();
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(-500_000_000))).not.toThrow();

    const vestingSchedule2 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_900_000_000, balance: '100000' },
    ];

    expect(() => assertValidTerminationSchedule(lockupSchedule, vestingSchedule2)).not.toThrow();
  });

  it('fails on leading lockup schedule', () => {
    const lockupSchedule = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];
    let buildVestingSchedule = (offset: number) => {
      return [
        { timestamp: 1_500_000_000 + offset, balance: '0' },
        { timestamp: 1_600_000_000 + offset, balance: '20000' },
        { timestamp: 1_700_000_000 + offset, balance: '30000' },
      ];
    };
    let error = /is ahead of/;
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(1))).toThrow(error);
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(50_000_000))).toThrow(error);
    expect(() => assertValidTerminationSchedule(lockupSchedule, buildVestingSchedule(500_000_000))).toThrow(error);

    const vestingSchedule2 = [
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '25000' },
    ];

    expect(() => assertValidTerminationSchedule(lockupSchedule, vestingSchedule2)).toThrow(error);

    const vestingSchedule3 = [
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '15000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ];

    expect(() => assertValidTerminationSchedule(lockupSchedule, vestingSchedule3)).toThrow(error);
  });
});

describe('terminateSchedule', () => {
  const schedule = [
    { timestamp: 1_500_000_000, balance: '0' },
    { timestamp: 1_600_000_000, balance: '20000' },
    { timestamp: 1_700_000_000, balance: '30000' },
  ];

  it('before schedule', () => {
    expect(terminateSchedule(schedule, 1_400_000_000)).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_500_000_001, balance: '0' },
    ]);
  });

  it('intermediate first segment', () => {
    expect(terminateSchedule(schedule, 1_525_000_000)).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_525_000_000, balance: '5000' },
    ]);
  });

  it('midpoint', () => {
    expect(terminateSchedule(schedule, 1_600_000_000)).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
    ]);
  });

  it('intermediate second segment', () => {
    expect(terminateSchedule(schedule, 1_625_000_000)).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_625_000_000, balance: '22500' },
    ]);
  });

  it('after schedule end', () => {
    expect(terminateSchedule(schedule, 1_750_000_000)).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ]);
  });
});

describe('terminateScheduleAtAmount', () => {
  const schedule = [
    { timestamp: 1_400_000_000, balance: '0' },
    { timestamp: 1_500_000_000, balance: '0' },
    { timestamp: 1_600_000_000, balance: '20000' },
    { timestamp: 1_700_000_000, balance: '30000' },
  ];

  it('before schedule', () => {
    expect(terminateScheduleAtAmount(schedule, '0', 1_350_000_000)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_400_000_001, balance: '0' },
    ]);
  });

  it('before schedule', () => {
    expect(terminateScheduleAtAmount(schedule, '0', 1_450_000_000)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_450_000_000, balance: '0' },
    ]);
  });

  it('intermediate first segment', () => {
    expect(terminateScheduleAtAmount(schedule, '5000', 1234567890)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_525_000_000, balance: '5000' },
    ]);
  });

  it('midpoint', () => {
    expect(terminateScheduleAtAmount(schedule, '20000', 1234567890)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
    ]);
  });

  it('intermediate second segment', () => {
    expect(terminateScheduleAtAmount(schedule, '22500', 123456789)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_625_000_000, balance: '22500' },
    ]);
  });

  it('after schedule end', () => {
    expect(terminateSchedule(schedule, 1_750_000_000)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ]);
  });

  const schedule2 = [
    { timestamp: 1_400_000_000, balance: '0' },
    { timestamp: 1_500_000_000, balance: '10000' },
    { timestamp: 1_600_000_000, balance: '10000' },
    { timestamp: 1_700_000_000, balance: '10000' },
    { timestamp: 1_800_000_000, balance: '20000' },
  ];

  it('with plateau clash', () => {
    expect(terminateScheduleAtAmount(schedule2, '10000', 1234567890)).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '10000' },
    ]);
  });
});

describe('shatterSchedule', () => {
  const schedule = [
    { timestamp: 1_500_000_000, balance: '0' },
    { timestamp: 1_600_000_000, balance: '20000' },
    { timestamp: 1_700_000_000, balance: '30000' },
  ];

  it('insert between', () => {
    expect(shatterSchedule(schedule, [
      1_400_000_000,
      1_750_000_000,
      1_625_000_000,
      1_525_000_000,
    ])).toStrictEqual([
      { timestamp: 1_400_000_000, balance: '0' },
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_525_000_000, balance: '5000' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_625_000_000, balance: '22500' },
      { timestamp: 1_700_000_000, balance: '30000' },
      { timestamp: 1_750_000_000, balance: '30000' },
    ]);
  });

  it('insert matching', () => {
    expect(shatterSchedule(schedule, [
      1_700_000_000,
      1_500_000_000,
      1_600_000_000,
    ])).toStrictEqual([
      { timestamp: 1_500_000_000, balance: '0' },
      { timestamp: 1_600_000_000, balance: '20000' },
      { timestamp: 1_700_000_000, balance: '30000' },
    ]);
  });
});

'''
'''--- src/services/scheduleHelpers.ts ---
import { Big } from 'big.js';
import { TCheckpoint, TNearTimestamp, TSchedule } from './api';
import { pseudoUtcIsoDateTime } from '../utils';

export const interpolateRaw = (x0: number, y0: string, x1: number, y1: string, xM: number) : string => {
  if (x1 <= x0) {
    throw new Error('invalid range');
  }
  if (xM < x0 || xM >= x1) {
    throw new Error('xM out of bound');
  }

  const yM = new Big(y0).add(
    (new Big(y1).sub(new Big(y0)))
      .mul(new Big(xM.toString()).sub(new Big(x0.toString())))
      .div(new Big(x1.toString()).sub(new Big(x0.toString()))),
  );

  return yM.toFixed(0, Big.roundDown);
};

export const interpolateRawAtY = (x0: number, y0: string, x1: number, y1: string, yM: string) : TNearTimestamp => {
  if (x1 <= x0) {
    throw new Error('invalid range');
  }
  if (new Big(yM).lt(new Big(y0)) || new Big(yM).gte(y1)) {
    throw new Error('yM out of bound');
  }

  const xM = new Big(x0).add(
    (new Big(x1).sub(new Big(x0)))
      .mul(new Big(yM.toString()).sub(new Big(y0.toString())))
      .div(new Big(y1.toString()).sub(new Big(y0.toString()))),
  );

  return parseInt(xM.toFixed(0, Big.roundUp), 10);
};

export const interpolate = (checkpoint0: TCheckpoint, checkpoint1: TCheckpoint, timestamp: TNearTimestamp) : TCheckpoint => {
  const balance = interpolateRaw(
    checkpoint0.timestamp,
    checkpoint0.balance,
    checkpoint1.timestamp,
    checkpoint1.balance,
    timestamp,
  );

  return { timestamp, balance };
};

export const interpolateAtY = (checkpoint0: TCheckpoint, checkpoint1: TCheckpoint, balance: string) : TCheckpoint => {
  const timestamp = interpolateRawAtY(
    checkpoint0.timestamp,
    checkpoint0.balance,
    checkpoint1.timestamp,
    checkpoint1.balance,
    balance,
  );

  return { timestamp, balance };
};

export const interpolateSchedule = (schedule: TCheckpoint[], timestamp: TNearTimestamp) : TCheckpoint => {
  if (schedule.length === 0) {
    throw new Error('empty schedule');
  }

  if (timestamp < schedule[0].timestamp) {
    return { timestamp, balance: schedule[0].balance };
  }

  if (timestamp >= schedule[schedule.length - 1].timestamp) {
    return { timestamp, balance: schedule[schedule.length - 1].balance };
  }

  // eslint-disable-next-line no-plusplus
  for (let i = 0; i < schedule.length - 1; i++) {
    if (schedule[i + 1].timestamp <= timestamp) {
      // eslint-disable-next-line no-continue
      continue;
    }
    return interpolate(schedule[i], schedule[i + 1], timestamp);
  }

  throw new Error('unreachable');
};

export const sumSchedules = (schedules: TSchedule[]) : TSchedule => {
  if (schedules.length === 0) {
    throw new Error('schedules is empty');
  }

  const timestamps = Array.from(new Set(schedules.flat().map((x) => x.timestamp).sort(
    (x, y) => x - y,
  )));

  const result: TSchedule = [];

  timestamps.forEach((timestamp:TNearTimestamp) => {
    let amount = new Big(0);
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < schedules.length; i++) {
      const balance = new Big(interpolateSchedule(schedules[i], timestamp).balance);
      amount = amount.plus(balance);
    }
    result.push({ timestamp, balance: amount.toString() });
  });

  return result;
};

export const assertValidTerminationSchedule = (lockupSchedule: TSchedule, vestingSchedule: TSchedule) => {
  const f = (x: number) => `${pseudoUtcIsoDateTime(x)} UTC`;

  lockupSchedule.forEach((checkpoint) => {
    const { timestamp } = checkpoint;
    const lockupBalance = checkpoint.balance;
    const vestingBalance = interpolateSchedule(vestingSchedule, timestamp).balance;
    if (!(new Big(lockupBalance).lte(new Big(vestingBalance)))) {
      throw new Error(`The lockup schedule is ahead of the termination schedule at ${f(timestamp)} (${timestamp})`);
    }
  });
  vestingSchedule.forEach((checkpoint) => {
    const { timestamp } = checkpoint;
    const lockupBalance = interpolateSchedule(lockupSchedule, timestamp).balance;
    const vestingBalance = checkpoint.balance;
    if (!(new Big(lockupBalance).lte(new Big(vestingBalance)))) {
      throw new Error(`The lockup schedule is ahead of the termination schedule at ${f(timestamp)} (${timestamp})`);
    }
  });
};

export const terminateSchedule = (schedule: TSchedule, timestamp: TNearTimestamp) => {
  if (schedule.length === 0) {
    throw new Error('empty schedule');
  }

  if (timestamp <= schedule[0].timestamp) {
    return [
      schedule[0],
      { timestamp: schedule[0].timestamp + 1, balance: schedule[0].balance },
    ];
  }

  if (timestamp >= schedule[schedule.length - 1].timestamp) {
    return schedule.slice(0, schedule.length);
  }

  const result = [];

  for (let i = 0; i < schedule.length - 1; i += 1) {
    result.push(schedule[i]);

    if (timestamp < schedule[i + 1].timestamp) {
      const finishCheckpoint = interpolate(schedule[i], schedule[i + 1], timestamp);
      result.push(finishCheckpoint);
      return result;
    }

    if (timestamp === schedule[i + 1].timestamp) {
      result.push(schedule[i + 1]);
      return result;
    }
  }

  throw new Error('unreachable');
};

export const terminateScheduleAtAmount = (schedule: TSchedule, amount: string, finishTimestamp: TNearTimestamp) => {
  if (schedule.length === 0) {
    throw new Error('empty schedule');
  }

  if (new Big(amount).eq(new Big('0'))) {
    return [
      schedule[0],
      { timestamp: Math.max(schedule[0].timestamp + 1, finishTimestamp), balance: schedule[0].balance },
    ];
  }

  if (new Big(amount).gte(new Big(schedule[schedule.length - 1].balance))) {
    return schedule.slice(0, schedule.length);
  }

  const result = [];

  for (let i = 0; i < schedule.length - 1; i += 1) {
    result.push(schedule[i]);

    if (new Big(amount).lt(new Big(schedule[i + 1].balance))) {
      const finishCheckpoint = interpolateAtY(schedule[i], schedule[i + 1], amount);
      result.push(finishCheckpoint);
      return result;
    }

    if (new Big(amount).eq(new Big(schedule[i + 1].balance))) {
      result.push(schedule[i + 1]);
      return result;
    }
  }

  throw new Error('unreachable');
};

export type TBalancesRaw = {
  claimed: string,
  unclaimed: string,
  vested: string,
  unvested: string,
  total: string,
};

export const calcBalancesRaw = (row: any, now: number): TBalancesRaw => {
  const totalBalanceRaw = row.schedule[row.schedule.length - 1].balance;
  const claimedBalanceRaw = row.claimed_balance || '0';

  const unclaimedBalanceRaw = new Big(interpolateSchedule(row.schedule, now).balance).sub(new Big(claimedBalanceRaw)).toFixed();
  let vestedBalanceFullRaw = null;
  const vestingSchedule = row.vesting_schedule?.Schedule || row.termination_config?.vesting_schedule?.Schedule;
  if (vestingSchedule) {
    vestedBalanceFullRaw = interpolateSchedule(vestingSchedule, now).balance;
  } else {
    vestedBalanceFullRaw = row.schedule[row.schedule.length - 1].balance;
  }
  const vestedBalanceRaw = new Big(vestedBalanceFullRaw)
    .sub(new Big(claimedBalanceRaw))
    .sub(new Big(unclaimedBalanceRaw))
    .toString();
  const unvestedBalanceRaw = new Big(totalBalanceRaw)
    .sub(new Big(vestedBalanceFullRaw))
    .toString();
  console.log(totalBalanceRaw, claimedBalanceRaw, unclaimedBalanceRaw, vestedBalanceRaw, unvestedBalanceRaw);

  return {
    claimed: claimedBalanceRaw,
    unclaimed: unclaimedBalanceRaw,
    vested: vestedBalanceRaw,
    unvested: unvestedBalanceRaw,
    total: totalBalanceRaw,
  };
};

export const shatterSchedule = (schedule: TSchedule, extraTimestamps: TNearTimestamp[]) => {
  const presentTimestamps = schedule.map((x) => x.timestamp);
  const timestamps: number[] = Array.from(new Set([...presentTimestamps, ...extraTimestamps])).sort();
  const result = timestamps.map((timestamp) => interpolateSchedule(schedule, timestamp));
  return result;
};

'''
'''--- src/services/spreadsheetImport.test.ts ---
import {
  datePlusDurationMul,
  parseValidAccountId,
  parseTokenAmount,
  parseCliffInfo,
  parseSpreadsheetColumns,
  parseHumanFriendlySchedule,
  parseDuration,
  parseLockup,
  parseRawSpreadsheetInput,
  parseTimestamp,
  parseToSpreadsheetRow,
  parseSpreadsheetToSpreadsheetRows,
  toLockupSchedule,
  toUnix,
} from './spreadsheetImport';

describe('.parseSpreadsheetColumns', () => {
  it('parses empty string', () => {
    expect(parseSpreadsheetColumns('')).toStrictEqual([]);
  });

  it('parses multiple rows', () => {
    let actual = parseSpreadsheetColumns(`
      id	name	bio
      10	John Doe	Traveller, worker
      20	Foma Kinyaev	Secret agent
    `);
    let expected = [
      { id: '10', name: 'John Doe', bio: 'Traveller, worker' },
      { id: '20', name: 'Foma Kinyaev', bio: 'Secret agent' },
    ];
    expect(actual).toStrictEqual(expected);
  });

  it('trims each cell value', () => {
    let actual = parseSpreadsheetColumns(`
      column with space  	  second column  
      first value  	  second value  
    `);
    let expected = [{ 'column with space': 'first value', 'second column': 'second value' }];
    expect(actual).toStrictEqual(expected);
  });
});

describe('.parseValidAccountId', () => {
  it('works', () => {
    expect(() => parseValidAccountId('')).toThrow('invalid near account id');
    expect(() => parseValidAccountId('a'.repeat(65))).toThrow('invalid near account id');
    expect(() => parseValidAccountId('foo#near')).toThrow('invalid near account id');

    expect(parseValidAccountId('foo.bar')).toBe('foo.bar');
  })
});

describe('.parseTokenAmount', () => {
  it('works', () => {
    expect(parseTokenAmount('123')).toBe('123');
    expect(parseTokenAmount('123.456')).toBe('123.456');
    expect(() => parseTokenAmount('123.')).toThrow('invalid token amount');
    expect(() => parseTokenAmount('.456')).toThrow('invalid token amount');
  })
});

describe('.parseTimestamp', () => {
  it('works', () => {
    expect(parseTimestamp('2022-12-31T23:59:59Z')).toStrictEqual(new Date('2022-12-31T23:59:59Z'));
    expect(() => parseTimestamp('2022-12-31T23:59:59+03:00')).toThrow("invalid timestamp");
    expect(() => parseTimestamp('2022-12-31 23:59:59+03:00Z')).toThrow("invalid timestamp");
  })
});

describe('.parseDuration', () => {
  it('works', () => {
    expect(() => parseDuration('')).toThrow("invalid duration");
    expect(() => parseDuration('P1Y1W')).toThrow("invalid duration");
    expect(() => parseDuration('P1WT23H')).toThrow("invalid duration");
    expect(parseDuration('P99Y'))
      .toStrictEqual( { year: 99, month: 0, week: 0, day: 0, hour: 0, minute: 0, second: 0 });
    expect(parseDuration('P12M'))
      .toStrictEqual( { year: 0, month: 12, week: 0, day: 0, hour: 0, minute: 0, second: 0 });
    expect(parseDuration('P52W'))
      .toStrictEqual( { year: 0, month: 0, week: 52, day: 0, hour: 0, minute: 0, second: 0 });
    expect(parseDuration('P365D'))
      .toStrictEqual( { year: 0, month: 0, week: 0, day: 365, hour: 0, minute: 0, second: 0 });
    expect(parseDuration('PT23H'))
      .toStrictEqual( { year: 0, month: 0, week: 0, day: 0, hour: 23, minute: 0, second: 0 });
    expect(parseDuration('PT59M'))
      .toStrictEqual( { year: 0, month: 0, week: 0, day: 0, hour: 0, minute: 59, second: 0 });
    expect(parseDuration('PT59S'))
      .toStrictEqual( { year: 0, month: 0, week: 0, day: 0, hour: 0, minute: 0, second: 59 });
    expect(parseDuration('P99Y11M364DT23H59M48S'))
      .toStrictEqual( { year: 99, month: 11, week: 0, day: 364, hour: 23, minute: 59, second: 48 });
  });
});

describe('.parseCliffInfo', () => {
  it('works', () => {
    expect(() => parseCliffInfo('')).toThrow(/expected 2 parts/);
    expect(() => parseCliffInfo('P1Y:112')).toThrow(/invalid cliff percentage/);
    expect(() => parseCliffInfo('P1Y:-7')).toThrow(/invalid cliff percentage/);
    expect(parseCliffInfo('P1Y:25'))
      .toStrictEqual({ duration: parseDuration('P1Y'), percentage: 25 });
  });
});

describe('.parseHumanFriendlySchedule', () => {
  it('works', () => {
    expect(() => parseHumanFriendlySchedule('')).toThrow(/expected 4 parts/);
    expect(parseHumanFriendlySchedule('2017-07-14T23:59:48Z|P4Y|P1Y:25|PT1S'))
      .toStrictEqual(
        {
          timestampStart: new Date('2017-07-14T23:59:48Z'),
          durationTotal: parseDuration('P4Y'),
          durationCliff: parseDuration('P1Y'),
          percentageCliff: 25,
          releaseEvery: parseDuration('PT1S'),
        },
      );
  });
});

describe('.parseToSpreadsheetRow', () => {
  it('works', () => {
    let input: any;

    input = {
      account_id: 'alice.near',
      amount: '100000',
      lockup_schedule: '2020-12-31T23:59:48Z|P4Y|P1Y:25|PT1S',
      vesting_schedule: '2021-12-31T23:59:48Z|P4Y|P1Y:25|PT1S',
    };
    expect(parseToSpreadsheetRow(input))
      .toStrictEqual(
        {
          account_id: 'alice.near',
          amount: '100000',
          lockup_schedule: parseHumanFriendlySchedule('2020-12-31T23:59:48Z|P4Y|P1Y:25|PT1S'),
          vesting_schedule: parseHumanFriendlySchedule('2021-12-31T23:59:48Z|P4Y|P1Y:25|PT1S'),
        },
      );
  });
});

describe('.parseToSpreadsheetRow', () => {
  it('works', () => {
    let input: any;

    input = `
      account_id	amount	lockup_schedule	vesting_schedule
      alice.near	100000	2020-12-31T23:59:48Z|P4Y|P1Y:25|PT1S	2021-12-31T23:59:48Z|P4Y|P1Y:25|PT1S
    `
    expect(parseSpreadsheetToSpreadsheetRows(input))
      .toStrictEqual(
        [{
          account_id: 'alice.near',
          amount: '100000',
          lockup_schedule: parseHumanFriendlySchedule('2020-12-31T23:59:48Z|P4Y|P1Y:25|PT1S'),
          vesting_schedule: parseHumanFriendlySchedule('2021-12-31T23:59:48Z|P4Y|P1Y:25|PT1S'),
        }],
      );
  });
})

describe('.datePlusDurationMul', () => {
  it('works', () => {
    let m = datePlusDurationMul;
    let d = parseDuration;
    let tm = new Date('1999-12-31T23:59:59Z');

    expect(m(tm, d('PT0S'), 1)).toStrictEqual(new Date('1999-12-31T23:59:59Z'));

    expect(m(tm, d('P1Y'), 2)).toStrictEqual(new Date('2001-12-31T23:59:59Z'));

    expect(m(tm, d('P2M'), 1)).toStrictEqual(new Date('2000-03-02T23:59:59Z'));
    expect(m(tm, d('P3M'), 1)).toStrictEqual(new Date('2000-03-31T23:59:59Z'));

    expect(m(tm, d('P2W'), 1)).toStrictEqual(new Date('2000-01-14T23:59:59Z'));

    expect(m(tm, d('P5D'), 1)).toStrictEqual(new Date('2000-01-05T23:59:59Z'));

    expect(m(tm, d('PT36H'), 1)).toStrictEqual(new Date('2000-01-02T11:59:59Z'));

    expect(m(tm, d('PT90M'), 1)).toStrictEqual(new Date('2000-01-01T01:29:59Z'));

    expect(m(tm, d('PT86400S'), 1)).toStrictEqual(new Date('2000-01-01T23:59:59Z'));

    expect(m(tm, d('P1Y2M3DT4H5M6S'), 1)).toStrictEqual(new Date('2001-03-07T04:05:05Z'));
  });

  it('considers all dates in utc', () => {
    let m = datePlusDurationMul;
    let d = parseDuration;

    expect(m(new Date('2022-01-28T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-02-28T00:00:00Z'));
    expect(m(new Date('2022-01-28T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-02-28T23:59:59Z'));

    expect(m(new Date('2022-01-29T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-01T00:00:00Z'));
    expect(m(new Date('2022-01-29T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-01T23:59:59Z'));

    expect(m(new Date('2022-01-30T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-02T00:00:00Z'));
    expect(m(new Date('2022-01-30T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-02T23:59:59Z'));

    expect(m(new Date('2022-01-31T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-03T00:00:00Z'));
    expect(m(new Date('2022-01-31T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-03T23:59:59Z'));

    expect(m(new Date('2022-02-01T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-01T00:00:00Z'));
    expect(m(new Date('2022-02-01T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-01T23:59:59Z'));

    expect(m(new Date('2022-02-02T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-02T00:00:00Z'));
    expect(m(new Date('2022-02-02T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-02T23:59:59Z'));

    expect(m(new Date('2022-02-03T00:00:00Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-03T00:00:00Z'));
    expect(m(new Date('2022-02-03T23:59:59Z'), d('P1M'), 1)).toStrictEqual(new Date('2022-03-03T23:59:59Z'));
  });
})

describe('.toLockupSchedule', () => {
  it('works', () => {
    // basic
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P1Y:25|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:59Z'), balance: '15000' + '000000000000' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // zero cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P1Y:0|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // full amount cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P1Y:100|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('2000-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // full duration cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P4Y:25|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2003-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // zero duration cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P0Y:25|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '15000' + '000000000000' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // full duration zero amount cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P4Y:0|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2003-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // zero duration full amount cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P0Y:100|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
      { timestamp: toUnix('2003-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // one second duration lockup
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|PT1S|PT1S:25|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '0' },
      { timestamp: toUnix('2000-01-01T00:00:00Z'), balance: '60000' + '000000000000' },
    ]);

    // zero duration lockup
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|PT0S|PT0S:25|PT1S'),
        '60000',
        12,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '60000' + '000000000000' },
    ]);

    // decimals rounding
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|PT0S|PT0S:25|PT1S'),
        '9000.456789',
        3,
      )
    ).toStrictEqual([
      { timestamp: toUnix('1999-12-31T23:59:58Z'), balance: '0' },
      { timestamp: toUnix('1999-12-31T23:59:59Z'), balance: '9000' + '456' },
    ]);
    // controversial cases

    // cliff bigger than total duration
    expect(
      () => toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P5Y:25|PT1S'),
        '60000',
        12,
      )
    ).toThrow('error: timestampCliff > timestampFinish');
  });

  it('builds steps correctly', () => {
    // basic
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('2022-01-15T12:00:30Z|P5M|P0Y:0|P1M'),
        '5000',
        0,
      )
    ).toStrictEqual([
      // pre cliff artifact
      { timestamp: toUnix('2022-01-15T12:00:29Z'), balance: '0' },

      { timestamp: toUnix('2022-01-15T12:00:30Z'), balance: '0' },
      { timestamp: toUnix('2022-02-15T12:00:29Z'), balance: '0' },
      { timestamp: toUnix('2022-02-15T12:00:30Z'), balance: '1000' },
      { timestamp: toUnix('2022-03-15T12:00:29Z'), balance: '1000' },
      { timestamp: toUnix('2022-03-15T12:00:30Z'), balance: '2000' },
      { timestamp: toUnix('2022-04-15T12:00:29Z'), balance: '2000' },
      { timestamp: toUnix('2022-04-15T12:00:30Z'), balance: '3000' },
      { timestamp: toUnix('2022-05-15T12:00:29Z'), balance: '3000' },
      { timestamp: toUnix('2022-05-15T12:00:30Z'), balance: '4000' },
      { timestamp: toUnix('2022-06-15T12:00:29Z'), balance: '4000' },
      { timestamp: toUnix('2022-06-15T12:00:30Z'), balance: '5000' },
    ]);
  });

  it('steps correctly in utc beginning', () => {
    // basic
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('2022-01-01T00:00:30Z|P5M|P0Y:0|P1M'),
        '5000',
        0,
      )
    ).toStrictEqual([
      // pre cliff artifact
      { timestamp: toUnix('2022-01-01T00:00:29Z'), balance: '0' },

      { timestamp: toUnix('2022-01-01T00:00:30Z'), balance: '0' },
      { timestamp: toUnix('2022-02-01T00:00:29Z'), balance: '0' },
      { timestamp: toUnix('2022-02-01T00:00:30Z'), balance: '1000' },
      { timestamp: toUnix('2022-03-01T00:00:29Z'), balance: '1000' },
      { timestamp: toUnix('2022-03-01T00:00:30Z'), balance: '2000' },
      { timestamp: toUnix('2022-04-01T00:00:29Z'), balance: '2000' },
      { timestamp: toUnix('2022-04-01T00:00:30Z'), balance: '3000' },
      { timestamp: toUnix('2022-05-01T00:00:29Z'), balance: '3000' },
      { timestamp: toUnix('2022-05-01T00:00:30Z'), balance: '4000' },
      { timestamp: toUnix('2022-06-01T00:00:29Z'), balance: '4000' },
      { timestamp: toUnix('2022-06-01T00:00:30Z'), balance: '5000' },
    ]);
  });

  it('steps correctly for month at end', () => {
    // basic
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('2022-01-31T23:59:30Z|P5M|P0Y:0|P1M'),
        '5000',
        0,
      ),
    ).toStrictEqual([
      // pre cliff artifact
      { timestamp: toUnix('2022-01-31T23:59:29Z'), balance: '0' },
      { timestamp: toUnix('2022-01-31T23:59:30Z'), balance: '0' },

      // 02-31 transfs into 02-03
      { timestamp: toUnix('2022-03-03T23:59:29Z'), balance: '0' },
      { timestamp: toUnix('2022-03-03T23:59:30Z'), balance: '1000' },

      // 03-31 exists, keep going
      { timestamp: toUnix('2022-03-31T23:59:29Z'), balance: '1000' },
      { timestamp: toUnix('2022-03-31T23:59:30Z'), balance: '2000' },

      // 04-31 transforms into 05-01
      { timestamp: toUnix('2022-05-01T23:59:29Z'), balance: '2000' },
      { timestamp: toUnix('2022-05-01T23:59:30Z'), balance: '3000' },

      // 05-31 exists, keep going
      { timestamp: toUnix('2022-05-31T23:59:29Z'), balance: '3000' },
      { timestamp: toUnix('2022-05-31T23:59:30Z'), balance: '4000' },

      // 06-31 transforms into 07-01
      { timestamp: toUnix('2022-07-01T23:59:29Z'), balance: '4000' },
      { timestamp: toUnix('2022-07-01T23:59:30Z'), balance: '5000' },
    ]);
  });
})

describe('.toLockupSchedule releaseEvery', () => {
  it('works', () => {
    let tmStart = new Date('1999-12-31T23:59:59Z');
    let tmBuild = (duration: string): Date => {
      return datePlusDurationMul(tmStart, parseDuration(duration), 1);
    };
    // basic
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P2Y|P1Y:50|P6M'),
        '40000',
        12,
      ),
    ).toStrictEqual([
      // start
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // cliff
      { timestamp: toUnix(tmBuild('P1Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P1Y')), balance: '20000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P1Y6M')) - 1, balance: '20000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P1Y6M')), balance: '30000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P2Y')) - 1, balance: '30000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P2Y')), balance: '40000' + '000000000000' },
    ]);

    // releaseEvery longer than aftercliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P2Y|P1Y:50|P10Y'),
        '40000',
        12,
      ),
    ).toStrictEqual([
      // start
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // cliff
      { timestamp: toUnix(tmBuild('P1Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P1Y')), balance: '20000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P2Y')) - 1, balance: '20000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P2Y')), balance: '40000' + '000000000000' },
    ]);

    // releaseEvery not aligned with interval end
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P1Y:25|P2Y6M'),
        '80000',
        12,
      ),
    ).toStrictEqual([
      // start
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // cliff
      { timestamp: toUnix(tmBuild('P1Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P1Y')), balance: '20000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P3Y6M')) - 1, balance: '20000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P3Y6M')), balance: '50000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P4Y')) - 1, balance: '50000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P4Y')), balance: '80000' + '000000000000' },
    ]);

    // zero duration zero amount cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P0Y:0|P2Y'),
        '80000',
        12,
      ),
    ).toStrictEqual([
      // cliff
      { timestamp: toUnix(tmBuild('P0M')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // period
      { timestamp: toUnix(tmBuild('P2Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P2Y')), balance: '40000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P4Y')) - 1, balance: '40000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P4Y')), balance: '80000' + '000000000000' },
    ]);

    // full duration cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P4Y:0|P1Y'),
        '80000',
        12,
      ),
    ).toStrictEqual([
      // cliff
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // period
      { timestamp: toUnix(tmBuild('P4Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P4Y')), balance: '80000' + '000000000000' },
    ]);

    // full amount cliff
    expect(
      toLockupSchedule(
        parseHumanFriendlySchedule('1999-12-31T23:59:59Z|P4Y|P2Y:100|P1Y'),
        '80000',
        12,
      ),
    ).toStrictEqual([
      // cliff
      { timestamp: toUnix(tmBuild('P0M')), balance: '0' },
      // period
      { timestamp: toUnix(tmBuild('P2Y')) - 1, balance: '0' },
      { timestamp: toUnix(tmBuild('P2Y')), balance: '80000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P3Y')) - 1, balance: '80000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P3Y')), balance: '80000' + '000000000000' },
      // period
      { timestamp: toUnix(tmBuild('P4Y')) - 1, balance: '80000' + '000000000000' },
      { timestamp: toUnix(tmBuild('P4Y')), balance: '80000' + '000000000000' },
    ]);
  })
})

describe('.parseLockup', () => {
  it('works', () => {
    expect(
      parseLockup({
        account_id: 'alice.near',
        amount: '60000',
        lockup_schedule: '1999-12-31T23:59:59Z|P4Y|P2Y:50|PT1S',
        vesting_schedule: '1999-12-31T23:59:59Z|P4Y|P1Y:25|PT1S',
      }, 12, 0),
    ).toStrictEqual(
      {
        account_id: "alice.near",
        id: 0,
        schedule: [
          { balance: "0", timestamp: 946684799 },
          { balance: "0", timestamp: 1009843198 },
          { balance: "30000000000000000", timestamp: 1009843199 },
          { balance: "60000000000000000", timestamp: 1072915199 },
        ],
        vesting_schedule: {
          Schedule: [
            { balance: "0", timestamp: 946684799 },
            { balance: "0", timestamp: 978307198 },
            { balance: "15000000000000000", timestamp: 978307199 },
            { balance: "60000000000000000", timestamp: 1072915199 },
          ],
        },
      },
    );
  });
  it('fails with incompatible schedule', () => {
    expect(
      () => parseLockup({
        account_id: 'alice.near',
        amount: '60000',
        lockup_schedule: '1999-12-31T23:59:59Z|P4Y|P2Y:50|PT1S',
        vesting_schedule: '2000-12-31T23:59:59Z|P4Y|P1Y:25|PT1S',
      }, 12, 0),
    ).toThrow(
      /is ahead of/
    );
  });
})

describe('.parseRawSpreadsheetInput', () => {
  it('works', () => {
    expect(
      parseRawSpreadsheetInput(`
        account_id	amount	lockup_schedule	vesting_schedule
        alice.near	100000	2009-12-31T23:59:59Z|P4Y|P2Y:50|PT1S	
        bob.near	60000	1999-12-31T23:59:59Z|P4Y|P2Y:50|PT1S	1999-12-31T23:59:59Z|P4Y|P2Y:50|PT1S
      `, 12),
    ).toStrictEqual([
      {
        account_id: "alice.near",
        id: 1,
        schedule: [
          { balance: '0', timestamp: 1262303999 },
          { balance: '0', timestamp: 1325375998 },
          { balance: '50000' + '000000000000', timestamp: 1325375999 },
          { balance: '100000' + '000000000000', timestamp: 1388534399 },
        ],
        vesting_schedule: null,
      },
      {
        account_id: 'bob.near',
        id: 2,
        schedule: [
          {balance: '0', timestamp: 946684799},
          {balance: '0', timestamp: 1009843198},
          {balance: '30000' + '000000000000', timestamp: 1009843199},
          {balance: '60000' + '000000000000', timestamp: 1072915199},
        ],
        vesting_schedule: {
          Schedule: [
            {balance: '0', timestamp: 946684799},
            {balance: '0', timestamp: 1009843198},
            {balance: '30000' + '000000000000', timestamp: 1009843199},
            {balance: '60000' + '000000000000', timestamp: 1072915199},
          ],
        },
      },
    ]);
  });
})

'''
'''--- src/services/spreadsheetImport.ts ---
import BN from 'bn.js';
import Big from 'big.js';
import { assertValidTerminationSchedule } from './scheduleHelpers';

// TODO: replace with cleaner hack or another library
BN.prototype.toJSON = function toJSON() {
  return this.toString();
};

const prefixErrorWith = (prefix: string, callback: () => any) => {
  try {
    return callback();
  } catch (e) {
    if (!(e instanceof Error)) throw new Error('unreachable');
    e.message = `${prefix}: ${e.message}`;
    throw e;
  }
};

export const parseSpreadsheetColumns = (input: string): any[] => {
  const colSep = '\t';
  const rowSep = '\n';
  const lines = input.trim().split(rowSep);
  if (lines.length <= 1) {
    return [];
  }
  const table = lines.map((line) => line.split(colSep).map((x) => x.trim()));
  const [columns, ...rowsSplit] = table;

  const rowsParsed = rowsSplit.map((row) => Object.fromEntries(
    columns.map((col, colIdx) => [col, row[colIdx] || '']),
  ));

  return rowsParsed;
};

type NearAccountId = string;

export const parseValidAccountId = (accountId: string): ValidAccountId => {
  let isValid = true;
  if (accountId.length < 2) isValid = false;
  if (accountId.length > 64) isValid = false;
  if (!accountId.match(/^[a-z0-9._-]+$/)) isValid = false;

  if (isValid) {
    return accountId;
  }
  throw new Error('invalid near account id');
};

type TokenAmount = string;

export const parseTokenAmount = (amount: string): TokenAmount => {
  if (amount.match(/^[0-9]+(\.[0-9]+)?$/)) {
    return amount;
  }
  throw new Error('invalid token amount');
};

export const parseTimestamp = (timestamp: string): Date => {
  if (!timestamp.match(/\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ/)) {
    throw new Error('invalid timestamp');
  }
  const result = new Date(timestamp);
  if (Number.isNaN(result.getTime())) {
    throw new Error('invalid timestamp');
  }

  return result;
};

type IsoDuration = {
  year: number,
  month: number,
  week: number,
  day: number,
  hour: number,
  minute: number,
  second: number,
};

export const parseDuration = (input: string): IsoDuration => {
  // const pattern = /^(P(\d+Y)?(\d+M)?(\d+D)?T(\d+H)?(\d+M)?(\d+S)?|P(\d+W))$/;
  const pattern = /^P(((((?<year>\d+)Y)?((?<month>\d+)M)?((?<day>\d+)D)?)(T((?<hour>\d+)H)?((?<minute>\d+)M)?((?<second>\d+)S)?)?)|((?<week>\d+)W)?)$/;
  const match = input.match(pattern);
  if (!match) {
    throw new Error('invalid duration');
  }

  const groups = match && match.groups || {};
  const result = {
    year: parseInt(groups.year, 10) || 0,
    month: parseInt(groups.month, 10) || 0,
    week: parseInt(groups.week, 10) || 0,
    day: parseInt(groups.day, 10) || 0,
    hour: parseInt(groups.hour, 10) || 0,
    minute: parseInt(groups.minute, 10) || 0,
    second: parseInt(groups.second, 10) || 0,
  };

  return result;
};

type CliffInfo = {
  duration: IsoDuration,
  percentage: number,
};

const parsePercentage = (input: string): number => {
  if (!(input.match(/^\d+$/))) {
    throw new Error('invalid cliff percentage');
  }

  const percentage = parseInt(input, 10);

  if (percentage < 0 || percentage > 100) {
    throw new Error('invalid cliff percentage');
  }

  return percentage;
};

export const parseCliffInfo = (input: string): CliffInfo => {
  const parts = input.split(':');
  if (parts.length !== 2) {
    throw new Error('expected 2 parts');
  }
  const [durationRaw, percentageRaw] = parts;
  const duration = parseDuration(durationRaw);
  const percentage = prefixErrorWith('percentage', () => parsePercentage(percentageRaw));
  return { duration, percentage };
};

type HumanFriendlySchedule = {
  timestampStart: Date,
  durationTotal: IsoDuration,
  durationCliff: IsoDuration,
  percentageCliff: number,
  releaseEvery: IsoDuration,
};

export const parseHumanFriendlySchedule = (schedule: string): HumanFriendlySchedule => {
  const parts = schedule.split('|');
  if (parts.length !== 4) {
    throw new Error('invalid human friendly schedule, expected 4 parts');
  }

  const [
    timestampStartRaw,
    durationTotalRaw,
    cliffInfoRaw,
    releaseEveryRaw,
  ] = parts;

  const timestampStart = prefixErrorWith('start timestamp', () => parseTimestamp(timestampStartRaw));
  const durationTotal = prefixErrorWith('duration', () => parseDuration(durationTotalRaw));
  const cliffInfo = prefixErrorWith('cliff', () => parseCliffInfo(cliffInfoRaw));
  const releaseEvery = prefixErrorWith('release every', () => parseDuration(releaseEveryRaw));

  return {
    timestampStart,
    durationTotal,
    durationCliff: cliffInfo.duration,
    percentageCliff: cliffInfo.percentage,
    releaseEvery,
  };
};

type RawSpreadsheetRow = any;

type SpreadsheetRow = {
  account_id: NearAccountId,
  amount: TokenAmount,
  lockup_schedule: HumanFriendlySchedule,
  vesting_schedule: HumanFriendlySchedule | null,
};

export const parseToSpreadsheetRow = (input: RawSpreadsheetRow): SpreadsheetRow => {
  const allowedKeys = ['account_id', 'amount', 'lockup_schedule', 'vesting_schedule'];
  Object.keys(input).forEach((key) => {
    if (!allowedKeys.includes(key)) {
      throw new Error(`unknown column '${key}'`);
    }
  });

  if (!input.account_id) throw new Error("column 'account_id' not found");
  const accountId = parseValidAccountId(input.account_id);

  if (!input.amount) throw new Error("column 'amount' not found");
  const amount = parseTokenAmount(input.amount);

  if (!input.lockup_schedule) throw new Error("column 'lockup_schedule' not found");
  const lockupSchedule = prefixErrorWith('lockup schedule', () => parseHumanFriendlySchedule(input.lockup_schedule));
  let vestingSchedule = null;

  if (input.vesting_schedule) {
    vestingSchedule = prefixErrorWith('vesting schedule', () => parseHumanFriendlySchedule(input.vesting_schedule));
  }

  return {
    account_id: accountId,
    amount,
    lockup_schedule: lockupSchedule,
    vesting_schedule: vestingSchedule,
  };
};

export const parseSpreadsheetToSpreadsheetRows = (input: string): SpreadsheetRow[] => {
  const parsedStringRows = parseSpreadsheetColumns(input);

  return parsedStringRows.map((x) => parseToSpreadsheetRow(x));
};

type ValidAccountId = string;
type TimestampSec = number;
type Balance = string;
type Checkpoint = {
  timestamp: TimestampSec,
  balance: Balance,
};
type Schedule = Checkpoint[];

export const datePlusDurationMul = (date: Date, duration: IsoDuration, mulInput: number): Date => {
  const mul = Math.floor(mulInput);
  const result = new Date(Date.UTC(
    date.getUTCFullYear() + duration.year * mul,
    date.getUTCMonth() + duration.month * mul,
    date.getUTCDate() + (duration.week * 7 + duration.day) * mul,
    date.getUTCHours() + duration.hour * mul,
    date.getUTCMinutes() + duration.minute * mul,
    date.getUTCSeconds() + duration.second * mul,
  ));
  return result;
};

export const toUnix = (date: Date | string) => Math.floor(new Date(date).getTime() / 1000);

export const toLockupSchedule = (schedule: HumanFriendlySchedule, inputTotalAmount: TokenAmount, tokenDecimals: number): Schedule => {
  if (!(tokenDecimals >= 0 && tokenDecimals === Math.floor(tokenDecimals))) {
    throw new Error('invalid token decimals');
  }
  const decimalsMultiplier = new Big(10).pow(tokenDecimals);

  const { timestampStart } = schedule;
  const timestampCliff = datePlusDurationMul(timestampStart, schedule.durationCliff, 1);
  const timestampPreCliff = datePlusDurationMul(timestampCliff, parseDuration('PT1S'), -1);
  const timestampFinish = datePlusDurationMul(timestampStart, schedule.durationTotal, 1);

  // clone normalizes internal structure, needed for unit test equality
  const totalAmount = new BN(new Big(inputTotalAmount).mul(decimalsMultiplier).round(0, Big.roundDown).toString());
  const cliffAmount = new BN(totalAmount).muln(schedule.percentageCliff).divn(100).clone();

  if (cliffAmount.gt(totalAmount)) {
    throw new Error('error: cliffAmount > totalAmount');
  }
  if (timestampCliff > timestampFinish) {
    throw new Error('error: timestampCliff > timestampFinish');
  }
  if (timestampCliff < timestampStart) {
    throw new Error('error: timestampPreCliff < timestampStart');
  }

  const { releaseEvery } = schedule;

  const tmCliff = timestampCliff;
  const tmFirstStep = datePlusDurationMul(timestampCliff, releaseEvery, 1);
  if (toUnix(tmFirstStep) <= toUnix(tmCliff)) {
    throw new Error('invalid releaseEvery, zero duration');
  }
  if (toUnix(tmFirstStep) - toUnix(tmCliff) === 1) { // linear unlock during cliff
    const cpStart = { timestamp: toUnix(timestampStart), balance: new BN('0').toString() };
    const cpPreCliff = { timestamp: toUnix(timestampPreCliff), balance: new BN('0').toString() };
    const cpCliff = { timestamp: toUnix(timestampCliff), balance: cliffAmount.toString() };
    const cpFinish = { timestamp: toUnix(timestampFinish), balance: totalAmount.toString() };

    const result = [];
    result.unshift(cpFinish);
    if (cpCliff.timestamp < cpFinish.timestamp) {
      result.unshift(cpCliff);
    }
    result.unshift(cpPreCliff);
    if (cpStart.timestamp < cpPreCliff.timestamp) {
      result.unshift(cpStart);
    }

    return result;
  }

  const tms = [];
  {
    // otherwise: use steps
    let tm = null;
    const maxSteps = 500;
    for (let i = 0; i < maxSteps; i += 1) {
      tm = datePlusDurationMul(timestampCliff, releaseEvery, i);
      if (tm >= timestampFinish) {
        tm = timestampFinish;
        tms.push(tm);
        break;
      }
      tms.push(tm);
      if (tms.length >= maxSteps) {
        throw new Error('too many checkpoints for schedule');
      }
    }
  }

  const increment = totalAmount.sub(cliffAmount).divn(tms.length - 1);

  const cps: Checkpoint[] = tms.flatMap((tm, i) => {
    if (tms.length === 1) {
      return [{ timestamp: toUnix(timestampFinish), balance: totalAmount.toString() }];
    }
    if (i === 0) {
      return [{ timestamp: toUnix(tm), balance: cliffAmount.toString() }];
    }
    const stepBalance = i === tms.length - 1
      ? totalAmount
      : cliffAmount.add(increment.muln(i)).toString();
    return [
      { timestamp: toUnix(tm) - 1, balance: cliffAmount.add(increment.muln(i - 1)).toString() },
      { timestamp: toUnix(tm), balance: stepBalance.toString() },
    ];
  });

  const cpsStart: Checkpoint[] = [];
  const cpStart = { timestamp: toUnix(timestampStart), balance: new BN('0').toString() };
  const cpPreCliff = { timestamp: toUnix(timestampPreCliff), balance: new BN('0').toString() };

  cpsStart.unshift(cpPreCliff);
  if (cpStart.timestamp < cpPreCliff.timestamp) {
    cpsStart.unshift(cpStart);
  }

  const result = cpsStart.concat(cps);
  return result;
};

export type Lockup = {
  id: number,
  account_id: ValidAccountId,
  schedule: Schedule,
  vesting_schedule: { Schedule: Schedule } | null,
};

export const parseLockup = (rawSpreadsheetRow: RawSpreadsheetRow, tokenDecimals: number, index: number): Lockup => {
  const row = parseToSpreadsheetRow(rawSpreadsheetRow);

  const lockupSchedule = toLockupSchedule(row.lockup_schedule, row.amount, tokenDecimals);
  let vestingSchedulePacked = null;

  if (row.vesting_schedule) {
    const vestingSchedule = toLockupSchedule(row.vesting_schedule, row.amount, tokenDecimals);
    assertValidTerminationSchedule(lockupSchedule, vestingSchedule);
    vestingSchedulePacked = { Schedule: vestingSchedule };
  }

  return {
    id: index,
    account_id: row.account_id,
    schedule: lockupSchedule,
    vesting_schedule: vestingSchedulePacked,
  };
};

export const parseRawSpreadsheetInput = (spreadsheetInput: string, tokenDecimals: number): Lockup[] => {
  const rows = parseSpreadsheetColumns(spreadsheetInput);
  return rows.map((x, index: number) => parseLockup(x, tokenDecimals, index + 1));
};

export type TLockupOrError = Lockup | Error;

export const parseRawSpreadsheetInputWithErrors = (spreadsheetInput: string, tokenDecimals: number): TLockupOrError[] => {
  const rows = parseSpreadsheetColumns(spreadsheetInput);
  return rows.map((x, index: number) => {
    try {
      return parseLockup(x, tokenDecimals, index + 1);
    } catch (e) {
      if (e instanceof Error) {
        return e;
      }
      throw new Error('unreachable');
    }
  });
};

export const lockupTotalBalance = (lockup: Lockup): Balance => lockup.schedule[lockup.schedule.length - 1].balance;

'''
'''--- src/services/tokenApi.ts ---
import {
  Contract, WalletConnection,
} from 'near-api-js';
import { TRY_CONVERT } from '../config';
import { TSchedule } from './api';

const MAX_GAS = 300_000_000_000_000;
const ONE_YOKTO = 1;

const TOKEN_VIEW_METHODS = [
  'ft_metadata',
  'storage_balance_of',
  'storage_balance_bounds',
];

const TOKEN_CHANGE_METHODS = [
  'ft_transfer_call', // redirects to wallet
  'storage_deposit',
];

type TTokenChangeMethods = {
  'ft_transfer_call': any,
  'storage_deposit': any,
};

type TTokenViewMethods = {
  'ft_metadata': any,
  'storage_balance_of': any,
  'storage_balance_bounds': any,
};

export type TMetadata = {
  spec: string,
  name: string,
  symbol: string,
  icon: string | null,
  reference: string | null,
  reference_hash: string | null,
  decimals: number,
};

type TLockupCreate = {
  account_id: string,
  schedule: TSchedule,
  vesting_schedule: { Schedule: TSchedule } | null,
};

type TDraftGroupFund = {
  draft_group_id: number,
  try_convert: boolean,
};

type TTokenContract = Contract & TTokenChangeMethods & TTokenViewMethods;

class TokenApi {
  private contract: TTokenContract;

  constructor(walletConnection: WalletConnection, contractId: string) {
    this.contract = new Contract(
      walletConnection.account(),
      contractId,
      { viewMethods: TOKEN_VIEW_METHODS, changeMethods: TOKEN_CHANGE_METHODS },
    ) as TTokenContract;
  }

  getContract(): TTokenContract {
    return this.contract;
  }

  async createLockup(
    lockupContractId: string,
    lockupTotalAmount: string,
    userAccountId: string,
    lockupSchedule: any[],
    vestingSchedule: TSchedule | null,
  ): Promise<void> {
    const result = await this.ftTransferCall({
      receiver_id: lockupContractId,
      amount: lockupTotalAmount.toString(),
      msg: {
        account_id: userAccountId,
        schedule: lockupSchedule,
        vesting_schedule: vestingSchedule ? { Schedule: vestingSchedule } : null,
      },
    });

    return result;
  }

  async fundDraftGroup(lockupContractId: string, draftGroupId: number, amount: string): Promise<void> {
    const result = await this.ftTransferCall({
      receiver_id: lockupContractId,
      amount,
      msg: {
        draft_group_id: draftGroupId,
        try_convert: TRY_CONVERT,
      },
    });

    return result;
  }

  async ftTransferCall(
    meta: {
      receiver_id: string,
      amount: string,
      msg: TLockupCreate | TDraftGroupFund,
    },
    gas = MAX_GAS,
    deposit = ONE_YOKTO,
  ): Promise<void> {
    const { msg, ...rest } = meta;

    await this.contract.ft_transfer_call(
      { msg: JSON.stringify(msg), ...rest },
      gas,
      deposit,
    );
  }

  storageDeposit(accountId: String, amount: String): Promise<any> {
    return this.contract.storage_deposit({
      args: { account_id: accountId },
      gas: MAX_GAS,
      amount,
    });
  }

  ftMetadata(): Promise<TMetadata> {
    return this.contract.ft_metadata({});
  }

  storageBalanceOf(accountId: String): Promise<String> {
    return this.contract.storage_balance_of({ account_id: accountId });
  }

  storageBalanceBounds(): Promise<{ min: string, max: string }> {
    return this.contract.storage_balance_bounds();
  }
}

export default TokenApi;

'''
'''--- src/services/transactionResultParser.ts ---
type TTxStatus = {
  origin: any,
  method: {
    name: string,
    args: any,
    result: any | null,
  },
};

export const parseTxResultUrl = (resultUrl: string): string | null => {
  const searchParams = new URLSearchParams(resultUrl);
  const transactionHashesRaw: string | null = searchParams.get('transactionHashes');

  if (!transactionHashesRaw) {
    return null;
  }

  const txHash = transactionHashesRaw.split(',')[0];

  console.log('txHash', txHash);

  return txHash;
};

export const fetchTxStatus = async (rpcProvider: any, contractAddress: string, txHash: string): Promise<TTxStatus | null> => {
  const fetch = async (): Promise<any | null> => {
    try {
      const response = await rpcProvider.txStatus(txHash, contractAddress);

      return response;
    } catch (error) {
      console.log('Transaction fetch error', { error });

      return null;
    }
  };

  const txStatus = await fetch();

  if (!txStatus) {
    return null;
  }

  const methodName = txStatus.transaction.actions[0].FunctionCall.method_name;
  const args = JSON.parse(atob(txStatus.transaction.actions[0].FunctionCall.args));
  const successValue = txStatus.status.SuccessValue;

  return {
    origin: txStatus,
    method: {
      name: methodName,
      args,
      result: successValue || null,
    },
  };
};

'''
'''--- src/services/useTitle.ts ---
import { useEffect } from 'react';

export interface UseTitleOptions {
  restoreOnUnmount?: boolean;
}

const DEFAULT_USE_TITLE_OPTIONS: UseTitleOptions = {
  restoreOnUnmount: false,
};

function useTitle(title: string, options: UseTitleOptions = DEFAULT_USE_TITLE_OPTIONS) {
  useEffect(() => {
    const prevTitle = document.title;
    if (document.title !== title) document.title = title;

    // eslint: disable
    if (options && options.restoreOnUnmount) {
      return () => {
        document.title = prevTitle;
      };
    }

    return () => {};
  });
}

export default typeof document !== 'undefined' ? useTitle : () => {};

'''
'''--- src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
// import * as JestFetchMock from 'jest-fetch-mock';

beforeEach(() => {
  global.fetch = jest.fn(() => { Prmose.reject("NETWORK ACCESS IS NOT ALLOWED IN TESTS") });
});

'''
'''--- src/utils.test.js ---
import { formatTokenAmount } from './utils';

describe('formatTokenAmount', () => {
  it('works', () => {
    expect(formatTokenAmount('1000000000000', 6)).toStrictEqual('1000000.00');
    expect(formatTokenAmount('499999', 6)).toStrictEqual('0.49');
    expect(formatTokenAmount('1000', 0)).toStrictEqual('1000.00');
    expect(formatTokenAmount('1000', 1)).toStrictEqual('100.00');
    expect(formatTokenAmount('1000', 2)).toStrictEqual('10.00');
    expect(formatTokenAmount('1000', 3)).toStrictEqual('1.00');
    expect(formatTokenAmount('1000', 4)).toStrictEqual('0.10');
    expect(formatTokenAmount('1000', 5)).toStrictEqual('0.01');
    expect(formatTokenAmount('1000', 6)).toStrictEqual('0.00');
  });
});

'''
'''--- src/utils.ts ---
import Big from 'big.js';
import { config } from './config';

export const MAX_GAS = 300_000_000_000_000;
export const ONE_YOCTO = 1;

Big.DP = 40;
Big.PE = 40;
export const NEAR_ROUND_DIGITS = 2;

export const pseudoUtcIsoDate = (unixSeconds: number) => {
  const date = new Date(unixSeconds * 1_000);
  const pad = (input: number | string, width: number) => input.toString().padStart(width, '0');

  const year = pad(date.getUTCFullYear(), 4);
  const month = pad(date.getUTCMonth() + 1, 2);
  const monthDay = pad(date.getUTCDate(), 2);

  const formatted = `${year}-${month}-${monthDay}`;

  return formatted;
};

export const pseudoUtcIsoTime = (unixSeconds: number) => {
  const date = new Date(unixSeconds * 1_000);
  const pad = (input: number | string, width: number) => input.toString().padStart(width, '0');

  const hours = pad(date.getUTCHours(), 2);
  const minutes = pad(date.getUTCMinutes(), 2);
  const seconds = pad(date.getUTCSeconds(), 2);

  const formatted = `${hours}:${minutes}:${seconds}`;

  return formatted;
};

export const pseudoUtcIsoDateTime = (unixSeconds: number) => {
  const formatted = `${pseudoUtcIsoDate(unixSeconds)} ${pseudoUtcIsoTime(unixSeconds)}`;

  return formatted;
};

export const toNear = (value: any) => Big(value).times(10 ** 24).round(0, Big.roundDown);
export const nearTo = (value: any, digits = NEAR_ROUND_DIGITS, mode?: number | undefined) => {
  // default is 20, need at least 38 for proper rounding of any near balance
  Big.DP = 40;
  return Big(value || '0').div(10 ** 24).toFixed(digits === 0 ? undefined : digits, mode);
};
export const nearToCeil = (
  value: any,
  digits = NEAR_ROUND_DIGITS,
) => nearTo(value, digits, Big.roundUp);
export const nearToFloor = (
  value: any,
  digits = NEAR_ROUND_DIGITS,
) => nearTo(value, digits, Big.roundDown);
export const big = (value = '0') => Big(value);
export const tsNear2JS = (time: number) => Math.floor(time / 1000000);

// formats token amount, always two digits after comma, fixed, no group separators
export const formatTokenAmount = (value: string, tokenDecimals: number) => new Big(value).div(10 ** tokenDecimals).toFixed(NEAR_ROUND_DIGITS, Big.roundDown);

export const addYear = (date: Date, year: number) => new Date(new Date(date).setUTCFullYear((date.getUTCFullYear()) + year)).getTime() / 1000;
export const startOfDay = (date: Date) => {
  const msInDay = 1_000 * 60 * 60 * 24;
  const result = new Date(Math.floor(date.getTime() / msInDay) * msInDay);

  return result;
};
export const addDays = (date: Date, days: number) => {
  const msInDay = 1_000 * 60 * 60 * 24;
  const result = new Date(date.getTime() + msInDay * days);

  return result;
};

export const dumpLocalStorage = (dumpKey: string = 'dump') => {
  const dumpValue = Object.keys(localStorage).map((key) => [key, localStorage.getItem(key)]);

  localStorage.setItem(dumpKey, JSON.stringify(dumpValue));
};

export const restoreLocalStorage = (dumpKey: string = 'dump') => {
  const data = localStorage.getItem(dumpKey);

  if (!data) {
    return;
  }

  const dumpValue = JSON.parse(data);

  localStorage.clear();

  dumpValue.forEach((record:string[]) => localStorage.setItem(record[0], record[1]));
};

export const toCompactString = (string: string, leftPad: number = 10, rightPad: number = 10) => {
  if (string.length > 24) {
    return `${string.slice(0, leftPad)}...${string.slice(-rightPad)}`;
  }
  return string;
};

export const txLinkInExplorer = (txHash: string) => `${config.explorerUrl}/transactions/${txHash}`;

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

'''