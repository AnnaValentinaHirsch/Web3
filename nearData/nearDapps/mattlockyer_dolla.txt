*GitHub Repository "mattlockyer/dolla"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# Dolla

> Cash rules everything around me, C.R.E.A.M., get the money, dollar dollar bill, y'all

NEAR Money Printer Go Brrr!

Print YUUUGE amounts of "NEAR CASH" bills and drop that STIMI!

Receivers can claim to an existing account or use funds to set up a brand new NEAR Account!

# React 17, Parcel with useContext and useReducer
- Bundled with Parcel 2.0.1
- *Minimal all-in-one state management with async/await support*

## Getting Started: State Store & useContext

>The following steps are already done, but describe how to use `src/utils/state` to create and use your own `store` and `StateProvider`.

1. Create a file e.g. `/state/app.js` and add the following code
```js
import { State } from '../utils/state';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { store, Provider } = State(initialState);
```
2. Now in your `index.js` wrap your `App` component with the `StateProvider`
```js
import { Provider } from './state/app';

ReactDOM.render(
    <Provider>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
3. Finally in `App.js` you can `useContext(store)`
```js
const { state, dispatch, update } = useContext(store);
```

## Usage in Components
### Print out state values
```js
<p>Hello {state.foo && state.foo.bar.hello}</p>
```
### Update state directly in component functions
```js
const handleClick = () => {
    update('clicked', !state.clicked);
};
```
### Dispatch a state update function (action listener)
```js
const onMount = () => {
    dispatch(onAppMount('world'));
};
useEffect(onMount, []);
```
## Dispatched Functions with context (update, getState, dispatch)

When a function is called using dispatch, it expects arguments passed in to the outer function and the inner function returned to be async with the following json args: `{ update, getState, dispatch }`

Example of a call:
```js
dispatch(onAppMount('world'));
```

All dispatched methods **and** update calls are async and can be awaited. It also doesn't matter what file/module the functions are in, since the json args provide all the context needed for updates to state.

For example:
```js
import { helloWorld } from './hello';

export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};
```
## Prefixing store and Provider

The default names the `State` factory method returns are `store` and `Provider`. However, if you want multiple stores and provider contexts you can pass an additional `prefix` argument to disambiguate.

```js
export const { appStore, AppProvider } = State(initialState, 'app');
```

## Performance and memo

The updating of a single store, even several levels down, is quite quick. If you're worried about components re-rendering, use `memo`:
```js
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered message');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
```
Higher up the component hierarchy you might have:
```js
const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    ...
	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button onClick={handleClick}>Click Me</button>
		</div>
	);
};
```
When the button is clicked, the component HelloMessage will not re-render, it's value has been memoized (cached). Using this method you can easily prevent performance intensive state updates in further down components until they are neccessary.

Reference:
- https://reactjs.org/docs/context.html
- https://dmitripavlutin.com/use-react-memo-wisely/

'''
'''--- contract/Cargo.toml ---
[package]
name = "linkdrop-proxy"
version = "0.1.0"
authors = ["Ryan Mehta <ryan.mehta@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.1"
near-contract-standards = "4.0.0-pre.1"
'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault,
    Promise, PromiseResult, PublicKey,
};

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct LinkDrop {
    pub linkdrop_contract: AccountId,
    pub accounts: LookupMap<PublicKey, Balance>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
}

/// 0.02 N
const ACCESS_KEY_ALLOWANCE: u128 = 20_000_000_000_000_000_000_000;
/// can take 0.5 of access key since gas required is 6.6 times what was actually used
const NEW_ACCOUNT_BASIC_AMOUNT: u128 = 15_000_000_000_000_000_000_000;
const ON_CREATE_ACCOUNT_GAS: Gas = Gas(40_000_000_000_000);
const ON_CALLBACK_GAS: Gas = Gas(20_000_000_000_000);
/// Indicates there are no deposit for a callback for better readability.
const NO_DEPOSIT: u128 = 0;

/// external and self callbacks
#[ext_contract(ext_linkdrop)]
trait ExtLinkdrop {
    fn create_account(&mut self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise;
}
#[ext_contract(ext_self)]
trait ExtLinkdrop {
    fn on_account_created(&mut self, pk: PublicKey) -> bool;
}

#[near_bindgen]
impl LinkDrop {
    #[init]
    pub fn new(linkdrop_contract: AccountId) -> Self {
        Self {
            linkdrop_contract,
            accounts: LookupMap::new(StorageKey::Accounts),
        }
    }

	pub fn set_contract(&mut self, linkdrop_contract: AccountId) {
		assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "predecessor != current"
        );
		self.linkdrop_contract = linkdrop_contract;
	}

	/// sending (adding keys)

    #[payable]
    pub fn send(&mut self, public_key: PublicKey) -> Promise {
        assert!(
            env::attached_deposit() >= ACCESS_KEY_ALLOWANCE,
            "Deposit < ACCESS_KEY_ALLOWANCE"
        );
        let pk = public_key;
        let value = self.accounts.get(&pk).unwrap_or(0);
        self.accounts.insert(
            &pk,
            &(value + env::attached_deposit() - ACCESS_KEY_ALLOWANCE),
        );
        Promise::new(env::current_account_id()).add_access_key(
            pk,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            b"claim,create_account_and_claim".to_vec(),
        )
    }

    #[payable]
    pub fn send_multiple(&mut self, public_keys: Vec<PublicKey>) {
        assert!(
            env::attached_deposit() >= ACCESS_KEY_ALLOWANCE,
            "Deposit < ACCESS_KEY_ALLOWANCE"
        );

		let current_account_id = env::current_account_id();

		let promise = env::promise_batch_create(&current_account_id);

		let len = public_keys.len() as u128;
		
		for pk in public_keys {

			env::promise_batch_action_add_key_with_function_call(
				promise, 
				&pk, 
				0, 
				ACCESS_KEY_ALLOWANCE, 
				&current_account_id, 
				b"claim,create_account_and_claim"
			);
			
			self.accounts.insert(
				&pk, 
				&(self.accounts.get(&pk).unwrap_or(0) + env::attached_deposit() / len - ACCESS_KEY_ALLOWANCE),
			);
		}

		env::promise_return(promise);
    }

	/// claiming

	fn process_claim(&mut self) -> Balance {
		assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "predecessor != current"
        );
        let mut amount = self
            .accounts
            .remove(&env::signer_account_pk())
            .expect("Missing public key");

		Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());

		if amount == 0 {
			amount = NEW_ACCOUNT_BASIC_AMOUNT;
		}

		amount
	}

    /// Claim tokens for specific account that are attached to the public key this tx is signed with.
    pub fn claim(&mut self, account_id: AccountId) -> Promise {
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );

        let amount = self.process_claim();
		
        Promise::new(account_id).transfer(amount)
    }

    /// Create new account and and claim tokens to it.
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) -> Promise {
        assert!(
            env::is_valid_account_id(new_account_id.as_bytes()),
            "Invalid account id"
        );

        let amount = self.process_claim();

        ext_linkdrop::create_account(
            new_account_id,
            new_public_key,
            &self.linkdrop_contract,
            amount,
            ON_CREATE_ACCOUNT_GAS,
        ).then(ext_self::on_account_created(
			env::signer_account_pk(),
			&env::current_account_id(),
			NO_DEPOSIT,
			ON_CALLBACK_GAS,
		))
    }

    /// Returns the balance associated with given key.
    pub fn get_key_balance(&self, key: PublicKey) -> U128 {
        self.accounts
            .get(&key)
            .expect("Key missing")
            .into()
    }

	/// self callback checks if account was created successfully or not
    pub fn on_account_created(&mut self, pk:PublicKey) -> bool {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "predecessor != current"
        );
		assert_eq!(env::promise_results_count(), 1, "no promise result");
        let creation_succeeded = matches!(env::promise_result(0), PromiseResult::Successful(_));
        if !creation_succeeded {
			// put access key back (was deleted before calling linkdrop contract)
            Promise::new(env::current_account_id()).add_access_key(
				pk,
				ACCESS_KEY_ALLOWANCE,
				env::current_account_id(),
				b"claim,create_account_and_claim".to_vec(),
			);
        }
        creation_succeeded
    }
}

'''
'''--- deploy/mainnet.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../test/config");

// for testnet
const network = 'mainnet'
let { nodeUrl, networkId, GAS } = getConfig(network);
GAS = "200000000000000"
const contractId = 'ld.dolla.near'

const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	KeyPair,
	transactions: { deployContract, functionCall },
} = nearAPI;

const credPath = `${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
console.log(
	"Loading Credentials:\n",
	credPath
);
let credentials = JSON.parse(
	fs.readFileSync(
		credPath
	)
);

const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractId,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

const linkdrop_contract = 'near'

async function init () {
	const contractBytes = fs.readFileSync('./out/main.wasm');
	console.log('\n\n deploying contractBytes:', contractBytes.length, '\n\n');

	const actions = [
		deployContract(contractBytes),
	];
	const state = await contractAccount.state()
	if (state.code_hash === '11111111111111111111111111111111') {
		actions.push(functionCall('new', { linkdrop_contract }, GAS))
	}

	await contractAccount.signAndSendTransaction({ receiverId: contractId, actions });
}
init()

'''
'''--- deploy/testnet.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../test/config");

// for testnet
const network = 'testnet'
const { nodeUrl, networkId, GAS } = getConfig(network);
const contractId = 'linkdrop-wrapper.' + network

const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	KeyPair,
	transactions: { deployContract, functionCall },
} = nearAPI;

const credPath = `./neardev/${networkId}/${contractId}.json`;
console.log(
	"Loading Credentials:\n",
	credPath
);

let credentials;
try {
	credentials = JSON.parse(
		fs.readFileSync(
			credPath
		)
	);
} catch(e) {
	console.warn('credentials not in /neardev');
	/// attempt to load backup creds from local machine
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
		)
	);
}

const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractId,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

async function init () {
	const contractBytes = fs.readFileSync('./out/main.wasm');
	console.log('\n\n deploying contractBytes:', contractBytes.length, '\n\n');

	const actions = [
		deployContract(contractBytes),
	];
	const state = await contractAccount.state()
	if (state.code_hash === '11111111111111111111111111111111') {
		actions.push(functionCall('new', { linkdrop_contract: network }, GAS))
	}
	await contractAccount.signAndSendTransaction({ receiverId: contractId, actions });
}
init()

'''
'''--- package.json ---
{
  "name": "near-printer",
  "version": "1.0.0",
  "description": "Print NEAR Linkdrops as Bills",
  "author": "Matt Lockyer",
  "license": "ISC",
  "dependencies": {
    "copy-to-clipboard": "^3.3.1",
    "near-api-js": "^0.44.2",
    "parcel": "^2.0.1",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^6.2.1"
  },
  "devDependencies": {
    "@parcel/transformer-sass": "^2.0.1",
    "eslint": "^7.14.0",
    "mocha": "^9.2.0",
    "rimraf": "^3.0.2"
  },
  "browserslist": [
    "last 2 Chrome versions"
  ],
  "scripts": {
    "prebuild": "yarn clean",
    "build": "parcel build src/index.html --no-source-maps",
    "build-prod": "yarn patch-prod && REACT_APP_ENV=prod parcel build src/index.html --no-source-maps",
    "clean": "rimraf ./dist",
    "fix": "eslint src/ --fix",
    "start": "parcel src/index.html --open",
    "start-prod": "yarn patch-prod && REACT_APP_ENV=prod parcel src/index.html --open",
    "build-contract": "cd contract && ./build.sh && cd ..",
    "patch-prod": "node ./utils/patch-prod.js",
    "patch-config": "node ./utils/patch-config.js",
    "dev-deploy": "yarn build-contract && rm -rf neardev && (near dev-deploy || exit 0) && yarn patch-config",
    "test-deploy": "yarn dev-deploy && mocha",
    "test": "mocha"
  }
}

'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';
import { Routes, Route, Link, useNavigate } from "react-router-dom";
import { appStore, onAppMount } from './state/app';
import { Bills } from './Bills'
import { Printer } from './Printer'
import IlliaPrinter from 'url:./img/illia-printer-small.gif'
import Sample from 'url:./img/sample.png'
import './App.scss';

const Wallet = ({ wallet }) => {
	return wallet?.signedIn ?
		<>
			<h2>Wallet</h2>
			<p>{wallet.account.accountId}</p>
			<Link to="/printer"><button>Print Bills</button></Link>
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>
		:
		<>
			<h2>Wallet</h2>
			<p>Not Signed In</p>
			<button onClick={() => wallet.signIn()}>Sign In</button>
		</>
}

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	const { wallet, account } = state

	const { href, pathname } = window.location;
	const txHashes = href.split('?transactionHashes=')[1];
	const navigate = useNavigate();

	const onMount = () => {
		dispatch(onAppMount());
		if (pathname !== '/' && txHashes?.length > 0) {
			navigate('/');
		}
	};
	useEffect(onMount, []);

	return <>
		<div className="background"></div>

		<nav>
			<ul>
				<li>
					<Link to="/">About</Link>
				</li>

				{
					account && <>
						<li>
							<Link to="/bills">Bills</Link>
						</li>
						<li>
							<Link to="/printer">Printer</Link>
						</li>
					</>
				}
				<li>
					<Link to="/wallet">Wallet</Link>
				</li>
			</ul>
		</nav>

		<div className='container-fluid'>

			<main>
				<Routes>
					<Route path="/printer" element={<Printer {...{ account }} />} />
					<Route path="/wallet" element={<Wallet {...{ wallet }} />} />
					<Route path="/bills" element={<Bills {...{ account }} />} />
					<Route path="/" element={<>
						<h3>NEAR Printer</h3>
						<img src={IlliaPrinter} />
						<p></p>
						<p>Sign in and use the printer to create "NEAR Bills".</p>
						<img src={Sample} />
						<p></p>
						{
							account
								?
								<Link to="/printer"><button>Print Bills</button></Link>
								:
								<button onClick={() => wallet.signIn()}>Sign In</button>
						}
						<p>You can download the image, a PDF with link, or share the link directly without the image.</p>
						<p>Print and be merry!</p>
						
					</>} />
				</Routes>
			</main>

		</div>
	</>
};

export default App;

'''
'''--- src/Bill.js ---
import React, { useEffect, useRef } from 'react';
import copy from "copy-to-clipboard";

import { contractId } from './state/near'

const WIDTH = 846, HEIGHT = 360
const TRY_URL = 'https://www.nearprinter.com'

export const Bill = ({ image, background, secretKey, reclaimFunc }) => {

	const qr = useRef();
	const canvas = useRef();

	const url = `https://wallet.near.org/linkdrop/${contractId}/${secretKey}`

	const onMount = async () => {
		if (qr.current.children.length < 2) {
			new QRCode(qr.current, {
				text: url,
				width: 256,
				height: 256,
				colorDark: "#444422",
				colorLight: "#FFFFFF88",
				correctLevel: QRCode.CorrectLevel.M
			});
			new QRCode(qr.current, {
				text: TRY_URL,
				width: 256,
				height: 256,
				colorDark: "#444422",
				colorLight: "#FFFFFF88",
				correctLevel: QRCode.CorrectLevel.M
			});
		}
		console.log(qr.current)
	}
	useEffect(onMount, [])

	const onImage = () => {

		const photo = document.getElementById('canvas');
		const image = document.getElementById(background + '-dollar');
		const c = canvas.current;
		c.width = WIDTH;
		c.height = HEIGHT;
		const ctx = c.getContext('2d');

		ctx.fillStyle = '#FFF'
		ctx.fillRect(0, 0, WIDTH, HEIGHT)

		console.log(photo.width, photo.height)

		let margin = Math.max(0, photo.height - photo.width) / 2
		let expand = HEIGHT / photo.height
		if (expand < 1) {
			expand *= 1.5
		}
		// alert(expand)

		if (background === 1) {
			ctx.drawImage(photo, 0, margin, photo.width, photo.height - margin * 2, WIDTH / 2 - photo.width / 2, 100, photo.width, photo.height - margin * 2);
			ctx.drawImage(image, 0, 0);

			let q = qr.current.children[0]
			ctx.drawImage(q, 0, 0, q.width, q.height, 117, 105, 200, 200);
			q = qr.current.children[2]
			ctx.drawImage(q, 0, 0, q.width, q.height, 535, 105, 200, 200);
		} else {
			ctx.fillStyle = 'white'
			ctx.fillRect(0, 0, WIDTH * 2, HEIGHT * 2)
			ctx.drawImage(photo, 0, margin, photo.width, photo.height, WIDTH / 2 - (photo.width * expand) / 2 - 60, 20, photo.width * expand, photo.height * expand);
			ctx.drawImage(image, 0, 0);

			let q = qr.current.children[0]
			ctx.drawImage(q, 0, 0, q.width, q.height, 28, 80, 200, 200);
			q = qr.current.children[2]
			ctx.drawImage(q, 0, 0, q.width, q.height, 506, 111, 190, 190);
		}
	}
	useEffect(onImage, [image, background])

	return <div>
		<div ref={qr} className="display-none"></div>
		<canvas ref={canvas} width={WIDTH} height={HEIGHT}></canvas>
		<button onClick={() => {

			// Default export is a4 paper, portrait, using millimeters for units
			const doc = new jspdf.jsPDF({
				orientation: "landscape",
				unit: "px",
				format: [WIDTH, HEIGHT + 25]
			});

			const c = canvas.current;
			var myImage = c.toDataURL("image/jpeg");
			doc.addImage(myImage, 'JPEG', 0, 25, WIDTH, HEIGHT);
			doc.setTextColor(0, 0, 255);
			doc.textWithLink(url, 15, 15, { url });
			// doc.link(10, 10, WIDTH, 100, { url });
			doc.save("a4.pdf");
		}}>Download PDF</button>

		<button onClick={async () => {
			if (window.navigator.share) {
				await window.navigator.share({
					title: 'You received a NEAR Bill!',
					text: 'Click this link to claim!',
					url,
				});
			} else {
				copy(url)
				alert('Link Copied!')
			}
		}}>Claim Link</button>
		<button onClick={reclaimFunc}>Reclaim Bill</button>
	</div>
}
'''
'''--- src/Bills.js ---
import React, { useEffect, useState } from 'react';

import { getKeysLS, setKeysLS } from './state/app';
import { near, contractAccount, KeyPair, networkId, contractId } from './state/near';

import { Bill } from './Bill'
import { Capture } from './Capture'
import OneDollar from './img/1-dollar.png'
import HundredDollar from './img/100-dollar.png'

export const Bills = ({ account }) => {

	if (!account) return <>
		<h3>NEAR Printer</h3>
		<p>First, sign in with your wallet.</p>
		<p>Print some bills using the printer!</p>
	</>
	const { accountId } = account

	const [keys, setKeys] = useState([])
	const [image, setImage] = useState(0)
	const [background, setBackground] = useState(1)

	const checkKeys = async (which) => {
		if (!which && keys.length > 0) return

		/// checks all keys
		if (!which) which = [...getKeysLS(accountId)]

		const invalidKeys = []
		await Promise.all(which.map(async (secretKey) => {
			try {
				const keyPair = KeyPair.fromString(secretKey)
				await account.viewFunction(contractId, 'get_key_balance', {
					key: keyPair.publicKey.toString()
				})
			} catch (e) {
				if (/Key missing/.test(e)) return invalidKeys.push(secretKey)
				throw e
			}
		}))

		const validKeys = [...getKeysLS(accountId)].filter((secretKey) => !invalidKeys.includes(secretKey))

		setKeys(validKeys);
		setKeysLS(accountId, validKeys);
	}
	useEffect(checkKeys, [])

	return <>

		<div style={{ display: 'none' }}>
			<img id="1-dollar" src={OneDollar} onClick={() => setBackground(1)} />
			<img id="100-dollar" src={HundredDollar} onClick={() => setBackground(100)} />
		</div>

		{
			keys.length > 0
				?
				<>
					<h3>Style</h3>

					<div className="style">
						<div>
							<Capture onClick={() => setImage(Math.random())} />
						</div>
						 <div>
							<img src={OneDollar} onClick={() => setBackground(1)} />
							<img src={HundredDollar} onClick={() => setBackground(100)} />
						</div>
					</div>

					<h3>Bills</h3>
					<div className="bills">
						<button onClick={async () => {

							for (let i = 0; i < keys.length; i++) {
								try {
									const secretKey = keys[i]
									const keyPair = KeyPair.fromString(secretKey)
									near.connection.signer.keyStore.setKey(networkId, contractId, keyPair);
									const res = await contractAccount.functionCall({
										contractId,
										methodName: 'claim',
										args: {
											account_id: account.accountId
										},
									})
									// console.log(res)
									checkKeys([secretKey])
								} catch (e) {
									if (/doesn't have access key/.test(e)) return console.log('invalid key')
									throw e
								}
							}

						}}>Reclaim All</button>
						{
							keys.map((secretKey, i) => {
								return <div key={secretKey}>
									<p>{i + 1} / {keys.length}</p>
									<Bill {...{
										image, background, secretKey, reclaimFunc: async () => {
											try {
												const keyPair = KeyPair.fromString(secretKey)
												near.connection.signer.keyStore.setKey(networkId, contractId, keyPair);
												const res = await contractAccount.functionCall({
													contractId,
													methodName: 'claim',
													args: {
														account_id: account.accountId
													},
													// gas,
												})
												// console.log(res)
												checkKeys([secretKey])
											} catch (e) {
												if (/doesn't have access key/.test(e)) return console.log('invalid key')
												throw e
											}
										}
									}} />

								</div>
							})
						}
					</div>
				</>
				:
				<>
					<h3>NEAR Printer</h3>
					<p>Print some bills using the printer!</p>
				</>
		}
	</>
}
'''
'''--- src/Capture.js ---
import React, { useEffect, useState } from 'react';

export const Capture = ({ onClick }) => {

	const onMount = async () => {

		let width = 320;    // We will scale the photo width to this
		let height = 0;     // This will be computed based on the input stream

		// The various HTML elements we need to configure or control. These
		// will be set by the startup() function.

		let streaming = false, video, canvas, photo, overlay, startbutton;

		function showViewLiveResultButton() {
			if (window.self !== window.top) {
				// Ensure that if our document is in a frame, we get the user
				// to first open it in its own tab or window. Otherwise, it
				// won’t be able to request permission for camera access.
				document.querySelector(".contentarea").remove();
				const button = document.createElement("button");
				button.textContent = "View live result of the example code above";
				document.body.append(button);
				button.addEventListener('click', () => window.open(location.href));
				return true;
			}
			return false;
		}

		function startup() {
			if (showViewLiveResultButton()) { return; }
			video = document.getElementById('video');
			canvas = document.getElementById('canvas');
			overlay = document.getElementById('overlay');
			photo = document.getElementById('photo');
			startbutton = document.getElementById('startbutton');

			navigator.mediaDevices.getUserMedia({ video: true, audio: false })
			.then(function (stream) {
				video.srcObject = stream;
				video.play();
			})
			.catch(function (err) {
				console.log("An error occurred: " + err);
			});
			

			video.addEventListener('canplay', function (ev) {
				if (!streaming) {
					height = video.videoHeight / (video.videoWidth / width);

					// Firefox currently has a bug where the height can't be read from
					// the video, so we will make assumptions if this happens.

					if (isNaN(height)) {
						height = width / (4 / 3);
					}

					video.setAttribute('width', width);
					video.setAttribute('height', height);
					overlay.setAttribute('width', width);
					overlay.setAttribute('height', height);
					canvas.setAttribute('width', width);
					canvas.setAttribute('height', height);
					streaming = true;
				}
			}, false);

			startbutton.addEventListener('click', function (ev) {
				onClick()
				takepicture();
				ev.preventDefault();
			}, false);
		}
		startup()

		function updateOverlay() {

		}

		// Capture a photo by fetching the current contents of the video
		// and drawing it into a canvas, then converting that to a PNG
		// format data URL. By drawing it on an offscreen canvas and then
		// drawing that to the screen, we can change its size and/or apply
		// other changes before drawing it.

		function takepicture() {
			let context = canvas.getContext('2d');
			if (width && height) {
				canvas.width = width;
				canvas.height = height;
				context.drawImage(video, 0, 0, width, height);
				// var data = canvas.toDataURL('image/png');
				// photo.setAttribute('src', data);
			}

			context = overlay.getContext('2d');
			if (width && height) {
				overlay.width = width;
				overlay.height = height;
				context.strokeStyle = 'red'
				context.arc(width/2, height/2 - height/8, width/4, 0, Math.PI*2)
				context.stroke()
			}
		}

		setTimeout(takepicture, 1000)
	}
	useEffect(onMount, [])

	return <>

		<div className="camera">
			<video id="video">Video stream not available.</video>
  			<canvas id="overlay"></canvas>
  			<canvas id="canvas" className="display-none"></canvas>
			<br />
			<button id="startbutton">Take photo</button>
		</div>

	</>
}
'''
'''--- src/HelloMessage.js ---
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered: HelloMessage component');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
'''
'''--- src/Printer.js ---
import React, { useEffect, useState } from 'react';
import BN  from 'bn.js'

import { getKeysLS, setKeysLS } from './state/app';
import { parseNearAmount, KeyPair, contractId, gas } from './state/near';

export const Printer = ({ account }) => {

	if (!account) return null

	const { accountId } = account
	const [num, setNum] = useState('1')
	const [amount, setAmount] = useState('0.02')

	const onMount = async () => {
		
	}
	useEffect(onMount, [])

	return <>
		<h3>Printer</h3>
		<p>Amount</p>
		<input type="number" value={amount} onChange={(e) => setAmount(e.target.value)} />
		<p>Number</p>
		<input type="number" value={num} onChange={(e) => setNum(e.target.value)} />
		<button onClick={() => {
			if (parseFloat(amount) < 0.02) {
				return alert('Amount too small (min 0.02 per bill).')
			}
			const keysLS = getKeysLS(accountId)
			const keys = []
			for (let i = 0; i < num; i++) {
				const keyPair = KeyPair.fromRandom('ed25519')
				keys.push(keyPair)
				keysLS.push(keyPair.secretKey)
			}
			setKeysLS(accountId, keysLS)

			account.functionCall({
				contractId,
				methodName: 'send_multiple',
				args: {
					public_keys: keys.map((keyPair) => keyPair.publicKey.toString())
				},
				gas,
				attachedDeposit: new BN(parseNearAmount(amount)).mul(new BN(num))
			})
		}}>Print</button>
	</>
}
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>NEAR Printer</title>
	<script type="javascript" src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

	<link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css" />

</head>

<body>
	<noscript>You need to enable JavaScript to run this app.</noscript>
	<div id="root"></div>
	<script type="module" src="./index.js"></script>
</body>

</html>
'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';
import { BrowserRouter } from "react-router-dom";

ReactDOM.render(
	<AppProvider>
		<BrowserRouter>
			<App />
		</BrowserRouter>
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';
import { initNear } from './near';

const initialState = {
	app: {
		mounted: false
	}
};

const KEYS = '__KEYS'
export const getKeysLS = (accountId) => JSON.parse(localStorage.getItem(accountId + KEYS) || '[]')
export const setKeysLS = (accountId, keys) => localStorage.setItem(accountId + KEYS, JSON.stringify(keys))

export const { appStore, AppProvider } = State(initialState, 'app');

// example app function
export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear())
};

'''
'''--- src/state/near.js ---
import * as nearAPI from 'near-api-js';
import { near, contractAccount } from '../../utils/near-utils';
import getConfig from '../../utils/config';
const networkId = process.env.REACT_APP_ENV === 'prod' ? 'mainnet' : 'testnet'
const { contractId, gas } = getConfig(networkId);
const { KeyPair, WalletAccount, utils: { format: { parseNearAmount } } } = nearAPI

export { near, networkId, contractAccount, KeyPair, parseNearAmount, contractId, gas }

export const initNear = () => async ({ update }) => {

	const wallet = new WalletAccount(near)

	wallet.signIn = () => {
		wallet.requestSignIn(contractId, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		wallet.signedIn = false
		update('', { account: null, wallet });
		window.location.href = window.location.origin
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.account = account
	}

	await update('', { near, wallet, account });

};

'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState = initialState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			const retState = { ...state }
			if (newState === null) return null
			Object.entries(newState).map(([k, v]) => {
				retState[k] = state[k] && typeof v === 'object' && !Array.isArray(v) ?
					updateState(state[k], v) : v
			})
			return retState;
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- test/api.test.js ---
const assert = require('assert');
const { KeyPair, Account } = require('near-api-js');
const { parseNearAmount } = require('near-api-js/lib/utils/format');
const testUtils = require('./test-utils');

let {
	near,
	networkId,
	contractId,
	contractAccount,
	recordStart,
	recordStop,
	getAccount,
} = testUtils;

let linkdropAccount = contractAccount;
/// contractAccount is the devAccount - testing against deployed contract on testnet
const useDeployedLinkdrop = false;
if (useDeployedLinkdrop) {
	contractId = 'linkdrop-wrapper.testnet';
	linkdropAccount = new Account(near.connection, contractId);
}

// 85 Tgas is enough with callback check
const gas = '85000000000000';
const gasMultiple = '200000000000000';
const attachedDeposit = parseNearAmount('0.02')
const attachedDepositDouble = parseNearAmount('0.04')

describe('Linkdrop Proxy', function () {
	this.timeout(60000);

	const aliceId = 'alice-test.' + contractId

	// linkdrop keypairs
	const keyPair1 = KeyPair.fromRandom('ed25519');
	const keyPair2 = KeyPair.fromRandom('ed25519');
	const public_key1 = keyPair1.publicKey.toString();
	const public_key2 = keyPair2.publicKey.toString();
	// the new account's keypair
	const keyPairNewAccount = KeyPair.fromRandom('ed25519');
	const new_public_key = keyPairNewAccount.publicKey.toString();

	it('accounts and contract deployed', async function() {

		alice = await getAccount(aliceId);
		// console.log(alice)

		const state = await linkdropAccount.state();
		if (state.code_hash.indexOf('111111') === 0) {
			return assert(true)
		}
		try {
			await contractAccount.functionCall({
				contractId,
				methodName: 'new',
				args: {
					linkdrop_contract: 'testnet'
				},
				gas
			});
		} catch (e) {
			if (!/contract has already been initialized/.test(e.toString())) {
				console.warn(e);
			}
		}
		
		assert.notStrictEqual(state.code_hash, '11111111111111111111111111111111');
	});

	// it('creation of linkdrop and wallet link for testing', async function() {

	// 	await alice.functionCall({
	// 		contractId,
	// 		methodName: 'send',
	// 		args: {
	// 			public_key: public_key1
	// 		},
	// 		gas,
	// 		// could be 0.02 N wallet needs to reduce gas from 100 Tgas to 50 Tgas
	// 		attachedDeposit
	// 	});

	// 	console.log(`https://wallet.testnet.near.org/linkdrop/${contractId}/${keyPair1.secretKey}?redirectUrl=https://example.com`);

	// 	return true;
	// });

	/// keyPair1

	it('creation of linkdrops', async function() {

		const EXTRA = 0
		const extraKeys = []
		for (let i = 0; i < EXTRA; i++) {
			extraKeys.push(KeyPair.fromRandom('ed25519').publicKey.toString())
		}

		await recordStart(contractId)

		const res = await alice.functionCall({
			contractId,
			methodName: 'send_multiple',
			args: {
				public_keys: [public_key1, public_key2, ...extraKeys]
			},
			gas: gasMultiple,
			attachedDeposit: parseNearAmount((0.02 * (EXTRA+2)).toString())
		});

		console.log(`https://wallet.testnet.near.org/linkdrop/${contractId}/${keyPair1.secretKey}?redirectUrl=https://example.com`);
		console.log(`https://wallet.testnet.near.org/linkdrop/${contractId}/${keyPair2.secretKey}?redirectUrl=https://example.com`);

		assert.strictEqual(res.status.SuccessValue, '');
	});

	// it('creation of account', async function() {
	// 	// WARNING tests after this with contractAccount will fail - signing key lost
	// 	// set key for contractAccount to linkdrop keyPair
	// 	near.connection.signer.keyStore.setKey(networkId, contractId, keyPair1);
	// 	const new_account_id = 'linkdrop-wrapper-' + Date.now().toString() + '.testnet';

	// 	const res = await linkdropAccount.functionCall({
	// 		contractId,
	// 		methodName: 'create_account_and_claim',
	// 		args: {
	// 			new_account_id,
	// 			new_public_key,
	// 		},
	// 		gas,
	// 	});

	// 	await recordStop(contractId)

	// 	console.log('created account', new_account_id)

	// 	try {
	// 		await (new Account(near.connection, new_account_id)).state()
	// 		assert(true)
	// 	} catch (e) {
	// 		assert(false)
	// 	}
	// });

	/// keyPair2

	// it('creation of linkdrop', async function() {

	// 	await recordStart(contractId)

	// 	const res = await alice.functionCall({
	// 		contractId,
	// 		methodName: 'send',
	// 		args: {
	// 			public_key: public_key2
	// 		},
	// 		gas,
	// 		attachedDeposit
	// 	});

	// 	assert.strictEqual(res.status.SuccessValue, '');
	// });

	// it('claim of linkdrop', async function() {
	// 	// WARNING tests after this with contractAccount will fail - signing key lost
	// 	// set key for contractAccount to linkdrop keyPair
	// 	near.connection.signer.keyStore.setKey(networkId, contractId, keyPair2);
	// 	const account_id = 'testnet';

	// 	const res = await linkdropAccount.functionCall({
	// 		contractId,
	// 		methodName: 'claim',
	// 		args: {
	// 			account_id,
	// 		},
	// 		gas,
	// 	});

	// 	await recordStop(contractId)

	// 	// console.log(res)

	// 	assert(true)
	// });

	/// testing if promise fails (must edit contract->on_account_created to return false)
	// it('creation of account - FAIL', async function() {
	// 	near.connection.signer.keyStore.setKey(networkId, contractId, keyPair2);
	// 	const new_account_id = 'linkdrop-wrapper-' + Date.now().toString();

	// 	try {
	// 		const res = await linkdropAccount.functionCall({
	// 			contractId,
	// 			methodName: 'create_account_and_claim',
	// 			args: {
	// 				new_account_id,
	// 				new_public_key,
	// 			},
	// 			gas,
	// 		});
	
	// 		console.log(new_account_id);
	// 		console.log(Buffer.from(res.status.SuccessValue, 'base64').toString('utf-8'))
	
	// 		// console.log(res)
	// 		// true
	// 		assert.strictEqual(res.status.SuccessValue, 'dHJ1ZQ==');
	// 	} catch(e) {
	// 		console.log('fail')
	// 		console.log(keyPair2.publicKey.toString())
	// 	}
		
	// });

});

'''
'''--- test/test-utils.js ---
const fs = require("fs");
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount, formatNearAmount } } } = nearAPI;
const { near, credentials, connection, keyStore, contract, contractAccount } = require('../utils/near-utils');
const getConfig = require('../utils/config');
const {
	networkId, contractName, contractMethods, gas,
	NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
} = getConfig('testnet');

const format = (amount) => {
	const res = formatNearAmount(amount, 8)
	if (res.indexOf('-') > -1) {
		return '-' + res.replace('-', '')
	}
	return res
}

const TEST_HOST = 'http://localhost:3000';
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			linkdrop_contract: contractId
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}

const initAccount = async(accountId, secret) => {
	account = new nearAPI.Account(connection, accountId);
	const newKeyPair = KeyPair.fromString(secret);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return account;
};

const createOrInitAccount = async(accountId, secret, amount = DEFAULT_NEW_CONTRACT_AMOUNT) => {
	let account;
	try {
		account = await createAccount(accountId, amount, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = initAccount(accountId, secret);
	}
	return account;
};

const getAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const account = new nearAPI.Account(connection, accountId);
	try {
		let secret;
		try {
			secret = JSON.parse(fs.readFileSync(process.env.HOME + `/.near-credentials/${networkId}/${accountId}.json`, 'utf-8')).private_key;
		} catch(e) {
			if (!/no such file|does not exist/.test(e.toString())) {
				throw e;
			}
			secret = fs.readFileSync(`./neardev/${accountId}`, 'utf-8');
		}
		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
		await account.state();
		return account;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount, secret);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
const createAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	fs.writeFileSync(`./neardev/${accountId}` , newKeyPair.toString(), 'utf-8');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, fundingAmount);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
};

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

const loadCredentials = (accountId) => {
	const credPath = `./neardev/${networkId}/${accountId}.json`;
	console.log(
		"Loading Credentials:\n",
		credPath
	);

	let credentials;
	try {
		credentials = JSON.parse(
			fs.readFileSync(
				credPath
			)
		);
	} catch(e) {
		console.warn('credentials not in /neardev');
		/// attempt to load backup creds from local machine
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${accountId}.json`
			)
		);
	}

	return credentials;
};

/// debugging

const getAccountBalance = (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();
const getAccountState = (accountId) => (new nearAPI.Account(connection, accountId)).state();
const totalDiff = (balanceBefore, balanceAfter) => format(new BN(balanceAfter.total).sub(new BN(balanceBefore.total)).toString());
const availableDiff = (balanceBefore, balanceAfter) => format(new BN(balanceAfter.available).sub(new BN(balanceBefore.available)).toString());
const stateCost = (balanceBefore, balanceAfter) => format(new BN(balanceAfter.stateStaked).sub(new BN(balanceBefore.stateStaked)).toString());
const bytesUsed = (stateBefore, stateAfter) => parseInt(stateAfter.storage_usage, 10) - parseInt(stateBefore.storage_usage);

/// analyzing

let data = {};
const recordStart = async (accountId) => {
	data[accountId] = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};
};

const recordStop = async (accountId) => {
	const before = data[accountId];
	const after = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};

	console.log(format(before.balance.total), format(after.balance.total))

	console.log(
		'\n', 'Analysis:', '\n',
		'Total diff:', totalDiff(before.balance, after.balance), '\n',
		'Avail diff:', availableDiff(before.balance, after.balance), '\n',
		'State used:', stateCost(before.balance, after.balance), '\n',
		'Bytes used:', bytesUsed(before.state, after.state), '\n',
	);
};

module.exports = { 
	recordStart,
	recordStop,
	TEST_HOST,
	near,
	gas,
	connection,
	credentials,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	networkId,
	contractId: contractName,
	contractMethods,
	contractAccount,
	initAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
	loadCredentials,
};

'''
'''--- utils/config.js ---
const contractName = 'ld.dolla.near';

module.exports = function getConfig(networkId = 'testnet') {
	let config = {
		networkId,
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	if (networkId) {
		config = {
			...config,
			GAS: "200000000000000",
			gas: "200000000000000",
			attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
			contractId: contractName,
			isBrowser: new Function("try {return this===window;}catch(e){ return false;}")()
		}
	}

	switch (networkId) {
		case 'testnet':
			config = {
				...config,
				networkId,
				explorerUrl: "https://explorer.testnet.near.org",
			};
			break;

		case 'mainnet':
			config = {
				...config,
				networkId,
				explorerUrl: "https://explorer.near.org",
				nodeUrl: "https://rpc.mainnet.near.org",
				walletUrl: "https://wallet.near.org",
				helperUrl: "https://helper.mainnet.near.org",
			};
			break;
	}

	return config;
};

'''
'''--- utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const networkId = process.env.REACT_APP_ENV === 'prod' ? 'mainnet' : 'testnet'
const { nodeUrl, walletUrl, contractId, isBrowser } = getConfig(networkId);

const {
	keyStores: { InMemoryKeyStore, BrowserLocalStorageKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials, keyStore;

if (isBrowser) {
	keyStore = new BrowserLocalStorageKeyStore();
} else {
	/// nodejs (for tests)
	try {
		console.log(`Loading Credentials: ${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
			)
		);
	} catch(e) {
		console.warn(`Loading Credentials: ./neardev/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`./neardev/${networkId}/${contractId}.json`
			)
		);
	}
	keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);
}

const near = new Near({
	networkId,
	nodeUrl,
	walletUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

module.exports = {
	near,
	credentials,
	keyStore,
	connection,
	contractId,
	contractAccount,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './test/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''
'''--- utils/patch-prod.js ---
const fs = require('fs');
const path = './utils/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = 'ld.dolla.near';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''