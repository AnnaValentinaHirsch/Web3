*GitHub Repository "near/near-indexer-events"*

'''--- Cargo.toml ---
[package]
name = "indexer-events"
version = "0.1.0"
edition = "2021"
rust-version = "1.64"

[lib]
proc-macro = true

[dependencies]
actix-web = "=4.0.1"
anyhow = "1.0.51"
avro-rs = "0.13.0"
base64 = "0.11"
bigdecimal = { version = "0.2", features = ["serde"] }
borsh = "0.9.3"
cached = "0.23.0"
clap = { version = "3.0.0-beta.5", features = ["color", "derive", "env"] }
dotenv = "0.15.0"
futures = "0.3.5"
hex = "0.4"
itertools = "0.9.0"
lazy_static = "1.4.0"
num-traits = "0.2.11"
primitive-types = { version = "0.10.0", default-features = false, features = ["rlp"] }
prometheus = "0.13.1"
quote = "1.0.17"
regex = "1.6.0"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
sqlx = { version = "0.5.13", features = ["runtime-tokio-native-tls", "postgres", "bigdecimal", "json"] }
syn = "1.0.90"
tempfile = "3.3.0"
tokio = { version = "1.8", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.35"
tracing-appender = "0.1.2"
tracing-subscriber = "0.2.4"

near-jsonrpc-primitives = "0.14.0"
near-jsonrpc-client = "0.4.0-beta.0"
near-lake-framework = "0.5.0"
near-primitives = "0.14.0"

'''
'''--- README.md ---
# Indexer Events

Async Postgres-compatible solution to load the data from NEAR blockchain.
Based on [NEAR Lake Framework](https://github.com/near/near-lake-framework-rs).

See [Indexer Base](https://github.com/near/near-indexer-base#indexer-base) docs for all the explanations, installation guide, etc.

This solution collects balance-changing events about FTs, NFTs, etc.

- We can index the blockchain from any point of time. The code does not check if all the previous history is collected.
- Potentially, some events may be skipped.
- We do not check the correctness of collected events, it should be done separately.
- We can re-run infinite number of indexers writing at the same DB, they may index same or different parts of the blockchain. It should not break the flow.

### Why existing `assets__*` tables are not enough?

`assets__non_fungible_token_events`, `assets__fungible_token_events` do not have the sorting column.
In the current solution, we've added artificial `event_index` column.

The new `coin_events` table stores the data in the format of affected/involved account_id, that simplifies filtering by affected `account_id`.  
`coin_events` still does not have `absolute_value` column, so you have to collect it from RPC if needed.

### What if my contract does not produce events?

Please go and update your contract with our new [SDK](https://github.com/near/near-sdk-rs).

If it's important for you to collect all the previous history as well, you need to make the contribution and implement your own legacy handler.  
You can use [existing handlers](src/db_adapters/coin/legacy) as the example, [wrap_near](src/db_adapters/coin/legacy/wrap_near.rs) may be a good starting point.

### My contract produces events/there's a custom legacy logic for my contract, but the Enhanced API still ignores me. Why?

It means that we've found inconsistency in the data you provided with the data we've queried by RPC.  
To be more clear, we collected all the logs/performed all the legacy logic, we know all the changed balances for all the active users at the end of the block.
After that, we ask the RPC to provide all the needed balances.
The numbers should be the same.
If they are not the same, it means the data is inconsistent.

When we meet the inconsistency, we mark such contract as "non-trusted".  
If you want to fix this, you need to write/edit [legacy handler](src/db_adapters/coin/legacy/DOC.md) for your contract.

### Contribution Guide

Please refer to this [guide](https://github.com/near/near-indexer-for-explorer/blob/master/CONTRIBUTING.md) before submitting PRs to this repo 
'''
'''--- migrations/20220712171424_initial.sql ---
CREATE TABLE nft_events
(
    event_index           numeric(38, 0) PRIMARY KEY,
    standard              text           NOT NULL,
    receipt_id            text           NOT NULL,
    block_height          numeric(20, 0) NOT NULL,
    block_timestamp       numeric(20, 0) NOT NULL,
    -- account_id of the contract itself. In a simple words, it's the owner/creator of NFT contract
    contract_account_id   text           NOT NULL,
    -- Unique ID of the token
    token_id              text           NOT NULL,
    cause                 text           NOT NULL,
    status                text           NOT NULL,
    -- Previous owner of the token. Null if we have nft_event_kind 'MINT'.
    old_owner_account_id  text,
    -- New owner of the token. Null if we have nft_event_kind 'BURN'.
    new_owner_account_id  text,
    authorized_account_id text,
    event_memo            text
);

CREATE INDEX CONCURRENTLY nft_events_block_height_idx ON nft_events (block_height);
CREATE INDEX CONCURRENTLY nft_events_receipt_id_idx ON nft_events (receipt_id);
CREATE INDEX CONCURRENTLY nft_events_old_owner_account_id_idx ON nft_events (old_owner_account_id);
CREATE INDEX CONCURRENTLY nft_events_new_owner_account_id_idx ON nft_events (new_owner_account_id);

-- ALTER TABLE nft_events
--     ADD CONSTRAINT nft_events_fk
--         FOREIGN KEY (receipt_id) REFERENCES receipts (receipt_id) ON DELETE CASCADE;

CREATE TABLE coin_events
(
    event_index         numeric(38, 0) PRIMARY KEY,
    standard            text           NOT NULL,
    receipt_id          text           NOT NULL,
    block_height        numeric(20, 0) NOT NULL,
    block_timestamp     numeric(20, 0) NOT NULL,
    -- account_id of the contract itself. In a simple words, it's the owner/creator of FT contract
    contract_account_id text           NOT NULL,
    affected_account_id text           NOT NULL,
    involved_account_id text,
    delta_amount        numeric(40, 0) NOT NULL,
    cause               text           NOT NULL,
    status              text           NOT NULL,
    -- Optional message associated with token movement.
    event_memo          text
);

CREATE INDEX CONCURRENTLY coin_events_block_height_idx ON coin_events (block_height);
CREATE INDEX CONCURRENTLY coin_events_receipt_id_idx ON coin_events (receipt_id);
CREATE INDEX CONCURRENTLY coin_events_affected_account_id_idx ON coin_events (affected_account_id);

-- ALTER TABLE coin_events
--     ADD CONSTRAINT coin_events_fk
--         FOREIGN KEY (receipt_id) REFERENCES receipts (receipt_id) ON DELETE CASCADE;

'''
'''--- src/configs.rs ---
use clap::Parser;
use tracing_subscriber::EnvFilter;

/// NEAR Indexer for Explorer
/// Watches for stream of blocks from the chain
#[derive(Parser, Debug)]
#[clap(
    version,
    author,
    about,
    disable_help_subcommand(true),
    propagate_version(true),
    next_line_help(true)
)]
pub(crate) struct Opts {
    /// Enabled Indexer for Explorer debug level of logs
    #[clap(long)]
    pub debug: bool,
    /// Block height to start the stream from
    #[clap(long, short, env)]
    pub start_block_height: u64,
    #[clap(long, short, env)]
    pub near_archival_rpc_url: String,
    // Chain ID: testnet or mainnet, used for NEAR Lake initialization
    #[clap(long, env)]
    pub chain_id: String,
    /// Port to enable metrics/health service
    #[clap(long, short, env, default_value_t = 3000)]
    pub port: u16,
}

impl Opts {
    // returns a Lake Config object where AWS credentials are sourced from .env file first, and then from .aws/credentials if not found.
    // https://docs.aws.amazon.com/sdk-for-rust/latest/dg/credentials.html
    pub async fn to_lake_config(&self) -> near_lake_framework::LakeConfig {
        let config_builder = near_lake_framework::LakeConfigBuilder::default();

        tracing::info!(target: crate::LOGGING_PREFIX, "CHAIN_ID: {}", self.chain_id);

        match self.chain_id.as_str() {
            "mainnet" => config_builder.mainnet(),
            "testnet" => config_builder.testnet(),
            invalid_chain => panic!(
                "Invalid CHAIN_ID: `{}`. Try `mainnet` or `testnet`",
                invalid_chain
            ),
        }
        .start_block_height(self.start_block_height)
        .build()
        .expect("Failed to build LakeConfig")
    }
}

pub(crate) fn init_tracing(
    debug: bool,
) -> anyhow::Result<tracing_appender::non_blocking::WorkerGuard> {
    let mut env_filter = EnvFilter::new("indexer_events=info");

    if debug {
        env_filter = env_filter.add_directive("near_lake_framework=debug".parse()?);
    }

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    tracing::warn!(
                        target: crate::LOGGING_PREFIX,
                        "Ignoring directive `{}`: {}",
                        s,
                        err
                    );
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    let (non_blocking, guard) = tracing_appender::non_blocking(std::io::stdout());

    let subscriber = tracing_subscriber::fmt::Subscriber::builder()
        .with_writer(non_blocking)
        .with_env_filter(env_filter);

    if std::env::var("ENABLE_JSON_LOGS").is_ok() {
        subscriber.json().init();
    } else {
        subscriber.compact().init();
    }

    Ok(guard)
}

'''
'''--- src/db_adapters/coin/legacy/DOC.md ---
## Legacy contracts

The contract is identified as legacy if it requires custom handling of its activity.
The most popular example: the contract has a period with some activity (coins minted/transferred/burnt), but no events were produced.
Another example: events are produced, but the part of the logic is not covered by events.  
We decided to make the custom support for some popular contracts.

If you are the author of the contract which does not produce the events, please upgrade your contract ASAP!
The old history (without corresponding events) will not be collected, but all the data starting from your upgrade wil be fetched successfully.

If it's important to collect the history when no events were produced, you have to write your own custom handler.
Please feel free to add implementation for your contract, we will re-index the data from time to time.

### Important details

The code here is duplicated more than it could be, but I decided not to generalize the logic because it's not intended to be reused or rewritten.  
I strongly recommend you to have a look at existing handlers before implementing your own one.

#### Mint

Some contracts may mint coins at `new` method: see `tkn_near`.  
Some contracts may mint coins at `ft_on_transfer` method: see `wentokensir`.

General mint methods are `mint`, `near_deposit`. The logic inside could differ a little.

#### Transfer
All the legacy contracts have the same logic regarding TRANSFER except Aurora.  
They implement `ft_transfer`, `ft_transfer_call`, `ft_resolve_transfer`, the code for handling transfers is the same except Aurora.

#### Burn

Most of the contracts have burn logic: see `withdraw`, `near_withdraw`. The logic inside also differs a little.

'''
'''--- src/db_adapters/coin/legacy/aurora.rs ---
use crate::db_adapters;
use crate::db_adapters::coin;
use crate::db_adapters::{numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::borsh;
use near_primitives::borsh::{BorshDeserialize, BorshSerialize};
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::io;
use std::ops::Mul;
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

// Took from the link below + some places around
// https://github.com/aurora-is-near/aurora-engine/blob/master/engine-types/src/parameters.rs
/// withdraw NEAR eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct WithdrawCallArgs {
    pub recipient_address: Address,
    pub amount: numeric_types::U128,
}

/// Base Eth Address type
#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Address(primitive_types::H160);

impl BorshSerialize for Address {
    fn serialize<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writer.write_all(self.0.as_bytes())
    }
}

impl BorshDeserialize for Address {
    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
        if buf.len() < 20 {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                "ETH_WRONG_ADDRESS_LENGTH",
            ));
        }
        // Guaranty no panics. The length checked early
        let address = Self(primitive_types::H160::from_slice(&buf[..20]));
        *buf = &buf[20..];
        Ok(address)
    }
}

pub(crate) async fn collect_aurora(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];
    for outcome in receipt_execution_outcomes {
        if outcome.receipt.receiver_id != AccountId::from_str("aurora")?
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events.extend(process_aurora_functions(block_header, action, outcome).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::Aurora,
    )?;
    Ok(events)
}

async fn process_aurora_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args, ..) = match action {
        ActionView::FunctionCall {
            method_name,
            args,
            deposit,
            ..
        } => (method_name, args, deposit),
        _ => return Ok(vec![]),
    };

    // Note: aurora (now always, but) usually has binary args
    let decoded_args = base64::decode(args)?;

    if vec![
        "new",
        "call",
        "new_eth_connector",
        "set_eth_connector_contract_data",
        "deposit",
        "storage_deposit",
        "submit",
        "deploy_erc20_token",
        "get_nep141_from_erc20",
        "ft_on_transfer",
        "ft_balance_of",
        "ft_metadata",
        "ft_total_supply",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // MINT may produce several events, where involved_account_id is always NULL
    // deposit do not mint anything; mint goes in finish_deposit
    if method_name == "finish_deposit" {
        let mut events = vec![];
        for log in &outcome.execution_outcome.outcome.logs {
            lazy_static::lazy_static! {
                static ref RE: regex::Regex = regex::Regex::new(r"^Mint (?P<amount>(0|[1-9][0-9]*)) nETH tokens for: (?P<account_id>[a-z0-9_\.\-]+)$").unwrap();
            }

            if let Some(cap) = RE.captures(log) {
                let amount = match cap.name("amount") {
                    Some(x) => x.as_str(),
                    None => anyhow::bail!("Unexpected mint log format in aurora: {}\n Expected format: Mint <amount> nETH tokens for: <account_id>", log)
                };
                if amount == "0" {
                    continue;
                }
                let account_id = match cap.name("account_id") {
                    Some(x) => x.as_str(),
                    None => anyhow::bail!("Unexpected mint log format in aurora: {}\n Expected format: Mint <amount> nETH tokens for: <account_id>", log)
                };

                let delta = BigDecimal::from_str(amount)?;
                let base = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: AccountId::from_str(account_id)?,
                    involved_id: None,
                    delta,
                    cause: "MINT".to_string(),
                    memo: None,
                };
                events.push(coin::build_event(base, custom).await?);
            };
        }

        return Ok(events);
    }

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        let mut events = vec![];
        for log in &outcome.execution_outcome.outcome.logs {
            lazy_static::lazy_static! {
                static ref RE: regex::Regex = regex::Regex::new(r"^Refund amount (?P<amount>(0|[1-9][0-9]*)) from (?P<from_account_id>[a-z0-9_\.\-]+) to (?P<to_account_id>[a-z0-9_\.\-]+)$").unwrap();
            }

            if let Some(cap) = RE.captures(log) {
                let amount = match cap.name("amount") {
                    Some(x) => x.as_str(),
                    None => anyhow::bail!("Unexpected ft_resolve_transfer log format in aurora: {}\n Expected format: Refund amount <amount> from <account_id> to <account_id>", log)
                };
                if amount == "0" {
                    continue;
                }
                let from_account_id = match cap.name("from_account_id") {
                    Some(x) => x.as_str(),
                    None => anyhow::bail!("Unexpected ft_resolve_transfer log format in aurora: {}\n Expected format: Refund amount <amount> from <account_id> to <account_id>", log)
                };
                let to_account_id = match cap.name("to_account_id") {
                    Some(x) => x.as_str(),
                    None => anyhow::bail!("Unexpected ft_resolve_transfer log format in aurora: {}\n Expected format: Refund amount <amount> from <account_id> to <account_id>", log)
                };

                let delta = BigDecimal::from_str(amount)?;
                let negative_delta = delta.clone().mul(BigDecimal::from(-1));

                let base_from = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: AccountId::from_str(from_account_id)?,
                    involved_id: Some(AccountId::from_str(to_account_id)?),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: None,
                };
                events.push(coin::build_event(base_from, custom_from).await?);

                let base_to = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: AccountId::from_str(to_account_id)?,
                    involved_id: Some(AccountId::from_str(from_account_id)?),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo: None,
                };
                events.push(coin::build_event(base_to, custom_to).await?);
            };
        }
        return Ok(events);
    }

    if method_name == "withdraw" {
        let args = match WithdrawCallArgs::try_from_slice(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let negative_delta =
            BigDecimal::from_str(&args.amount.0.to_string())?.mul(BigDecimal::from(-1));
        let base = db_adapters::get_base(Event::Aurora, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta: negative_delta,
            cause: "BURN".to_string(),
            memo: None,
        };

        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "AURORA {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

'''
'''--- src/db_adapters/coin/legacy/mod.rs ---
use crate::models::coin_events::CoinEvent;
use futures::try_join;
use near_lake_framework::near_indexer_primitives;

mod aurora;
mod rainbow_bridge;
mod skyward;
mod tkn_near;
mod wentokensir;
mod wrap_near;

pub(crate) async fn collect_legacy(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    chain_id: &str,
) -> anyhow::Result<Vec<CoinEvent>> {
    // We don't need to store legacy events for testnet
    if chain_id == "testnet" {
        return Ok(vec![]);
    }
    let mut events: Vec<CoinEvent> = vec![];

    let aurora_future = aurora::collect_aurora(shard_id, receipt_execution_outcomes, block_header);
    let rainbow_bridge_future =
        rainbow_bridge::collect_rainbow_bridge(shard_id, receipt_execution_outcomes, block_header);
    let skyward_future =
        skyward::collect_skyward(shard_id, receipt_execution_outcomes, block_header);
    let tkn_near_future =
        tkn_near::collect_tkn_near(shard_id, receipt_execution_outcomes, block_header);
    let wentokensir_future =
        wentokensir::collect_wentokensir(shard_id, receipt_execution_outcomes, block_header);
    let wrap_near_future =
        wrap_near::collect_wrap_near(shard_id, receipt_execution_outcomes, block_header);

    let (
        aurora_events,
        rainbow_bridge_events,
        skyward_events,
        tkn_near_events,
        wentokensir_events,
        wrap_near_events,
    ) = try_join!(
        aurora_future,
        rainbow_bridge_future,
        skyward_future,
        tkn_near_future,
        wentokensir_future,
        wrap_near_future
    )?;

    events.extend(aurora_events);
    events.extend(rainbow_bridge_events);
    events.extend(skyward_events);
    events.extend(tkn_near_events);
    events.extend(wentokensir_events);
    events.extend(wrap_near_events);
    Ok(events)
}

'''
'''--- src/db_adapters/coin/legacy/rainbow_bridge.rs ---
use crate::db_adapters;
use crate::db_adapters::{coin, numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::ops::{Mul, Sub};
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct Mint {
    pub account_id: AccountId,
    pub amount: String,
}

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct FtRefund {
    pub receiver_id: AccountId,
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct Withdraw {
    pub amount: numeric_types::U128,
    // Contains internal info of bridged contracts. It's not NEAR account_id
    // pub recipient: AccountId,
}

pub(crate) async fn collect_rainbow_bridge(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    for outcome in receipt_execution_outcomes {
        if !is_rainbow_bridge_contract(outcome.receipt.receiver_id.as_str())
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events
                    .extend(process_rainbow_bridge_functions(block_header, action, outcome).await?);
            }
        }
    }

    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::RainbowBridge,
    )?;

    Ok(events)
}

fn is_rainbow_bridge_contract(contract_id: &str) -> bool {
    if let Some(contract_prefix) = contract_id.strip_suffix(".factory.bridge.near") {
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("^[a-f0-9]+$").unwrap();
        }
        contract_prefix.len() == 40 && RE.is_match(contract_prefix)
    } else {
        false
    }
}

async fn process_rainbow_bridge_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args, ..) = match action {
        ActionView::FunctionCall {
            method_name,
            args,
            deposit,
            ..
        } => (method_name, args, deposit),
        _ => return Ok(vec![]),
    };

    let decoded_args = base64::decode(args)?;

    if vec![
        "storage_deposit",
        "finish_deposit",
        "verify_log_entry",
        "ft_balance_of",
        "ft_metadata",
        "set_metadata",
        "ft_total_supply",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // MINT produces 1 event, where involved_account_id is NULL
    if method_name == "mint" {
        let mint_args = match serde_json::from_slice::<Mint>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let delta = BigDecimal::from_str(&mint_args.amount)?;
        let base = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
        let custom = coin::FtEvent {
            // We can't use here outcome.receipt.predecessor_id, it's usually factory.bridge.near
            affected_id: mint_args.account_id.clone(),
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        if outcome.execution_outcome.outcome.logs.is_empty() {
            // ft_transfer_call was successful, there's nothing to return back
            return Ok(vec![]);
        }
        let ft_refund_args = match serde_json::from_slice::<FtRefund>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let mut delta = BigDecimal::from_str(&ft_refund_args.amount.0.to_string())?;
        // The contract may return only the part of the coins.
        // We should parse it from the output and subtract from the value from args
        if let ExecutionStatusView::SuccessValue(transferred_amount_decoded) =
            &outcome.execution_outcome.outcome.status
        {
            let transferred_amount =
                serde_json::from_slice::<String>(&base64::decode(transferred_amount_decoded)?)?;
            delta = delta.sub(BigDecimal::from_str(&transferred_amount)?);
        }
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_refund_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        for log in &outcome.execution_outcome.outcome.logs {
            if log == "The account of the sender was deleted" {
                // I never met this case so it's better to re-check it manually when we find it
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "The account of the sender was deleted {}",
                    block_header.height
                );

                // we should revert ft_transfer_call, but there's no receiver_id. We should burn tokens
                let base = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id,
                    involved_id: None,
                    delta: negative_delta,
                    cause: "BURN".to_string(),
                    memo,
                };
                return Ok(vec![coin::build_event(base, custom).await?]);
            }
            if log.starts_with("Refund ") {
                // we should revert ft_transfer_call
                let base_from = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id.clone(),
                    involved_id: Some(ft_refund_args.sender_id.clone()),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: memo.clone(),
                };

                let base_to = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: ft_refund_args.sender_id,
                    involved_id: Some(ft_refund_args.receiver_id),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo,
                };

                return Ok(vec![
                    coin::build_event(base_from, custom_from).await?,
                    coin::build_event(base_to, custom_to).await?,
                ]);
            }
        }
        return Ok(vec![]);
    }

    // BURN produces 1 event, where involved_account_id is NULL
    if method_name == "withdraw" {
        let ft_burn_args = match serde_json::from_slice::<Withdraw>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let negative_delta =
            BigDecimal::from_str(&ft_burn_args.amount.0.to_string())?.mul(BigDecimal::from(-1));

        let base = db_adapters::get_base(Event::RainbowBridge, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta: negative_delta,
            cause: "BURN".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "RAINBOW {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

'''
'''--- src/db_adapters/coin/legacy/skyward.rs ---
use crate::db_adapters;
use crate::db_adapters::{coin, numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::ops::{Mul, Sub};
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct FtNew {
    // pub metadata: ...,
    pub owner_id: AccountId,
    pub total_supply: numeric_types::U128,
}

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct FtRefund {
    pub receiver_id: AccountId,
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

pub(crate) async fn collect_skyward(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    for outcome in receipt_execution_outcomes {
        if outcome.receipt.receiver_id != AccountId::from_str("token.skyward.near")?
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events.extend(process_skyward_functions(block_header, action, outcome).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::Skyward,
    )?;

    Ok(events)
}

async fn process_skyward_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args) = match action {
        ActionView::FunctionCall {
            method_name, args, ..
        } => (method_name, args),
        _ => return Ok(vec![]),
    };

    let decoded_args = base64::decode(args)?;

    if vec![
        "storage_deposit",
        "ft_balance_of",
        "ft_metadata",
        "ft_total_supply",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // may mint the tokens
    if method_name == "new" {
        let args = match serde_json::from_slice::<FtNew>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&args.total_supply.0.to_string())?;
        let base = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: args.owner_id,
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // no examples of MINT calls except `new`

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        if outcome.execution_outcome.outcome.logs.is_empty() {
            // ft_transfer_call was successful, there's nothing to return back
            return Ok(vec![]);
        }
        let ft_refund_args = match serde_json::from_slice::<FtRefund>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let mut delta = BigDecimal::from_str(&ft_refund_args.amount.0.to_string())?;
        // The contract may return only the part of the coins.
        // We should parse it from the output and subtract from the value from args
        if let ExecutionStatusView::SuccessValue(transferred_amount_decoded) =
            &outcome.execution_outcome.outcome.status
        {
            let transferred_amount =
                serde_json::from_slice::<String>(&base64::decode(transferred_amount_decoded)?)?;
            delta = delta.sub(BigDecimal::from_str(&transferred_amount)?);
        }
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_refund_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        for log in &outcome.execution_outcome.outcome.logs {
            if log == "The account of the sender was deleted" {
                // I never met this case so it's better to re-check it manually when we find it
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "The account of the sender was deleted {}",
                    block_header.height
                );

                // we should revert ft_transfer_call, but there's no receiver_id. We should burn tokens
                let base = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id,
                    involved_id: None,
                    delta: negative_delta,
                    cause: "BURN".to_string(),
                    memo,
                };
                return Ok(vec![coin::build_event(base, custom).await?]);
            }
            if log.starts_with("Refund ") {
                // we should revert ft_transfer_call
                let base_from = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id.clone(),
                    involved_id: Some(ft_refund_args.sender_id.clone()),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: memo.clone(),
                };

                let base_to = db_adapters::get_base(Event::Skyward, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: ft_refund_args.sender_id,
                    involved_id: Some(ft_refund_args.receiver_id),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo,
                };
                return Ok(vec![
                    coin::build_event(base_from, custom_from).await?,
                    coin::build_event(base_to, custom_to).await?,
                ]);
            }
        }
        return Ok(vec![]);
    }

    // no examples of BURN calls

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "SKYWARD {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

'''
'''--- src/db_adapters/coin/legacy/tkn_near.rs ---
use crate::db_adapters;
use crate::db_adapters::{coin, numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::ops::{Mul, Sub};
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct FtNew {
    // pub metadata: ...,
    pub owner_id: AccountId,
    pub total_supply: numeric_types::U128,
}

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct FtRefund {
    pub receiver_id: AccountId,
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct NearWithdraw {
    pub amount: numeric_types::U128,
}

pub(crate) async fn collect_tkn_near(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    for outcome in receipt_execution_outcomes {
        if !is_tkn_near_contract(outcome.receipt.receiver_id.as_str())
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events.extend(process_tkn_near_functions(block_header, action, outcome).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::TknNear,
    )?;

    Ok(events)
}

fn is_tkn_near_contract(contract_id: &str) -> bool {
    if let Some(contract_prefix) = contract_id.strip_suffix(".tkn.near") {
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new(r"^[a-z0-9\-]+$").unwrap();
        }
        RE.is_match(contract_prefix)
    } else {
        false
    }
}

async fn process_tkn_near_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args, deposit) = match action {
        ActionView::FunctionCall {
            method_name,
            args,
            deposit,
            ..
        } => (method_name, args, deposit),
        _ => return Ok(vec![]),
    };

    let decoded_args = base64::decode(args)?;

    if vec![
        "storage_deposit",
        "ft_balance_of",
        "ft_metadata",
        "ft_total_supply",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // may mint the tokens
    if method_name == "new" {
        let args = match serde_json::from_slice::<FtNew>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&args.total_supply.0.to_string())?;
        let base = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: args.owner_id,
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // MINT produces 1 event, where involved_account_id is NULL.
    if method_name == "near_deposit" {
        let delta = BigDecimal::from_str(&deposit.to_string())?;
        let base = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        if outcome.execution_outcome.outcome.logs.is_empty() {
            // ft_transfer_call was successful, there's nothing to return back
            return Ok(vec![]);
        }
        let ft_refund_args = match serde_json::from_slice::<FtRefund>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let mut delta = BigDecimal::from_str(&ft_refund_args.amount.0.to_string())?;
        // The contract may return only the part of the coins.
        // We should parse it from the output and subtract from the value from args
        if let ExecutionStatusView::SuccessValue(transferred_amount_decoded) =
            &outcome.execution_outcome.outcome.status
        {
            let transferred_amount =
                serde_json::from_slice::<String>(&base64::decode(transferred_amount_decoded)?)?;
            delta = delta.sub(BigDecimal::from_str(&transferred_amount)?);
        }
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_refund_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        for log in &outcome.execution_outcome.outcome.logs {
            if log == "The account of the sender was deleted" {
                // I never met this case so it's better to re-check it manually when we find it
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "The account of the sender was deleted {}",
                    block_header.height
                );

                // we should revert ft_transfer_call, but there's no receiver_id. We should burn tokens
                let base = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id,
                    involved_id: None,
                    delta: negative_delta,
                    cause: "BURN".to_string(),
                    memo,
                };
                return Ok(vec![coin::build_event(base, custom).await?]);
            }
            if log.starts_with("Refund ") {
                // we should revert ft_transfer_call
                let base_from = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id.clone(),
                    involved_id: Some(ft_refund_args.sender_id.clone()),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: memo.clone(),
                };

                let base_to = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: ft_refund_args.sender_id,
                    involved_id: Some(ft_refund_args.receiver_id),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo,
                };

                return Ok(vec![
                    coin::build_event(base_from, custom_from).await?,
                    coin::build_event(base_to, custom_to).await?,
                ]);
            }
        }
        return Ok(vec![]);
    }

    // BURN produces 1 event, where involved_account_id is NULL
    // I've seen no burn events, but if someone calls it, it should be like this
    if method_name == "near_withdraw" {
        let ft_burn_args = match serde_json::from_slice::<NearWithdraw>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let negative_delta =
            BigDecimal::from_str(&ft_burn_args.amount.0.to_string())?.mul(BigDecimal::from(-1));

        let base = db_adapters::get_base(Event::TknNear, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta: negative_delta,
            cause: "BURN".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "TKN {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

'''
'''--- src/db_adapters/coin/legacy/wentokensir.rs ---
use crate::db_adapters;
use crate::db_adapters::{coin, numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::ops::{Mul, Sub};
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct FtOnTransfer {
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
}

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct FtRefund {
    pub receiver_id: AccountId,
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct NearWithdraw {
    pub amount: numeric_types::U128,
}

pub(crate) async fn collect_wentokensir(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    for outcome in receipt_execution_outcomes {
        if !is_wentokensir_contract(outcome.receipt.receiver_id.as_str())
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events.extend(process_wentokensir_functions(block_header, action, outcome).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::Wentokensir,
    )?;

    Ok(events)
}

fn is_wentokensir_contract(contract_id: &str) -> bool {
    if let Some(contract_prefix) = contract_id.strip_suffix(".wentokensir.near") {
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new(r"^[a-z0-9\-]+$").unwrap();
        }
        RE.is_match(contract_prefix)
    } else {
        false
    }
}

async fn process_wentokensir_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args, deposit) = match action {
        ActionView::FunctionCall {
            method_name,
            args,
            deposit,
            ..
        } => (method_name, args, deposit),
        _ => return Ok(vec![]),
    };

    let decoded_args = base64::decode(args)?;

    if vec![
        "storage_deposit",
        "new",
        "on_ft_metadata",
        "ft_balance_of",
        "ft_metadata",
        "ft_total_supply",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // MINT produces 1 event, where involved_account_id is NULL
    if method_name == "near_deposit" {
        let delta = BigDecimal::from_str(&deposit.to_string())?;
        let base = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // other way to make MINT
    if method_name == "ft_on_transfer" {
        let args = match serde_json::from_slice::<FtOnTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let delta = BigDecimal::from_str(&args.amount.0.to_string())?;
        let base = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: args.sender_id,
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        if outcome.execution_outcome.outcome.logs.is_empty() {
            // ft_transfer_call was successful, there's nothing to return back
            return Ok(vec![]);
        }
        let ft_refund_args = match serde_json::from_slice::<FtRefund>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let mut delta = BigDecimal::from_str(&ft_refund_args.amount.0.to_string())?;
        // The contract may return only the part of the coins.
        // We should parse it from the output and subtract from the value from args
        if let ExecutionStatusView::SuccessValue(transferred_amount_decoded) =
            &outcome.execution_outcome.outcome.status
        {
            let transferred_amount =
                serde_json::from_slice::<String>(&base64::decode(transferred_amount_decoded)?)?;
            delta = delta.sub(BigDecimal::from_str(&transferred_amount)?);
        }
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_refund_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        for log in &outcome.execution_outcome.outcome.logs {
            if log == "The account of the sender was deleted" {
                // I never met this case so it's better to re-check it manually when we find it
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "The account of the sender was deleted {}",
                    block_header.height
                );

                // we should revert ft_transfer_call, but there's no receiver_id. We should burn tokens
                let base = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id,
                    involved_id: None,
                    delta: negative_delta,
                    cause: "BURN".to_string(),
                    memo,
                };
                return Ok(vec![coin::build_event(base, custom).await?]);
            }
            if log.starts_with("Refund ") {
                // we should revert ft_transfer_call
                let base_from = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id.clone(),
                    involved_id: Some(ft_refund_args.sender_id.clone()),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: memo.clone(),
                };

                let base_to = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: ft_refund_args.sender_id,
                    involved_id: Some(ft_refund_args.receiver_id),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo,
                };

                return Ok(vec![
                    coin::build_event(base_from, custom_from).await?,
                    coin::build_event(base_to, custom_to).await?,
                ]);
            }
        }
        return Ok(vec![]);
    }

    // BURN produces 1 event, where involved_account_id is NULL
    // I've seen no burn events, but if someone calls it, it should be like this
    if method_name == "near_withdraw" {
        let ft_burn_args = match serde_json::from_slice::<NearWithdraw>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let negative_delta =
            BigDecimal::from_str(&ft_burn_args.amount.0.to_string())?.mul(BigDecimal::from(-1));

        let base = db_adapters::get_base(Event::Wentokensir, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta: negative_delta,
            cause: "BURN".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "WENTOKENSIR {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

'''
'''--- src/db_adapters/coin/legacy/wrap_near.rs ---
use crate::db_adapters;
use crate::db_adapters::{coin, numeric_types, Event};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use near_primitives::views::{ActionView, ExecutionStatusView, ReceiptEnumView};
use serde::Deserialize;
use std::ops::{Mul, Sub};
use std::str::FromStr;

#[derive(Deserialize, Debug, Clone)]
struct FtTransfer {
    pub receiver_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct FtRefund {
    pub receiver_id: AccountId,
    pub sender_id: AccountId,
    pub amount: numeric_types::U128,
    pub memo: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
struct NearWithdraw {
    pub amount: numeric_types::U128,
}

pub(crate) async fn collect_wrap_near(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    for outcome in receipt_execution_outcomes {
        if outcome.receipt.receiver_id != AccountId::from_str("wrap.near")?
            || !db_adapters::events::extract_events(outcome).is_empty()
        {
            continue;
        }
        if let ReceiptEnumView::Action { actions, .. } = &outcome.receipt.receipt {
            for action in actions {
                events.extend(process_wrap_near_functions(block_header, action, outcome).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut events,
        shard_id,
        block_header.timestamp,
        &Event::WrapNear,
    )?;

    Ok(events)
}

// We can't take the info from function call parameters, see https://explorer.near.org/transactions/AAcncdoxDGaoM8TMMRSVuMLfrRvvmAMtU3mDbtB9L6JJ#EahNmkevAXEjXeQfP6sxxi6c53KE1pZpwzNWoXnDWDeS
// We also can't just parse logs. near_deposit and ft_transfer_call are usually have logs duplicated
async fn process_wrap_near_functions(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    action: &ActionView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> anyhow::Result<Vec<CoinEvent>> {
    let (method_name, args) = match action {
        ActionView::FunctionCall {
            method_name, args, ..
        } => (method_name, args),
        _ => return Ok(vec![]),
    };

    let decoded_args = base64::decode(args)?;

    if vec![
        "storage_deposit",
        "ft_balance_of",
        "ft_metadata",
        "ft_total_supply",
        "new",
    ]
    .contains(&method_name.as_str())
    {
        return Ok(vec![]);
    }

    // MINT produces 1 event, where involved_account_id is NULL
    if method_name == "near_deposit" {
        // We can't take deposit value because of
        // https://explorer.near.org/transactions/AAcncdoxDGaoM8TMMRSVuMLfrRvvmAMtU3mDbtB9L6JJ#EahNmkevAXEjXeQfP6sxxi6c53KE1pZpwzNWoXnDWDeS
        let mut events = vec![];
        for log in &outcome.execution_outcome.outcome.logs {
            if let Some(mint) = process_mint_log(block_header, outcome, log).await? {
                events.push(mint);
            }
            // there are also transfer logs, but they are duplicated, we will catch them in transfer section
        }
        return Ok(events);
    }

    // TRANSFER produces 2 events
    // 1. affected_account_id is sender, delta is negative, absolute_amount decreased
    // 2. affected_account_id is receiver, delta is positive, absolute_amount increased
    if method_name == "ft_transfer" || method_name == "ft_transfer_call" {
        let ft_transfer_args = match serde_json::from_slice::<FtTransfer>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };

        let delta = BigDecimal::from_str(&ft_transfer_args.amount.0.to_string())?;
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_transfer_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        let base_from = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
        let custom_from = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: Some(ft_transfer_args.receiver_id.clone()),
            delta: negative_delta,
            cause: "TRANSFER".to_string(),
            memo: memo.clone(),
        };

        let base_to = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
        let custom_to = coin::FtEvent {
            affected_id: ft_transfer_args.receiver_id,
            involved_id: Some(outcome.receipt.predecessor_id.clone()),
            delta,
            cause: "TRANSFER".to_string(),
            memo,
        };
        return Ok(vec![
            coin::build_event(base_from, custom_from).await?,
            coin::build_event(base_to, custom_to).await?,
        ]);
    }

    // If TRANSFER failed, it could be revoked. The procedure is the same as for TRANSFER
    if method_name == "ft_resolve_transfer" {
        if outcome.execution_outcome.outcome.logs.is_empty() {
            // ft_transfer_call was successful, there's nothing to return back
            return Ok(vec![]);
        }
        let ft_refund_args = match serde_json::from_slice::<FtRefund>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let mut delta = BigDecimal::from_str(&ft_refund_args.amount.0.to_string())?;
        // The contract may return only the part of the coins.
        // We should parse it from the output and subtract from the value from args
        if let ExecutionStatusView::SuccessValue(transferred_amount_decoded) =
            &outcome.execution_outcome.outcome.status
        {
            let transferred_amount =
                serde_json::from_slice::<String>(&base64::decode(transferred_amount_decoded)?)?;
            delta = delta.sub(BigDecimal::from_str(&transferred_amount)?);
        }
        let negative_delta = delta.clone().mul(BigDecimal::from(-1));
        let memo = ft_refund_args
            .memo
            .as_ref()
            .map(|s| s.escape_default().to_string());

        for log in &outcome.execution_outcome.outcome.logs {
            if log == "The account of the sender was deleted" {
                // I never met this case so it's better to re-check it manually when we find it
                tracing::error!(
                    target: crate::LOGGING_PREFIX,
                    "The account of the sender was deleted {}",
                    block_header.height
                );

                // we should revert ft_transfer_call, but there's no receiver_id. We should burn tokens
                let base = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id,
                    involved_id: None,
                    delta: negative_delta,
                    cause: "BURN".to_string(),
                    memo,
                };
                return Ok(vec![coin::build_event(base, custom).await?]);
            }
            if log.starts_with("Refund ") {
                // we should revert ft_transfer_call
                let base_from = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
                let custom_from = coin::FtEvent {
                    affected_id: ft_refund_args.receiver_id.clone(),
                    involved_id: Some(ft_refund_args.sender_id.clone()),
                    delta: negative_delta,
                    cause: "TRANSFER".to_string(),
                    memo: memo.clone(),
                };

                let base_to = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
                let custom_to = coin::FtEvent {
                    affected_id: ft_refund_args.sender_id,
                    involved_id: Some(ft_refund_args.receiver_id),
                    delta,
                    cause: "TRANSFER".to_string(),
                    memo,
                };

                return Ok(vec![
                    coin::build_event(base_from, custom_from).await?,
                    coin::build_event(base_to, custom_to).await?,
                ]);
            }
        }
        return Ok(vec![]);
    }

    // BURN produces 1 event, where involved_account_id is NULL
    if method_name == "near_withdraw" {
        let ft_burn_args = match serde_json::from_slice::<NearWithdraw>(&decoded_args) {
            Ok(x) => x,
            Err(err) => {
                match outcome.execution_outcome.outcome.status {
                    // We couldn't parse args for failed receipt. Let's just ignore it, we can't save it properly
                    ExecutionStatusView::Unknown | ExecutionStatusView::Failure(_) => {
                        return Ok(vec![])
                    }
                    ExecutionStatusView::SuccessValue(_)
                    | ExecutionStatusView::SuccessReceiptId(_) => {
                        anyhow::bail!(err)
                    }
                }
            }
        };
        let negative_delta =
            BigDecimal::from_str(&ft_burn_args.amount.0.to_string())?.mul(BigDecimal::from(-1));

        let base = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: outcome.receipt.predecessor_id.clone(),
            involved_id: None,
            delta: negative_delta,
            cause: "BURN".to_string(),
            memo: None,
        };
        return Ok(vec![coin::build_event(base, custom).await?]);
    }

    tracing::error!(
        target: crate::LOGGING_PREFIX,
        "WRAP NEAR {} new method found: {}, receipt {}",
        block_header.height,
        method_name,
        outcome.receipt.receipt_id
    );
    Ok(vec![])
}

async fn process_mint_log(
    block_header: &near_indexer_primitives::views::BlockHeaderView,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
    log: &str,
) -> anyhow::Result<Option<CoinEvent>> {
    lazy_static::lazy_static! {
        static ref RE: regex::Regex = regex::Regex::new(r"^Deposit (?P<amount>(0|[1-9][0-9]*)) NEAR to (?P<account_id>[a-z0-9_\.\-]+)$").unwrap();
    }

    if let Some(cap) = RE.captures(log) {
        let amount = match cap.name("amount") {
                Some(x) => x.as_str(),
                None => anyhow::bail!("Unexpected deposit log format in wrap.near: {}\n Expected format: Deposit <amount> NEAR to <account_id>", log)
            };
        if amount == "0" {
            return Ok(None);
        }
        let account_id = match cap.name("account_id") {
                Some(x) => x.as_str(),
                None => anyhow::bail!("Unexpected deposit log format in wrap.near: {}\n Expected format: Deposit <amount> NEAR to <account_id>", log)
            };

        let delta = BigDecimal::from_str(amount)?;
        let base = db_adapters::get_base(Event::WrapNear, outcome, block_header)?;
        let custom = coin::FtEvent {
            affected_id: AccountId::from_str(account_id)?,
            involved_id: None,
            delta,
            cause: "MINT".to_string(),
            memo: None,
        };
        return Ok(Some(coin::build_event(base, custom).await?));
    }

    Ok(None)
}

'''
'''--- src/db_adapters/coin/mod.rs ---
use crate::db_adapters::Event;
use crate::models;
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use futures::future::try_join_all;
use futures::try_join;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use num_traits::Zero;

mod legacy;
mod nep141_events;

pub const FT: &str = "FT_NEP141";
pub const FT_LEGACY: &str = "FT_LEGACY";

struct FtEvent {
    pub affected_id: AccountId,
    pub involved_id: Option<AccountId>,
    pub delta: BigDecimal,
    pub cause: String,
    pub memo: Option<String>,
}

pub(crate) async fn store_ft(
    pool: &sqlx::Pool<sqlx::Postgres>,
    streamer_message: &near_indexer_primitives::StreamerMessage,
    chain_id: &str,
) -> anyhow::Result<()> {
    let mut events: Vec<CoinEvent> = vec![];

    let events_futures = streamer_message
        .shards
        .iter()
        .map(|shard| collect_ft_for_shard(streamer_message, shard, chain_id));
    for events_by_shard in try_join_all(events_futures).await? {
        events.extend(events_by_shard);
    }
    models::chunked_insert(pool, &events).await
}

pub(crate) fn filter_zeros_and_enumerate_events(
    ft_events: &mut Vec<crate::models::coin_events::CoinEvent>,
    shard_id: &near_indexer_primitives::types::ShardId,
    timestamp: u64,
    event_type: &Event,
) -> anyhow::Result<()> {
    ft_events.retain(|event| !event.delta_amount.is_zero());
    for (index, event) in ft_events.iter_mut().enumerate() {
        event.event_index =
            crate::db_adapters::compose_db_index(timestamp, shard_id, event_type, index)?;
    }
    Ok(())
}

async fn collect_ft_for_shard(
    streamer_message: &near_indexer_primitives::StreamerMessage,
    shard: &near_indexer_primitives::IndexerShard,
    chain_id: &str,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut events: Vec<CoinEvent> = vec![];

    let nep141_future = nep141_events::collect_nep141_events(
        &shard.shard_id,
        &shard.receipt_execution_outcomes,
        &streamer_message.block.header,
    );
    let legacy_contracts_future = legacy::collect_legacy(
        &shard.shard_id,
        &shard.receipt_execution_outcomes,
        &streamer_message.block.header,
        chain_id,
    );
    let (nep141_events, legacy_events) = try_join!(nep141_future, legacy_contracts_future)?;

    events.extend(nep141_events);
    events.extend(legacy_events);
    Ok(events)
}

async fn build_event(
    base: crate::db_adapters::EventBase,
    custom: FtEvent,
) -> anyhow::Result<CoinEvent> {
    Ok(CoinEvent {
        event_index: BigDecimal::zero(), // initialized later
        standard: base.standard,
        receipt_id: base.receipt_id,
        block_height: base.block_height,
        block_timestamp: base.block_timestamp,
        contract_account_id: base.contract_account_id.to_string(),
        affected_account_id: custom.affected_id.to_string(),
        involved_account_id: custom.involved_id.map(|id| id.to_string()),
        delta_amount: custom.delta,
        // coin_id: "".to_string(),
        cause: custom.cause,
        status: crate::db_adapters::get_status(&base.status),
        event_memo: custom.memo,
    })
}

'''
'''--- src/db_adapters/coin/nep141_events.rs ---
use crate::db_adapters::event_types;
use crate::db_adapters::event_types::Nep141Event;
use crate::db_adapters::Event;
use crate::db_adapters::{coin, events, get_base};
use crate::models::coin_events::CoinEvent;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_primitives::types::AccountId;
use std::ops::Mul;
use std::str::FromStr;

pub(crate) async fn collect_nep141_events(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut res = Vec::new();
    for outcome in receipt_execution_outcomes {
        let events = events::extract_events(outcome);
        for event in events {
            if let event_types::NearEvent::Nep141(ft_events) = event {
                res.extend(compose_db_events(&ft_events, outcome, block_header).await?);
            }
        }
    }
    coin::filter_zeros_and_enumerate_events(
        &mut res,
        shard_id,
        block_header.timestamp,
        &Event::Nep141,
    )?;

    Ok(res)
}

async fn compose_db_events(
    events: &Nep141Event,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<CoinEvent>> {
    let mut ft_events = Vec::new();
    match &events.event_kind {
        event_types::Nep141EventKind::FtMint(mint_events) => {
            for mint_event in mint_events {
                // We filter such things later; I add this check here
                // only because sweatcoin produces too many such events and we want to ignore them in the early beginning
                if mint_event.amount == "0" {
                    continue;
                }
                let base = get_base(Event::Nep141, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: AccountId::from_str(&mint_event.owner_id)?,
                    involved_id: None,
                    delta: BigDecimal::from_str(&mint_event.amount)?,
                    cause: "MINT".to_string(),
                    memo: mint_event
                        .memo
                        .as_ref()
                        .map(|s| s.escape_default().to_string()),
                };
                ft_events.push(coin::build_event(base, custom).await?);
            }
        }
        event_types::Nep141EventKind::FtTransfer(transfer_events) => {
            for transfer_event in transfer_events {
                let base = get_base(Event::Nep141, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: AccountId::from_str(&transfer_event.old_owner_id)?,
                    involved_id: Some(AccountId::from_str(&transfer_event.new_owner_id)?),
                    delta: BigDecimal::from_str(&transfer_event.amount)?.mul(BigDecimal::from(-1)),
                    cause: "TRANSFER".to_string(),
                    memo: transfer_event
                        .memo
                        .as_ref()
                        .map(|s| s.escape_default().to_string()),
                };
                ft_events.push(coin::build_event(base, custom).await?);

                let base = get_base(Event::Nep141, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: AccountId::from_str(&transfer_event.new_owner_id)?,
                    involved_id: Some(AccountId::from_str(&transfer_event.old_owner_id)?),
                    delta: BigDecimal::from_str(&transfer_event.amount)?,
                    cause: "TRANSFER".to_string(),
                    memo: transfer_event
                        .memo
                        .as_ref()
                        .map(|s| s.escape_default().to_string()),
                };
                ft_events.push(coin::build_event(base, custom).await?);
            }
        }
        event_types::Nep141EventKind::FtBurn(burn_events) => {
            for burn_event in burn_events {
                let base = get_base(Event::Nep141, outcome, block_header)?;
                let custom = coin::FtEvent {
                    affected_id: AccountId::from_str(&burn_event.owner_id)?,
                    involved_id: None,
                    delta: BigDecimal::from_str(&burn_event.amount)?.mul(BigDecimal::from(-1)),
                    cause: "BURN".to_string(),
                    memo: burn_event
                        .memo
                        .as_ref()
                        .map(|s| s.escape_default().to_string()),
                };
                ft_events.push(coin::build_event(base, custom).await?);
            }
        }
    }

    Ok(ft_events)
}

'''
'''--- src/db_adapters/event_types.rs ---
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "standard")]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent {
    Nep141(Nep141Event),
    Nep171(Nep171Event),
}

// *** NEP-141 FT ***
#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct Nep141Event {
    pub version: String,
    #[serde(flatten)]
    pub event_kind: Nep141EventKind,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
pub(crate) enum Nep141EventKind {
    FtMint(Vec<FtMintData>),
    FtTransfer(Vec<FtTransferData>),
    FtBurn(Vec<FtBurnData>),
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct FtMintData {
    pub owner_id: String,
    pub amount: String,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct FtTransferData {
    pub old_owner_id: String,
    pub new_owner_id: String,
    pub amount: String,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct FtBurnData {
    pub owner_id: String,
    pub amount: String,
    pub memo: Option<String>,
}

// *** NEP-171 NFT ***
#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct Nep171Event {
    pub version: String,
    #[serde(flatten)]
    pub event_kind: Nep171EventKind,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
pub(crate) enum Nep171EventKind {
    NftMint(Vec<NftMintData>),
    NftTransfer(Vec<NftTransferData>),
    NftBurn(Vec<NftBurnData>),
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct NftMintData {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct NftTransferData {
    pub authorized_id: Option<String>,
    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub(crate) struct NftBurnData {
    pub authorized_id: Option<String>,
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub memo: Option<String>,
}

'''
'''--- src/db_adapters/events.rs ---
use crate::db_adapters::event_types;
use crate::db_adapters::{coin, nft};
use futures::try_join;
use near_lake_framework::near_indexer_primitives;

pub(crate) async fn store_events(
    pool: &sqlx::Pool<sqlx::Postgres>,
    streamer_message: &near_indexer_primitives::StreamerMessage,
    chain_id: &str,
) -> anyhow::Result<()> {
    try_join!(
        coin::store_ft(pool, streamer_message, chain_id),
        nft::store_nft(pool, streamer_message),
    )?;
    Ok(())
}

pub(crate) fn extract_events(
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
) -> Vec<event_types::NearEvent> {
    let prefix = "EVENT_JSON:";
    outcome.execution_outcome.outcome.logs.iter().filter_map(|untrimmed_log| {
        let log = untrimmed_log.trim();
        if !log.starts_with(prefix) {
            return None;
        }

        match serde_json::from_str::<'_, event_types::NearEvent>(
            log[prefix.len()..].trim(),
        ) {
            Ok(result) => Some(result),
            Err(err) => {
                tracing::info!(
                    target: crate::LOGGING_PREFIX,
                    "Provided event log does not correspond to any of formats defined in NEP. Will ignore this event. \n {:#?} \n{:#?}",
                    err,
                    untrimmed_log,
                );
                None
            }
        }
    }).collect()
}

'''
'''--- src/db_adapters/mod.rs ---
use crate::db_adapters::coin::{FT, FT_LEGACY};
use crate::db_adapters::nft::NFT;
use bigdecimal::BigDecimal;
use near_lake_framework::near_indexer_primitives;
use near_lake_framework::near_indexer_primitives::views::ExecutionStatusView;
use std::str::FromStr;

mod coin;
mod event_types;
pub(crate) mod events;
mod nft;
mod numeric_types;

pub(crate) const CHUNK_SIZE_FOR_BATCH_INSERT: usize = 100;
pub(crate) const RETRY_COUNT: usize = 10;

pub(crate) enum Event {
    Nep141,
    Nep171,
    Aurora,
    RainbowBridge,
    Skyward,
    TknNear,
    Wentokensir,
    WrapNear,
}

pub(crate) struct EventBase {
    pub standard: String,
    pub receipt_id: String,
    pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
    pub contract_account_id: near_primitives::types::AccountId,
    pub status: ExecutionStatusView,
}

pub(crate) fn get_base(
    event_type: Event,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<EventBase> {
    Ok(EventBase {
        standard: get_standard(&event_type),
        receipt_id: outcome.receipt.receipt_id.to_string(),
        block_height: BigDecimal::from(block_header.height),
        block_timestamp: BigDecimal::from(block_header.timestamp),
        contract_account_id: outcome.execution_outcome.outcome.executor_id.clone(),
        status: outcome.execution_outcome.outcome.status.clone(),
    })
}

fn get_standard(event_type: &Event) -> String {
    match event_type {
        Event::Nep141 => FT,
        Event::Nep171 => NFT,
        Event::Aurora => FT_LEGACY,
        Event::RainbowBridge => FT_LEGACY,
        Event::Skyward => FT_LEGACY,
        Event::TknNear => FT_LEGACY,
        Event::Wentokensir => FT_LEGACY,
        Event::WrapNear => FT_LEGACY,
    }
    .to_string()
}

fn get_status(status: &ExecutionStatusView) -> String {
    match status {
        ExecutionStatusView::Unknown => {
            tracing::warn!(
                target: crate::LOGGING_PREFIX,
                "Unknown execution status view",
            );
            "UNKNOWN"
        }
        ExecutionStatusView::Failure(_) => "FAILURE",
        ExecutionStatusView::SuccessValue(_) => "SUCCESS",
        ExecutionStatusView::SuccessReceiptId(_) => "SUCCESS",
    }
    .to_string()
}

fn compose_db_index(
    block_timestamp: u64,
    shard_id: &near_primitives::types::ShardId,
    event: &Event,
    event_index: usize,
) -> anyhow::Result<BigDecimal> {
    let event_type_index: u128 = match event {
        Event::Nep141 => 1,
        Event::Nep171 => 2,
        Event::Aurora => 3,
        Event::RainbowBridge => 4,
        Event::Skyward => 5,
        Event::TknNear => 6,
        Event::Wentokensir => 7,
        Event::WrapNear => 8,
    };
    let db_index: u128 = (block_timestamp as u128) * 100_000_000 * 100_000_000
        + (*shard_id as u128) * 1_000_000_000
        + event_type_index * 1_000_000
        + (event_index as u128);
    Ok(BigDecimal::from_str(&db_index.to_string())?)
}

'''
'''--- src/db_adapters/nft/mod.rs ---
use crate::db_adapters::Event;
use crate::models;
use crate::models::nft_events::NftEvent;
use futures::future::try_join_all;
use near_lake_framework::near_indexer_primitives;

mod nep171_events;

pub const NFT: &str = "NFT_NEP171";
// pub const NFT_LEGACY: &str = "NFT_LEGACY";

pub(crate) async fn store_nft(
    pool: &sqlx::Pool<sqlx::Postgres>,
    streamer_message: &near_indexer_primitives::StreamerMessage,
) -> anyhow::Result<()> {
    let mut nep171_events: Vec<NftEvent> = vec![];
    let nft_events_futures = streamer_message.shards.iter().map(|shard| {
        nep171_events::collect_nep171_events(
            &shard.shard_id,
            &shard.receipt_execution_outcomes,
            &streamer_message.block.header,
        )
    });
    for events in try_join_all(nft_events_futures).await? {
        nep171_events.extend(events);
    }
    models::chunked_insert(pool, &nep171_events).await
}

// todo it could be one method both for ft and nft
pub(crate) fn enumerate_events(
    nft_events: &mut [crate::models::nft_events::NftEvent],
    shard_id: &near_indexer_primitives::types::ShardId,
    timestamp: u64,
    event_type: &Event,
) -> anyhow::Result<()> {
    for (index, event) in nft_events.iter_mut().enumerate() {
        event.event_index =
            crate::db_adapters::compose_db_index(timestamp, shard_id, event_type, index)?;
    }
    Ok(())
}

'''
'''--- src/db_adapters/nft/nep171_events.rs ---
use bigdecimal::BigDecimal;

use crate::db_adapters::event_types::Nep171Event;
use crate::db_adapters::Event;
use crate::db_adapters::{events, get_status, nft};
use crate::models::nft_events::NftEvent;
use near_lake_framework::near_indexer_primitives;
use num_traits::Zero;

use crate::db_adapters::event_types;
use crate::db_adapters::nft::NFT;

pub(crate) async fn collect_nep171_events(
    shard_id: &near_indexer_primitives::types::ShardId,
    receipt_execution_outcomes: &[near_indexer_primitives::IndexerExecutionOutcomeWithReceipt],
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<NftEvent>> {
    let mut res = Vec::new();
    for outcome in receipt_execution_outcomes {
        for event in events::extract_events(outcome) {
            if let event_types::NearEvent::Nep171(nft_events) = event {
                compose_nft_db_events(&nft_events, outcome, block_header)?;
            }
        }
    }

    nft::enumerate_events(&mut res, shard_id, block_header.timestamp, &Event::Nep171)?;
    Ok(res)
}

fn compose_nft_db_events(
    events: &Nep171Event,
    outcome: &near_indexer_primitives::IndexerExecutionOutcomeWithReceipt,
    block_header: &near_indexer_primitives::views::BlockHeaderView,
) -> anyhow::Result<Vec<NftEvent>> {
    let mut nft_events = vec![];
    let contract_id = &outcome.receipt.receiver_id;
    match &events.event_kind {
        event_types::Nep171EventKind::NftMint(mint_events) => {
            for mint_event in mint_events {
                for token_id in &mint_event.token_ids {
                    nft_events.push(NftEvent {
                        event_index: BigDecimal::zero(), // initialized later
                        standard: NFT.to_string(),
                        receipt_id: outcome.receipt.receipt_id.to_string(),
                        block_height: BigDecimal::from(block_header.height),
                        block_timestamp: BigDecimal::from(block_header.timestamp),
                        contract_account_id: contract_id.to_string(),
                        token_id: token_id.escape_default().to_string(),
                        cause: "MINT".to_string(),
                        status: get_status(&outcome.execution_outcome.outcome.status),
                        old_owner_account_id: None,
                        new_owner_account_id: Some(
                            mint_event.owner_id.escape_default().to_string(),
                        ),
                        authorized_account_id: None,
                        event_memo: mint_event
                            .memo
                            .as_ref()
                            .map(|s| s.escape_default().to_string()),
                    });
                }
            }
        }
        event_types::Nep171EventKind::NftTransfer(transfer_events) => {
            for transfer_event in transfer_events {
                for token_id in &transfer_event.token_ids {
                    nft_events.push(NftEvent {
                        event_index: BigDecimal::zero(), // initialized later
                        standard: NFT.to_string(),
                        receipt_id: outcome.receipt.receipt_id.to_string(),
                        block_height: BigDecimal::from(block_header.height),
                        block_timestamp: BigDecimal::from(block_header.timestamp),
                        contract_account_id: contract_id.to_string(),
                        token_id: token_id.escape_default().to_string(),
                        cause: "TRANSFER".to_string(),
                        status: get_status(&outcome.execution_outcome.outcome.status),
                        old_owner_account_id: Some(
                            transfer_event.old_owner_id.escape_default().to_string(),
                        ),
                        new_owner_account_id: Some(
                            transfer_event.new_owner_id.escape_default().to_string(),
                        ),
                        authorized_account_id: transfer_event
                            .authorized_id
                            .as_ref()
                            .map(|s| s.escape_default().to_string()),
                        event_memo: transfer_event
                            .memo
                            .as_ref()
                            .map(|s| s.escape_default().to_string()),
                    });
                }
            }
        }
        event_types::Nep171EventKind::NftBurn(burn_events) => {
            for burn_event in burn_events {
                for token_id in &burn_event.token_ids {
                    nft_events.push(NftEvent {
                        event_index: BigDecimal::zero(), // initialized later
                        standard: NFT.to_string(),
                        receipt_id: outcome.receipt.receipt_id.to_string(),
                        block_height: BigDecimal::from(block_header.height),
                        block_timestamp: BigDecimal::from(block_header.timestamp),
                        contract_account_id: contract_id.to_string(),
                        token_id: token_id.escape_default().to_string(),
                        cause: "BURN".to_string(),
                        status: get_status(&outcome.execution_outcome.outcome.status),
                        old_owner_account_id: Some(
                            burn_event.owner_id.escape_default().to_string(),
                        ),
                        new_owner_account_id: None,
                        authorized_account_id: burn_event
                            .authorized_id
                            .as_ref()
                            .map(|s| s.escape_default().to_string()),
                        event_memo: burn_event
                            .memo
                            .as_ref()
                            .map(|s| s.escape_default().to_string()),
                    });
                }
            }
        }
    }
    Ok(nft_events)
}

'''
'''--- src/db_adapters/numeric_types.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Deserializer, Serialize, Serializer};

// Taken from https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/json_types/integers.rs
macro_rules! impl_str_type {
    ($iden: ident, $ty: tt) => {
        #[derive(
            Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, BorshDeserialize, BorshSerialize,
        )]
        pub struct $iden(pub $ty);

        impl From<$ty> for $iden {
            fn from(v: $ty) -> Self {
                Self(v)
            }
        }

        impl From<$iden> for $ty {
            fn from(v: $iden) -> $ty {
                v.0
            }
        }

        impl Serialize for $iden {
            fn serialize<S>(
                &self,
                serializer: S,
            ) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
            where
                S: Serializer,
            {
                serializer.serialize_str(&self.0.to_string())
            }
        }

        impl<'de> Deserialize<'de> for $iden {
            fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
            where
                D: Deserializer<'de>,
            {
                let s: String = Deserialize::deserialize(deserializer)?;
                Ok(Self(str::parse::<$ty>(&s).map_err(|err| {
                    serde::de::Error::custom(err.to_string())
                })?))
            }
        }
    };
}

impl_str_type!(U128, u128);
impl_str_type!(U64, u64);

'''
'''--- src/lib.rs ---
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct};

#[proc_macro_derive(FieldCount)]
pub fn derive_field_count(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemStruct);

    let name = &input.ident;
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
    let field_count = input.fields.iter().count();

    let output = quote! {
        impl #impl_generics FieldCount for #name #ty_generics #where_clause {
            fn field_count() -> usize {
                #field_count
            }
        }
    };

    TokenStream::from(output)
}

'''
'''--- src/main.rs ---
// TODO cleanup imports in all the files in the end
use crate::configs::{init_tracing, Opts};
use clap::Parser;
use dotenv::dotenv;
use futures::StreamExt;
use near_lake_framework::near_indexer_primitives;
use std::env;
mod configs;
mod db_adapters;
mod metrics;
mod models;

#[macro_use]
extern crate lazy_static;

pub(crate) const LOGGING_PREFIX: &str = "indexer_events";

const INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
const MAX_DELAY_TIME: std::time::Duration = std::time::Duration::from_secs(120);

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct AccountWithContract {
    pub account_id: near_primitives::types::AccountId,
    pub contract_account_id: near_primitives::types::AccountId,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenv().ok();
    let opts: Opts = Opts::parse();

    let pool = sqlx::PgPool::connect(&env::var("DATABASE_URL")?).await?;

    let _worker_guard = init_tracing(opts.debug)?;

    let config: near_lake_framework::LakeConfig = opts.to_lake_config().await;
    let (_lake_handle, stream) = near_lake_framework::streamer(config);

    tokio::spawn(async move {
        let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
            .map(|streamer_message| {
                handle_streamer_message(streamer_message, &pool, &opts.chain_id)
            })
            .buffer_unordered(1usize);

        let mut time_now = std::time::Instant::now();
        while let Some(handle_message) = handlers.next().await {
            match handle_message {
                Ok(block_height) => {
                    let elapsed = time_now.elapsed();
                    tracing::info!(
                        target: LOGGING_PREFIX,
                        "Elapsed time spent on block {}: {:.3?}",
                        block_height,
                        elapsed
                    );
                    time_now = std::time::Instant::now();
                }
                Err(e) => {
                    tracing::error!(target: LOGGING_PREFIX, "Stop indexing due to {}", e);
                    // we do not catch this error anywhere, this thread is just stopped with error,
                    // main thread continues serving metrics
                    anyhow::bail!(e)
                }
            }
        }
        Ok(()) // unreachable statement, loop above is endless
    });

    metrics::init_metrics_server(opts.port).await
}

async fn handle_streamer_message(
    streamer_message: near_indexer_primitives::StreamerMessage,
    pool: &sqlx::Pool<sqlx::Postgres>,
    chain_id: &str,
) -> anyhow::Result<u64> {
    metrics::BLOCK_PROCESSED_TOTAL.inc();
    // Prometheus Gauge Metric type do not support u64
    // https://github.com/tikv/rust-prometheus/issues/470
    metrics::LATEST_BLOCK_HEIGHT.set(i64::try_from(streamer_message.block.header.height)?);

    if streamer_message.block.header.height % 100 == 0 {
        tracing::info!(
            target: crate::LOGGING_PREFIX,
            "{} / shards {}",
            streamer_message.block.header.height,
            streamer_message.shards.len()
        );
    }

    db_adapters::events::store_events(pool, &streamer_message, chain_id).await?;

    Ok(streamer_message.block.header.height)
}

'''
'''--- src/metrics.rs ---
use actix_web::{get, App, HttpServer, Responder};
use prometheus::{Encoder, IntCounter, IntGauge, Opts};

use crate::LOGGING_PREFIX;

type Result<T, E> = std::result::Result<T, E>;

fn try_create_int_counter(name: &str, help: &str) -> Result<IntCounter, prometheus::Error> {
    let opts = Opts::new(name, help);
    let counter = IntCounter::with_opts(opts)?;
    prometheus::register(Box::new(counter.clone()))?;
    Ok(counter)
}

fn try_create_int_gauge(name: &str, help: &str) -> Result<IntGauge, prometheus::Error> {
    let opts = Opts::new(name, help);
    let gauge = IntGauge::with_opts(opts)?;
    prometheus::register(Box::new(gauge.clone()))?;
    Ok(gauge)
}

lazy_static! {
    pub(crate) static ref BLOCK_PROCESSED_TOTAL: IntCounter = try_create_int_counter(
        "indexer_events_total_blocks_processed",
        "Total number of blocks processed by indexer regardless of restarts. Used to calculate Block Processing Rate(BPS)"
    )
    .unwrap();
    pub(crate) static ref LATEST_BLOCK_HEIGHT: IntGauge = try_create_int_gauge(
        "indexer_events_latest_block_height",
        "Last seen block height by indexer"
    )
    .unwrap();
}

#[get("/metrics")]
async fn get_metrics() -> impl Responder {
    let encoder = prometheus::TextEncoder::new();

    let mut buffer = Vec::new();
    if let Err(e) = encoder.encode(&prometheus::gather(), &mut buffer) {
        tracing::error!(target: LOGGING_PREFIX, "could not encode metrics: {}", e);
    };

    match String::from_utf8(buffer.clone()) {
        Ok(v) => v,
        Err(e) => {
            tracing::error!(
                target: LOGGING_PREFIX,
                "custom metrics could not be from_utf8'd: {}",
                e
            );
            String::default()
        }
    }
}

pub(crate) async fn init_metrics_server(port: u16) -> anyhow::Result<()> {
    tracing::info!(
        target: LOGGING_PREFIX,
        "Starting metrics server on http://0.0.0.0:{port}/metrics"
    );

    HttpServer::new(|| App::new().service(get_metrics))
        .bind(("0.0.0.0", port))?
        .run()
        .await
        .map_err(|e| anyhow::anyhow!("Error while executing HTTP Server: {}", e))
}

'''
'''--- src/models/coin_events.rs ---
use bigdecimal::BigDecimal;
use sqlx::Arguments;

use crate::models::FieldCount;

#[derive(Debug, sqlx::FromRow, FieldCount)]
pub struct CoinEvent {
    pub event_index: BigDecimal,
    pub standard: String,
    pub receipt_id: String,
    pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
    pub contract_account_id: String,
    pub affected_account_id: String,
    pub involved_account_id: Option<String>,
    pub delta_amount: BigDecimal,
    pub cause: String,
    pub status: String,
    pub event_memo: Option<String>,
}

impl crate::models::SqlMethods for CoinEvent {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments) {
        args.add(&self.event_index);
        args.add(&self.standard);
        args.add(&self.receipt_id);
        args.add(&self.block_height);
        args.add(&self.block_timestamp);
        args.add(&self.contract_account_id);
        args.add(&self.affected_account_id);
        args.add(&self.involved_account_id);
        args.add(&self.delta_amount);
        args.add(&self.cause);
        args.add(&self.status);
        args.add(&self.event_memo);
    }

    fn insert_query(items_count: usize) -> anyhow::Result<String> {
        Ok("INSERT INTO coin_events VALUES ".to_owned()
            + &crate::models::create_placeholders(items_count, CoinEvent::field_count())?
            + " ON CONFLICT DO NOTHING")
    }

    fn name() -> String {
        "coin_events".to_string()
    }
}

'''
'''--- src/models/contracts.rs ---
use bigdecimal::BigDecimal;
use sqlx::Arguments;

use crate::models::FieldCount;

#[derive(Debug, Clone, sqlx::FromRow, FieldCount)]
pub struct Contract {
    pub contract_account_id: String,
    pub standard: String,
    pub first_event_at_timestamp: BigDecimal,
    pub first_event_at_block_height: BigDecimal,
    pub inconsistency_found_at_timestamp: Option<BigDecimal>,
    pub inconsistency_found_at_block_height: Option<BigDecimal>,
}

impl crate::models::SqlMethods for Contract {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments) {
        args.add(&self.contract_account_id);
        args.add(&self.standard);
        args.add(&self.first_event_at_timestamp);
        args.add(&self.first_event_at_block_height);
        args.add(&self.inconsistency_found_at_timestamp);
        args.add(&self.inconsistency_found_at_block_height);
    }

    fn insert_query(items_count: usize) -> anyhow::Result<String> {
        Ok("INSERT INTO contracts VALUES ".to_owned()
            + &crate::models::create_placeholders(items_count, Contract::field_count())?
            + " ON CONFLICT (contract_account_id) DO UPDATE SET "
            + " first_event_at_timestamp = least(contracts.first_event_at_timestamp, excluded.first_event_at_timestamp), "
            + " first_event_at_block_height = least(contracts.first_event_at_block_height, excluded.first_event_at_block_height), "
            + " inconsistency_found_at_timestamp = least(contracts.inconsistency_found_at_timestamp, excluded.inconsistency_found_at_timestamp), "
            + " inconsistency_found_at_block_height = least(contracts.inconsistency_found_at_block_height, excluded.inconsistency_found_at_block_height)")
    }

    fn name() -> String {
        "contracts".to_string()
    }
}

'''
'''--- src/models/mod.rs ---
use futures::future::try_join_all;
use std::fmt::Write;

pub use indexer_events::FieldCount;

pub(crate) mod coin_events;
pub(crate) mod contracts;
pub(crate) mod nft_events;

pub trait FieldCount {
    /// Get the number of fields on a struct.
    fn field_count() -> usize;
}

pub trait SqlMethods {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments);
    fn insert_query(count: usize) -> anyhow::Result<String>;
    fn name() -> String;
}

pub async fn chunked_insert<T: SqlMethods + std::fmt::Debug>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    items: &[T],
) -> anyhow::Result<()> {
    let futures = items
        .chunks(crate::db_adapters::CHUNK_SIZE_FOR_BATCH_INSERT)
        .map(|items_part| insert_retry_or_panic(pool, items_part, crate::db_adapters::RETRY_COUNT));
    try_join_all(futures).await.map(|_| ())
}

async fn insert_retry_or_panic<T: SqlMethods + std::fmt::Debug>(
    pool: &sqlx::Pool<sqlx::Postgres>,
    items: &[T],
    retry_count: usize,
) -> anyhow::Result<()> {
    let mut interval = crate::INTERVAL;
    let mut retry_attempt = 0usize;
    let query = T::insert_query(items.len())?;

    loop {
        if retry_attempt == retry_count {
            return Err(anyhow::anyhow!(
                "Failed to perform query to database after {} attempts. Stop trying.",
                retry_count
            ));
        }
        retry_attempt += 1;

        let mut args = sqlx::postgres::PgArguments::default();
        for item in items {
            item.add_to_args(&mut args);
        }

        match sqlx::query_with(&query, args).execute(pool).await {
            Ok(_) => break,
            Err(async_error) => {
                tracing::warn!(
                    target: crate::LOGGING_PREFIX,
                    "Error occurred during {}:\n{} were not stored. \n{:#?} \n Retrying in {} milliseconds...",
                    async_error,
                    &T::name(),
                    &items,
                    interval.as_millis(),
                );
                tokio::time::sleep(interval).await;
                if interval < crate::MAX_DELAY_TIME {
                    interval *= 2;
                }
            }
        }
    }
    Ok(())
}

// Generates `($1, $2), ($3, $4)`
pub(crate) fn create_placeholders(
    mut items_count: usize,
    fields_count: usize,
) -> anyhow::Result<String> {
    if items_count < 1 {
        return Err(anyhow::anyhow!("At least 1 item expected"));
    }

    let mut start_num: usize = 1;
    let mut res = create_placeholder(&mut start_num, fields_count)?;
    items_count -= 1;
    while items_count > 0 {
        write!(
            res,
            ", {}",
            create_placeholder(&mut start_num, fields_count)?
        )?;
        items_count -= 1;
    }

    Ok(res)
}

// Generates `($1, $2, $3)`
pub(crate) fn create_placeholder(
    start_num: &mut usize,
    mut fields_count: usize,
) -> anyhow::Result<String> {
    if fields_count < 1 {
        return Err(anyhow::anyhow!("At least 1 field expected"));
    }
    let mut item = format!("(${}", start_num);
    *start_num += 1;
    fields_count -= 1;
    while fields_count > 0 {
        write!(item, ", ${}", start_num)?;
        *start_num += 1;
        fields_count -= 1;
    }
    item += ")";
    Ok(item)
}

'''
'''--- src/models/nft_events.rs ---
use bigdecimal::BigDecimal;
use sqlx::Arguments;

use crate::models::FieldCount;

#[derive(Debug, sqlx::FromRow, FieldCount)]
pub struct NftEvent {
    pub event_index: BigDecimal,
    pub standard: String,
    pub receipt_id: String,
    pub block_height: BigDecimal,
    pub block_timestamp: BigDecimal,
    pub contract_account_id: String,
    pub token_id: String,
    pub cause: String,
    pub status: String,
    pub old_owner_account_id: Option<String>,
    pub new_owner_account_id: Option<String>,
    pub authorized_account_id: Option<String>,
    pub event_memo: Option<String>,
}

impl crate::models::SqlMethods for NftEvent {
    fn add_to_args(&self, args: &mut sqlx::postgres::PgArguments) {
        args.add(&self.event_index);
        args.add(&self.standard);
        args.add(&self.receipt_id);
        args.add(&self.block_height);
        args.add(&self.block_timestamp);
        args.add(&self.contract_account_id);
        args.add(&self.token_id);
        args.add(&self.cause);
        args.add(&self.status);
        args.add(&self.old_owner_account_id);
        args.add(&self.new_owner_account_id);
        args.add(&self.authorized_account_id);
        args.add(&self.event_memo);
    }

    fn insert_query(items_count: usize) -> anyhow::Result<String> {
        Ok("INSERT INTO nft_events VALUES ".to_owned()
            + &crate::models::create_placeholders(items_count, NftEvent::field_count())?
            + " ON CONFLICT DO NOTHING")
    }

    fn name() -> String {
        "nft_events".to_string()
    }
}

'''