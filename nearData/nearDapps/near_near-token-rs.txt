*GitHub Repository "near/near-token-rs"*

'''--- .github/workflows/ci.yml ---
name: CI

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  RUSTFLAGS: -D warnings
  RUST_BACKTRACE: short
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0

jobs:
  test-msrv:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Install minimal supported Rust version
      uses: dtolnay/rust-toolchain@1.68

    - name: Run cargo test
      run: cargo test --verbose

  test-all-features:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Install minimal supported Rust version
      uses: dtolnay/rust-toolchain@stable

    - name: Run cargo test
      run: cargo test --verbose --all-features

  clippy:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Run clippy
      run: cargo clippy --all-features -- -D clippy::all

  cargo-fmt:
    runs-on: ubuntu-20.04

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Run cargo fmt
      run: cargo fmt -- --check

  release-plz:
    runs-on: ubuntu-latest
    needs: [test-msrv, test-all-features, clippy, cargo-fmt]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://marcoieni.github.io/release-plz/github-action.html#triggering-further-workflow-runs
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.0](https://github.com/near/near-token-rs/compare/v0.1.0...v0.2.0) - 2023-10-28

### Other
- [**breaking**] Renamed NearTokenError variants and implemented std::error::Error and Display traits for it ([#8](https://github.com/near/near-token-rs/pull/8))
- Added more examples to `README.md` ([#6](https://github.com/near/near-token-rs/pull/6))

'''
'''--- Cargo.toml ---
[package]
name = "near-token"
version = "0.2.0"
edition = "2021"
authors = ["Serhieiev Ivan <serhieievivan6@gmail.com>", "Vlad Frolov <frolvlad@gmail.com>"]
repository = "https://github.com/near/near-token"
rust-version = "1.68.2"
categories = ["parser-implementations", "value-formatting", "no-std"]
license = "MIT OR Apache-2.0"
description = "a small crate to work with NEAR token values ergonomically and efficiently (NEAR Protocol)"

[dependencies]
serde = { version = "1", features = ["derive"], optional = true }
borsh = { version = "1", features = ["derive"], optional = true }
schemars = { version = "0.8.8", optional = true }
interactive-clap = { version = "0.2.4", optional = true }

[dev-dependencies]
serde_json = { version = "1" }

[features]
abi = ["borsh/unstable__schema", "schemars"]

'''
'''--- README.md ---
<p>
    <a href="https://crates.io/crates/near-token"><img src="https://img.shields.io/crates/d/near-token?style=flat-square&logo=near&label=crates.io" alt="Crates.io (latest)"></a>
    <a href="https://docs.rs/near-token/latest/near_token"><img src="https://img.shields.io/docsrs/near-token?style=flat-square" alt="Docs.rs"></a>
    <img src="https://img.shields.io/badge/rustc-1.68%2B-lightgray.svg?style=flat-square" alt="Rust Version">
</p>

# near-token
near-token is crate for work with [tokens](https://docs.near.org/concepts/basics/tokens) in near-protocol.

The crate includes NearToken type and constructors for converting data as NearToken and as u128 type values.

## Examples

### Basic

Add near-token to your dependencies:

```bash
cargo add near-token
```

Here is the basic usage of near-token crate:

```rust
use near_token::NearToken;

fn main() {
    const TEN_NEAR: NearToken = NearToken::from_near(10);

    assert_eq!(TEN_NEAR.to_string(), "10.00 NEAR");
    assert_eq!(TEN_NEAR.as_near(), 10);
    assert_eq!(TEN_NEAR.as_millinear(), 10000);
    assert_eq!(TEN_NEAR.as_yoctonear(), 10000000000000000000000000);

    let input_str = "0.123456 NEAR";
    let input_near: NearToken = input_str.parse().unwrap();
    assert_eq!(
        input_near,
        NearToken::from_yoctonear(123456000000000000000000)
    );

}
```

### serde support

In order to use NearToken in `serde`-serializable structs, enable `serde` feature:

```bash
cargo add near-token --features serde
```

Here is the basic usage of near-token crate with serde:

```rust
// When `serde` feature is enabled, NearToken can be used in serde-serializable structs.
// NearToken will be serialized to a token-precision u128 value encoded as string.
#[derive(serde::Serialize)]
struct TransferDetails {
    amount: NearToken,
}

fn main() {
    const TEN_NEAR: NearToken = NearToken::from_near(10);

    let details = TransferDetails { amount: TEN_NEAR };
    assert_eq!(
        serde_json::to_string(&details).unwrap(),
        r#"{"amount":"10000000000000000000000000"}"#
    );
}
```

### borsh support

In order to use NearToken in `borsh`-serializable structs, enable `borsh` feature:

```bash
cargo add near-token --features borsh
```

Here is the basic usage of near-token crate with borsh:

```rust
use borsh::{to_vec, BorshSerialize};
use near_token::NearToken;

#[derive(BorshSerialize)]
struct TransferDetails {
    amount: NearToken,
}

fn main() {
    const TEN_NEAR: NearToken = NearToken::from_near(10);

    let details = TransferDetails { amount: TEN_NEAR };
    assert_eq!(
        to_vec(&details).unwrap(),
        vec![0, 0, 0, 74, 72, 1, 20, 22, 149, 69, 8, 0, 0, 0, 0, 0]
    );
}
```

## NearToken information

NEAR is used to price computation and storage on the NEAR infrastructure. The network charges transaction fees in NEAR to process changes and transactions.

### License

This project is licensed under the [MIT license] and [Apache-2.0 license].

[MIT license]: https://github.com/near/near-token/blob/main/LICENSE-MIT
[Apache-2.0 license]:  https://github.com/near/near-token/blob/main/LICENSE-APACHE

'''
'''--- src/error.rs ---
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NearTokenError {
    InvalidTokensAmount(crate::utils::DecimalNumberParsingError),
    InvalidTokenUnit(String),
}

impl std::fmt::Display for NearTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            NearTokenError::InvalidTokensAmount(err) => write!(f, "invalid tokens amount: {}", err),
            NearTokenError::InvalidTokenUnit(unit) => write!(f, "invalid token unit: {}", unit),
        }
    }
}

impl std::error::Error for NearTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            NearTokenError::InvalidTokensAmount(err) => Some(err),
            NearTokenError::InvalidTokenUnit(_) => None,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_near_token_error_display() {
        assert_eq!(
            format!(
                "{}",
                NearTokenError::InvalidTokensAmount(
                    crate::utils::DecimalNumberParsingError::InvalidNumber("abc".to_owned())
                )
            ),
            "invalid tokens amount: invalid number: abc"
        );
        assert_eq!(
            format!(
                "{}",
                NearTokenError::InvalidTokensAmount(
                    crate::utils::DecimalNumberParsingError::LongWhole("999999999999.0".to_owned())
                )
            ),
            "invalid tokens amount: too long whole part: 999999999999.0"
        );
        assert_eq!(
            format!(
                "{}",
                NearTokenError::InvalidTokensAmount(
                    crate::utils::DecimalNumberParsingError::LongFractional(
                        "0.999999999999".to_owned()
                    )
                )
            ),
            "invalid tokens amount: too long fractional part: 0.999999999999"
        );
        assert_eq!(
            format!("{}", NearTokenError::InvalidTokenUnit("abc".to_owned())),
            "invalid token unit: abc"
        );
    }
}

'''
'''--- src/lib.rs ---
//! A `NearToken` type to represent a value of Near.
//!
//! Each `Neartokens` is composed of a floating point number of tokens where each integer unit is equal to one yocto-Near.
//! `NearToken` is implementing the common trait `FromStr`. Also, have utils function to parse from `str` into `u128`.
//!
//! # Examples
//! ```
//! use near_token::NearToken;
//!
//! let one_near = NearToken::from_yoctonear(10_u128.pow(24));
//! assert_eq!(one_near, NearToken::from_near(1));
//! assert_eq!(one_near, NearToken::from_millinear(1000));
//! ```
//!
//! # Crate features
//!
//! * **borsh** (optional) -
//!   When enabled allows `NearToken` to serialized and deserialized by `borsh`.
//!
//! * **serde** (optional) -
//!   When enabled allows `NearToken` to serialized and deserialized by `serde`.
//!
//! * **schemars** (optional) -
//!  Implements `schemars::JsonSchema` for `NearToken`.
//!
//! * **interactive-clap** (optional) -
//!  Implements `interactive_clap::ToCli` for `NearToken`.
mod error;

mod utils;

mod trait_impls;

pub use self::error::NearTokenError;
pub use self::utils::DecimalNumberParsingError;

#[derive(Default, Debug, Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Hash)]
#[cfg_attr(
    feature = "borsh",
    derive(borsh::BorshDeserialize, borsh::BorshSerialize)
)]
#[cfg_attr(feature = "abi", derive(borsh::BorshSchema))]
#[repr(transparent)]
pub struct NearToken {
    inner: u128,
}

const ONE_NEAR: u128 = 10_u128.pow(24);
const ONE_MILLINEAR: u128 = 10_u128.pow(21);

impl NearToken {
    /// `from_yoctonear` is a function that takes value by a number of yocto-near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!( NearToken::from_yoctonear(10u128.pow(21)), NearToken::from_millinear(1))
    /// ```
    pub const fn from_yoctonear(inner: u128) -> Self {
        Self { inner }
    }

    /// `from_millinear` is a function that takes value by a number of mili-near and converts it to an equivalent to the yocto-near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_millinear(1), NearToken::from_yoctonear(10u128.pow(21)))
    /// ```
    pub const fn from_millinear(inner: u128) -> Self {
        Self {
            inner: inner * ONE_MILLINEAR,
        }
    }

    /// `from_near` is a function that takes value by a number of near and converts it to an equivalent to the yocto-near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_near(1), NearToken::from_yoctonear(10u128.pow(24)))
    /// ```
    pub const fn from_near(inner: u128) -> Self {
        Self {
            inner: inner * ONE_NEAR,
        }
    }

    /// `as_near` is a function that converts number of yocto-near to an equivalent to the near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(10u128.pow(24)).as_near(), 1)
    /// ```
    pub const fn as_near(&self) -> u128 {
        self.inner / ONE_NEAR
    }

    /// `as_millinear` is a function that converts number of yocto-near to an equivalent to the mili-near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(10u128.pow(21)).as_millinear(), 1)
    /// ```
    pub const fn as_millinear(&self) -> u128 {
        self.inner / ONE_MILLINEAR
    }

    /// `as_yoctonear` is a function that shows a number of yocto-near.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(10).as_yoctonear(), 10)
    /// ```
    pub const fn as_yoctonear(&self) -> u128 {
        self.inner
    }

    /// `is_zero` is a boolian function that checks `NearToken`
    /// if a `NearToken` inner is zero, returns true.
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(0).is_zero(), true)
    /// ```
    pub const fn is_zero(&self) -> bool {
        self.inner == 0
    }

    /// Checked integer addition. Computes self + rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// use std::u128;
    /// assert_eq!(NearToken::from_yoctonear(u128::MAX -2).checked_add(NearToken::from_yoctonear(2)), Some(NearToken::from_yoctonear(u128::MAX)));
    /// assert_eq!(NearToken::from_yoctonear(u128::MAX -2).checked_add(NearToken::from_yoctonear(3)), None);
    /// ```
    pub const fn checked_add(self, rhs: Self) -> Option<Self> {
        if let Some(near) = self.as_yoctonear().checked_add(rhs.as_yoctonear()) {
            Some(Self::from_yoctonear(near))
        } else {
            None
        }
    }

    /// Checked integer subtraction. Computes self - rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(2).checked_sub(NearToken::from_yoctonear(2)), Some(NearToken::from_yoctonear(0)));
    /// assert_eq!(NearToken::from_yoctonear(2).checked_sub(NearToken::from_yoctonear(3)), None);
    /// ```
    pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
        if let Some(near) = self.as_yoctonear().checked_sub(rhs.as_yoctonear()) {
            Some(Self::from_yoctonear(near))
        } else {
            None
        }
    }

    /// Checked integer multiplication. Computes self * rhs, returning None if overflow occurred.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// use std::u128;
    /// assert_eq!(NearToken::from_yoctonear(2).checked_mul(2), Some(NearToken::from_yoctonear(4)));
    /// assert_eq!(NearToken::from_yoctonear(u128::MAX).checked_mul(2), None)
    pub const fn checked_mul(self, rhs: u128) -> Option<Self> {
        if let Some(near) = self.as_yoctonear().checked_mul(rhs) {
            Some(Self::from_yoctonear(near))
        } else {
            None
        }
    }

    /// Checked integer division. Computes self / rhs, returning None if rhs == 0.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(10).checked_div(2), Some(NearToken::from_yoctonear(5)));
    /// assert_eq!(NearToken::from_yoctonear(2).checked_div(0), None);
    /// ```
    pub const fn checked_div(self, rhs: u128) -> Option<Self> {
        if let Some(near) = self.as_yoctonear().checked_div(rhs) {
            Some(Self::from_yoctonear(near))
        } else {
            None
        }
    }

    /// Saturating integer addition. Computes self + rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(5).saturating_add(NearToken::from_yoctonear(5)), NearToken::from_yoctonear(10));
    /// assert_eq!(NearToken::from_yoctonear(u128::MAX).saturating_add(NearToken::from_yoctonear(1)), NearToken::from_yoctonear(u128::MAX));
    /// ```
    pub const fn saturating_add(self, rhs: Self) -> Self {
        NearToken::from_yoctonear(self.as_yoctonear().saturating_add(rhs.as_yoctonear()))
    }

    /// Saturating integer subtraction. Computes self - rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(5).saturating_sub(NearToken::from_yoctonear(2)), NearToken::from_yoctonear(3));
    /// assert_eq!(NearToken::from_yoctonear(1).saturating_sub(NearToken::from_yoctonear(2)), NearToken::from_yoctonear(0));
    /// ```
    pub const fn saturating_sub(self, rhs: Self) -> Self {
        NearToken::from_yoctonear(self.as_yoctonear().saturating_sub(rhs.as_yoctonear()))
    }

    /// Saturating integer multiplication. Computes self * rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// use std::u128;
    /// assert_eq!(NearToken::from_yoctonear(2).saturating_mul(5), NearToken::from_yoctonear(10));
    /// assert_eq!(NearToken::from_yoctonear(u128::MAX).saturating_mul(2), NearToken::from_yoctonear(u128::MAX));
    /// ```
    pub const fn saturating_mul(self, rhs: u128) -> Self {
        NearToken::from_yoctonear(self.as_yoctonear().saturating_mul(rhs))
    }

    /// Saturating integer division. Computes self / rhs, saturating at the numeric bounds instead of overflowing.
    ///
    /// # Examples
    /// ```
    /// use near_token::NearToken;
    /// assert_eq!(NearToken::from_yoctonear(10).saturating_div(2), NearToken::from_yoctonear(5));
    /// assert_eq!(NearToken::from_yoctonear(10).saturating_div(0), NearToken::from_yoctonear(0))
    /// ```
    pub const fn saturating_div(self, rhs: u128) -> Self {
        if rhs == 0 {
            return NearToken::from_yoctonear(0);
        }
        NearToken::from_yoctonear(self.as_yoctonear().saturating_div(rhs))
    }
}

#[cfg(test)]
mod test {
    use crate::NearToken;

    #[test]
    fn checked_add_tokens() {
        let tokens = NearToken::from_yoctonear(u128::MAX - 3);
        let any_tokens = NearToken::from_yoctonear(3);
        let more_tokens = NearToken::from_yoctonear(4);
        assert_eq!(
            tokens.checked_add(any_tokens),
            Some(NearToken::from_yoctonear(u128::MAX))
        );
        assert_eq!(tokens.checked_add(more_tokens), None);
    }

    #[test]
    fn checked_sub_tokens() {
        let tokens = NearToken::from_yoctonear(3);
        let any_tokens = NearToken::from_yoctonear(1);
        let more_tokens = NearToken::from_yoctonear(4);
        assert_eq!(
            tokens.checked_sub(any_tokens),
            Some(NearToken::from_yoctonear(2))
        );
        assert_eq!(tokens.checked_sub(more_tokens), None);
    }

    #[test]
    fn checked_mul_tokens() {
        let tokens = NearToken::from_yoctonear(u128::MAX / 10);
        assert_eq!(
            tokens.checked_mul(10),
            Some(NearToken::from_yoctonear(u128::MAX / 10 * 10))
        );
        assert_eq!(tokens.checked_mul(11), None);
    }

    #[test]
    fn checked_div_tokens() {
        let tokens = NearToken::from_yoctonear(10);
        assert_eq!(tokens.checked_div(2), Some(NearToken::from_yoctonear(5)));
        assert_eq!(tokens.checked_div(11), Some(NearToken::from_yoctonear(0)));
        assert_eq!(tokens.checked_div(0), None);
    }

    #[test]
    fn saturating_add_tokens() {
        let tokens = NearToken::from_yoctonear(100);
        let added_tokens = NearToken::from_yoctonear(1);
        let another_tokens = NearToken::from_yoctonear(u128::MAX);
        assert_eq!(
            tokens.saturating_add(added_tokens.clone()),
            NearToken::from_yoctonear(101)
        );
        assert_eq!(
            another_tokens.saturating_add(added_tokens),
            NearToken::from_yoctonear(u128::MAX)
        );
    }

    #[test]
    fn saturating_sub_tokens() {
        let tokens = NearToken::from_yoctonear(100);
        let rhs_tokens = NearToken::from_yoctonear(1);
        let another_tokens = NearToken::from_yoctonear(u128::MIN);
        assert_eq!(
            tokens.saturating_sub(rhs_tokens.clone()),
            NearToken::from_yoctonear(99)
        );
        assert_eq!(
            another_tokens.saturating_sub(rhs_tokens),
            NearToken::from_yoctonear(u128::MIN)
        );
    }

    #[test]
    fn saturating_mul_tokens() {
        let tokens = NearToken::from_yoctonear(2);
        let rhs = 10;
        let another_tokens = u128::MAX;
        assert_eq!(tokens.saturating_mul(rhs), NearToken::from_yoctonear(20));
        assert_eq!(
            tokens.saturating_mul(another_tokens),
            NearToken::from_yoctonear(u128::MAX)
        );
    }

    #[test]
    fn saturating_div_tokens() {
        let tokens = NearToken::from_yoctonear(10);
        let rhs = 2;
        let another_tokens = 20;
        assert_eq!(tokens.saturating_div(rhs), NearToken::from_yoctonear(5));
        assert_eq!(
            tokens.saturating_div(another_tokens),
            NearToken::from_yoctonear(0)
        );
    }
}

'''
'''--- src/trait_impls/borsh.rs ---
#[cfg(test)]
mod test {
    use borsh::{to_vec, BorshDeserialize};

    use crate::NearToken;

    #[test]
    fn borsh() {
        fn test_borsh_ser(val: u128, expected_serialized_value: [u8; 16]) {
            let gas = NearToken::from_yoctonear(val);
            let ser = to_vec(&gas).unwrap();
            // println!("{:?}", ser);
            assert_eq!(expected_serialized_value, ser.as_slice());
            let de: NearToken = NearToken::try_from_slice(&ser).unwrap();
            assert_eq!(de.as_yoctonear(), val);
        }

        test_borsh_ser(
            u128::MAX,
            [
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            ],
        );
        test_borsh_ser(8, [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        test_borsh_ser(0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
}

'''
'''--- src/trait_impls/display.rs ---
use crate::{NearToken, ONE_MILLINEAR};

/// NearToken Display implementation rounds up the token amount to the relevant precision point.
/// There are 4 breakpoints:
/// 1. exactly 0 NEAR
/// 2. <0.001 NEAR
/// 3. 0.001 - 0.999 NEAR (uses 3 digits after the floating point)
/// 4. >1 NEAR (uses 2 digits after the floating point)
impl std::fmt::Display for NearToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if *self == NearToken::from_yoctonear(0) {
            write!(f, "0 NEAR")
        } else if *self < NearToken::from_millinear(1) {
            write!(f, "<0.001 NEAR")
        } else if *self <= NearToken::from_millinear(999) {
            let millinear_rounded_up =
                self.as_yoctonear().saturating_add(ONE_MILLINEAR - 1) / ONE_MILLINEAR;
            write!(f, "0.{:03} NEAR", millinear_rounded_up)
        } else {
            let near_rounded_up =
                self.as_yoctonear().saturating_add(10 * ONE_MILLINEAR - 1) / ONE_MILLINEAR / 10;
            write!(
                f,
                "{}.{:02} NEAR",
                near_rounded_up / 100,
                near_rounded_up % 100
            )
        }
    }
}

#[cfg(test)]
mod test {
    use crate::NearToken;

    #[test]
    fn test_display() {
        for (near_tokens, expected_display) in [
            (NearToken::from_yoctonear(0), "0 NEAR"),
            (NearToken::from_yoctonear(1), "<0.001 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(21) - 1), "<0.001 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(21)), "0.001 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(21) + 1), "0.002 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(21) * 2), "0.002 NEAR"),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 200),
                "0.200 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 999),
                "0.999 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 999 + 1),
                "1.00 NEAR",
            ),
            (NearToken::from_yoctonear(10u128.pow(24) - 1), "1.00 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(24)), "1.00 NEAR"),
            (NearToken::from_yoctonear(10u128.pow(24) + 1), "1.01 NEAR"),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 1234),
                "1.24 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 1500),
                "1.50 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 10000),
                "10.00 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 10500),
                "10.50 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 100000 - 1),
                "100.00 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 100000),
                "100.00 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 100500),
                "100.50 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 100000000),
                "100000.00 NEAR",
            ),
            (
                NearToken::from_yoctonear(10u128.pow(21) * 100000500),
                "100000.50 NEAR",
            ),
        ] {
            assert_eq!(
                near_tokens.to_string(),
                expected_display,
                "tokens: {}",
                near_tokens.as_yoctonear()
            );
        }
    }
}

'''
'''--- src/trait_impls/from_str.rs ---
use crate::{NearToken, NearTokenError, ONE_NEAR};

impl std::str::FromStr for NearToken {
    type Err = NearTokenError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let uppercase_s = s.trim().to_ascii_uppercase();
        let (value, unit) = uppercase_s.split_at(
            s.find(|c: char| c.is_ascii_alphabetic())
                .ok_or_else(|| NearTokenError::InvalidTokenUnit(s.to_owned()))?,
        );
        let unit_precision = match unit {
            "YN" | "YNEAR" | "YOCTONEAR" => 1,
            "NEAR" | "N" => ONE_NEAR,
            _ => return Err(NearTokenError::InvalidTokenUnit(s.to_owned())),
        };
        Ok(NearToken::from_yoctonear(
            crate::utils::parse_decimal_number(value.trim(), unit_precision)
                .map_err(NearTokenError::InvalidTokensAmount)?,
        ))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::{DecimalNumberParsingError, NearToken, NearTokenError};

    #[test]
    fn parse_decimal_number() {
        let data = "0.123456 near";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(
            gas.unwrap(),
            NearToken::from_yoctonear(123456000000000000000000)
        );
    }
    #[test]
    fn parse_number_with_decimal_part() {
        let data = "11.123456 near";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(
            gas.unwrap(),
            NearToken::from_yoctonear(11123456000000000000000000)
        );
    }

    #[test]
    fn parse_yocto_number() {
        let data = "123456 YN";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(gas.unwrap(), NearToken::from_yoctonear(123456));
    }

    #[test]
    fn doubledot() {
        let data = "1.1.1 Near";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearTokenError::InvalidTokensAmount(
                DecimalNumberParsingError::InvalidNumber("1.1.1".to_owned())
            ))
        )
    }

    #[test]
    fn space_after_dot() {
        let data = "1. 0 near";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearTokenError::InvalidTokensAmount(
                DecimalNumberParsingError::InvalidNumber("1. 0".to_owned())
            ))
        )
    }

    #[test]
    fn incorect_currency() {
        let data = "0 pas";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(gas, Err(NearTokenError::InvalidTokenUnit(data.to_owned())))
    }

    #[test]
    fn without_currency() {
        let data = "0";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(gas, Err(NearTokenError::InvalidTokenUnit("0".to_owned())))
    }

    #[test]
    fn invalid_whole() {
        let data = "-1 Near";
        let gas: Result<NearToken, NearTokenError> = FromStr::from_str(data);
        assert_eq!(
            gas,
            Err(NearTokenError::InvalidTokensAmount(
                DecimalNumberParsingError::InvalidNumber("-1".to_owned())
            ))
        )
    }

    #[test]
    fn test_from_str_f64_gas_without_int() {
        let near_gas = NearToken::from_str(".055 ynear").unwrap_err();
        assert_eq!(
            near_gas,
            NearTokenError::InvalidTokensAmount(DecimalNumberParsingError::InvalidNumber(
                ".055".to_string()
            ))
        );
    }

    #[test]
    fn test_from_str_without_unit() {
        let near_gas = NearToken::from_str("100").unwrap_err();
        assert_eq!(
            near_gas,
            NearTokenError::InvalidTokenUnit("100".to_string())
        );
    }

    #[test]
    fn test_from_str_incorrect_unit() {
        let near_gas = NearToken::from_str("100 UAH").unwrap_err();
        assert_eq!(
            near_gas,
            NearTokenError::InvalidTokenUnit("100 UAH".to_string())
        );
    }

    #[test]
    fn test_from_str_invalid_double_dot() {
        let near_gas = NearToken::from_str("100.55.").unwrap_err();
        assert_eq!(
            near_gas,
            NearTokenError::InvalidTokenUnit("100.55.".to_string())
        );
    }

    #[test]
    fn test_from_str_large_fractional_part() {
        let near_gas = NearToken::from_str("100.1111122222333 ynear").unwrap_err(); // 13 digits after "."
        assert_eq!(
            near_gas,
            NearTokenError::InvalidTokensAmount(DecimalNumberParsingError::LongFractional(
                "1111122222333".to_string()
            ))
        );
    }
}

'''
'''--- src/trait_impls/interactive_clap.rs ---
use crate::NearToken;

impl interactive_clap::ToCli for NearToken {
    type CliVariant = NearToken;
}

'''
'''--- src/trait_impls/mod.rs ---
#[cfg(feature = "borsh")]
mod borsh;
mod display;
mod from_str;
#[cfg(feature = "interactive-clap")]
mod interactive_clap;
#[cfg(feature = "schemars")]
mod schemars;
#[cfg(feature = "serde")]
mod serde;

'''
'''--- src/trait_impls/schemars.rs ---
use crate::NearToken;

impl schemars::JsonSchema for NearToken {
    fn is_referenceable() -> bool {
        false
    }

    fn schema_name() -> String {
        String::schema_name()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        String::json_schema(gen)
    }
}

'''
'''--- src/trait_impls/serde.rs ---
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};

use crate::NearToken;

impl Serialize for NearToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::Error;
        let mut buf = [0u8; 40];
        let remainder = {
            use std::io::Write;
            let mut w: &mut [u8] = &mut buf;
            write!(w, "{}", self.inner)
                .map_err(|err| Error::custom(format!("Failed to serialize: {}", err)))?;
            w.len()
        };
        let len = buf.len() - remainder;

        let s = std::str::from_utf8(&buf[..len])
            .map_err(|err| Error::custom(format!("Failed to serialize: {}", err)))?;
        serializer.serialize_str(s)
    }
}

impl<'de> Deserialize<'de> for NearToken {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        s.parse::<u128>()
            .map(NearToken::from_yoctonear)
            .map_err(|err| de::Error::custom(err.to_string()))
    }
}

#[cfg(test)]
mod test {
    use crate::NearToken;

    #[test]
    fn json_ser() {
        fn test_json_ser(val: u128) {
            let gas = NearToken::from_yoctonear(val);
            let ser = serde_json::to_string(&gas).unwrap();
            assert_eq!(ser, format!("\"{}\"", val));
            let de: NearToken = serde_json::from_str(&ser).unwrap();
            assert_eq!(de.as_yoctonear(), val);
        }

        test_json_ser(u128::MAX);
        test_json_ser(8);
        test_json_ser(0);
    }
}

'''
'''--- src/utils.rs ---
/// Parsing decimal numbers from `&str` type in `u128`.
/// Function also takes a value of metric prefix in u128 type.
/// `parse_str` use the `u128` type, and have the same max and min values.
///
/// If the fractional part is longer than several zeros in the prefix, it will return the error `DecimalNumberParsingError::LongFractional`.
///
/// If the string slice has invalid chars, it will return the error `DecimalNumberParsingError::InvalidNumber`.
///
/// If the whole part of the number has a value more than the `u64` maximum value, it will return the error `DecimalNumberParsingError::LongWhole`.
pub(crate) fn parse_decimal_number(
    s: &str,
    pref_const: u128,
) -> Result<u128, DecimalNumberParsingError> {
    let (int, fract) = if let Some((whole, fractional)) = s.trim().split_once('.') {
        let int: u128 = whole
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        let mut fract: u128 = fractional
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        let len = u32::try_from(fractional.len())
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        fract = fract
            .checked_mul(
                pref_const
                    .checked_div(10u128.checked_pow(len).ok_or_else(|| {
                        DecimalNumberParsingError::LongFractional(fractional.to_owned())
                    })?)
                    .filter(|n| *n != 0u128)
                    .ok_or_else(|| {
                        DecimalNumberParsingError::LongFractional(fractional.to_owned())
                    })?,
            )
            .ok_or_else(|| DecimalNumberParsingError::LongFractional(fractional.to_owned()))?;
        (int, fract)
    } else {
        let int: u128 = s
            .parse()
            .map_err(|_| DecimalNumberParsingError::InvalidNumber(s.to_owned()))?;
        (int, 0)
    };
    let result = fract
        .checked_add(
            int.checked_mul(pref_const)
                .ok_or_else(|| DecimalNumberParsingError::LongWhole(int.to_string()))?,
        )
        .ok_or_else(|| DecimalNumberParsingError::LongWhole(int.to_string()))?;
    Ok(result)
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DecimalNumberParsingError {
    InvalidNumber(String),
    LongWhole(String),
    LongFractional(String),
}

impl std::error::Error for DecimalNumberParsingError {}

impl std::fmt::Display for DecimalNumberParsingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecimalNumberParsingError::InvalidNumber(s) => {
                write!(f, "invalid number: {}", s)
            }
            DecimalNumberParsingError::LongWhole(s) => {
                write!(f, "too long whole part: {}", s)
            }
            DecimalNumberParsingError::LongFractional(s) => {
                write!(f, "too long fractional part: {}", s)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TEST: [(u128, &'static str, u128); 6] = [
        (129380_000_001u128, "129.380000001", 10u128.pow(9)),
        (
            12938_000_000_100_000_000u128,
            "12938000000.1",
            10u128.pow(9),
        ),
        (129380_000_001u128, "0.129380000001", 10u128.pow(12)),
        (129380_000_001_000u128, "129.380000001000", 10u128.pow(12)),
        (9488129380_000_001u128, "9488.129380000001", 10u128.pow(12)),
        (129380_000_001u128, "00.129380000001", 10u128.pow(12)),
    ];

    #[test]
    fn parse_test() {
        for (expected_value, str_value, precision) in TEST {
            let parsed_value = parse_decimal_number(str_value, precision).unwrap();
            assert_eq!(parsed_value, expected_value)
        }
    }

    #[test]
    fn test_long_fract() {
        let data = "1.23456";
        let prefix = 10000u128;
        assert_eq!(
            parse_decimal_number(data, prefix),
            Err(DecimalNumberParsingError::LongFractional(23456.to_string()))
        );
    }

    #[test]
    fn invalidnumber_whole() {
        let num = "1h4.7859";
        let prefix: u128 = 10000;
        assert_eq!(
            parse_decimal_number(num, prefix),
            Err(DecimalNumberParsingError::InvalidNumber(
                "1h4.7859".to_owned()
            ))
        );
    }
    #[test]
    fn invalidnumber_fract() {
        let num = "14.785h9";
        let prefix: u128 = 10000;
        assert_eq!(
            parse_decimal_number(num, prefix),
            Err(DecimalNumberParsingError::InvalidNumber(
                "14.785h9".to_owned()
            ))
        );
    }

    #[test]
    fn max_long_fract() {
        let max_data = 10u128.pow(17) + 1;
        let data = "1.".to_string() + max_data.to_string().as_str();
        let prefix = 10u128.pow(17);
        assert_eq!(
            parse_decimal_number(data.as_str(), prefix),
            Err(DecimalNumberParsingError::LongFractional(
                max_data.to_string()
            ))
        );
    }

    #[test]
    fn parse_u128_errortest() {
        let test_data = u128::MAX.to_string();
        let gas = parse_decimal_number(&test_data, 10u128.pow(9));
        assert_eq!(
            gas,
            Err(DecimalNumberParsingError::LongWhole(u128::MAX.to_string()))
        );
    }

    #[test]
    fn test() {
        let data = "1.000000000000000000000000000000000000001";
        let prefix = 100u128;
        assert_eq!(
            parse_decimal_number(data, prefix),
            Err(DecimalNumberParsingError::LongFractional(
                "000000000000000000000000000000000000001".to_string()
            ))
        );
    }
}

'''