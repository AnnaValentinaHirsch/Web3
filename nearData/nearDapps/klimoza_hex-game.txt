*GitHub Repository "klimoza/hex-game"*

'''--- Cargo.toml ---
[package]
name = "hex-game"
version = "0.1.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
The Game of Hex
===============
Hex is a two player abstract strategy board game in which players attempt to connect opposite sides of a rhombus-shaped board made of hexagonal cells. Hex was invented by mathematician and poet Piet Hein in 1942 and later rediscovered and popularized by John Nash. 

## Description
This contract implements hex-game backed by storage on NEAR blockchain.
Contract in `src/lib.rs` provides methods to create new game, make an allowed move in one of already existing games or view information about game by index.

The project is divided into separate files, each file contains one of the structures, that is used to keep information about the game, and tests for this structure.

## Interacting with contract

#### `create_game(first_player: AccountId, second_player: AccountId, field_size: usize) -> GameIndex`

Creates new game with given parameters and returns index of created game. For example:
```console
➜ near call crossword.klimoza.testnet create_game '{"first_player": "crossword.klimoza.testnet", "second_player": "klimoza.testnet", "field_size": 2}' --accountId crossword.klimoza.testnet
Scheduling a call: crossword.klimoza.testnet.create_game({"first_player": "crossword.klimoza.testnet", "second_player": "klimoza.testnet", "field_size": 2})
Doing account.functionCall()
Receipt: 95QtZWq7chRA4MyftnkPE8Smoi7iQo9kWpeVfxFZGDEV
	Log [crossword.klimoza.testnet]: Created board:
	Log [crossword.klimoza.testnet]: . .
	Log [crossword.klimoza.testnet]:  . .
Transaction Id BHvhLbLWHhKbmnewLHzMv7XY2y5izssY9spWEdVm6wUE
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/BHvhLbLWHhKbmnewLHzMv7XY2y5izssY9spWEdVm6wUE
4
```

#### `make_move(index: GameIndex, move_type: MoveType, cell: Option<Cell>) -> Game`
Tries to make a move in the game at the given index and returns Game if move is correct(panics otherwise). Used structures:
```rust
pub type GameIndex = u64;

pub enum MoveType {
    PLACE,
    SWAP,
}

pub struct Cell {
    pub x: usize,
    pub y: usize,
}
```
You can omit the `cell` parameter if `move_type` is `SWAP`(i.e. applying swap rule on the current move). For example:
```console
➜ near call crossword.klimoza.testnet make_move '{"index": 4, "move_type": "SWAP"}' --accountId klimoza.testnet
Scheduling a call: crossword.klimoza.testnet.make_move({"index": 4, "move_type": "SWAP"})
Doing account.functionCall()
Receipt: 9SntyX6t9j8jZCZMNb5wMn82k7YQKXoWH8tuYbaNZQs6
	Log [crossword.klimoza.testnet]: Old board:
	Log [crossword.klimoza.testnet]: . R
	Log [crossword.klimoza.testnet]:  . .
	Log [crossword.klimoza.testnet]: New board:
	Log [crossword.klimoza.testnet]: . .
	Log [crossword.klimoza.testnet]:  B .
Transaction Id FqsxYTzGaHYXvmxk3xYhBR3Mq4rveK5UvzkMNNerL6Th
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/FqsxYTzGaHYXvmxk3xYhBR3Mq4rveK5UvzkMNNerL6Th
{
  first_player: 'crossword.klimoza.testnet',
  second_player: 'klimoza.testnet',
  turn: 2,
  board: { size: 2, field: 'IA==' },
  current_block_height: 96244955,
  prev_block_height: 96244934,
  is_finished: false
}
```

#### `get_game(index: GameIndex) -> Option<Game>`
Returns the game at the given index(if there is one). For example:
```console
➜ near call crossword.klimoza.testnet get_game '{"index": 4}' --accountId crossword.klimoza.testnet
Scheduling a call: crossword.klimoza.testnet.get_game({"index": 4})
Doing account.functionCall()
Receipt: Fzjemr6ukV7mWNLNaJLrjxwU7uwnz2wgLfcNRNvLMyEH
	Log [crossword.klimoza.testnet]: Game board:
	Log [crossword.klimoza.testnet]: R B
	Log [crossword.klimoza.testnet]:  B .
Transaction Id DwpznqSWT8WqsirqFm64e8xHPEu1S3J52FpKsAR4okAQ
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/DwpznqSWT8WqsirqFm64e8xHPEu1S3J52FpKsAR4okAQ
{
  first_player: 'crossword.klimoza.testnet',
  second_player: 'klimoza.testnet',
  turn: 4,
  board: { size: 2, field: 'KQ==' },
  current_block_height: 96244985,
  prev_block_height: 96244971,
  is_finished: true
}
```

## Testing
At the moment, the projects contains 33 tests, each of which lies in the file of the structure it is testing. You can run them all using following command:
```console
cargo test
```
Alternatively, you can specify test group you want to run, for example:
```console
cargo test cell_tests
```

## Demonstration

[![Video](https://img.youtube.com/vi/mwgUEafpeow/0.jpg)](https://youtu.be/mwgUEafpeow)
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/hex_game.wasm ./res/hex_game.wasm

'''
'''--- src/bid.rs ---
use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    json_types::Base58CryptoHash,
    Promise, PromiseResult,
};

use crate::{
    external::AccountView,
    game::Player,
    roketo::{get_two_streams, roketo_create_stream, roketo_get_account, stop_stream},
    utils::{FEE, MIN_MAKE_BID_GAS},
    *,
};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub bid: u128,
    pub did_first_player_bet: bool,
    pub did_second_player_bet: bool,
    pub stream_to_first_player: Base58CryptoHash,
    pub stream_to_second_player: Base58CryptoHash,
}

impl Bid {
    pub fn new(bid: u128) -> Self {
        Self {
            bid,
            did_first_player_bet: false,
            did_second_player_bet: false,
            stream_to_first_player: Base58CryptoHash::default(),
            stream_to_second_player: Base58CryptoHash::default(),
        }
    }

    pub fn stop_streams(&self) -> Promise {
        stop_stream(self.stream_to_first_player).then(stop_stream(self.stream_to_second_player))
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn make_bid(&mut self, game_id: GameIndex) -> Promise {
        let opt_bid = self.bids.get(&game_id);
        require!(
            opt_bid.is_some(),
            "There's no betting game with such index."
        );
        require!(
            env::prepaid_gas() >= MIN_MAKE_BID_GAS,
            "You should attach more gas"
        );

        let game = self.games.get(&game_id).unwrap().game;
        let bid = opt_bid.unwrap();
        let account_id = env::predecessor_account_id();

        require!(env::attached_deposit() >= 2 * bid.bid + FEE);

        if account_id == game.first_player && !bid.did_first_player_bet {
            roketo_create_stream(bid.bid, game.playtime.unwrap(), account_id)
                .then(roketo_get_account(env::current_account_id()))
                .then(Self::ext(env::current_account_id()).resolve_player_bid(
                    bid,
                    game_id,
                    Player::First,
                ))
        } else if account_id == game.second_player && !bid.did_second_player_bet {
            roketo_create_stream(bid.bid, game.playtime.unwrap(), account_id)
                .then(roketo_get_account(env::current_account_id()))
                .then(Self::ext(env::current_account_id()).resolve_player_bid(
                    bid,
                    game_id,
                    Player::Second,
                ))
        } else {
            require!(false, "Invalid bet");
            unreachable!();
        }
    }

    #[private]
    pub fn resolve_player_bid(&mut self, bid: Bid, game_id: GameIndex, player: Player) {
        require!(env::predecessor_account_id() == env::current_account_id());
        require!(env::promise_results_count() == 1, "ERR_TOO_MANY_RESULTS");
        let stream_id = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(account) = near_sdk::serde_json::from_slice::<AccountView>(&val) {
                    account.last_created_stream.unwrap()
                } else {
                    env::panic_str("ERR_WRONG_VAL_RECEIVED")
                }
            }
            PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
        };
        let new_bid = match player {
            Player::First => Bid {
                did_first_player_bet: true,
                stream_to_first_player: stream_id,
                ..bid
            },
            Player::Second => Bid {
                did_second_player_bet: true,
                stream_to_second_player: stream_id,
                ..bid
            },
        };
        self.bids.insert(&game_id, &new_bid);
    }

    pub(crate) fn player_won(&self, bid: &Bid, game: &Game, player: Player) -> Promise {
        match player {
            Player::First => Promise::new(game.first_player.clone()).transfer(bid.bid),
            Player::Second => Promise::new(game.second_player.clone()).transfer(bid.bid),
        }
    }

    pub(crate) fn check_stream_bids(&mut self, game_id: GameIndex) -> Option<Promise> {
        let bid = self.bids.get(&game_id);
        if bid.is_none() {
            None
        } else {
            let unwrap_bid = bid.unwrap();
            Some(
                get_two_streams(
                    unwrap_bid.stream_to_first_player,
                    unwrap_bid.stream_to_second_player,
                )
                .then(Self::ext(env::current_account_id()).parse_two_promise_streams()),
            )
        }
    }
}

'''
'''--- src/board.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, require};

use crate::cell::Cell;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Board {
    pub size: usize,
    pub field: Base64VecU8,
}

impl Board {
    pub fn new(size: usize) -> Self {
        require!(size <= 19, "The size of the field must be less or equal 19");
        let field_len = (size * size + 3) / 4;
        Board {
            size,
            field: Base64VecU8::from(vec![0u8; field_len]),
        }
    }

    fn get_byte_and_bit(&self, cell: &Cell) -> (u8, usize, usize) {
        let index = (self.size * cell.y + cell.x) * 2;
        let byte_index = index / 8;
        let byte: u8 = self.field.0[byte_index];
        let bit_index = index & 7;
        (byte, byte_index, bit_index)
    }

    pub fn get_cell(&self, cell: &Cell) -> u8 {
        require!(
            cell.x < self.size && cell.y < self.size,
            "Cell is out of bounds."
        );
        let (byte, _, bit_index) = self.get_byte_and_bit(cell);
        (byte >> bit_index) & 3
    }

    pub fn set_cell(&mut self, cell: &Cell, value: u8) {
        let (byte, byte_index, bit_index) = self.get_byte_and_bit(cell);
        let bits = (byte >> bit_index) & 3;
        let new_byte = byte ^ (bits << bit_index) ^ (value << bit_index);
        self.field.0[byte_index] = new_byte;
    }

    pub fn get_coords(&self, bit_number: usize) -> Cell {
        Cell::new(bit_number / 2 % self.size, bit_number / 2 / self.size)
    }

    pub fn get_board_as_strings(&self) -> Vec<String> {
        let mut vector = Vec::new();

        for i in 0..self.size {
            let mut result: String = (0..i).into_iter().map(|_| ' ').collect();
            for j in 0..self.size {
                let symbol = match self.get_cell(&Cell::new(j, i)) {
                    0 => '.',
                    1 => 'R',
                    2 => 'B',
                    _ => unreachable!(),
                };
                result.push(symbol);
                if j + 1 != self.size {
                    result.push(' ');
                }
            }
            vector.push(result);
        }

        vector
    }

    pub fn debug_logs(&self) {
        self.get_board_as_strings()
            .into_iter()
            .for_each(|s| env::log_str(&s));
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod board_tests {
    use near_sdk::json_types::Base64VecU8;

    use crate::cell::Cell;

    use super::Board;

    #[test]
    #[should_panic]
    fn test_board_is_too_big() {
        Board::new(20);
    }

    #[test]
    fn test_get_byte_and_bit() {
        let mut test_board = Board::new(11);
        assert_eq!((0, 3, 6), test_board.get_byte_and_bit(&Cell::new(4, 1)));
        assert_eq!((0, 0, 0), test_board.get_byte_and_bit(&Cell::new(0, 0)));
        assert_eq!((0, 5, 0), test_board.get_byte_and_bit(&Cell::new(9, 1)));

        let mut test_vec = vec![0u8; 7];
        test_vec[0] = 255;
        test_vec[1] = 19;
        test_vec[2] = 7;
        test_vec[3] = 113;
        test_board = Board {
            size: 5,
            field: Base64VecU8::from(test_vec),
        };

        assert_eq!((255, 0, 6), test_board.get_byte_and_bit(&Cell::new(3, 0)));
        assert_eq!((7, 2, 6), test_board.get_byte_and_bit(&Cell::new(1, 2)));
        assert_eq!((19, 1, 0), test_board.get_byte_and_bit(&Cell::new(4, 0)));
        assert_eq!((0, 6, 0), test_board.get_byte_and_bit(&Cell::new(4, 4)));
    }

    #[test]
    #[should_panic]
    fn test_get_cell_out_of_bounds() {
        Board::new(11).get_cell(&Cell::new(5, 11));
    }

    #[test]
    fn test_get_cell() {
        let mut test_vec = vec![0u8; 7];
        test_vec[0] = 255;
        test_vec[1] = 32;
        test_vec[2] = 7;
        test_vec[3] = 113;
        let test_board = Board {
            size: 5,
            field: Base64VecU8::from(test_vec),
        };

        assert_eq!(3, test_board.get_cell(&Cell::new(3, 0)));
        assert_eq!(1, test_board.get_cell(&Cell::new(4, 1)));
        assert_eq!(3, test_board.get_cell(&Cell::new(4, 2)));
        assert_eq!(2, test_board.get_cell(&Cell::new(1, 1)));
    }

    #[test]
    #[should_panic]
    fn test_set_cell_out_of_bounds() {
        Board::new(5).set_cell(&Cell::new(6, 3), 1);
    }

    #[test]
    #[should_panic]
    fn test_set_cell_too_big_value() {
        Board::new(4).set_cell(&Cell::new(1, 1), 3);
    }

    #[test]
    fn test_set_sell() {
        let mut test_board = Board::new(11);
        let test_cell = Cell::new(2, 5);

        test_board.set_cell(&test_cell, 1);
        assert_eq!(1, test_board.get_cell(&test_cell));

        test_board.set_cell(&test_cell, 0);
        assert_eq!(0, test_board.get_cell(&test_cell));

        test_board.set_cell(&test_cell, 2);
        assert_eq!(2, test_board.get_cell(&test_cell));

        test_board.set_cell(&Cell::new(10, 10), 1);
        test_board.set_cell(&Cell::new(3, 5), 1);

        assert_eq!(2, test_board.get_cell(&Cell::new(2, 5)));
        assert_eq!(1, test_board.get_cell(&Cell::new(10, 10)));
        assert_eq!(1, test_board.get_cell(&Cell::new(3, 5)));
    }

    #[test]
    fn test_get_coords() {
        let mut test_board = Board::new(5);
        assert_eq!(Cell::new(0, 1), test_board.get_coords(10));
        assert_eq!(Cell::new(0, 0), test_board.get_coords(0));
        assert_eq!(Cell::new(0, 0), test_board.get_coords(1));
        assert_eq!(Cell::new(4, 4), test_board.get_coords(48));

        test_board = Board::new(15);
        let mut test_cell = Cell::new(11, 7);
        let (_, mut byte, mut bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));

        test_cell = Cell::new(0, 14);
        (_, byte, bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));

        test_cell = Cell::new(10, 2);
        (_, byte, bit) = test_board.get_byte_and_bit(&test_cell);
        assert_eq!(test_cell, test_board.get_coords(byte * 8 + bit));
    }
}

'''
'''--- src/cell.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Cell {
    pub x: usize,
    pub y: usize,
}

impl Cell {
    pub fn new(x: usize, y: usize) -> Self {
        Self { x, y }
    }

    pub fn get_neighbours(&self, field_size: usize) -> Vec<Cell> {
        let mut neighbours: Vec<Cell> = Vec::new();
        let (x, y) = (self.x, self.y);
        if self.x > 0 {
            neighbours.push(Cell::new(x - 1, y));
        }
        if self.y > 0 {
            neighbours.push(Cell::new(x, y - 1));
        }
        if self.x + 1 < field_size && self.y > 0 {
            neighbours.push(Cell::new(x + 1, y - 1));
        }
        if self.x + 1 < field_size {
            neighbours.push(Cell::new(x + 1, y));
        }
        if self.y + 1 < field_size {
            neighbours.push(Cell::new(x, y + 1));
        }
        if self.x > 0 && self.y + 1 < field_size {
            neighbours.push(Cell::new(x - 1, y + 1));
        }
        return neighbours;
    }

    pub fn symm(&self) -> Self {
        Self {
            x: self.y,
            y: self.x,
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod cell_tests {
    use super::Cell;

    impl PartialEq for Cell {
        fn eq(&self, other: &Self) -> bool {
            self.x == other.x && self.y == other.y
        }
    }

    #[test]
    fn test_cell_neighbours_single() {
        let test_cell = Cell::new(0, 0);
        let neighbours = test_cell.get_neighbours(1);
        assert!(neighbours.is_empty());
    }

    #[test]
    fn test_cell_neighbours_center() {
        let test_cell = Cell::new(1, 1);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(0, 1),
                Cell::new(1, 0),
                Cell::new(2, 0),
                Cell::new(2, 1),
                Cell::new(1, 2),
                Cell::new(0, 2)
            ]
        );
    }
    #[test]
    fn test_cell_neighbours_right_bottom_corner() {
        let test_cell = Cell::new(1, 1);
        let neighbours = test_cell.get_neighbours(2);
        assert_eq!(neighbours, vec![Cell::new(0, 1), Cell::new(1, 0)]);
    }
    #[test]
    fn test_cell_neighbours_left_upper_corner() {
        let test_cell = Cell::new(0, 0);
        let neighbours = test_cell.get_neighbours(4);
        assert_eq!(neighbours, vec![Cell::new(1, 0), Cell::new(0, 1)]);
    }
    #[test]
    fn test_cell_neighbours_left_bottom_corner() {
        let test_cell = Cell::new(0, 2);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![Cell::new(0, 1), Cell::new(1, 1), Cell::new(1, 2)]
        );
    }
    #[test]
    fn test_cell_neighbours_right_upper_corner() {
        let test_cell = Cell::new(4, 0);
        let neighbours = test_cell.get_neighbours(5);
        assert_eq!(
            neighbours,
            vec![Cell::new(3, 0), Cell::new(4, 1), Cell::new(3, 1)]
        );
    }

    #[test]
    fn test_cell_neighbours_left_border() {
        let test_cell = Cell::new(0, 1);
        let neighbours = test_cell.get_neighbours(3);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(0, 0),
                Cell::new(1, 0),
                Cell::new(1, 1),
                Cell::new(0, 2)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_upper_border() {
        let test_cell = Cell::new(2, 0);
        let neighbours = test_cell.get_neighbours(4);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(1, 0),
                Cell::new(3, 0),
                Cell::new(2, 1),
                Cell::new(1, 1)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_right_border() {
        let test_cell = Cell::new(4, 3);
        let neighbours = test_cell.get_neighbours(5);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(3, 3),
                Cell::new(4, 2),
                Cell::new(4, 4),
                Cell::new(3, 4)
            ]
        );
    }

    #[test]
    fn test_cell_neighbours_bottom_border() {
        let test_cell = Cell::new(2, 5);
        let neighbours = test_cell.get_neighbours(6);
        assert_eq!(
            neighbours,
            vec![
                Cell::new(1, 5),
                Cell::new(2, 4),
                Cell::new(3, 4),
                Cell::new(3, 5)
            ]
        );
    }

    #[test]
    #[should_panic]
    fn test_cell_of_bounds() {
        Cell::new(3, 4).get_neighbours(4);
    }
}

'''
'''--- src/external.rs ---
use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    ext_contract,
    json_types::{Base58CryptoHash, U128},
    serde::{Deserialize, Serialize},
    AccountId, Balance, CryptoHash, Promise, Timestamp,
};
use std::collections::HashMap;

use crate::*;

pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod b58_dec_format {
    use near_sdk::json_types::Base58CryptoHash;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};
    use near_sdk::CryptoHash;

    pub fn serialize<S>(val: &CryptoHash, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // impossible to do without intermediate serialization
        serializer.serialize_str(&String::from(&Base58CryptoHash::from(*val)))
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<CryptoHash, D::Error>
    where
        D: Deserializer<'de>,
    {
        // same as above
        Ok(Base58CryptoHash::deserialize(deserializer)?.into())
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum StreamFinishReason {
    StoppedByOwner,
    StoppedByReceiver,
    FinishedNaturally,
    FinishedBecauseCannotBeExtended,
    FinishedWhileTransferred,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum StreamStatus {
    Initialized,
    Active,
    Paused,
    Finished { reason: StreamFinishReason },
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Stream {
    #[serde(with = "b58_dec_format")]
    pub id: CryptoHash,
    pub description: Option<String>,
    pub creator_id: AccountId,
    pub owner_id: AccountId,
    pub receiver_id: AccountId,
    pub token_account_id: AccountId,

    pub timestamp_created: Timestamp,
    pub last_action: Timestamp,

    #[serde(with = "u128_dec_format")]
    pub balance: Balance,
    #[serde(with = "u128_dec_format")]
    pub tokens_per_sec: Balance,

    pub status: StreamStatus,
    #[serde(with = "u128_dec_format")]
    pub tokens_total_withdrawn: Balance,

    // Cliff is a moment of time which divides the stream into two parts:
    // - before the cliff - withdraw is disabled;
    // - after the cliff - stream becomes a regular one.
    //
    // Streams with cliff must be started immediately.
    // Additionally, pausing streams with cliff is disabled
    // because it's hard to predict the proper behavior of the stream.
    //
    // The only way to withdraw tokens from stream with active cliff
    // is to stop it completely. In this case we take commission
    // that is proportional to time passed for total stream time.
    //
    // The reason of having cliffs is to reproduce vesting contracts.
    pub cliff: Option<Timestamp>,

    // Stream non-expiration is a hard concept to understand.
    //
    // The idea is based on observation that no stream can be stopped
    // automatically with no action provided. So, if receiver haven't
    // withdraw his tokens from fully expired stream yet,
    // the stream is considered Active.
    //
    // This basically means, the owner can deposit tokens onto the stream
    // even it's already expired, as long as receiver haven't tried to withdraw
    // the tokens that leads to stream finishing. In other terms,
    // it's possible to have a credit that may be covered later.
    //
    // Such behavior called non-expirable streams and disabled by default.
    // Expirable streams will be terminated even on stream depositing.
    pub is_expirable: bool,

    // Locked streams are ones that are unable to pause, stop and change receiver.
    // Locked streams are still may be terminated or deposited until started.
    //
    // For locked streams we take commission when the stream is started,
    // to allow us to own and handle commission tokens without waiting
    // as the final result of locked stream cannot be changed.
    pub is_locked: bool,

    #[borsh_skip]
    #[serde(with = "u128_dec_format")]
    pub available_to_withdraw_by_formula: Balance,
}

#[derive(Deserialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AccountView {
    pub active_incoming_streams: u32,
    pub active_outgoing_streams: u32,
    pub inactive_incoming_streams: u32,
    pub inactive_outgoing_streams: u32,

    pub total_incoming: HashMap<AccountId, U128>,
    pub total_outgoing: HashMap<AccountId, U128>,
    pub total_received: HashMap<AccountId, U128>,

    #[serde(with = "u128_dec_format")]
    pub deposit: Balance,

    #[serde(with = "u128_dec_format")]
    pub stake: Balance,

    pub last_created_stream: Option<Base58CryptoHash>,
    pub is_cron_allowed: bool,
}

#[ext_contract(ext_roketo)]
pub trait Roketo {
    fn get_account(self, account_id: AccountId, only_if_exist: Option<bool>) -> AccountView;
    fn get_stream(self, stream_id: Base58CryptoHash) -> Stream;
    fn pause_stream(&mut self, stream_id: Base58CryptoHash) -> Vec<Promise>;
    fn start_stream(&mut self, stream_id: Base58CryptoHash);
    fn stop_stream(&mut self, stream_id: Base58CryptoHash) -> Vec<Promise>;
}

#[ext_contract(ext_wrap)]
pub trait Wrap {
    fn near_deposit(&mut self);
}

'''
'''--- src/game.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, BlockHeight};

use crate::board::Board;
use crate::cell::Cell;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Player {
    First,
    Second,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Game {
    pub first_player: AccountId,
    pub second_player: AccountId,
    pub turn: usize,
    pub board: Board,
    pub current_block_height: BlockHeight,
    pub prev_block_height: BlockHeight,
    pub is_started: bool,
    pub is_finished: bool,
    pub playtime: Option<u32>,
    pub winner: Option<Player>,
}

pub type GameIndex = u64;

impl Game {
    pub fn new(
        first_player: AccountId,
        second_player: AccountId,
        field_size: usize,
        playtime: Option<u32>,
    ) -> Self {
        Self {
            first_player,
            second_player,
            turn: 0,
            board: Board::new(field_size),
            current_block_height: env::block_height(),
            prev_block_height: 0,
            is_started: false,
            is_finished: false,
            playtime,
            winner: None,
        }
    }

    pub fn place_counter(&mut self, cell: &Cell, player: u8) {
        self.board.set_cell(cell, player);
        self.turn += 1;
        if env::block_height() != self.current_block_height {
            self.prev_block_height = self.current_block_height;
            self.current_block_height = env::block_height();
        }
    }

    pub fn swap_rule(&mut self) -> Cell {
        let non_zero_byte = self
            .board
            .field
            .0
            .iter()
            .enumerate()
            .find(|(_, &x)| x != 0)
            .unwrap();
        let mut bit_number = 8 * non_zero_byte.0;
        if non_zero_byte.1 & 4 == 4 {
            bit_number += 2;
        } else if non_zero_byte.1 & 16 == 16 {
            bit_number += 4;
        } else if non_zero_byte.1 & 64 == 64 {
            bit_number += 6;
        }
        let cell = self.board.get_coords(bit_number);

        self.board.set_cell(&cell, 0);
        self.board.set_cell(&cell.symm(), 2);
        self.turn += 1;
        if env::block_height() != self.current_block_height {
            self.prev_block_height = self.current_block_height;
            self.current_block_height = env::block_height();
        }

        cell
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod game_tests {
    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env,
    };

    use crate::cell::Cell;

    use super::Game;

    fn get_context() -> VMContextBuilder {
        VMContextBuilder::new()
    }

    #[test]
    #[should_panic]
    fn test_place_counter_wrong_player_1() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(1, 1), 2);
    }

    #[test]
    #[should_panic]
    fn test_place_counter_wrong_player_2() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(2, 1), 1);
    }

    #[test]
    #[should_panic]
    fn test_place_counter_cell_is_already_filled() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(1, 1), 2);
    }

    #[test]
    fn test_place_counter() {
        testing_env!(get_context().block_index(0).build());

        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(1, 2), 2);
        game.place_counter(&Cell::new(10, 7), 1);
        assert_eq!(game.current_block_height, 0);
        assert_eq!(game.prev_block_height, 0);

        testing_env!(get_context().block_index(100).build());
        game.place_counter(&Cell::new(5, 9), 2);
        game.place_counter(&Cell::new(3, 7), 1);
        assert_eq!(game.current_block_height, 100);
        assert_eq!(game.prev_block_height, 0);

        assert_eq!(game.first_player, accounts(0));
        assert_eq!(game.second_player, accounts(1));
        assert_eq!(game.turn, 5);
        for i in 0..11 {
            for j in 0..11 {
                let cell = Cell::new(i, j);
                if cell == Cell::new(1, 1) || cell == Cell::new(10, 7) || cell == Cell::new(3, 7) {
                    assert_eq!(game.board.get_cell(&cell), 1);
                } else if cell == Cell::new(1, 2) || cell == Cell::new(5, 9) {
                    assert_eq!(game.board.get_cell(&cell), 2);
                } else {
                    assert_eq!(game.board.get_cell(&cell), 0);
                }
            }
        }
    }

    #[test]
    #[should_panic]
    fn test_swap_rule_too_early() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.swap_rule();
    }

    #[test]
    #[should_panic]
    fn test_swap_rule_too_late() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(2, 5), 1);
        game.place_counter(&Cell::new(10, 7), 2);
        game.swap_rule();
    }

    #[test]
    fn test_swap_rule() {
        let mut game = Game::new(accounts(0), accounts(1), 11, None);
        game.place_counter(&Cell::new(10, 7), 1);

        let c = game.swap_rule();
        assert_eq!(Cell::new(10, 7), c);
        assert_eq!(0, game.board.get_cell(&Cell::new(10, 7)));
        assert_eq!(2, game.board.get_cell(&Cell::new(7, 10)));

        game.place_counter(&Cell::new(1, 1), 1);
        game.place_counter(&Cell::new(5, 9), 2);
        game.place_counter(&Cell::new(3, 7), 1);

        assert_eq!(game.turn, 5);
        for i in 0..11 {
            for j in 0..11 {
                let cell = Cell::new(i, j);
                if cell == Cell::new(1, 1) || cell == Cell::new(3, 7) {
                    assert_eq!(game.board.get_cell(&cell), 1);
                } else if cell == Cell::new(7, 10) || cell == Cell::new(5, 9) {
                    assert_eq!(game.board.get_cell(&cell), 2);
                } else {
                    assert_eq!(game.board.get_cell(&cell), 0);
                }
            }
        }
    }
}

'''
'''--- src/game_with_data.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::AccountId;
use std::collections::VecDeque;

use crate::board::Board;
use crate::cell::Cell;
use crate::game::Game;
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct GameWithData {
    pub game: Game,
    pub data: Board,
}

impl GameWithData {
    pub fn new(
        first_player: AccountId,
        second_player: AccountId,
        field_size: usize,
        playtime: Option<u32>,
    ) -> Self {
        Self {
            game: Game::new(first_player, second_player, field_size, playtime),
            data: Board::new(field_size),
        }
    }

    pub fn make_move(&mut self, move_type: MoveType, cell: Option<Cell>) {
        match (move_type, cell) {
            (MoveType::PLACE, Some(cell)) => {
                if self.game.turn % 2 == 0 {
                    self.game.place_counter(&cell, 1);
                } else {
                    self.game.place_counter(&cell, 2);
                }
                self.process_cell(cell);
            }
            (MoveType::SWAP, _) => {
                let cell = self.game.swap_rule();
                self.data.set_cell(&cell, 0);
                self.process_cell(cell.symm());
            }
            _ => unreachable!(),
        };
    }

    fn process_cell(&mut self, cell: Cell) {
        let color = self.game.board.get_cell(&cell);
        let (mut border1, mut border2) = if color == 1 {
            (cell.y == 0, cell.y + 1 == self.data.size)
        } else {
            (cell.x == 0, cell.x + 1 == self.data.size)
        };
        let neighbours = cell.get_neighbours(self.data.size);
        let good_neighbours = neighbours
            .iter()
            .filter(|c| self.game.board.get_cell(c) == color);
        border1 = border1 || good_neighbours.clone().any(|c| self.data.get_cell(c) == 1);
        border2 = border2 || good_neighbours.clone().any(|c| self.data.get_cell(c) == 2);
        if border1 && border2 {
            self.game.is_finished = true;
        } else if border1 {
            self.bfs(cell, color, 1);
        } else if border2 {
            self.bfs(cell, color, 2);
        }
    }

    fn bfs(&mut self, cell: Cell, color: u8, border: u8) {
        self.data.set_cell(&cell, border);
        let mut q: VecDeque<Cell> = VecDeque::new();
        q.push_back(cell);
        let field_size = self.data.size;
        while !q.is_empty() {
            let v = q.pop_front().unwrap();
            let neighbours = v.get_neighbours(field_size);
            let good_neighbours: Vec<Cell> = neighbours
                .into_iter()
                .filter(|c| self.game.board.get_cell(c) == color && self.data.get_cell(c) != border)
                .collect();
            if good_neighbours
                .clone()
                .into_iter()
                .any(|c| self.data.get_cell(&c) != 0)
            {
                self.game.is_finished = true;
                return;
            }
            for c in good_neighbours.into_iter() {
                self.data.set_cell(&c, border);
                q.push_back(Cell::new(c.x, c.y));
            }
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod game_with_board_tests {
    use std::fmt::Debug;

    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env,
    };

    use super::*;

    impl PartialEq for Board {
        fn eq(&self, other: &Self) -> bool {
            self.size == other.size && self.field == other.field
        }
    }

    impl Debug for Board {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("Board")
                .field("size", &self.size)
                .field("field", &self.field)
                .finish()
        }
    }

    fn get_context(account: AccountId) -> near_sdk::VMContext {
        VMContextBuilder::new()
            .predecessor_account_id(account)
            .build()
    }

    #[test]
    fn test_bfs() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        test_game.game.board.set_cell(&Cell::new(0, 0), 1);
        test_game.game.board.set_cell(&Cell::new(0, 1), 1);
        test_game.game.board.set_cell(&Cell::new(0, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 4), 1);
        test_game.game.board.set_cell(&Cell::new(3, 4), 1);

        test_game.game.board.set_cell(&Cell::new(0, 3), 1);
        test_game.game.board.set_cell(&Cell::new(1, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 0), 2);

        test_game.game.board.set_cell(&Cell::new(2, 1), 1);

        test_game.game.board.set_cell(&Cell::new(3, 0), 2);

        let mut test_data = Board::new(5);
        test_data.set_cell(&Cell::new(0, 0), 2);
        test_data.set_cell(&Cell::new(0, 1), 2);
        test_data.set_cell(&Cell::new(0, 2), 2);
        test_data.set_cell(&Cell::new(0, 3), 2);
        test_data.set_cell(&Cell::new(1, 2), 2);
        test_data.set_cell(&Cell::new(2, 1), 2);

        test_game.bfs(Cell::new(0, 2), 1, 2);
        assert_eq!(test_game.data, test_data);

        test_data.set_cell(&Cell::new(4, 0), 2);
        test_data.set_cell(&Cell::new(3, 0), 2);

        test_game.bfs(Cell::new(3, 0), 2, 2);
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    fn test_process_cell() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        test_game.game.board.set_cell(&Cell::new(0, 0), 1);
        test_game.game.board.set_cell(&Cell::new(0, 1), 1);
        test_game.game.board.set_cell(&Cell::new(0, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 4), 1);
        test_game.game.board.set_cell(&Cell::new(3, 4), 1);

        test_game.game.board.set_cell(&Cell::new(0, 3), 1);
        test_game.game.board.set_cell(&Cell::new(1, 2), 1);

        test_game.game.board.set_cell(&Cell::new(4, 0), 2);

        test_game.game.board.set_cell(&Cell::new(2, 1), 1);

        test_game.game.board.set_cell(&Cell::new(3, 0), 2);

        let mut test_data = Board::new(5);
        test_data.set_cell(&Cell::new(0, 0), 1);
        test_data.set_cell(&Cell::new(0, 1), 1);
        test_data.set_cell(&Cell::new(0, 2), 1);
        test_data.set_cell(&Cell::new(0, 3), 1);
        test_data.set_cell(&Cell::new(1, 2), 1);
        test_data.set_cell(&Cell::new(2, 1), 1);

        test_game.process_cell(Cell::new(0, 1));
        assert_eq!(test_game.data, Board::new(5));

        test_game.process_cell(Cell::new(0, 0));
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    fn test_make_move() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        let mut test_data = Board::new(5);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(3, 0)));
        test_data.set_cell(&Cell::new(3, 0), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::SWAP, None);
        test_data.set_cell(&Cell::new(3, 0), 0);
        test_data.set_cell(&Cell::new(0, 3), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 4)));
        test_data.set_cell(&Cell::new(4, 4), 2);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(1, 2)));
        test_data.set_cell(&Cell::new(1, 2), 1);
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 2)));
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(3, 2)));
        assert_eq!(test_game.data, test_data);

        testing_env!(get_context(accounts(0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 3)));
        test_data.set_cell(&Cell::new(4, 2), 2);
        test_data.set_cell(&Cell::new(4, 3), 2);
        assert_eq!(test_game.data, test_data);
    }

    #[test]
    #[should_panic]
    fn test_make_move_incorrect_args() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        test_game.make_move(MoveType::PLACE, None);
    }

    #[test]
    #[should_panic]
    fn test_make_move_wrong_player() {
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        testing_env!(get_context(accounts(1)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(0, 0)));
    }
}

'''
'''--- src/internal.rs ---
use crate::{game::Player, *};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum FinishedStreams {
    None,
    First,
    Second,
    Both,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum StatusType {
    Active,
    Paused,
    Finished,
}

impl StatusType {
    pub fn new(status: StreamStatus) -> Self {
        match status {
            StreamStatus::Active => Self::Active,
            StreamStatus::Initialized => Self::Paused,
            StreamStatus::Paused => Self::Paused,
            StreamStatus::Finished {
                reason: StreamFinishReason::StoppedByReceiver,
            } => Self::Paused,
            StreamStatus::Finished {
                reason: StreamFinishReason::FinishedBecauseCannotBeExtended,
            } => Self::Finished,
            StreamStatus::Finished {
                reason: StreamFinishReason::FinishedNaturally,
            } => Self::Finished,
            StreamStatus::Finished {
                reason: StreamFinishReason::FinishedWhileTransferred,
            } => Self::Finished,
            StreamStatus::Finished {
                reason: StreamFinishReason::StoppedByOwner,
            } => Self::Finished,
        }
    }
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn get_game_internal(&self, index: GameIndex) -> Game {
        require!(env::predecessor_account_id() == env::current_account_id());
        let game = self.games.get(&index).map(|x| x.game);
        game.unwrap()
    }

    #[private]
    pub fn make_move_internal(
        &mut self,
        index: GameIndex,
        move_type: MoveType,
        cell: Option<Cell>,
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id());
        let mut game_with_data = self.games.get(&index).expect("Game doesn't exist.");
        if game_with_data.game.is_finished {
            return Self::ext(env::current_account_id()).get_game_internal(index);
        }
        let old_board = game_with_data.game.board.clone();

        game_with_data.make_move(move_type, cell);

        env::log_str("Old board:");
        old_board.debug_logs();

        env::log_str("New board:");
        game_with_data.game.board.debug_logs();

        if game_with_data.game.is_finished {
            if game_with_data.game.turn % 2 == 1 {
                game_with_data.game.winner = Some(Player::First);
                env::log_str("First player wins!");
            } else {
                game_with_data.game.winner = Some(Player::Second);
                env::log_str("Second player wins!");
            }
            self.games.insert(&index, &game_with_data);
            let winner = game_with_data.game.winner.clone();
            if let Some(bid) = self.bids.get(&index) {
                bid.stop_streams()
                    .then(self.player_won(&bid, &game_with_data.game, winner.unwrap()))
                    .then(Self::ext(env::current_account_id()).get_game_internal(index))
            } else {
                Self::ext(env::current_account_id()).get_game_internal(index)
            }
        } else {
            self.games.insert(&index, &game_with_data);
            if let Some(bid) = self.bids.get(&index) {
                if game_with_data.game.turn % 2 == 1 {
                    start_stream(bid.stream_to_second_player)
                        .then(Self::ext(env::current_account_id()).get_game_internal(index))
                } else {
                    start_stream(bid.stream_to_first_player)
                        .then(Self::ext(env::current_account_id()).get_game_internal(index))
                }
            } else {
                Self::ext(env::current_account_id()).get_game_internal(index)
            }
        }
    }

    #[private]
    pub fn resolve_streams(
        &mut self,
        game_id: GameIndex,
        move_type: MoveType,
        cell: Option<Cell>,
    ) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id());
        require!(env::promise_results_count() == 1, "ERR_WRONG_RESULTS_COUNT");
        let (res, stream1, stream2) = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(res) =
                    near_sdk::serde_json::from_slice::<(FinishedStreams, Stream, Stream)>(&val)
                {
                    res
                } else {
                    env::panic_str("ERR_WRONG_VAL_RECEIVED")
                }
            }
            PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
        };

        let bid = self.bids.get(&game_id).unwrap();
        let mut game_with_data = self.games.get(&game_id).unwrap();

        match res {
            FinishedStreams::None => {
                Self::ext(env::current_account_id()).make_move_internal(game_id, move_type, cell)
            }
            FinishedStreams::First => {
                let bal = stream2.balance;
                game_with_data.game.is_finished = true;
                game_with_data.game.winner = Some(Player::First);
                self.games.insert(&game_id, &game_with_data);
                let game = game_with_data.game;
                if stream2.status == StreamStatus::Paused {
                    stop_stream(stream2.id.into())
                        .then(Promise::new(game.first_player.clone()).transfer(bal + bid.bid))
                } else {
                    Promise::new(game.first_player.clone()).transfer(bal + bid.bid)
                }
            }
            FinishedStreams::Second => {
                let bal = stream1.balance;
                game_with_data.game.is_finished = true;
                game_with_data.game.winner = Some(Player::First);
                self.games.insert(&game_id, &game_with_data);
                let game = game_with_data.game;
                if stream1.status == StreamStatus::Paused {
                    stop_stream(stream1.id.into())
                        .then(Promise::new(game.second_player.clone()).transfer(bal + bid.bid))
                } else {
                    Promise::new(game.second_player.clone()).transfer(bal + bid.bid)
                }
            }
            FinishedStreams::Both => {
                game_with_data.game.is_finished = true;
                self.games.insert(&game_id, &game_with_data);
                let game = game_with_data.game;
                Promise::new(game.first_player.clone())
                    .transfer(bid.bid)
                    .then(Promise::new(game.second_player.clone()).transfer(bid.bid))
            }
        }
    }

    #[private]
    pub fn parse_two_promise_streams(&mut self) -> Promise {
        require!(env::predecessor_account_id() == env::current_account_id());
        require!(env::promise_results_count() == 2, "ERR_WRONG_RESULTS_COUNT");
        let mut stream1 = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(stream) = near_sdk::serde_json::from_slice::<Stream>(&val) {
                    stream
                } else {
                    env::panic_str("ERR_WRONG_VAL_RECEIVED")
                }
            }
            PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
        };
        let mut stream2 = match env::promise_result(1) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(stream) = near_sdk::serde_json::from_slice::<Stream>(&val) {
                    stream
                } else {
                    env::panic_str("ERR_WRONG_VAL_RECEIVED")
                }
            }
            PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
        };
        if stream1.status == StreamStatus::Active && stream2.status == StreamStatus::Active {
            let promise1 = if stream1.balance == stream1.available_to_withdraw_by_formula {
                stream1.status = StreamStatus::Finished {
                    reason: StreamFinishReason::StoppedByOwner,
                };
                stop_stream(stream1.id.into())
            } else {
                stream1.status = StreamStatus::Paused;
                pause_stream(stream1.id.into())
            };
            let promise2 = if stream2.balance == stream2.available_to_withdraw_by_formula {
                stream2.status = StreamStatus::Finished {
                    reason: StreamFinishReason::StoppedByOwner,
                };
                stop_stream(stream2.id.into())
            } else {
                stream2.status = StreamStatus::Paused;
                pause_stream(stream2.id.into())
            };
            (promise1.and(promise2))
                .then(Self::ext(env::current_account_id()).parse_two_streams(stream1, stream2))
        } else if stream1.status == StreamStatus::Active {
            let promise1 = if stream1.balance == stream1.available_to_withdraw_by_formula {
                stream1.status = StreamStatus::Finished {
                    reason: StreamFinishReason::StoppedByOwner,
                };
                stop_stream(stream1.id.into())
            } else {
                stream1.status = StreamStatus::Paused;
                pause_stream(stream1.id.into())
            };
            promise1.then(Self::ext(env::current_account_id()).parse_two_streams(stream1, stream2))
        } else if stream2.status == StreamStatus::Active {
            let promise2 = if stream2.balance == stream2.available_to_withdraw_by_formula {
                stream2.status = StreamStatus::Finished {
                    reason: StreamFinishReason::StoppedByOwner,
                };
                stop_stream(stream2.id.into())
            } else {
                stream2.status = StreamStatus::Paused;
                pause_stream(stream2.id.into())
            };
            promise2.then(Self::ext(env::current_account_id()).parse_two_streams(stream1, stream2))
        } else {
            Self::ext(env::current_account_id()).parse_two_streams(stream1, stream2)
        }
    }

    #[private]
    pub fn parse_two_streams(
        &mut self,
        stream1: Stream,
        stream2: Stream,
    ) -> (FinishedStreams, Stream, Stream) {
        require!(env::predecessor_account_id() == env::current_account_id());
        match (
            StatusType::new(stream1.status.clone()),
            StatusType::new(stream2.status.clone()),
        ) {
            (StatusType::Active, _) => unreachable!(),
            (_, StatusType::Active) => unreachable!(),
            (StatusType::Paused, StatusType::Paused) => (FinishedStreams::None, stream1, stream2),
            (StatusType::Finished, StatusType::Paused) => {
                (FinishedStreams::First, stream1, stream2)
            }
            (StatusType::Paused, StatusType::Finished) => {
                (FinishedStreams::Second, stream1, stream2)
            }
            (StatusType::Finished, StatusType::Finished) => {
                (FinishedStreams::Both, stream1, stream2)
            }
        }
    }
}

'''
'''--- src/lib.rs ---
use bid::Bid;
use cell::Cell;
use game::{Game, GameIndex};
use game_with_data::GameWithData;
use near_contract_standards::non_fungible_token::refund_deposit;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseResult,
};
use roketo::start_stream;
use utils::{DEFAULT_PLAYTIME, MIN_BID};

use crate::external::{Stream, StreamFinishReason, StreamStatus};
use crate::roketo::{pause_stream, stop_stream};
use crate::utils::{MAX_BID, MAX_PLAYTIME, MIN_PLAYTIME};

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Games,
    Field { game_id: GameIndex },
    Bid,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum MoveType {
    PLACE,
    SWAP,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub games: LookupMap<GameIndex, GameWithData>,
    pub bids: LookupMap<GameIndex, Bid>,
    pub next_game_id: u64,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            games: LookupMap::new(StorageKey::Games),
            bids: LookupMap::new(StorageKey::Bid),
            next_game_id: 0,
        }
    }

    #[payable]
    pub fn create_game(
        &mut self,
        first_player: AccountId,
        second_player: AccountId,
        field_size: Option<usize>,
        bid: Option<U128>,
        playtime: Option<u32>,
    ) -> GameIndex {
        if playtime.is_some() {
            require!(
                playtime.unwrap() >= MIN_PLAYTIME && playtime.unwrap() <= MAX_PLAYTIME,
                "Game playtime can't be too small or too big."
            );
            require!(
                bid.is_some(),
                "You can't make game with time control without betting."
            )
        }
        let game_bid = bid.map(|x| u128::from(x));
        if game_bid.is_some() {
            require!(
                game_bid.unwrap() >= MIN_BID && game_bid.unwrap() <= MAX_BID,
                "Bid can't be too small or too big."
            );
        }
        let initial_storage_usage = env::storage_usage();

        let index = self.next_game_id;
        let size = field_size.unwrap_or(11);
        let game_playtime = if game_bid.is_some() {
            if playtime.is_some() {
                playtime
            } else {
                Some(DEFAULT_PLAYTIME)
            }
        } else {
            None
        };

        self.games.insert(
            &index,
            &GameWithData::new(first_player, second_player, size, game_playtime),
        );

        if game_bid.is_some() {
            self.bids.insert(&index, &Bid::new(game_bid.unwrap()));
        }

        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;
        refund_deposit(required_storage_in_bytes);

        env::log_str("Created board:");
        self.games.get(&index).unwrap().game.board.debug_logs();
        self.next_game_id += 1;
        index
    }

    pub fn get_game(&self, index: GameIndex) -> Option<Game> {
        let game = self.games.get(&index).map(|x| x.game);
        if game.is_some() {
            env::log_str("Game board:");
            game.clone().unwrap().board.debug_logs();
        }
        game
    }

    pub fn make_move(
        &mut self,
        index: GameIndex,
        move_type: MoveType,
        cell: Option<Cell>,
    ) -> Promise {
        let game_with_data = self.games.get(&index).expect("Game doesn't exist.");
        require!(
            !game_with_data.game.is_finished,
            "Game is already finished!"
        );
        let bid = self.bids.get(&index);
        if let Some(bid) = bid {
            require!(
                bid.did_first_player_bet && bid.did_second_player_bet,
                "Players should deposit their bets before game start."
            );
        }
        let game = game_with_data.game;
        match (move_type.clone(), cell.clone()) {
            (MoveType::PLACE, Some(cell)) => {
                if game.turn % 2 == 0 {
                    require!(
                        env::predecessor_account_id() == game.first_player,
                        "It's not your turn"
                    );
                } else {
                    require!(
                        env::predecessor_account_id() == game.second_player,
                        "It's not your turn"
                    );
                }
                require!(game.board.get_cell(&cell) == 0, "Cell is already filled.");
            }
            (MoveType::SWAP, _) => {
                require!(
                    env::predecessor_account_id() == game.second_player,
                    "Incorrect predecessor account"
                );
                require!(
                    game.turn == 1,
                    "You can apply swap rule only on the second turn"
                );
            }
            _ => env::panic_str("Incorrect move args"),
        };

        // require!(
        //     env::prepaid_gas() >= MIN_MAKE_MOVE_GAS,
        //     "You should attach more gas."
        // );

        if let Some(promise) = self.check_stream_bids(index) {
            promise
                .then(Self::ext(env::current_account_id()).resolve_streams(index, move_type, cell))
        } else {
            Self::ext(env::current_account_id()).make_move_internal(index, move_type, cell)
        }
    }
}

pub mod bid;
pub mod board;
pub mod cell;
pub mod external;
pub mod game;
pub mod game_with_data;
pub mod internal;
pub mod roketo;
pub mod utils;

#[cfg(all(test, not(target_arch = "wasm32")))]
mod contract_tests {
    use core::fmt::Debug;
    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env, AccountId,
    };

    use crate::{
        board::Board, cell::Cell, game::Game, game_with_data::GameWithData, Contract, MoveType,
    };

    fn get_context(account: AccountId) -> near_sdk::VMContext {
        VMContextBuilder::new()
            .predecessor_account_id(account)
            .build()
    }

    impl PartialEq for Game {
        fn eq(&self, other: &Self) -> bool {
            self.first_player == other.first_player
                && self.second_player == other.second_player
                && self.turn == other.turn
                && self.board == other.board
                && self.current_block_height == other.current_block_height
                && self.prev_block_height == other.prev_block_height
                && self.is_finished == other.is_finished
        }
    }

    impl PartialEq for GameWithData {
        fn eq(&self, other: &Self) -> bool {
            self.game == other.game && self.data == other.data
        }
    }

    impl Debug for Game {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("Game")
                .field("first_player", &self.first_player)
                .field("second_player", &self.second_player)
                .field("turn", &self.turn)
                .field("board", &self.board)
                .field("current_block_height", &self.current_block_height)
                .field("prev_block_height", &self.prev_block_height)
                .field("is_finished", &self.is_finished)
                .finish()
        }
    }

    impl Debug for GameWithData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_struct("GameWithData")
                .field("game", &self.game)
                .field("data", &self.data)
                .finish()
        }
    }

    #[test]
    fn test_create_get() {
        let mut contract = Contract::new();
        contract.create_game(accounts(1), accounts(2), Some(3), None, None);
        contract.create_game(accounts(4), accounts(3), Some(4), None, None);
        let id = contract.create_game(accounts(0), accounts(1), None, None, None);
        assert_eq!(id, 2);
        let game = contract.get_game(id);

        assert!(contract.get_game(id + 1).is_none());
        assert!(game.is_some());
        assert_eq!(game.clone().unwrap().first_player, accounts(0));
        assert_eq!(game.clone().unwrap().second_player, accounts(1));
        assert_eq!(game.unwrap().board, Board::new(11));
    }

    #[test]
    fn test_make_move() {
        let mut contract = Contract::new();
        let id = contract.create_game(accounts(0), accounts(1), Some(5), None, None);

        testing_env!(get_context(accounts(0)));
        let mut test_game = GameWithData::new(accounts(0), accounts(1), 5, None);
        assert_eq!(test_game, contract.games.get(&id).unwrap());

        // let game = contract.make_move(id, MoveType::PLACE, Some(Cell::new(4, 0)));
        test_game.make_move(MoveType::PLACE, Some(Cell::new(4, 0)));
        // assert_eq!(test_game.game, game);
        assert_eq!(test_game, contract.games.get(&id).unwrap());

        testing_env!(get_context(accounts(1)));
        // let game = contract.make_move(id, MoveType::SWAP, Some(Cell::new(4, 0)));
        test_game.make_move(MoveType::SWAP, Some(Cell::new(4, 0)));
        // assert_eq!(test_game.game, game);
        assert_eq!(test_game, contract.games.get(&id).unwrap());
    }
}

'''
'''--- src/roketo.rs ---
use near_contract_standards::fungible_token::core::ext_ft_core;
use near_sdk::{
    json_types::{Base58CryptoHash, U128},
    Gas, Promise,
};

use crate::{
    external::{ext_roketo, ext_wrap},
    utils::{ONE_TERA, ROKETO_ACC, WRAP_ACC},
    *,
};

pub(crate) fn roketo_create_stream(
    bid: u128,
    game_playtime: u32,
    receiver_id: AccountId,
) -> Promise {
    let tokens_per_sec = (bid + game_playtime as u128 - 1) / game_playtime as u128;
    let fee = (bid + 9) / 10;
    let msg = format!("{{\"Create\":{{\"request\":{{\"balance\":\"{}\", \"owner_id\":\"{}\",\"receiver_id\":\"{}\",\"token_name\": \"wrap.testnet\", \"tokens_per_sec\":\"{}\"}}}}}}", bid, env::current_account_id(), receiver_id.to_string(), tokens_per_sec);
    ext_wrap::ext(WRAP_ACC.parse().unwrap())
        .with_attached_deposit(bid + fee)
        .near_deposit()
        .then(
            ext_ft_core::ext(WRAP_ACC.parse().unwrap())
                .with_attached_deposit(1)
                .with_static_gas(Gas(50 * ONE_TERA))
                .ft_transfer_call(
                    ROKETO_ACC.parse().unwrap(),
                    U128::from(bid + fee),
                    Some(String::from("Roketo transfer")),
                    msg,
                ),
        )
}

pub(crate) fn roketo_get_account(account_id: AccountId) -> Promise {
    ext_roketo::ext(ROKETO_ACC.parse().unwrap()).get_account(account_id, None)
}

pub(crate) fn roketo_get_stream(stream_id: Base58CryptoHash) -> Promise {
    ext_roketo::ext(ROKETO_ACC.parse().unwrap()).get_stream(stream_id)
}

pub(crate) fn get_two_streams(
    stream_id1: Base58CryptoHash,
    stream_id2: Base58CryptoHash,
) -> Promise {
    roketo_get_stream(stream_id1).and(roketo_get_stream(stream_id2))
}

pub(crate) fn pause_stream(stream_id: Base58CryptoHash) -> Promise {
    ext_roketo::ext(ROKETO_ACC.parse().unwrap())
        .with_attached_deposit(1)
        .with_static_gas(Gas(50 * ONE_TERA))
        .pause_stream(stream_id)
}

pub(crate) fn stop_stream(stream_id: Base58CryptoHash) -> Promise {
    ext_roketo::ext(ROKETO_ACC.parse().unwrap())
        .with_attached_deposit(1)
        .stop_stream(stream_id)
}

pub(crate) fn start_stream(stream_id: Base58CryptoHash) -> Promise {
    ext_roketo::ext(ROKETO_ACC.parse().unwrap())
        .with_attached_deposit(1)
        .start_stream(stream_id)
}

'''
'''--- src/utils.rs ---
use near_sdk::{Balance, Gas, ONE_NEAR};

pub const MIN_PLAYTIME: u32 = 5 * 60;
pub const MAX_PLAYTIME: u32 = 60 * 60;
pub const DEFAULT_PLAYTIME: u32 = 20 * 60;

pub const MIN_BID: Balance = 2 * ONE_NEAR;
pub const MAX_BID: Balance = 100 * ONE_NEAR;

pub const MIN_MAKE_BID_GAS: Gas = Gas(300 * ONE_TERA);
pub const MIN_MAKE_MOVE_GAS: Gas = Gas(300 * ONE_TERA);

pub const ONE_TERA: u64 = Gas::ONE_TERA.0;
pub const FEE: Balance = 2 * 10u128.pow(23);

pub const ROKETO_ACC: &str = "streaming-r-v2.dcversus.testnet";
pub const WRAP_ACC: &str = "wrap.testnet";
// pub const ROKETO_ACC: &str = "streaming.r-v2.near";
// pub const WRAP_ACC: &str = "wrap.near";

'''