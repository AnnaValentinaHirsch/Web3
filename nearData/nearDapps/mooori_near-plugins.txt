*GitHub Repository "mooori/near-plugins"*

'''--- .github/workflows/contract-analysis.yml ---
---
on:
  push:
    branches:
      - master
  pull_request:
  schedule:
    - cron: "30 15 * * *"
  workflow_dispatch:

name: "Contract Security Analysis"
jobs:
  contract_analysis:
    name: "Shared"
    uses: aurora-is-near/.github/.github/workflows/contract_analysis.yml@master
    secrets: inherit

'''
'''--- .github/workflows/test.yml ---
name: Rust Contracts

on:
  push:
    branches:
      - master
  pull_request:

jobs:
  tests:
    name: Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout sources
        uses: actions/checkout@v3

      - name: Install toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - uses: Swatinem/rust-cache@v1
        with:
          cache-on-failure: true

      - name: add wasm32-unknown-unknown
        run: rustup target add wasm32-unknown-unknown

      - name: cargo test
        run: cargo test --all --all-features

  lint:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout sources
        uses: actions/checkout@v3

      - name: Install toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy

      - uses: Swatinem/rust-cache@v1
        with:
          cache-on-failure: true

      - name: cargo fmt
        run: cargo fmt --all -- --check

      - name: cargo clippy
        run: cargo clippy --all --all-features --all-targets -- -D warnings

'''
'''--- CHANGELOG.md ---
# 0.1.0 (2023-05-08)

This section lists changes affecting multiple plugins. Changes that affect only individual plugins are listed below.

## BREAKING CHANGES
- Functions returning storage prefixes return `&'static [u8]` instead of `Vec<u8>`. [[#92](https://github.com/aurora-is-near/near-plugins/pull/92)]

## Testing & documentation
- All plugins are now tested in integration tests using Nearâ€™s [workspaces](https://docs.rs/crate/workspaces/0.7.0), as described [here](https://github.com/aurora-is-near/near-plugins#testing).
- The contracts used in tests contain many comments and serve as usage examples.

## Dependencies
- Update `near-sdk` to 4.1.0. [[#40](https://github.com/aurora-is-near/near-plugins/pull/40)]
- Update `workspaces` to 0.7. [[#65](https://github.com/aurora-is-near/near-plugins/pull/65)]

## Plugins

### `AccessControllable`

#### BREAKING CHANGES
- Store plugin state under a separate storage key. Previously it was stored under a field injected into the struct that derives `AccessControllable`. [[#84](https://github.com/aurora-is-near/near-plugins/pull/84)]

#### Feature enhancements
- Make the limit for the the number of role variants explicit. [[#70](https://github.com/aurora-is-near/near-plugins/pull/70)]
- Enable viewing permissions that have been granted to accounts. [[#75](https://github.com/aurora-is-near/near-plugins/pull/75), [#78](https://github.com/aurora-is-near/near-plugins/pull/78)]
- Add the function `acl_revoke_super_admin`. [[#89](https://github.com/aurora-is-near/near-plugins/pull/89)]
- Add the function `acl_transfer_super_admin`. [[#94](https://github.com/aurora-is-near/near-plugins/pull/94)]
- Add the function `acl_add_super_admin`. [[#98](https://github.com/aurora-is-near/near-plugins/pull/98)]

### `FullAccessKeyFallback`

#### BREAKING CHANGES
- The plugin has been removed. [[#87](https://github.com/aurora-is-near/near-plugins/pull/87)]

### `Pausable`

#### BREAKING CHANGES
- Use `AccessControllable` instead of `Ownable` to manage authorization of (un)pausing features and to define exemptions via `except`. [[47](https://github.com/aurora-is-near/near-plugins/pull/47)]
- Make functions `pa_[un]pause` return `bool`. [[#91](https://github.com/aurora-is-near/near-plugins/pull/91)]
- Emit events `Pause` and `Unpause` only if state was modified successfully. [[#91](https://github.com/aurora-is-near/near-plugins/pull/91)]

#### Feature enhancements
- Improve an error message related to `if_paused`. [[95](https://github.com/aurora-is-near/near-plugins/pull/95)]

### `Upgradable`

#### BREAKING CHANGES
- Use `AccessControllable` instead of `Ownable` to manage permissions for functionality provided by `Upgradable`. [[85](https://github.com/aurora-is-near/near-plugins/pull/85)]
- Enable optionally batching a function call with code deployment, which changes the signature of `Upgradable::up_deploy_code`. [[86](https://github.com/aurora-is-near/near-plugins/pull/86)]

#### Feature enhancements
- Allow contracts to set a minimum duration that must pass between staging and deploying new code. The staging duration is a safety mechanism to protect users. [[#44](https://github.com/aurora-is-near/near-plugins/pull/44)]

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "near-plugins",
    "near-plugins-derive"
]
exclude = ["target", "examples"]

[workspace.metadata.workspaces]
version = "0.15.0"

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Aurora Labs <hello@aurora.dev>"]
rust-version = "1.64.0"
description = "Ergonomic plugin system to extend NEAR contracts."
license = "CC0-1.0"
readme = "README.md"
repository = "https://github.com/aurora-is-near/near-plugins"
homepage = "https://github.com/aurora-is-near/near-plugins"
keywords = ["near", "smart contract", "plugin"]

[workspace.dependencies]
bitflags = "1.3"
near-sdk = "4.1.0"
near-plugins = { path = "near-plugins" }
near-plugins-derive = { path = "near-plugins-derive" }
serde = "1"
anyhow = "1.0"
borsh = "0.9"
tokio = { version = "1", features = ["full"] }
workspaces = "0.7"
toml = "0.5"
darling = "0.13.1"
proc-macro2 = "1.0"
quote = "1.0.9"
syn = { version = "1.0.69", features = ["full"] }
proc-macro-crate = "0.1.5"

'''
'''--- README.md ---
# NEAR Smart Contracts Plugins

Implementation of common patterns used for NEAR smart contracts. Macros provided by default assumes the contract is
using near-sdk-rs and `#[near_bindgen]` macro.

## Plugins

Documentation and implementation details of each plugin can be found in the source code, primarily in the [traits](/near-plugins/src/) which define plugin behavior. Events emitted by each plugin
are also described in the [source code](/near-plugins-derive/src/) of each macro. Each event follows [NEP-297](https://nomicon.io/Standards/EventsFormat).

The following sections provide an overview of all available plugins. More examples and usage patterns are available in [tests](/near-plugins-derive/tests) and [demo contracts](/near-plugins-derive/tests/contracts/).

### [Ownable](/near-plugins/src/ownable.rs)

Basic access control mechanism that allows _only_ an authorized account id to call certain methods. Note this account id can belong either to a regular user, or it could be a contract (a DAO for example).

[This contract](/near-plugins-derive/tests/contracts/ownable/src/lib.rs) provides an example of using `Ownable`. It is compiled, deployed on chain and interacted with in [integration tests](/near-plugins-derive/tests/ownable.rs).

Documentation of all methods provided by the derived implementation of `Ownable` is available in the [definition of the trait](/near-plugins/src/ownable.rs).

### [Pausable](/near-plugins/src/pausable.rs)

Allow contracts to implement an emergency stop mechanism that can be triggered by an authorized account. Pauses can be
used granularly to only limit certain features.

Using the `Pausable` plugin requires the contract to be _AccessControllable_ in order to manage permissions. Roles allowing accounts to call certain methods can be granted and revoked via the _AccessControllable_ plugin.

[This contract](/near-plugins-derive/tests/contracts/pausable/src/lib.rs) provides an example of using `Pausable`. It is compiled, deployed on chain and interacted with in [integration tests](/near-plugins-derive/tests/pausable.rs).

Documentation of all methods provided by `Pausable` is available in the [definition of the trait](/near-plugins/src/pausable.rs).

### [Upgradable](/near-plugins/src/upgradable.rs)

Allows a contract to be upgraded without requiring a full access key. Optionally a staging duration can be set, which defines the minimum duration that must pass before staged code can be deployed. The staging duration is a safety mechanism to protect users that interact with the contract, giving them time to opt-out before an unfavorable update is deployed.

Using the `Upgradable` plugin requires a contract to be `AccessControllable` to handle authorization for calling `Upgradable` methods to stage or deploy updates (listed below). 

To upgrade the contract, first call `up_stage_code` passing the binary as first argument serialized as borsh. Then call `up_deploy_code`.

To set a staging duration, call `up_init_staging_duration`. After initialization the staging duration can be updated by calling `up_stage_update_staging_duration` followed by `up_apply_update_staging_duration`. Updating the staging duration is itself subject to a delay: at least the currently set staging duration must pass before a staged update can be applied.

[This contract](/near-plugins-derive/tests/contracts/upgradable/src/lib.rs) provides an example of using `Upgradable`. It is compiled, deployed on chain and interacted with in [integration tests](/near-plugins-derive/tests/upgradable.rs).

Documentation of all methods provided by `Upgradable` is available in the [definition of the trait](/near-plugins/src/upgradable.rs).

### [AccessControllable](/near-plugins/src/access_controllable.rs)

Enables role-based access control for contract methods. A method with restricted access can only be called _successfully_ by accounts that have been granted one of the whitelisted roles. If a restricted method is called by an account with insufficient permissions, it panics.

Each role is managed by admins who may grant the role to accounts and revoke it from them. In addition, there are super admins that have admin permissions for every role. The sets of accounts that are (super) admins and grantees are stored in the contract's state.

[This contract](/near-plugins-derive/tests/contracts/access_controllable/src/lib.rs) provides an example of using `AccessControllable`. It is compiled, deployed on chain and interacted with in [integration tests](/near-plugins-derive/tests/access_controllable.rs).

Documentation of all methods provided by `AccessControllable` is available in the [definition of the trait](/near-plugins/src/access_controllable.rs).

## Internal Architecture

Each plugin's functionality is described by a trait defined in `near-plugins/src/<plugin_name>.rs`. The trait's methods will be available on contracts that use the corresponding plugin, whereas the implementation of the trait is provided by procedural macros.

The code that is generated for a trait implementation is based on `near-plugins-derive/src/<plugin_name.rs>`. To inspect the code generated for your particular smart contract, [`cargo-expand`](https://github.com/dtolnay/cargo-expand) can be helpful.

## Testing

Tests should verify that once the macros provided by this crate are expanded, the contract they are used in has the intended functionality. Integration tests are utilized for that purpose:

- A contract using the plugin is contained in `near-plugins-derive/tests/contracts/<plugin_name>/`.
- This contract is used in `near-plugins-derive/tests/<plugin_name>.rs` which:
    - Compiles and deploys the contract on chain via [NEAR `workspaces`](https://docs.rs/workspaces/0.7.0/workspaces/).
    - Sends transactions to the deployed contract to verify plugin functionality.

## Contributors Notes

Traits doesn't contain any implementation, even though some interfaces are self-contained enough to have it.
It is this way since `near_bindgen` macro from near-sdk-rs will only expose as public methods those that are implemented
during the trait implementation for the contract.

In the documentation all comments under Default Implementation makes remarks about the current implementation derived
automatically from macros. They can be changed if the trait is manually implemented rather than deriving the macro.

## Roadmap

- Factory upgrades: Allow upgrading all deployed contracts from the factory fetching binary upstream.
- Events ergonomics. `Event` macro that can be used in the following way:
```rust
#[derive(Serialize, Event(standard="nepXXX", version="1.0.1", action="transfer"))]
struct Transfer { 
    value: u64
}

/// In the contract
let transfer = Transfer { value: 1 };
transfer.emit(); // At this step the event is serialized and the log is emitted.
```
- Allow deriving plugins privately, i.e. without making the methods public.
    This will allow developers to create custom logic on top of the plugin without modifying source code.

'''
'''--- near-plugins-derive/Cargo.toml ---
[package]
name = "near-plugins-derive"
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
version.workspace = true

[lib]
proc-macro = true

[dependencies]
darling.workspace = true
proc-macro2.workspace = true
quote.workspace = true
syn.workspace = true
proc-macro-crate.workspace = true

[dev-dependencies]
anyhow.workspace = true
borsh.workspace = true
near-plugins.workspace = true
near-sdk.workspace = true
tokio.workspace = true
workspaces.workspace = true
toml.workspace = true

'''
'''--- near-plugins-derive/README.md ---
../README.md

'''
'''--- near-plugins-derive/src/access_control_role.rs ---
//! Implements `AccessControlRole` for an enum.
//!
//! The conversion of enum variants to bitflags representable by `u128` is the
//! key part of this implementation. Assume the trait is derived on the
//! following enum:
//!
//! ```ignore
//! #[derive(AccessControlRole)]
//! pub enum Role {
//!     LevelA,
//!     LevelB,
//!     LevelC,
//! }
//! ```
//!
//! This results in the following bitflags:
//! ```ignore
//! bitflags! {
//!     struct RoleFlags: u128 {
//!         const __SUPER_ADMIN = 1u128 << 0;
//!         const LEVELA        = 1u128 << 1;
//!         const LEVELA_ADMIN  = 1u128 << 2;
//!         const LEVELB        = 1u128 << 3;
//!         const LEVELB_ADMIN  = 1u128 << 4;
//!         const LEVELC        = 1u128 << 5;
//!         const LEVELC_ADMIN  = 1u128 << 6;
//!     }
//! }
//! ```
//!
//! The mapping between enum variants and bitflag has these properties:
//!
//! - Each flag has exactly one bit with value 1.
//! - A bitflag `1u128 << x` with odd `x` represents a role permission.
//! - A bitflag `1u128 << x` with even `x` represents an admin permission.
//! - Shifting a role's 1-bit to the left by one position yields the
//!   corresponding admin permission.
//!
//! The last property aims to facilitate migrations which add or remove enum
//! variants.

use crate::utils::cratename;
use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use quote::quote;
use std::convert::TryFrom;
use syn::{parse_macro_input, ItemEnum};

/// Roles as are represented by enum variants which are, in turn, represented by
/// `u128` bitflags. Each variant requires two flags, one for the role itself
/// and one for the corresponding admin permission. This would allow for 64
/// roles. However, one flag is reserved for `__SUPER_ADMIN`, leaving 127
/// bits that can fit 63 roles.
pub const MAX_ROLE_VARIANTS: u8 = 63;

const DEFAULT_SUPER_ADMIN_NAME: &str = "__SUPER_ADMIN";
const DEFAULT_BITFLAGS_TYPE_NAME: &str = "RoleFlags";
const DEFAULT_BOUNDCHECKER_TYPE_NAME: &str = "__AclBoundchecker";

/// Generates the token stream that implements `AccessControlRole`.
pub fn derive_access_control_role(input: TokenStream) -> TokenStream {
    // This derive doesn't take attributes, so no need to use `darling`.
    let cratename = cratename();
    let input: ItemEnum = parse_macro_input!(input);
    let ItemEnum {
        ident, variants, ..
    } = input;

    let variant_idents = variants.into_iter().map(|v| v.ident).collect::<Vec<_>>();
    assert!(
        variant_idents.len() <= usize::try_from(MAX_ROLE_VARIANTS).unwrap(),
        "The number of enum variants should not exceed MAX_ROLE_VARIANTS",
    );
    let variant_idxs: Vec<_> =
        (0..u8::try_from(variant_idents.len()).expect("Too many enum variants")).collect();
    let variant_names: Vec<_> = variant_idents.iter().map(|v| format!("{}", v)).collect();

    let boundchecker_type = Ident::new(DEFAULT_BOUNDCHECKER_TYPE_NAME, ident.span());
    let bitflags_type_ident = new_bitflags_type_ident(Span::call_site());
    let bitflags_idents = bitflags_idents(variant_names.as_ref(), bitflags_type_ident.span());
    let bitflags_idxs: Vec<_> =
        (0..u8::try_from(bitflags_idents.len()).expect("Too many bitflags")).collect();

    let output = quote! {
        // Ensure #ident satisfies bounds required for acl. This is done
        // explicitly to provide a clear error message to developers whose
        // enum doesn't satisfy the required bounds.
        //
        // Without this explicit check, compilation would still fail if a bound
        // is not satisfied. Though with less a clear error message.
        struct #boundchecker_type<T: Copy + Clone> {
            _marker: ::std::marker::PhantomData<T>,
        }
        impl<T: Copy + Clone> #boundchecker_type<T> {
            fn new() -> Self {
                Self {  _marker: Default::default() }
            }
        }
        impl #ident {
            fn check_bounds() {
                // Compilation will fail if #ident doesn't satisfy above bounds.
                let _x = #boundchecker_type::<#ident>::new();
            }
        }

        impl From<#ident> for u8 {
            fn from(value: #ident) -> Self {
                match value {
                    #(
                        #ident::#variant_idents => #variant_idxs,
                    )*
                }
            }
        }

        impl ::std::convert::TryFrom<u8> for #ident {
            type Error = &'static str;

            fn try_from(value: u8) -> Result<Self, Self::Error> {
                match value {
                    #(
                        #variant_idxs => Ok(#ident::#variant_idents),
                    )*
                    _ => Err("Value does not correspond to a variant"),
                }
            }
        }

        impl From<#ident> for &'static str {
            fn from(value: #ident) -> Self {
                match value {
                    #(
                        #ident::#variant_idents => #variant_names,
                    )*
                }
            }
        }

        impl From<#ident> for String {
            fn from(value: #ident) -> Self {
                match value {
                    #(
                        #ident::#variant_idents => #variant_names.to_string(),
                    )*
                }
            }
        }

        impl ::std::convert::TryFrom<&str> for #ident {
            type Error = &'static str;

            fn try_from(value: &str) -> Result<#ident, Self::Error> {
                match value {
                    #(
                        #variant_names => Ok(#ident::#variant_idents),
                    )*
                    _ => Err("Value does not correspond to a variant"),
                }
            }
        }

        /// Panics if `n` is too large.
        fn safe_leftshift(value: u128, n: u8) -> u128 {
            value
                .checked_shl(n.into())
                .unwrap_or_else(|| ::near_sdk::env::panic_str("Too many enum variants to be represented by bitflags"))
        }

        impl AccessControlRole for #ident {
            fn acl_role_variants() -> Vec<&'static str> {
                vec![
                    #(#variant_names,)*
                ]
            }

            fn acl_super_admin_permission() -> u128 {
                // See module documentation.
                1 // corresponds to safe_leftshift(1, 0)
            }

            fn acl_permission(self) -> u128 {
                // Shift 1u128 left by an odd number, see module documentation.
                let n = (u8::from(self) + 1)
                    .checked_mul(2).unwrap_or_else(|| ::near_sdk::env::panic_str("Too many enum variants")) - 1;
                safe_leftshift(1, n)
            }

            fn acl_admin_permission(self) -> u128 {
                // Shift 1u128 left by an even number, see module documentation.
                let n = (u8::from(self) + 1)
                    .checked_mul(2)
                    .unwrap_or_else(|| ::near_sdk::env::panic_str("Too many enum variants"));
                safe_leftshift(1, n)
            }
        }

        #cratename::bitflags::bitflags! {
            /// Encodes permissions for roles and admins.
            #[derive(BorshDeserialize, BorshSerialize, Default)]
            struct #bitflags_type_ident: u128 {
                #(
                    const #bitflags_idents = 1u128 << #bitflags_idxs;
                )*
            }
        }
    };

    output.into()
}

/// Generates and identifier for the bitflag type that represents permissions.
pub fn new_bitflags_type_ident(span: Span) -> Ident {
    Ident::new(DEFAULT_BITFLAGS_TYPE_NAME, span)
}

fn bitflags_idents(names: &[String], span: Span) -> Vec<Ident> {
    // Assuming enum variant names are in camel case, simply converting them
    // to uppercase is not ideal. However, bitflag identifiers aren't exposed,
    // so let's not bother with converting camel to screaming-snake case.
    let names = names
        .iter()
        .map(|name| name.to_uppercase())
        .collect::<Vec<_>>();
    let admin_names = names
        .iter()
        .map(|name| format!("{}_ADMIN", name))
        .collect::<Vec<_>>();
    let mut idents = vec![Ident::new(DEFAULT_SUPER_ADMIN_NAME, span)];
    for (name, admin_name) in names.iter().zip(admin_names) {
        idents.push(Ident::new(name.as_ref(), span));
        idents.push(Ident::new(admin_name.as_ref(), span));
    }
    idents
}

'''
'''--- near-plugins-derive/src/access_controllable.rs ---
use crate::access_control_role::new_bitflags_type_ident;
use crate::utils;
use crate::utils::{cratename, is_near_bindgen_wrapped_or_marshall};
use darling::FromMeta;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{parse_macro_input, AttributeArgs, ItemFn, ItemStruct};

/// Defines attributes for the `access_controllable` macro.
#[derive(Debug, FromMeta)]
pub struct MacroArgs {
    #[darling(default)]
    storage_prefix: Option<String>,
    role_type: darling::util::PathList,
}

const DEFAULT_STORAGE_PREFIX: &str = "__acl";
const DEFAULT_ACL_TYPE_NAME: &str = "__Acl";

const ERR_PARSE_BITFLAG: &str = "Value does not correspond to a permission";
const ERR_PARSE_ROLE: &str = "Value does not correspond to a role";

/// Generates the token stream that implements `AccessControllable`.
pub fn access_controllable(attrs: TokenStream, item: TokenStream) -> TokenStream {
    let cratename = cratename();
    let attr_args = parse_macro_input!(attrs as AttributeArgs);
    let input: ItemStruct = parse_macro_input!(item);
    let acl_type = syn::Ident::new(DEFAULT_ACL_TYPE_NAME, Span::call_site());
    let bitflags_type = new_bitflags_type_ident(Span::call_site());
    let ItemStruct { ident, .. } = input.clone();

    let macro_args = match MacroArgs::from_list(&attr_args) {
        Ok(args) => args,
        Err(e) => {
            return TokenStream::from(e.write_errors());
        }
    };
    let storage_prefix = macro_args
        .storage_prefix
        .unwrap_or_else(|| DEFAULT_STORAGE_PREFIX.to_string());
    assert!(
        macro_args.role_type.len() == 1,
        "role_type should be exactly one path"
    );
    let role_type = &macro_args.role_type[0];

    let output = quote! {
        #input

        #[derive(::near_sdk::borsh::BorshDeserialize, ::near_sdk::borsh::BorshSerialize)]
        struct #acl_type {
            /// Stores permissions per account.
            permissions: ::near_sdk::store::UnorderedMap<
                ::near_sdk::AccountId,
                #bitflags_type,
            >,
            /// Stores the set of accounts that bear a permission.
            bearers: ::near_sdk::store::UnorderedMap<
                #bitflags_type,
                ::near_sdk::store::UnorderedSet<::near_sdk::AccountId>,
            >,
        }

        impl Default for #acl_type {
            fn default() -> Self {
                let base_prefix = <#ident as AccessControllable>::acl_storage_prefix();
                Self {
                     permissions: ::near_sdk::store::UnorderedMap::new(
                        __acl_storage_prefix(base_prefix, __AclStorageKey::Permissions),
                    ),
                    bearers: ::near_sdk::store::UnorderedMap::new(
                        __acl_storage_prefix(base_prefix, __AclStorageKey::Bearers),
                    ),
                }
            }
        }

        /// Used to make storage prefixes unique. Not to be used directly,
        /// instead it should be prepended to the storage prefix specified by
        /// the user.
        #[derive(::near_sdk::borsh::BorshSerialize)]
        enum __AclStorageKey {
            Permissions,
            Bearers,
            BearersSet { permission: #bitflags_type },
            AclStorage,
        }

        /// Generates a prefix by concatenating the input parameters.
        fn __acl_storage_prefix(base: &[u8], specifier: __AclStorageKey) -> Vec<u8> {
            let specifier = specifier
                .try_to_vec()
                .unwrap_or_else(|_| ::near_sdk::env::panic_str("Storage key should be serializable"));
            [base, specifier.as_slice()].concat()
        }

        impl #ident {
            fn acl_get_storage(&self) -> Option<#acl_type> {
                let base_prefix = <#ident as AccessControllable>::acl_storage_prefix();
                near_sdk::env::storage_read(&__acl_storage_prefix(
                    base_prefix,
                    __AclStorageKey::AclStorage,
                ))
                .map(|acl_storage_bytes| {
                    #acl_type::try_from_slice(&acl_storage_bytes)
                        .unwrap_or_else(|_| near_sdk::env::panic_str("ACL: invalid acl storage format"))
                })
            }

            fn acl_get_or_init(&mut self) -> #acl_type {
                self.acl_get_storage().unwrap_or_else(|| self.acl_init_storage_unchecked())
            }

            fn acl_init_storage_unchecked(&mut self) -> #acl_type {
                let base_prefix = <#ident as AccessControllable>::acl_storage_prefix();
                let acl_storage: #acl_type = Default::default();
                near_sdk::env::storage_write(
                    &__acl_storage_prefix(base_prefix, __AclStorageKey::AclStorage),
                    &acl_storage.try_to_vec().unwrap(),
                );
                acl_storage
            }
        }

        impl #acl_type {
            fn new_bearers_set(permission: #bitflags_type) -> ::near_sdk::store::UnorderedSet<::near_sdk::AccountId> {
                let base_prefix = <#ident as AccessControllable>::acl_storage_prefix();
                let specifier = __AclStorageKey::BearersSet { permission };
                ::near_sdk::store::UnorderedSet::new(__acl_storage_prefix(base_prefix, specifier))
            }

            fn get_or_insert_permissions(&mut self, account_id: ::near_sdk::AccountId) -> &mut #bitflags_type {
                self.permissions.entry(account_id).or_insert_with(|| #bitflags_type::empty())
            }

            fn init_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> bool {
                let permission = <#bitflags_type>::from_bits(<#role_type>::acl_super_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                // Taking 1 at offset 0 is enough to check if there are no super admins assigned.
                let super_admins = self.get_bearers(permission, 0, 1);
                if super_admins.len() > 0 {
                    return false;
                }
                let res = self.add_super_admin_unchecked(account_id);
                ::near_sdk::require!(res, "Failed to init super-admin.");
                res
            }

            fn add_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_super_admin(&::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.add_super_admin_unchecked(account_id))
            }

            /// Makes `account_id` a super-admin __without__ checking any permissions.
            /// It returns whether `account_id` is a new super-admin.
            ///
            /// Note that there may be zero or more super-admins.
            fn add_super_admin_unchecked(&mut self, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(<#role_type>::acl_super_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = self.get_or_insert_permissions(account_id.clone());

                let is_new_super_admin = !permissions.contains(flag);
                if is_new_super_admin {
                    permissions.insert(flag);
                    self.add_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::SuperAdminAdded {
                        account: account_id.clone(),
                        by: ::near_sdk::env::predecessor_account_id(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                is_new_super_admin
            }

            fn is_super_admin(&self, account_id: &::near_sdk::AccountId) -> bool {
                let permissions = {
                    match self.permissions.get(account_id) {
                        Some(permissions) => permissions,
                        None => return false,
                    }
                };
                let super_admin = <#bitflags_type>::from_bits(<#role_type>::acl_super_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                permissions.contains(super_admin)
            }

            fn revoke_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_super_admin(&::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.revoke_super_admin_unchecked(account_id))
            }

            fn transfer_super_admin(&mut self, account_id: &::near_sdk::AccountId) -> Option<bool> {
                let current_super_admin = ::near_sdk::env::predecessor_account_id();
                if !self.is_super_admin(&current_super_admin) {
                    return None;
                }

                // The following state modifications can be considered atomic: They happen in the
                // current `FunctionCall` action because no promises or cross contract calls are
                // scheduled.
                //
                // If this ever changes, it should be avoided that revoking `current_super_admin`
                // succeeds and adding `account_id` as super-admin fails. This could lock contracts
                // in a state without super-admins. To protect against this scenario, the new
                // super-admin is added first.
                if account_id == &current_super_admin {
                    // That means Alice called `acl_transfer_super_admin(Alice)`, which should be a
                    // no-op and return `Some(true)`. However, the operations below would first add
                    // and then revoke Alice as super-admin, meaning Alice wouldn't be super-admin
                    // anymore. We return early to avoid that.
                    return Some(true);
                }
                let is_new_super_admin = self.add_super_admin_unchecked(account_id);
                self.revoke_super_admin_unchecked(&current_super_admin);
                Some(is_new_super_admin)
            }

            /// Revokes super-admin permissions from `account_id` without checking any
            /// permissions. It returns whether `account_id` was a super-admin.
            fn revoke_super_admin_unchecked(&mut self, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(<#role_type>::acl_super_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = match self.permissions.get_mut(account_id) {
                    Some(permissions) => permissions,
                    None => return false, // nothing to do, account has no permissions
                };

                let was_super_admin = permissions.contains(flag);
                if was_super_admin {
                    permissions.remove(flag);
                    self.remove_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::SuperAdminRevoked {
                        account: account_id.clone(),
                        by: ::near_sdk::env::predecessor_account_id(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                was_super_admin
            }

            fn add_admin(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.add_admin_unchecked(role, account_id))
            }

            /// Makes `account_id` an admin for role, __without__ checking any
            /// permissions. Returns whether `account_id` is a new admin for `role`.
            ///
            /// Note that any role may have multiple (or zero) admins.
            fn add_admin_unchecked(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(role.acl_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = self.get_or_insert_permissions(account_id.clone());

                let is_new_admin = !permissions.contains(flag);
                if is_new_admin {
                    permissions.insert(flag);
                    self.add_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::AdminAdded {
                        role: role.into(),
                        account: account_id.clone(),
                        by: ::near_sdk::env::predecessor_account_id(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                is_new_admin
            }

            fn is_admin(&self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                let permissions = {
                    match self.permissions.get(account_id) {
                        Some(permissions) => permissions,
                        None => return false,
                    }
                };
                let super_admin = <#bitflags_type>::from_bits(<#role_type>::acl_super_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let role_admin = <#bitflags_type>::from_bits(role.acl_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                permissions.contains(super_admin) || permissions.contains(role_admin)
            }

            fn revoke_admin(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.revoke_admin_unchecked(role, account_id))
            }

            fn renounce_admin(&mut self, role: #role_type) -> bool {
                self.revoke_admin_unchecked(role, &::near_sdk::env::predecessor_account_id())
            }

            /// Revokes admin permissions from `account_id` __without__ checking any
            /// permissions. Returns whether `account_id` was an admin for `role`.
            fn revoke_admin_unchecked(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(role.acl_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = match self.permissions.get_mut(account_id) {
                    Some(permissions) => permissions,
                    None => return false, // nothing to do, account has no permissions
                };

                let was_admin = permissions.contains(flag);
                if was_admin {
                    permissions.remove(flag);
                    self.remove_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::AdminRevoked {
                        role: role.into(),
                        account: account_id.clone(),
                        by: ::near_sdk::env::predecessor_account_id(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                was_admin
            }

            fn grant_role(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.grant_role_unchecked(role, account_id))
            }

            /// Grants `role` to `account_id` __without__ checking any permissions.
            /// Returns whether `role` was newly granted to `account_id`.
            fn grant_role_unchecked(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(role.acl_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = self.get_or_insert_permissions(account_id.clone());

                let is_new_grantee = !permissions.contains(flag);
                if is_new_grantee {
                    permissions.insert(flag);
                    self.add_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::RoleGranted {
                        role: role.into(),
                        by: ::near_sdk::env::predecessor_account_id(),
                        to: account_id.clone(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                is_new_grantee
            }

            fn revoke_role(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> Option<bool> {
                if !self.is_admin(role, &::near_sdk::env::predecessor_account_id()) {
                    return None;
                }
                Some(self.revoke_role_unchecked(role, account_id))
            }

            fn renounce_role(&mut self, role: #role_type) -> bool {
                self.revoke_role_unchecked(role, &::near_sdk::env::predecessor_account_id())
            }

            fn revoke_role_unchecked(&mut self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                let flag = <#bitflags_type>::from_bits(role.acl_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let mut permissions = match self.permissions.get_mut(account_id) {
                    Some(permissions) => permissions,
                    None => return false, // nothing to do, account has no permissions
                };

                let was_grantee = permissions.contains(flag);
                if was_grantee {
                    permissions.remove(flag);
                    self.remove_bearer(flag, account_id);

                    let event = #cratename::access_controllable::events::RoleRevoked {
                        role: role.into(),
                        from: account_id.clone(),
                        by: ::near_sdk::env::predecessor_account_id(),
                    };
                    #cratename::events::AsEvent::emit(&event);
                }

                was_grantee
            }

            fn has_role(&self, role: #role_type, account_id: &::near_sdk::AccountId) -> bool {
                match self.permissions.get(account_id) {
                    Some(permissions) => {
                        let flag = <#bitflags_type>::from_bits(role.acl_permission())
                            .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                        permissions.contains(flag)
                    }
                    None => false,
                }
            }

            fn has_any_role(
                &self, roles: Vec<#role_type>,
                account_id: &::near_sdk::AccountId
            ) -> bool {
                // Create a bitflags value with active bits for all `roles`.
                let target = roles
                    .iter()
                    .map(|role| {
                        <#bitflags_type>::from_bits(role.acl_permission())
                            .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG))
                    })
                    .fold(
                        <#bitflags_type>::empty(),
                        |acc, x| acc | x,
                    );
                self.has_any_permission(target, account_id)
            }

            fn has_any_permission(&self, target: #bitflags_type, account_id: &::near_sdk::AccountId) -> bool {
                let permissions = match self.permissions.get(account_id) {
                    Some(&permissions) => permissions,
                    None => return false,
                };
                target.intersects(permissions)
            }

            /// Adds `account_id` to the set of `permission` bearers.
            ///
            /// # Panics
            ///
            /// Panics if `permission` has more than one active bit. The type of
            /// permission defines only flags which have one active bit. Still,
            /// developers might call this function with a `permission` that has
            /// multiple active bits. In that case, the panic prevents polluting
            /// state.
            fn add_bearer(&mut self, permission: #bitflags_type, account_id: &::near_sdk::AccountId) {
                ::near_sdk::require!(
                    permission.bits().is_power_of_two(),
                    "Adding a bearer is allowed only for permissions with exactly one active bit"
                );
                let mut set = self.bearers.entry(permission).or_insert_with(|| {
                    Self::new_bearers_set(permission)
                });
                set.insert(account_id.clone());
            }

            /// Enables paginated retrieval of bearers. Returns up to `limit`
            /// bearers of `permission`, skipping the first `skip` items.
            ///
            /// # Panics
            ///
            /// Panics if `skip` or `limit` are outside the range of `usize`.
            fn get_bearers(&self, permission: #bitflags_type, skip: u64, limit: u64) -> Vec<::near_sdk::AccountId> {
                let skip: usize = ::std::convert::TryFrom::try_from(skip).unwrap_or_else(|_| ::near_sdk::env::panic_str("skip should be in the range of usize"));
                let limit: usize = ::std::convert::TryFrom::try_from(limit).unwrap_or_else(|_| ::near_sdk::env::panic_str("limit should be in the range of usize"));
                let set = match self.bearers.get(&permission) {
                    Some(set) => set,
                    None => return vec![],
                };
                set.iter().skip(skip).take(limit).cloned().collect()
            }

            /// Returns _all_ bearers of `permission`. In this implementation of
            /// `AccessControllable` there is no upper bound on the number of bearers per
            /// permission, so gas limits should be considered when calling this function.
            fn get_all_bearers(&self, permission: #bitflags_type) -> Vec<::near_sdk::AccountId> {
                let set = match self.bearers.get(&permission) {
                    Some(set) => set,
                    None => return vec![],
                };
                set.iter().cloned().collect()
            }

            /// Removes `account_id` from the set of `permission` bearers.
            fn remove_bearer(&mut self, permission: #bitflags_type, account_id: &::near_sdk::AccountId) {
                // If `permission` is invalid (more than one active bit), this
                // function is a no-op, due to the check in `add_bearer`.
                let mut set = match self.bearers.get_mut(&permission) {
                    Some(set) => set,
                    None => return,
                };
                set.remove(account_id);
            }

            /// Provides the implementation of `AccessControllable::acl_get_permissioned_accounts`.
            ///
            /// Uniqueness of account ids in returned vectors is guaranteed by the ids being
            /// retrieved from bearer sets.
            fn get_permissioned_accounts(&self) -> #cratename::access_controllable::PermissionedAccounts {
                // Get super admins.
                let permission = <#bitflags_type>::from_bits(
                    <#role_type>::acl_super_admin_permission()
                )
                .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                let super_admins = self.get_all_bearers(permission);

                // Get admins and grantees per role.
                let roles = <#role_type>::acl_role_variants();
                let mut map = ::std::collections::HashMap::new();
                for role in roles {
                    let role: #role_type = ::std::convert::TryFrom::try_from(role)
                        .unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                    let admin_permission = <#bitflags_type>::from_bits(role.acl_admin_permission())
                        .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                    let admins = self.get_all_bearers(admin_permission);

                    let grantee_permission = <#bitflags_type>::from_bits(role.acl_permission())
                        .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                    let grantees = self.get_all_bearers(grantee_permission);

                    map.insert(
                        role.into(),
                        #cratename::access_controllable::PermissionedAccountsPerRole {
                            admins,
                            grantees,
                        }
                    );
                }

                #cratename::access_controllable::PermissionedAccounts {
                    super_admins,
                    roles: map,
                }
            }
        }

        fn get_default_permissioned_accounts() -> #cratename::access_controllable::PermissionedAccounts {
            let roles = <#role_type>::acl_role_variants();
            let mut map = ::std::collections::HashMap::new();
            for role in roles {
                let role: #role_type = ::std::convert::TryFrom::try_from(role)
                    .unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));

                map.insert(
                    role.into(),
                    #cratename::access_controllable::PermissionedAccountsPerRole {
                        admins: Default::default(),
                        grantees: Default::default(),
                    }
                );
            }

            #cratename::access_controllable::PermissionedAccounts {
                super_admins: Default::default(),
                roles: map,
            }
        }

        macro_rules! return_if_none {
            ($res:expr, $default_value:expr) => {
                match $res {
                    Some(val) => val,
                    None => {
                        return $default_value;
                    }
                }
            };
        }

        // Note that `#[near-bindgen]` exposes non-public functions in trait
        // implementations. This is [documented] behavior. Therefore some
        // functions are made `#[private]` despite _not_ being public.
        //
        // [documented]: https://docs.near.org/sdk/rust/contract-interface/public-methods#exposing-trait-implementations
        #[near_bindgen]
        impl AccessControllable for #ident {
            fn acl_storage_prefix() -> &'static [u8] {
                (#storage_prefix).as_bytes()
            }

            #[private]
            fn acl_init_super_admin(&mut self, account_id: ::near_sdk::AccountId) -> bool {
                self.acl_get_or_init().init_super_admin(&account_id)
            }

            fn acl_add_super_admin(&mut self, account_id: ::near_sdk::AccountId) -> Option<bool> {
                self.acl_get_or_init().add_super_admin(&account_id)
            }

            fn acl_role_variants(&self) -> Vec<&'static str> {
                <#role_type>::acl_role_variants()
            }

            fn acl_is_super_admin(&self, account_id: ::near_sdk::AccountId) -> bool {
                return_if_none!(self.acl_get_storage(), false).is_super_admin(&account_id)
            }

            fn acl_revoke_super_admin(&mut self, account_id: ::near_sdk::AccountId) -> Option<bool> {
                self.acl_get_or_init().revoke_super_admin(&account_id)
            }

            fn acl_transfer_super_admin(&mut self, account_id: ::near_sdk::AccountId) -> Option<bool> {
                self.acl_get_or_init().transfer_super_admin(&account_id)
            }

            fn acl_add_admin(&mut self, role: String, account_id: ::near_sdk::AccountId) -> Option<bool> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().add_admin(role, &account_id)
            }

            fn acl_is_admin(&self, role: String, account_id: ::near_sdk::AccountId) -> bool {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                return_if_none!(self.acl_get_storage(), false).is_admin(role, &account_id)
            }

            fn acl_revoke_admin(&mut self, role: String, account_id: ::near_sdk::AccountId) -> Option<bool> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().revoke_admin(role, &account_id)
            }

            fn acl_renounce_admin(&mut self, role: String) -> bool {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().renounce_admin(role)
            }

            fn acl_revoke_role(&mut self, role: String, account_id: ::near_sdk::AccountId) -> Option<bool> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().revoke_role(role, &account_id)
            }

            fn acl_renounce_role(&mut self, role: String) -> bool {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().renounce_role(role)
            }

            fn acl_grant_role(&mut self, role: String, account_id: ::near_sdk::AccountId) -> Option<bool> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                self.acl_get_or_init().grant_role(role, &account_id)
            }

            fn acl_has_role(&self, role: String, account_id: ::near_sdk::AccountId) -> bool {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                return_if_none!(self.acl_get_storage(), false).has_role(role, &account_id)
            }

            fn acl_has_any_role(&self, roles: Vec<String>, account_id: ::near_sdk::AccountId) -> bool {
                let roles: Vec<#role_type> = roles
                    .iter()
                    .map(|role| {
                        ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE))
                    })
                    .collect();
                return_if_none!(self.acl_get_storage(), false).has_any_role(roles, &account_id)
            }

            fn acl_get_super_admins(&self, skip: u64, limit: u64) -> Vec<::near_sdk::AccountId> {
                let permission = <#bitflags_type>::from_bits(
                    <#role_type>::acl_super_admin_permission()
                )
                .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                return_if_none!(self.acl_get_storage(), vec![]).get_bearers(permission, skip, limit)
            }

            fn acl_get_admins(&self, role: String, skip: u64, limit: u64) -> Vec<::near_sdk::AccountId> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                let permission = <#bitflags_type>::from_bits(role.acl_admin_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                return_if_none!(self.acl_get_storage(), vec![]).get_bearers(permission, skip, limit)
            }

            fn acl_get_grantees(&self, role: String, skip: u64, limit: u64) -> Vec<::near_sdk::AccountId> {
                let role: #role_type = ::std::convert::TryFrom::try_from(role.as_str()).unwrap_or_else(|_| ::near_sdk::env::panic_str(#ERR_PARSE_ROLE));
                let permission = <#bitflags_type>::from_bits(role.acl_permission())
                    .unwrap_or_else(|| ::near_sdk::env::panic_str(#ERR_PARSE_BITFLAG));
                return_if_none!(self.acl_get_storage(), vec![]).get_bearers(permission, skip, limit)
            }

            fn acl_get_permissioned_accounts(&self) -> #cratename::access_controllable::PermissionedAccounts {
                return_if_none!(self.acl_get_storage(), get_default_permissioned_accounts()).get_permissioned_accounts()
            }
        }
    };

    output.into()
}

/// Defines attributes for the `access_control_any` macro.
#[derive(Debug, FromMeta)]
pub struct MacroArgsAny {
    roles: darling::util::PathList,
}

/// Generates the token stream for the `access_control_any` macro.
pub fn access_control_any(attrs: TokenStream, item: TokenStream) -> TokenStream {
    let attr_args = parse_macro_input!(attrs as AttributeArgs);
    let cloned_item = item.clone();
    let input: ItemFn = parse_macro_input!(cloned_item);
    if is_near_bindgen_wrapped_or_marshall(&input) {
        return item;
    }

    let function_name = input.sig.ident.to_string();

    let macro_args = match MacroArgsAny::from_list(&attr_args) {
        Ok(args) => args,
        Err(e) => {
            return TokenStream::from(e.write_errors());
        }
    };
    let roles = macro_args.roles;
    assert!(roles.len() > 0, "Specify at least one role");

    // TODO optimize case `roles.len() == 1` (speed up expected common case)
    let acl_check = quote! {
        let __acl_any_roles: Vec<&str> = vec![#(#roles.into()),*];
        let __acl_any_roles_ser: Vec<String> =
            __acl_any_roles.iter().map(|&role| role.into()).collect();
        let __acl_any_account_id = ::near_sdk::env::predecessor_account_id();
        if !self.acl_has_any_role(__acl_any_roles_ser, __acl_any_account_id) {
            let message = format!(
                "Insufficient permissions for method {} restricted by access control. Requires one of these roles: {:?}",
                #function_name,
                __acl_any_roles,
            );
            near_sdk::env::panic_str(&message);
        }
    };

    utils::add_extra_code_to_fn(&input, acl_check)
}

'''
'''--- near-plugins-derive/src/lib.rs ---
use proc_macro::{self, TokenStream};

mod access_control_role;
mod access_controllable;
mod ownable;
mod pausable;
mod upgradable;
mod utils;

/// Defines the derive macro for `Ownable`.
#[proc_macro_derive(Ownable, attributes(ownable))]
pub fn derive_ownable(input: TokenStream) -> TokenStream {
    ownable::derive_ownable(input)
}

/// Defines attribute macro `only`.
#[proc_macro_attribute]
pub fn only(attrs: TokenStream, item: TokenStream) -> TokenStream {
    ownable::only(attrs, item)
}

/// Defines the derive macro for `Upgradable`.
#[proc_macro_derive(Upgradable, attributes(upgradable))]
pub fn derive_upgradable(input: TokenStream) -> TokenStream {
    upgradable::derive_upgradable(input)
}

/// Defines the derive macro for `Pausable`.
#[proc_macro_derive(Pausable, attributes(pausable))]
pub fn derive_pausable(input: TokenStream) -> TokenStream {
    pausable::derive_pausable(input)
}

/// Defines the attribute macro `pause`.
#[proc_macro_attribute]
pub fn pause(attrs: TokenStream, item: TokenStream) -> TokenStream {
    pausable::pause(attrs, item)
}

/// Defines the attribute macro `if_paused`.
#[proc_macro_attribute]
pub fn if_paused(attrs: TokenStream, item: TokenStream) -> TokenStream {
    pausable::if_paused(attrs, item)
}

/// Defines the derive macro for `AccessControlRole`.
#[proc_macro_derive(AccessControlRole)]
pub fn derive_access_control_role(input: TokenStream) -> TokenStream {
    access_control_role::derive_access_control_role(input)
}

/// Defines the attribute macro `access_control`.
#[proc_macro_attribute]
pub fn access_control(attrs: TokenStream, item: TokenStream) -> TokenStream {
    access_controllable::access_controllable(attrs, item)
}

/// Defines the attribute macro `access_control_any`.
#[proc_macro_attribute]
pub fn access_control_any(attrs: TokenStream, item: TokenStream) -> TokenStream {
    access_controllable::access_control_any(attrs, item)
}

'''
'''--- near-plugins-derive/src/ownable.rs ---
use crate::utils;
use crate::utils::{cratename, is_near_bindgen_wrapped_or_marshall};
use darling::FromDeriveInput;
use proc_macro::{self, TokenStream};
use quote::quote;
use syn::{parse, parse_macro_input, DeriveInput, ItemFn};

#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(ownable), forward_attrs(allow, doc, cfg))]
struct Opts {
    owner_storage_key: Option<String>,
}

/// Generates the token stream that implements `Ownable`.
pub fn derive_ownable(input: TokenStream) -> TokenStream {
    let cratename = cratename();

    let input = parse_macro_input!(input);
    let opts = Opts::from_derive_input(&input).expect("Wrong options");
    let DeriveInput { ident, .. } = input;

    let owner_storage_key = opts
        .owner_storage_key
        .unwrap_or_else(|| "__OWNER__".to_string());

    let output = quote! {
        #[near_bindgen]
        impl Ownable for #ident {
            fn owner_storage_key(&self) -> &'static [u8] {
                (#owner_storage_key).as_bytes()
            }

            fn owner_get(&self) -> Option<::near_sdk::AccountId> {
                ::near_sdk::env::storage_read(&self.owner_storage_key()).map(|owner_bytes| {
                    let owner_raw =
                        String::from_utf8(owner_bytes).unwrap_or_else(|_| ::near_sdk::env::panic_str("Ownable: Invalid string format"));
                    std::convert::TryInto::try_into(owner_raw).unwrap_or_else(|_| ::near_sdk::env::panic_str("Ownable: Invalid account id"))
                })
            }

            fn owner_set(&mut self, owner: Option<::near_sdk::AccountId>) {
                let current_owner = self.owner_get();

                if let Some(owner) = current_owner.as_ref() {
                    assert_eq!(
                        &::near_sdk::env::predecessor_account_id(),
                        owner,
                        "Ownable: Only owner can update current owner"
                    );
                } else {
                    // If owner is not set, only self can update the owner.
                    // Used mostly on constructor.
                    assert_eq!(
                        ::near_sdk::env::predecessor_account_id(),
                        ::near_sdk::env::current_account_id(),
                        "Ownable: Owner not set. Only self can set the owner"
                    );
                }

                let event = #cratename::ownable::OwnershipTransferred {
                    previous_owner: current_owner,
                    new_owner: owner.clone(),
                };
                #cratename::events::AsEvent::emit(&event);

                match owner.as_ref() {
                    Some(owner) => ::near_sdk::env::storage_write(
                        &self.owner_storage_key(),
                        owner.as_ref().as_bytes(),
                    ),
                    None => ::near_sdk::env::storage_remove(&self.owner_storage_key()),
                };
            }

            fn owner_is(&self) -> bool {
                self.owner_get().map_or(false, |owner| {
                    owner == ::near_sdk::env::predecessor_account_id()
                })
            }
        }
    };

    output.into()
}

/// Generates the token stream for the `only` macro.
pub fn only(attrs: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse::<ItemFn>(item.clone()).unwrap();
    if is_near_bindgen_wrapped_or_marshall(&input) {
        return item;
    }
    let mut contains_self = false;
    let mut contains_owner = false;
    // TODO: Use darling
    for attr in attrs {
        match attr.to_string().as_str() {
            "self" => contains_self = true,
            "owner" => contains_owner = true,
            _ => {}
        }
    }

    let owner_check = match (contains_self, contains_owner) {
        (true, true) => quote! {
            if !self.owner_is() {
                ::near_sdk::assert_self();
            }
        },
        (true, false) => quote! {
            ::near_sdk::assert_self();
        },
        (false, true) => quote! {
            ::near_sdk::require!(self.owner_is(), "Ownable: Method must be called from owner");
        },
        (false, false) => {
            // The developer did not specify a target for `only`, so we panic during macro
            // expansion instead of returning a `TokenStream` that's added to the `input` function.
            // That's why this block is _not_ wrapped in `quote!` and we use `std::panic!` as opposed
            // to `near_sdk::env::panic_str`.
            panic!("Ownable::only macro target not specified. Select at least one in [self, owner]")
        }
    };

    utils::add_extra_code_to_fn(&input, owner_check)
}

'''
'''--- near-plugins-derive/src/pausable.rs ---
use crate::utils;
use crate::utils::{cratename, is_near_bindgen_wrapped_or_marshall};
use darling::util::PathList;
use darling::{FromDeriveInput, FromMeta};
use proc_macro::{self, TokenStream};
use quote::quote;
use syn::{parse, parse_macro_input, AttributeArgs, DeriveInput, ItemFn};

#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(pausable), forward_attrs(allow, doc, cfg))]
struct Opts {
    /// Storage key under which the set of paused features is stored. If it is
    /// `None` the default value will be used.
    paused_storage_key: Option<String>,
    /// Access control roles whose grantees may pause and unpause features.
    manager_roles: PathList,
}

/// Generates the token stream that implements `Pausable`.
pub fn derive_pausable(input: TokenStream) -> TokenStream {
    let cratename = cratename();

    let input = parse_macro_input!(input);
    let opts = Opts::from_derive_input(&input).expect("Wrong options");
    let DeriveInput { ident, .. } = input;

    let paused_storage_key = opts
        .paused_storage_key
        .unwrap_or_else(|| "__PAUSE__".to_string());
    let manager_roles = opts.manager_roles;
    assert!(
        manager_roles.len() > 0,
        "Specify at least one role for manager_roles"
    );

    let output = quote! {
        #[near_bindgen]
        impl Pausable for #ident {
            fn pa_storage_key(&self) -> &'static [u8] {
                (#paused_storage_key).as_bytes()
            }

            fn pa_is_paused(&self, key: String) -> bool {
                self.pa_all_paused()
                    .map(|keys| keys.contains(&key) || keys.contains("ALL"))
                    .unwrap_or(false)
            }

            fn pa_all_paused(&self) -> Option<std::collections::HashSet<String>> {
                ::near_sdk::env::storage_read(self.pa_storage_key().as_ref()).map(|value| {
                    std::collections::HashSet::try_from_slice(value.as_ref())
                        .unwrap_or_else(|_| ::near_sdk::env::panic_str("Pausable: Invalid format for paused keys"))
                })
            }

            #[#cratename::access_control_any(roles(#(#manager_roles),*))]
            fn pa_pause_feature(&mut self, key: String) -> bool {
                let mut paused_keys = self.pa_all_paused().unwrap_or_default();
                let newly_paused = paused_keys.insert(key.clone());

                if !newly_paused {
                    // Nothing to do since state was not modified.
                    return false;
                }

                ::near_sdk::env::storage_write(
                    self.pa_storage_key().as_ref(),
                    paused_keys
                        .try_to_vec()
                        .unwrap_or_else(|_| ::near_sdk::env::panic_str("Pausable: Unexpected error serializing keys"))
                        .as_ref(),
                );

                let event = #cratename::pausable::Pause {
                    by: ::near_sdk::env::predecessor_account_id(),
                    key,
                };
                #cratename::events::AsEvent::emit(&event);

                // The feature is newly paused.
                true
            }

            #[#cratename::access_control_any(roles(#(#manager_roles),*))]
            fn pa_unpause_feature(&mut self, key: String) -> bool {
                let mut paused_keys = self.pa_all_paused().unwrap_or_default();
                let was_paused = paused_keys.remove(&key);

                if !was_paused {
                    // Nothing to do since state is not modified.
                    return false;
                }

                if paused_keys.is_empty() {
                    ::near_sdk::env::storage_remove(self.pa_storage_key().as_ref());
                } else {
                    ::near_sdk::env::storage_write(
                        self.pa_storage_key().as_ref(),
                        paused_keys
                            .try_to_vec()
                            .unwrap_or_else(|_| ::near_sdk::env::panic_str("Pausable: Unexpected error serializing keys"))
                            .as_ref(),
                    );
                }

                let event = #cratename::pausable::Unpause {
                    by: ::near_sdk::env::predecessor_account_id(),
                    key,
                };
                #cratename::events::AsEvent::emit(&event);

                // The feature was paused.
                true
            }
        }
    };

    output.into()
}

/// Defines sub-attributes for the `except` attribute.
#[derive(Default, FromMeta, Debug)]
#[darling(default)]
pub struct ExceptSubArgs {
    /// Grantees of these roles are exempted and may always call the method.
    roles: PathList,
}

/// Defines attributes for the `pause` macro.
#[derive(Debug, FromMeta)]
pub struct PauseArgs {
    #[darling(default)]
    name: Option<String>,
    #[darling(default)]
    except: ExceptSubArgs,
}

/// Generates the token stream for the `pause` macro.
pub fn pause(attrs: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse::<ItemFn>(item.clone()).unwrap();

    if is_near_bindgen_wrapped_or_marshall(&input) {
        return item;
    }

    let attr_args = parse_macro_input!(attrs as AttributeArgs);
    let args = PauseArgs::from_list(&attr_args).expect("Invalid arguments");

    let fn_name = args.name.unwrap_or_else(|| input.sig.ident.to_string());

    let bypass_condition = get_bypass_condition(&args.except);

    let check_pause = quote!(
        let mut __check_paused = true;
        #bypass_condition
        if __check_paused {
            ::near_sdk::require!(!self.pa_is_paused(#fn_name.to_string()), "Pausable: Method is paused");
        }
    );

    utils::add_extra_code_to_fn(&input, check_pause)
}

/// Defines attributes for the `if_paused` macro.
#[derive(Debug, FromMeta)]
pub struct IfPausedArgs {
    name: String,
    #[darling(default)]
    except: ExceptSubArgs,
}

/// Generates the token stream for the `if_paused` macro.
pub fn if_paused(attrs: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse::<ItemFn>(item.clone()).unwrap();

    if is_near_bindgen_wrapped_or_marshall(&input) {
        return item;
    }

    let attr_args = parse_macro_input!(attrs as AttributeArgs);
    let args = IfPausedArgs::from_list(&attr_args).expect("Invalid arguments");

    let fn_name = args.name;

    // Construct error messages that use `format!` here, i.e. at compile time. Doing that during
    // contract execution would cost extra gas.
    let err_feature_not_paused = format!("Pausable: {fn_name} must be paused to use this function");

    let bypass_condition = get_bypass_condition(&args.except);

    let check_pause = quote!(
        let mut __check_paused = true;
        #bypass_condition
        if __check_paused {
            ::near_sdk::require!(
                self.pa_is_paused(#fn_name.to_string()),
                #err_feature_not_paused,
            );
        }
    );

    utils::add_extra_code_to_fn(&input, check_pause)
}

fn get_bypass_condition(args: &ExceptSubArgs) -> proc_macro2::TokenStream {
    let except_roles = args.roles.clone();
    quote!(
        let __except_roles: Vec<&str> = vec![#(#except_roles.into()),*];
        let __except_roles: Vec<String> = __except_roles.iter().map(|&x| x.into()).collect();
        let may_bypass = self.acl_has_any_role(
            __except_roles,
            ::near_sdk::env::predecessor_account_id()
        );
        if may_bypass {
            __check_paused = false;
        }
    )
}

'''
'''--- near-plugins-derive/src/upgradable.rs ---
use crate::utils::cratename;
use darling::util::PathList;
use darling::{FromDeriveInput, FromMeta};
use proc_macro::{self, TokenStream};
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(upgradable), forward_attrs(allow, doc, cfg))]
struct Opts {
    /// Storage prefix under which this plugin stores its state. If it is `None` the default value
    /// will be used.
    storage_prefix: Option<String>,
    /// Roles which are permitted to call protected methods.
    access_control_roles: AccessControlRoles,
}

/// Specifies which `AccessControlRole`s may call protected methods.
///
/// All field names need to be passed to calls of `check_roles_specified_for!`.
#[derive(Default, FromMeta, Debug)]
#[darling(default)]
struct AccessControlRoles {
    /// Grantess of these roles may successfully call `Upgradable::up_stage_code`.
    code_stagers: PathList,
    /// Grantess of these roles may successfully call `Upgradable::up_deploy_code`.
    code_deployers: PathList,
    /// Grantess of these roles may successfully call `Upgradable::up_init_staging_duration`.
    duration_initializers: PathList,
    /// Grantess of these roles may successfully call `Upgradable::up_stage_update_staging_duration`.
    duration_update_stagers: PathList,
    /// Grantess of these roles may successfully call `Upgradable::up_apply_update_staging_duration`.
    duration_update_appliers: PathList,
}

impl AccessControlRoles {
    /// Validates the roles provided by the plugin user and panics if they are invalid.
    fn validate(&self) {
        // Ensure at least one role is provided for every field of `AccessControlRoles`.
        let mut missing_roles = vec![];

        macro_rules! check_roles_specified_for {
            ($($field_name:ident),+) => (
                $(
                if self.$field_name.len() == 0 {
                    missing_roles.push(stringify!($field_name));
                }
                )+
            )
        }

        check_roles_specified_for!(
            code_stagers,
            code_deployers,
            duration_initializers,
            duration_update_stagers,
            duration_update_appliers
        );
        assert!(
            missing_roles.is_empty(),
            "Specify access_control_roles for: {:?}",
            missing_roles,
        );
    }
}

const DEFAULT_STORAGE_PREFIX: &str = "__up__";

/// Generates the token stream for the `Upgradable` macro.
pub fn derive_upgradable(input: TokenStream) -> TokenStream {
    let cratename = cratename();

    let input = parse_macro_input!(input);
    let opts = Opts::from_derive_input(&input).expect("Wrong options");
    let DeriveInput { ident, .. } = input;

    let storage_prefix = opts
        .storage_prefix
        .unwrap_or_else(|| DEFAULT_STORAGE_PREFIX.to_string());
    let acl_roles = opts.access_control_roles;
    acl_roles.validate();

    // To use fields of a struct inside `quote!`, they must be lifted into variables, see
    // https://github.com/dtolnay/quote/pull/88#pullrequestreview-180577592
    let acl_roles_code_stagers = acl_roles.code_stagers;
    let acl_roles_code_deployers = acl_roles.code_deployers;
    let acl_roles_duration_initializers = acl_roles.duration_initializers;
    let acl_roles_duration_update_stagers = acl_roles.duration_update_stagers;
    let acl_roles_duration_update_appliers = acl_roles.duration_update_appliers;

    let output = quote! {
        /// Used to make storage prefixes unique. Not to be used directly,
        /// instead it should be prepended to the storage prefix specified by
        /// the user.
        #[derive(::near_sdk::borsh::BorshSerialize)]
        enum __UpgradableStorageKey {
            Code,
            StagingTimestamp,
            StagingDuration,
            NewStagingDuration,
            NewStagingDurationTimestamp,
        }

        impl #ident {
            fn up_get_timestamp(&self, key: __UpgradableStorageKey) -> Option<::near_sdk::Timestamp> {
                near_sdk::env::storage_read(self.up_storage_key(key).as_ref()).map(|timestamp_bytes| {
                    ::near_sdk::Timestamp::try_from_slice(&timestamp_bytes).unwrap_or_else(|_|
                        near_sdk::env::panic_str("Upgradable: Invalid u64 timestamp format")
                    )
                })
            }

            fn up_get_duration(&self, key: __UpgradableStorageKey) -> Option<::near_sdk::Duration> {
                near_sdk::env::storage_read(self.up_storage_key(key).as_ref()).map(|duration_bytes| {
                    ::near_sdk::Duration::try_from_slice(&duration_bytes).unwrap_or_else(|_|
                            near_sdk::env::panic_str("Upgradable: Invalid u64 Duration format")
                    )
                })
            }

            fn up_set_timestamp(&self, key: __UpgradableStorageKey, value: ::near_sdk::Timestamp) {
                self.up_storage_write(key, &value.try_to_vec().unwrap());
            }

            fn up_set_duration(&self, key: __UpgradableStorageKey, value: ::near_sdk::Duration) {
                self.up_storage_write(key, &value.try_to_vec().unwrap());
            }

            fn up_storage_key(&self, key: __UpgradableStorageKey) -> Vec<u8> {
                let key_vec = key
                    .try_to_vec()
                    .unwrap_or_else(|_| ::near_sdk::env::panic_str("Storage key should be serializable"));
                [(#storage_prefix).as_bytes(), key_vec.as_slice()].concat()
            }

            fn up_storage_write(&self, key: __UpgradableStorageKey, value: &[u8]) {
                near_sdk::env::storage_write(self.up_storage_key(key).as_ref(), &value);
            }

            fn up_set_staging_duration_unchecked(&self, staging_duration: near_sdk::Duration) {
                self.up_storage_write(__UpgradableStorageKey::StagingDuration, &staging_duration.try_to_vec().unwrap());
            }
        }

        #[near_bindgen]
        impl Upgradable for #ident {
            fn up_storage_prefix(&self) -> &'static [u8] {
                (#storage_prefix).as_bytes()
            }

            fn up_get_delay_status(&self) -> #cratename::UpgradableDurationStatus {
                near_plugins::UpgradableDurationStatus {
                    staging_duration: self.up_get_duration(__UpgradableStorageKey::StagingDuration),
                    staging_timestamp: self.up_get_timestamp(__UpgradableStorageKey::StagingTimestamp),
                    new_staging_duration: self.up_get_duration(__UpgradableStorageKey::NewStagingDuration),
                    new_staging_duration_timestamp: self.up_get_timestamp(__UpgradableStorageKey::NewStagingDurationTimestamp),
                }
            }

            #[#cratename::access_control_any(roles(#(#acl_roles_code_stagers),*))]
            fn up_stage_code(&mut self, #[serializer(borsh)] code: Vec<u8>) {
                if code.is_empty() {
                    near_sdk::env::storage_remove(self.up_storage_key(__UpgradableStorageKey::Code).as_ref());
                    near_sdk::env::storage_remove(self.up_storage_key(__UpgradableStorageKey::StagingTimestamp).as_ref());
                } else {
                    let timestamp = near_sdk::env::block_timestamp() + self.up_get_duration(__UpgradableStorageKey::StagingDuration).unwrap_or(0);
                    self.up_storage_write(__UpgradableStorageKey::Code, &code);
                    self.up_set_timestamp(__UpgradableStorageKey::StagingTimestamp, timestamp);
                }
            }

            #[result_serializer(borsh)]
            fn up_staged_code(&self) -> Option<Vec<u8>> {
                near_sdk::env::storage_read(self.up_storage_key(__UpgradableStorageKey::Code).as_ref())
            }

            fn up_staged_code_hash(&self) -> Option<::near_sdk::CryptoHash> {
                self.up_staged_code()
                    .map(|code| std::convert::TryInto::try_into(near_sdk::env::sha256(code.as_ref())).unwrap())
            }

            #[#cratename::access_control_any(roles(#(#acl_roles_code_deployers),*))]
            fn up_deploy_code(&mut self, function_call_args: Option<#cratename::upgradable::FunctionCallArgs>) -> near_sdk::Promise {
                let staging_timestamp = self.up_get_timestamp(__UpgradableStorageKey::StagingTimestamp)
                    .unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: staging timestamp isn't set"));

                if near_sdk::env::block_timestamp() < staging_timestamp {
                    near_sdk::env::panic_str(
                        format!(
                            "Upgradable: Deploy code too early: staging ends on {}",
                            staging_timestamp
                        )
                        .as_str(),
                    );
                }

                let code = self.up_staged_code().unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: No staged code"));
                let promise = near_sdk::Promise::new(near_sdk::env::current_account_id())
                    .deploy_contract(code);
                match function_call_args {
                    None => promise,
                    Some(args) => {
                        // Execute the `DeployContract` and `FunctionCall` actions in a batch
                        // transaction to make a failure of the function call roll back the code
                        // deployment.
                        promise.function_call(args.function_name, args.arguments, args.amount, args.gas)
                    },
                }
            }

            #[#cratename::access_control_any(roles(#(#acl_roles_duration_initializers),*))]
            fn up_init_staging_duration(&mut self, staging_duration: near_sdk::Duration) {
                near_sdk::require!(self.up_get_duration(__UpgradableStorageKey::StagingDuration).is_none(), "Upgradable: staging duration was already initialized");
                self.up_set_staging_duration_unchecked(staging_duration);
            }

            #[#cratename::access_control_any(roles(#(#acl_roles_duration_update_stagers),*))]
            fn up_stage_update_staging_duration(&mut self, staging_duration: near_sdk::Duration) {
                let current_staging_duration = self.up_get_duration(__UpgradableStorageKey::StagingDuration)
                    .unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: staging duration isn't initialized"));

                self.up_set_duration(__UpgradableStorageKey::NewStagingDuration, staging_duration);
                let staging_duration_timestamp = near_sdk::env::block_timestamp() + current_staging_duration;
                self.up_set_timestamp(__UpgradableStorageKey::NewStagingDurationTimestamp, staging_duration_timestamp);
            }

            #[#cratename::access_control_any(roles(#(#acl_roles_duration_update_appliers),*))]
            fn up_apply_update_staging_duration(&mut self) {
                let staging_timestamp = self.up_get_timestamp(__UpgradableStorageKey::NewStagingDurationTimestamp)
                    .unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: No staged update"));

                if near_sdk::env::block_timestamp() < staging_timestamp {
                    near_sdk::env::panic_str(
                        format!(
                            "Upgradable: Update duration too early: staging ends on {}",
                            staging_timestamp
                        )
                        .as_str(),
                    );
                }

                let new_duration = self.up_get_duration(__UpgradableStorageKey::NewStagingDuration)
                    .unwrap_or_else(|| ::near_sdk::env::panic_str("Upgradable: No staged duration update"));

                self.up_set_duration(__UpgradableStorageKey::StagingDuration, new_duration);
            }
        }
    };

    output.into()
}

'''
'''--- near-plugins-derive/src/utils.rs ---
use proc_macro2::Span;
use proc_macro_crate::crate_name;
use syn::{Ident, ItemFn};

/// Determines if this block of code was [generated by near_bindgen].
/// Heuristic used is to check for #[no_mangle].
/// TODO: How to make this 100% safe. Discuss with near-sdk team
///
/// [generated by near_bindgen]: https://github.com/near/near-sdk-rs/issues/722
pub(crate) fn is_near_bindgen_wrapped_or_marshall(item: &ItemFn) -> bool {
    let pattern1 = "(target_arch = \"wasm32\")";
    let pattern2 = "(not(target_arch = \"wasm32\"))";
    item.attrs.iter().any(|attr| {
        let seq = attr.tokens.to_string();
        seq == pattern1 || seq == pattern2
    })
}

/// Returns an identifier for the name of the crate which is imported by plugin users.
pub(crate) fn cratename() -> Ident {
    Ident::new(
        &crate_name("near-plugins").unwrap_or_else(|_| "near_plugins".to_string()),
        Span::call_site(),
    )
}

/// Injects extra code into a function.
pub(crate) fn add_extra_code_to_fn(
    fn_code: &ItemFn,
    extra_code: proc_macro2::TokenStream,
) -> proc_macro::TokenStream {
    let ItemFn {
        attrs,
        vis,
        sig,
        block,
    } = fn_code;
    let stmts = &block.stmts;

    // https://stackoverflow.com/a/66851407
    quote::quote! {
        #(#attrs)* #vis #sig {
            #extra_code
            #(#stmts)*
        }
    }
    .into()
}

'''
'''--- near-plugins-derive/tests/access_controllable.rs ---
// Using `pub` to avoid invalid `dead_code` warnings, see
// https://users.rust-lang.org/t/invalid-dead-code-warning-for-submodule-in-integration-test/80259
pub mod common;

use common::access_controllable_contract::AccessControllableContract;
use common::utils::{
    as_sdk_account_id, assert_insufficient_acl_permissions, assert_private_method_failure,
    assert_success_with,
};
use near_plugins::access_controllable::{PermissionedAccounts, PermissionedAccountsPerRole};
use near_sdk::serde_json::json;
use std::collections::{HashMap, HashSet};
use std::convert::TryFrom;
use std::path::Path;
use workspaces::network::Sandbox;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract, Worker};

const PROJECT_PATH: &str = "./tests/contracts/access_controllable";

/// All roles which are defined in the contract in [`PROJECT_PATH`].
const ALL_ROLES: [&str; 3] = ["ByMax2Increaser", "ByMax3Increaser", "Resetter"];

/// Bundles resources required in tests.
struct Setup {
    /// The worker interacting with the current sandbox.
    worker: Worker<Sandbox>,
    /// Deployed instance of the contract in [`PROJECT_PATH`].
    contract: AccessControllableContract,
    /// A newly created account (which differs from the contract).
    account: Account,
}

impl Setup {
    fn contract_account(&self) -> &Account {
        self.contract.contract().as_account()
    }

    /// Deploys the contract and calls the initialization method without passing any accounts to be
    /// added as admin or grantees.
    async fn new() -> anyhow::Result<Self> {
        Self::new_with_admins_and_grantees(Default::default(), Default::default()).await
    }

    /// Deploys the contract and passes `admins` and `grantees` to the initialization method. Note
    /// that accounts corresponding to the ids in `admins` and `grantees` are _not_ created.
    async fn new_with_admins_and_grantees(
        admins: HashMap<String, AccountId>,
        grantees: HashMap<String, AccountId>,
    ) -> anyhow::Result<Self> {
        let worker = workspaces::sandbox().await?;
        let wasm =
            common::repo::compile_project(Path::new(PROJECT_PATH), "access_controllable").await?;
        let contract = AccessControllableContract::new(worker.dev_deploy(&wasm).await?);
        let account = worker.dev_create_account().await?;

        contract
            .contract()
            .call("new")
            .args_json(json!({
                "admins": admins,
                "grantees": grantees,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?;

        Ok(Self {
            worker,
            contract,
            account,
        })
    }

    /// Returns a new account that is super-admin.
    async fn new_super_admin_account(&self) -> anyhow::Result<Account> {
        let account = self.worker.dev_create_account().await?;
        self.contract
            .acl_add_super_admin_unchecked(self.contract_account(), account.id())
            .await?
            .into_result()?;
        Ok(account)
    }

    /// Returns a new account that is admin for `roles`.
    async fn new_account_as_admin(&self, roles: &[&str]) -> anyhow::Result<Account> {
        let account = self.worker.dev_create_account().await?;
        for &role in roles {
            self.contract
                .acl_add_admin_unchecked(self.contract_account(), role, account.id())
                .await?
                .into_result()?;
        }
        Ok(account)
    }

    async fn new_account_with_roles(&self, roles: &[&str]) -> anyhow::Result<Account> {
        let account = self.worker.dev_create_account().await?;
        for &role in roles {
            self.contract
                .acl_grant_role_unchecked(self.contract_account(), role, account.id())
                .await?
                .into_result()?;
        }
        Ok(account)
    }
}

async fn call_increase_2(
    contract: &Contract,
    caller: &Account,
) -> workspaces::Result<ExecutionFinalResult> {
    caller
        .call(contract.id(), "increase_2")
        .args_json(())
        .max_gas()
        .transact()
        .await
}

/// Returns new `PermissionedAccounts` for [`ALL_ROLES`].
fn new_permissioned_accounts() -> PermissionedAccounts {
    let mut permissioned_accounts = PermissionedAccounts {
        super_admins: vec![],
        roles: HashMap::new(),
    };

    for role in ALL_ROLES {
        permissioned_accounts.roles.insert(
            role.to_string(),
            PermissionedAccountsPerRole {
                admins: vec![],
                grantees: vec![],
            },
        );
    }

    permissioned_accounts
}

/// Asserts both `PermissionedAcccounts` contain the same accounts with the same permissions,
/// disregarding order.
///
/// Expects both `a` and `b` to contain every role in [`ALL_ROLES`].
///
/// This function is available only in tests and used for small numbers of accounts, so simplicity
/// is favored over efficiency.
fn assert_permissioned_account_equivalence(a: &PermissionedAccounts, b: &PermissionedAccounts) {
    // Verify super admins.
    assert_account_ids_equivalence(
        a.super_admins.as_slice(),
        b.super_admins.as_slice(),
        "super_admins",
    );

    // Verify admins and grantees per role.
    assert_eq!(a.roles.len(), b.roles.len(), "Unequal number of roles");
    assert_eq!(a.roles.len(), ALL_ROLES.len(), "More roles than expected");
    for role in ALL_ROLES {
        let per_role_a = a
            .roles
            .get(role)
            .unwrap_or_else(|| panic!("PermissionedAccounts a misses role {}", role));
        let per_role_b = b
            .roles
            .get(role)
            .unwrap_or_else(|| panic!("PermissionedAccounts b misses role {}", role));

        assert_account_ids_equivalence(
            &per_role_a.admins,
            &per_role_b.admins,
            format!("admins of role {}", role).as_str(),
        );
        assert_account_ids_equivalence(
            &per_role_a.grantees,
            &per_role_b.grantees,
            format!("grantees of role {}", role).as_str(),
        );
    }
}

/// Asserts `a` and `b` contain the same `AccountId`s, disregarding order. Parameter `specifier` is
/// passed to the panic message in case of a mismatch.
///
/// This function is available only in tests and used for small numbers of accounts, so simplicity
/// is favored over efficiency.
fn assert_account_ids_equivalence(
    a: &[near_sdk::AccountId],
    b: &[near_sdk::AccountId],
    specifier: &str,
) {
    let set_a: HashSet<_> = a.iter().cloned().collect();
    let set_b: HashSet<_> = b.iter().cloned().collect();
    assert_eq!(set_a, set_b, "Unequal sets of AccountIds for {}", specifier,);
}

/// Smoke test of contract setup and basic functionality.
#[tokio::test]
async fn test_increase_and_get_counter() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract = contract.contract();

    account
        .call(contract.id(), "increase")
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let res: u64 = account
        .call(contract.id(), "get_counter")
        .view()
        .await?
        .json()?;

    assert_eq!(res, 1);
    Ok(())
}

#[tokio::test]
async fn test_acl_initialization_in_constructor() -> anyhow::Result<()> {
    let admin_id: AccountId = "admin.acl_test.near".parse().unwrap();
    let grantee_id: AccountId = "grantee.acl_test.near".parse().unwrap();
    let setup = Setup::new_with_admins_and_grantees(
        HashMap::from([("ByMax2Increaser".to_string(), admin_id.clone())]),
        HashMap::from([("Resetter".to_string(), grantee_id.clone())]),
    )
    .await?;

    setup
        .contract
        .assert_acl_is_admin(true, "ByMax2Increaser", &admin_id)
        .await;
    setup
        .contract
        .assert_acl_has_role(true, "Resetter", &grantee_id)
        .await;

    Ok(())
}

#[tokio::test]
async fn test_acl_role_variants() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let variants = setup.contract.acl_role_variants(&setup.account).await?;
    assert_eq!(variants, ALL_ROLES);
    Ok(())
}

#[tokio::test]
async fn test_acl_is_super_admin() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;

    let is_super_admin = contract.acl_is_super_admin(&account, account.id()).await?;
    assert!(!is_super_admin);

    contract
        .acl_add_super_admin_unchecked(contract.contract().as_account(), account.id())
        .await?
        .into_result()?;

    let is_super_admin = contract.acl_is_super_admin(&account, account.id()).await?;
    assert!(is_super_admin);

    Ok(())
}

#[tokio::test]
async fn test_acl_init_super_admin() -> anyhow::Result<()> {
    let Setup {
        worker,
        contract,
        account,
        ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();

    // Calling `acl_init_super_admin` after initialization adds super-admin.
    contract
        .assert_acl_is_super_admin(false, contract_account, account.id())
        .await;
    let res = contract
        .acl_init_super_admin(contract_account, account.id())
        .await?;
    assert_success_with(res, true);
    contract
        .assert_acl_is_super_admin(true, contract_account, account.id())
        .await;

    // Once there's a super-admin, `acl_init_super_admin` returns `false`.
    let res = contract
        .acl_init_super_admin(contract_account, account.id())
        .await?;
    assert_success_with(res, false);

    let other_account = worker.dev_create_account().await?;
    let res = contract
        .acl_init_super_admin(contract_account, other_account.id())
        .await?;
    assert_success_with(res, false);
    contract
        .assert_acl_is_super_admin(false, contract_account, other_account.id())
        .await;

    // When all super-admins have been removed, it succeeds again.
    let res = contract
        .acl_revoke_super_admin_unchecked(contract_account, account.id())
        .await?;
    assert_success_with(res, true);
    let res = contract
        .acl_init_super_admin(contract_account, other_account.id())
        .await?;
    assert_success_with(res, true);
    contract
        .assert_acl_is_super_admin(true, contract_account, other_account.id())
        .await;

    Ok(())
}

#[tokio::test]
async fn test_acl_add_super_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let to_be_super_admin = setup.worker.dev_create_account().await?;

    // Create accounts that add a super-admin.
    let caller_unauth = setup.worker.dev_create_account().await?;
    let caller_auth = setup.new_super_admin_account().await?;

    // Adding is a no-op if the caller is not a super-admin.
    let res = setup
        .contract
        .acl_add_super_admin(&caller_unauth, to_be_super_admin.id())
        .await?;
    assert_eq!(res, None);
    setup
        .contract
        .assert_acl_is_super_admin(false, setup.contract_account(), to_be_super_admin.id())
        .await;

    // Adding succeeds if the caller is a super-admin.
    let res = setup
        .contract
        .acl_add_super_admin(&caller_auth, to_be_super_admin.id())
        .await?;
    assert_eq!(res, Some(true));
    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), to_be_super_admin.id())
        .await;

    // Adding an account which is already super-admin returns `Some(false)`.
    let res = setup
        .contract
        .acl_add_super_admin(&caller_auth, to_be_super_admin.id())
        .await?;
    assert_eq!(res, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_add_super_admin_unchecked() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();

    contract
        .assert_acl_is_super_admin(false, contract_account, account.id())
        .await;
    let res = contract
        .acl_add_super_admin_unchecked(contract_account, account.id())
        .await?;
    assert_success_with(res, true);
    contract
        .assert_acl_is_super_admin(true, contract_account, account.id())
        .await;

    // Adding as super-admin again behaves as expected.
    let res = contract
        .acl_add_super_admin_unchecked(contract_account, account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_super_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), super_admin.id())
        .await;

    // Create revoker accounts.
    let revoker_unauth = setup.worker.dev_create_account().await?;
    let revoker_auth = setup.new_super_admin_account().await?;

    // Revoke is a no-op if revoker is not a super-admin.
    let res = setup
        .contract
        .acl_revoke_super_admin(&revoker_unauth, super_admin.id())
        .await?;
    assert_eq!(res, None);
    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), super_admin.id())
        .await;

    // Revoke succeeds if the revoker is a super-admin.
    let res = setup
        .contract
        .acl_revoke_super_admin(&revoker_auth, super_admin.id())
        .await?;
    assert_eq!(res, Some(true));
    setup
        .contract
        .assert_acl_is_super_admin(false, setup.contract_account(), super_admin.id())
        .await;

    // Revoking from an account which isn't super-admin returns `Some(false)`.
    let account = setup.worker.dev_create_account().await?;
    let res = setup
        .contract
        .acl_revoke_super_admin(&revoker_auth, account.id())
        .await?;
    assert_eq!(res, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_transfer_super_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;
    let new_super_admin = setup.worker.dev_create_account().await?;

    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), super_admin.id())
        .await;

    // Create caller account.
    let caller_unauth = setup.worker.dev_create_account().await?;

    // Transfer is a no-op if caller is not a super-admin.
    let res = setup
        .contract
        .acl_transfer_super_admin(&caller_unauth, super_admin.id())
        .await?;
    assert_eq!(res, None);
    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), super_admin.id())
        .await;
    setup
        .contract
        .assert_acl_is_super_admin(false, setup.contract_account(), new_super_admin.id())
        .await;

    // Transfer succeeds if the caller is a super-admin.
    let res = setup
        .contract
        .acl_transfer_super_admin(&super_admin, new_super_admin.id())
        .await?;
    assert_eq!(res, Some(true));
    setup
        .contract
        .assert_acl_is_super_admin(false, setup.contract_account(), super_admin.id())
        .await;
    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), new_super_admin.id())
        .await;

    // Transfer to an account that is already super-admin returns `Some(false)`.
    let admin = setup.new_super_admin_account().await?;
    let res = setup
        .contract
        .acl_transfer_super_admin(&new_super_admin, admin.id())
        .await?;
    assert_eq!(res, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_super_admin_unchecked() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let account = setup.new_super_admin_account().await?;

    setup
        .contract
        .assert_acl_is_super_admin(true, setup.contract_account(), account.id())
        .await;

    // Revoke an existing super-admin permission.
    let res = setup
        .contract
        .acl_revoke_super_admin_unchecked(setup.contract_account(), account.id())
        .await?;
    assert_success_with(res, true);
    setup
        .contract
        .assert_acl_is_super_admin(false, setup.contract_account(), account.id())
        .await;

    // Revoke from an account which is not super-admin.
    let res = setup
        .contract
        .acl_revoke_super_admin_unchecked(setup.contract_account(), account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

/// Verify that a super-admin is admin for every role.
#[tokio::test]
async fn test_super_admin_is_any_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    for role in ALL_ROLES {
        setup
            .contract
            .assert_acl_is_admin(true, role, super_admin.id())
            .await;
    }

    Ok(())
}

/// Verify that a super-admin may add admins for every role.
#[tokio::test]
async fn test_super_admin_may_add_any_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    for role in ALL_ROLES {
        let account = setup.worker.dev_create_account().await?;
        setup
            .contract
            .assert_acl_is_admin(false, role, account.id())
            .await;

        let res = setup
            .contract
            .acl_add_admin(&super_admin, role, account.id())
            .await?;
        assert_eq!(res, Some(true));
        setup
            .contract
            .assert_acl_is_admin(true, role, account.id())
            .await;
    }

    Ok(())
}

/// Verify that a super-admin may revoke admins for every role.
#[tokio::test]
async fn test_super_admin_may_revoke_any_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    for role in ALL_ROLES {
        let admin = setup.new_account_as_admin(&[role]).await?;
        setup
            .contract
            .assert_acl_is_admin(true, role, admin.id())
            .await;

        let res = setup
            .contract
            .acl_revoke_admin(&super_admin, role, admin.id())
            .await?;
        assert_eq!(res, Some(true));
        setup
            .contract
            .assert_acl_is_admin(false, role, admin.id())
            .await;
    }

    Ok(())
}

/// Verify that a super-admin may grant every role.
#[tokio::test]
async fn test_super_admin_may_grant_any_role() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    for role in ALL_ROLES {
        let account = setup.worker.dev_create_account().await?;
        setup
            .contract
            .assert_acl_has_role(false, role, account.id())
            .await;

        let res = setup
            .contract
            .acl_grant_role(&super_admin, role, account.id())
            .await?;
        assert_eq!(res, Some(true));
        setup
            .contract
            .assert_acl_has_role(true, role, account.id())
            .await;
    }

    Ok(())
}

/// Verify that a super-admin may revoke every role.
#[tokio::test]
async fn test_super_admin_may_revoke_any_role() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let super_admin = setup.new_super_admin_account().await?;

    for role in ALL_ROLES {
        let grantee = setup.new_account_with_roles(&[role]).await?;
        setup
            .contract
            .assert_acl_has_role(true, role, grantee.id())
            .await;

        let res = setup
            .contract
            .acl_revoke_role(&super_admin, role, grantee.id())
            .await?;
        assert_eq!(res, Some(true));
        setup
            .contract
            .assert_acl_has_role(false, role, grantee.id())
            .await;
    }

    Ok(())
}

#[tokio::test]
async fn test_acl_is_admin() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax2Increaser";

    let is_admin = contract.acl_is_admin(&account, role, account.id()).await?;
    assert!(!is_admin);

    contract
        .acl_add_admin_unchecked(contract_account, role, account.id())
        .await?
        .into_result()?;

    let is_admin = contract.acl_is_admin(&account, role, account.id()).await?;
    assert!(is_admin);

    Ok(())
}

#[tokio::test]
async fn test_acl_add_admin() -> anyhow::Result<()> {
    let Setup {
        worker,
        contract,
        account,
        ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax2Increaser";

    let acc_adding_admin = account;
    let acc_to_be_admin = worker.dev_create_account().await?;

    contract
        .assert_acl_is_admin(false, role, acc_to_be_admin.id())
        .await;

    // An account which isn't admin can't add admins.
    let added = contract
        .acl_add_admin(&acc_adding_admin, role, acc_to_be_admin.id())
        .await?;
    assert_eq!(added, None);

    // Admin can add others as admin.
    contract
        .acl_add_admin_unchecked(contract_account, role, acc_adding_admin.id())
        .await?
        .into_result()?;
    let added = contract
        .acl_add_admin(&acc_adding_admin, role, acc_to_be_admin.id())
        .await?;
    assert_eq!(added, Some(true));
    contract
        .assert_acl_is_admin(true, role, acc_to_be_admin.id())
        .await;

    // Adding an account that is already admin.
    let added = contract
        .acl_add_admin(&acc_adding_admin, role, acc_to_be_admin.id())
        .await?;
    assert_eq!(added, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_add_admin_unchecked() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax2Increaser";

    contract
        .assert_acl_is_admin(false, role, account.id())
        .await;
    let res = contract
        .acl_add_admin_unchecked(contract_account, role, account.id())
        .await?;
    assert_success_with(res, true);
    contract.assert_acl_is_admin(true, role, account.id()).await;

    // Adding as admin again behaves as expected.
    let res = contract
        .acl_add_admin_unchecked(contract_account, role, account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "ByMax3Increaser";
    let admin = setup.new_account_as_admin(&[role]).await?;

    setup
        .contract
        .assert_acl_is_admin(true, role, admin.id())
        .await;

    // Revoke is a no-op if revoker is not an admin for the role.
    let revoker = setup.new_account_as_admin(&[]).await?;
    let res = setup
        .contract
        .acl_revoke_admin(&revoker, role, admin.id())
        .await?;
    assert_eq!(res, None);
    let revoker = setup.new_account_as_admin(&["ByMax2Increaser"]).await?;
    let res = setup
        .contract
        .acl_revoke_admin(&revoker, role, admin.id())
        .await?;
    assert_eq!(res, None);
    setup
        .contract
        .assert_acl_is_admin(true, role, admin.id())
        .await;

    // Revoke succeeds if the revoker is an admin for the role.
    let revoker = setup.new_account_as_admin(&[role]).await?;
    let res = setup
        .contract
        .acl_revoke_admin(&revoker, role, admin.id())
        .await?;
    assert_eq!(res, Some(true));
    setup
        .contract
        .assert_acl_is_admin(false, role, admin.id())
        .await;

    // Revoking a role for which the account isn't admin returns `Some(false)`.
    let revoker = setup.new_account_as_admin(&[role]).await?;
    let account = setup.worker.dev_create_account().await?;
    let res = setup
        .contract
        .acl_revoke_admin(&revoker, role, account.id())
        .await?;
    assert_eq!(res, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_renounce_admin() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "Resetter";

    // An account which is isn't admin calls `acl_renounce_admin`.
    let res = setup
        .contract
        .acl_renounce_admin(&setup.account, role)
        .await?;
    assert!(!res);

    // An admin calls `acl_renounce_admin`.
    let admin = setup.new_account_as_admin(&[role]).await?;
    setup
        .contract
        .assert_acl_is_admin(true, role, admin.id())
        .await;
    let res = setup.contract.acl_renounce_admin(&admin, role).await?;
    assert!(res);
    setup
        .contract
        .assert_acl_is_admin(false, role, admin.id())
        .await;

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_admin_unchecked() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let account = setup
        .new_account_as_admin(&["ByMax2Increaser", "Resetter"])
        .await?;

    setup
        .contract
        .assert_acl_is_admin(true, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_is_admin(true, "Resetter", account.id())
        .await;

    // Revoke admin permissions for one of the roles.
    let res = setup
        .contract
        .acl_revoke_admin_unchecked(setup.contract_account(), "ByMax2Increaser", account.id())
        .await?;
    assert_success_with(res, true);
    setup
        .contract
        .assert_acl_is_admin(false, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_is_admin(true, "Resetter", account.id())
        .await;

    // Revoke admin permissions for the other role too.
    let res = setup
        .contract
        .acl_revoke_admin_unchecked(setup.contract_account(), "Resetter", account.id())
        .await?;
    assert_success_with(res, true);
    setup
        .contract
        .assert_acl_is_admin(false, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_is_admin(false, "Resetter", account.id())
        .await;

    // Revoking behaves as expected if the permission is not present.
    let res = setup
        .contract
        .acl_revoke_admin_unchecked(setup.contract_account(), "Resetter", account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

#[tokio::test]
async fn test_acl_has_role() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax2Increaser";

    let has_role = contract.acl_has_role(&account, role, account.id()).await?;
    assert!(!has_role);

    contract
        .acl_grant_role_unchecked(contract_account, role, account.id())
        .await?
        .into_result()?;

    let has_role = contract.acl_has_role(&account, role, account.id()).await?;
    assert!(has_role);

    Ok(())
}

#[tokio::test]
async fn test_acl_grant_role() -> anyhow::Result<()> {
    let Setup {
        worker,
        contract,
        account,
        ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax3Increaser";

    let granter = account;
    let grantee = worker.dev_create_account().await?;

    // An account which isn't admin can't grant the role.
    contract
        .assert_acl_is_admin(false, role, granter.id())
        .await;
    let granted = contract
        .acl_grant_role(&granter, role, grantee.id())
        .await?;
    assert_eq!(granted, None);
    contract
        .assert_acl_has_role(false, role, grantee.id())
        .await;

    // Admin can grant the role.
    contract
        .acl_add_admin_unchecked(contract_account, role, granter.id())
        .await?
        .into_result()?;
    let granted = contract
        .acl_grant_role(&granter, role, grantee.id())
        .await?;
    assert_eq!(granted, Some(true));
    contract.assert_acl_has_role(true, role, grantee.id()).await;

    // Granting the role to an account which already is a grantee.
    let granted = contract
        .acl_grant_role(&granter, role, grantee.id())
        .await?;
    assert_eq!(granted, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_grant_role_unchecked() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let contract_account = contract.contract().as_account();
    let role = "ByMax2Increaser";

    contract
        .assert_acl_has_role(false, role, account.id())
        .await;
    let res = contract
        .acl_grant_role_unchecked(contract_account, role, account.id())
        .await?;
    assert_success_with(res, true);
    contract.assert_acl_has_role(true, role, account.id()).await;

    // Granting a role again behaves as expected.
    let res = contract
        .acl_grant_role_unchecked(contract_account, role, account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_role() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "ByMax3Increaser";
    let grantee = setup.new_account_with_roles(&[role]).await?;

    setup
        .contract
        .assert_acl_has_role(true, role, grantee.id())
        .await;

    // Revoke is a no-op if revoker is not an admin for the role.
    let revoker = setup.new_account_as_admin(&[]).await?;
    let res = setup
        .contract
        .acl_revoke_role(&revoker, role, grantee.id())
        .await?;
    assert_eq!(res, None);
    let revoker = setup.new_account_as_admin(&["ByMax2Increaser"]).await?;
    let res = setup
        .contract
        .acl_revoke_role(&revoker, role, grantee.id())
        .await?;
    assert_eq!(res, None);
    setup
        .contract
        .assert_acl_has_role(true, role, grantee.id())
        .await;

    // Revoke succeeds if the revoker is an admin for the role.
    let revoker = setup.new_account_as_admin(&[role]).await?;
    let res = setup
        .contract
        .acl_revoke_role(&revoker, role, grantee.id())
        .await?;
    assert_eq!(res, Some(true));
    setup
        .contract
        .assert_acl_has_role(false, role, grantee.id())
        .await;

    // Revoking a role that isn't granted returns `Some(false)`.
    let revoker = setup.new_account_as_admin(&[role]).await?;
    let account = setup.worker.dev_create_account().await?;
    let res = setup
        .contract
        .acl_revoke_role(&revoker, role, account.id())
        .await?;
    assert_eq!(res, Some(false));

    Ok(())
}

#[tokio::test]
async fn test_acl_renounce_role() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "Resetter";

    // An account which is isn't grantee calls `acl_renounce_role`.
    let res = setup
        .contract
        .acl_renounce_role(&setup.account, role)
        .await?;
    assert!(!res);

    // A grantee calls `acl_renounce_admin`.
    let grantee = setup.new_account_with_roles(&[role]).await?;
    setup
        .contract
        .assert_acl_has_role(true, role, grantee.id())
        .await;
    let res = setup.contract.acl_renounce_role(&grantee, role).await?;
    assert!(res);
    setup
        .contract
        .assert_acl_has_role(false, role, grantee.id())
        .await;

    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_role_unchecked() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let account = setup
        .new_account_with_roles(&["ByMax2Increaser", "Resetter"])
        .await?;

    setup
        .contract
        .assert_acl_has_role(true, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_has_role(true, "Resetter", account.id())
        .await;

    // Revoke one of the roles.
    let res = setup
        .contract
        .acl_revoke_role_unchecked(setup.contract_account(), "ByMax2Increaser", account.id())
        .await?;
    assert_success_with(res, true);
    setup
        .contract
        .assert_acl_has_role(false, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_has_role(true, "Resetter", account.id())
        .await;

    // Revoke the other role too.
    let res = setup
        .contract
        .acl_revoke_role_unchecked(setup.contract_account(), "Resetter", account.id())
        .await?;
    assert_success_with(res, true);
    setup
        .contract
        .assert_acl_has_role(false, "ByMax2Increaser", account.id())
        .await;
    setup
        .contract
        .assert_acl_has_role(false, "Resetter", account.id())
        .await;

    // Revoking behaves as expected if the role is not granted.
    let res = setup
        .contract
        .acl_revoke_role_unchecked(setup.contract_account(), "Resetter", account.id())
        .await?;
    assert_success_with(res, false);

    Ok(())
}

#[tokio::test]
async fn test_attribute_access_control_any() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let raw_contract = setup.contract.contract();
    let method_name = "increase_2";
    let allowed_roles = vec!["ByMax2Increaser".to_string(), "ByMax3Increaser".to_string()];

    // Account without any of the required permissions is restricted.
    let account = setup.new_account_with_roles(&[]).await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_insufficient_acl_permissions(res, method_name, allowed_roles.clone());
    let account = setup.new_account_with_roles(&["Resetter"]).await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_insufficient_acl_permissions(res, method_name, allowed_roles.clone());

    // A super-admin which has not been granted the role is restricted.
    let super_admin = setup.new_super_admin_account().await?;
    let res = call_increase_2(raw_contract, &super_admin).await?;
    assert_insufficient_acl_permissions(res, method_name, allowed_roles.clone());

    // An admin for a permitted role is restricted (no grantee of role itself).
    let admin = setup.new_account_as_admin(&["ByMax2Increaser"]).await?;
    let res = call_increase_2(raw_contract, &admin).await?;
    assert_insufficient_acl_permissions(res, method_name, allowed_roles.clone());

    // Account with one of the required permissions succeeds.
    let account = setup.new_account_with_roles(&["ByMax2Increaser"]).await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_success_with(res, 2);
    let account = setup.new_account_with_roles(&["ByMax3Increaser"]).await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_success_with(res, 4);
    let account = setup
        .new_account_with_roles(&["ByMax2Increaser", "Resetter"])
        .await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_success_with(res, 6);

    // Account with both permissions succeeds.
    let account = setup
        .new_account_with_roles(&["ByMax2Increaser", "ByMax3Increaser"])
        .await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_success_with(res, 8);
    let account = setup
        .new_account_with_roles(&["ByMax2Increaser", "ByMax3Increaser", "Resetter"])
        .await?;
    let res = call_increase_2(raw_contract, &account).await?;
    assert_success_with(res, 10);

    Ok(())
}

#[tokio::test]
async fn test_acl_init_super_admin_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_init_super_admin(&account, account.id())
        .await?;
    assert_private_method_failure(res, "acl_init_super_admin");
    Ok(())
}

#[tokio::test]
async fn test_acl_get_super_admins() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    let super_admin_ids = vec![
        setup.new_super_admin_account().await?,
        setup.new_super_admin_account().await?,
        setup.new_super_admin_account().await?,
    ]
    .iter()
    .map(|account| account.id().clone())
    .collect::<Vec<_>>();

    // Behaves as expected for limit = 0.
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, 0, 0)
        .await?;
    assert_eq!(actual, vec![],);

    // Skip outside of the number of existing super-admins.
    let n = u64::try_from(super_admin_ids.len()).unwrap();
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, n, 1)
        .await?;
    assert_eq!(actual, vec![],);

    // Retrieve super-admins with step size 1.
    for i in 0..3 {
        let actual = setup
            .contract
            .acl_get_super_admins(&setup.account, i, 1)
            .await?;
        let i = usize::try_from(i).unwrap();
        let expected = super_admin_ids[i..i + 1].to_vec();
        assert_eq!(actual, expected, "Mismatch at position {}", i,);
    }

    // Retrieve super-admins with step size 2.
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, 0, 2)
        .await?;
    let expected = super_admin_ids[0..2].to_vec();
    assert_eq!(actual, expected);
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, 2, 2)
        .await?;
    let expected = vec![super_admin_ids[2].clone()];
    assert_eq!(actual, expected);

    // Retrieve all super-admins at once.
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, 0, 3)
        .await?;
    assert_eq!(actual, super_admin_ids);

    // Limit larger than the number of existing super-admins.
    let actual = setup
        .contract
        .acl_get_super_admins(&setup.account, 0, 4)
        .await?;
    assert_eq!(actual, super_admin_ids);

    Ok(())
}

#[tokio::test]
async fn test_acl_get_admins() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "ByMax3Increaser";

    let admin_ids = vec![
        setup.new_account_as_admin(&[role]).await?,
        setup.new_account_as_admin(&[role]).await?,
        setup.new_account_as_admin(&[role]).await?,
    ]
    .iter()
    .map(|account| account.id().clone())
    .collect::<Vec<_>>();

    // Behaves as expected for limit = 0.
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, 0, 0)
        .await?;
    assert_eq!(actual, vec![],);

    // Skip outside of the number of existing admins.
    let n = u64::try_from(admin_ids.len()).unwrap();
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, n, 1)
        .await?;
    assert_eq!(actual, vec![],);

    // Retrieve admins with step size 1.
    for i in 0..3 {
        let actual = setup
            .contract
            .acl_get_admins(&setup.account, role, i, 1)
            .await?;
        let i = usize::try_from(i).unwrap();
        let expected = admin_ids[i..i + 1].to_vec();
        assert_eq!(actual, expected, "Mismatch at position {}", i,);
    }

    // Retrieve admins with step size 2.
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, 0, 2)
        .await?;
    let expected = admin_ids[0..2].to_vec();
    assert_eq!(actual, expected);
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, 2, 2)
        .await?;
    let expected = vec![admin_ids[2].clone()];
    assert_eq!(actual, expected);

    // Retrieve all admins at once.
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, 0, 3)
        .await?;
    assert_eq!(actual, admin_ids);

    // Limit larger than the number of existing admins.
    let actual = setup
        .contract
        .acl_get_admins(&setup.account, role, 0, 4)
        .await?;
    assert_eq!(actual, admin_ids);

    Ok(())
}

#[tokio::test]
async fn test_acl_get_grantees() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let role = "ByMax2Increaser";

    let grantee_ids = vec![
        setup.new_account_with_roles(&[role]).await?,
        setup.new_account_with_roles(&[role]).await?,
        setup.new_account_with_roles(&[role]).await?,
    ]
    .iter()
    .map(|account| account.id().clone())
    .collect::<Vec<_>>();

    // Behaves as expected for limit = 0.
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, 0, 0)
        .await?;
    assert_eq!(actual, vec![],);

    // Skip outside of the number of existing grantees.
    let n = u64::try_from(grantee_ids.len()).unwrap();
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, n, 1)
        .await?;
    assert_eq!(actual, vec![],);

    // Retrieve grantees with step size 1.
    for i in 0..3 {
        let actual = setup
            .contract
            .acl_get_grantees(&setup.account, role, i, 1)
            .await?;
        let i = usize::try_from(i).unwrap();
        let expected = grantee_ids[i..i + 1].to_vec();
        assert_eq!(actual, expected, "Mismatch at position {}", i,);
    }

    // Retrieve grantees with step size 2.
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, 0, 2)
        .await?;
    let expected = grantee_ids[0..2].to_vec();
    assert_eq!(actual, expected);
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, 2, 2)
        .await?;
    let expected = vec![grantee_ids[2].clone()];
    assert_eq!(actual, expected);

    // Retrieve all grantees at once.
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, 0, 3)
        .await?;
    assert_eq!(actual, grantee_ids);

    // Limit larger than the number of existing grantees.
    let actual = setup
        .contract
        .acl_get_grantees(&setup.account, role, 0, 4)
        .await?;
    assert_eq!(actual, grantee_ids);

    Ok(())
}

#[tokio::test]
async fn test_acl_get_permissioned_accounts() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Verify returned `PermissionedAccounts` are empty when there are no outstanding permissions.
    let permissioned_accounts = setup
        .contract
        .acl_get_permissioned_accounts(&setup.account)
        .await?;
    let mut expected = new_permissioned_accounts();
    assert_permissioned_account_equivalence(&permissioned_accounts, &expected);

    // Add a super admin to the contract's Acl.
    let super_admin = setup.worker.dev_create_account().await?;
    let res = setup
        .contract
        .acl_init_super_admin(setup.contract_account(), super_admin.id())
        .await?;
    assert_success_with(res, true);

    // Add admins and grantees to the contract's Acl.
    let admin_0 = setup.new_account_as_admin(&[ALL_ROLES[0]]).await?;
    let admin_2 = setup.new_account_as_admin(&[ALL_ROLES[2]]).await?;
    let grantee_1_a = setup.new_account_with_roles(&[ALL_ROLES[1]]).await?;
    let grantee_1_b = setup.new_account_with_roles(&[ALL_ROLES[1]]).await?;

    // Insert ids added to contract's Acl into `expected`.
    expected
        .super_admins
        .push(as_sdk_account_id(super_admin.id()));
    expected
        .roles
        .get_mut(ALL_ROLES[0])
        .unwrap()
        .admins
        .push(as_sdk_account_id(admin_0.id()));
    expected
        .roles
        .get_mut(ALL_ROLES[1])
        .unwrap()
        .grantees
        .extend([
            as_sdk_account_id(grantee_1_a.id()),
            as_sdk_account_id(grantee_1_b.id()),
        ]);
    expected
        .roles
        .get_mut(ALL_ROLES[2])
        .unwrap()
        .admins
        .push(as_sdk_account_id(admin_2.id()));

    // Verify returned `PermissionedAccounts` when there are outstanding permissions.
    let permissioned_accounts = setup
        .contract
        .acl_get_permissioned_accounts(&setup.account)
        .await?;
    assert_permissioned_account_equivalence(&permissioned_accounts, &expected);

    Ok(())
}

#[tokio::test]
async fn test_acl_add_super_admin_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_add_super_admin_unchecked(&account, account.id())
        .await?;
    assert_private_method_failure(res, "acl_add_super_admin_unchecked");
    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_super_admin_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_revoke_super_admin_unchecked(&account, account.id())
        .await?;
    assert_private_method_failure(res, "acl_revoke_super_admin_unchecked");
    Ok(())
}

#[tokio::test]
async fn test_acl_add_admin_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_add_admin_unchecked(&account, "ByMax2Increaser", account.id())
        .await?;
    assert_private_method_failure(res, "acl_add_admin_unchecked");
    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_admin_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_revoke_admin_unchecked(&account, "ByMax2Increaser", account.id())
        .await?;
    assert_private_method_failure(res, "acl_revoke_admin_unchecked");
    Ok(())
}

#[tokio::test]
async fn test_acl_grant_role_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_grant_role_unchecked(&account, "ByMax2Increaser", account.id())
        .await?;
    assert_private_method_failure(res, "acl_grant_role_unchecked");
    Ok(())
}

#[tokio::test]
async fn test_acl_revoke_role_unchecked_is_private() -> anyhow::Result<()> {
    let Setup {
        contract, account, ..
    } = Setup::new().await?;
    let res = contract
        .acl_revoke_role_unchecked(&account, "ByMax2Increaser", account.id())
        .await?;
    assert_private_method_failure(res, "acl_revoke_role_unchecked");
    Ok(())
}

'''
'''--- near-plugins-derive/tests/common/access_controllable_contract.rs ---
use near_plugins::access_controllable::PermissionedAccounts;

use near_sdk::serde_json::json;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract};

/// Wrapper for a contract that is `#[access_controllable]`. It allows
/// implementing helpers for calling contract methods.
pub struct AccessControllableContract {
    contract: Contract,
}

impl AccessControllableContract {
    pub fn new(contract: Contract) -> Self {
        Self { contract }
    }

    pub fn contract(&self) -> &Contract {
        &self.contract
    }

    pub async fn acl_role_variants(&self, caller: &Account) -> anyhow::Result<Vec<String>> {
        let res = caller
            .call(self.contract.id(), "acl_role_variants")
            .view()
            .await?;
        Ok(res.json::<Vec<String>>()?)
    }

    pub async fn acl_is_super_admin(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "acl_is_super_admin")
            .args_json(json!({
                "account_id": account_id,
            }))
            .view()
            .await?;
        Ok(res.json::<bool>()?)
    }

    pub async fn assert_acl_is_super_admin(
        &self,
        expected: bool,
        caller: &Account,
        account_id: &AccountId,
    ) {
        let is_super_admin = self.acl_is_super_admin(caller, account_id).await.unwrap();
        assert_eq!(is_super_admin, expected);
    }

    pub async fn acl_init_super_admin(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_init_super_admin")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_add_super_admin(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_add_super_admin")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_add_super_admin_unchecked(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_add_super_admin_unchecked")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_revoke_super_admin(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_revoke_super_admin")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_transfer_super_admin(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_transfer_super_admin")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_revoke_super_admin_unchecked(
        &self,
        caller: &Account,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_revoke_super_admin_unchecked")
            .args_json(json!({
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_is_admin(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "acl_is_admin")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .view()
            .await?;
        Ok(res.json::<bool>()?)
    }

    pub async fn assert_acl_is_admin(&self, expected: bool, role: &str, account_id: &AccountId) {
        let is_admin = self
            .acl_is_admin(self.contract.as_account(), role, account_id)
            .await
            .unwrap();
        assert_eq!(is_admin, expected);
    }

    pub async fn acl_add_admin(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_add_admin")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_add_admin_unchecked(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_add_admin_unchecked")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_revoke_admin(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_revoke_admin")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_renounce_admin(&self, caller: &Account, role: &str) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "acl_renounce_admin")
            .args_json(json!({
                "role": role,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<bool>()?;
        Ok(res)
    }

    pub async fn acl_revoke_admin_unchecked(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_revoke_admin_unchecked")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_has_role(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "acl_has_role")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .view()
            .await?;
        Ok(res.json::<bool>()?)
    }

    pub async fn assert_acl_has_role(&self, expected: bool, role: &str, account_id: &AccountId) {
        let has_role = self
            .acl_has_role(self.contract.as_account(), role, account_id)
            .await
            .unwrap();
        assert_eq!(has_role, expected);
    }

    pub async fn acl_grant_role(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_grant_role")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_grant_role_unchecked(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_grant_role_unchecked")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_revoke_role(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> anyhow::Result<Option<bool>> {
        let res = caller
            .call(self.contract.id(), "acl_revoke_role")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Option<bool>>()?;
        Ok(res)
    }

    pub async fn acl_renounce_role(&self, caller: &Account, role: &str) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "acl_renounce_role")
            .args_json(json!({
                "role": role,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<bool>()?;
        Ok(res)
    }

    pub async fn acl_revoke_role_unchecked(
        &self,
        caller: &Account,
        role: &str,
        account_id: &AccountId,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "acl_revoke_role_unchecked")
            .args_json(json!({
                "role": role,
                "account_id": account_id,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn acl_get_super_admins(
        &self,
        caller: &Account,
        skip: u64,
        limit: u64,
    ) -> anyhow::Result<Vec<AccountId>> {
        let res = caller
            .call(self.contract.id(), "acl_get_super_admins")
            .args_json(json!({
                "skip": skip,
                "limit": limit,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Vec<AccountId>>()?;
        Ok(res)
    }

    pub async fn acl_get_admins(
        &self,
        caller: &Account,
        role: &str,
        skip: u64,
        limit: u64,
    ) -> anyhow::Result<Vec<AccountId>> {
        let res = caller
            .call(self.contract.id(), "acl_get_admins")
            .args_json(json!({
                "role": role,
                "skip": skip,
                "limit": limit,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Vec<AccountId>>()?;
        Ok(res)
    }

    pub async fn acl_get_grantees(
        &self,
        caller: &Account,
        role: &str,
        skip: u64,
        limit: u64,
    ) -> anyhow::Result<Vec<AccountId>> {
        let res = caller
            .call(self.contract.id(), "acl_get_grantees")
            .args_json(json!({
                "role": role,
                "skip": skip,
                "limit": limit,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?
            .json::<Vec<AccountId>>()?;
        Ok(res)
    }

    pub async fn acl_get_permissioned_accounts(
        &self,
        caller: &Account,
    ) -> anyhow::Result<PermissionedAccounts> {
        let res = caller
            .call(self.contract.id(), "acl_get_permissioned_accounts")
            .view()
            .await?;
        Ok(res.json::<PermissionedAccounts>()?)
    }
}

'''
'''--- near-plugins-derive/tests/common/key.rs ---
use workspaces::result::ExecutionFinalResult;
use workspaces::types::{AccessKeyInfo, PublicKey};
use workspaces::{Account, AccountId, Contract};

/// Creates a transaction signed by `signer` to delete `key` from `contract`.
pub async fn delete_access_key(
    signer: &Account,
    contract: &AccountId,
    key: PublicKey,
) -> workspaces::Result<ExecutionFinalResult> {
    signer.batch(contract).delete_key(key).transact().await
}

/// Panics if access key info cannot be retrieved.
pub async fn get_access_key_infos(contract: &Contract) -> Vec<AccessKeyInfo> {
    contract
        .view_access_keys()
        .await
        .expect("Should retrieve access keys")
}

'''
'''--- near-plugins-derive/tests/common/mod.rs ---
pub mod access_controllable_contract;
pub mod key;
pub mod ownable_contract;
pub mod pausable_contract;
pub mod repo;
pub mod upgradable_contract;
pub mod utils;

'''
'''--- near-plugins-derive/tests/common/ownable_contract.rs ---
use near_sdk::serde_json::json;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract};

/// Wrapper for a contract that is `#[ownable]`. It allows implementing helpers for calling contract
/// methods.
pub struct OwnableContract {
    contract: Contract,
}

impl OwnableContract {
    pub fn new(contract: Contract) -> Self {
        Self { contract }
    }

    pub fn contract(&self) -> &Contract {
        &self.contract
    }

    pub async fn owner_get(&self, caller: &Account) -> anyhow::Result<Option<AccountId>> {
        let res = caller.call(self.contract.id(), "owner_get").view().await?;
        Ok(res.json::<Option<AccountId>>()?)
    }

    pub async fn owner_set(
        &self,
        caller: &Account,
        owner: Option<AccountId>,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "owner_set")
            .args_json(json!({ "owner": owner }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn owner_is(&self, caller: &Account) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "owner_is")
            .max_gas()
            .transact()
            .await?;
        Ok(res.json::<bool>()?)
    }
}

'''
'''--- near-plugins-derive/tests/common/pausable_contract.rs ---
use near_sdk::serde_json::json;
use std::collections::HashSet;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, Contract};

/// Wrapper for a contract that is `#[pausable]`. It allows implementing helpers
/// for calling contract methods.
pub struct PausableContract {
    contract: Contract,
}

impl PausableContract {
    pub fn new(contract: Contract) -> Self {
        Self { contract }
    }

    pub fn contract(&self) -> &Contract {
        &self.contract
    }

    pub async fn pa_is_paused(&self, caller: &Account, key: &str) -> anyhow::Result<bool> {
        let res = caller
            .call(self.contract.id(), "pa_is_paused")
            .args_json(json!({
                "key": key,
            }))
            .view()
            .await?;
        Ok(res.json::<bool>()?)
    }

    pub async fn pa_pause_feature(
        &self,
        caller: &Account,
        key: &str,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "pa_pause_feature")
            .args_json(json!({ "key": key }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn pa_unpause_feature(
        &self,
        caller: &Account,
        key: &str,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "pa_unpause_feature")
            .args_json(json!({ "key": key }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn pa_all_paused(&self, caller: &Account) -> anyhow::Result<Option<HashSet<String>>> {
        let res = caller
            .call(self.contract.id(), "pa_all_paused")
            .view()
            .await?;
        Ok(res.json::<Option<HashSet<String>>>()?)
    }
}

'''
'''--- near-plugins-derive/tests/common/repo.rs ---
use std::path::{Path, PathBuf};
use std::process::Output;

async fn read_toolchain(project_path: &Path) -> anyhow::Result<String> {
    let bytes = tokio::fs::read(project_path.join("rust-toolchain")).await?;
    let value: toml::Value = toml::from_slice(&bytes)?;
    let result = value
        .as_table()
        .and_then(|t| t.get("toolchain"))
        .and_then(|v| v.as_table())
        .and_then(|t| t.get("channel"))
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow::Error::msg("Failed to parse rust-toolchain toml"))?
        .to_string();
    Ok(result)
}

pub fn require_success(output: Output) -> Result<(), anyhow::Error> {
    if output.status.success() {
        Ok(())
    } else {
        Err(anyhow::Error::msg(format!("Command failed: {:?}", output)))
    }
}

async fn add_wasm_target(project_path: &Path, toolchain: &str) -> anyhow::Result<()> {
    let output = tokio::process::Command::new("rustup")
        .env("RUSTUP_TOOLCHAIN", toolchain)
        .current_dir(project_path)
        .args(["target", "add", "wasm32-unknown-unknown"])
        .output()
        .await?;
    require_success(output)?;
    Ok(())
}

pub async fn compile_project(project_path: &Path, package_name: &str) -> anyhow::Result<Vec<u8>> {
    let toolchain = read_toolchain(project_path).await?;
    add_wasm_target(project_path, &toolchain).await?;
    let output = tokio::process::Command::new("cargo")
        .env("RUSTUP_TOOLCHAIN", &toolchain)
        .current_dir(project_path)
        .args([
            "build",
            "--target",
            "wasm32-unknown-unknown",
            "--release",
            "--no-default-features",
            "-p",
            package_name,
        ])
        .output()
        .await?;

    require_success(output)?;
    let binary_path = project_path.join(
        [
            "target",
            "wasm32-unknown-unknown",
            "release",
            format!("{}.wasm", package_name).as_str(),
        ]
        .iter()
        .collect::<PathBuf>(),
    );
    Ok(tokio::fs::read(binary_path).await?)
}

'''
'''--- near-plugins-derive/tests/common/upgradable_contract.rs ---
use near_plugins::upgradable::{FunctionCallArgs, UpgradableDurationStatus};

use near_sdk::serde_json::json;
use near_sdk::CryptoHash;
use near_sdk::Duration;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, Contract};

/// Wrapper for a contract that derives `Upgradable`. It allows implementing helpers for calling
/// contract methods provided by `Upgradable`.
pub struct UpgradableContract {
    contract: Contract,
}

impl UpgradableContract {
    pub fn new(contract: Contract) -> Self {
        Self { contract }
    }

    pub fn contract(&self) -> &Contract {
        &self.contract
    }

    pub async fn up_get_delay_status(
        &self,
        caller: &Account,
    ) -> anyhow::Result<UpgradableDurationStatus> {
        let res = caller
            .call(self.contract.id(), "up_get_delay_status")
            .view()
            .await?;
        Ok(res.json::<UpgradableDurationStatus>()?)
    }

    pub async fn up_stage_code(
        &self,
        caller: &Account,
        code: Vec<u8>,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "up_stage_code")
            .args_borsh(code)
            .max_gas()
            .transact()
            .await
    }

    pub async fn up_staged_code(&self, caller: &Account) -> anyhow::Result<Option<Vec<u8>>> {
        let res = caller
            .call(self.contract.id(), "up_staged_code")
            .max_gas()
            .transact()
            .await?;
        Ok(res.borsh::<Option<Vec<u8>>>()?)
    }

    pub async fn up_staged_code_hash(
        &self,
        caller: &Account,
    ) -> anyhow::Result<Option<CryptoHash>> {
        let res = caller
            .call(self.contract.id(), "up_staged_code_hash")
            .max_gas()
            .transact()
            .await?;
        Ok(res.json::<Option<CryptoHash>>()?)
    }

    /// The `Promise` returned by trait method `up_deploy_code` is resolved in the `workspaces`
    /// transaction.
    pub async fn up_deploy_code(
        &self,
        caller: &Account,
        function_call_args: Option<FunctionCallArgs>,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "up_deploy_code")
            .args_json(json!({
                "function_call_args": function_call_args,
            }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn up_init_staging_duration(
        &self,
        caller: &Account,
        staging_duration: Duration,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "up_init_staging_duration")
            .args_json(json!({ "staging_duration": staging_duration }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn up_stage_update_staging_duration(
        &self,
        caller: &Account,
        staging_duration: Duration,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "up_stage_update_staging_duration")
            .args_json(json!({ "staging_duration": staging_duration }))
            .max_gas()
            .transact()
            .await
    }

    pub async fn up_apply_update_staging_duration(
        &self,
        caller: &Account,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), "up_apply_update_staging_duration")
            .max_gas()
            .transact()
            .await
    }
}

'''
'''--- near-plugins-derive/tests/common/utils.rs ---
use near_sdk::serde::de::DeserializeOwned;
use near_sdk::Duration;
use std::cmp::PartialEq;
use std::fmt::Debug;
use std::str::FromStr;
use workspaces::network::Sandbox;
use workspaces::result::{ExecutionFinalResult, ExecutionOutcome};
use workspaces::{AccountId, Block, Worker};

/// Converts `account_id` to a `near_sdk::AccountId` and panics on failure.
///
/// Only available in tests, hence favoring simplicity over efficiency.
pub fn as_sdk_account_id(account_id: &AccountId) -> near_sdk::AccountId {
    near_sdk::AccountId::from_str(account_id.as_str())
        .expect("Conversion to near_sdk::AccountId should succeed")
}

/// Convenience function to create a new `near_sdk::Duration`. Panics if the conversion fails.
pub fn sdk_duration_from_secs(seconds: u64) -> Duration {
    std::time::Duration::from_secs(seconds)
        .as_nanos()
        .try_into()
        .expect("Conversion from std Duration to near_sdk Duration should succeed")
}

/// Asserts execution was successful and returned `()`.
pub fn assert_success_with_unit_return(res: ExecutionFinalResult) {
    match res.into_result() {
        Ok(res) => {
            assert!(
                res.raw_bytes().unwrap().is_empty(),
                "Unexpected return value"
            );
        }
        Err(err) => panic!("Transaction should have succeeded but failed with: {err}"),
    }
}

/// Asserts execution was successful and returned the `expected` value.
pub fn assert_success_with<T>(res: ExecutionFinalResult, expected: T)
where
    T: DeserializeOwned + PartialEq + Debug,
{
    let actual = res
        .into_result()
        .expect("Transaction should have succeeded")
        .json::<T>()
        .expect("Return value should be deserializable");
    assert_eq!(actual, expected);
}

/// Asserts transaction failure due `MethodNotFound` error.
pub fn assert_method_not_found_failure(res: ExecutionFinalResult) {
    assert_failure_with(res, "Action #0: MethodResolveError(MethodNotFound)");
}

/// Asserts transaction failure due to `method` being `#[private]`.
pub fn assert_private_method_failure(res: ExecutionFinalResult, method: &str) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    let must_contain = format!("Method {} is private", method);
    assert!(
        err.contains(&must_contain),
        "'{}' is not contained in '{}'",
        must_contain,
        err,
    );
}

/// Asserts transaction failure due to insufficient `AccessControllable` (ACL)
/// permissions.
pub fn assert_insufficient_acl_permissions(
    res: ExecutionFinalResult,
    method: &str,
    _allowed_roles: Vec<String>,
) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);

    // TODO fix escaping issue to also verify second sentence of the error
    // Using `format!` here it'll be: Requires one of these roles: ["LevelA", "LevelB"]
    // However, roles contained in `err` are escaped, i.e. [\"LevelA\", \"LevelB\"]
    let must_contain = format!(
        "Insufficient permissions for method {} restricted by access control.",
        method,
    );

    assert!(
        err.contains(&must_contain),
        "'{}' is not contained in '{}'",
        must_contain,
        err,
    );
}

pub fn assert_method_is_paused(res: ExecutionFinalResult) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    let must_contain = "Pausable: Method is paused";
    assert!(
        err.contains(must_contain),
        "Expected method to be paused, instead it failed with: {}",
        err
    );
}

pub fn assert_pausable_escape_hatch_is_closed(res: ExecutionFinalResult, feature: &str) {
    let must_contain = format!("Pausable: {feature} must be paused to use this function");
    assert_failure_with(res, &must_contain);
}

pub fn assert_owner_update_failure(res: ExecutionFinalResult) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    let must_contain = "Ownable: Only owner can update current owner";
    assert!(
        err.contains(must_contain),
        "Expected failure due to caller not being owner, instead it failed with: {}",
        err
    );
}

/// Assert failure due to calling a method protected by `#[only]` without required permissions.
pub fn assert_ownable_permission_failure(res: ExecutionFinalResult) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    let must_contain = "Method is private";
    assert!(
        err.contains(must_contain),
        "Expected failure due to insufficient permissions, instead it failed with: {}",
        err
    );
}

/// Assert failure due to calling a method protected by `#[only(owner)]` from an account other than the
/// owner.
pub fn assert_only_owner_permission_failure(res: ExecutionFinalResult) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    let must_contain = "Ownable: Method must be called from owner";
    assert!(
        err.contains(must_contain),
        "Expected failure due to caller not being owner, instead it failed with: {}",
        err
    );
}

/// Asserts the execution of `res` failed and the error contains `must_contain`.
pub fn assert_failure_with(res: ExecutionFinalResult, must_contain: &str) {
    let err = res
        .into_result()
        .expect_err("Transaction should have failed");
    let err = format!("{}", err);
    assert!(
        err.contains(must_contain),
        "The expected message\n'{}'\nis not contained in error\n'{}'",
        must_contain,
        err,
    );
}

pub fn assert_access_key_not_found_error(
    res: workspaces::Result<ExecutionFinalResult, workspaces::error::Error>,
) {
    let err = res.expect_err("Transaction should not have been executed");

    // Debug formatting is required to get the full error message containing `AccessKeyNotFound`.
    // Assume that is acceptable since this function is avaible only in tests.
    let err = format!("{:?}", err);
    let must_contain = "InvalidAccessKeyError";

    assert!(
        err.contains(must_contain),
        "The expected message\n'{}'\nis not contained in error\n'{}'",
        must_contain,
        err,
    );
}

/// Returns the block timestamp in nanoseconds. Panics on failure.
async fn block_timestamp(worker: &Worker<Sandbox>) -> u64 {
    worker
        .view_block()
        .await
        .expect("Should view block")
        .timestamp()
}

/// Returns the block in which a transaction or receipt was included.
pub async fn get_transaction_block(
    worker: &Worker<Sandbox>,
    result: &ExecutionOutcome,
) -> workspaces::Result<Block> {
    let block_hash = result.block_hash;
    worker.view_block().block_hash(block_hash).await
}

/// [Time travels] `worker` forward by at least `duration`. This is achieved by a very naive
/// approach: fast forward blocks until `duration` has passed. Keeping it simple since this function
/// is available only in tests.
///
/// Due to this approach, it is recommended to pass only relatively small values as `duration`. Fast
/// forwarding provided by this function is reasonly fast in our tests for durations that correspond
/// to less than 100 seconds.
///
/// [Time travels]: https://github.com/near/workspaces-rs#time-traveling
pub async fn fast_forward_beyond(worker: &Worker<Sandbox>, duration: Duration) {
    let initial_timestamp = block_timestamp(worker).await;

    // Estimating a number of blocks to skip based on `duration` and calling `fast_forward` only
    // once seems more efficient. However, that leads to jittery tests as `fast_forward` may _not_
    // forward the block timestamp significantly.
    while block_timestamp(worker).await - initial_timestamp < duration {
        worker
            .fast_forward(1)
            .await
            .expect("Fast forward should succeed");
    }
}

'''
'''--- near-plugins-derive/tests/contracts/README.md ---
Contains contracts that use the plugins provided by `near-plugins`.

These contracts are compiled during tests via Near's `workspaces-rs` and may serve as examples for smart contract developers.

# TODO: contract to test optional ACL arguments
- `#[access_control]` has optional arguments, e.g. `storage_prefix`.
- Add a contract which sets all those optional arguments.
- Purpose: docs/example + verify processing of the arguments

'''
'''--- near-plugins-derive/tests/contracts/access_controllable/Cargo.toml ---
[package]
name = "access_controllable"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.0.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/access_controllable/src/lib.rs ---
use near_plugins::{access_control, access_control_any, AccessControlRole, AccessControllable};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault};
use std::collections::HashMap;

/// Roles are represented by enum variants.
///
/// Deriving `AccessControlRole` ensures `Role` can be used in `AccessControllable`.
#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    /// Grantees may call contract methods increasing the counter by up to _two_ at once.
    ByMax2Increaser,
    /// Grantees may call contract methods increasing the counter by up to _three_ at once.
    ByMax3Increaser,
    /// Grantees of this role may call the contract method `reset`.
    Resetter,
}

/// Pass `Role` to the `access_controllable` macro.
#[access_control(role_type(Role))]
#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    counter: u64,
}

#[near_bindgen]
impl Counter {
    /// Constructor of the contract which optionally adds access control admins and grants roles if
    /// either of the maps passed as parameters contains account ids. In that case, the contract
    /// itself is made super admin, which permits it to add admins and grantees for every role.
    ///
    /// Both `admins` and `grantees` map the string representation of a role to an account id. With
    /// standard `serde` deserialization, the string representation of a role corresponds to the
    /// identifier of the enum variant, i.e. `"Updater"` for `Role::Updater`.
    #[init]
    pub fn new(admins: HashMap<String, AccountId>, grantees: HashMap<String, AccountId>) -> Self {
        let mut contract = Self { counter: 0 };

        if admins.len() > 0 || grantees.len() > 0 {
            // First we make the contract itself super admin to allow it adding admin and grantees.
            // That can be done via trait method `AccessControllable::acl_init_super_admin`, which is
            // automatically implemented and exported for the contract by `#[access_controllable]`.
            near_sdk::require!(
                contract.acl_init_super_admin(env::current_account_id()),
                "Failed to initialize super admin",
            );

            // Add admins.
            for (role, account_id) in admins.into_iter() {
                let result = contract.acl_add_admin(role, account_id);
                near_sdk::require!(Some(true) == result, "Failed to add admin");
            }

            // Grant roles.
            for (role, account_id) in grantees.into_iter() {
                let result = contract.acl_grant_role(role, account_id);
                near_sdk::require!(Some(true) == result, "Failed to grant role");
            }

            // Using internal `*_unchecked` methods is another option for adding (super) admins and
            // granting roles, for example:
            //
            // ```
            // contract.acl_get_or_init().add_admin_unchecked(role, account_id);
            // contract.acl_get_or_init().grant_role_unchecked(role, account_id);
            // ```
            //
            // **Attention**: for security reasons, `acl_get_or_init().*_unchecked` methods should only be called
            // from within methods with attribute `#[init]` or `#[private]`.
        }

        contract
    }

    /// Returns the current value of the counter.
    ///
    /// This method has no access control. Anyone can call it successfully.
    pub fn get_counter(&self) -> u64 {
        self.counter
    }

    /// Increases the counter by one and returns its new value.
    ///
    /// This method has no access control. Anyone can call it successfully.
    pub fn increase(&mut self) -> u64 {
        self.counter += 1;
        self.counter
    }

    /// Increases the counter by two and returns its new value.
    ///
    /// This method shows how to pass multiple `Role` variants to the `roles` attribute of
    /// `access_control_any`. It lets any account which was granted at least one of the specified
    /// roles call the method successfully. If the caller was not granted any of these roles, the
    /// method panics.
    #[access_control_any(roles(Role::ByMax2Increaser, Role::ByMax3Increaser))]
    pub fn increase_2(&mut self) -> u64 {
        self.counter += 2;
        self.counter
    }

    /// Increases the counter by three and returns its new value.
    ///
    /// Only an account that was granted `Role::ByMax3Increaser` may successfully call this method.
    #[access_control_any(roles(Role::ByMax3Increaser))]
    pub fn increase_3(&mut self) -> u64 {
        self.counter += 3;
        self.counter
    }

    /// Resets the counters value to zero.
    ///
    /// Only an account that was granted `Role:Resetter` may successfully call this method.
    #[access_control_any(roles(Role::Resetter))]
    pub fn reset(&mut self) {
        self.counter = 0;
    }

    /// The implementation of `AccessControllable` provided by `near-plugins`
    /// adds further methods to the contract which are not part of the trait.
    /// Most of them are implemented for the type that holds the plugin's state,
    /// which can be accessed with `self.acl_get_or_init()`.
    ///
    /// This function shows how these methods can be exposed on the contract.
    /// Usually this should involve security checks, for example requiring the
    /// caller to be a super admin.
    pub fn add_super_admin(&mut self, account_id: AccountId) -> bool {
        near_sdk::require!(
            self.acl_is_super_admin(env::predecessor_account_id()),
            "Only super admins are allowed to add other super admins."
        );
        self.acl_get_or_init().add_super_admin_unchecked(&account_id)
    }
}

/// Exposing internal methods to facilitate integration testing.
#[near_bindgen]
impl Counter {
    #[private]
    pub fn acl_add_super_admin_unchecked(&mut self, account_id: AccountId) -> bool {
        self.acl_get_or_init().add_super_admin_unchecked(&account_id)
    }

    #[private]
    pub fn acl_revoke_super_admin_unchecked(&mut self, account_id: AccountId) -> bool {
        self.acl_get_or_init().revoke_super_admin_unchecked(&account_id)
    }

    #[private]
    pub fn acl_revoke_role_unchecked(&mut self, role: Role, account_id: AccountId) -> bool {
        self.acl_get_or_init()
            .revoke_role_unchecked(role.into(), &account_id)
    }

    #[private]
    pub fn acl_add_admin_unchecked(&mut self, role: Role, account_id: AccountId) -> bool {
        self.acl_get_or_init().add_admin_unchecked(role, &account_id)
    }

    #[private]
    pub fn acl_revoke_admin_unchecked(&mut self, role: Role, account_id: AccountId) -> bool {
        self.acl_get_or_init().revoke_admin_unchecked(role, &account_id)
    }

    #[private]
    pub fn acl_grant_role_unchecked(&mut self, role: Role, account_id: AccountId) -> bool {
        self.acl_get_or_init().grant_role_unchecked(role, &account_id)
    }
}

'''
'''--- near-plugins-derive/tests/contracts/ownable/Cargo.toml ---
[package]
name = "ownable"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/ownable/src/lib.rs ---
use near_plugins::{only, Ownable};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, AccountId, PanicOnDefault};

#[near_bindgen]
#[derive(Ownable, PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    counter: u64,
}

#[near_bindgen]
impl Counter {
    /// Optionally set the owner in the constructor.
    #[init]
    pub fn new(owner: Option<AccountId>) -> Self {
        let mut contract = Self { counter: 0 };
        if owner.is_some() {
            contract.owner_set(owner);
        }
        contract
    }

    /// Returns the value of the counter.
    pub fn get_counter(&self) -> u64 {
        self.counter
    }

    /// Anyone may call this method successfully.
    pub fn increase(&mut self) -> u64 {
        self.counter += 1;
        self.counter
    }

    /// _Only_ the owner or the contract itself may call this method successfully. It panics if
    /// anyone else calls it.
    #[only(self, owner)]
    pub fn increase_2(&mut self) -> u64 {
        self.counter += 2;
        self.counter
    }

    /// _Only_ the owner may call this method successfully. It panics if anyone else calls it.
    #[only(owner)]
    pub fn increase_3(&mut self) -> u64 {
        self.counter += 3;
        self.counter
    }

    /// _Only_ the contract itself may call this method successfully. It panics if anyone else calls
    /// it.
    ///
    /// It is possible to use `#[only(self)]` even if the contract does not derive `Ownable`.
    #[only(self)]
    pub fn increase_4(&mut self) -> u64 {
        self.counter += 4;
        self.counter
    }
}

'''
'''--- near-plugins-derive/tests/contracts/pausable/Cargo.toml ---
[package]
name = "pausable"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/pausable/src/lib.rs ---
use near_plugins::{
    access_control, if_paused, pause, AccessControlRole, AccessControllable, Pausable,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault};

/// Define roles for access control of `Pausable` features. Accounts which are
/// granted a role are authorized to execute the corresponding action.
#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    /// May pause and unpause features.
    PauseManager,
    /// May call `increase_4` even when it is paused.
    Unrestricted4Increaser,
    /// May call `decrease_4` even when `increase_4` is not paused.
    Unrestricted4Decreaser,
    /// May always call both `increase_4` and `decrease_4`.
    Unrestricted4Modifier,
}

#[access_control(role_type(Role))]
#[near_bindgen]
#[derive(Pausable, PanicOnDefault, BorshDeserialize, BorshSerialize)]
#[pausable(manager_roles(Role::PauseManager))]
pub struct Counter {
    counter: u64,
}

#[near_bindgen]
impl Counter {
    /// Permissons for `AccessControllable` can be initialized in the constructor. Here we are:
    ///
    /// * Making the contract itself super admin.
    /// * Granting `Role::PauseManager` to the account id `pause_manager`.
    ///
    /// For a general overview of access control, please refer to the `AccessControllable` plugin.
    #[init]
    pub fn new(pause_manager: AccountId) -> Self {
        let mut contract = Self {
            counter: 0,
        };

        // Make the contract itself super admin. This allows us to grant any role in the
        // constructor.
        near_sdk::require!(
            contract.acl_init_super_admin(env::current_account_id()),
            "Failed to initialize super admin",
        );

        // Grant `Role::PauseManager` to the provided account.
        let result = contract.acl_grant_role(Role::PauseManager.into(), pause_manager);
        near_sdk::require!(Some(true) == result, "Failed to grant role");

        contract
    }

    /// Returns the value of the counter.
    pub fn get_counter(&self) -> u64 {
        self.counter
    }

    /// Function can be paused using feature name "increase_1" or "ALL" like:
    /// `contract.pa_pause_feature("increase_1")` or `contract.pa_pause_feature("ALL")`
    ///
    /// If the function is paused, all calls to it will fail. Even calls initiated by accounts which
    /// are access control super admin or role grantee.
    #[pause]
    pub fn increase_1(&mut self) {
        self.counter += 1;
    }

    /// Similar to `#[pause]` but use an explicit name for the feature. In this case the feature to
    /// be paused is named "Increase by two". Note that trying to pause it using "increase_2" will
    /// not have any effect.
    ///
    /// This can be used to pause a subset of the methods at once without requiring to use "ALL".
    #[pause(name = "Increase by two")]
    pub fn increase_2(&mut self) {
        self.counter += 2;
    }

    /// Similar to `#[pause]` but roles passed as argument may still successfully call this method
    /// even when the corresponding feature is paused.
    #[pause(except(roles(Role::Unrestricted4Increaser, Role::Unrestricted4Modifier)))]
    pub fn increase_4(&mut self) {
        self.counter += 4;
    }

    /// This method can only be called when "increase_1" is paused. Use this macro to create escape
    /// hatches when some features are paused. Note that if "ALL" is specified the "increase_1" is
    /// considered to be paused.
    #[if_paused(name = "increase_1")]
    pub fn decrease_1(&mut self) {
        self.counter -= 1;
    }

    /// Similar to `#[if_paused]` but roles passed as argument may successfully call the method even
    /// when the feature is _not_ paused.
    #[if_paused(name = "increase_4", except(roles(Role::Unrestricted4Decreaser)))]
    pub fn decrease_4(&mut self) {
        self.counter -= 4;
    }

    /// Custom use of pause features. Only allow increasing the counter using `careful_increase` if
    /// it is below 3.
    pub fn careful_increase(&mut self) {
        if self.counter >= 3 {
            assert!(
                !self.pa_is_paused("increase_big".to_string()),
                "Method paused for large values of counter"
            );
        }

        self.counter += 1;
    }
}

'''
'''--- near-plugins-derive/tests/contracts/upgradable/Cargo.toml ---
[package]
name = "upgradable"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/upgradable/src/lib.rs ---
use near_plugins::{access_control, AccessControlRole, AccessControllable, Upgradable};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId, Duration, PanicOnDefault};

/// Defines roles for access control of protected methods provided by the `Upgradable` plugin.
#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    /// May successfully call any of the protected `Upgradable` methods since below it is passed to
    /// every attribute of `access_control_roles`.
    ///
    /// Using this pattern grantees of a single role are authorized to call all `Upgradable`methods.
    DAO,
    /// May successfully call `Upgradable::up_stage_code`, but none of the other protected methods,
    /// since below is passed only to the `code_stagers` attribute.
    ///
    /// Using this pattern grantees of a role are authorized to call only one particular protected
    /// `Upgradable` method.
    CodeStager,
    /// May successfully call `Upgradable::up_deploy_code`, but none of the other protected methods,
    /// since below is passed only to the `code_deployers` attribute.
    ///
    /// Using this pattern grantees of a role are authorized to call only one particular protected
    /// `Upgradable` method.
    CodeDeployer,
    /// May successfully call `Upgradable` methods to initialize and update the staging duration
    /// since below it is passed to the attributes `duration_initializers`,
    /// `duration_update_stagers`, and `duration_update_appliers`.
    ///
    /// Using this pattern grantees of a single role are authorized to call multiple (but not all)
    /// protected `Upgradable` methods.
    DurationManager,
}

/// Deriving `Upgradable` requires the contract to be `AccessControllable`.
///
/// Variants of `Role` are passed to `upgradables`'s `access_control_roles` attribute to specify
/// which roles are authorized to successfully call protected `Upgradable` methods. A protected
/// method panics if it is called by an account which is not a grantee of at least one of the
/// whitelisted roles.
#[access_control(role_type(Role))]
#[near_bindgen]
#[derive(Upgradable, PanicOnDefault, BorshDeserialize, BorshSerialize)]
#[upgradable(access_control_roles(
    code_stagers(Role::CodeStager, Role::DAO),
    code_deployers(Role::CodeDeployer, Role::DAO),
    duration_initializers(Role::DurationManager, Role::DAO),
    duration_update_stagers(Role::DurationManager, Role::DAO),
    duration_update_appliers(Role::DurationManager, Role::DAO),
))]
pub struct Contract;

#[near_bindgen]
impl Contract {
    /// Makes the contract itself `AccessControllable` super admin to allow it granting and revoking
    /// permissions. If parameter `dao` is `Some(account_id)`, then `account_id` is granted
    /// `Role::DAO`. After initialization permissions can be managed using the methods provided by
    /// `AccessControllable`.
    ///
    /// Parameter `staging_duration` allows initializing the time that is required to pass between
    /// staging and deploying code. This delay provides a safety mechanism to protect users against
    /// unfavorable or malicious code upgrades. If `staging_duration` is `None`, no staging duration
    /// will be set in the constructor. It is possible to set it later using
    /// `Upgradable::up_init_staging_duration`. If no staging duration is set, it defaults to zero,
    /// allowing immediate deployments of staged code.
    #[init]
    pub fn new(dao: Option<AccountId>, staging_duration: Option<Duration>) -> Self {
        let mut contract = Self;

        // Make the contract itself access control super admin, allowing it to grant and revoke
        // permissions.
        near_sdk::require!(
            contract.acl_init_super_admin(env::current_account_id()),
            "Failed to initialize super admin",
        );

        // Optionally grant `Role::DAO`.
        if let Some(account_id) = dao {
            let res = contract.acl_grant_role(Role::DAO.into(), account_id);
            assert_eq!(Some(true), res, "Failed to grant role");
        }

        // Optionally initialize the staging duration.
        if let Some(staging_duration) = staging_duration {
            // Temporarily grant `Role::DurationManager` to the contract to authorize it for
            // initializing the staging duration. Granting and revoking the role is possible since
            // the contract was made super admin above.
            contract.acl_grant_role(Role::DurationManager.into(), env::current_account_id());
            contract.up_init_staging_duration(staging_duration);
            contract.acl_revoke_role(Role::DurationManager.into(), env::current_account_id());
        }

        contract
    }

    /// Function to verify the contract was deployed and initialized successfully.
    pub fn is_set_up(&self) -> bool {
        true
    }
}

'''
'''--- near-plugins-derive/tests/contracts/upgradable_2/Cargo.toml ---
[package]
name = "upgradable_2"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/upgradable_2/src/lib.rs ---
//! A simple contract to be deployed via `Upgradable`.

use near_plugins::{access_control, AccessControlRole, AccessControllable, Upgradable};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, PanicOnDefault};

/// Roles correspond to those defined in the initial contract `../upgradable`, to make permissions
/// granted before the upgrade remain valid.
#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    DAO,
    CodeStager,
    CodeDeployer,
    DurationManager,
}

/// The struct is the same as in the initial contract `../upgradable`, so no [state migration] is
/// required.
///
/// [state migration]: https://docs.near.org/develop/upgrade#migrating-the-state
#[access_control(role_type(Role))]
#[near_bindgen]
#[derive(Upgradable, PanicOnDefault, BorshDeserialize, BorshSerialize)]
#[upgradable(access_control_roles(
    code_stagers(Role::CodeStager, Role::DAO),
    code_deployers(Role::CodeDeployer, Role::DAO),
    duration_initializers(Role::DurationManager, Role::DAO),
    duration_update_stagers(Role::DurationManager, Role::DAO),
    duration_update_appliers(Role::DurationManager, Role::DAO),
))]
pub struct Contract;

#[near_bindgen]
impl Contract {
    /// A method that is _not_ defined in the initial contract, so its existence proves the
    /// contract defined in this file was deployed.
    pub fn is_upgraded() -> bool {
        true
    }
}

'''
'''--- near-plugins-derive/tests/contracts/upgradable_state_migration/Cargo.toml ---
[package]
name = "upgradable_state_migration"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-plugins = { path = "../../../../near-plugins" }
near-sdk = "4.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- near-plugins-derive/tests/contracts/upgradable_state_migration/src/lib.rs ---
//! A simple contract to be deployed via `Upgradable`. It requires [state migration].
//!
//! [state migration]: https://docs.near.org/develop/upgrade#migrating-the-state

use near_plugins::{access_control, AccessControlRole, AccessControllable, Upgradable};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, PanicOnDefault};

/// Roles correspond to those defined in the initial contract `../upgradable`, to make permissions
/// granted before the upgrade remain valid.
#[derive(AccessControlRole, Deserialize, Serialize, Copy, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    DAO,
    CodeStager,
    CodeDeployer,
    DurationManager,
}

/// The struct differs from the one defined in the initial contract `../upgradable`, hence [state
/// migration] is required.
///
/// [state migration]: https://docs.near.org/develop/upgrade#migrating-the-state
#[access_control(role_type(Role))]
#[near_bindgen]
#[derive(Upgradable, PanicOnDefault, BorshDeserialize, BorshSerialize)]
#[upgradable(access_control_roles(
    code_stagers(Role::CodeStager, Role::DAO),
    code_deployers(Role::CodeDeployer, Role::DAO),
    duration_initializers(Role::DurationManager, Role::DAO),
    duration_update_stagers(Role::DurationManager, Role::DAO),
    duration_update_appliers(Role::DurationManager, Role::DAO),
))]
pub struct Contract {
    is_migrated: bool,
}

#[near_bindgen]
impl Contract {
    /// Migrates state from [`OldContract`] to [`Contract`].
    ///
    /// It follows the state migration pattern described [here].
    ///
    /// [here]: https://docs.near.org/develop/upgrade#migrating-the-state
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        // Ensure old state can be read and deserialized.
        let _: OldContract = env::state_read().expect("Should be able to load old state");

        Self { is_migrated: true }
    }

    /// A migration method that fails on purpose to test the rollback mechanism of
    /// `Upgradable::up_deploy_code`.
    #[private]
    #[init(ignore_state)]
    pub fn migrate_with_failure() -> Self {
        env::panic_str("Failing migration on purpose");
    }

    /// This method is _not_ defined in the initial contract, so calling it successfully proves the
    /// contract defined in this file was deployed and the old state was migrated.
    pub fn is_migrated(&self) -> bool {
        self.is_migrated
    }
}

/// Corresponds to the state defined in the initial `../upgradable` contract.
#[derive(BorshDeserialize)]
pub struct OldContract;

'''
'''--- near-plugins-derive/tests/ownable.rs ---
// Using `pub` to avoid invalid `dead_code` warnings, see
// https://users.rust-lang.org/t/invalid-dead-code-warning-for-submodule-in-integration-test/80259
pub mod common;

use anyhow::Ok;
use common::key::{delete_access_key, get_access_key_infos};
use common::ownable_contract::OwnableContract;
use common::utils::{
    assert_access_key_not_found_error, assert_only_owner_permission_failure,
    assert_ownable_permission_failure, assert_owner_update_failure, assert_success_with,
};
use near_sdk::serde_json::json;
use std::path::Path;
use workspaces::network::Sandbox;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract, Worker};

const PROJECT_PATH: &str = "./tests/contracts/ownable";

/// Allows spinning up a setup for testing the contract in [`PROJECT_PATH`] and bundles related
/// resources.
struct Setup {
    /// Instance of the deployed contract.
    contract: Contract,
    /// Wrapper around the deployed contract that facilitates interacting with methods provided by
    /// the `Ownable` plugin.
    ownable_contract: OwnableContract,
    /// A newly created account without any `Ownable` permissions.
    unauth_account: Account,
}

impl Setup {
    /// Deploys and initializes the contract in [`PROJECT_PATH`] and returns a new `Setup`.
    ///
    /// The `owner` parameter is passed on to the contract's constructor, allowing to optionally set
    /// the owner during initialization.
    async fn new(worker: Worker<Sandbox>, owner: Option<AccountId>) -> anyhow::Result<Self> {
        // Compile and deploy the contract.
        let wasm = common::repo::compile_project(Path::new(PROJECT_PATH), "ownable").await?;
        let contract = worker.dev_deploy(&wasm).await?;
        let ownable_contract = OwnableContract::new(contract.clone());

        // Call the contract's constructor.
        contract
            .call("new")
            .args_json(json!({
                "owner": owner,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?;

        let unauth_account = worker.dev_create_account().await?;
        Ok(Self {
            contract,
            ownable_contract,
            unauth_account,
        })
    }

    /// Calls the contract's `get_counter` method from an account without any `Ownable` permissions.
    async fn get_counter(&self) -> anyhow::Result<u64> {
        let res = self
            .unauth_account
            .call(self.contract.id(), "get_counter")
            .view()
            .await?;
        Ok(res.json::<u64>()?)
    }

    /// Calls one of the methods that increases the counter with signature:
    ///
    /// ```ignore
    /// method_name(&mut self) -> u64
    /// ```
    async fn call_counter_increaser(
        &self,
        caller: &Account,
        method_name: &str,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.contract.id(), method_name)
            .max_gas()
            .transact()
            .await
    }

    /// Asserts the contract's `owner_get` method returns the expected value.
    async fn assert_owner_is(&self, expected: Option<&AccountId>) {
        // Call from an account without any permissions since `owner_get` is unrestricted.
        let owner = self
            .ownable_contract
            .owner_get(&self.unauth_account)
            .await
            .unwrap();
        assert_eq!(owner.as_ref(), expected);
    }
}

/// Smoke test of contract setup and basic functionality.
#[tokio::test]
async fn test_setup() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    assert_eq!(setup.get_counter().await?, 0);
    let res = setup
        .call_counter_increaser(&setup.unauth_account, "increase")
        .await?;
    assert_success_with(res, 1);
    assert_eq!(setup.get_counter().await?, 1);

    Ok(())
}

#[tokio::test]
async fn test_owner_is() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    // Returns false for an account that isn't owner.
    assert!(
        !setup
            .ownable_contract
            .owner_is(&setup.unauth_account)
            .await?
    );

    // Returns true for the owner.
    assert!(setup.ownable_contract.owner_is(&owner).await?);

    Ok(())
}

#[tokio::test]
async fn test_set_owner_ok() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    setup.assert_owner_is(None).await;

    let owner_id = setup.unauth_account.id();
    setup
        .ownable_contract
        .owner_set(setup.contract.as_account(), Some(owner_id.clone()))
        .await?
        .into_result()?;
    setup.assert_owner_is(Some(owner_id)).await;

    Ok(())
}

#[tokio::test]
async fn test_set_owner_fail() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    setup.assert_owner_is(Some(owner.id())).await;
    let res = setup
        .ownable_contract
        .owner_set(
            &setup.unauth_account,
            Some(setup.unauth_account.id().clone()),
        )
        .await?;
    assert_owner_update_failure(res);

    Ok(())
}

#[tokio::test]
async fn test_remove_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    setup.assert_owner_is(Some(owner.id())).await;

    setup
        .ownable_contract
        .owner_set(&owner, None)
        .await?
        .into_result()?;
    setup.assert_owner_is(None).await;

    Ok(())
}

/// Contract itself may successfully call a method protected by `#[only(self)]`.
#[tokio::test]
async fn test_only_self_ok() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    assert_eq!(setup.get_counter().await?, 0);
    let res = setup
        .call_counter_increaser(setup.contract.as_account(), "increase_4")
        .await?;
    assert_success_with(res, 4);
    assert_eq!(setup.get_counter().await?, 4);

    Ok(())
}

/// A method protected by `#[only(self)]` fails if called from another account.
#[tokio::test]
async fn test_only_self_fail_unauth() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    let res = setup
        .call_counter_increaser(&setup.unauth_account, "increase_4")
        .await?;
    assert_ownable_permission_failure(res);

    Ok(())
}

/// A method protected by `#[only(self)]` fails if called by the owner.
#[tokio::test]
async fn test_only_self_fail_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    let res = setup.call_counter_increaser(&owner, "increase_4").await?;
    assert_ownable_permission_failure(res);

    Ok(())
}

/// Calling a method protected by `#[only(owner)]` from the owner succeeds.
#[tokio::test]
async fn test_only_owner_ok() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    assert_eq!(setup.get_counter().await?, 0);
    let res = setup.call_counter_increaser(&owner, "increase_3").await?;
    assert_success_with(res, 3);
    assert_eq!(setup.get_counter().await?, 3);

    Ok(())
}

/// A method protected by `#[only(owner)]` fails if called by the contract itself.
#[tokio::test]
async fn test_only_owner_fail_self() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    let res = setup
        .call_counter_increaser(setup.contract.as_account(), "increase_3")
        .await?;
    assert_only_owner_permission_failure(res);

    Ok(())
}

/// A method protected by `#[only(owner)]` fails if called by another account.
#[tokio::test]
async fn test_only_owner_fail() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    let res = setup
        .call_counter_increaser(&setup.unauth_account, "increase_3")
        .await?;
    assert_only_owner_permission_failure(res);

    Ok(())
}

/// Calling a method protected by `#[only(self, owner)]` succeeds if called by the contract itself
/// or by the owner.
#[tokio::test]
async fn test_only_self_owner_ok() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    assert_eq!(setup.get_counter().await?, 0);
    let res = setup
        .call_counter_increaser(setup.contract.as_account(), "increase_2")
        .await?;
    assert_success_with(res, 2);
    assert_eq!(setup.get_counter().await?, 2);

    let res = setup.call_counter_increaser(&owner, "increase_2").await?;
    assert_success_with(res, 4);
    assert_eq!(setup.get_counter().await?, 4);

    Ok(())
}

/// Calling a method protected by `#[only(self, owner)]` fails if called by another account.
#[tokio::test]
async fn test_only_self_owner_fail() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None).await?;

    let res = setup
        .call_counter_increaser(&setup.unauth_account, "increase_2")
        .await?;
    assert_ownable_permission_failure(res);

    Ok(())
}

/// Verifies that the contract cannot set a new owner after its access keys are removed.
#[tokio::test]
async fn test_removing_contract_keys_freezes_owner() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let owner = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(owner.id().clone())).await?;

    setup.assert_owner_is(Some(owner.id())).await;

    // Remove the contract's access key.
    let contract_key = setup.contract.as_account().secret_key().public_key();
    delete_access_key(
        setup.contract.as_account(),
        setup.contract.id(),
        contract_key,
    )
    .await?
    .into_result()?;

    // Assert the contract has no access keys anymore.
    let access_key_infos = get_access_key_infos(&setup.contract).await;
    assert_eq!(access_key_infos.len(), 0, "There should be no access keys");

    // Remove the current owner.
    setup
        .ownable_contract
        .owner_set(&owner, None)
        .await?
        .into_result()?;
    setup.assert_owner_is(None).await;

    // Verify setting a new owner fails since the contract has no access keys.
    let res = setup
        .ownable_contract
        .owner_set(
            setup.contract.as_account(),
            Some(setup.unauth_account.id().clone()),
        )
        .await;
    assert_access_key_not_found_error(res);
    setup.assert_owner_is(None).await;

    Ok(())
}

'''
'''--- near-plugins-derive/tests/pausable.rs ---
// Using `pub` to avoid invalid `dead_code` warnings, see
// https://users.rust-lang.org/t/invalid-dead-code-warning-for-submodule-in-integration-test/80259
pub mod common;

use common::access_controllable_contract::AccessControllableContract;
use common::pausable_contract::PausableContract;
use common::utils::{
    assert_failure_with, assert_insufficient_acl_permissions, assert_method_is_paused,
    assert_pausable_escape_hatch_is_closed, assert_success_with, assert_success_with_unit_return,
};
use near_sdk::serde_json::json;
use std::collections::HashSet;
use std::path::Path;
use workspaces::network::Sandbox;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract, Worker};

const PROJECT_PATH: &str = "./tests/contracts/pausable";

/// Bundles resources required in tests.
struct Setup {
    /// The worker interacting with the current sandbox.
    worker: Worker<Sandbox>,
    // Instance of the deployed contract.
    contract: Contract,
    /// Wrapper around the deployed contract that facilitates interacting with
    /// methods provided by the `Pausable` plugin.
    pausable_contract: PausableContract,
    /// Wrapper around the deployed contract that facilitates interacting with
    /// methods provided by the `AccessControllable` plugin.
    acl_contract: AccessControllableContract,
    /// An account with permission to pause and unpause features.
    pause_manager: Account,
    /// A newly created account without any `AccessControllable` permissions.
    unauth_account: Account,
}

impl Setup {
    /// Deploys the contract in [`PROJECT_PATH`] and initializes `Setup`.
    async fn new() -> anyhow::Result<Self> {
        // Compile and deploy the contract.
        let worker = workspaces::sandbox().await?;
        let wasm = common::repo::compile_project(Path::new(PROJECT_PATH), "pausable").await?;
        let contract = worker.dev_deploy(&wasm).await?;
        let pausable_contract = PausableContract::new(contract.clone());
        let acl_contract = AccessControllableContract::new(contract.clone());

        // Call the contract's constructor.
        let pause_manager = worker.dev_create_account().await?;
        contract
            .call("new")
            .args_json(json!({
                "pause_manager": pause_manager.id(),
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?;

        let unauth_account = worker.dev_create_account().await?;
        Ok(Self {
            worker,
            contract,
            pausable_contract,
            acl_contract,
            pause_manager,
            unauth_account,
        })
    }

    /// Grants `role` to `account_id`. Panics if the role is not successfully granted.
    async fn must_grant_acl_role(&self, role: &str, account_id: &AccountId) {
        // The contract itself is made super admin in the constructor, hence this should succeed.
        let result = self
            .acl_contract
            .acl_grant_role(self.contract.as_account(), role, account_id)
            .await
            .unwrap();
        assert_eq!(result, Some(true));
    }

    /// Calls `get_counter` from an account without acl permissions. This method isn't restricted by
    /// acl and cannot be paused.
    async fn get_counter(&self) -> anyhow::Result<u64> {
        let res = self
            .unauth_account
            .call(self.pausable_contract.contract().id(), "get_counter")
            .view()
            .await?;
        Ok(res.json::<u64>()?)
    }

    /// Calls one of the methods that increases or decreases the counter with signature:
    ///
    /// ```ignore
    /// method_name(&mut self) -> ()
    /// ```
    async fn call_counter_modifier(
        &self,
        caller: &Account,
        method_name: &str,
    ) -> workspaces::Result<ExecutionFinalResult> {
        caller
            .call(self.pausable_contract.contract().id(), method_name)
            .max_gas()
            .transact()
            .await
    }
}

/// Smoke test of contract setup and basic functionality.
#[tokio::test]
async fn test_setup() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    setup
        .unauth_account
        .call(setup.pausable_contract.contract().id(), "increase_1")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    assert_eq!(setup.get_counter().await?, 1);

    Ok(())
}

#[tokio::test]
async fn test_pause_feature() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Pause a feature that is not yet paused.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_method_is_paused(res);

    // Pause a feature that is already paused.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, false);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_method_is_paused(res);

    Ok(())
}

/// A paused method cannot be called from an account with a manager role.
#[tokio::test]
async fn test_pause_feature_from_pause_manager() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.pause_manager, "increase_1")
        .await?;
    assert_method_is_paused(res);
    Ok(())
}

/// Asserts `pa_pause_feature` fails due to insufficient acl permissions when called by `caller`.
async fn assert_pause_feature_acl_failure(contract: &PausableContract, caller: &Account) {
    let result = contract
        .pa_pause_feature(caller, "increase_1")
        .await
        .unwrap();
    assert_insufficient_acl_permissions(
        result,
        "pa_pause_feature",
        vec!["PauseManager".to_string()],
    );
}

#[tokio::test]
/// Only accounts that were granted a manager role may pause features.
async fn test_pause_not_allowed_from_unauthorized_account() -> anyhow::Result<()> {
    let Setup {
        pausable_contract,
        unauth_account,
        ..
    } = Setup::new().await?;
    assert_pause_feature_acl_failure(&pausable_contract, &unauth_account).await;
    Ok(())
}

#[tokio::test]
/// If not granted a manager role, the contract itself may not pause features.
async fn test_pause_not_allowed_from_self() -> anyhow::Result<()> {
    let Setup {
        contract,
        pausable_contract,
        ..
    } = Setup::new().await?;
    assert_pause_feature_acl_failure(&pausable_contract, contract.as_account()).await;
    Ok(())
}

#[tokio::test]
async fn test_unpause_feature() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Pause a feature.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_method_is_paused(res);

    // Unpause a feature that is paused. The method it protected can then be called successfully.
    let res = setup
        .pausable_contract
        .pa_unpause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?
        .into_result()?;

    // Unpause a feature that is not paused.
    let res = setup
        .pausable_contract
        .pa_unpause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, false);
    setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?
        .into_result()?;

    Ok(())
}

/// Asserts `pa_unpause_feature` fails due to insufficient acl permissions when called by `caller`.
async fn assert_unpause_feature_acl_failure(contract: &PausableContract, caller: &Account) {
    let result = contract
        .pa_unpause_feature(caller, "increase_1")
        .await
        .unwrap();
    assert_insufficient_acl_permissions(
        result,
        "pa_unpause_feature",
        vec!["PauseManager".to_string()],
    );
}

#[tokio::test]
/// Only accounts that were granted a manager role may unpause features.
async fn test_unpause_not_allowed_from_unauthorized_account() -> anyhow::Result<()> {
    let Setup {
        pausable_contract,
        unauth_account,
        ..
    } = Setup::new().await?;
    assert_unpause_feature_acl_failure(&pausable_contract, &unauth_account).await;
    Ok(())
}

#[tokio::test]
/// If not granted a manager role, the contract itself may not unpause features.
async fn test_unpause_not_allowed_from_self() -> anyhow::Result<()> {
    let Setup {
        contract,
        pausable_contract,
        ..
    } = Setup::new().await?;
    assert_unpause_feature_acl_failure(&pausable_contract, contract.as_account()).await;
    Ok(())
}

#[tokio::test]
async fn test_pause_with_all() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "ALL")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_method_is_paused(res);
    Ok(())
}

/// Verify `except` escape hatch works when the feature is paused via `ALL`.
#[tokio::test]
async fn test_pause_with_all_allows_except() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "ALL")
        .await?;
    assert_success_with(res, true);

    let exempted_account = setup.unauth_account.clone();
    setup
        .must_grant_acl_role("Unrestricted4Increaser", exempted_account.id())
        .await;

    let res = setup
        .call_counter_modifier(&exempted_account, "increase_4")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 4);
    Ok(())
}

#[tokio::test]
async fn test_not_paused_with_different_key() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "other_feature")
        .await?;
    assert_success_with(res, true);

    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 1);

    Ok(())
}

#[tokio::test]
async fn test_work_after_unpause() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // After pausing function call fails.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_method_is_paused(res);

    // After unpausing function call succeeds.
    let res = setup
        .pausable_contract
        .pa_unpause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 1);

    Ok(())
}

async fn assert_paused_list(
    expected: Option<HashSet<String>>,
    contract: &PausableContract,
    caller: &Account,
) {
    let paused_list = contract.pa_all_paused(caller).await.unwrap();
    assert_eq!(paused_list, expected);
}

#[tokio::test]
async fn test_paused_list() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    assert_paused_list(None, &setup.pausable_contract, &setup.unauth_account).await;

    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "feature_a")
        .await?;
    assert_success_with(res, true);
    assert_paused_list(
        Some(HashSet::from(["feature_a".to_string()])),
        &setup.pausable_contract,
        &setup.unauth_account,
    )
    .await;

    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "feature_b")
        .await?;
    assert_success_with(res, true);
    assert_paused_list(
        Some(HashSet::from([
            "feature_a".to_string(),
            "feature_b".to_string(),
        ])),
        &setup.pausable_contract,
        &setup.unauth_account,
    )
    .await;

    let res = setup
        .pausable_contract
        .pa_unpause_feature(&setup.pause_manager, "feature_a")
        .await?;
    assert_success_with(res, true);
    assert_paused_list(
        Some(HashSet::from(["feature_b".to_string()])),
        &setup.pausable_contract,
        &setup.unauth_account,
    )
    .await;

    Ok(())
}

async fn assert_is_paused(expected: bool, key: &str, contract: &PausableContract, caller: Account) {
    let is_paused = contract.pa_is_paused(&caller, key).await.unwrap();
    assert_eq!(is_paused, expected);
}

#[tokio::test]
async fn test_is_paused() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    assert_is_paused(
        false,
        "feature_a",
        &setup.pausable_contract,
        setup.unauth_account.clone(),
    )
    .await;

    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "feature_a")
        .await?;
    assert_success_with(res, true);
    assert_is_paused(
        true,
        "feature_a",
        &setup.pausable_contract,
        setup.unauth_account.clone(),
    )
    .await;

    let res = setup
        .pausable_contract
        .pa_unpause_feature(&setup.pause_manager, "feature_a")
        .await?;
    assert_success_with(res, true);
    assert_is_paused(
        false,
        "feature_a",
        &setup.pausable_contract,
        setup.unauth_account.clone(),
    )
    .await;

    Ok(())
}

/// Pausing method name has no effect if the method has a custom feature name.
#[tokio::test]
async fn test_pause_custom_name_ok() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_2")
        .await?;
    assert_success_with(res, true);

    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_2")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 2);

    Ok(())
}

#[tokio::test]
async fn test_pause_custom_name_fail() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "Increase by two")
        .await?;
    assert_success_with(res, true);

    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_2")
        .await?;
    assert_method_is_paused(res);

    Ok(())
}

#[tokio::test]
async fn test_pause_except_ok() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Pause feature.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_4")
        .await?;
    assert_success_with(res, true);

    // Grantee of `Role::Unrestricted4Increaser` is exempted.
    let increaser = setup.worker.dev_create_account().await?;
    setup
        .must_grant_acl_role("Unrestricted4Increaser", increaser.id())
        .await;
    let res = setup
        .call_counter_modifier(&increaser, "increase_4")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 4);

    // Grantee of `Role::Unrestricted4Modifier` is exempted.
    let modifier = setup.worker.dev_create_account().await?;
    setup
        .must_grant_acl_role("Unrestricted4Modifier", modifier.id())
        .await;
    let res = setup.call_counter_modifier(&modifier, "increase_4").await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 8);

    Ok(())
}

/// If a paused method exempts grantees of roles via `except`, calling that method from an account
/// without an excepted role fails.
#[tokio::test]
async fn test_pause_except_fail() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Pause feature.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_4")
        .await?;
    assert_success_with(res, true);

    // Calling the method from an account which is not exempted fails.
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_4")
        .await?;
    assert_method_is_paused(res);

    Ok(())
}

#[tokio::test]
async fn test_custom_big_ok() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    for _ in 0..5 {
        let res = setup
            .call_counter_modifier(&setup.unauth_account, "careful_increase")
            .await?;
        assert_success_with_unit_return(res);
    }
    assert_eq!(setup.get_counter().await?, 5);
    Ok(())
}

#[tokio::test]
async fn test_custom_big_fail() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Pause feature.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_big")
        .await?;
    assert_success_with(res, true);

    // Counter can still be increased until threshold.
    for _ in 0..3 {
        let res = setup
            .call_counter_modifier(&setup.unauth_account, "careful_increase")
            .await?;
        assert_success_with_unit_return(res);
    }

    // After the threshold the method fails.
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "careful_increase")
        .await?;
    assert_failure_with(res, "Method paused for large values of counter");

    Ok(())
}

/// Calling the method succeeds if the corresponding feature is paused.
#[tokio::test]
async fn test_escape_hatch_ok() -> anyhow::Result<()> {
    let setup = Setup::new().await?;

    // Make counter decreasable.
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "increase_1")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 1);

    // Pause feature.
    let res = setup
        .pausable_contract
        .pa_pause_feature(&setup.pause_manager, "increase_1")
        .await?;
    assert_success_with(res, true);

    // Calling escape hatch succeeds.
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "decrease_1")
        .await?;
    assert_success_with_unit_return(res);
    assert_eq!(setup.get_counter().await?, 0);

    Ok(())
}

/// Calling the method fails if the corresponding feature is not paused.
#[tokio::test]
async fn test_escape_hatch_fail() -> anyhow::Result<()> {
    let setup = Setup::new().await?;
    let res = setup
        .call_counter_modifier(&setup.unauth_account, "decrease_1")
        .await?;
    assert_pausable_escape_hatch_is_closed(res, "increase_1");
    Ok(())
}

'''
'''--- near-plugins-derive/tests/upgradable.rs ---
// Using `pub` to avoid invalid `dead_code` warnings, see
// https://users.rust-lang.org/t/invalid-dead-code-warning-for-submodule-in-integration-test/80259
pub mod common;

use anyhow::Ok;
use common::access_controllable_contract::AccessControllableContract;
use common::upgradable_contract::UpgradableContract;
use common::utils::{
    assert_failure_with, assert_insufficient_acl_permissions, assert_method_not_found_failure,
    assert_success_with, assert_success_with_unit_return, fast_forward_beyond,
    get_transaction_block, sdk_duration_from_secs,
};
use near_plugins::upgradable::FunctionCallArgs;
use near_sdk::serde_json::json;
use near_sdk::{CryptoHash, Duration, Gas, Timestamp};
use std::path::Path;
use workspaces::network::Sandbox;
use workspaces::result::ExecutionFinalResult;
use workspaces::{Account, AccountId, Contract, Worker};

const PROJECT_PATH: &str = "./tests/contracts/upgradable";
const PROJECT_PATH_2: &str = "./tests/contracts/upgradable_2";
const PROJECT_PATH_STATE_MIGRATION: &str = "./tests/contracts/upgradable_state_migration";

const ERR_MSG_NO_STAGING_TS: &str = "Upgradable: staging timestamp isn't set";
const ERR_MSG_DEPLOY_CODE_TOO_EARLY: &str = "Upgradable: Deploy code too early: staging ends on";
const ERR_MSG_UPDATE_DURATION_TOO_EARLY: &str =
    "Upgradable: Update duration too early: staging ends on";

/// Allows spinning up a setup for testing the contract in [`PROJECT_PATH`] and bundles related
/// resources.
struct Setup {
    /// The worker interacting with the current sandbox.
    worker: Worker<Sandbox>,
    /// A deployed instance of the contract.
    contract: Contract,
    /// Wrapper around the deployed contract that facilitates interacting with methods provided by
    /// the `Upgradable` plugin.
    upgradable_contract: UpgradableContract,
    /// Wrapper around the deployed contract that facilitates interacting with methods provided by
    /// the `AccessControllable` plugin.
    acl_contract: AccessControllableContract,
    /// A newly created account without any `AccessControllable` permissions.
    unauth_account: Account,
}

impl Setup {
    /// Deploys and initializes the test contract in [`PROJECT_PATH`] and returns a new `Setup`.
    ///
    /// The `dao` and `staging_duration` parameters are passed to the contract's constructor,
    /// allowing to optionally grant the `DAO` role and initialize the staging duration.
    ///
    /// Grantees of the `DAO` role are authorized to call all protected `Upgradable` methods of the
    /// test contract, which facilitates testing.
    async fn new(
        worker: Worker<Sandbox>,
        dao: Option<AccountId>,
        staging_duration: Option<Duration>,
    ) -> anyhow::Result<Self> {
        // Compile and deploy the contract.
        let wasm = common::repo::compile_project(Path::new(PROJECT_PATH), "upgradable").await?;
        let contract = worker.dev_deploy(&wasm).await?;
        let upgradable_contract = UpgradableContract::new(contract.clone());
        let acl_contract = AccessControllableContract::new(contract.clone());

        // Call the contract's constructor.
        contract
            .call("new")
            .args_json(json!({
                "dao": dao,
                "staging_duration": staging_duration,
            }))
            .max_gas()
            .transact()
            .await?
            .into_result()?;

        let unauth_account = worker.dev_create_account().await?;
        Ok(Self {
            worker,
            contract,
            upgradable_contract,
            acl_contract,
            unauth_account,
        })
    }

    /// Computes the expected staging timestamp based on the result of a transaction that calls a
    /// function which sets the timestamp. For example a transaction which calls
    /// `Upgradable::up_stage_code`. The function call is expected to be the first action in the
    /// transaction.
    ///
    /// Panics if the block timestamp cannot be retrieved.
    async fn expected_staging_timestamp(
        &self,
        result: ExecutionFinalResult,
        delay: Duration,
    ) -> Timestamp {
        // Grab the receipt corresponding to the function call.
        let receipt = result
            .receipt_outcomes()
            .get(0)
            .expect("There should be at least one receipt outcome");
        let block_timestamp = get_transaction_block(&self.worker, receipt)
            .await
            .expect("Should retrieve the transaction's block")
            .timestamp();
        block_timestamp + delay
    }

    /// Asserts staged code equals `expected_code`.
    async fn assert_staged_code(&self, expected_code: Option<Vec<u8>>) {
        let staged = self
            .upgradable_contract
            .up_staged_code(&self.unauth_account)
            .await
            .expect("Call to up_staged_code should succeed");
        assert_eq!(staged, expected_code);
    }

    /// Asserts the staging duration of the `Upgradable` contract equals the `expected_duration`.
    async fn assert_staging_duration(&self, expected_duration: Option<Duration>) {
        let status = self
            .upgradable_contract
            .up_get_delay_status(&self.unauth_account)
            .await
            .expect("Call to up_get_delay_status should succeed");
        assert_eq!(status.staging_duration, expected_duration);
    }

    /// Asserts the staging timestamp of the `Upgradable` contract equals the `expected_timestamp`.
    async fn assert_staging_timestamp(&self, expected_timestamp: Option<Timestamp>) {
        let status = self
            .upgradable_contract
            .up_get_delay_status(&self.unauth_account)
            .await
            .expect("Call to up_get_delay_status should succeed");
        assert_eq!(status.staging_timestamp, expected_timestamp);
    }

    /// Asserts the staged new staging duration of the `Upgradable` contract equals the
    /// `expected_duration`.
    async fn assert_new_staging_duration(&self, expected_duration: Option<Duration>) {
        let status = self
            .upgradable_contract
            .up_get_delay_status(&self.unauth_account)
            .await
            .expect("Call to up_get_delay_status should succeed");
        assert_eq!(status.new_staging_duration, expected_duration);
    }

    /// Asserts the staging timestamp of the new duration of an `Upgradable` contract equals the
    /// `expected_timestamp`.
    async fn assert_new_duration_staging_timestamp(&self, expected_timestamp: Option<Timestamp>) {
        let status = self
            .upgradable_contract
            .up_get_delay_status(&self.unauth_account)
            .await
            .expect("Call to up_get_delay_status should succeed");
        assert_eq!(status.new_staging_duration_timestamp, expected_timestamp);
    }

    async fn call_is_upgraded(&self, caller: &Account) -> workspaces::Result<ExecutionFinalResult> {
        // `is_upgraded` could be called via `view`, however here it is called via `transact` so we
        // get an `ExecutionFinalResult` that can be passed to `assert_*` methods from
        // `common::utils`. It is acceptable since all we care about is whether the method exists.
        caller
            .call(self.contract.id(), "is_upgraded")
            .max_gas()
            .transact()
            .await
    }

    async fn call_is_migrated(&self, caller: &Account) -> workspaces::Result<ExecutionFinalResult> {
        // `is_migrated` could be called via `view`, however here it is called via `transact` so we
        // get an `ExecutionFinalResult` that can be passed to `assert_*` methods from
        // `common::utils`. It is acceptable since all we care about is whether the method exists
        // and can be called successfully.
        caller
            .call(self.contract.id(), "is_migrated")
            .max_gas()
            .transact()
            .await
    }

    /// Calls the contract's `is_set_up` method and asserts it returns `true`. Panics on failure.
    async fn assert_is_set_up(&self, caller: &Account) {
        let res = caller
            .call(self.contract.id(), "is_set_up")
            .view()
            .await
            .expect("Function call should succeed");
        let is_set_up = res
            .json::<bool>()
            .expect("Should be able to deserialize the result");
        assert!(is_set_up);
    }
}

/// Panics if the conversion fails.
fn convert_code_to_crypto_hash(code: &[u8]) -> CryptoHash {
    near_sdk::env::sha256(code)
        .try_into()
        .expect("Code should be converted to CryptoHash")
}

/// Smoke test of contract setup.
#[tokio::test]
async fn test_setup() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker, None, None).await?;
    setup.assert_is_set_up(&setup.unauth_account).await;

    Ok(())
}

#[tokio::test]
async fn test_stage_code_permission_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker,
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(42)),
    )
    .await?;

    // Only the roles passed as `code_stagers` to the `Upgradable` derive macro may successfully
    // call this method.
    let res = setup
        .upgradable_contract
        .up_stage_code(&setup.unauth_account, vec![])
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_stage_code",
        vec!["CodeStager".to_string(), "DAO".to_string()],
    );

    // Verify no code was staged.
    setup.assert_staged_code(None).await;

    Ok(())
}

#[tokio::test]
async fn test_stage_code_without_delay() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(dao.id().clone()), None).await?;

    // Stage code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res.clone());

    // Verify code was staged.
    let staged = setup
        .upgradable_contract
        .up_staged_code(&setup.unauth_account)
        .await?
        .expect("Code should be staged");
    assert_eq!(staged, code);

    // Verify staging timestamp. The staging duration defaults to zero if not set.
    let staging_timestamp = setup.expected_staging_timestamp(res, 0).await;
    setup
        .assert_staging_timestamp(Some(staging_timestamp))
        .await;

    Ok(())
}

#[tokio::test]
async fn test_stage_code_with_delay() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(42);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Stage code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res.clone());

    // Verify code was staged.
    let staged = setup
        .upgradable_contract
        .up_staged_code(&setup.unauth_account)
        .await?
        .expect("Code should be staged");
    assert_eq!(staged, code);

    // Verify staging timestamp.
    let staging_timestamp = setup
        .expected_staging_timestamp(res, staging_duration)
        .await;
    setup
        .assert_staging_timestamp(Some(staging_timestamp))
        .await;

    Ok(())
}

#[tokio::test]
async fn test_staging_empty_code_clears_storage() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker,
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(42)),
    )
    .await?;

    // First stage some code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Verify staging empty code removes it.
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, vec![])
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(None).await;

    // Verify the staging timestamp was removed along with the staged code.
    setup.assert_staging_timestamp(None).await;

    Ok(())
}

#[tokio::test]
async fn test_staged_code() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker,
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(42)),
    )
    .await?;

    // No code staged.
    let staged = setup
        .upgradable_contract
        .up_staged_code(&setup.unauth_account)
        .await?;
    assert_eq!(staged, None);

    // Stage code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);

    // Some code is staged.
    let staged = setup
        .upgradable_contract
        .up_staged_code(&setup.unauth_account)
        .await?
        .expect("Code should be staged");
    assert_eq!(staged, code);

    Ok(())
}

#[tokio::test]
async fn test_staged_code_hash() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker,
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(42)),
    )
    .await?;

    // No code staged.
    let staged_hash = setup
        .upgradable_contract
        .up_staged_code_hash(&setup.unauth_account)
        .await?;
    assert_eq!(staged_hash, None);

    // Stage code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);

    // Some code is staged.
    let staged_hash = setup
        .upgradable_contract
        .up_staged_code_hash(&setup.unauth_account)
        .await?
        .expect("Code should be staged");
    let code_hash = convert_code_to_crypto_hash(code.as_slice());
    assert_eq!(staged_hash, code_hash);

    Ok(())
}

#[tokio::test]
async fn test_deploy_code_without_delay() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker.clone(), Some(dao.id().clone()), None).await?;

    // Stage some code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Deploy staged code.
    let res = setup.upgradable_contract.up_deploy_code(&dao, None).await?;
    assert_success_with_unit_return(res);

    Ok(())
}

/// Verifies the upgrade was successful by calling a method that's available only on the upgraded
/// contract. Ensures the new contract can be deployed and state remains valid without
/// explicit state migration.
#[tokio::test]
async fn test_deploy_code_and_call_method() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker.clone(), Some(dao.id().clone()), None).await?;

    // Verify function `is_upgraded` is not defined in the initial contract.
    let res = setup.call_is_upgraded(&setup.unauth_account).await?;
    assert_method_not_found_failure(res);

    // Compile the other version of the contract and stage its code.
    let code = common::repo::compile_project(Path::new(PROJECT_PATH_2), "upgradable_2").await?;
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Deploy staged code.
    let res = setup.upgradable_contract.up_deploy_code(&dao, None).await?;
    assert_success_with_unit_return(res);

    // The newly deployed contract defines the function `is_upgraded`. Calling it successfully
    // verifies the staged contract is deployed and there are no issues with state migration.
    let res = setup.call_is_upgraded(&setup.unauth_account).await?;
    assert_success_with(res, true);

    Ok(())
}

/// Deploys a new version of the contract that requires state migration and verifies the migration
/// succeeded.
#[tokio::test]
async fn test_deploy_code_with_migration() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker.clone(), Some(dao.id().clone()), None).await?;

    // Verify function `is_migrated` is not defined in the initial contract.
    let res = setup.call_is_migrated(&setup.unauth_account).await?;
    assert_method_not_found_failure(res);

    // Compile the other version of the contract and stage its code.
    let code = common::repo::compile_project(
        Path::new(PROJECT_PATH_STATE_MIGRATION),
        "upgradable_state_migration",
    )
    .await?;
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Deploy staged code and call the new contract's `migrate` method.
    let function_call_args = FunctionCallArgs {
        function_name: "migrate".to_string(),
        arguments: Vec::new(),
        amount: 0,
        gas: Gas::ONE_TERA,
    };
    let res = setup
        .upgradable_contract
        .up_deploy_code(&dao, Some(function_call_args))
        .await?;
    assert_success_with_unit_return(res);

    // The newly deployed contract defines the function `is_migrated`. Calling it successfully
    // verifies the staged contract is deployed and state migration succeeded.
    let res = setup.call_is_migrated(&setup.unauth_account).await?;
    assert_success_with(res, true);

    Ok(())
}

/// Deploys a new version of the contract and, batched with the `DeployContractAction`, calls a
/// migration method that fails. Verifies the failure rolls back the deployment, i.e. the initial
/// code remains active.
#[tokio::test]
async fn test_deploy_code_with_migration_failure_rollback() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker.clone(), Some(dao.id().clone()), None).await?;

    // Compile the other version of the contract and stage its code.
    let code = common::repo::compile_project(
        Path::new(PROJECT_PATH_STATE_MIGRATION),
        "upgradable_state_migration",
    )
    .await?;
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Deploy staged code and call the new contract's `migrate_with_failure` method.
    let function_call_args = FunctionCallArgs {
        function_name: "migrate_with_failure".to_string(),
        arguments: Vec::new(),
        amount: 0,
        gas: Gas::ONE_TERA,
    };
    let res = setup
        .upgradable_contract
        .up_deploy_code(&dao, Some(function_call_args))
        .await?;
    assert_failure_with(res, "Failing migration on purpose");

    // Verify `code` wasn't deployed by calling a function that is defined only in the initial
    // contract but not in the contract contract corresponding to `code`.
    setup.assert_is_set_up(&setup.unauth_account).await;

    Ok(())
}

/// Deploys staged code in a batch transaction with two function call actions:
///
/// 1. `up_deploy_code` with a function call to a migration method that fails
/// 2. `up_stage_code` to remove staged code from storage
///
/// The pitfall is that a failure in the promise returned by 1 does _not_ make the transaction fail
/// and 2 executes anyway.
#[tokio::test]
async fn test_deploy_code_in_batch_transaction_pitfall() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker.clone(), Some(dao.id().clone()), None).await?;

    // Compile the other version of the contract and stage its code.
    let code = common::repo::compile_project(
        Path::new(PROJECT_PATH_STATE_MIGRATION),
        "upgradable_state_migration",
    )
    .await?;
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Construct the function call actions to be executed in a batch transaction.
    // Note that we are attaching a call to `migrate_with_failure`, which will fail.
    let fn_call_deploy = workspaces::operations::Function::new("up_deploy_code")
        .args_json(json!({ "function_call_args": FunctionCallArgs {
        function_name: "migrate_with_failure".to_string(),
        arguments: Vec::new(),
        amount: 0,
        gas: Gas::ONE_TERA,
    } }))
        .gas(Gas::ONE_TERA.0 * 200);
    let fn_call_remove_code = workspaces::operations::Function::new("up_stage_code")
        .args_borsh(Vec::<u8>::new())
        .gas(Gas::ONE_TERA.0 * 90);

    let res = dao
        .batch(setup.contract.id())
        .call(fn_call_deploy)
        .call(fn_call_remove_code)
        .transact()
        .await?;

    // Here is the pitfall: Despite the failure of `migrate_with_failure`, the transaction succeeds.
    // This is due to `fn_call_deploy` _successfully_ returning a promise `p`. The promise `p`
    // fails, however that does not affect the result of the transaction.
    assert_success_with_unit_return(res.clone());

    // Verify the promise resulting from `fn_call_deploy` failed. There seems to be no public API to
    // get the status of an `ExecutionOutcome`, hence `is_failure` is used in combination with debug
    // formatting. Since this is test code we can use debug formatting for this purpose.
    let fn_call_deploy_receipt = res
        .receipt_outcomes()
        .get(1)
        .expect("There should be at least two receipts");
    assert!(fn_call_deploy_receipt.is_failure());
    assert!(format!("{:?}", fn_call_deploy_receipt).contains("Failing migration on purpose"));

    // Verify `code` wasn't deployed by calling a function that is defined only in the initial
    // contract but not in the contract corresponding to `code`.
    setup.assert_is_set_up(&setup.unauth_account).await;

    // However the staged code was removed, i.e. `fn_call_remove_code` was executed anyway.
    setup.assert_staged_code(None).await;

    Ok(())
}

#[tokio::test]
async fn test_deploy_code_with_delay() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(3);
    let setup = Setup::new(
        worker.clone(),
        Some(dao.id().clone()),
        Some(staging_duration),
    )
    .await?;

    // Stage some code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Let the staging duration pass.
    fast_forward_beyond(&worker, staging_duration).await;

    // Deploy staged code.
    let res = setup.upgradable_contract.up_deploy_code(&dao, None).await?;
    assert_success_with_unit_return(res);

    Ok(())
}

#[tokio::test]
async fn test_deploy_code_with_delay_failure_too_early() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker.clone(),
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(1024)),
    )
    .await?;

    // Stage some code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Let some time pass but not enough.
    fast_forward_beyond(&worker, sdk_duration_from_secs(1)).await;

    // Verify trying to deploy staged code fails.
    let res = setup.upgradable_contract.up_deploy_code(&dao, None).await?;
    assert_failure_with(res, ERR_MSG_DEPLOY_CODE_TOO_EARLY);

    // Verify `code` wasn't deployed by calling a function that is defined only in the initial
    // contract but not in the contract contract corresponding to `code`.
    setup.assert_is_set_up(&setup.unauth_account).await;

    Ok(())
}

#[tokio::test]
async fn test_deploy_code_permission_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(dao.id().clone()), None).await?;

    // Stage some code.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&dao, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Only the roles passed as `code_deployers` to the `Upgradable` derive macro may successfully
    // call this method.
    let res = setup
        .upgradable_contract
        .up_deploy_code(&setup.unauth_account, None)
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_deploy_code",
        vec!["CodeDeployer".to_string(), "DAO".to_string()],
    );

    // Verify `code` wasn't deployed by calling a function that is defined only in the initial
    // contract but not in the contract contract corresponding to `code`.
    setup.assert_is_set_up(&setup.unauth_account).await;

    Ok(())
}

/// `up_deploy_code` fails if there's no code staged.
#[tokio::test]
async fn test_deploy_code_empty_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(
        worker,
        Some(dao.id().clone()),
        Some(sdk_duration_from_secs(42)),
    )
    .await?;

    // Verify there is no code staged.
    let staged_hash = setup
        .upgradable_contract
        .up_staged_code_hash(&setup.unauth_account)
        .await?;
    assert_eq!(staged_hash, None);

    // Verify failure of `up_deploy_code`.
    //
    // The staging timestamp is set when staging code and removed when unstaging code. So when there
    // is no code staged, there is no staging timestamp. Hence the error message regarding a missing
    // staging timestamp is expected.
    let res = setup.upgradable_contract.up_deploy_code(&dao, None).await?;
    assert_failure_with(res, ERR_MSG_NO_STAGING_TS);

    Ok(())
}

#[tokio::test]
async fn test_init_staging_duration_permission_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(dao.id().clone()), None).await?;

    // Only the roles passed as `duration_initializers` to the `Upgradable` derive macro may
    // successfully call this method.
    let res = setup
        .upgradable_contract
        .up_init_staging_duration(&setup.unauth_account, sdk_duration_from_secs(23))
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_init_staging_duration",
        vec!["DurationManager".to_string(), "DAO".to_string()],
    );

    setup.assert_staging_duration(None).await;

    Ok(())
}

#[tokio::test]
async fn test_init_staging_duration() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let setup = Setup::new(worker, Some(dao.id().clone()), None).await?;

    // Verify the contract was initialized without staging duration.
    setup.assert_staging_duration(None).await;

    // Initialize the staging duration.
    let staging_duration = sdk_duration_from_secs(42);
    let res = setup
        .upgradable_contract
        .up_init_staging_duration(&dao, staging_duration)
        .await?;
    assert_success_with_unit_return(res.clone());

    // Verify the staging duration was set.
    setup.assert_staging_duration(Some(staging_duration)).await;

    Ok(())
}

#[tokio::test]
async fn test_stage_update_staging_duration_permission_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(42);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Only the roles passed as `duration_update_stagers` to the `Upgradable` derive macro may
    // successfully call this method.
    let res = setup
        .upgradable_contract
        .up_stage_update_staging_duration(&setup.unauth_account, sdk_duration_from_secs(23))
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_stage_update_staging_duration",
        vec!["DurationManager".to_string(), "DAO".to_string()],
    );

    // Verify no duration was staged.
    setup.assert_new_staging_duration(None).await;

    Ok(())
}

#[tokio::test]
async fn test_stage_update_staging_duration() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(42);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Initially there's no new staging duration staged and no timestamp set.
    setup.assert_new_staging_duration(None).await;
    setup.assert_new_duration_staging_timestamp(None).await;

    // Stage a new duration.
    let new_staging_duration = sdk_duration_from_secs(23);
    let res = setup
        .upgradable_contract
        .up_stage_update_staging_duration(&dao, new_staging_duration)
        .await?;
    assert_success_with_unit_return(res.clone());

    // Verify the new duration was staged.
    setup
        .assert_new_staging_duration(Some(new_staging_duration))
        .await;

    // Verify timestamp for the staging duration update.
    let expected_timestamp = setup
        .expected_staging_timestamp(res, staging_duration)
        .await;
    setup
        .assert_new_duration_staging_timestamp(Some(expected_timestamp))
        .await;

    Ok(())
}

#[tokio::test]
async fn test_apply_update_staging_duration_permission_failure() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(21);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Verify the initial staging duration.
    setup.assert_staging_duration(Some(staging_duration)).await;

    // Stage a new duration.
    let new_staging_duration = sdk_duration_from_secs(23);
    let res = setup
        .upgradable_contract
        .up_stage_update_staging_duration(&dao, new_staging_duration)
        .await?;
    assert_success_with_unit_return(res.clone());

    // Let the staging duration pass.
    fast_forward_beyond(&setup.worker, staging_duration).await;

    // Only the roles passed as `duration_update_appliers` to the `Upgradable` derive macro may
    // successfully call this method.
    let res = setup
        .upgradable_contract
        .up_apply_update_staging_duration(&setup.unauth_account)
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_apply_update_staging_duration",
        vec!["DurationManager".to_string(), "DAO".to_string()],
    );

    // Verify the update was not applied.
    setup.assert_staging_duration(Some(staging_duration)).await;
    setup
        .assert_new_staging_duration(Some(new_staging_duration))
        .await;

    Ok(())
}

#[tokio::test]
async fn test_apply_update_staging_duration() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(21);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Verify the initial staging duration.
    setup.assert_staging_duration(Some(staging_duration)).await;

    // Stage a new duration.
    let new_staging_duration = sdk_duration_from_secs(12);
    let res = setup
        .upgradable_contract
        .up_stage_update_staging_duration(&dao, new_staging_duration)
        .await?;
    assert_success_with_unit_return(res.clone());

    // Let the staging duration pass.
    fast_forward_beyond(&setup.worker, staging_duration).await;

    // Apply the update and verify the new duration was set.
    let res = setup
        .upgradable_contract
        .up_apply_update_staging_duration(&dao)
        .await?;
    assert_success_with_unit_return(res);
    setup
        .assert_staging_duration(Some(new_staging_duration))
        .await;

    Ok(())
}

#[tokio::test]
async fn test_apply_update_staging_duration_failure_too_early() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let dao = worker.dev_create_account().await?;
    let staging_duration = sdk_duration_from_secs(1024);
    let setup = Setup::new(worker, Some(dao.id().clone()), Some(staging_duration)).await?;

    // Verify the initial staging duration.
    setup.assert_staging_duration(Some(staging_duration)).await;

    // Stage a new duration.
    let new_staging_duration = sdk_duration_from_secs(42);
    let res = setup
        .upgradable_contract
        .up_stage_update_staging_duration(&dao, new_staging_duration)
        .await?;
    assert_success_with_unit_return(res.clone());

    // Let some time pass but not enough.
    fast_forward_beyond(&setup.worker, sdk_duration_from_secs(1)).await;

    // Verify trying to apply the new duration fails.
    let res = setup
        .upgradable_contract
        .up_apply_update_staging_duration(&dao)
        .await?;
    assert_failure_with(res, ERR_MSG_UPDATE_DURATION_TOO_EARLY);

    Ok(())
}

/// An account that has been granted an access control role `r` may not successfully call a method
/// that whitelists only roles other than `r`.
#[tokio::test]
async fn test_acl_permission_scope() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let setup = Setup::new(worker.clone(), None, None).await?;

    // Create an account and grant it `Role::CodeStager`.
    let code_stager = worker.dev_create_account().await?;
    let granted = setup
        .acl_contract
        .acl_grant_role(setup.contract.as_account(), "CodeStager", code_stager.id())
        .await?;
    assert_eq!(Some(true), granted);

    // Stage some code. Account `code_stager` is authorized to do this.
    let code = vec![1, 2, 3];
    let res = setup
        .upgradable_contract
        .up_stage_code(&code_stager, code.clone())
        .await?;
    assert_success_with_unit_return(res);
    setup.assert_staged_code(Some(code)).await;

    // Verify `code_stager` is not authorized to deploy staged code. Only grantees of at least one
    // of the roles passed as `code_deployers` to the `Upgradable` derive macro are authorized to
    // deploy code.
    let res = setup
        .upgradable_contract
        .up_deploy_code(&setup.unauth_account, None)
        .await?;
    assert_insufficient_acl_permissions(
        res,
        "up_deploy_code",
        vec!["CodeDeployer".to_string(), "DAO".to_string()],
    );

    // Verify `code` wasn't deployed by calling a function that is defined only in the initial
    // contract but not in the contract corresponding to `code`.
    setup.assert_is_set_up(&setup.unauth_account).await;

    Ok(())
}

'''
'''--- near-plugins/Cargo.toml ---
[package]
name = "near-plugins"
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
version.workspace = true

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
bitflags.workspace = true
near-sdk.workspace = true
near-plugins-derive.workspace = true
serde.workspace = true

'''
'''--- near-plugins/README.md ---
../README.md

'''
'''--- near-plugins/src/access_control_role.rs ---
/// Represents permissions for the [`AccessControllable`](crate::AccessControllable) plugin.
pub trait AccessControlRole {
    /// Returns the names of all role variants.
    fn acl_role_variants() -> Vec<&'static str>;

    /// Returns the bitflag corresponding to the super admin permission.
    fn acl_super_admin_permission() -> u128;

    /// Returns the bitflag corresponding to the admin permission for the role.
    fn acl_admin_permission(self) -> u128;

    /// Returns the bitflag corresponding to the role's permission.
    fn acl_permission(self) -> u128;
}

'''
'''--- near-plugins/src/access_controllable.rs ---
//! # `AccessControllable`
//!
//! A trait specifying an interface to manage permissions via roles and access control lists. A
//! contract that is `AccessControllable` may restrict functions or features to accounts that have
//! been granted permissions.
//!
//! ## Roles
//!
//! Permissions are based on roles defined by smart contract developers. In the default
//! implementation provided by `near-plugins`, roles are represented by enum variants.
//!
//! # Controlling access
//!
//! Using the `#[access_control_any(roles(...))]` macro on a contract method restricts access to the
//! method to grantees of the specified `roles`. The method panics if it is called by an account
//! which is not a grantee of any of the `roles`.
//!
//! In addition, methods like `AccessControllable::has_role` can be used within other contract
//! methods to restrict access to certain features or actions.
//!
//! ## Granting and revoking permissions
//!
//! Admins can grant roles to and revoke them from accounts. Each role has its own set of admins,
//! which may contain zero or multiple admin accounts. An admin is allowed to add and remove other
//! admin accounts. Note that admin permissions differ from role permissions: an account which is
//! admin for role `r` but not a grantee of role `r` may not use methods or features restricted to
//! role `r`.
//!
//! Besides (regular) admins the `AccessControllable` trait also defines super-admins. A super-admin
//! is considered admin for every role. An `AccessControllable` contract can have zero or more
//! super-admins.
//!
//! ## Credits
//!
//! Inspired by OpenZeppelin's
//! [AccessControl](https://docs.openzeppelin.com/contracts/3.x/api/access#AccessControl) module.

use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::collections::HashMap;

/// # Representation of roles
///
/// This trait is unaware of the concrete type used to represent roles. It is
/// not possible to use a generic type `R` since `near-sdk` [does not support]
/// `impl` type parameters.
///
/// ```ignore
/// // This is not possible:
/// impl<R> AccessControllable<R> for Contract {/* ... */}
/// ```
///
/// Instead, roles are represented by `u8`, which allows contract developers to
/// define their own enum whose variants are converted to `u8`.
///
/// [does not support]: https://github.com/near/near-sdk-rs/blob/9d99077c6acfde68c06845f2a1eb2b5ed7983401/near-sdk/compilation_tests/impl_generic.stderr
pub trait AccessControllable {
    /// Returns the storage prefix for collections related to access control. By
    /// default `b"__acl"` is used.
    ///
    /// Attribute `storage_prefix` can be used to set a different prefix:
    ///
    /// ```ignore
    /// #[access_controllable(storage_prefix="CUSTOM_KEY")]
    /// struct Contract { /* ... */}
    /// ```
    fn acl_storage_prefix() -> &'static [u8];

    /// Returns the names of all variants of the enum that represents roles.
    ///
    /// In the default implementation provided by this crate, this enum is defined by contract
    /// developers using the plugin and passed as an attribute to the `access_controllable` macro.
    ///
    /// A vector containing _all_ variant names is returned since the default implementation limits
    /// the number of variants to [`near_plugins_derive::access_control_role::MAX_ROLE_VARIANTS`].
    /// This allows for a simpler user experience compared to the iterator based approach of
    /// [`Self::acl_get_admins`], for example. For custom implmentations of this it is advised to
    /// limit the number of role variants as well.
    ///
    /// Event though it might not be used, this method takes paramter `&self` to be [available in
    /// view calls].
    ///
    /// [available in view calls]: https://stackoverflow.com/q/66715815
    fn acl_role_variants(&self) -> Vec<&'static str>;

    /// Adds `account_id` as super-admin __without__ checking any permissions in
    /// case there are no super-admins. If there is already a super-admin, it
    /// has no effect. This function can be used to add a super-admin during
    /// contract initialization. Moreover, it may provide a recovery mechanism
    /// if (mistakenly) all super-admins have been removed.
    ///
    /// The return value indicates whether `account_id` was added as
    /// super-admin.
    ///
    /// It is `#[private]` in the implementation provided by this trait, i.e.
    /// only the contract itself may call this method.
    ///
    /// Despite the restrictions of this method, it is possible to add multiple
    /// super-admins using [`acl_add_super_admin`].
    ///
    /// If a super-admin is added, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"super_admin_added",
    ///    "data":{
    ///       "account":"<SUPER_ADMIN_ACCOUNT>",
    ///       "by":"<CONTRACT_ACCOUNT>"
    ///    }
    /// }
    /// ```
    fn acl_init_super_admin(&mut self, account_id: AccountId) -> bool;

    /// Adds `account_id` as super-admin provided that the predecessor has sufficient permissions,
    /// i.e. is a super-admin as defined by [`acl_is_super_admin`]. To add the first super-admin,
    /// [`acl_init_super_admin`] can be used.
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates whether `account_id`
    /// is a new super-admin. Without permissions, `None` is returned and internal state is not
    /// modified.
    ///
    /// Note that there may be multiple (or zero) super-admins.
    ///
    /// If a super-admin is added, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"super_admin_added",
    ///    "data":{
    ///       "account":"<NEW_SUPER_ADMIN>",
    ///       "by":"<SUPER_ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_add_super_admin(&mut self, account_id: AccountId) -> Option<bool>;

    /// Returns whether `account_id` is a super-admin. A super-admin has admin
    /// permissions for every role. However, a super-admin is not considered
    /// grantee of any role.
    fn acl_is_super_admin(&self, account_id: AccountId) -> bool;

    /// Revoke super-admin permissions from `account_id` provided that the
    /// predecessor has sufficient permissions, i.e. is a super-admin as defined
    /// by [`acl_is_super_admin`]. This means a super-admin may revoke
    /// super-admin permissions from any other super-admin.
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` was a super-admin. Without permissions, `None` is
    /// returned and internal state is not modified.
    ///
    /// If super-admin permissions are revoked, the following event will be
    /// emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"super_admin_revoked",
    ///    "data":{
    ///       "account":"<PREVIOUSLY_SUPER_ADMIN>",
    ///       "by":"<SUPER_ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_revoke_super_admin(&mut self, account_id: AccountId) -> Option<bool>;

    /// Transfer super-admin permissions from the predecessor to `account_id` provided that the
    /// predecessor has sufficient permissions, i.e. is a super-admin as defined
    /// by [`acl_is_super_admin`]. This function allows a super-admin to revoke the permission from
    /// themselves and add `account_id` as super-admin. While it is a helper for use cases which
    /// require this transfer, it should be noted that `AccessControllable` allows having more than
    /// one super-admin.
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` is a new super-admin. Without permissions, `None` is
    /// returned and internal state is not modified.
    ///
    /// If super-admin permissions are transferred, the following events will be
    /// emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"super_admin_revoked",
    ///    "data":{
    ///       "account":"<PREVIOUSLY_SUPER_ADMIN>",
    ///       "by":"<SUPER_ADMIN>"
    ///    }
    /// }
    /// ```
    ///     
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"super_admin_added",
    ///    "data":{
    ///       "account":"<SUPER_ADMIN_ACCOUNT>",
    ///       "by":"<CONTRACT_ACCOUNT>"
    ///    }
    /// }
    /// ```
    fn acl_transfer_super_admin(&mut self, account_id: AccountId) -> Option<bool>;

    /// Makes `account_id` an admin provided that the predecessor has sufficient
    /// permissions, i.e. is an admin as defined by [`acl_is_admin`].
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` is a new admin for `role`. Without permissions,
    /// `None` is returned and internal state is not modified.
    ///
    /// Note that any role may have multiple (or zero) admins.
    ///
    /// If an admin is added, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"admin_added",
    ///    "data": {
    ///       "role":"<ROLE>",
    ///       "account":"<NEW_ADMIN>",
    ///       "by":"<ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_add_admin(&mut self, role: String, account_id: AccountId) -> Option<bool>;

    /// Returns whether `account_id` is an admin for `role`. Super-admins are
    /// admins for _every_ role.
    ///
    /// Note that adding an account as admin for `role` does not make that
    /// account a grantee of `role`. Instead, `role` has to be granted
    /// explicitly. The same applies to super-admins.
    fn acl_is_admin(&self, role: String, account_id: AccountId) -> bool;

    /// Revokes admin permissions for `role` from `account_id` provided that the
    /// predecessor has sufficient permissions, i.e. is an admin as defined by
    /// [`acl_is_admin`]. This means an admin for `role` may revoke admin
    /// permissions from any other account that is admin for `role`.
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` was an admin for `role`. Without permissions,
    /// `None` is returned and internal state is not modified.
    ///
    /// If an admin is revoked, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"admin_revoked",
    ///    "data":{
    ///       "role":"<ROLE>",
    ///       "account":"<PREVIOUSLY_ADMIN>",
    ///       "by":"<ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_revoke_admin(&mut self, role: String, account_id: AccountId) -> Option<bool>;

    /// Revokes admin permissions for `role` from the predecessor. Returns
    /// whether the predecessor was an admin for `role`.
    ///
    /// If an admin is revoked, the event described in
    /// [`Self::acl_revoke_admin`] will be emitted.
    fn acl_renounce_admin(&mut self, role: String) -> bool;

    /// Grants `role` to `account_id` provided that the predecessor has
    /// sufficient permissions, i.e. is an admin as defined by [`acl_is_admin`].
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` is a new grantee of `role`. Without permissions,
    /// `None` is returned and internal state is not modified.
    ///
    /// If a role is granted, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"role_granted",
    ///    "data": {
    ///       "role":"<ROLE>",
    ///       "to":"<GRANTEE>",
    ///       "by":"<ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_grant_role(&mut self, role: String, account_id: AccountId) -> Option<bool>;

    /// Returns whether `account_id` has been granted `role`. Note that adding
    /// an account as (super-)admin for `role` does not make that account a
    /// grantee of `role`. Instead, `role` has to be granted explicitly.
    fn acl_has_role(&self, role: String, account_id: AccountId) -> bool;

    /// Revokes `role` from `account_id` provided that the predecessor has
    /// sufficient permissions, i.e. is an admin as defined by [`acl_is_admin`].
    ///
    /// In case of sufficient permissions, the returned `Some(bool)` indicates
    /// whether `account_id` was a grantee of `role`. Without permissions,
    /// `None` is returned and internal state is not modified.
    ///
    /// If a role is revoked, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"AccessControllable",
    ///    "version":"1.0.0",
    ///    "event":"role_revoked",
    ///    "data": {
    ///       "role":"<ROLE>",
    ///       "from":"<GRANTEE>",
    ///       "by":"<ADMIN>"
    ///    }
    /// }
    /// ```
    fn acl_revoke_role(&mut self, role: String, account_id: AccountId) -> Option<bool>;

    /// Revokes `role` from the predecessor and returns whether it was a grantee
    /// of `role`.
    ///
    /// If a role is revoked, the event described in [`Self::acl_revoke_role`]
    /// will be emitted.
    fn acl_renounce_role(&mut self, role: String) -> bool;

    /// Returns whether `account_id` has been granted any of the `roles`.
    fn acl_has_any_role(&self, roles: Vec<String>, account_id: AccountId) -> bool;

    /// Enables paginated retrieval of super-admins. It returns up to `limit`
    /// super-admins and skips the first `skip` super-admins.
    fn acl_get_super_admins(&self, skip: u64, limit: u64) -> Vec<AccountId>;

    /// Enables paginated retrieval of admins of `role`. It returns up to
    /// `limit` admins and skips the first `skip` admins.
    fn acl_get_admins(&self, role: String, skip: u64, limit: u64) -> Vec<AccountId>;

    /// Enables paginated retrieval of grantees of `role`. It returns up to
    /// `limit` grantees and skips the first `skip` grantees.
    fn acl_get_grantees(&self, role: String, skip: u64, limit: u64) -> Vec<AccountId>;

    /// Convenience method that returns all [`PermissionedAccounts`].
    ///
    /// # Gas limits
    ///
    /// This function is eligible for view calls and while view calls are free for users, the
    /// underlying transaction is still subject to a [gas limit] defined by the RPC node.
    ///
    /// In use cases where gas cost matters, the data returned by this function can be retrieved
    /// more efficiently by a combination of the following:
    ///
    /// * Get roles with [`Self::acl_get_roles`].
    /// * Get (a subset) of permissioned accounts with [`Self::acl_get_super_admins`],
    /// [`Self::acl_get_admins`], or [`Self::acl_get_grantees`].
    ///
    /// [gas limit]: https://github.com/near/nearcore/pull/4381
    fn acl_get_permissioned_accounts(&self) -> PermissionedAccounts;
}

/// Collects super admin accounts and accounts that have been granted permissions defined by
/// `AccessControlRole`.
///
/// # Data structure
///
/// Assume `AccessControlRole` is derived for the following enum, which is then passed as `role`
/// attribute to `AccessControllable`.
///
/// ```rust
/// pub enum Role {
///     PauseManager,
///     UnpauseManager,
/// }
/// ```
///
/// Then the returned data has the following structure:
///
/// ```ignore
/// PermissionedAccounts {
///     super_admins: vec!["acc1.near", "acc2.near"],
///     roles: HashMap::from([
///         ("PauseManager", PermissionedAccountsPerRole {
///             admins: vec!["acc3.near", "acc4.near"],
///             grantees: vec!["acc5.near", "acc6.near"],
///         }),
///         ("UnpauseManager", PermissionedAccountsPerRole {
///             admins: vec!["acc7.near", "acc8.near"],
///             grantees: vec!["acc9.near", "acc10.near"],
///         }),
///     ])
/// }
/// ```
///
/// # Uniqueness and ordering
///
/// Account ids returned in vectors are unique but not ordered.
#[derive(Deserialize, Serialize, Debug)]
pub struct PermissionedAccounts {
    /// The accounts that have super admin permissions.
    pub super_admins: Vec<AccountId>,
    /// The admins and grantees of all roles.
    pub roles: HashMap<String, PermissionedAccountsPerRole>,
}

/// Collects all admins and grantees of a role.
///
/// # Uniqueness and ordering
///
/// Account ids returned in vectors are unique but not ordered.
#[derive(Deserialize, Serialize, Debug)]
pub struct PermissionedAccountsPerRole {
    /// The accounts that have admin permissions for the role.
    pub admins: Vec<AccountId>,
    /// The accounts that have been granted the role.
    pub grantees: Vec<AccountId>,
}

pub mod events {
    use crate::events::{AsEvent, EventMetadata};
    use near_sdk::serde::Serialize;
    use near_sdk::AccountId;

    const STANDARD: &str = "AccessControllable";
    const VERSION: &str = "1.0.0";

    /// Event emitted when an accout is made super-admin.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct SuperAdminAdded {
        /// Account that was added as super-admin.
        pub account: AccountId,
        /// Account that added the super-admin.
        pub by: AccountId,
    }

    impl AsEvent<SuperAdminAdded> for SuperAdminAdded {
        fn metadata(&self) -> EventMetadata<SuperAdminAdded> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "super_admin_added".to_string(),
                data: Some(self.clone()),
            }
        }
    }

    /// Event emitted when super-admin permissions are revoked.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct SuperAdminRevoked {
        /// Account from whom permissions were revoked.
        pub account: AccountId,
        /// Account that revoked the permissions.
        pub by: AccountId,
    }

    impl AsEvent<SuperAdminRevoked> for SuperAdminRevoked {
        fn metadata(&self) -> EventMetadata<SuperAdminRevoked> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "super_admin_revoked".to_string(),
                data: Some(self.clone()),
            }
        }
    }

    /// Event emitted when an account is made admin.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct AdminAdded {
        /// The Role for which an admin was added.
        pub role: String,
        /// Account that was added as admin.
        pub account: AccountId,
        /// Account that added the admin.
        pub by: AccountId,
    }

    impl AsEvent<AdminAdded> for AdminAdded {
        fn metadata(&self) -> EventMetadata<AdminAdded> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "admin_added".to_string(),
                data: Some(self.clone()),
            }
        }
    }

    /// Event emitted when admin permissions are revoked.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct AdminRevoked {
        /// The Role for which an admin was revoked.
        pub role: String,
        /// Account from whom permissions where revoked.
        pub account: AccountId,
        /// Account that revoked the admin.
        pub by: AccountId,
    }

    impl AsEvent<AdminRevoked> for AdminRevoked {
        fn metadata(&self) -> EventMetadata<AdminRevoked> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "admin_revoked".to_string(),
                data: Some(self.clone()),
            }
        }
    }

    /// Event emitted when a role is granted to an account.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct RoleGranted {
        /// Role that was granted.
        pub role: String,
        /// Account that was granted the role.
        pub to: AccountId,
        /// Account that granted the role.
        pub by: AccountId,
    }

    impl AsEvent<RoleGranted> for RoleGranted {
        fn metadata(&self) -> EventMetadata<RoleGranted> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "role_granted".to_string(),
                data: Some(self.clone()),
            }
        }
    }

    /// Event emitted when a role is revoked from an account.
    #[derive(Serialize, Clone)]
    #[serde(crate = "near_sdk::serde")]
    pub struct RoleRevoked {
        /// Role that was revoked.
        pub role: String,
        /// Account from whom the role was revoked.
        pub from: AccountId,
        /// Account that revoked the role.
        pub by: AccountId,
    }

    impl AsEvent<RoleRevoked> for RoleRevoked {
        fn metadata(&self) -> EventMetadata<RoleRevoked> {
            EventMetadata {
                standard: STANDARD.to_string(),
                version: VERSION.to_string(),
                event: "role_revoked".to_string(),
                data: Some(self.clone()),
            }
        }
    }
}

'''
'''--- near-plugins/src/events.rs ---
//! # NEAR Events
//!
//! Description of Events on NEAR following [NEP-297](https://nomicon.io/Standards/EventsFormat)
use serde::Serialize;

/// Interface to capture metadata about an event
#[derive(Serialize)]
pub struct EventMetadata<T: Serialize = ()> {
    /// name of standard, e.g. nep171
    pub standard: String,
    /// e.g. 1.0.0
    pub version: String,
    /// type of the event, e.g. nft_mint
    pub event: String,
    /// associate event data. Strictly typed for each set {standard, version, event}
    /// inside corresponding NEP
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<T>,
}

/// Trait to generate and emit NEAR events.
pub trait AsEvent<T: Serialize> {
    /// Returns the metadata that makes up the event.
    fn metadata(&self) -> EventMetadata<T>;

    /// Returns the string representation of the event.
    fn event(&self) -> String {
        format!(
            "EVENT_JSON:{}",
            near_sdk::serde_json::to_string(&self.metadata()).unwrap()
        )
    }

    /// Emits the event on chain.
    fn emit(&self) {
        near_sdk::log!(self.event());
    }
}

#[cfg(test)]
mod tests {
    use crate::events::{AsEvent, EventMetadata};

    struct CompileEvent {
        info: Option<String>,
    }

    impl AsEvent<String> for CompileEvent {
        fn metadata(&self) -> EventMetadata<String> {
            EventMetadata {
                standard: "Compile".to_string(),
                version: "0.0.1".to_string(),
                event: "compile_test".to_string(),
                data: self.info.clone(),
            }
        }
    }

    /// Helper function to check if an event is well formed and follows NEP-297
    /// i.e. tries to deserialize the json object.
    fn valid_event(event: String) -> bool {
        #[derive(serde::Deserialize)]
        struct EventFormat {
            #[allow(dead_code)]
            standard: String,
            #[allow(dead_code)]
            version: String,
            #[allow(dead_code)]
            event: String,
            #[allow(dead_code)]
            data: Option<near_sdk::serde_json::Value>,
        }

        let prefix = "EVENT_JSON:";
        if !event.starts_with(prefix) {
            return false;
        }
        let r = &event[prefix.len()..];
        near_sdk::serde_json::from_str::<EventFormat>(r).is_ok()
    }

    #[test]
    fn event_no_data() {
        let compile_event = CompileEvent { info: None };
        let event_log = compile_event.event();
        let expected =
            r#"EVENT_JSON:{"standard":"Compile","version":"0.0.1","event":"compile_test"}"#;
        assert_eq!(event_log, expected);
        assert!(valid_event(event_log));
    }

    #[test]
    fn event_with_data() {
        let compile_event = CompileEvent {
            info: Some("Compilation successful".to_string()),
        };
        let event_log = compile_event.event();
        let expected = r#"EVENT_JSON:{"standard":"Compile","version":"0.0.1","event":"compile_test","data":"Compilation successful"}"#;
        assert_eq!(event_log, expected);
        assert!(valid_event(event_log));
    }
}

'''
'''--- near-plugins/src/lib.rs ---
pub mod access_control_role;
pub mod access_controllable;
pub mod events;
pub mod ownable;
pub mod pausable;
pub mod upgradable;

pub use access_control_role::AccessControlRole;
pub use access_controllable::AccessControllable;
pub use near_plugins_derive::{
    access_control, access_control_any, if_paused, only, pause, AccessControlRole, Ownable,
    Pausable, Upgradable,
};
pub use ownable::Ownable;
pub use pausable::Pausable;
pub use upgradable::Upgradable;
pub use upgradable::UpgradableDurationStatus;

// Re-exporting these dependencies avoids requiring contracts to depend on them.
// For example, without re-exporting `bitflags` a contract using the access
// control plugin would require:
//
// ```toml
// # Cargo.toml
// [dependencies]
// bitflags = "x.y"
// ```
#[doc(hidden)]
pub use bitflags;

'''
'''--- near-plugins/src/ownable.rs ---
//! # Ownable:
//!
//! Trait which provides a basic access control mechanism, where
//! there is an account (an owner) that can be granted exclusive access to
//! specific functions.
//!
//! During creation of the contract set the owner using `owner_set`. Protect functions that should
//! only be called by the owner using #[only(owner)].
//!
//! ## Credits:
//!
//! Inspired by Open Zeppelin Ownable module:
//! https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
use crate::events::{AsEvent, EventMetadata};
use near_sdk::AccountId;
use serde::Serialize;

/// Trait describing the functionality of the _Ownable_ plugin.
pub trait Ownable {
    /// Returns the key of storage slot to save the current owner. By default b"__OWNER__" is used.
    ///
    /// Attribute `owner_storage_key` can be used to set a different key:
    ///
    /// ```ignore
    /// #[ownable(owner_storage_key="CUSTOM_KEY")]
    /// struct Contract { /* ... */}
    /// ```
    fn owner_storage_key(&self) -> &'static [u8];

    /// Returns the current owner of the contract. Result must be a NEAR valid account id or None,
    /// in case the account doesn't have an owner.
    fn owner_get(&self) -> Option<AccountId>;

    /// Replaces the current owner of the contract by a new owner. Use `None` to remove the owner of
    /// the contract.
    ///
    /// # Default Implementation:
    ///
    /// Only the current owner can call this method. If no owner is set, only self can call this
    /// method. Notice that if the owner is set, self will not be able to call `owner_set` by default.
    ///
    /// # Event
    ///
    /// If ownership is successfully transferred, the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard": "Ownable",
    ///    "version": "1.0.0",
    ///    "event": "ownership_transferred",
    ///    "data": {
    ///       "previous_owner": "Option<PREV_OWNER_ACCOUNT>",
    ///       "new_owner": "Option<NEW_OWNER_ACCOUNT>"
    ///    }
    /// }
    /// ```
    fn owner_set(&mut self, owner: Option<AccountId>);

    /// Returns true if the predecessor account id is the owner of the contract.
    ///
    /// # View calls
    ///
    /// This method fails in view calls since getting the predecessor account id is [not allowed] in
    /// view calls. A workaround is using [`Self::owner_get`] and checking the returned account id.
    ///
    /// [not allowed]: https://nomicon.io/Proposals/view-change-method
    fn owner_is(&self) -> bool;
}

/// Event emitted when ownership is changed.
#[derive(Serialize, Clone)]
pub struct OwnershipTransferred {
    /// The previous owner, if any.
    pub previous_owner: Option<AccountId>,
    /// The new owner, if any.
    pub new_owner: Option<AccountId>,
}

impl AsEvent<OwnershipTransferred> for OwnershipTransferred {
    fn metadata(&self) -> EventMetadata<OwnershipTransferred> {
        EventMetadata {
            standard: "Ownable".to_string(),
            version: "1.0.0".to_string(),
            event: "ownership_transferred".to_string(),
            data: Some(self.clone()),
        }
    }
}

'''
'''--- near-plugins/src/pausable.rs ---
//! # Pausable:
//!
//! Trait which allows contracts to implement an emergency stop mechanism that can be triggered
//! by an authorized account. This authorized account can pause certain features which will
//! prevent some methods or behaviors to be executed. It is expected as well that some methods
//! only work in case certain feature is paused, this will be useful to implement escape hatches.
//!
//! Features are identified by keys.
//!
//! ## Default implementation:
//!
//! Key "ALL" is understood to pause all "pausable" features at once.
//! Provided implementation is optimized for the case where only a small amount of features are
//! paused at a single moment. If all features are meant to be paused, use "ALL" instead. This is done
//! by storing all paused keys in a single slot on the storage. Notice that unpausing "ALL" will not
//! necessarily unpause all features, if other features are still present in the paused_list.
//!
//! As a precondition for being `Pausable` a contract must be `AccessControllable`. Access control
//! is used to define the permissions required to pause and unpause features. In addition, grantees
//! of access control roles may be allowed to call methods that are `#[pause]` or `#[if_paused]`
//! unrestrictedly via the `except` argument.
//!
//! ## Credits:
//!
//! Inspired by Open Zeppelin Pausable module:
//! https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol
use crate::events::{AsEvent, EventMetadata};
use near_sdk::AccountId;
use serde::Serialize;
use std::collections::HashSet;

/// Trait describing the functionality of the `Pausable` plugin.
pub trait Pausable {
    /// Returns the key of the storage slot which contains the list of features that are paused. By
    /// default `b"__PAUSED__"` is used.
    ///
    /// Attribute `paused_storage_key` can be used to set a different key:
    ///
    /// ```ignore
    /// #[pausable(paused_storage_key="CUSTOM_KEY")]
    /// struct Contract { /* ... */}
    /// ```
    fn pa_storage_key(&self) -> &'static [u8];

    /// Returns whether feature `key` is paused.
    fn pa_is_paused(&self, key: String) -> bool;

    /// Returns all features that are currently paused.
    fn pa_all_paused(&self) -> Option<HashSet<String>>;

    /// Pauses feature `key`. This method fails if the caller has not been granted one of the access
    /// control `manager_roles` passed to the `Pausable` plugin.
    ///
    /// It returns `true` if the feature is paused as a result of this function call and `false` if
    /// the feature was already paused. In either case, the feature is paused after the function
    /// returns successfully.
    ///
    /// If the feature is newly paused (the return value is `true`), the following event will be
    /// emitted:
    ///
    /// ```json
    /// {
    ///   "standard":"Pausable",
    ///   "version":"1.0.0",
    ///   "event":"pause",
    ///   "data":
    ///     {
    ///       "by":"<OWNER_ACCOUNT>",
    ///       "key":"<KEY>"
    ///     }
    /// }
    /// ```
    fn pa_pause_feature(&mut self, key: String) -> bool;

    /// Unpauses feature `key`. This method fails if the caller has not been granted one of the
    /// access control `manager_roles` passed to the `Pausable` plugin.
    ///
    /// It returns whether the feature was paused, i.e. `true` if the feature was paused and
    /// otherwise `false`. In either case, the feature is unpaused after the function returns
    /// successfully.
    ///
    /// If the feature was paused (the return value is `true`), the following event will be emitted:
    ///
    /// ```json
    /// {
    ///    "standard":"Pausable",
    ///    "version":"1.0.0",
    ///    "event":"unpause",
    ///    "data":
    ///    {
    ///       "by":"<OWNER_ACCOUNT>",
    ///       "key":"<KEY>"
    ///    }
    /// }
    /// ```
    fn pa_unpause_feature(&mut self, key: String) -> bool;
}

/// Event emitted when a feature is paused.
#[derive(Serialize, Clone)]
pub struct Pause {
    /// Account Id that triggered the pause.
    pub by: AccountId,
    /// Key identifying the feature that was paused.
    pub key: String,
}

impl AsEvent<Pause> for Pause {
    fn metadata(&self) -> EventMetadata<Pause> {
        EventMetadata {
            standard: "Pausable".to_string(),
            version: "1.0.0".to_string(),
            event: "pause".to_string(),
            data: Some(self.clone()),
        }
    }
}

/// Event emitted when a feature is unpaused.
#[derive(Serialize, Clone)]
pub struct Unpause {
    /// Account Id that triggered the unpause.
    pub by: AccountId,
    /// Key identifying the feature that was unpaused.
    pub key: String,
}

impl AsEvent<Unpause> for Unpause {
    fn metadata(&self) -> EventMetadata<Unpause> {
        EventMetadata {
            standard: "Pausable".to_string(),
            version: "1.0.0".to_string(),
            event: "unpause".to_string(),
            data: Some(self.clone()),
        }
    }
}

'''
'''--- near-plugins/src/upgradable.rs ---
//! # Upgradable
//!
//! Upgradable trait inspired by [NEP123](https://github.com/near/NEPs/pull/123).
//!
//! Using the `Upgradable` plugin requires a contract to be `AccessControllable`.
//!
//! To upgrade the contract, first the code needs to be staged via [`Upgradable::up_stage_code`].
//! Staged code can then be deployed by calling [`Upgradable::up_deploy_code`]. Optionally a staging
//! duration can be set, which defines the minimum duration that must pass before staged code can be
//! deployed.
//!
//! The staging duration defaults to zero, allowing staged code to be deployed immediately. To set a
//! staging duration, call [`Upgradable::up_init_staging_duration`]. After initialization the
//! staging duration can be updated by calling [`Upgradable::up_stage_update_staging_duration`]
//! followed by [`Upgradable::up_apply_update_staging_duration`]. Updating the staging duration is
//! itself subject to a delay: at least the currently set staging duration must pass before a staged
//! update can be applied.
//!
//! ## Permissions
//!
//! The `Upgradable` methods mentioned above are protected by `AccessControllable`. Only accounts
//! that have been granted one of the whitelisted roles may successfully call the corresponding
//! method. The documentation of these methods and the [example contract] explain how to define and
//! whitelist roles to manage authorization for the `Upgradable` plugin.
//!
//! ## State migration
//!
//! Upgrading a contract might require [state migration]. The `Upgradable` plugin allows to attach a
//! function call to code deployments. Using this mechanism, state migration can be carried out by
//! calling a migration function. If the function fails, the deployment is rolled back and the
//! initial code remains active. More detailed information is available in the documentation of
//! [`Upgradable::up_deploy_code`].
//!
//! ## Stale staged code
//!
//! After the code is deployed, it should be removed from staging to unstake tokens and avoid the
//! issues described in [`Self::up_deploy_code`].
//!
//! ## Upgrading code that contains a security vulnerability
//!
//! Once code is staged for an upgrade, it is publicly visible via [`Upgradable::up_staged_code`].
//! Staged code that fixes a security vulnerability might be discovered by an attacker who then
//! exploits the vulnerability before its fix is deployed.
//!
//! To avoid that, the upgrade can be executed by calling [`Upgradable::up_stage_code`] and
//! [`Upgradable::up_deploy_code`] in a [batch transaction] in case no staging duration is set.
//! Since [`Upgradable::up_deploy_code`] returns a promise that ultimately deploys the new contract
//! code, a theoretical risk remains. However, the [time between scheduling and execution] of a
//! promise hardly allows an attacker to exploit a vulnerability: they would have to retrieve the
//! bytes of the staged code, reverse engineer the new contract, build an exploit and finally
//! execute it. Therefore, we consider that risk of an exploit in case of a batched upgrade
//! negligible.
//!
//! Another defense mechanism is staging encrypted code, though this requires your own
//! implementation of the trait `Upgradable`. The default implementation provided by
//! `near-plugins-derive` does not support it.
//!
//! [example contract]: ../../near-plugins-derive/tests/contracts/upgradable/src/lib.rs
//! [state migration]: https://docs.near.org/develop/upgrade#migrating-the-state
//! [batch transaction]: https://docs.near.org/concepts/basics/transactions/overview
//! [time between scheduling and execution]: https://docs.near.org/sdk/rust/promises/intro
use crate::events::{AsEvent, EventMetadata};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, CryptoHash, Gas, Promise};

/// Trait describing the functionality of the _Upgradable_ plugin.
pub trait Upgradable {
    /// Returns the storage prefix for slots related to upgradable.
    ///
    /// Attribute `storage_prefix` can be used to set a different prefix:
    ///
    /// ```ignore
    /// #[derive(Upgradable)]
    /// #[upgradable(storage_prefix="CUSTOM_KEY")]
    /// struct Contract { /* ... */}
    /// ```
    fn up_storage_prefix(&self) -> &'static [u8];

    /// Returns all staging durations and timestamps.
    fn up_get_delay_status(&self) -> UpgradableDurationStatus;

    /// Allows an authorized account to stage code to be potentially deployed later. It sets the
    /// staging timestamp, which is the earliest time at which `code` may be deployed. The staging
    /// timestamp is calculated as the block timestamp plus the staging duration. Any code that was
    /// staged previously is discarded.
    ///
    /// If `code` is empty, previously staged code and the corresponding staging timestamp are
    /// removed.
    ///
    /// In the default implementation, this method is protected by access control provided by the
    /// `AccessControllable` plugin. The roles which may successfully call this method are
    /// specified via the `code_stagers` field of the `Upgradable` macro's `access_control_roles`
    /// attribute. The example contract (accessible via the `README`) shows how access control roles
    /// can be defined and passed on to the `Upgradable` macro.
    fn up_stage_code(&mut self, code: Vec<u8>);

    /// Returns the staged code.
    fn up_staged_code(&self) -> Option<Vec<u8>>;

    /// Returns the hash of the staged code
    fn up_staged_code_hash(&self) -> Option<CryptoHash>;

    /// Allows an authorized account to deploy the staged code. It panics if no code is staged.
    ///
    /// # Attaching a function call
    ///
    /// If `function_call_args` are provided, code is deployed in a batch promise that contains the
    /// `DeployContractAction` followed by `FunctionCallAction`. In case the function call fails,
    /// the deployment is rolled back and the initial code remains active. For this purpose,
    /// batching the actions mentioned above is required due to the [asynchronous design] of NEAR.
    ///
    /// Attaching a function call can be useful, for example, if deploying the staged code requires
    /// [state migration]. It can be achieved by calling a migration function defined in the new
    /// version of the contract. A failure during state migration can leave the contract in a broken
    /// state, which is avoided by the roleback mechanism described above.
    ///
    /// # Removal of staged code
    ///
    /// After deployment, staged code remains in storage. It is not removed automatically as this
    /// would cost extra gas and therefore increase the risk of the transaction hitting NEAR's gas
    /// limit. Moreover, in case the deployment is roled back due to a failure in the attached
    /// function call, the staged code might still be required.
    ///
    /// Once staged code is no longer needed, it can be removed by passing the appropriate arguments
    /// to [`Self::up_stage_code`]. Removing staged code allows to [unstake tokens] that are storage
    /// staked.
    ///
    /// It is recommended to remove staged code as soon as possible to avoid deploying code and
    /// executing an attached function call multiple times. Using batch transaction for this purpose
    /// can be dangerous. Since `up_deploy_code` returns a promise, there can be unexpected outcomes
    /// when it is combined in a batch transaction with another function call that removes code from
    /// storage. This is demonstrated in the `Upgradable` test
    /// `test_deploy_code_in_batch_transaction_pitfall`.
    ///
    /// # Permissions
    ///
    /// In the default implementation, this method is protected by access control provided by the
    /// `AccessControllable` plugin. The roles which may successfully call this method are
    /// specified via the `code_deployers` field of the `Upgradable` macro's `access_control_roles`
    /// attribute. The example contract (accessible via the `README`) shows how access control roles
    /// can be defined and passed on to the `Upgradable` macro.
    ///
    /// [asynchronous design]: https://docs.near.org/concepts/basics/transactions/overview
    /// [state migration]: https://docs.near.org/develop/upgrade#migrating-the-state
    /// [storage staked]: https://docs.near.org/concepts/storage/storage-staking#btw-you-can-remove-data-to-unstake-some-tokens
    fn up_deploy_code(&mut self, function_call_args: Option<FunctionCallArgs>) -> Promise;

    /// Initializes the duration of the delay for deploying the staged code. It defaults to zero if
    /// code is staged before the staging duration is initialized. Once the staging duration has
    /// been initialized, this method panics. For subsequent updates of the staging duration,
    /// [`Self::up_stage_update_staging_duration`] and [`Self::up_apply_update_staging_duration`]
    /// can be used.
    ///
    /// In the default implementation, this method is protected by access control provided by the
    /// `AccessControllable` plugin. The roles which may successfully call this method are
    /// specified via the `duration_initializers` field of the `Upgradable` macro's
    /// `access_control_roles` attribute. The example contract (accessible via the `README`) shows
    /// how access control roles can be defined and passed on to the `Upgradable` macro.
    fn up_init_staging_duration(&mut self, staging_duration: near_sdk::Duration);

    /// Allows an authorized account to stage an update of the staging duration. It panics if the
    /// staging duration was not previously initialized with [`Self::up_init_staging_duration`]. It
    /// sets the timestamp for the new staging duration, which is the earliest time at which the
    /// update may be applied. The new staging duration timestamp is calculated as the block
    /// timestamp plus the current staging duration.
    ///
    /// In the default implementation, this method is protected by access control provided by the
    /// `AccessControllable` plugin. The roles which may successfully call this method are specified
    /// via the `duration_update_stagers` field of the `Upgradable` macro's `access_control_roles`
    /// attribute. The example contract (accessible via the `README`) shows how access control roles
    /// can be defined and passed on to the `Upgradable` macro.
    fn up_stage_update_staging_duration(&mut self, staging_duration: near_sdk::Duration);

    /// Allows an authorized account to apply the staged update of the staging duration. It fails if
    /// no staging duration update is staged.
    ///
    /// In the default implementation, this method is protected by access control provided by the
    /// `AccessControllable` plugin. The roles which may successfully call this method are specified
    /// via the `duration_update_appliers` field of the `Upgradable` macro's `access_control_roles`
    /// attribute. The example contract (accessible via the `README`) shows how access control roles
    /// can be defined and passed on to the `Upgradable` macro.
    fn up_apply_update_staging_duration(&mut self);
}

#[derive(Deserialize, Serialize)]
pub struct UpgradableDurationStatus {
    pub staging_duration: Option<near_sdk::Duration>,
    pub staging_timestamp: Option<near_sdk::Timestamp>,
    pub new_staging_duration: Option<near_sdk::Duration>,
    pub new_staging_duration_timestamp: Option<near_sdk::Timestamp>,
}

/// Specifies a function call to be appended to the actions of a promise via
/// [`near_sdk::Promise::function_call`]).
#[derive(Deserialize, Serialize, Debug)]
pub struct FunctionCallArgs {
    /// The name of the function to call.
    pub function_name: String,
    /// The arguments to pass to the function.
    pub arguments: Vec<u8>,
    /// The amount of tokens to transfer to the receiver.
    pub amount: Balance,
    /// The gas limit for the function call.
    pub gas: Gas,
}

/// Event emitted when the code is staged
#[derive(Serialize, Clone)]
struct StageCode {
    /// The account which staged the code.
    by: AccountId,
    /// The hash of the code that was staged.
    code_hash: CryptoHash,
}

impl AsEvent<StageCode> for StageCode {
    fn metadata(&self) -> EventMetadata<StageCode> {
        EventMetadata {
            standard: "Upgradable".to_string(),
            version: "1.0.0".to_string(),
            event: "stage_code".to_string(),
            data: Some(self.clone()),
        }
    }
}

/// Event emitted when the code is deployed
#[derive(Serialize, Clone)]
struct DeployCode {
    /// The account that deployed the code.
    by: AccountId,
    /// The hash of the code that was deployed.
    code_hash: CryptoHash,
}

impl AsEvent<DeployCode> for DeployCode {
    fn metadata(&self) -> EventMetadata<DeployCode> {
        EventMetadata {
            standard: "Upgradable".to_string(),
            version: "1.0.0".to_string(),
            event: "deploy_code".to_string(),
            data: Some(self.clone()),
        }
    }
}

'''