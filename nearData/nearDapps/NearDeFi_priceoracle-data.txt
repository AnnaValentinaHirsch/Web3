*GitHub Repository "NearDeFi/priceoracle-data"*

'''--- Cargo.toml ---
[package]
name = "price_data"
version = "1.0.0"
authors = ["Vadim Ilin <vadim@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "=4.0.0-pre.8"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# priceoracle-data
NEAR Native Price Oracle on-chain dashboard

Live-demo: 
https://priceoracle-data.testnet.page/
https://oracle-prices.near.page/

'''
'''--- build.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)"

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ./res
cp target/wasm32-unknown-unknown/release/price_data.wasm ./res/

'''
'''--- build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_pricedata"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/price-data \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2021-10-21; rustup default stable-2021-10-21; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/price_data.wasm $DIR/res/release.wasm

'''
'''--- res/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEAR Native Price Oracle Data</title>

    <meta name="og:title" content="NEAR Native Price Oracle Data"/>
    <meta name="og:description" content="%NEAR Native Price Oracle Data"/>

    <link href="https://fonts.googleapis.com/css?family=Outfit:100,200,300,regular,500,600,700,800,900"
          rel="stylesheet"/>

    <style>
        :root {
            --oxford-blue: hsl(217, 54%, 11%);
            --light-oxford-blue: hsl(216, 50%, 16%);
            --indigo-dye: hsl(215, 32%, 27%);
            --blue-yonder: hsl(216, 30%, 55%);
            --aqua: hsl(178, 100%, 50%);
            --white: hsl(0, 0%, 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-family: "Outfit", sans-serif;
        }

        a {
            text-decoration: none;
        }

        body {
            background: var(--oxford-blue);
            min-height: 100vh;
            padding: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        h1 {
            color: var(--white);
            font-size: 24px;
            padding-bottom: 10px;
        }

        h2 {
            color: var(--white);
            font-size: 24px;
            padding-bottom: 5px;
        }

        .prices, .validators {
            color: var(--white);
            font-size: 18px;
            border-spacing: 0;
        }

        .prices tbody tr:nth-of-type(odd), .validators tbody tr:nth-of-type(odd) {
            background-color: #2f415b;
        }

        .prices td, .validators td, .prices th, .validators th {
            padding: 3px;
            vertical-align: bottom;
        }

        .prices th, .validators th {
            font-weight: initial;
            text-align: left;
        }

        .prices td:first-child, .validators td:first-child, .prices th:first-child, .validators th:first-child {
            width: 100%;
        }

        .prices td:last-child, .validators td:last-child {
            font-family: monospace;
            min-width: 115px;
        }

        .card {
            background: var(--light-oxford-blue);
            max-width: 350px;
            padding: 24px;
            border-radius: 15px;
            box-shadow: 0 20px 25px 15px rgba(0, 0, 0, 0.05),
            0 40px 30px 15px rgba(0, 0, 0, 0.1);
        }

        .validators-header {
            padding-top: 20px;
        }

    </style>
</head>

<body>

<div class="card">

    <h1>NEAR Native Price Oracle</h1>

    <h2>Assets</h2>

    <table class="prices">
        <thead>
            <tr>
                <th>Asset</th>
                <th>Price</th>
            </tr>
        </thead>
        <tbody>
            %PRICES%
        </tbody>
    </table>

    <h2 class="validators-header">Oracle validators</h2>

    <table class="validators">
        <thead>
            <tr>
                <th>Oracle Validator</th>
                <th>Last&nbsp;report, seconds ago</th>
            </tr>
        </thead>
        <tbody>
            %VALIDATORS%
        </tbody>
    </table>
</div>
</body>
</html>

'''
'''--- src/lib.rs ---
mod web4;
mod utils;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId, BorshStorageKey, PanicOnDefault};
use near_sdk::collections::LookupMap;

const PRICE_ORACLE: &str = "priceoracle.near";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub config: LookupMap<AccountId, TokenConfig>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenConfig {
    pub token_name: String,
    pub decimals: u8,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Config
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            config: LookupMap::new(StorageKey::Config)
        }
    }

    #[private]
    pub fn add_token_config(&mut self, account_id: AccountId, config: TokenConfig) {
        self.config.insert(&account_id, &config);
    }

    #[private]
    pub fn add_token_configs(&mut self, configs: Vec<(AccountId, TokenConfig)>) {
        for (account_id, config) in configs {
            self.config.insert(&account_id, &config);
        }
    }

    pub fn get_config(&self, keys: Vec<AccountId>) -> Vec<(AccountId, Option<TokenConfig>)> {
        keys
            .into_iter()
            .map(|account_id| (account_id.clone(), self.config.get(&account_id)))
            .collect()
    }
}
'''
'''--- src/utils.rs ---
pub(crate) mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
        where
            D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub(crate) mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
        where
            D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

'''
'''--- src/web4.rs ---
use std::cmp::max;
use crate::*;
use crate::utils::*;

use near_sdk::json_types::Base64VecU8;
use near_sdk::{env, serde_json, Balance, Timestamp};
use std::collections::HashMap;

const INDEX_BODY: &str = include_str!("../res/index.html");

#[allow(dead_code)]
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Web4Request {
    #[serde(rename = "accountId")]
    account_id: Option<AccountId>,
    path: String,
    params: Option<HashMap<String, String>>,
    query: Option<HashMap<String, Vec<String>>>,
    preloads: Option<HashMap<String, Web4Response>>,
}

#[derive(Serialize, Deserialize, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct Web4Response {
    #[serde(rename = "contentType")]
    content_type: Option<String>,
    status: Option<u32>,
    body: Option<Base64VecU8>,
    #[serde(rename = "bodyUrl")]
    body_url: Option<String>,
    #[serde(rename = "preloadUrls")]
    preload_urls: Option<Vec<String>>,
}

pub type DurationSec = u32;

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

#[derive(Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetPrice {
    #[serde(with = "u128_dec_format")]
    multiplier: Balance,
    decimals: u8,
}

impl AssetOptionalPrice {
    pub fn get_price(&self) -> String {
        if let Some(data) = &self.price {
            data.multiplier.to_string()
        } else {
            "Not found".to_string()
        }
    }
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AccountId,
    pub price: Option<AssetPrice>,
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    pub reports: Vec<Report>,
    pub emas: Vec<AssetEma>,
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Report {
    pub oracle_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub price: AssetPrice,
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetEma {
    pub period_sec: DurationSec,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub price: Option<AssetPrice>,
}

impl Web4Response {
    pub fn html_response(text: String) -> Self {
        Self {
            content_type: Some(String::from("text/html; charset=UTF-8")),
            body: Some(text.into_bytes().into()),
            ..Default::default()
        }
    }

    pub fn plain_response(text: String) -> Self {
        Self {
            content_type: Some(String::from("text/plain; charset=UTF-8")),
            body: Some(text.into_bytes().into()),
            ..Default::default()
        }
    }

    pub fn preload_urls(urls: Vec<String>) -> Self {
        Self {
            preload_urls: Some(urls),
            ..Default::default()
        }
    }

    pub fn body_url(url: String) -> Self {
        Self {
            body_url: Some(url),
            ..Default::default()
        }
    }

    pub fn status(status: u32) -> Self {
        Self {
            status: Some(status),
            ..Default::default()
        }
    }
}

#[near_bindgen]
impl Contract {
    #[allow(unused_variables)]
    pub fn web4_get(&self, request: Web4Request) -> Web4Response {
        let path = request.path;

        if path == "/robots.txt" {
            return Web4Response::plain_response("User-agent: *\nDisallow:".to_string());
        }

        let get_price_data_path =
            format!("/web4/contract/{}/get_price_data", PRICE_ORACLE.to_string());

        let get_assets_path =
            format!("/web4/contract/{}/get_assets", PRICE_ORACLE.to_string());

        if let Some(preloads) = request.preloads {
            let price_data: PriceData = serde_json::from_slice(
                &preloads
                    .get(&get_price_data_path)
                    .unwrap()
                    .body
                    .as_ref()
                    .expect("Data not found")
                    .0,
            )
                .expect("Failed to parse price data");

            let assets: Vec<(AccountId, Asset)> = serde_json::from_slice(
                &preloads
                    .get(&get_assets_path)
                    .unwrap()
                    .body
                    .as_ref()
                    .expect("Data not found")
                    .0,
            )
                .expect("Failed to parse assets");

            let mut prices_table: String = "".to_string();
            for price_data in &price_data.prices {
                if let Some(config) = self.config.get(&price_data.asset_id) {
                    if let Some(asset_price) = &price_data.price {
                        let price: f64 = asset_price.multiplier as f64 /
                            (10u128.pow((asset_price.decimals - config.decimals) as u32)) as f64;
                        prices_table = format!("{}<tr><td>{}</td><td>{}</td></tr>", &prices_table,
                                               config.token_name,
                                               price.to_string());
                    }
                } else {
                    if price_data.asset_id.to_string() != "c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near" {
                        prices_table = format!("{}<tr><td>{}</td><td>{}</td></tr>", &prices_table,
                                               &price_data.asset_id,
                                               &price_data.get_price());
                    }
                }
            }

            let mut validators: HashMap<AccountId, Timestamp> = HashMap::new();
            for (account_id, asset) in assets {
                for report in asset.reports {
                    let last_timestamp = max(
                        report.timestamp,
                        validators.get(&report.oracle_id).cloned().unwrap_or_default());
                    validators.insert(report.oracle_id, last_timestamp);
                }

                for ema in asset.emas {
                    if let Some(config) = self.config.get(&account_id) {
                        if let Some(ema_price) = &ema.price {
                            let price: f64 = ema_price.multiplier as f64 /
                                (10u128.pow((ema_price.decimals - config.decimals) as u32)) as f64;
                            prices_table = format!("{}<tr><td>{} EMA#{}</td><td>{}</td></tr>", &prices_table,
                                                   config.token_name,
                                                   ema.period_sec.to_string(),
                                                   ((price * 10000f64).floor() / 10000.0).to_string());
                        }
                    }
                }
            }

            let mut validators_table: String = "".to_string();
            for (validator_id, timestamp) in validators {
                let time_diff: Timestamp = env::block_timestamp() - timestamp;
                validators_table = format!("{}<tr><td>{}</td><td>{:.2}</td></tr>", &validators_table,
                                           &validator_id,
                                           &(time_diff as f64 / 10u64.pow(9) as f64));
            }

            Web4Response::html_response(
                INDEX_BODY
                    .replace("%PRICES%", &prices_table)
                    .replace("%VALIDATORS%", &validators_table),
            )
        } else {
            Web4Response::preload_urls(vec![get_assets_path, get_price_data_path])
        }
    }
}

'''