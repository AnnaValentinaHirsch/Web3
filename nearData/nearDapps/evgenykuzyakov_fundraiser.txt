*GitHub Repository "evgenykuzyakov/fundraiser"*

'''--- Cargo.toml ---
[package]
name = "fundraiser"
version = "1.0.0"
authors = ["referencedev <goi65io3903d@protonmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint = { version = "0.9.0", default-features = false }
near-sdk = { version = "4.0.0-pre.3" }
near-contract-standards = "4.0.0-pre.3"

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "z"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Fundraising contract

Fundraising contract, with two core features:
 - Create sales, that people can deposit funds into.
 - Create linkdrops for creating accounts. This gets recorded in the internal table of this contract to see which account helped created which account.

## Registering new accounts

As a secondary goal of this fundraising contract is to help onboard more users on NEAR. 
To facilitate this, contract provides existing users a way to create a linkdrop for onboarding users.

Linkdrops are a single usage private key that allows to issue a transaction to the given contract. 
This call will in turn create a new ".near" account and record that this account was paid by user who created linkdrop.   

## Sales distribution process

This contract doesn't handle sales distribution process, instead leaving this to the owner.
Owner will be able to extra the table of all the users and how much they have deposited for the given sale.
After that, owner should airdrop the tokens according to whatever other rules (referral, whitelists, etc).
Referral map of account creations can be extracted as well by listing all the users or queried for specific user.

# Testing

We are going to use `dev-1634658127682-97093903837694` test token as a deposit token.
To mint yourself some of it call:

```
near call dev-1634658127682-97093903837694 mint '{"account_id": "dev-1634657876145-24893242863336", "amount": "10000000000000"}' --accountId dev-1634657876145-24893242863336
```

Next steps dev-deploy the contract:

```
./build_local.sh

near dev-deploy --wasmFile=res/fundraiser_local.wasm

near call dev-1634657876145-24893242863336 new '{"owner_id": "dev-1634657876145-24893242863336", "join_fee": "100000", "referral_fees": [10, 20, 30]}' --accountId dev-1634657876145-24893242863336
```

Replace `dev-1634657876145-24893242863336` with what dev-deploy command will output.

Create new sale with the token above:

```
near call dev-1634657876145-24893242863336 create_sale '{"sale": {"metadata": {"name": "test", "symbol": "TEST", "description": "test", "logo_url": "", "smart_contract_url": ""}, "min_near_deposit": "0", "deposit_token_id": "dev-1634658127682-97093903837694", "min_buy": "1", "max_buy": "10000", "start_date": "10000000", "end_date": "100000000", "price": "1000"}}' --accountId dev-1634657876145-24893242863336
```

View sale info:

```
near view dev-1634657876145-24893242863336 get_sale '{"sale_id": 2}'
```

'''
'''--- build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="build_fundraiser"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/fundraiser \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2021-10-21; rustup default stable-2021-10-21; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/fundraiser.wasm $DIR/res/fundraiser_release.wasm

'''
'''--- build_local.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/fundraiser.wasm ./res/fundraiser_local.wasm

'''
'''--- migrtation.txt ---
REINIT (SKIP FOR MAINNET)
export CONTRACT_ID=dev-1637079331366-44744905777480
near dev-deploy --wasmFile=res/fundraiser_local.wasm
near call $CONTRACT_ID new '{"owner_id": "'$CONTRACT_ID'", "join_fee": "100000", "referral_fees": [10, 20, 30]}' --accountId $CONTRACT_ID

STATE REPAIR:
MIGRATE ACCOUNTS:
near call $CONTRACT_ID migrate_a0 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_a1 '{"limit": 17}' --gas 200000000000000 --accountId $CONTRACT_ID (repeat until Pending items: 0)

LOAD USERS
near call $CONTRACT_ID migrate_u '{"from_index":0, "limit":60}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_u '{"from_index":60, "limit":60}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_u '{"from_index":120, "limit":60}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_u '{"from_index":180, "limit":60}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_u '{"from_index":240, "limit":60}' --gas 200000000000000 --accountId $CONTRACT_ID

LOAD SALES
near call $CONTRACT_ID migrate_s10 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s11 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s20 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s21 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s30 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s31 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s40 '{}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID migrate_s41 '{}' --gas 200000000000000 --accountId $CONTRACT_ID

CONFIG
near call $CONTRACT_ID update_referral_fees '{"referral_fees": [50, 25, 10]}' --accountId $CONTRACT_ID
/// Denominator: 10000

NOTES:
1) Check if claim_available for Aurora sales set to false. Otherwise: update_sale_claim_available

2) How to claim purchase:
- claim_purchase(sale_id)
- check if get_sale_account(account_id, sale_id) has refund > 0
- claim_refund(sale_id)

====
EXAMPLES:

near view $CONTRACT_ID get_sale_accounts '{"sale_id": 0, "from_index":0, "limit":50}'
near view $CONTRACT_ID get_sales '{"from_index":0, "limit":50}'
near view $CONTRACT_ID get_accounts '{"from_index":0, "limit":50}'
near view $CONTRACT_ID get_sale '{"sale_id": 3}'
near view $CONTRACT_ID get_links '{"account_id": "n0ok.near"}'
near view $CONTRACT_ID get_account '{"account_id": "n0ok.near"}'
near view $CONTRACT_ID get_sale_account '{"account_id": "n0ok.near", "sale_id": 4}'
near view $CONTRACT_ID get_num_sales '{}'

near call $CONTRACT_ID update_sale_distribute_token_id '{"sale_id":3, "distribute_token_id": "wrap.testnet"}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID update_sale_distribute_token_decimals '{"sale_id":3, "distribute_token_decimals": 18}' --gas 200000000000000 --accountId $CONTRACT_ID
near call $CONTRACT_ID claim_purchase '{"sale_id":3}' --gas 200000000000000 --accountId $CONTRACT_ID

export TOKEN_ID=wrap.testnet
export REFERRAL_ID=n0ok.near
export USER_ID=lr.testnet
near call $TOKEN_ID storage_deposit '{"account_id": "'$CONTRACT_ID'", "registration_only": true}' --accountId=$USER_ID --deposit 0.00125

near call $CONTRACT_ID create_sale '{"sale": {"metadata": {"name": "test", "symbol": "TEST", "description": "test", "logo_url": "", "smart_contract_url": "", "output_ticker": "OUT", "project_telegram": "t.me/test", "reward_timestamp": 123, "reward_description": "123123123"}, "staking_contracts": [], "hard_max_amount_limit": false, "min_near_deposit": "0", "deposit_token_id": "'$TOKEN_ID'", "min_buy": "1", "max_buy": "30000000000000000000000000", "start_date": "10000000", "end_date": "1935298768424417800", "price": "200000000000000000000000", "max_amount": "30000000000000000000000", "limit_per_transaction": "2000000000000000000000000", "claim_available": true, "distribute_token_id": "'$TOKEN_ID'", "distribute_token_decimals": 24, "sale_type": "BySubscription", "distribute_supply_amount": "1000000000000000000000000"}}' --accountId $CONTRACT_ID

export SALE_ID=11

near call $CONTRACT_ID join '{"referrer_id": "'$REFERRAL_ID'"}' --accountId $USER_ID --depositYocto 100000

near view $CONTRACT_ID get_account '{"account_id": "'$USER_ID'"}'

near call $TOKEN_ID storage_deposit '{"account_id": "'$USER_ID'", "registration_only": true}' --accountId=$USER_ID --deposit 0.00125
near call $CONTRACT_ID deposit_near '{"sale_deposit": {"sale_id": '$SALE_ID'}}' --accountId $USER_ID --deposit=0.1 --gas=150000000000000

near view $CONTRACT_ID get_referrals '{"account_id": "'$USER_ID'"}'
near view $CONTRACT_ID get_sale '{"sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_referral_fees '{}'
near view $CONTRACT_ID get_sale_account '{"account_id": "'$USER_ID'", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_account '{"account_id": "'$REFERRAL_ID'", "sale_id": '$SALE_ID'}'

near call $CONTRACT_ID claim_purchase '{"sale_id": '$SALE_ID'}' --accountId $USER_ID --gas=150000000000000
near call $CONTRACT_ID claim_affiliate_reward '{"sale_id": '$SALE_ID'}' --accountId $USER_ID --gas=150000000000000

export REF_1=new_acc.testnet
near call $CONTRACT_ID join '{}' --accountId nft1.testnet --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "nft1.testnet"}' --accountId testbeta.testnet --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "testbeta.testnet"}' --accountId new_acc.testnet --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "'$REF_1'"}' --accountId lr.testnet --depositYocto 100000
near view $CONTRACT_ID get_affiliate_account '{"account_id": "nft1.testnet", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_account '{"account_id": "testbeta.testnet", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_account '{"account_id": "new_acc.testnet", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_account '{"account_id": "lr.testnet", "sale_id": '$SALE_ID'}'
near call $CONTRACT_ID deposit_near '{"sale_deposit": {"sale_id": '$SALE_ID'}}' --accountId $USER_ID --deposit=0.1 --gas=150000000000000
near view $TOKEN_ID ft_balance_of '{"account_id": "'$USER_ID'"}'
near call $TOKEN_ID storage_deposit '{"account_id": "'$USER_ID'", "registration_only": true}' --accountId=$USER_ID --deposit 0.00125
near call $CONTRACT_ID claim_purchase '{"sale_id": '$SALE_ID'}' --accountId $USER_ID --gas=150000000000000

near call $TOKEN_ID storage_deposit '{"account_id": "'$REF_1'", "registration_only": true}' --accountId=$USER_ID --deposit 0.00125
near view $TOKEN_ID ft_balance_of '{"account_id": "'$REF_1'"}'
near call $CONTRACT_ID claim_affiliate_reward '{"sale_id": '$SALE_ID'}' --accountId $REF_1 --gas=150000000000000
near view $CONTRACT_ID get_affiliate_account '{"account_id": "'$REF_1'", "sale_id": '$SALE_ID'}'

// TEST By Subscription
near call $CONTRACT_ID create_sale '{"sale": {"metadata": {"name": "test", "symbol": "TEST", "description": "test", "logo_url": "", "smart_contract_url": "", "output_ticker": "OUT", "project_telegram": "t.me/test", "reward_timestamp": 123, "reward_description": "123123123"}, "staking_contracts": [], "hard_max_amount_limit": false, "min_near_deposit": "0", "deposit_token_id": "'$TOKEN_ID'", "min_buy": "1", "max_buy": "30000000000000000000000000", "start_date": "10000000", "end_date": "1935298768424417800", "price": "200000000000000000000000", "max_amount": "30000000000000000000000", "limit_per_transaction": "2000000000000000000000000", "claim_available": true, "distribute_token_id": "'$TOKEN_ID'", "distribute_token_decimals": 24, "sale_type": "BySubscription", "distribute_supply_amount": "1000000000000000000000000"}}' --accountId $CONTRACT_ID

export USER_2_ID=new_acc.testnet
export USER_3_ID=testbeta.testnet
export REF_2=testbeta.testnet
near view $CONTRACT_ID get_sale '{"sale_id": '$SALE_ID'}'

near call $CONTRACT_ID deposit_near '{"sale_deposit": {"sale_id": '$SALE_ID'}}' --accountId $USER_ID --deposit=0.3 --gas=150000000000000
near view $CONTRACT_ID get_sale_account '{"account_id": "'$USER_ID'", "sale_id": '$SALE_ID'}'
near call $CONTRACT_ID deposit_near '{"sale_deposit": {"sale_id": '$SALE_ID'}}' --accountId $USER_2_ID --deposit=0.4 --gas=150000000000000
near view $CONTRACT_ID get_sale_account '{"account_id": "'$USER_2_ID'", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_account_after_claim '{"account_id": "'$USER_2_ID'", "sale_id": '$SALE_ID'}'
near call $CONTRACT_ID deposit_near '{"sale_deposit": {"sale_id": '$SALE_ID'}}' --accountId $USER_3_ID --deposit=0.5 --gas=150000000000000
near view $CONTRACT_ID get_sale_account '{"account_id": "'$USER_3_ID'", "sale_id": '$SALE_ID'}'

near view $CONTRACT_ID get_affiliate_account '{"account_id": "'$REF_1'", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_account '{"account_id": "'$REF_2'", "sale_id": '$SALE_ID'}'

near call $CONTRACT_ID claim_purchase '{"sale_id": '$SALE_ID'}' --accountId $USER_ID --gas=150000000000000
near call $CONTRACT_ID claim_refund '{"sale_id": '$SALE_ID'}' --accountId $USER_ID --gas=150000000000000
near call $CONTRACT_ID claim_purchase '{"sale_id": '$SALE_ID'}' --accountId $USER_2_ID --gas=150000000000000
near call $CONTRACT_ID claim_purchase '{"sale_id": '$SALE_ID'}' --accountId $USER_3_ID --gas=150000000000000
near call $CONTRACT_ID claim_refund '{"sale_id": '$SALE_ID'}' --accountId $USER_3_ID --gas=150000000000000

near call $CONTRACT_ID claim_affiliate_reward '{"sale_id": '$SALE_ID'}' --accountId $USER_3_ID --gas=150000000000000
near view $CONTRACT_ID get_affiliate_account '{"account_id": "'$USER_3_ID'", "sale_id": '$SALE_ID'}'
near view $CONTRACT_ID get_affiliate_reward_account_after_claim  '{"account_id": "'$USER_3_ID'", "sale_id": '$SALE_ID'}'

export REF_0=learnrust2.testnet
export REF_1=new_acc.testnet
export REF_2=testbeta.testnet
export REF_3=not-kotleta.testnet
export REF_4=bubble-nft.testnet
export REF_5=contract.lr.testnet
export REF_6=my6.api.testnet
near call $CONTRACT_ID join '{"referrer_id": "'$REF_1'"}' --accountId $REF_0 --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "'$REF_0'"}' --accountId $REF_4 --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "'$REF_4'"}' --accountId $REF_6 --depositYocto 100000
near call $CONTRACT_ID join '{"referrer_id": "12312223'$REF_4'"}' --accountId market.dev-1625142307760-73087269739287 --depositYocto 100000

near view $CONTRACT_ID get_account '{"account_id": "'$REF_1'"}'
near view $CONTRACT_ID get_affiliates '{"account_id": "'$REF_4'"}'
near view $CONTRACT_ID get_referrals '{"account_id": "'$REF_3'"}'

near dev-deploy --wasmFile=res/fundraiser_local.wasm

'''
'''--- src/lib.rs ---
use near_sdk::{
    AccountId, Balance, BorshStorageKey, env, ext_contract, Gas, near_bindgen, PanicOnDefault,
    Promise, PromiseOrValue, PublicKey,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

use crate::sale::VSale;

mod sale;
mod token_receiver;
mod migration_0;
mod migration_1;

pub(crate) const ONE_NEAR: Balance = 10u128.pow(24);

const BASE_GAS: Gas = Gas(5_000_000_000_000);
pub(crate) const CREATE_ACCOUNT_GAS: Gas = Gas(4 * BASE_GAS.0);
pub(crate) const ON_CREATE_ACCOUNT_GAS: Gas = Gas(4 * BASE_GAS.0);

const NO_DEPOSIT: Balance = 0;
const ACCESS_KEY_ALLOWANCE: Balance = ONE_NEAR / 100;
// AUDIT: This should be more than `ACCESS_KEY_ALLOWANCE` to cover cost of storage for access key + allowance.
const CREATE_LINK_AMOUNT: Balance = ONE_NEAR / 100;
const CREATE_ACCOUNT_AMOUNT: Balance = ONE_NEAR / 100;

const REFERRAL_FEE_DENOMINATOR: u128 = 10000;
const NEAR_ACCOUNT: &str = "near";
const WRAP_NEAR_ACCOUNT: &str = "wrap.near";

#[ext_contract(ext_self)]
pub trait ExtContract {
    /// Callback from checking staked balance of the given user.
    fn on_get_account_staked_balance(
        &mut self,
        sale_id: u64,
        token_id: AccountId,
        sender_id: AccountId,
        deposit_amount: U128,
    ) -> PromiseOrValue<U128>;

    /// Callback after account creation.
    fn on_create_account(&mut self, new_account_id: AccountId) -> Promise;

    /// Callback after near deposit
    fn after_ft_on_transfer_near_deposit(
        &mut self,
        sender_id: AccountId,
        deposit_amount: U128,
    ) -> PromiseOrValue<U128>;

    /// Callback after token claim
    fn after_withdraw_purchase(&mut self,
                               account_id: AccountId,
                               amount_to_claim: U128,
                               sale_id: u64) -> bool;

    /// Callback after token refund for subscription sales
    fn after_refund_purchase(&mut self,
                             account_id: AccountId,
                             amount_to_refund: U128,
                             sale_id: u64) -> bool;

    /// Callback after affiliate_rewards claim
    fn after_withdraw_affiliate_reward(&mut self, account_id: AccountId, amount: U128, sale_id: u64) -> bool;
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountOld {
    referrer: AccountId,
    links: UnorderedSet<PublicKey>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Account {
    referrer: AccountId,
    links: UnorderedSet<PublicKey>,
    affiliates: LookupMap<u8, UnorderedSet<AccountId>>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAccount {
    Current(Account),
}

impl From<VAccount> for Account {
    fn from(v_account: VAccount) -> Self {
        match v_account {
            VAccount::Current(account) => account,
        }
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct AccountOutput {
    referrer: AccountId,
    affiliates_num: u64,
}

impl From<Account> for AccountOutput {
    fn from(account: Account) -> Self {
        let aff_0 = get_affiliates_num(&account, 0);
        let aff_1 = if aff_0 > 0 { get_affiliates_num(&account, 1) } else { 0 };
        let aff_2 = if aff_1 > 0 { get_affiliates_num(&account, 2) } else { 0 };

        Self {
            referrer: account.referrer,
            affiliates_num: aff_0 + aff_1 + aff_2,
        }
    }
}

fn get_affiliates_num(account: &Account, level: u8) -> u64 {
    if let Some(affiliates) = account.affiliates.get(&level) {
        affiliates.len()
    } else {
        0
    }
}

impl Account {
    pub fn new(account_id: &AccountId, referrer: &AccountId) -> Self {
        Self {
            referrer: referrer.clone(),
            links: UnorderedSet::new(StorageKey::AccountLinks {
                account_id: account_id.clone(),
            }),
            affiliates: LookupMap::new(StorageKey::Affiliates {
                account_id: account_id.clone(),
            }),
        }
    }
}

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Accounts,
    Sales,
    AccountSales { sale_id: u64 },
    Links,
    AccountLinks { account_id: AccountId },
    AccountAffiliateRewards { sale_id: u64 },
    Affiliates { account_id: AccountId },
    AffiliateLevels { account_id: AccountId, level: u8 },
    AccountsV1,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
struct Contract {
    owner_id: AccountId,
    join_fee: Balance,
    /// 3 values vector, 1 => 0.01% (fee / 10000)
    referral_fees: Vec<u64>,
    accounts: UnorderedMap<AccountId, VAccount>,
    sales: LookupMap<u64, VSale>,
    links: LookupMap<PublicKey, AccountId>,
    num_sales: u64,
    // not used anymore
    accounts_old: UnorderedMap<AccountId, AccountOld>,
}

impl Contract {
    fn internal_remove_link(&mut self, account_id: AccountId, public_key: PublicKey) -> Promise {
        let mut account: Account = self.accounts.get(&account_id).expect("ERR_NO_ACCOUNT").into();
        self.links.remove(&public_key);
        account.links.remove(&public_key);
        self.accounts.insert(&account_id, &VAccount::Current(account));
        Promise::new(env::current_account_id()).delete_key(public_key)
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, join_fee: U128, referral_fees: Vec<u64>) -> Self {
        let mut this = Self {
            owner_id,
            join_fee: join_fee.0,
            referral_fees,
            accounts: UnorderedMap::new(StorageKey::Accounts),
            sales: LookupMap::new(StorageKey::Sales),
            links: LookupMap::new(StorageKey::Links),
            num_sales: 0,
            accounts_old: UnorderedMap::new(StorageKey::AccountsV1),
        };
        this.accounts.insert(
            &this.owner_id,
            &VAccount::Current(Account::new(&this.owner_id, &this.owner_id)),
        );
        // AUDIT: If this contract has other access keys (e.g. full access key), then it should
        // be whitelisted by the owner. Otherwise an attacker may use `create_link` to claim this
        // public key and then delete it, which can be used to remove any public key from this
        // account that was not whitelisted before.
        this
    }

    #[payable]
    pub fn create_link(&mut self, public_key: PublicKey) -> Promise {
        assert_eq!(env::attached_deposit(), CREATE_LINK_AMOUNT);
        let mut account: Account = self
            .accounts
            .get(&env::predecessor_account_id())
            .expect("ERR_NO_ACCOUNT")
            .into();
        assert!(self.links.get(&public_key).is_none(), "ERR_DUPLICATE_KEY");
        self.links
            .insert(&public_key, &env::predecessor_account_id());
        account.links.insert(&public_key);
        self.accounts
            .insert(&env::predecessor_account_id(), &VAccount::Current(account));
        Promise::new(env::current_account_id()).add_access_key(
            public_key,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            "create_account".to_string(),
        )
    }

    pub fn remove_link(&mut self, public_key: PublicKey) -> Promise {
        let account_id = self.links.get(&public_key).expect("ERR_NO_LINK");
        assert_eq!(
            account_id,
            env::predecessor_account_id(),
            "ERR_NOT_LINK_OWNER"
        );
        self.internal_remove_link(env::predecessor_account_id(), public_key)
    }

    /// Only can be called by the access key on this contract.
    /// Can be added via create_link.
    pub fn create_account(&mut self, account_id: AccountId, public_key: PublicKey) -> Promise {
        assert_eq!(env::predecessor_account_id(), env::current_account_id());
        Promise::new(AccountId::new_unchecked(NEAR_ACCOUNT.to_string()))
            .function_call(
                "create_account".to_string(),
                format!(
                    "{{\"new_account_id\": \"{}\", \"new_public_key\": \"{:?}\"}}",
                    account_id, public_key
                )
                .into_bytes(),
                CREATE_ACCOUNT_AMOUNT,
                CREATE_ACCOUNT_GAS,
            )
            .then(ext_self::on_create_account(
                account_id,
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_GAS,
            ))
    }

    /// Callback after account was created by near.
    /// Add an internal account with referrer and remove the link info.
    pub fn on_create_account(&mut self, new_account_id: AccountId) -> Promise {
        assert_eq!(env::predecessor_account_id(), env::current_account_id());
        let referrer = self
            .links
            .get(&env::signer_account_pk())
            .expect("ERR_NO_LINK");
        self.accounts
            .insert(&new_account_id, &VAccount::Current(Account::new(&new_account_id, &referrer)));
        // AUDIT: Predecessor here is `env::current_account_id()`, so it's a bug. I guess you can
        // use `referrer` here instead.
        // BEFORE AUDIT: self.internal_remove_link(env::predecessor_account_id(), env::signer_account_pk())
        self.internal_remove_link(referrer, env::signer_account_pk())
    }

    #[payable]
    pub fn join(&mut self, referrer_id: Option<AccountId>) {
        let account_id = env::predecessor_account_id();
        let referrer_id_unwrapped: AccountId =
            if let Some(referrer_id_unwrapped) = referrer_id {
                if self.accounts.get(&referrer_id_unwrapped).is_some() {
                    referrer_id_unwrapped
                } else {
                    self.owner_id.clone()
                }
            } else {
                self.owner_id.clone()
            };

        assert_ne!(referrer_id_unwrapped, account_id, "SELF_REFERRER");
        assert!(self.accounts.get(&account_id).is_none(), "ERR_ACCOUNT_EXISTS");
        assert_eq!(env::attached_deposit(), self.join_fee, "ERR_FEE");
        self.accounts
            .insert(&account_id, &VAccount::Current(Account::new(&account_id, &referrer_id_unwrapped)));

        // Don't save internal affiliates to save storage and gas
        if self.owner_id != referrer_id_unwrapped {
            self.insert_affiliates(referrer_id_unwrapped, account_id);
        }
    }

    fn insert_affiliate_on_level(&mut self, referrer_id: &AccountId, mut referrer_account: Account, level: u8, affiliate_account_id: &AccountId) {
        let mut affiliates_on_level: UnorderedSet<AccountId> =
            if let Some(affiliates_unwrapped) = referrer_account.affiliates.get(&level) {
                affiliates_unwrapped
            } else {
                UnorderedSet::new(StorageKey::AffiliateLevels {
                    account_id: affiliate_account_id.clone(),
                    level,
                })
            };

        affiliates_on_level.insert(affiliate_account_id);
        referrer_account.affiliates.insert(&level, &affiliates_on_level);

        self.accounts.insert(referrer_id, &VAccount::Current(referrer_account));
    }

    fn insert_affiliates(&mut self, referrer_1_id: AccountId, account_id: AccountId) {
        if let Some(referrer_v_account_1) = self.accounts.get(&referrer_1_id) {
            let referrer_account_1: Account = referrer_v_account_1.into();
            let referrer_2_id = &referrer_account_1.referrer.clone();
            self.insert_affiliate_on_level(&referrer_1_id, referrer_account_1, 0, &account_id);

            if let Some(referrer_v_account_2) = self.accounts.get(referrer_2_id) {
                let referrer_account_2: Account = referrer_v_account_2.into();
                let referrer_3_id = &referrer_account_2.referrer.clone();
                self.insert_affiliate_on_level(referrer_2_id, referrer_account_2, 1, &account_id);

                if let Some(referrer_v_account_3) = self.accounts.get(referrer_3_id) {
                    let referrer_account_3: Account = referrer_v_account_3.into();
                    self.insert_affiliate_on_level(referrer_3_id, referrer_account_3, 2, &account_id);
                }
            }
        }
    }

    pub fn get_join_fee(&self) -> U128 {
        U128(self.join_fee)
    }

    pub fn get_referral_fees(&self) -> Vec<u64> {
        self.referral_fees.clone()
    }

    pub fn get_account(&self, account_id: AccountId) -> AccountOutput {
        let account: Account = self.accounts
            .get(&account_id)
            .expect("ERR_ACCOUNT_DOESNT_EXIST")
            .into();

        account.into()
    }

    pub fn get_num_accounts(&self) -> u64 {
        self.accounts.len()
    }

    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<(AccountId, AccountOutput)> {
        let keys = self.accounts.keys_as_vector();
        let values = self.accounts.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| {
                let account: Account = values.get(index).unwrap().into();
                (keys.get(index).unwrap(), account.into())
            })
            .collect()
    }

    pub fn get_link_referrer(&self, public_key: PublicKey) -> AccountId {
        self.links.get(&public_key).expect("ERR_NO_KEY")
    }

    pub fn get_links(&self, account_id: AccountId) -> Vec<PublicKey> {
        let account: Account = self.accounts.get(&account_id).expect("ERR_NO_ACCOUNT").into();
        account.links.to_vec()
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
    use near_sdk::{PromiseResult, serde_json, testing_env};
    use near_sdk::json_types::U64;
    use near_sdk::test_utils::{accounts, testing_env_with_promise_results};
    use near_sdk::test_utils::VMContextBuilder;

    use crate::sale::{SaleInput, SaleMetadata, SaleType};
    use crate::token_receiver::SaleDeposit;

    use super::*;

    fn contract_with_sale_info(
        max_amount: Balance,
        start_date: u64,
        end_date: u64,
    ) -> (VMContextBuilder, Contract) {
        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let join_fee = U128(1_000_000);
        let referral_fees = vec![10, 20, 30];
        let mut contract = Contract::new(accounts(0), join_fee, referral_fees.clone());
        contract.create_sale(SaleInput {
            metadata: SaleMetadata {
                name: "test".to_string(),
                symbol: "TEST".to_string(),
                description: "".to_string(),
                smart_contract_url: "".to_string(),
                logo_url: "".to_string(),
                output_ticker: "".to_string(),
                project_telegram: None,
                project_medium: None,
                project_twitter: None,
                reward_timestamp: None,
                reward_description: None
            },
            staking_contracts: vec![AccountId::new_unchecked("test.staking".to_string())],
            min_near_deposit: U128(100),
            deposit_token_id: accounts(1),
            claim_available: true,
            distribute_token_id: None,
            distribute_token_decimals: None,
            distribute_supply_amount: None,
            min_buy: U128(100),
            max_buy: U128(10000),
            max_amount: max_amount.map(|a| U128(a)),
            hard_max_amount_limit: max_amount.is_some(),
            start_date: U64(start_date),
            end_date: U64(end_date),
            price: U128(1000),
            whitelist_hash: None,
            limit_per_transaction: U128(100),
            sale_type: SaleType::ByAmount
        });
        assert_eq!(contract.get_referral_fees(), referral_fees);
        assert_eq!(contract.get_join_fee(), join_fee);
        (context, contract)
    }

    fn contract_with_sale() -> (VMContextBuilder, Contract) {
        contract_with_sale_info(Some(10000), 0, 1_000_000_000)
    }

    fn register_account(
        context: &mut VMContextBuilder,
        contract: &mut Contract,
        account_id: AccountId,
    ) {
        testing_env!(context
            .predecessor_account_id(account_id)
            .attached_deposit(1000000)
            .build());
        contract.join();
    }

    fn deposit(context: &mut VMContextBuilder, contract: &mut Contract, account_id: AccountId) {
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        contract.ft_on_transfer(
            account_id,
            U128(100),
            serde_json::to_string(&SaleDeposit {
                sale_id: 0,
                staking_contract: None,
            })
            .unwrap(),
        );
    }

    #[test]
    fn test_basics() {
        let (mut context, mut contract) = contract_with_sale();
        assert_eq!(contract.get_num_sales(), 1);
        assert_eq!(contract.get_sale(0).price.0, 1000);
        assert_eq!(contract.get_sales(0, 10).len(), 1);

        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1000000)
            .build());
        contract.join();
        assert_eq!(contract.get_account(accounts(2)).referrer, accounts(0));

        testing_env!(context.predecessor_account_id(accounts(1)).build());
        contract.ft_on_transfer(
            accounts(2),
            U128(100),
            serde_json::to_string(&SaleDeposit {
                sale_id: 0,
                staking_contract: Some(AccountId::new_unchecked("test.staking".to_string())),
            })
            .unwrap(),
        );

        testing_env_with_promise_results(
            context
                .current_account_id(accounts(0))
                .predecessor_account_id(accounts(0))
                .build(),
            PromiseResult::Successful(vec![]),
        );
        contract.on_get_account_staked_balance(U128(1000), 0, accounts(1), accounts(2), U128(100));

        assert_eq!(contract.get_sale(0).num_account_sales, 1);
        assert_eq!(contract.get_sale(0).collected_amount.0, 100);

        assert_eq!(contract.get_num_accounts(), 2);
        assert_eq!(contract.get_accounts(0, 10).len(), 2);
        assert_eq!(contract.get_account(accounts(2)).referrer, accounts(0));
    }

    #[test]
    #[should_panic(expected = "ERR_NOT_REGISTERED_ACCOUNT")]
    fn test_not_registered() {
        let (mut context, mut contract) = contract_with_sale();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        contract.ft_on_transfer(
            accounts(2),
            U128(100),
            serde_json::to_string(&SaleDeposit {
                sale_id: 0,
                staking_contract: None,
            })
            .unwrap(),
        );
    }

    #[test]
    #[should_panic(expected = "ERR_NO_SALE")]
    fn test_no_sale() {
        let (mut context, mut contract) = contract_with_sale();
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1000000)
            .build());
        contract.join();
        testing_env!(context.predecessor_account_id(accounts(1)).build());
        contract.ft_on_transfer(
            accounts(2),
            U128(100),
            serde_json::to_string(&SaleDeposit {
                sale_id: 1,
                staking_contract: None,
            })
            .unwrap(),
        );
    }

    #[test]
    fn test_create_remove_link() {
        let (mut context, mut contract) = contract_with_sale();
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(1000000)
            .build());
        contract.join();
        testing_env!(context
            .predecessor_account_id(accounts(2))
            .attached_deposit(CREATE_LINK_AMOUNT)
            .build());
        let pk = PublicKey::from_str("qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz").unwrap();
        contract.create_link(pk.clone());
        contract.remove_link(pk);
    }

    #[test]
    #[should_panic = "ERR_SALE_NOT_STARTED"]
    fn test_sale_too_early() {
        let (mut context, mut contract) = contract_with_sale_info(None, 1_000, 1_000_000);
        register_account(&mut context, &mut contract, accounts(2));
        deposit(&mut context, &mut contract, accounts(2));
    }

    #[test]
    #[should_panic = "ERR_SALE_DONE"]
    fn test_sale_too_late() {
        let (mut context, mut contract) = contract_with_sale_info(None, 1_000, 1_000_000);
        register_account(&mut context, &mut contract, accounts(2));
        testing_env!(context
            .block_timestamp(1_000_001)
            .predecessor_account_id(accounts(1))
            .build());
        contract.ft_on_transfer(
            accounts(2),
            U128(100),
            serde_json::to_string(&SaleDeposit {
                sale_id: 0,
                staking_contract: None,
            })
            .unwrap(),
        );
    }
}

'''
'''--- src/migration_0.rs ---
use near_sdk::log;

use crate::*;
use crate::sale::*;

#[near_bindgen]
impl Contract {
    // recreate accounts
    #[private]
    #[init(ignore_state)]
    #[allow(dead_code)]
    pub fn migrate_a0() -> Self {
        #[derive(BorshDeserialize)]
        struct OldContract {
            owner_id: AccountId,
            join_fee: Balance,
            referral_fees: Vec<u64>,
            accounts: UnorderedMap<AccountId, AccountOld>,
            sales: LookupMap<u64, VSale>,
            links: LookupMap<PublicKey, AccountId>,
            num_sales: u64,
        }

        let old_contract: OldContract = env::state_read().expect("Old state doesn't exist");

        Self {
            owner_id: old_contract.owner_id,
            join_fee: old_contract.join_fee,
            referral_fees: old_contract.referral_fees,
            accounts: UnorderedMap::new(StorageKey::AccountsV1),
            sales: old_contract.sales,
            links: old_contract.links,
            num_sales: old_contract.num_sales,
            accounts_old: old_contract.accounts,
        }
    }

    #[private]
    pub fn migrate_a1(&mut self, limit: u64) { // accounts_old transition
        let keys = self.accounts_old.keys_as_vector();
        let account_ids: Vec<AccountId> =
            (0..std::cmp::min(limit,  keys.len()))
                .map(|index| keys.get(index).unwrap().into())
                .collect();

        for account_id in account_ids {
            let account_old: AccountOld = self.accounts_old.get(&account_id).unwrap();
            let account = Account {
                referrer: account_old.referrer,
                links: account_old.links,
                affiliates: LookupMap::new(StorageKey::Affiliates {
                    account_id: account_id.clone(),
                }),
            };
            self.accounts.insert(&account_id, &VAccount::Current(account));
            self.accounts_old.remove(&account_id);
        }

        log!("Pending items: {}", self.accounts_old.len());
    }

}

'''
'''--- src/sale.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::{
    AccountId, Balance, CryptoHash, ext_contract, log, PromiseError, PromiseOrValue, PromiseResult,
    Timestamp,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;
use crate::token_receiver::*;

const ONE_YOCTO: Balance = 1;
const GAS_NEAR_DEPOSIT: Gas = BASE_GAS;
const GAS_AFTER_FT_ON_TRANSFER_NEAR_DEPOSIT: Gas = Gas(40_000_000_000_000);
const GAS_FOR_FT_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_AFTER_FT_TRANSFER: Gas = Gas(10_000_000_000_000);

uint::construct_uint! {
    pub struct U256(4);
}

#[ext_contract(ext_wrap_near)]
pub trait ExtWrapNear {
    /// Deposit NEAR to mint wNEAR tokens to the predecessor account in this contract.
    fn near_deposit(&mut self);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleMetadata {
    /// Project name that is going to be on sale.
    pub name: String,
    /// Symbol (ticker) for the token on sale.
    pub symbol: String,
    /// Project description.
    pub description: String,
    /// Link to project smart contract.
    pub smart_contract_url: String,
    /// Project logo.
    pub logo_url: String,
    /// Symbol for output token
    pub output_ticker: String,
    /// Social medias of the project
    pub project_telegram: Option<String>,
    pub project_medium: Option<String>,
    pub project_twitter: Option<String>,
    pub reward_timestamp: Option<Timestamp>,
    pub reward_description: Option<String>,
}

/// Sale information for creating new sale.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleInput {
    pub metadata: SaleMetadata,
    /// Set of staking contract that will be checked if user has staked with it.
    /// Empty if staking is not required for this sale.
    pub staking_contracts: Vec<AccountId>,
    /// Minimum NEAR staked in the above staking contract.
    pub min_near_deposit: U128,
    /// Token to sell for.
    pub deposit_token_id: AccountId,
    /// Is claim available?
    pub claim_available: bool,
    /// Is refund available
    pub refund_available: bool,
    /// Token for sale
    pub distribute_token_id: Option<AccountId>,
    /// Number of decimals of token for sale, used to calculate purchase amount
    pub distribute_token_decimals: Option<u8>,
    /// Minimum amount of deposit token.
    pub min_buy: U128,
    /// Maximum amount of deposit token for one account.
    pub max_buy: U128,
    /// Maximum amount that can be collected by the sale. A.k.a. target_amount
    pub max_amount: U128,
    /// Max amount is hard requirement or not.
    /// If true, max_amount must be provided.
    pub hard_max_amount_limit: bool,
    /// Start date of the sale.
    pub start_date: U64,
    /// End date of the sale.
    pub end_date: U64,
    /// Price per a single token in decimals of the deposit token.
    pub price: U128,
    /// Hash of the merkle tree of whitelisted accounts.
    pub whitelist_hash: Option<CryptoHash>,
    /// Limit per transaction
    pub limit_per_transaction: U128,
    /// Sale Type
    pub sale_type: SaleType
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleOutput {
    pub sale_id: Option<u64>,
    pub metadata: SaleMetadata,
    pub staking_contracts: Vec<AccountId>,
    pub min_near_deposit: U128,
    pub deposit_token_id: AccountId,
    pub claim_available: bool,
    pub refund_available: bool,
    pub distribute_token_id: Option<AccountId>,
    pub distribute_token_decimals: Option<u8>,
    pub distribute_supply_amount: Option<U128>,
    pub min_buy: U128,
    pub max_buy: U128,
    pub max_amount: U128,
    pub hard_max_amount_limit: bool,
    pub start_date: U64,
    pub end_date: U64,
    pub price: U128,
    pub whitelist_hash: Option<CryptoHash>,
    pub limit_per_transaction: U128,
    pub collected_amount: U128,
    pub num_account_sales: u64,
    pub sale_type: SaleType,
    pub claim_begun: bool
}

/// Sale information.
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VSale {
    First(SaleOld),
    Current(Sale),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum SaleType {
    /// First buyers receive tokens. Sale stops when collected_amount reached
    ByAmount,
    /// Unlimited purchase, proportional distribution. Sale stops when end_date reached
    BySubscription,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct SaleOld {
    pub metadata: SaleMetadata,
    pub staking_contracts: Vec<AccountId>,
    pub min_near_deposit: Balance,
    pub deposit_token_id: AccountId,
    pub min_buy: Balance,
    pub max_buy: Balance,
    pub max_amount: Balance,
    pub hard_max_amount_limit: bool,
    pub start_date: Timestamp,
    pub end_date: Timestamp,
    pub price: Balance,
    pub whitelist_hash: Option<CryptoHash>,
    pub limit_per_transaction: Balance,

    pub collected_amount: Balance,
    pub account_sales: UnorderedMap<AccountId, VSaleAccount>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Sale {
    pub metadata: SaleMetadata,
    pub staking_contracts: Vec<AccountId>,
    pub min_near_deposit: Balance,
    pub deposit_token_id: AccountId,
    pub claim_available: bool,
    pub refund_available: bool,
    pub distribute_token_id: Option<AccountId>,
    pub distribute_token_decimals: Option<u8>,
    /// Total amount of supply (in tokens for distribution). Only for sale_type: Subscription
    pub distribute_supply_amount: Option<Balance>,
    pub min_buy: Balance,
    pub max_buy: Balance,
    /// target_amount
    pub max_amount: Balance,
    pub hard_max_amount_limit: bool,
    pub start_date: Timestamp,
    pub end_date: Timestamp,
    pub price: Balance,
    pub whitelist_hash: Option<CryptoHash>,
    pub limit_per_transaction: Balance,

    pub collected_amount: Balance,
    pub account_sales: UnorderedMap<AccountId, VSaleAccount>,
    pub account_affiliate_rewards: UnorderedMap<AccountId, VAffiliateRewardAccount>,
    pub sale_type: SaleType,
    pub claim_begun: bool
}

impl From<VSale> for Sale {
    fn from(v_sale: VSale) -> Self {
        match v_sale {
            VSale::First(sale) => Sale {
                metadata: sale.metadata,
                staking_contracts: sale.staking_contracts,
                min_near_deposit: sale.min_near_deposit,
                deposit_token_id: sale.deposit_token_id,
                claim_available: false,
                refund_available: false,
                distribute_token_id: None,
                distribute_token_decimals: None,
                distribute_supply_amount: None,
                min_buy: sale.min_buy,
                max_buy: sale.max_buy,
                max_amount: sale.max_amount,
                hard_max_amount_limit: sale.hard_max_amount_limit,
                start_date: sale.start_date,
                end_date: sale.end_date,
                price: sale.price,
                whitelist_hash: sale.whitelist_hash,
                limit_per_transaction: sale.limit_per_transaction,
                collected_amount: sale.collected_amount,
                account_sales: sale.account_sales,
                account_affiliate_rewards: UnorderedMap::new(StorageKey::AccountAffiliateRewards { sale_id: 0 }),
                sale_type: SaleType::ByAmount,
                claim_begun: false,
            },
            VSale::Current(sale) => sale,
        }
    }
}

impl From<VSale> for SaleOutput {
    fn from(v_sale: VSale) -> Self {
        match v_sale {
            VSale::First(sale) => SaleOutput {
                sale_id: None,
                metadata: sale.metadata,
                staking_contracts: sale.staking_contracts,
                min_near_deposit: U128(sale.min_near_deposit),
                deposit_token_id: sale.deposit_token_id,
                claim_available: false,
                refund_available: false,
                distribute_token_id: None,
                distribute_token_decimals: None,
                distribute_supply_amount: None,
                min_buy: U128(sale.min_buy),
                max_buy: U128(sale.max_buy),
                max_amount: U128(sale.max_amount),
                hard_max_amount_limit: sale.hard_max_amount_limit,
                start_date: U64(sale.start_date),
                end_date: U64(sale.end_date),
                price: U128(sale.price),
                whitelist_hash: sale.whitelist_hash,
                limit_per_transaction: sale.limit_per_transaction.into(),
                collected_amount: U128(sale.collected_amount),
                num_account_sales: sale.account_sales.keys_as_vector().len(),
                sale_type: SaleType::ByAmount,
                claim_begun: false
            },
            VSale::Current(sale) => SaleOutput {
                sale_id: None,
                metadata: sale.metadata,
                staking_contracts: sale.staking_contracts,
                min_near_deposit: U128(sale.min_near_deposit),
                deposit_token_id: sale.deposit_token_id,
                claim_available: sale.claim_available,
                refund_available: sale.refund_available,
                distribute_token_id: sale.distribute_token_id,
                distribute_token_decimals: sale.distribute_token_decimals,
                distribute_supply_amount: Some(U128(sale.distribute_supply_amount.unwrap_or(0))),
                min_buy: U128(sale.min_buy),
                max_buy: U128(sale.max_buy),
                max_amount: U128(sale.max_amount),
                hard_max_amount_limit: sale.hard_max_amount_limit,
                start_date: U64(sale.start_date),
                end_date: U64(sale.end_date),
                price: U128(sale.price),
                whitelist_hash: sale.whitelist_hash,
                limit_per_transaction: sale.limit_per_transaction.into(),
                collected_amount: U128(sale.collected_amount),
                num_account_sales: sale.account_sales.keys_as_vector().len(),
                sale_type: sale.sale_type,
                claim_begun: sale.claim_begun
            },
        }
    }
}

impl VSale {
    pub fn new(sale_id: u64, sale_input: SaleInput) -> Self {
        let distribute_supply_amount: Option<Balance> = if sale_input.sale_type == SaleType::BySubscription {
            Some((
                U256::from(sale_input.price.0)
                    * U256::from(sale_input.max_amount.0)
                    / U256::from(u128::pow(10, sale_input.distribute_token_decimals.unwrap() as u32))
            ).as_u128())
        } else {
            None
        };
        Self::Current(Sale {
            metadata: sale_input.metadata,
            staking_contracts: sale_input.staking_contracts,
            min_near_deposit: sale_input.min_near_deposit.0,
            deposit_token_id: sale_input.deposit_token_id,
            claim_available: sale_input.claim_available,
            refund_available: sale_input.refund_available,
            distribute_token_id: sale_input.distribute_token_id,
            distribute_token_decimals: sale_input.distribute_token_decimals,
            distribute_supply_amount,
            min_buy: sale_input.min_buy.0,
            max_buy: sale_input.max_buy.0,
            max_amount: sale_input.max_amount.0,
            hard_max_amount_limit: sale_input.hard_max_amount_limit,
            start_date: sale_input.start_date.0,
            end_date: sale_input.end_date.0,
            price: sale_input.price.0,
            whitelist_hash: sale_input.whitelist_hash,
            limit_per_transaction: sale_input.limit_per_transaction.into(),
            collected_amount: 0,
            account_sales: UnorderedMap::new(StorageKey::AccountSales { sale_id }),
            account_affiliate_rewards: UnorderedMap::new(StorageKey::AccountAffiliateRewards { sale_id }),
            sale_type: sale_input.sale_type,
            claim_begun: false
        })
    }
}

/// Account deposits for the a sale.
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VSaleAccount {
    First(SaleAccountOld),
    Current(SaleAccount),
}

/// Affiliate rewards for the a sale
#[derive(BorshSerialize, BorshDeserialize)]
pub enum VAffiliateRewardAccount {
    Current(AffiliateRewardAccount),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleAccountOld {
    pub amount: U128,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleAccount {
    pub amount: U128,
    pub amount_to_claim: U128,
    pub claimed: U128,
    pub refund: U128,
    pub refunded: U128,
}

impl From<VSaleAccount> for SaleAccount {
    fn from(v_account_sale: VSaleAccount) -> Self {
        match v_account_sale {
            VSaleAccount::Current(account_sale) => account_sale,
            VSaleAccount::First(account_sale) => SaleAccount {
                amount: account_sale.amount,
                amount_to_claim: U128(0),
                claimed: U128(0),
                refund: U128(0),
                refunded: U128(0),
            },
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AffiliateRewardAccount {
    pub amount: U128,
    pub claimed: U128,
}

impl From<VAffiliateRewardAccount> for AffiliateRewardAccount {
    fn from(v_account_affiliate_reward: VAffiliateRewardAccount) -> Self {
        match v_account_affiliate_reward {
            VAffiliateRewardAccount::Current(account_affiliate_reward) => account_affiliate_reward
        }
    }
}

impl Contract {
    fn get_sale_output(sale: VSale, sale_id: u64) -> SaleOutput {
        let mut output: SaleOutput = sale.into();
        output.sale_id = Some(sale_id);
        output
    }

    /// Validates deposit and records it for the given user for give sale.
    /// Returns extra amount if sale is already over capacity.
    pub(crate) fn internal_sale_deposit(
        &mut self,
        sale_id: u64,
        token_id: &AccountId,
        sender_id: &AccountId,
        staked_amount: Balance,
        amount: Balance,
    ) -> Balance {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert_eq!(&sale.deposit_token_id, token_id, "ERR_WRONG_TOKEN");
        assert!(amount <= sale.limit_per_transaction, "ERR_LIMIT_PER_TX");
        assert!(
            staked_amount >= sale.min_near_deposit,
            "ERR_NOT_ENOUGH_STAKED"
        );
        // TODO: add check for the whitelist hash.
        let deposit_amount = if !sale.hard_max_amount_limit {
            amount
        } else {
            std::cmp::min(
                amount,
                sale.max_amount - sale.collected_amount,
            )
        };
        let mut account_sale = sale
            .account_sales
            .get(sender_id)
            .map(|account_sale| account_sale.into())
            .unwrap_or(SaleAccount {
                amount: U128(0),
                amount_to_claim: U128(0),
                claimed: U128(0),
                refund: U128(0),
                refunded: U128(0),
            });
        account_sale.amount = U128(account_sale.amount.0 + deposit_amount);
        assert!(
            sale.max_buy >= account_sale.amount.0 && sale.min_buy <= account_sale.amount.0,
            "ERR_WRONG_AMOUNT"
        );

        let fees = self.referral_fees.clone();
        if let Some(referrer_v_account_1) = self.accounts.get(sender_id) {
            let referrer_account_1: Account = referrer_v_account_1.into();
            let reward_1 = deposit_amount * fees[0] as u128 / REFERRAL_FEE_DENOMINATOR;
            self.internal_insert_affiliate(&mut sale, &referrer_account_1.referrer, reward_1);
            if let Some(referrer_v_account_2) = self.accounts.get(&referrer_account_1.referrer) {
                let referrer_account_2: Account = referrer_v_account_2.into();
                let reward_2 = deposit_amount * fees[1] as u128 / REFERRAL_FEE_DENOMINATOR;
                self.internal_insert_affiliate(&mut sale, &referrer_account_2.referrer, reward_2);
                if let Some(referrer_v_account_3) = self.accounts.get(&referrer_account_2.referrer) {
                    let referrer_account_3: Account = referrer_v_account_3.into();
                    let reward_3 = deposit_amount * fees[2] as u128 / REFERRAL_FEE_DENOMINATOR;
                    self.internal_insert_affiliate(&mut sale, &referrer_account_3.referrer, reward_3);
                }
            }
        }

        sale.account_sales.insert(sender_id, &VSaleAccount::Current(account_sale));
        sale.collected_amount += deposit_amount;
        self.sales.insert(&sale_id, &VSale::Current(sale));
        amount - deposit_amount
    }

    pub(crate) fn internal_insert_affiliate(&mut self, sale: &mut Sale, account_id: &AccountId, amount: u128) {
        let account_affiliate_reward =
            if let Some(v_account_affiliate_reward) = sale.account_affiliate_rewards.get(account_id) {
                let mut account_affiliate_reward: AffiliateRewardAccount = v_account_affiliate_reward.into();
                account_affiliate_reward.amount = U128::from(account_affiliate_reward.amount.0 + amount);
                account_affiliate_reward
            } else {
                AffiliateRewardAccount {
                    amount: U128::from(amount),
                    claimed: U128::from(0),
                }
            };

        sale.account_affiliate_rewards.insert(account_id, &VAffiliateRewardAccount::Current(account_affiliate_reward));
    }

    pub(crate) fn internal_finalize_near_deposit(
        &mut self,
        return_amount: Balance,
        sender_id: AccountId,
        deposit_amount: Balance,
    ) -> PromiseOrValue<U128> {
        let wrap_amount = deposit_amount - return_amount;
        if wrap_amount > 0 {
            // Assuming it will succeed
            ext_wrap_near::near_deposit(
                AccountId::new_unchecked(WRAP_NEAR_ACCOUNT.to_string()),
                wrap_amount,
                GAS_NEAR_DEPOSIT,
            );
        }
        if return_amount > 0 {
            Promise::new(sender_id).transfer(return_amount).into()
        } else {
            PromiseOrValue::Value(U128(0))
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_referrals(&self, account_id: AccountId) -> Vec<AccountId> {
        let mut referrals = [].to_vec();

        if let Some(referrer_v_account_1) = self.accounts.get(&account_id) {
            let referrer_account_1: Account = referrer_v_account_1.into();
            referrals.push(referrer_account_1.referrer.clone());
            if let Some(referrer_v_account_2) = self.accounts.get(&referrer_account_1.referrer) {
                let referrer_account_2: Account = referrer_v_account_2.into();
                referrals.push(referrer_account_2.referrer.clone());
                if let Some(referrer_v_account_3) = self.accounts.get(&referrer_account_2.referrer) {
                    let referrer_account_3: Account = referrer_v_account_3.into();
                    referrals.push(referrer_account_3.referrer);
                }
            }
        }

        referrals
    }

    pub fn get_affiliates(&self, account_id: AccountId) -> (Vec<AccountId>, Vec<AccountId>, Vec<AccountId>) {
        let account: Account = self.accounts.get(&account_id).expect("ERR_NO_ACCOUNT").into();
        (
            internal_get_affiliates_vector(&account.affiliates, 0),
            internal_get_affiliates_vector(&account.affiliates, 1),
            internal_get_affiliates_vector(&account.affiliates, 2),
        )
    }

    pub fn get_sale_amount(&self, sale_id: u64, account_id: AccountId) -> U128 {
        let sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        if let Some(sale_account) = sale.account_sales.get(&account_id) {
            let sale_account: SaleAccount = sale_account.into();
            match sale.sale_type {
                SaleType::ByAmount => sale_account.amount,
                SaleType::BySubscription => {
                    U128::from(
                        get_amount_by_subscription(sale_account.amount.0, sale.collected_amount, sale.distribute_supply_amount.expect("ERR_MUST_HAVE_SUPPLY_AMOUNT"))
                    )
                }
            }
        } else {
            U128::from(0)
        }
    }

    fn internal_calculate_purchase(&mut self, sale_id: u64) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();

        let account_id = env::predecessor_account_id();
        let distribute_token_decimals = sale.distribute_token_decimals.expect("ERR_NO_TOKEN_DECIMALS");

        if let Some(v_sale_account) = sale.account_sales.get(&account_id) {
            let mut account_sale: SaleAccount = v_sale_account.into();

            assert_ne!(account_sale.amount.0, 0, "ERR_NO_ALLOCATION");

            let deposit_amount = account_sale.amount.0;

            let amount_to_claim: u128 =
                if account_sale.claimed.0 == 0 {
                    let total_amount_to_claim: u128 = (
                        U256::from(u128::pow(10, distribute_token_decimals as u32))
                            * U256::from(deposit_amount)
                            / U256::from(sale.price)
                    ).as_u128();

                    let total_filled_amount: u128 = (
                        U256::from(u128::pow(10, distribute_token_decimals as u32))
                            * U256::from(sale.collected_amount)
                            / U256::from(sale.price)
                    ).as_u128();

                    match sale.sale_type {
                        SaleType::ByAmount => total_amount_to_claim,
                        SaleType::BySubscription => {
                            if sale.max_amount >= sale.collected_amount {
                                total_amount_to_claim
                            } else {
                                get_amount_by_subscription(total_amount_to_claim, total_filled_amount, sale.distribute_supply_amount.expect("ERR_MUST_HAVE_SUPPLY_AMOUNT"))
                            }
                        }
                    }
                } else {
                    account_sale.claimed.0
                };

            if account_sale.amount_to_claim.0 == 0 && amount_to_claim > 0 {
                account_sale.amount_to_claim = U128(amount_to_claim);
            }

            if sale.sale_type == SaleType::BySubscription {
                let client_purchase_amount: u128 = (
                    U256::from(amount_to_claim)
                        * U256::from(sale.price)
                        / U256::from(u128::pow(10, distribute_token_decimals as u32))
                ).as_u128();

                if account_sale.refund.0 == 0 && deposit_amount > client_purchase_amount {
                    account_sale.refund = U128(deposit_amount - client_purchase_amount);
                }
            }

            sale.account_sales.insert(&account_id, &VSaleAccount::Current(account_sale));
            self.sales.insert(&sale_id, &VSale::Current(sale));
        } else {
            panic!("ERR_NO_DATA");
        }
    }

    pub fn claim_purchase(&mut self, sale_id: u64) -> Promise {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.claim_available, "ERR_CLAIM_NOT_AVAILABLE");
        assert_ne!(sale.price, 0, "ERR_NO_SALE_PRICE");
        assert!(env::block_timestamp() > sale.end_date, "ERR_SALE_IN_PROGRESS");

        let distribute_token_id = sale.distribute_token_id.clone().expect("ERR_NO_TOKEN_ID");

        let account_id = env::predecessor_account_id();

        self.internal_calculate_purchase(sale_id);

        if let Some(v_sale_account) = sale.account_sales.get(&account_id) {
            let mut account_sale: SaleAccount = v_sale_account.into();

            assert_eq!(account_sale.claimed.0, 0, "ERR_ALREADY_CLAIMED");

            let amount_to_claim = account_sale.amount_to_claim;
            assert_ne!(amount_to_claim.0, 0, "ERR_NOTHING_TO_CLAIM");
            account_sale.claimed = amount_to_claim;

            if !sale.claim_begun {
                sale.claim_begun = true;
            }

            log!("Amount to claim: {}", amount_to_claim.0);

            sale.account_sales.insert(&account_id, &VSaleAccount::Current(account_sale));
            self.sales.insert(&sale_id, &VSale::Current(sale));

            self.withdraw_purchase(account_id,
                                   amount_to_claim.0,
                                   distribute_token_id,
                                   sale_id)
        }
        else {
            panic!("ERR_NO_DATA")
        }
    }

    pub fn claim_refund(&mut self, sale_id: u64) -> Promise {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.sale_type == SaleType::BySubscription, "ERR_REFUND_NOT_ALLOWED");
        assert!(sale.refund_available, "ERR_REFUND_NOT_AVAILABLE");
        assert!(env::block_timestamp() > sale.end_date, "ERR_SALE_IN_PROGRESS");

        let account_id = env::predecessor_account_id();

        self.internal_calculate_purchase(sale_id);

        if let Some(v_sale_account) = sale.account_sales.get(&account_id) {
            let mut account_sale: SaleAccount = v_sale_account.into();

            assert_ne!(account_sale.refund.0, 0, "ERR_NOTHING_TO_REFUND");
            assert_eq!(account_sale.refunded.0, 0, "ERR_ALREADY_REFUNDED");
            assert_ne!(account_sale.claimed.0, 0, "ERR_MUST_CLAIM_BEFORE_REFUND");

            let amount_to_refund: U128 = account_sale.refund;
            account_sale.refunded = amount_to_refund;

            log!("Amount to refund: {}", amount_to_refund.0);
            let token_account_id = sale.deposit_token_id.clone();

            sale.account_sales
                .insert(&account_id, &VSaleAccount::Current(account_sale));
            self.sales.insert(&sale_id, &VSale::Current(sale));

            self.refund_purchase(account_id,
                                 amount_to_refund.0,
                                 token_account_id,
                                 sale_id)
        } else {
            panic!("ERR_NO_DATA");
        }
    }

    pub fn claim_affiliate_reward(&mut self, sale_id: u64) -> Promise {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        let distribute_token_decimals = sale.distribute_token_decimals.expect("ERR_NO_TOKEN_DECIMALS");
        let account_id = env::predecessor_account_id();

        assert!(sale.refund_available, "ERR_NOT_AVAILABLE");
        assert!(sale.sale_type == SaleType::BySubscription && sale.max_amount < sale.collected_amount, "SALE_BY_SUBSCRIPTION_FAILED");
        assert!(env::block_timestamp() > sale.end_date, "ERR_SALE_IN_PROGRESS");

        if let Some(v_sale_account) = sale.account_affiliate_rewards.get(&account_id) {
            let mut account_affiliate_reward: AffiliateRewardAccount = v_sale_account.into();

            assert_ne!(account_affiliate_reward.amount.0, 0, "ERR_NOTHING_TO_CLAIM");
            assert_eq!(account_affiliate_reward.claimed.0, 0, "ERR_ALREADY_CLAIMED");

            let deposit_amount = account_affiliate_reward.amount.0;

            let total_amount_to_claim: u128 = (
                U256::from(u128::pow(10, distribute_token_decimals as u32))
                    * U256::from(deposit_amount)
                    / U256::from(sale.price)
            ).as_u128();

            let total_filled_amount: u128 = (
                U256::from(u128::pow(10, distribute_token_decimals as u32))
                    * U256::from(sale.collected_amount)
                    / U256::from(sale.price)
            ).as_u128();

            let amount_to_claim: u128 = match sale.sale_type {
                SaleType::ByAmount => total_amount_to_claim,
                SaleType::BySubscription => {
                    get_amount_by_subscription(total_amount_to_claim, total_filled_amount, sale.distribute_supply_amount.expect("ERR_MUST_HAVE_SUPPLY_AMOUNT"))
                }
            };

            assert_ne!(amount_to_claim, 0, "ERR_NOTHING_TO_CLAIM");
            log!("Amount to claim: {}", amount_to_claim);

            account_affiliate_reward.claimed = U128(amount_to_claim);

            let deposit_token_id = sale.deposit_token_id.clone();

            sale.account_affiliate_rewards.insert(&account_id, &VAffiliateRewardAccount::Current(account_affiliate_reward));
            self.sales.insert(&sale_id, &VSale::Current(sale));

            self.withdraw_affiliate_reward(account_id, amount_to_claim, deposit_token_id, sale_id)
        } else {
            panic!("ERR_NO_DATA");
        }
    }

    #[payable]
    pub fn deposit_near(&mut self, sale_deposit: SaleDeposit) -> PromiseOrValue<U128> {
        let sender_id = env::predecessor_account_id();
        let token_id = AccountId::new_unchecked(WRAP_NEAR_ACCOUNT.to_string());
        let amount = env::attached_deposit();
        match self.internal_ft_on_transfer(token_id, sender_id.clone(), amount.into(), sale_deposit)
        {
            PromiseOrValue::Promise(promise) => promise
                .then(ext_self::after_ft_on_transfer_near_deposit(
                    sender_id,
                    U128(amount),
                    env::current_account_id(),
                    NO_DEPOSIT,
                    GAS_AFTER_FT_ON_TRANSFER_NEAR_DEPOSIT,
                ))
                .into(),
            PromiseOrValue::Value(value) => {
                self.internal_finalize_near_deposit(value.0, sender_id, amount)
            }
        }
    }

    pub fn create_sale(&mut self, sale: SaleInput) -> u64 {
        assert_eq!(
            self.owner_id,
            env::predecessor_account_id(),
            "ERR_MUST_BE_OWNER"
        );

        assert!(
            !sale.hard_max_amount_limit
                || (sale.hard_max_amount_limit && sale.max_amount.0 > 0),
            "ERR_MUST_HAVE_MAX_AMOUNT"
        );

        assert!(sale.distribute_token_decimals.expect("ERR_NO_TOKEN_DECIMALS") > 0, "WRONG_DECIMALS");

        self.sales
            .insert(&self.num_sales, &VSale::new(self.num_sales, sale));
        let sale_id = self.num_sales;
        self.num_sales += 1;
        sale_id
    }

    #[private]
    pub fn remove_sale(&mut self, sale_id: u64) {
        let sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert_eq!(sale.collected_amount, 0, "SALE_NOT_EMPTY");
        self.sales.remove(&sale_id);
    }

    #[private]
    pub fn update_referral_fees(&mut self, referral_fees: Vec<u64>) {
        assert_eq!(referral_fees.len(), 3, "WRONG_LENGTH");
        self.referral_fees = referral_fees;
    }

    #[private]
    pub fn update_sale_dates(&mut self, sale_id: u64, start_date: U64, end_date: U64) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(
            sale.collected_amount < sale.max_amount,
            "ERR_SALE_DONE"
        );
        sale.start_date = start_date.into();
        sale.end_date = end_date.into();
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    #[private]
    pub fn update_sale_distribute_token_id(&mut self, sale_id: u64, distribute_token_id: AccountId) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.distribute_token_id.is_none(), "ERR_ALREADY_SET");
        sale.distribute_token_id = Some(distribute_token_id);
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    #[private]
    pub fn update_sale_price(&mut self, sale_id: u64, price: U128) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(!sale.claim_begun, "ERR_CLAIM_ALREADY_BEGUN");
        let timestamp = env::block_timestamp();
        assert!(
            timestamp < sale.start_date || timestamp > sale.end_date,
            "ERR_SALE_IS_ACTIVE"
        );
        sale.price = price.0;
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    #[private]
    pub fn update_sale_distribute_token_decimals(&mut self, sale_id: u64, distribute_token_decimals: u8) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.distribute_token_decimals.is_none(), "ERR_ALREADY_SET");
        sale.distribute_token_decimals = Some(distribute_token_decimals);
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    #[private]
    pub fn update_sale_claim_available(&mut self, sale_id: u64, claim_available: bool) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.distribute_token_id.is_some(), "ERR_NOT_ENOUGH_DATA");
        assert!(sale.distribute_token_decimals.is_some(), "ERR_NOT_ENOUGH_DATA");
        sale.claim_available = claim_available;
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    #[private]
    pub fn update_sale_refund_available(&mut self, sale_id: u64, refund_available: bool) {
        let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        assert!(sale.distribute_token_id.is_some(), "ERR_NOT_ENOUGH_DATA");
        assert!(sale.distribute_token_decimals.is_some(), "ERR_NOT_ENOUGH_DATA");
        sale.refund_available = refund_available;
        self.sales.insert(&sale_id, &VSale::Current(sale));
    }

    pub fn get_num_sales(&self) -> u64 {
        self.num_sales
    }

    pub fn get_sale(&self, sale_id: u64) -> SaleOutput {
        Contract::get_sale_output(self.sales.get(&sale_id).expect("ERR_NO_SALE"), sale_id)
    }

    pub fn get_sales(&self, from_index: u64, limit: u64) -> Vec<SaleOutput> {
        (from_index..std::cmp::min(from_index + limit, self.num_sales))
            .filter_map(|sale_id| self.sales.get(&sale_id).map(|sale| Contract::get_sale_output(sale, sale_id)))
            .collect()
    }

    pub fn get_sale_accounts(
        &self,
        sale_id: u64,
        from_index: u64,
        limit: u64,
    ) -> Vec<(AccountId, SaleAccount)> {
        let sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        let keys = sale.account_sales.keys_as_vector();
        let values = sale.account_sales.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap().into()))
            .collect()
    }

    pub fn get_sale_account(&self, sale_id: u64, account_id: AccountId) -> SaleAccount {
        let sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        if let Some(sale_account) = sale.account_sales.get(&account_id) {
            sale_account.into()
        } else {
            SaleAccount {
                amount: U128(0),
                amount_to_claim: U128(0),
                claimed: U128(0),
                refund: U128(0),
                refunded: U128(0),
            }
        }
    }

    pub fn get_affiliate_account(&self, sale_id: u64, account_id: AccountId) -> AffiliateRewardAccount {
        let sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();
        if let Some(sale_account) = sale.account_affiliate_rewards.get(&account_id) {
            sale_account.into()
        } else {
            AffiliateRewardAccount {
                amount: U128::from(0),
                claimed: U128::from(0),
            }
        }
    }

    pub fn on_get_account_staked_balance(
        &mut self,
        #[callback] staked_amount: U128,
        sale_id: u64,
        token_id: AccountId,
        sender_id: AccountId,
        deposit_amount: U128,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "ERR_NOT_OWNER"
        );
        log!("{} stake: {}", sender_id, staked_amount.0);
        PromiseOrValue::Value(U128(self.internal_sale_deposit(
            sale_id,
            &token_id,
            &sender_id,
            staked_amount.0,
            deposit_amount.0,
        )))
    }

    #[private]
    pub fn after_ft_on_transfer_near_deposit(
        &mut self,
        #[callback_result] return_amount: Result<U128, PromiseError>,
        sender_id: AccountId,
        deposit_amount: U128,
    ) -> PromiseOrValue<U128> {
        self.internal_finalize_near_deposit(
            return_amount.map(|v| v.0).unwrap_or(0),
            sender_id,
            deposit_amount.0,
        )
    }

    pub(crate) fn withdraw_purchase(&mut self,
                                    recipient_account_id: AccountId,
                                    amount_to_claim: Balance,
                                    claim_token_account_id: AccountId,
                                    sale_id: u64) -> Promise {
        ext_fungible_token::ft_transfer(
            recipient_account_id.clone(),
            amount_to_claim.into(),
            Some(format!("Claim {} of {}. Sale #{}", amount_to_claim, claim_token_account_id, sale_id)),
            claim_token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
            .then(ext_self::after_withdraw_purchase(
                recipient_account_id,
                amount_to_claim.into(),
                sale_id,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_AFTER_FT_TRANSFER,
            ))
    }

    #[private]
    pub fn after_withdraw_purchase(
        &mut self,
        account_id: AccountId,
        amount_to_claim: U128,
        sale_id: u64,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let mut sale: Sale = self
                .sales
                .get(&sale_id)
                .expect("ERR_NO_SALE")
                .into();

            if let Some(v_sale_account) = sale.account_sales.get(&account_id) {
                let mut account_sale: SaleAccount = v_sale_account.into();
                account_sale.claimed = U128::from(account_sale.claimed.0 - amount_to_claim.0);
                sale.account_sales.insert(&account_id, &VSaleAccount::Current(account_sale));
                self.sales.insert(&sale_id, &VSale::Current(sale));
                log!("Purchase withdraw for {} failed. Tokens to recharge: {}",account_id, amount_to_claim.0);
            }
        }
        promise_success
    }

    pub(crate) fn refund_purchase(&mut self,
                                  recipient_account_id: AccountId,
                                  amount_to_refund: Balance,
                                  token_account_id: AccountId,
                                  sale_id: u64) -> Promise {
        ext_fungible_token::ft_transfer(
            recipient_account_id.clone(),
            amount_to_refund.into(),
            Some(format!("Refund {} of {}. Sale #{}", amount_to_refund, token_account_id, sale_id)),
            token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
            .then(ext_self::after_refund_purchase(
                recipient_account_id,
                amount_to_refund.into(),
                sale_id,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_AFTER_FT_TRANSFER,
            ))
    }

    #[private]
    pub fn after_refund_purchase(
        &mut self,
        account_id: AccountId,
        amount_to_refund: U128,
        sale_id: u64,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();

            if let Some(v_sale_account) = sale.account_sales.get(&account_id) {
                let mut account_sale: SaleAccount = v_sale_account.into();
                account_sale.refunded = U128::from(account_sale.refunded.0 - amount_to_refund.0);
                sale.account_sales.insert(&account_id, &VSaleAccount::Current(account_sale));
                self.sales.insert(&sale_id, &VSale::Current(sale));
                log!("Purchase refund for {} failed. Tokens to recharge: {}", account_id, amount_to_refund.0);
            }
        }

        promise_success
    }

    pub(crate) fn withdraw_affiliate_reward(&mut self,
                                            recipient_account_id: AccountId,
                                            amount: Balance,
                                            token_account_id: AccountId,
                                            sale_id: u64) -> Promise {
        ext_fungible_token::ft_transfer(
            recipient_account_id.clone(),
            amount.into(),
            Some(format!("Claim affiliate rewards {} of {}. Sale #{}", amount, token_account_id, sale_id)),
            token_account_id,
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER,
        )
            .then(ext_self::after_withdraw_affiliate_reward(
                recipient_account_id,
                amount.into(),
                sale_id,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_AFTER_FT_TRANSFER,
            ))
    }

    #[private]
    pub fn after_withdraw_affiliate_reward(
        &mut self,
        account_id: AccountId,
        amount: U128,
        sale_id: u64,
    ) -> bool {
        let promise_success = is_promise_success();
        if !promise_success {
            let mut sale: Sale = self.sales.get(&sale_id).expect("ERR_NO_SALE").into();

            if let Some(v_sale_account) = sale.account_affiliate_rewards.get(&account_id) {
                let mut account_affiliate_reward: AffiliateRewardAccount = v_sale_account.into();
                account_affiliate_reward.claimed = U128::from(account_affiliate_reward.claimed.0 - amount.0);
                sale.account_affiliate_rewards.insert(&account_id, &VAffiliateRewardAccount::Current(account_affiliate_reward));
                self.sales.insert(&sale_id, &VSale::Current(sale));
                log!("Affiliate rewards withdraw for {} failed. Tokens to recharge: {}",account_id, amount.0);
            }
        }
        promise_success
    }
}

fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

fn get_amount_by_subscription(amount_to_claim: Balance, collected_amount: Balance, supply_amount: Balance) -> u128 {
    (
        U256::from(amount_to_claim)
            * U256::from(supply_amount)
            / U256::from(collected_amount)
    ).as_u128()
}

fn internal_get_affiliates_vector(affiliates: &LookupMap<u8, UnorderedSet<AccountId>>, level: u8) -> Vec<AccountId> {
    if let Some(affiliates_unwrapped) =  affiliates.get(&level){
        affiliates_unwrapped.to_vec()
    }
    else{
        [].to_vec()
    }
}

'''
'''--- src/token_receiver.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, ext_contract, serde_json};

use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;

use crate::sale::Sale;
use crate::*;

const GAS_GET_ACCOUNT_STAKED_BALANCE: Gas = Gas(25_000_000_000_000);
const GAS_ON_GET_ACCOUNT_STAKED_BALANCE: Gas = Gas(25_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    /// Check the staked balance of the given account.
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128;
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleDeposit {
    pub sale_id: u64,
    /// Optional argument to point to the contract where this user has staked if sale requires this.
    pub staking_contract: Option<AccountId>,
}

impl Contract {
    pub fn internal_ft_on_transfer(
        &mut self,
        token_id: AccountId,
        sender_id: AccountId,
        amount: U128,
        sale_deposit: SaleDeposit,
    ) -> PromiseOrValue<U128> {
        // Check that account is registered.
        let _ = self
            .accounts
            .get(&sender_id)
            .expect("ERR_NOT_REGISTERED_ACCOUNT");
        let sale: Sale = self
            .sales
            .get(&sale_deposit.sale_id)
            .expect("ERR_NO_SALE")
            .into();
        assert_eq!(sale.deposit_token_id, token_id, "ERR_WRONG_TOKEN");
        if sale.hard_max_amount_limit {
            assert!(
                sale.collected_amount < sale.max_amount,
                "ERR_SALE_DONE"
            );
        }
        let timestamp = env::block_timestamp();
        assert!(timestamp >= sale.start_date, "ERR_SALE_NOT_STARTED");
        assert!(
            timestamp >= sale.start_date && timestamp <= sale.end_date,
            "ERR_SALE_DONE"
        );

        // Send call to check how much is staked if staking is required.
        if sale.staking_contracts.len() > 0 {
            let staking_contract = sale_deposit
                .staking_contract
                .expect("ERR_MUST_HAVE_STAKING_CONTRACT");
            assert!(
                sale.staking_contracts.contains(&staking_contract),
                "ERR_NOT_WHITELISTED_STAKING_CONTRACT"
            );
            PromiseOrValue::Promise(
                ext_staking_pool::get_account_staked_balance(
                    sender_id.clone(),
                    staking_contract,
                    NO_DEPOSIT,
                    GAS_GET_ACCOUNT_STAKED_BALANCE,
                )
                .then(ext_self::on_get_account_staked_balance(
                    sale_deposit.sale_id,
                    token_id,
                    sender_id,
                    amount,
                    env::current_account_id(),
                    NO_DEPOSIT,
                    GAS_ON_GET_ACCOUNT_STAKED_BALANCE,
                )),
            )
        } else {
            PromiseOrValue::Value(U128(self.internal_sale_deposit(
                sale_deposit.sale_id,
                &token_id,
                &sender_id,
                0,
                amount.0,
            )))
        }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    /// Record the AccountSale for given Sale.
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let sale_deposit = serde_json::from_str::<SaleDeposit>(&msg).expect("ERR_MSG_WRONG_FORMAT");
        self.internal_ft_on_transfer(
            env::predecessor_account_id(),
            sender_id,
            amount,
            sale_deposit,
        )
    }
}

'''