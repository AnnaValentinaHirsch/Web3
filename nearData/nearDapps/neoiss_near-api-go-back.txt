*GitHub Repository "neoiss/near-api-go-back"*

'''--- .github/workflows/lint.yml ---
name: lint
on:
  push:
    tags:
      - v*
    branches:
      - master
  pull_request:

jobs:
  golangci:
    name: "Run linter (golangci-lint)"
    runs-on: "ubuntu-latest"
    steps:
      - name: "Checkout code"
        uses: "actions/checkout@v2"

      - name: "Run golangci-lint"
        id: "run-linter"
        uses: "golangci/golangci-lint-action@v2"

'''
'''--- README.md ---
# near-api-go

[![Go Reference](https://pkg.go.dev/badge/github.com/eteu-technologies/near-api-go.svg)](https://pkg.go.dev/github.com/eteu-technologies/near-api-go)
[![CI](https://github.com/eteu-technologies/near-api-go/actions/workflows/lint.yml/badge.svg)](https://github.com/eteu-technologies/near-api-go/actions/workflows/lint.yml)

**WARNING**: This library is still work in progress. While it covers about 90% of the use-cases, it does not have many batteries included.

## Usage

```
go get github.com/eteu-technologies/near-api-go
```

### Notes

What this library does not (and probably won't) provide:
- Access key caching & management
- Retry solution for `TransactionSendAwait`

What this library doesn't have yet:
- Response types for RPC queries marked as experimental by NEAR (prefixed with `EXPERIMENTAL_`)
- Few type definitions (especially complex ones, for example it's not very comfortable to reflect enum types in Go)

## Examples

See [cmd/](cmd/) in this repo for more fully featured CLI examples.
See [NEARKit](https://github.com/eteu-technologies/nearkit) for a project which makes use of this API.

### Query latest block on NEAR testnet
```go
package main

import (
	"context"
	"fmt"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/client/block"
)

func main() {
	rpc, err := client.NewClient("https://rpc.testnet.near.org")
	if err != nil {
		panic(err)
	}

	ctx := context.Background()

	res, err := rpc.BlockDetails(ctx, block.FinalityFinal())
	if err != nil {
		panic(err)
	}

	fmt.Println("latest block: ", res.Header.Hash)
}
```

### Transfer 1 NEAR token between accounts

```go
package main

import (
	"context"
	"fmt"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

var (
	sender    = "mikroskeem.testnet"
	recipient = "mikroskeem2.testnet"

	senderPrivateKey = `ed25519:...`
)

func main() {
	rpc, err := client.NewClient("https://rpc.testnet.near.org")
	if err != nil {
		panic(err)
	}

	keyPair, err := key.NewBase58KeyPair(senderPrivateKey)
	if err != nil {
		panic(err)
	}

	ctx := client.ContextWithKeyPair(context.Background(), keyPair)
	res, err := rpc.TransactionSendAwait(ctx, sender, recipient, []action.Action{
		action.NewTransfer(types.NEARToYocto(1)),
	})
	if err != nil {
		panic(err)
	}

	fmt.Printf("https://rpc.testnet.near.org/transactions/%s\n", res.Transaction.Hash)
}
```

## License

MIT

'''
'''--- cmd/block/main.go ---
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/davecgh/go-spew/spew"
	"github.com/urfave/cli/v2"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/config"
)

func main() {
	app := &cli.App{
		Name:  "block",
		Usage: "View latest or specified block info",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "network",
				Usage:   "NEAR network",
				Value:   "testnet",
				EnvVars: []string{"NEAR_ENV"},
			},
			&cli.StringFlag{
				Name:  "block",
				Usage: "Block hash",
			},
		},
		Action: entrypoint,
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func entrypoint(cctx *cli.Context) (err error) {
	networkID := cctx.String("network")
	network, ok := config.Networks[networkID]
	if !ok {
		return fmt.Errorf("unknown network '%s'", networkID)
	}

	rpc, err := client.NewClient(network.NodeURL)
	if err != nil {
		return fmt.Errorf("failed to create rpc client: %w", err)
	}

	characteristic := block.FinalityFinal()
	if v := cctx.String("block"); v != "" {
		characteristic = block.BlockHashRaw(v)
	}

	blockDetailsResp, err := rpc.BlockDetails(context.Background(), characteristic)
	if err != nil {
		return fmt.Errorf("failed to query latest block info: %w", err)
	}

	spew.Dump(blockDetailsResp)

	return
}

'''
'''--- cmd/edkeypair/main.go ---
package main

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"os"

	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

func main() {
	keyPair, err := key.GenerateKeyPair(key.KeyTypeED25519, rand.Reader)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate keypair: %s\n", err)
		os.Exit(1)
	}

	pub := keyPair.PublicKey

	_ = json.NewEncoder(os.Stdout).Encode(struct {
		AccountID  string              `json:"account_id"`
		PublicKey  key.Base58PublicKey `json:"public_key"`
		PrivateKey string              `json:"private_key"`
	}{pub.ToPublicKey().Hash(), pub, keyPair.PrivateEncoded()})
}

'''
'''--- cmd/funcall/main.go ---
package main

import (
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/urfave/cli/v2"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/config"
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

func main() {
	app := &cli.App{
		Name:  "funcall",
		Usage: "Calls function on a smart contract",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "account",
				Usage: "Account id",
			},
			&cli.StringFlag{
				Name:     "target",
				Required: true,
				Usage:    "Account id whose smart contract to call",
			},
			&cli.StringFlag{
				Name:  "mode",
				Usage: "Call mode, either 'view' or 'change'",
				Value: "view",
			},
			&cli.StringFlag{
				Name:  "deposit",
				Usage: "Amount of NEAR to deposit",
			},
			&cli.Uint64Flag{
				Name:  "gas",
				Usage: "Amount of gas to attach for this transaction",
				Value: types.DefaultFunctionCallGas,
			},
			&cli.StringFlag{
				Name:     "method",
				Usage:    "Method to call on specified contract",
				Required: true,
			},
			&cli.StringFlag{
				Name:  "args",
				Usage: "Arguments to pass for specified method. Accepts both JSON and Base64 payload",
			},
			&cli.StringFlag{
				Name:    "network",
				Usage:   "NEAR network",
				Value:   "testnet",
				EnvVars: []string{"NEAR_ENV"},
			},
		},
		Action: entrypoint,
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func entrypoint(cctx *cli.Context) (err error) {
	network, ok := config.Networks[cctx.String("network")]
	if !ok {
		return fmt.Errorf("unknown network '%s'", cctx.String("network"))
	}

	rpc, err := client.NewClient(network.NodeURL)
	if err != nil {
		return fmt.Errorf("failed to create rpc client: %w", err)
	}

	log.Printf("near network: %s", rpc.NetworkAddr())

	var args []byte = nil
	if a := cctx.String("args"); cctx.IsSet("args") {
		args = []byte(a)
	}

	switch cctx.String("mode") {
	case "view":
		if err := viewFunction(cctx, rpc, args); err != nil {
			return fmt.Errorf("failed to call view function: %w", err)
		}
	case "change":
		if !cctx.IsSet("account") {
			return fmt.Errorf("--account is required for change function call")
		}

		keyPair, err := resolveCredentials(network.NetworkID, cctx.String("account"))
		if err != nil {
			return fmt.Errorf("failed to load private key: %w", err)
		}

		if err := changeFunction(cctx, rpc, keyPair, network, args); err != nil {
			return fmt.Errorf("failed to call change function: %w", err)
		}
	default:
		return fmt.Errorf("either 'change' or 'view' is accepted, you supplied '%s'", cctx.String("mode"))
	}

	return
}

func viewFunction(cctx *cli.Context, rpc client.Client, args []byte) (err error) {
	res, err := rpc.ContractViewCallFunction(cctx.Context, cctx.String("target"), cctx.String("method"), base64.StdEncoding.EncodeToString(args), block.FinalityFinal())
	if err != nil {
		return
	}

	if l := res.Logs; len(l) > 0 {
		log.Println("logs:")
		for _, line := range l {
			log.Printf("- %s", line)
		}
	}

	log.Println("result:")
	if len(res.Result) == 0 {
		fmt.Println("(empty)")
		return
	}

	fmt.Printf("%s", hex.Dump(res.Result))

	return
}

func changeFunction(cctx *cli.Context, rpc client.Client, keyPair key.KeyPair, network config.NetworkInfo, args []byte) (err error) {
	var deposit types.Balance = types.NEARToYocto(0)
	var gas types.Gas = cctx.Uint64("gas")

	if cctx.IsSet("deposit") {
		depositValue := cctx.String("deposit")
		deposit, err = types.BalanceFromString(depositValue)
		if err != nil {
			return fmt.Errorf("failed to parse amount '%s': %w", depositValue, err)
		}
	}

	// Make a transaction
	res, err := rpc.TransactionSendAwait(
		cctx.Context,
		cctx.String("account"),
		cctx.String("target"),
		[]action.Action{
			action.NewFunctionCall(cctx.String("method"), args, gas, deposit),
		},
		client.WithLatestBlock(),
		client.WithKeyPair(keyPair),
	)
	if err != nil {
		return fmt.Errorf("failed to do txn: %w", err)
	}

	// Try to get logs
	type LogEntry struct {
		Executor types.AccountID
		Lines    []string
	}
	logEntries := map[hash.CryptoHash]*LogEntry{}
	for _, receipt := range res.ReceiptsOutcome {
		if len(receipt.Outcome.Logs) == 0 {
			continue
		}

		entry, ok := logEntries[receipt.ID]
		if !ok {
			entry = &LogEntry{
				Executor: receipt.Outcome.ExecutorID,
				Lines:    []string{},
			}
			logEntries[receipt.ID] = entry
		}

		entry.Lines = append(entry.Lines, receipt.Outcome.Logs...)
	}

	if len(logEntries) > 0 {
		oneEntry := len(logEntries) == 1

		log.Println("logs:")
		for _, receipt := range res.ReceiptsOutcome {
			logEntry, ok := logEntries[receipt.ID]
			if !ok {
				continue
			}

			for _, line := range logEntry.Lines {
				if oneEntry {
					log.Printf("- %s", line)
				} else {
					log.Printf("- (%s / %s) %s", receipt.ID, logEntry.Executor, line)
				}
			}
		}
	}

	log.Printf("tx id: %s/transactions/%s", network.ExplorerURL, res.Transaction.Hash)
	return
}

func resolveCredentials(networkName string, id types.AccountID) (kp key.KeyPair, err error) {
	var creds struct {
		AccountID  types.AccountID     `json:"account_id"`
		PublicKey  key.Base58PublicKey `json:"public_key"`
		PrivateKey key.KeyPair         `json:"private_key"`
	}

	var home string
	home, err = os.UserHomeDir()
	if err != nil {
		return
	}

	credsFile := filepath.Join(home, ".near-credentials", networkName, fmt.Sprintf("%s.json", id))

	var cf *os.File
	if cf, err = os.Open(credsFile); err != nil {
		return
	}
	defer cf.Close()

	if err = json.NewDecoder(cf).Decode(&creds); err != nil {
		return
	}

	if creds.PublicKey.String() != creds.PrivateKey.PublicKey.String() {
		err = fmt.Errorf("inconsistent public key, %s != %s", creds.PublicKey.String(), creds.PrivateKey.PublicKey.String())
		return
	}
	kp = creds.PrivateKey

	return
}

'''
'''--- cmd/genesis/main.go ---
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"github.com/urfave/cli/v2"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/config"
)

func main() {
	app := &cli.App{
		Name:  "genesis",
		Usage: "Gets genesis config for the network",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "network",
				Usage:   "NEAR network",
				Value:   "testnet",
				EnvVars: []string{"NEAR_ENV"},
			},
		},
		Action: entrypoint,
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func entrypoint(cctx *cli.Context) (err error) {
	networkID := cctx.String("network")
	network, ok := config.Networks[networkID]
	if !ok {
		return fmt.Errorf("unknown network '%s'", networkID)
	}

	rpc, err := client.NewClient(network.NodeURL)
	if err != nil {
		return fmt.Errorf("failed to create rpc client: %w", err)
	}

	genesisConfig, err := rpc.GenesisConfig(cctx.Context)
	if err != nil {
		return fmt.Errorf("failed to query genesis config: %w", err)
	}

	encoder := json.NewEncoder(os.Stdout)
	encoder.SetIndent("", "    ")
	_ = encoder.Encode(genesisConfig)

	return
}

'''
'''--- cmd/keys/main.go ---
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/davecgh/go-spew/spew"
	"github.com/urfave/cli/v2"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/config"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

func main() {
	app := &cli.App{
		Name:  "keys",
		Usage: "Display access keys attached to an account",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:     "account",
				Required: true,
				Usage:    "Account id",
			},
			&cli.StringFlag{
				Name:  "key",
				Usage: "Specific key to query. Otherwise shows all access keys",
			},
			&cli.StringFlag{
				Name:    "network",
				Usage:   "NEAR network",
				Value:   "testnet",
				EnvVars: []string{"NEAR_ENV"},
			},
		},
		Action: entrypoint,
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func entrypoint(cctx *cli.Context) (err error) {
	network, ok := config.Networks[cctx.String("network")]
	if !ok {
		return fmt.Errorf("unknown network '%s'", cctx.String("network"))
	}

	rpc, err := client.NewClient(network.NodeURL)
	if err != nil {
		return fmt.Errorf("failed to create rpc client: %w", err)
	}

	log.Printf("near network: %s", rpc.NetworkAddr())

	ctx := context.Background()
	if rawKey := cctx.String("key"); cctx.IsSet("key") {
		pubKey, err := key.NewBase58PublicKey(rawKey)
		if err != nil {
			return fmt.Errorf("failed to parse access pubkey: %w", err)
		}

		accessKeyViewResp, err := rpc.AccessKeyView(ctx, cctx.String("account"), pubKey, block.FinalityFinal())
		if err != nil {
			return fmt.Errorf("failed to query access key: %w", err)
		}

		spew.Dump(accessKeyViewResp)
	} else {
		accessKeyViewListResp, err := rpc.AccessKeyViewList(ctx, cctx.String("account"), block.FinalityFinal())
		if err != nil {
			return fmt.Errorf("failed to query access key list: %w", err)
		}

		spew.Dump(accessKeyViewListResp)
	}

	return
}

'''
'''--- cmd/transfer/main.go ---
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/urfave/cli/v2"

	"github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/eteu-technologies/near-api-go/pkg/config"
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

func main() {
	app := &cli.App{
		Name:  "transfer",
		Usage: "Transfer NEAR between accounts",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:     "from",
				Required: true,
				Usage:    "Sender account id",
			},
			&cli.StringFlag{
				Name:     "to",
				Aliases:  []string{"recipient"},
				Required: true,
				Usage:    "Recipient account id",
			},
			&cli.StringFlag{
				Name:     "amount",
				Required: true,
				Usage:    "Amount of NEAR to send",
			},
			&cli.StringFlag{
				Name:    "network",
				Usage:   "NEAR network",
				Value:   "testnet",
				EnvVars: []string{"NEAR_ENV"},
			},
		},
		Action: entrypoint,
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func entrypoint(cctx *cli.Context) (err error) {
	networkID := cctx.String("network")
	senderID := cctx.String("from")
	recipientID := cctx.String("to")
	amountValue := cctx.String("amount")

	var amount types.Balance

	amount, err = types.BalanceFromString(amountValue)
	if err != nil {
		return fmt.Errorf("failed to parse amount '%s': %w", amountValue, err)
	}

	network, ok := config.Networks[networkID]
	if !ok {
		return fmt.Errorf("unknown network '%s'", networkID)
	}

	keyPair, err := resolveCredentials(networkID, senderID)
	if err != nil {
		return fmt.Errorf("failed to load private key: %w", err)
	}

	rpc, err := client.NewClient(network.NodeURL)
	if err != nil {
		return fmt.Errorf("failed to create rpc client: %w", err)
	}

	log.Printf("near network: %s", rpc.NetworkAddr())

	ctx := client.ContextWithKeyPair(context.Background(), keyPair)
	res, err := rpc.TransactionSendAwait(
		ctx, senderID, recipientID,
		[]action.Action{
			action.NewTransfer(amount),
		},
		client.WithLatestBlock(),
	)
	if err != nil {
		return fmt.Errorf("failed to do txn: %w", err)
	}

	log.Printf("tx url: %s/transactions/%s", network.ExplorerURL, res.Transaction.Hash)
	return
}

func resolveCredentials(networkName string, id types.AccountID) (kp key.KeyPair, err error) {
	var creds struct {
		AccountID  types.AccountID     `json:"account_id"`
		PublicKey  key.Base58PublicKey `json:"public_key"`
		PrivateKey key.KeyPair         `json:"private_key"`
	}

	var home string
	home, err = os.UserHomeDir()
	if err != nil {
		return
	}

	credsFile := filepath.Join(home, ".near-credentials", networkName, fmt.Sprintf("%s.json", id))

	var cf *os.File
	if cf, err = os.Open(credsFile); err != nil {
		return
	}
	defer cf.Close()

	if err = json.NewDecoder(cf).Decode(&creds); err != nil {
		return
	}

	if creds.PublicKey.String() != creds.PrivateKey.PublicKey.String() {
		err = fmt.Errorf("inconsistent public key, %s != %s", creds.PublicKey.String(), creds.PrivateKey.PublicKey.String())
		return
	}
	kp = creds.PrivateKey

	return
}

'''
'''--- nearnet/docker-compose.yml ---
version: '2.4'

services:
  nearup:
    #image: nearprotocol/nearup:latest
    build: .
    command: 'run localnet --verbose --binary-path /neard-local'
    init: true
    volumes:
      - data:/root/.near
    ports:
      - 127.0.0.1:3030:3030

volumes:
  data:

'''
'''--- nearnet/entrypoint.sh ---
#!/usr/bin/env bash
set -euo pipefail

datadir=/root/.near
pidfile="${HOME}/.nearup/node.pid"

if [ -f "${pidfile}" ]; then
	rm "${pidfile}"
fi

nearup "${@}"
sleep 1

pid="$(sed 's/^\(\w\+\)|.*/\1/g' "${pidfile}" | head -1)"
while (kill -0 "${pid}" &>/dev/null); do
	sleep 2
done

'''
'''--- nearnet/get_creds.sh ---
#!/usr/bin/env bash
set -euo pipefail

datadir="$(docker volume inspect nearnet_data --format '{{ .Mountpoint }}')"
sudo cat "${datadir}"/localnet/node0/validator_key.json

'''
'''--- nearnet/tail_logs.sh ---
#!/usr/bin/env bash
set -euo pipefail

docker-compose exec nearup tail -f /root/.nearup/logs/localnet/node0.log

'''
'''--- pkg/client/access_key.go ---
package client

import (
	"context"
	"errors"
	"fmt"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/jsonrpc"
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

// https://docs.near.org/docs/api/rpc#view-access-key
func (c *Client) AccessKeyView(ctx context.Context, accountID types.AccountID, publicKey key.Base58PublicKey, block block.BlockCharacteristic) (resp AccessKeyView, err error) {
	_, err = c.doRPC(ctx, &resp, "query", block, map[string]interface{}{
		"request_type": "view_access_key",
		"account_id":   accountID,
		"public_key":   publicKey,
	})

	if resp.Error != nil {
		err = fmt.Errorf("RPC returned an error: %w", errors.New(*resp.Error))
	}

	return
}

// https://docs.near.org/docs/api/rpc#view-access-key-list
func (c *Client) AccessKeyViewList(ctx context.Context, accountID types.AccountID, block block.BlockCharacteristic) (resp AccessKeyList, err error) {
	_, err = c.doRPC(ctx, &resp, "query", block, map[string]interface{}{
		"request_type": "view_access_key_list",
		"account_id":   accountID,
	})

	return
}

// TODO: decode response
// https://docs.near.org/docs/api/rpc#view-access-key-changes-single
func (c *Client) AccessKeyViewChanges(ctx context.Context, accountID types.AccountID, publicKey key.Base58PublicKey, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes", block, map[string]interface{}{
		"changes_type": "single_access_key_changes",
		"keys": map[string]interface{}{
			"account_id": accountID,
			"public_key": publicKey,
		},
	})

	return
}

// TODO: decode response
// https://docs.near.org/docs/api/rpc#view-access-key-changes-all
func (c *Client) AccessKeyViewChangesAll(ctx context.Context, accountIDs []types.AccountID, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes", block, map[string]interface{}{
		"changes_type": "all_access_key_changes",
		"account_ids":  accountIDs,
	})

	return
}

'''
'''--- pkg/client/access_key_structs.go ---
package client

import (
	"encoding/json"
	"fmt"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

type AccessKey struct {
	Nonce types.Nonce `json:"nonce"`

	// Permission holds parsed access key permission info
	Permission AccessKeyPermission `json:"-"`
}

func (ak *AccessKey) UnmarshalJSON(b []byte) (err error) {
	// Unmarshal into inline struct to avoid recursion
	var tmp struct {
		Nonce         types.Nonce     `json:"nonce"`
		RawPermission json.RawMessage `json:"permission"`
	}
	if err = json.Unmarshal(b, &tmp); err != nil {
		return
	}

	*ak = AccessKey{
		Nonce: tmp.Nonce,
	}
	err = ak.Permission.UnmarshalJSON(tmp.RawPermission)

	return
}

// AccessKeyPermission holds info whether access key is a FullAccess, or FunctionCall key
type AccessKeyPermission struct {
	FullAccess   bool                   `json:"-"`
	FunctionCall FunctionCallPermission `json:"-"`
}

func (akp *AccessKeyPermission) UnmarshalJSON(b []byte) (err error) {
	*akp = AccessKeyPermission{}

	// Option 1: "FullAccess"
	var s string
	if err = json.Unmarshal(b, &s); err == nil {
		switch s {
		case "FullAccess":
			akp.FullAccess = true
			return
		default:
			return fmt.Errorf("'%s' is neither object or 'FullAccess'", s)
		}
	} else if jerr, ok := err.(*json.UnmarshalTypeError); ok && jerr.Value != "object" {
		// If trying to unmarshal object into string, then continue. Otherwise return here
		return
	}

	// Option 2: Function call
	var perm struct {
		FunctionCall FunctionCallPermission `json:"FunctionCall"`
	}
	err = json.Unmarshal(b, &perm)
	akp.FunctionCall = perm.FunctionCall

	return
}

// FunctionCallPermission represents a function call permission
type FunctionCallPermission struct {
	// Allowance for this function call (default 0.25 NEAR). Can be absent.
	Allowance *types.Balance `json:"allowance"`
	// ReceiverID holds the contract the key is allowed to call methods on
	ReceiverID types.AccountID `json:"receiver_id"`
	// MethodNames hold which functions are allowed to call. Can be empty (all methods are allowed)
	MethodNames []string `json:"method_names"`
}

type AccessKeyView struct {
	AccessKey
	QueryResponse
}

func (a *AccessKeyView) UnmarshalJSON(data []byte) (err error) {
	var qr QueryResponse
	var ak AccessKey

	if err = json.Unmarshal(data, &qr); err != nil {
		err = fmt.Errorf("unable to parse QueryResponse: %w", err)
		return
	}

	if qr.Error == nil {
		if err = json.Unmarshal(data, &ak); err != nil {
			err = fmt.Errorf("unable to parse AccessKey: %w", err)
			return
		}
	}

	*a = AccessKeyView{
		AccessKey:     ak,
		QueryResponse: qr,
	}
	return
}

type AccessKeyViewInfo struct {
	PublicKey key.Base58PublicKey `json:"public_key"`
	AccessKey AccessKey           `json:"access_key"`
}

type AccessKeyList struct {
	Keys []AccessKeyViewInfo `json:"keys"`
}

'''
'''--- pkg/client/account.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/jsonrpc"
	"github.com/eteu-technologies/near-api-go/pkg/types"
)

// https://docs.near.org/docs/api/rpc#view-account
func (c *Client) AccountView(ctx context.Context, accountID types.AccountID, block block.BlockCharacteristic) (res AccountView, err error) {
	_, err = c.doRPC(ctx, &res, "query", block, map[string]interface{}{
		"request_type": "view_account",
		"account_id":   accountID,
	})

	return
}

// TODO: decode response
// https://docs.near.org/docs/api/rpc#view-account-changes
func (c *Client) AccountViewChanges(ctx context.Context, accountIDs []types.AccountID, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes", block, map[string]interface{}{
		"changes_type": "account_changes",
		"account_ids":  accountIDs,
	})

	return
}

'''
'''--- pkg/client/account_structs.go ---
package client

import (
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

type AccountView struct {
	Amount        types.Balance      `json:"amount"`
	Locked        types.Balance      `json:"locked"`
	CodeHash      hash.CryptoHash    `json:"code_hash"`
	StorageUsage  types.StorageUsage `json:"storage_usage"`
	StoragePaidAt types.BlockHeight  `json:"storage_paid_at"`

	QueryResponse
}

'''
'''--- pkg/client/block.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/jsonrpc"
)

// https://docs.near.org/docs/api/rpc#block-details
func (c *Client) BlockDetails(ctx context.Context, block block.BlockCharacteristic) (resp BlockView, err error) {
	_, err = c.doRPC(ctx, &resp, "block", block, map[string]interface{}{})

	return
}

// TODO: decode resposne
// https://docs.near.org/docs/api/rpc#changes-in-block
func (c *Client) BlockChanges(ctx context.Context, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes_in_block", block, map[string]interface{}{})

	return
}

'''
'''--- pkg/client/block/block.go ---
package block

import (
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

// BlockCharacteristic is a function type aiding with specifying a block
type BlockCharacteristic func(map[string]interface{})

// FinalityOptimistic specifies the latest block recorded on the node that responded to your query (<1 second delay after the transaction is submitted)
func FinalityOptimistic() BlockCharacteristic {
	return func(params map[string]interface{}) {
		params["finality"] = "optimistic"
	}
}

// FinalityFinal specifies a block that has been validated on at least 66% of the nodes in the network (usually takes 2 blocks / approx. 2 second delay)
func FinalityFinal() BlockCharacteristic {
	return func(params map[string]interface{}) {
		params["finality"] = "final"
	}
}

// BlockID specifies a block id/height
func BlockID(blockID uint) BlockCharacteristic {
	return func(params map[string]interface{}) {
		params["block_id"] = blockID
	}
}

// BlockHash specifies a block hash
func BlockHash(blockHash hash.CryptoHash) BlockCharacteristic {
	return func(params map[string]interface{}) {
		params["block_id"] = blockHash
	}
}

// BlockHashRaw is a variant of `BlockHash` function accepting a raw block hash (string)
func BlockHashRaw(blockHash string) BlockCharacteristic {
	return func(params map[string]interface{}) {
		params["block_id"] = blockHash
	}
}

'''
'''--- pkg/client/block_structs.go ---
package client

import (
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type ChallengesResult = []SlashedValidator

type SlashedValidator struct {
	AccountID    types.AccountID `json:"account_id"`
	IsDoubleSign bool            `json:"is_double_sign"`
}

// ValidatorStakeView is based on ValidatorStakeV1 struct in nearcore
type ValidatorStakeView struct {
	AccountID types.AccountID     `json:"account_id"`
	PublicKey key.Base58PublicKey `json:"public_key"`
	Stake     types.Balance       `json:"stake"`
}

type BlockView struct {
	Author types.AccountID   `json:"author"`
	Header BlockHeaderView   `json:"header"`
	Chunks []ChunkHeaderView `json:"chunks"`
}

type BlockHeaderView struct {
	Height                types.BlockHeight            `json:"height"`
	EpochID               hash.CryptoHash              `json:"epoch_id"`
	NextEpochID           hash.CryptoHash              `json:"next_epoch_id"`
	Hash                  hash.CryptoHash              `json:"hash"`
	PrevHash              hash.CryptoHash              `json:"prev_hash"`
	PrevStateRoot         hash.CryptoHash              `json:"prev_state_root"`
	ChunkReceiptsRoot     hash.CryptoHash              `json:"chunk_receipts_root"`
	ChunkHeadersRoot      hash.CryptoHash              `json:"chunk_headers_root"`
	ChunkTxRoot           hash.CryptoHash              `json:"chunk_tx_root"`
	OutcomeRoot           hash.CryptoHash              `json:"outcome_root"`
	ChunksIncluded        uint64                       `json:"chunks_included"`
	ChallengesRoot        hash.CryptoHash              `json:"challenges_root"`
	Timestamp             uint64                       `json:"timestamp"`         // milliseconds
	TimestampNanosec      types.TimeNanos              `json:"timestamp_nanosec"` // nanoseconds, uint128
	RandomValue           hash.CryptoHash              `json:"random_value"`
	ValidatorProposals    []ValidatorStakeView         `json:"validator_proposals"`
	ChunkMask             []bool                       `json:"chunk_mask"`
	GasPrice              types.Balance                `json:"gas_price"`
	RentPaid              types.Balance                `json:"rent_paid"`        // NOTE: deprecated - 2021-05-14
	ValidatorReward       types.Balance                `json:"validator_reward"` // NOTE: deprecated - 2021-05-14
	TotalSupply           types.Balance                `json:"total_supply"`
	ChallengesResult      ChallengesResult             `json:"challenges_result"`
	LastFinalBlock        hash.CryptoHash              `json:"last_final_block"`
	LastDSFinalBlock      hash.CryptoHash              `json:"last_ds_final_block"`
	NextBPHash            hash.CryptoHash              `json:"next_bp_hash"`
	BlockMerkleRoot       hash.CryptoHash              `json:"block_merkle_root"`
	Approvals             []*signature.Base58Signature `json:"approvals"`
	Signature             signature.Base58Signature    `json:"signature"`
	LatestProtocolVersion uint64                       `json:"latest_protocol_version"`
}

'''
'''--- pkg/client/chunk.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

// https://docs.near.org/docs/api/rpc#chunk-details
func (c *Client) ChunkDetails(ctx context.Context, chunkHash hash.CryptoHash) (res ChunkView, err error) {
	_, err = c.doRPC(ctx, &res, "chunk", nil, []string{chunkHash.String()})

	return
}

'''
'''--- pkg/client/chunk_structs.go ---
package client

import (
	"encoding/json"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type ChunkView struct {
	Author       types.AccountID         `json:"author"`
	Header       ChunkHeaderView         `json:"header"`
	Transactions []SignedTransactionView `json:"transactions"`
	Receipts     []ReceiptView           `json:"receipts"`
}

type ChunkHeaderView struct {
	ChunkHash            hash.CryptoHash           `json:"chunk_hash"`
	PrevBlockHash        hash.CryptoHash           `json:"prev_block_hash"`
	OutcomeRoot          hash.CryptoHash           `json:"outcome_root"`
	PrevStateRoot        json.RawMessage           `json:"prev_state_root"` // TODO: needs a type!
	EncodedMerkleRoot    hash.CryptoHash           `json:"encoded_merkle_root"`
	EncodedLength        uint64                    `json:"encoded_length"`
	HeightCreated        types.BlockHeight         `json:"height_created"`
	HeightIncluded       types.BlockHeight         `json:"height_included"`
	ShardID              types.ShardID             `json:"shard_id"`
	GasUsed              types.Gas                 `json:"gas_used"`
	GasLimit             types.Gas                 `json:"gas_limit"`
	RentPaid             types.Balance             `json:"rent_paid"`        // TODO: deprecated
	ValidatorReward      types.Balance             `json:"validator_reward"` // TODO: deprecated
	BalanceBurnt         types.Balance             `json:"balance_burnt"`
	OutgoingReceiptsRoot hash.CryptoHash           `json:"outgoing_receipts_root"`
	TxRoot               hash.CryptoHash           `json:"tx_root"`
	ValidatorProposals   []ValidatorStakeView      `json:"validator_proposals"`
	Signature            signature.Base58Signature `json:"signature"`
}

'''
'''--- pkg/client/client.go ---
package client

import (
	"context"
	"encoding/json"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/jsonrpc"
)

type Client struct {
	RPCClient jsonrpc.Client
}

func NewClient(networkAddr string) (client Client, err error) {
	client.RPCClient, err = jsonrpc.NewClient(networkAddr)
	if err != nil {
		return
	}

	return
}

func (c *Client) NetworkAddr() string {
	return c.RPCClient.URL
}

func (c *Client) doRPC(ctx context.Context, result interface{}, method string, block block.BlockCharacteristic, params interface{}) (res jsonrpc.Response, err error) {
	if block != nil {
		if mapv, ok := params.(map[string]interface{}); ok {
			block(mapv)
		}
	}

	res, err = c.RPCClient.CallRPC(ctx, method, params)
	if err != nil {
		return
	}

	// If JSON-RPC error happens, conveniently set it as err to avoid duplicating code
	// XXX: using plain assignment makes `err != nil` true for some reason
	if err := res.Error; err != nil {
		return res, err
	}

	if result != nil {
		if err = json.Unmarshal(res.Result, result); err != nil {
			return
		}
	}

	return
}

'''
'''--- pkg/client/common.go ---
package client

import (
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

type QueryResponse struct {
	BlockHeight types.BlockHeight `json:"block_height"`
	BlockHash   hash.CryptoHash   `json:"block_hash"`
	Error       *string           `json:"error"`
	Logs        []interface{}     `json:"logs"` // TODO: use correct type
}

'''
'''--- pkg/client/context.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

type rpcContext int

const (
	clientCtx = rpcContext(iota)
	keyPairCtx
)

func ContextWithKeyPair(ctx context.Context, keyPair key.KeyPair) context.Context {
	kp := keyPair
	return context.WithValue(ctx, keyPairCtx, &kp)
}

func getKeyPair(ctx context.Context) *key.KeyPair {
	v, ok := ctx.Value(keyPairCtx).(*key.KeyPair)
	if ok {
		return v
	}

	return nil
}

'''
'''--- pkg/client/contract.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/jsonrpc"
	"github.com/eteu-technologies/near-api-go/pkg/types"
)

// https://docs.near.org/docs/api/rpc#view-contract-state
func (c *Client) ContractViewState(ctx context.Context, accountID types.AccountID, prefixBase64 string, block block.BlockCharacteristic) (res ViewStateResult, err error) {
	_, err = c.doRPC(ctx, &res, "query", block, map[string]interface{}{
		"request_type":  "view_state",
		"account_id":    accountID,
		"prefix_base64": prefixBase64,
	})

	return
}

// TODO: decode response
// https://docs.near.org/docs/api/rpc#view-contract-state-changes
func (c *Client) ContractViewStateChanges(ctx context.Context, accountIDs []types.AccountID, keyPrefixBase64 string, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes", block, map[string]interface{}{
		"changes_type":      "data_changes",
		"account_ids":       accountIDs,
		"key_prefix_base64": keyPrefixBase64,
	})

	return
}

// TODO: decode response
// https://docs.near.org/docs/api/rpc#view-contract-code-changes
func (c *Client) ContractViewCodeChanges(ctx context.Context, accountIDs []types.AccountID, block block.BlockCharacteristic) (res jsonrpc.Response, err error) {
	res, err = c.doRPC(ctx, nil, "EXPERIMENTAL_changes", block, map[string]interface{}{
		"changes_type": "contract_code_changes",
		"account_ids":  accountIDs,
	})

	return
}

// https://docs.near.org/docs/api/rpc#call-a-contract-function
func (c *Client) ContractViewCallFunction(ctx context.Context, accountID, methodName, argsBase64 string, block block.BlockCharacteristic) (res CallResult, err error) {
	_, err = c.doRPC(ctx, &res, "query", block, map[string]interface{}{
		"request_type": "call_function",
		"account_id":   accountID,
		"method_name":  methodName,
		"args_base64":  argsBase64,
	})

	return
}

'''
'''--- pkg/client/contract_structs.go ---
package client

type ViewStateResult struct {
	Values []StateItem   `json:"values"`
	Proof  TrieProofPath `json:"proof"`

	QueryResponse
}

type StateItem struct {
	Key   string        `json:"key"`
	Value string        `json:"value"`
	Proof TrieProofPath `json:"proof"`
}

type CallResult struct {
	Result []byte   `json:"result"`
	Logs   []string `json:"logs"`

	QueryResponse
}

// TrieProofPath is a set of serialized TrieNodes that are encoded in base64. Represent proof of inclusion of some TrieNode in the MerkleTrie.
type TrieProofPath = []string

'''
'''--- pkg/client/gas.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
)

// https://docs.near.org/docs/api/rpc#gas-price
func (c *Client) GasPriceView(ctx context.Context, block block.BlockCharacteristic) (res GasPrice, err error) {
	_, err = c.doRPC(ctx, &res, "gas_price", nil, blockIDArrayParams(block))

	return
}

'''
'''--- pkg/client/gas_structs.go ---
package client

import "github.com/eteu-technologies/near-api-go/pkg/types"

type GasPrice struct {
	GasPrice types.Balance `json:"gas_price"`
}

'''
'''--- pkg/client/genesis.go ---
package client

import (
	"context"
)

// https://docs.near.org/docs/api/rpc#genesis-config
func (c *Client) GenesisConfig(ctx context.Context) (res map[string]interface{}, err error) {
	_, err = c.doRPC(ctx, &res, "EXPERIMENTAL_genesis_config", nil, nil)

	return
}

'''
'''--- pkg/client/light.go ---
package client

import (
	"context"
	"errors"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

// NextLightClientBlock doc: https://nomicon.io/ChainSpec/LightClient#light-client-block
func (c *Client) NextLightClientBlock(ctx context.Context, lastHash hash.CryptoHash) (resp LightClientBlockView, err error) {
	_, err = c.doRPC(ctx, &resp, "next_light_client_block", nil, []hash.CryptoHash{lastHash})
	return
}

// LightClientProof doc: https://nomicon.io/ChainSpec/LightClient#light-client-proof
func (c *Client) LightClientProof(ctx context.Context, tor TransactionOrReceiptId) (resp RpcLightClientExecutionProofResponse, err error) {
	params := make(map[string]interface{}, 3)
	typ := tor.Type()
	if typ == TypeTransaction {
		params["transaction_hash"] = tor.Hash()
		params["sender_id"] = tor.ID()
	} else if typ == TypeReceipt {
		params["receipt_id"] = tor.Hash()
		params["receiver_id"] = tor.ID()
	} else {
		return RpcLightClientExecutionProofResponse{}, errors.New("invalid type")
	}
	params["type"] = typ
	params["light_client_head"] = tor.LightClientHeadHash()

	_, err = c.doRPC(ctx, &resp, "EXPERIMENTAL_light_client_proof", nil, params)
	return
}

'''
'''--- pkg/client/light_structs.go ---
package client

import (
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type ValidatorStakeWithVersion struct {
	AccountID                   types.AccountID     `json:"account_id"`
	PublicKey                   key.Base58PublicKey `json:"public_key"`
	Stake                       types.Balance       `json:"stake"`
	ValidatorStakeStructVersion string              `json:"validator_stake_struct_version"`
}

type BlockHeaderInnerLiteView struct {
	Height           types.BlockHeight `json:"height"`
	EpochID          hash.CryptoHash   `json:"epoch_id"`
	NextEpochId      hash.CryptoHash   `json:"next_epoch_id"`
	PrevStateRoot    hash.CryptoHash   `json:"prev_state_root"`
	OutcomeRoot      hash.CryptoHash   `json:"outcome_root"`
	Timestamp        uint64            `json:"timestamp"`
	TimestampNanoSec string            `json:"timestamp_nanosec"`
	NextBpHash       hash.CryptoHash   `json:"next_bp_hash"`
	BlockMerkleRoot  hash.CryptoHash   `json:"block_merkle_root"`
}

type LightClientBlockView struct {
	PrevBlockHash      hash.CryptoHash              `json:"prev_block_hash"`
	NextBlockInnerHash hash.CryptoHash              `json:"next_block_inner_hash"`
	InnerLite          BlockHeaderInnerLiteView     `json:"inner_lite"`
	InnerRestHash      hash.CryptoHash              `json:"inner_rest_hash"`
	NextBps            []ValidatorStakeWithVersion  `json:"next_bps"`
	ApprovalsAfterNext []*signature.Base58Signature `json:"approvals_after_next"`
}

type LightClientBlockLiteView struct {
	PrevBlockHash hash.CryptoHash          `json:"prev_block_hash"`
	InnerRestHash hash.CryptoHash          `json:"inner_rest_hash"`
	InnerLite     BlockHeaderInnerLiteView `json:"inner_lite"`
}

type RpcLightClientExecutionProofResponse struct {
	OutcomeProof     ExecutionOutcomeWithIdView `json:"outcome_proof"`
	OutcomeRootProof MerklePath                 `json:"outcome_root_proof"`
	BlockHeaderLite  LightClientBlockLiteView   `json:"block_header_lite"`
	BlockProof       MerklePath                 `json:"block_proof"`
}

const (
	TypeReceipt     = "receipt"
	TypeTransaction = "transaction"
)

type TransactionOrReceiptId interface {
	Type() string
	ID() types.AccountID
	Hash() hash.CryptoHash
	LightClientHeadHash() hash.CryptoHash
}

type Transaction struct {
	TransactionHash hash.CryptoHash `json:"transaction_hash"`
	SenderID        types.AccountID `json:"sender_id"`
	LightClientHead hash.CryptoHash `json:"light_client_head"`
}

func (t Transaction) Type() string {
	return TypeTransaction
}

func (t Transaction) ID() types.AccountID {
	return t.SenderID
}

func (t Transaction) Hash() hash.CryptoHash {
	return t.TransactionHash
}

func (t Transaction) LightClientHeadHash() hash.CryptoHash {
	return t.LightClientHead
}

type Receipt struct {
	ReceiptID       hash.CryptoHash `json:"receipt_id"`
	ReceiverID      types.AccountID `json:"receiver_id"`
	LightClientHead hash.CryptoHash
}

func (r Receipt) Type() string {
	return TypeReceipt
}

func (r Receipt) ID() types.AccountID {
	return r.ReceiverID
}

func (r Receipt) Hash() hash.CryptoHash {
	return r.ReceiptID
}

func (r Receipt) LightClientHeadHash() hash.CryptoHash {
	return r.LightClientHead
}

'''
'''--- pkg/client/network.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
)

// https://docs.near.org/docs/api/rpc#network-info
func (c *Client) NetworkInfo(ctx context.Context) (res NetworkInfo, err error) {
	_, err = c.doRPC(ctx, &res, "network_info", nil, []string{})

	return
}

// https://docs.near.org/docs/api/rpc#general-validator-status
func (c *Client) NetworkStatusValidators(ctx context.Context) (res StatusResponse, err error) {
	_, err = c.doRPC(ctx, &res, "status", nil, []string{})

	return
}

// https://docs.near.org/docs/api/rpc#detailed-validator-status
func (c *Client) NetworkStatusValidatorsDetailed(ctx context.Context, block block.BlockCharacteristic) (res ValidatorsResponse, err error) {
	_, err = c.doRPC(ctx, nil, "validators", nil, blockIDArrayParams(block))

	return
}

'''
'''--- pkg/client/network_structs.go ---
package client

import (
	"encoding/json"
	"time"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

// NetworkInfo holds network information
type NetworkInfo struct {
	ActivePeers         []FullPeerInfo  `json:"active_peers"`
	NumActivePeers      uint            `json:"num_active_peers"`
	PeerMaxCount        uint32          `json:"peer_max_count"`
	HighestHeightPeers  []FullPeerInfo  `json:"highest_height_peers"`
	SentBytesPerSec     uint64          `json:"sent_bytes_per_sec"`
	ReceivedBytesPerSec uint64          `json:"received_bytes_per_sec"`
	KnownProducers      []KnownProducer `json:"known_producers"`
	MetricRecorder      MetricRecorder  `json:"metric_recorder"`
	PeerCounter         uint            `json:"peer_counter"`
}

type FullPeerInfo struct {
	PeerInfo  PeerInfo      `json:"peer_info"`
	ChainInfo PeerChainInfo `json:"chain_info"`
	EdgeInfo  EdgeInfo      `json:"edge_info"`
}

// PeerInfo holds peer information
type PeerInfo struct {
	ID        key.PeerID       `json:"id"`
	Addr      *string          `json:"addr"`
	AccountID *types.AccountID `json:"account_id"`
}

// PeerChainInfo contains peer chain information. This is derived from PeerCHainInfoV2 in nearcore
type PeerChainInfo struct {
	// Chain Id and hash of genesis block.
	GenesisID GenesisID `json:"genesis_id"`
	// Last known chain height of the peer.
	Height types.BlockHeight `json:"height"`
	// Shards that the peer is tracking.
	TrackedShards []types.ShardID `json:"tracked_shards"`
	// Denote if a node is running in archival mode or not.
	Archival bool `json:"archival"`
}

// EdgeInfo contains information that will be ultimately used to create a new edge. It contains nonce proposed for the edge with signature from peer.
type EdgeInfo struct {
	Nonce     types.Nonce         `json:"nonce"`
	Signature signature.Signature `json:"signature"`
}

// KnownProducer is basically PeerInfo, but AccountID is known
type KnownProducer struct {
	AccountID types.AccountID `json:"account_id"`
	Addr      *string         `json:"addr"`
	PeerID    key.PeerID      `json:"peer_id"`
}

// TODO: chain/network/src/recorder.rs
type MetricRecorder = json.RawMessage

type GenesisID struct {
	// Chain Id
	ChainID string `json:"chain_id"`
	// Hash of genesis block
	Hash hash.CryptoHash `json:"hash"`
}

type StatusResponse struct {
	// Binary version
	Version NodeVersion `json:"version"`
	// Unique chain id.
	ChainID string `json:"chain_id"`
	// Currently active protocol version.
	ProtocolVersion uint32 `json:"protocol_version"`
	// Latest protocol version that this client supports.
	LatestProtocolVersion uint32 `json:"latest_protocol_version"`
	// Address for RPC server.
	RPCAddr string `json:"rpc_addr"`
	// Current epoch validators.
	Validators []ValidatorInfo `json:"validators"`
	// Sync status of the node.
	SyncInfo StatusSyncInfo `json:"sync_info"`
	// Validator id of the node
	ValidatorAccountID *types.AccountID `json:"validator_account_id"`
}

type NodeVersion struct {
	Version string `json:"version"`
	Build   string `json:"build"`
}

type ValidatorInfo struct {
	AccountID types.AccountID `json:"account_id"`
	Slashed   bool            `json:"is_slashed"`
}

type StatusSyncInfo struct {
	LatestBlockHash   hash.CryptoHash   `json:"latest_block_hash"`
	LatestBlockHeight types.BlockHeight `json:"latest_block_height"`
	LatestBlockTime   time.Time         `json:"latest_block_time"`
	Syncing           bool              `json:"syncing"`
}

type ValidatorsResponse struct {
	CurrentValidators []CurrentEpochValidatorInfo `json:"current_validator"`
}

type CurrentEpochValidatorInfo struct {
	ValidatorInfo
	PublicKey         key.Base58PublicKey `json:"public_key"`
	Stake             types.Balance       `json:"stake"`
	Shards            []types.ShardID     `json:"shards"`
	NumProducedBlocks types.NumBlocks     `json:"num_produced_blocks"`
	NumExpectedBlocks types.NumBlocks     `json:"num_expected_blocks"`
}

'''
'''--- pkg/client/transaction.go ---
package client

import (
	"context"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
)

// https://docs.near.org/docs/api/rpc#send-transaction-async
func (c *Client) RPCTransactionSend(ctx context.Context, signedTxnBase64 string) (resp hash.CryptoHash, err error) {
	_, err = c.doRPC(ctx, &resp, "broadcast_tx_async", nil, []string{signedTxnBase64})

	return
}

// https://docs.near.org/docs/api/rpc#send-transaction-await
func (c *Client) RPCTransactionSendAwait(ctx context.Context, signedTxnBase64 string) (resp FinalExecutionOutcomeView, err error) {
	_, err = c.doRPC(ctx, &resp, "broadcast_tx_commit", nil, []string{signedTxnBase64})

	return
}

// https://docs.near.org/docs/api/rpc#transaction-status
func (c *Client) TransactionStatus(ctx context.Context, tx hash.CryptoHash, sender types.AccountID) (resp FinalExecutionOutcomeView, err error) {
	_, err = c.doRPC(ctx, &resp, "tx", nil, []string{
		tx.String(), sender,
	})

	return
}

// https://docs.near.org/docs/api/rpc#transaction-status-with-receipts
func (c *Client) TransactionStatusWithReceipts(ctx context.Context, tx hash.CryptoHash, sender types.AccountID) (resp FinalExecutionOutcomeWithReceiptView, err error) {
	_, err = c.doRPC(ctx, &resp, "EXPERIMENTAL_tx_status", nil, []string{
		tx.String(), sender,
	})

	return
}

'''
'''--- pkg/client/transaction_structs.go ---
package client

import (
	"encoding/json"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type TransactionStatus struct {
	SuccessValue     string          `json:"SuccessValue"`
	SuccessReceiptID string          `json:"SuccessReceiptId"`
	Failure          json.RawMessage `json:"Failure"` // TODO
}

type SignedTransactionView struct {
	SignerID   types.AccountID           `json:"signer_id"`
	PublicKey  key.Base58PublicKey       `json:"public_key"`
	Nonce      types.Nonce               `json:"nonce"`
	ReceiverID types.AccountID           `json:"receiver_id"`
	Actions    []action.Action           `json:"actions"`
	Signature  signature.Base58Signature `json:"signature"`
	Hash       hash.CryptoHash           `json:"hash"`
}

type FinalExecutionOutcomeView struct {
	Status             TransactionStatus            `json:"status"`
	Transaction        SignedTransactionView        `json:"transaction"`
	TransactionOutcome ExecutionOutcomeWithIdView   `json:"transaction_outcome"`
	ReceiptsOutcome    []ExecutionOutcomeWithIdView `json:"receipts_outcome"`
}

type FinalExecutionOutcomeWithReceiptView struct {
	FinalExecutionOutcomeView
	Receipts []ReceiptView `json:"receipts"`
}

type ReceiptView struct {
	PredecessorID types.AccountID `json:"predecessor_id"`
	ReceiverID    types.AccountID `json:"receiver_id"`
	ReceiptID     hash.CryptoHash `json:"receipt_id"`
	Receipt       json.RawMessage `json:"receipt"` // TODO: needs a type!
}

type ExecutionOutcomeView struct {
	Logs        []string          `json:"logs"`
	ReceiptIDs  []hash.CryptoHash `json:"receipt_ids"`
	GasBurnt    types.Gas         `json:"gas_burnt"`
	TokensBurnt types.Balance     `json:"tokens_burnt"`
	ExecutorID  types.AccountID   `json:"executor_id"`
	Status      TransactionStatus `json:"status"`
}

type MerklePathItem struct {
	Hash      hash.CryptoHash `json:"hash"`
	Direction string          `json:"direction"` // TODO: enum type, either 'Left' or 'Right'
}

type MerklePath = []MerklePathItem

type ExecutionOutcomeWithIdView struct {
	Proof     MerklePath           `json:"proof"`
	BlockHash hash.CryptoHash      `json:"block_hash"`
	ID        hash.CryptoHash      `json:"id"`
	Outcome   ExecutionOutcomeView `json:"outcome"`
}

'''
'''--- pkg/client/transaction_wrapper.go ---
package client

import (
	"context"
	"errors"

	"github.com/eteu-technologies/near-api-go/pkg/client/block"
	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/transaction"
)

type transactionCtx struct {
	txn         transaction.Transaction
	keyPair     *key.KeyPair
	keyNonceSet bool
}

type TransactionOpt func(context.Context, *transactionCtx) error

func (c *Client) prepareTransaction(ctx context.Context, from, to types.AccountID, actions []action.Action, txnOpts ...TransactionOpt) (ctx2 context.Context, blob string, err error) {
	ctx2 = context.WithValue(ctx, clientCtx, c)
	txn := transaction.Transaction{
		SignerID:   from,
		ReceiverID: to,
		Actions:    actions,
	}
	txnCtx := transactionCtx{
		txn:         txn,
		keyPair:     getKeyPair(ctx2),
		keyNonceSet: false,
	}

	for _, opt := range txnOpts {
		if err = opt(ctx2, &txnCtx); err != nil {
			return
		}
	}

	if txnCtx.keyPair == nil {
		err = errors.New("no keypair specified")
		return
	}

	txnCtx.txn.PublicKey = txnCtx.keyPair.PublicKey.ToPublicKey()

	// Query the access key nonce, if not specified
	if !txnCtx.keyNonceSet {
		var accessKey AccessKeyView
		accessKey, err = c.AccessKeyView(ctx2, txnCtx.txn.SignerID, txnCtx.keyPair.PublicKey, block.FinalityFinal())
		if err != nil {
			return
		}

		nonce := accessKey.Nonce

		// Increment nonce by 1
		txnCtx.txn.Nonce = nonce + 1
		txnCtx.keyNonceSet = true
	}

	blob, err = transaction.SignAndSerializeTransaction(*txnCtx.keyPair, txnCtx.txn)
	return
}

// https://docs.near.org/docs/api/rpc#send-transaction-async
func (c *Client) TransactionSend(ctx context.Context, from, to types.AccountID, actions []action.Action, txnOpts ...TransactionOpt) (res hash.CryptoHash, err error) {
	ctx2, blob, err := c.prepareTransaction(ctx, from, to, actions, txnOpts...)
	if err != nil {
		return
	}
	return c.RPCTransactionSend(ctx2, blob)
}

// https://docs.near.org/docs/api/rpc#send-transaction-await
func (c *Client) TransactionSendAwait(ctx context.Context, from, to types.AccountID, actions []action.Action, txnOpts ...TransactionOpt) (res FinalExecutionOutcomeView, err error) {
	ctx2, blob, err := c.prepareTransaction(ctx, from, to, actions, txnOpts...)
	if err != nil {
		return
	}
	return c.RPCTransactionSendAwait(ctx2, blob)
}

func WithBlockCharacteristic(block block.BlockCharacteristic) TransactionOpt {
	return func(ctx context.Context, txnCtx *transactionCtx) (err error) {
		client := ctx.Value(clientCtx).(*Client)

		var res BlockView
		if res, err = client.BlockDetails(ctx, block); err != nil {
			return
		}

		txnCtx.txn.BlockHash = res.Header.Hash
		return
	}

}

// WithBlockHash sets block hash to attach this transaction to
func WithBlockHash(hash hash.CryptoHash) TransactionOpt {
	return func(_ context.Context, txnCtx *transactionCtx) (err error) {
		txnCtx.txn.BlockHash = hash
		return
	}
}

// WithLatestBlock is alias to `WithBlockCharacteristic(block.FinalityFinal())`
func WithLatestBlock() TransactionOpt {
	return WithBlockCharacteristic(block.FinalityFinal())
}

// WithKeyPair sets key pair to use sign this transaction with
func WithKeyPair(keyPair key.KeyPair) TransactionOpt {
	return func(_ context.Context, txnCtx *transactionCtx) (err error) {
		kp := keyPair
		txnCtx.keyPair = &kp
		return
	}
}

// WithKeyNonce sets key nonce to use with this transaction. If not set via this function, a RPC query will be done to query current nonce and
// (nonce+1) will be used
func WithKeyNonce(nonce types.Nonce) TransactionOpt {
	return func(_ context.Context, txnCtx *transactionCtx) (err error) {
		txnCtx.txn.Nonce = nonce
		txnCtx.keyNonceSet = true
		return
	}
}

'''
'''--- pkg/client/utils.go ---
package client

import "github.com/eteu-technologies/near-api-go/pkg/client/block"

// HACK
func blockIDArrayParams(block block.BlockCharacteristic) []interface{} {
	params := []interface{}{nil}
	p := map[string]interface{}{}

	block(p)
	if v, ok := p["block_id"]; ok {
		params[0] = v
	}

	return params
}

'''
'''--- pkg/config/network.go ---
package config

import "fmt"

type NetworkInfo struct {
	NetworkID   string
	NodeURL     string
	WalletURL   string
	HelperURL   string
	ExplorerURL string

	archive    string
	nonArchive string
}

func (n NetworkInfo) Archival() (ni NetworkInfo, ok bool) {
	ni, ok = Networks[n.archive]
	return
}

func (n NetworkInfo) NonArchival() (ni NetworkInfo, ok bool) {
	ni, ok = Networks[n.nonArchive]
	return
}

func (n NetworkInfo) IsArchival() bool {
	return n.nonArchive != ""
}

func buildNetworkConfig(networkID string, hasArchival bool) (ni NetworkInfo) {
	ni.NetworkID = networkID
	ni.NodeURL = fmt.Sprintf("https://rpc.%s.near.org", networkID)
	ni.WalletURL = fmt.Sprintf("https://wallet.%s.near.org", networkID)
	ni.HelperURL = fmt.Sprintf("https://helper.%s.near.org", networkID)
	ni.ExplorerURL = fmt.Sprintf("https://explorer.%s.near.org", networkID)
	if hasArchival {
		ni.archive = fmt.Sprintf("archival-%s", networkID)
	}
	return
}

func buildArchivalNetworkConfig(networkID string) (ni NetworkInfo) {
	ni = buildNetworkConfig(networkID, false)
	ni.NetworkID = fmt.Sprintf("archival-%s", networkID)
	ni.NodeURL = fmt.Sprintf("https://archival-rpc.%s.near.org", networkID)
	ni.nonArchive = networkID
	return
}

var Networks = map[string]NetworkInfo{
	"mainnet": buildNetworkConfig("mainnet", true),
	"testnet": buildNetworkConfig("testnet", true),
	"betanet": buildNetworkConfig("betanet", false),
	"local": {
		NetworkID: "local",
		NodeURL:   "http://127.0.0.1:3030",
	},
	// From https://docs.near.org/docs/api/rpc#setup:
	// > Querying historical data (older than 5 epochs or ~2.5 days), you may get responses that the data is not available anymore.
	// > In that case, archival RPC nodes will come to your rescue
	"archival-mainnet": buildArchivalNetworkConfig("mainnet"),
	"archival-testnet": buildArchivalNetworkConfig("testnet"),
}

'''
'''--- pkg/config/network_test.go ---
package config_test

import (
	"testing"

	"github.com/eteu-technologies/near-api-go/pkg/config"
)

func TestArchivalConfigLink(t *testing.T) {
	amni, ok := config.Networks["mainnet"].Archival()
	if !ok {
		t.Fatal("mainnet should have archival link")
	}

	mni, ok := amni.NonArchival()
	if !ok {
		t.Fatal("archival-mainnet should have non-archival link")
	}

	atni, ok := config.Networks["testnet"].Archival()
	if !ok {
		t.Fatal("testnet should have archival link")
	}

	tni, ok := atni.NonArchival()
	if !ok {
		t.Fatal("archival-testnet should have non-archival link")
	}

	_ = mni
	_ = tni
}

'''
'''--- pkg/jsonrpc/client.go ---
package jsonrpc

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"sync/atomic"
)

const JSONRPCVersion = "2.0"

type Client struct {
	URL string

	client    *http.Client
	nextReqId uint64
}

func NewClient(networkAddr string) (client Client, err error) {
	_, err = url.Parse(networkAddr)
	if err != nil {
		return
	}

	client.client = new(http.Client)
	client.URL = networkAddr
	atomic.StoreUint64(&client.nextReqId, 0)

	return
}

func (c *Client) nextId() uint64 {
	return atomic.AddUint64(&c.nextReqId, 1)
}

func (c *Client) CallRPC(ctx context.Context, method string, params interface{}) (res Response, err error) {
	reqId := fmt.Sprintf("%d", c.nextId())
	body, err := json.Marshal(Request{
		JSONRPC{JSONRPCVersion, reqId, method},
		params,
	})
	if err != nil {
		return
	}

	request, err := http.NewRequestWithContext(ctx, http.MethodPost, c.URL, bytes.NewBuffer(body))
	if err != nil {
		return
	}

	request.Header.Add("Content-Type", "application/json")

	response, err := c.client.Do(request)
	if err != nil {
		return
	}

	return parseRPCBody(response)
}

func parseRPCBody(r *http.Response) (res Response, err error) {
	//fmt.Printf("%#v\n", r)

	body := r.Body
	if body == nil {
		err = errors.New("nil body")
		return
	}
	defer func() { _ = body.Close() }()

	// TODO: check for Content-Type header
	decoder := json.NewDecoder(body)
	decoder.DisallowUnknownFields()

	if err = decoder.Decode(&res); err != nil {
		return
	}

	return
}

'''
'''--- pkg/jsonrpc/error.go ---
package jsonrpc

import (
	"encoding/json"
	"fmt"
	"strconv"
)

const (
	CodeParseError     = -32700
	CodeInvalidRequest = -32600
	CodeMethodNotFound = -32601
	CodeInvalidParams  = -32602
	CodeInternalError  = -32603

	CodeServerErrorRangeStart = -32099
	CodeServerErrorRangeEnd   = -32000
)

type Error struct {
	Name  string     `json:"name"`
	Cause ErrorCause `json:"cause"`

	// Legacy - do not rely on them
	Code    int             `json:"code"`
	Message string          `json:"message"`
	Data    json.RawMessage `json:"data"`
}

func (err *Error) Error() string {
	return fmt.Sprintf("RPC error %s (%s)", err.Name, err.Cause.String())
}

type ErrorCause struct {
	Name string          `json:"name"`
	Info json.RawMessage `json:"info"`

	message *ErrorCauseMessage
}

type ErrorCauseMessage struct {
	ErrorMessage string `json:"error_message"`
}

func (cause *ErrorCause) UnmarshalJSON(b []byte) (err error) {
	var data struct {
		Name string          `json:"name"`
		Info json.RawMessage `json:"info"`
	}

	if err = json.Unmarshal(b, &data); err != nil {
		err = fmt.Errorf("unable to unmarshal error cause: %w", err)
		return
	}

	var info map[string]interface{}
	if err = json.Unmarshal(data.Info, &info); err != nil {
		err = fmt.Errorf("unable to unmarshal error cause info: %w", err)
		return
	}

	var message *ErrorCauseMessage
	if v, ok := info["error_message"]; ok {
		message = &ErrorCauseMessage{
			ErrorMessage: v.(string),
		}
	}

	*cause = ErrorCause{
		Name:    data.Name,
		Info:    data.Info,
		message: message,
	}

	return
}

func (cause ErrorCause) String() string {
	if cause.message != nil {
		return fmt.Sprintf("name=%s, message=%s", cause.Name, cause.message.ErrorMessage)
	}
	return fmt.Sprintf("name=%s, info=%s", cause.Name, strconv.Quote(string(cause.Info)))
}

'''
'''--- pkg/jsonrpc/structs.go ---
package jsonrpc

import (
	"encoding/json"
)

type JSONRPC struct {
	JSONRPC string `json:"jsonrpc"`
	ID      string `json:"id"`
	Method  string `json:"method"`
}

type Request struct {
	JSONRPC
	Params interface{} `json:"params,omitempty"`
}

type Response struct {
	JSONRPC
	Error  *Error          `json:"error"`
	Result json.RawMessage `json:"result"`
}

'''
'''--- pkg/types/action/access_key.go ---
package action

import (
	"encoding/json"
	"fmt"

	"github.com/eteu-technologies/borsh-go"
	"github.com/eteu-technologies/near-api-go/pkg/types"
)

type AccessKeyPermission struct {
	Enum borsh.Enum `borsh_enum:"true"`

	FunctionCallPermission AccessKeyFunctionCallPermission
	FullAccessPermission   struct{}
}

type fullAccessPermissionWrapper struct {
	FunctionCall AccessKeyFunctionCallPermission `json:"FunctionCall"`
}

func NewFunctionCallPermission(allowance types.Balance, receiverID types.AccountID, methodNames []string) AccessKeyPermission {
	return AccessKeyPermission{
		Enum: borsh.Enum(0),
		FunctionCallPermission: AccessKeyFunctionCallPermission{
			Allowance:   &allowance,
			ReceiverID:  receiverID,
			MethodNames: methodNames,
		},
	}
}

func NewFunctionCallUnlimitedAllowancePermission(receiverID types.AccountID, methodNames []string) AccessKeyPermission {
	return AccessKeyPermission{
		Enum: borsh.Enum(0),
		FunctionCallPermission: AccessKeyFunctionCallPermission{
			Allowance:   nil,
			ReceiverID:  receiverID,
			MethodNames: methodNames,
		},
	}
}

func NewFullAccessPermission() AccessKeyPermission {
	return AccessKeyPermission{
		Enum: borsh.Enum(1),
	}
}

func (a AccessKeyPermission) MarshalJSON() (b []byte, err error) {
	if a.IsFullAccess() {
		b = []byte(`"FullAccess"`)
		return
	}

	var v fullAccessPermissionWrapper
	v.FunctionCall = a.FunctionCallPermission

	b, err = json.Marshal(&v)
	return
}

func (a *AccessKeyPermission) UnmarshalJSON(b []byte) (err error) {
	if len(b) > 0 && b[0] == '{' {
		var permission fullAccessPermissionWrapper
		if err = json.Unmarshal(b, &permission); err != nil {
			return
		}

		*a = AccessKeyPermission{
			Enum:                   borsh.Enum(0),
			FunctionCallPermission: permission.FunctionCall,
		}
		return
	}

	var value string
	if err = json.Unmarshal(b, &value); err != nil {
		return
	}

	if value == "FullAccess" {
		*a = NewFullAccessPermission()
		return
	}

	err = fmt.Errorf("unknown permission '%s'", value)
	return
}

func (a AccessKeyPermission) String() string {
	var value string = "FullAccess"
	if a.IsFunctionCall() {
		value = a.FunctionCallPermission.String()
	}
	return fmt.Sprintf("AccessKeyPermission{%s}", value)
}

func (a *AccessKeyPermission) IsFunctionCall() bool {
	return a.Enum == 0
}

func (a *AccessKeyPermission) IsFullAccess() bool {
	return a.Enum == 1
}

type AccessKeyFunctionCallPermission struct {
	Allowance   *types.Balance  `json:"allowance"`
	ReceiverID  types.AccountID `json:"receiver_id"`
	MethodNames []string        `json:"method_names"`
}

func (a AccessKeyFunctionCallPermission) String() string {
	return fmt.Sprintf("AccessKeyFunctionCallPermission{Allowance=%v, ReceiverID=%v, MethodNames=%v}", a.Allowance, a.ReceiverID, a.MethodNames)
}

'''
'''--- pkg/types/action/action.go ---
package action

import (
	"encoding/json"
	"fmt"

	"github.com/eteu-technologies/borsh-go"
	uint128 "github.com/eteu-technologies/golang-uint128"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

type Action struct {
	Enum borsh.Enum `borsh_enum:"true"`

	CreateAccount  ActionCreateAccount
	DeployContract ActionDeployContract
	FunctionCall   ActionFunctionCall
	Transfer       ActionTransfer
	Stake          ActionStake
	AddKey         ActionAddKey
	DeleteKey      ActionDeleteKey
	DeleteAccount  ActionDeleteAccount
}

const (
	ordCreateAccount uint8 = iota
	ordDeployContract
	ordFunctionCall
	ordTransfer
	ordStake
	ordAddKey
	ordDeleteKey
	ordDeleteAccount
)

var (
	ordMappings = map[string]uint8{
		"CreateAccount":  ordCreateAccount,
		"DeployContract": ordDeployContract,
		"FunctionCall":   ordFunctionCall,
		"Transfer":       ordTransfer,
		"Stake":          ordStake,
		"AddKey":         ordAddKey,
		"DeleteKey":      ordDeleteKey,
		"DeleteAccount":  ordDeleteAccount,
	}

	simpleActions = map[string]bool{
		"CreateAccount": true,
	}
)

func (a *Action) PrepaidGas() types.Gas {
	switch uint8(a.Enum) {
	case ordFunctionCall:
		return a.FunctionCall.Gas
	default:
		return 0
	}
}

func (a *Action) DepositBalance() types.Balance {
	switch uint8(a.Enum) {
	case ordFunctionCall:
		return a.FunctionCall.Deposit
	case ordTransfer:
		return a.Transfer.Deposit
	default:
		return types.Balance(uint128.Zero)
	}
}

func (a *Action) UnderlyingValue() interface{} {
	switch uint8(a.Enum) {
	case ordCreateAccount:
		return &a.CreateAccount
	case ordDeployContract:
		return &a.DeployContract
	case ordFunctionCall:
		return &a.FunctionCall
	case ordTransfer:
		return &a.Transfer
	case ordStake:
		return &a.Stake
	case ordAddKey:
		return &a.AddKey
	case ordDeleteKey:
		return &a.DeleteKey
	case ordDeleteAccount:
		return &a.DeleteAccount
	}

	panic("unreachable")
}

func (a Action) String() string {
	ul := a.UnderlyingValue()
	if u, ok := ul.(interface{ String() string }); ok {
		return fmt.Sprintf("Action{%s}", u.String())
	}

	return fmt.Sprintf("Action{%#v}", ul)
}

func (a *Action) UnmarshalJSON(b []byte) (err error) {
	var obj map[string]json.RawMessage

	// actions can be either strings, or objects, so try deserializing into string first
	var actionType string
	if len(b) > 0 && b[0] == '"' {
		if err = json.Unmarshal(b, &actionType); err != nil {
			return
		}

		if _, ok := simpleActions[actionType]; !ok {
			err = fmt.Errorf("Action '%s' had no body", actionType)
			return
		}

		obj = map[string]json.RawMessage{
			actionType: json.RawMessage(`{}`),
		}
	} else {
		if err = json.Unmarshal(b, &obj); err != nil {
			return
		}
	}

	if l := len(obj); l > 1 {
		err = fmt.Errorf("action object contains invalid amount of keys (expected: 1, got: %d)", l)
		return
	}

	for k := range obj {
		actionType = k
		break
	}

	ord := ordMappings[actionType]
	*a = Action{Enum: borsh.Enum(ord)}
	ul := a.UnderlyingValue()

	if err = json.Unmarshal(obj[actionType], ul); err != nil {
		return
	}

	return nil
}

type ActionCreateAccount struct {
}

// Create an (sub)account using a transaction `receiver_id` as an ID for a new account
func NewCreateAccount() Action {
	return Action{
		Enum:          borsh.Enum(ordCreateAccount),
		CreateAccount: ActionCreateAccount{},
	}
}

type ActionDeployContract struct {
	Code []byte `json:"code"`
}

func NewDeployContract(code []byte) Action {
	return Action{
		Enum: borsh.Enum(ordDeployContract),
		DeployContract: ActionDeployContract{
			Code: code,
		},
	}
}

type ActionFunctionCall struct {
	MethodName string        `json:"method_name"`
	Args       []byte        `json:"args"`
	Gas        types.Gas     `json:"gas"`
	Deposit    types.Balance `json:"deposit"`
}

func (f ActionFunctionCall) String() string {
	return fmt.Sprintf("FunctionCall{MethodName: %s, Args: %s, Gas: %d, Deposit: %s}", f.MethodName, f.Args, f.Gas, f.Deposit)
}

func NewFunctionCall(methodName string, args []byte, gas types.Gas, deposit types.Balance) Action {
	return Action{
		Enum: borsh.Enum(ordFunctionCall),
		FunctionCall: ActionFunctionCall{
			MethodName: methodName,
			Args:       args,
			Gas:        gas,
			Deposit:    deposit,
		},
	}
}

type ActionTransfer struct {
	Deposit types.Balance `json:"deposit"`
}

func (t ActionTransfer) String() string {
	return fmt.Sprintf("Transfer{Deposit: %s}", t.Deposit)
}

func NewTransfer(deposit types.Balance) Action {
	return Action{
		Enum: borsh.Enum(ordTransfer),
		Transfer: ActionTransfer{
			Deposit: deposit,
		},
	}
}

type ActionStake struct {
	// Amount of tokens to stake.
	Stake types.Balance `json:"stake"`
	// Validator key which will be used to sign transactions on behalf of singer_id
	PublicKey key.PublicKey `json:"public_key"`
}

func NewStake(stake types.Balance, publicKey key.PublicKey) Action {
	return Action{
		Enum: borsh.Enum(ordStake),
		Stake: ActionStake{
			Stake:     stake,
			PublicKey: publicKey,
		},
	}
}

type ActionAddKey struct {
	PublicKey key.PublicKey         `json:"public_key"`
	AccessKey ActionAddKeyAccessKey `json:"access_key"`
}

type ActionAddKeyAccessKey struct {
	Nonce      types.Nonce         `json:"nonce"`
	Permission AccessKeyPermission `json:"permission"`
}

type jsonActionAddKey struct {
	PublicKey key.Base58PublicKey   `json:"public_key"`
	AccessKey ActionAddKeyAccessKey `json:"access_key"`
}

func NewAddKey(publicKey key.PublicKey, nonce types.Nonce, permission AccessKeyPermission) Action {
	return Action{
		Enum:   borsh.Enum(ordAddKey),
		AddKey: ActionAddKey{},
	}
}

func (a ActionAddKey) MarshalJSON() (b []byte, err error) {
	v := jsonActionAddKey{
		PublicKey: a.PublicKey.ToBase58PublicKey(),
		AccessKey: a.AccessKey,
	}
	b, err = json.Marshal(&v)
	return
}

func (a *ActionAddKey) UnmarshalJSON(b []byte) (err error) {
	var v jsonActionAddKey
	if err = json.Unmarshal(b, &v); err != nil {
		return
	}

	*a = ActionAddKey{
		PublicKey: v.PublicKey.ToPublicKey(),
		AccessKey: v.AccessKey,
	}

	return
}

type ActionDeleteKey struct {
	PublicKey key.PublicKey `json:"public_key"`
}

type jsonActionDeleteKey struct {
	PublicKey key.Base58PublicKey `json:"public_key"`
}

func NewDeleteKey(publicKey key.PublicKey) Action {
	return Action{
		Enum: borsh.Enum(ordDeleteKey),
		DeleteKey: ActionDeleteKey{
			PublicKey: publicKey,
		},
	}
}

func (a ActionDeleteKey) MarshalJSON() (b []byte, err error) {
	v := jsonActionDeleteKey{
		PublicKey: a.PublicKey.ToBase58PublicKey(),
	}
	b, err = json.Marshal(&v)
	return
}

func (a *ActionDeleteKey) UnmarshalJSON(b []byte) (err error) {
	var v jsonActionDeleteKey
	if err = json.Unmarshal(b, &v); err != nil {
		return
	}

	*a = ActionDeleteKey{
		PublicKey: v.PublicKey.ToPublicKey(),
	}

	return
}

type ActionDeleteAccount struct {
	BeneficiaryID types.AccountID `json:"beneficiary_id"`
}

func NewDeleteAccount(beneficiaryID types.AccountID) Action {
	return Action{
		Enum: borsh.Enum(ordDeleteAccount),
		DeleteAccount: ActionDeleteAccount{
			BeneficiaryID: beneficiaryID,
		},
	}
}

'''
'''--- pkg/types/balance.go ---
package types

import (
	"encoding/json"
	"fmt"
	"math"
	"math/big"

	uint128 "github.com/eteu-technologies/golang-uint128"
)

var (
	tenPower24 = uint128.From64(uint64(math.Pow10(12))).Mul64(uint64(math.Pow10(12)))
	zeroNEAR   = Balance(uint128.From64(0))
)

// Balance holds amount of yoctoNEAR
type Balance uint128.Uint128

func (bal *Balance) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}

	val := big.Int{}
	if _, ok := val.SetString(s, 10); !ok {
		return fmt.Errorf("unable to parse '%s'", s)
	}

	*bal = Balance(uint128.FromBig(&val))

	return nil
}

func (bal Balance) MarshalJSON() ([]byte, error) {
	return json.Marshal(bal.String())
}

func (bal Balance) String() string {
	return uint128.Uint128(bal).String()
}

// Convenience funcs
func (bal Balance) Div64(div uint64) Balance {
	return Balance(uint128.Uint128(bal).Div64(div))
}

// TODO
func NEARToYocto(near uint64) Balance {
	if near == 0 {
		return zeroNEAR
	}

	return Balance(uint128.From64(near).Mul(tenPower24))
}

// TODO
func YoctoToNEAR(yocto Balance) uint64 {
	div := uint128.Uint128(yocto).Div(tenPower24)
	if h := div.Hi; h != 0 {
		panic(fmt.Errorf("yocto div failed, remaining: %d", h))
	}

	return div.Lo
}

func scaleToYocto(f *big.Float) (r *big.Int) {
	// Convert reference 1 NEAR to big.Float
	base := new(big.Float).SetPrec(128).SetInt(uint128.Uint128(NEARToYocto(1)).Big())

	// Multiply base using the supplied float
	// XXX: small precision issues here will haunt me forever
	bigf2 := new(big.Float).SetPrec(128).SetMode(big.ToZero).Mul(base, f)

	// Convert it to big.Int
	r, _ = bigf2.Int(nil)
	return
}

// TODO
func BalanceFromFloat(f float64) (bal Balance) {
	bigf := big.NewFloat(f)
	bal = Balance(uint128.FromBig(scaleToYocto(bigf)))
	return
}

// TODO
func BalanceFromString(s string) (bal Balance, err error) {
	var bigf *big.Float
	bigf, _, err = big.ParseFloat(s, 10, 128, big.ToZero)
	if err != nil {
		return
	}

	bal = Balance(uint128.FromBig(scaleToYocto(bigf)))
	return
}

'''
'''--- pkg/types/balance_test.go ---
package types_test

import (
	"testing"

	fuzz "github.com/google/gofuzz"

	. "github.com/eteu-technologies/near-api-go/pkg/types"
)

func TestNEARToYocto(t *testing.T) {
	var NEAR uint64 = 10

	yoctoValue := NEARToYocto(NEAR)
	orig := YoctoToNEAR(yoctoValue)

	if NEAR != orig {
		t.Errorf("expected: %d, got: %d", NEAR, orig)
	}
}

func TestNEARToYocto_Fuzz(t *testing.T) {
	f := fuzz.New()

	// TODO: ?
	var value uint16

	for i := 0; i < 1000; i++ {
		f.Fuzz(&value)
		newValue := YoctoToNEAR(NEARToYocto(uint64(value)))
		if uint64(value) != newValue {
			t.Errorf("expected: %d, got: %d", value, newValue)
		}
	}
}

'''
'''--- pkg/types/basic.go ---
package types

// Account identifier. Provides access to user's state.
type AccountID = string

// Gas is a type for storing amounts of gas.
type Gas = uint64

// Nonce for transactions.
type Nonce = uint64

// Time nanoseconds fit into uint128. Using existing Balance type which
// implements JSON marshal/unmarshal
type TimeNanos = Balance

// BlockHeight is used for height of the block
type BlockHeight = uint64

// ShardID is used for a shard index, from 0 to NUM_SHARDS - 1.
type ShardID = uint64

// StorageUsage is used to count the amount of storage used by a contract.
type StorageUsage = uint64

// NumBlocks holds number of blocks in current group.
type NumBlocks = uint64

'''
'''--- pkg/types/constants.go ---
package types

var (
	// 30 TGas
	DefaultFunctionCallGas Gas = 30 * 1000000000000
)

'''
'''--- pkg/types/hash/crypto_hash.go ---
package hash

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"

	"github.com/mr-tron/base58"
)

// CryptoHash is a wrapper for SHA-256 digest byte array.
// Note that nearcore also defines MerkleHash as an alias, but it's omitted from this project.
type CryptoHash [sha256.Size]byte

func (c *CryptoHash) UnmarshalJSON(b []byte) (err error) {
	var s string
	if err = json.Unmarshal(b, &s); err != nil {
		return
	}

	if *c, err = NewCryptoHashFromBase58(s); err != nil {
		return
	}

	return nil
}

func (c CryptoHash) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.String())
}

func (c CryptoHash) String() string {
	return base58.Encode(c[:])
}

func NewCryptoHash(data []byte) CryptoHash {
	return CryptoHash(sha256.Sum256(data))
}

func NewCryptoHashFromBase58(blob string) (ch CryptoHash, err error) {
	bytes, err := base58.Decode(blob)
	if err != nil {
		return
	}

	if len(bytes) != sha256.Size {
		return ch, fmt.Errorf("invalid base58 data size %d", bytes)
	}

	copy(ch[:], bytes)
	return
}

func MustCryptoHashFromBase58(blob string) CryptoHash {
	if hash, err := NewCryptoHashFromBase58(blob); err != nil {
		panic(err)
	} else {
		return hash
	}
}

'''
'''--- pkg/types/key/aliases.go ---
package key

// PeerID is the public key
type PeerID = PublicKey

'''
'''--- pkg/types/key/base58_public_key.go ---
package key

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mr-tron/base58"
)

type Base58PublicKey struct {
	Type  PublicKeyType
	Value string

	pk PublicKey
}

func NewBase58PublicKey(raw string) (pk Base58PublicKey, err error) {
	split := strings.SplitN(raw, ":", 2)
	if len(split) != 2 {
		return pk, ErrInvalidPublicKey
	}

	keyTypeRaw := split[0]
	encodedKey := split[1]

	keyType, ok := reverseKeyTypeMapping[keyTypeRaw]
	if !ok {
		return pk, ErrInvalidKeyType
	}

	decoded, err := base58.Decode(encodedKey)
	if err != nil {
		return pk, fmt.Errorf("failed to decode public key: %w", err)
	}

	pk.Type = keyTypes[keyType]
	pk.Value = encodedKey

	pk.pk, err = WrapRawKey(pk.Type, decoded)

	return
}

func (pk Base58PublicKey) String() string {
	return fmt.Sprintf("%s:%s", pk.Type, pk.Value)
}

func (pk Base58PublicKey) MarshalJSON() ([]byte, error) {
	return json.Marshal(pk.String())
}

func (pk *Base58PublicKey) UnmarshalJSON(b []byte) (err error) {
	var s string
	if err = json.Unmarshal(b, &s); err != nil {
		return
	}

	*pk, err = NewBase58PublicKey(s)
	return
}

// Copies Base58PublicKey to PublicKey
func (pk *Base58PublicKey) ToPublicKey() PublicKey {
	var buf PublicKey
	copy(buf[:], pk.pk[:])
	return buf
}

'''
'''--- pkg/types/key/common.go ---
package key

import "errors"

type PublicKeyType string

const (
	RawKeyTypeED25519 byte = iota
	RawKeyTypeSECP256K1
)

const (
	KeyTypeED25519   PublicKeyType = "ed25519"
	KeyTypeSECP256K1 PublicKeyType = "secp256k1"
)

var (
	ErrInvalidPublicKey  = errors.New("invalid public key")
	ErrInvalidPrivateKey = errors.New("invalid private key")
	ErrInvalidKeyType    = errors.New("invalid key type")

	// nolint: deadcode,varcheck,unused
	keyTypes = map[byte]PublicKeyType{
		RawKeyTypeED25519:   KeyTypeED25519,
		RawKeyTypeSECP256K1: KeyTypeSECP256K1,
	}
	reverseKeyTypeMapping = map[string]byte{
		string(KeyTypeED25519):   RawKeyTypeED25519,
		string(KeyTypeSECP256K1): RawKeyTypeSECP256K1,
	}
)

'''
'''--- pkg/types/key/key_pair.go ---
package key

import (
	"crypto/ed25519"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/mr-tron/base58"

	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type KeyPair struct {
	Type PublicKeyType

	PublicKey  Base58PublicKey
	PrivateKey ed25519.PrivateKey
}

func GenerateKeyPair(keyType PublicKeyType, rand io.Reader) (kp KeyPair, err error) {
	if _, ok := reverseKeyTypeMapping[string(keyType)]; !ok {
		return kp, ErrInvalidKeyType
	}

	var rawPub PublicKey

	switch keyType {
	case KeyTypeED25519:
		var pub ed25519.PublicKey
		var priv ed25519.PrivateKey

		pub, priv, err = ed25519.GenerateKey(rand)
		if err != nil {
			return
		}

		rawPub, err = WrapRawKey(keyType, pub)
		if err != nil {
			return
		}

		kp = CreateKeyPair(keyType, rawPub.ToBase58PublicKey(), priv)
	case KeyTypeSECP256K1:
		// TODO
		return kp, fmt.Errorf("SECP256K1 is not supported yet")
	}

	return
}

func CreateKeyPair(keyType PublicKeyType, pub Base58PublicKey, priv ed25519.PrivateKey) KeyPair {
	return KeyPair{
		Type:       keyType,
		PublicKey:  pub,
		PrivateKey: priv,
	}
}

func NewBase58KeyPair(raw string) (kp KeyPair, err error) {
	split := strings.SplitN(raw, ":", 2)
	if len(split) != 2 {
		return kp, ErrInvalidPrivateKey
	}

	keyTypeRaw := split[0]
	encodedKey := split[1]

	keyType, ok := reverseKeyTypeMapping[keyTypeRaw]
	if !ok {
		return kp, ErrInvalidKeyType
	}

	// TODO
	if keyType == RawKeyTypeSECP256K1 {
		return kp, fmt.Errorf("SECP256K1 is not supported yet")
	}

	decoded, err := base58.Decode(encodedKey)
	if err != nil {
		return kp, fmt.Errorf("failed to decode private key: %w", err)
	}

	if len(decoded) != ed25519.PrivateKeySize {
		return kp, ErrInvalidPrivateKey
	}

	var pubKey PublicKey

	theKeyType := keyTypes[keyType]
	privKey := ed25519.PrivateKey(decoded)
	pubKey, err = WrapRawKey(theKeyType, privKey[32:]) // See ed25519.Public()
	if err != nil {
		println("wraprawkey failed")
		return
	}

	kp = CreateKeyPair(theKeyType, pubKey.ToBase58PublicKey(), privKey)

	return
}

func (kp *KeyPair) Sign(data []byte) (sig signature.Signature) {
	sigType := reverseKeyTypeMapping[string(kp.Type)]

	switch sigType {
	//case RawPublicKeyTypeSECP256K1:
	case RawKeyTypeED25519:
		sig = signature.NewSignatureED25519(ed25519.Sign(kp.PrivateKey, data))
	}
	return
}

func (kp *KeyPair) PrivateEncoded() string {
	return fmt.Sprintf("%s:%s", kp.Type, base58.Encode(kp.PrivateKey))
}

func (kp *KeyPair) UnmarshalJSON(b []byte) (err error) {
	var s string
	if err = json.Unmarshal(b, &s); err != nil {
		return
	}

	*kp, err = NewBase58KeyPair(s)
	return
}

'''
'''--- pkg/types/key/public_key.go ---
package key

import (
	"crypto/ed25519"
	"encoding/hex"
	"encoding/json"
	"fmt"

	"github.com/mr-tron/base58"

	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

// TODO: SECP256K1
type PublicKey [33]byte

func (p PublicKey) Hash() string {
	return hex.EncodeToString(p[1:])
}

func (p PublicKey) TypeByte() byte {
	return p[0]
}

func (p PublicKey) Value() []byte {
	return p[1:]
}

func (p PublicKey) MarshalJSON() ([]byte, error) {
	return json.Marshal(base58.Encode(p[:]))
}

func (p PublicKey) String() string {
	return fmt.Sprintf("%s:%s", keyTypes[p.TypeByte()], base58.Encode(p.Value()))
}

func (p *PublicKey) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}

	dec, err := base58.Decode(s)
	if err != nil {
		return err
	}

	*p = PublicKey{}
	copy(p[:], dec)
	return nil
}

func (p *PublicKey) Verify(data []byte, signature signature.Signature) (ok bool, err error) {
	keyType := p.TypeByte()
	if signature.Type() != keyType {
		return false, fmt.Errorf("cannot verify signature type %d with key type %d", signature.Type(), p.TypeByte())
	}

	switch keyType {
	case RawKeyTypeED25519:
		ok = ed25519.Verify(ed25519.PublicKey(p.Value()), data, signature.Value())
	case RawKeyTypeSECP256K1:
		// TODO!
		return false, fmt.Errorf("SECP256K1 is not supported yet")
	}

	return
}

func (p *PublicKey) ToBase58PublicKey() Base58PublicKey {
	return Base58PublicKey{
		Type:  keyTypes[p[0]],
		Value: base58.Encode(p[1:]),
		pk:    *p,
	}
}

func PublicKeyFromBytes(b []byte) (pk PublicKey, err error) {
	f := b[0]
	l := len(b) - 1
	switch f {
	case RawKeyTypeED25519:
		if l != ed25519.PublicKeySize {
			return pk, ErrInvalidPublicKey
		}
		copy(pk[:], b)
		return
	case RawKeyTypeSECP256K1:
		// TODO!
		return pk, fmt.Errorf("SECP256K1 is not supported yet")
	}

	return pk, ErrInvalidKeyType
}

func WrapRawKey(keyType PublicKeyType, key []byte) (pk PublicKey, err error) {
	switch keyType {
	case KeyTypeED25519:
		if len(key) != ed25519.PublicKeySize {
			return pk, ErrInvalidPublicKey
		}

		pk[0] = RawKeyTypeED25519
		copy(pk[1:], key[0:ed25519.PublicKeySize])
		return
	case KeyTypeSECP256K1:
		// TODO!
		return pk, fmt.Errorf("SECP256K1 is not supported yet")
	}

	return pk, ErrInvalidKeyType
}

func WrapED25519(key ed25519.PublicKey) PublicKey {
	if pk, err := WrapRawKey(KeyTypeED25519, key); err != nil {
		panic(err)
	} else {
		return pk
	}
}

'''
'''--- pkg/types/key/public_key_test.go ---
package key_test

import (
	"testing"

	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

func TestED25519Key(t *testing.T) {
	expected := `ed25519:DcA2MzgpJbrUATQLLceocVckhhAqrkingax4oJ9kZ847`

	parsed, err := key.NewBase58PublicKey(expected)
	if err != nil {
		t.Errorf("failed to parse public key: %s", err)
	}

	if s := parsed.String(); s != expected {
		t.Errorf("%s != %s", s, expected)
	}
}

func TestED25519Key_Base58_And_Back(t *testing.T) {
	expected := `ed25519:3xCFas58RKvD5UpF9GqvEb6q9rvgfbEJPhLf85zc4HpC`

	parsed, err := key.NewBase58PublicKey(expected)
	if err != nil {
		t.Errorf("failed to parse public key: %s", err)
	}

	publicKey := parsed.ToPublicKey()
	converted := publicKey.ToBase58PublicKey()

	if s := converted.String(); s != expected {
		t.Errorf("%s != %s", s, expected)
	}
}

'''
'''--- pkg/types/signature/base58_signature.go ---
package signature

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mr-tron/base58"
)

type Base58Signature struct {
	Type  SignatureType
	Value string

	//sig Signature
}

func NewBase58Signature(raw string) (pk Base58Signature, err error) {
	split := strings.SplitN(raw, ":", 2)
	if len(split) != 2 {
		return pk, ErrInvalidSignature
	}

	sigTypeRaw := split[0]
	encodedSig := split[1]

	sigType, ok := reverseSignatureMapping[sigTypeRaw]
	if !ok {
		return pk, ErrInvalidSignatureType
	}

	decoded, err := base58.Decode(encodedSig)
	if err != nil {
		return pk, fmt.Errorf("failed to decode signature: %w", err)
	}

	pk.Type = signatureTypes[sigType]
	pk.Value = encodedSig

	// TODO
	_ = decoded

	return
}

func (sig Base58Signature) String() string {
	return fmt.Sprintf("%s:%s", sig.Type, sig.Value)
}

func (sig Base58Signature) MarshalJSON() ([]byte, error) {
	return json.Marshal(sig.String())
}

func (sig *Base58Signature) UnmarshalJSON(b []byte) (err error) {
	var s string
	if err = json.Unmarshal(b, &s); err != nil {
		return
	}

	*sig, err = NewBase58Signature(s)
	return
}

'''
'''--- pkg/types/signature/common.go ---
package signature

import (
	"errors"
)

type SignatureType string

const (
	RawSignatureTypeED25519 byte = iota
	RawSignatureTypeSECP256K1
)

const (
	SignatureTypeED25519   = SignatureType("ed25519")
	SignatureTypeSECP256K1 = SignatureType("secp256k1")
)

var (
	ErrInvalidSignature     = errors.New("invalid signature")
	ErrInvalidSignatureType = errors.New("invalid signature type")

	signatureTypes = map[byte]SignatureType{
		RawSignatureTypeED25519:   SignatureTypeED25519,
		RawSignatureTypeSECP256K1: SignatureTypeSECP256K1,
	}
	reverseSignatureMapping = map[string]byte{
		string(SignatureTypeED25519):   RawSignatureTypeED25519,
		string(SignatureTypeSECP256K1): RawSignatureTypeSECP256K1,
	}
)

'''
'''--- pkg/types/signature/signature.go ---
package signature

import (
	"crypto/ed25519"
)

// TODO: SECP256K1 support
type Signature [1 + ed25519.SignatureSize]byte

func NewSignatureED25519(data []byte) Signature {
	var buf Signature
	buf[0] = RawSignatureTypeED25519
	copy(buf[1:], data[0:ed25519.SignatureSize])
	return buf
}

func (s Signature) Type() byte {
	return s[0]
}

func (s Signature) Value() []byte {
	return s[1:]
}

'''
'''--- pkg/types/signature/signature_test.go ---
package signature_test

import (
	"testing"
)

func TestED25519Signature(t *testing.T) {
	expected := `ed25519:`

	_ = expected
}

'''
'''--- pkg/types/transaction/signed_transaction.go ---
package transaction

import (
	"encoding/base64"

	"github.com/eteu-technologies/borsh-go"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"
)

type SignedTransaction struct {
	Transaction Transaction
	Signature   signature.Signature

	SerializedTransaction []byte          `borsh_skip:"true"`
	hash                  hash.CryptoHash `borsh_skip:"true"`
	size                  int             `borsh_skip:"true"`
}

func NewSignedTransaction(keyPair key.KeyPair, transaction Transaction) (stxn SignedTransaction, err error) {
	stxn.Transaction = transaction
	stxn.hash, stxn.SerializedTransaction, stxn.Signature, err = transaction.HashAndSign(keyPair)
	if err != nil {
		return
	}

	stxn.size = len(stxn.SerializedTransaction)
	return
}

func (st *SignedTransaction) Hash() hash.CryptoHash {
	return st.hash
}

func (st *SignedTransaction) Size() int {
	return st.size
}

func (st *SignedTransaction) Verify(pubKey key.PublicKey) (ok bool, err error) {
	var txnHash hash.CryptoHash
	txnHash, _, err = st.Transaction.Hash()
	if err != nil {
		return
	}

	return pubKey.Verify(txnHash[:], st.Signature)
}

func (st SignedTransaction) Serialize() (serialized string, err error) {
	var blob []byte

	blob, err = borsh.Serialize(st)
	if err != nil {
		return
	}

	serialized = base64.StdEncoding.EncodeToString(blob)

	return
}

'''
'''--- pkg/types/transaction/transaction.go ---
package transaction

import (
	"github.com/eteu-technologies/borsh-go"
	"github.com/eteu-technologies/near-api-go/pkg/types/signature"

	"github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/eteu-technologies/near-api-go/pkg/types/hash"
	"github.com/eteu-technologies/near-api-go/pkg/types/key"
)

type Transaction struct {
	SignerID   types.AccountID
	PublicKey  key.PublicKey
	Nonce      types.Nonce
	ReceiverID types.AccountID
	BlockHash  hash.CryptoHash
	Actions    []action.Action
}

func (t Transaction) Hash() (txnHash hash.CryptoHash, serialized []byte, err error) {
	// Serialize into Borsh
	serialized, err = borsh.Serialize(t)
	if err != nil {
		return
	}
	txnHash = hash.NewCryptoHash(serialized)
	return
}

func (t Transaction) HashAndSign(keyPair key.KeyPair) (txnHash hash.CryptoHash, serialized []byte, sig signature.Signature, err error) {
	txnHash, serialized, err = t.Hash()
	if err != nil {
		return
	}

	sig = keyPair.Sign(txnHash[:])
	return
}

'''
'''--- pkg/types/transaction/utils.go ---
package transaction

import "github.com/eteu-technologies/near-api-go/pkg/types/key"

func SignAndSerializeTransaction(keyPair key.KeyPair, txn Transaction) (blob string, err error) {
	var stxn SignedTransaction
	if stxn, err = NewSignedTransaction(keyPair, txn); err != nil {
		return
	}

	blob, err = stxn.Serialize()
	return
}

'''