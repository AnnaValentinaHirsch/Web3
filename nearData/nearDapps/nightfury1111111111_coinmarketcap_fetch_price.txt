*GitHub Repository "nightfury1111111111/coinmarketcap_fetch_price"*

'''--- Cargo.toml ---
[package]
name = "test_contract"
version = "0.1.0"
edition = "2021"
author = "MGdev93"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

static_assertions = "1"

[dev-dependencies]
quickcheck = "1.0.3"
quickcheck_macros = "1.0.0"

[profile.release]
codegen-units = 1

opt-level = "z"
lto = true
debug = false
panic = "abort"

overflow-checks = true

'''
'''--- src/lib.rs ---
//Return a average price of Bitcoin.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod util;

//Can change the length of saved price 
const CURRENT_SIZE: usize = 5;

/// Return the array of coin price
#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct PriceHistory {
    price_history: util::PriceArray<f64, CURRENT_SIZE>,
    recorded: u16,
}

#[near_bindgen]
impl PriceHistory {
    /// Returns the average price.
    /// Will panic when not enough historical data has been collected.
    pub fn get_average(&self) -> f64 {
        static_assertions::const_assert_ne!(CURRENT_SIZE, 0);
        if usize::from(self.recorded) != CURRENT_SIZE {
            env::panic(b"Not enough historical data has been collected yet")
        }
        let sum: f64 = self.price_history.iter().sum();
        sum / CURRENT_SIZE as f64
    }

    /// Adds the provided `price` to the storage.
    ///
    /// # Panics
    ///
    /// Will panic when called not from the account which was used to deployed
    /// the contract.
    pub fn record_price(&mut self, price: f64) {
        if env::signer_account_id() != env::current_account_id() {
            // Check unnecessary action
            env::panic(b"This account can't store price data")
        }
        if usize::from(self.recorded) < CURRENT_SIZE {
            // check overflow
            static_assertions::const_assert_ne!(CURRENT_SIZE, usize::MAX);
            self.recorded += 1;
        }
        self.price_history.push(price)
    }

    /// Returns the size of the stored data.
    pub fn depth_so_far(&self) -> usize {
        usize::from(self.recorded)
    }

    /// Return the size of total length of price array
    pub fn required_depth(&self) -> usize {
        CURRENT_SIZE
    }

    /// Reset the history.
    pub fn reset(&mut self) {
        self.recorded = 0;
        env::log(b"History has been reset");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // Hint: copied from one of NEAR SDK examples.
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "alice.testnet".to_string(),
            // if you want to check malicious action use this:
            // signer_account_id: "bob.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn record() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let mut counter = PriceHistory::default();

        for price in [1., 2., 3., 4., 5.] {
            counter.record_price(price);
        }

        let expected = 3.;
        assert!((counter.get_average() - expected).abs() < 1e-5);
    }

    #[test]
    #[should_panic]
    fn empty() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let counter = PriceHistory::default();
        counter.get_average();
    }
}

'''
'''--- src/util.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

// You can set the length of number of stored price - LENGTH
#[derive(Debug, BorshDeserialize, BorshSerialize)]
pub struct PriceArray<T, const LENGTH: usize> {
    array: [T; LENGTH],
    position: usize,
}

// PriceArray must have at least 1 value 
// We don't need to save much numbers of price. Of course we can set up LENGTH = 5 directly, but for for flexibility
// we use this way
impl<T, const LENGTH: usize> Default for PriceArray<T, LENGTH>
where
    T: Default + Copy,
{
    fn default() -> Self {
        if LENGTH == 0 {
            near_sdk::env::panic(b"PriceArray must have at least one value");
        } else if LENGTH > usize::MAX {
            near_sdk::env::panic(b"Too large number of price. Save less numbers");
        }
        Self {
            array: [T::default(); LENGTH],
            position: 0,
        }
    }
}

impl<T, const LENGTH: usize> PriceArray<T, LENGTH> {
    /// Generate new array of price and its length is LENGTH.
    pub fn new() -> Self
    where
        T: Default + Copy,
    {
        Self::default()
    }

    /// Push new value to this array
    pub fn push(&mut self, item: T) {
        let insert_position = (self.position + LENGTH) % LENGTH;
        self.position = (self.position + 1) % LENGTH;
        self.array[insert_position] = item;
    }

    /// Returns an iterator over the queued items.
    pub fn iter(&self) -> PriceIterator<'_, T, LENGTH> {
        PriceIterator {
            array: &self.array,
            start_position: self.position,
            count: LENGTH,
        }
    }
}

impl<'a, T: 'a, const LENGTH: usize> IntoIterator for &'a PriceArray<T, LENGTH> {
    type Item = &'a T;

    type IntoIter = PriceIterator<'a, T, LENGTH>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

/// An iterator over the queued values.
// the iterator could have been implemented alternatively as a chained
// iterator over two consecutive slices.
pub struct PriceIterator<'a, T, const LENGTH: usize> {
    array: &'a [T; LENGTH],
    start_position: usize,
    count: usize,
}

impl<'a, T: 'a, const LENGTH: usize> Iterator for PriceIterator<'a, T, LENGTH> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.count = self.count.checked_sub(1)?;
        let item = &self.array[self.start_position % LENGTH];
        self.start_position += 1;
        Some(item)
    }
}

#[cfg(test)]
mod test {
    use std::collections::VecDeque;

    use super::*;
    use quickcheck::TestResult;
    use quickcheck_macros::quickcheck;

    #[test]
    fn simple_test() {
        let mut queue = PriceArray::<_, 5>::new();
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 0, 0]
        );

        queue.push(100);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 0, 100]
        );

        queue.push(200);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 0, 100, 200]
        );

        queue.push(300);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 0, 100, 200, 300]
        );

        queue.push(400);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![0, 100, 200, 300, 400]
        );

        queue.push(500);
        assert_eq!(
            queue.iter().copied().collect::<Vec<_>>(),
            vec![100, 200, 300, 400, 500]
        );
    }

    #[quickcheck]
    fn extensive_test(input: Vec<u8>) -> TestResult {
        if input.len() < 5 {
            return TestResult::discard();
        }

        let mut reference_queue = VecDeque::with_capacity(5);
        let mut testing_queue = PriceArray::<u8, 5>::new();
        for item in input {
            if reference_queue.len() >= 5 {
                reference_queue.pop_front();
            }
            reference_queue.push_back(item);
            testing_queue.push(item);
        }

        let reference: Vec<_> = reference_queue.into_iter().collect();
        let testing: Vec<_> = testing_queue.iter().copied().collect();

        assert_eq!(reference, testing);

        TestResult::passed()
    }
}

'''