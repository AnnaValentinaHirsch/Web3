*GitHub Repository "near/near-abi-js"*

'''--- README.md ---
# near-abi-js

NEAR smart contract ABI primitives

'''
'''--- lib/index.d.ts ---
import { JSONSchema7 } from 'json-schema';
export declare const SCHEMA_VERSION = "0.3.0";
/** Root model representing the entire contract ABI with all its functions and custom types. */
export interface AbiRoot {
    /** Semver of the ABI schema format. */
    schema_version: string;
    /** Metadata information about the contract. */
    metadata: AbiMetadata;
    /** Core ABI information (functions and types). */
    body: AbiBody;
}
/** Metadata information about the contract. */
export interface AbiMetadata {
    /** The name of the smart contract. */
    name?: string;
    /** The version of the smart contract. */
    version?: string;
    /** The authors of the smart contract. */
    authors?: string[];
    /** The information about how this contract was built. */
    build?: BuildInfo;
    /** The SHA-256 hash of the contract WASM code in Base58 format. */
    wasm_hash?: string;
}
export interface BuildInfo {
    /** The compiler (versioned) that was used to build the contract. */
    compiler: string;
    /** The build tool (versioned) that was used to build the contract. */
    builder: string;
    /** The docker image (versioned) where the contract was built. */
    image?: string;
}
/** Core ABI information. */
export interface AbiBody {
    /** ABIs of all contract's functions. */
    functions: AbiFunction[];
    /** Root JSON schema for the ABI. */
    root_schema: JSONSchema7;
}
/** ABI of a single function. */
export interface AbiFunction {
    name: string;
    /** Human-readable documentation parsed from the source file. */
    doc?: string;
    /** Function kind that regulates whether the function has to be invoked from a transaction. */
    kind: AbiFunctionKind;
    /** List of modifiers affecting the function. */
    modifiers?: AbiFunctionModifier[];
    /** Type identifiers of the function parameters. */
    params?: AbiParameters;
    /** Type identifiers of the callbacks of the function. */
    callbacks?: AbiType[];
    /** Type identifier of the vararg callbacks of the function. */
    callbacks_vec?: AbiType;
    /** Return type identifier. */
    result?: AbiType;
}
/**
 * Function kind regulates whether this function's invocation requires a transaction (so-called
 * call functions) or not (view functions).
 */
export declare enum AbiFunctionKind {
    View = "view",
    Call = "call"
}
/** Function can have multiple modifiers that can change its semantics. */
export declare enum AbiFunctionModifier {
    /** Init functions can be used to initialize the state of the contract. */
    Init = "init",
    /**
     * Private functions can only be called from the contract containing them. Usually, when a
     * contract has to have a callback for a remote cross-contract call, this callback method
     * should only be called by the contract itself.
     */
    Private = "private",
    /** Payable functions can accept token transfer together with the function call.
     * This is done so that contracts can define a fee in tokens that needs to be payed when
     * they are used.
     */
    Payable = "payable"
}
/** Supported serialization formats. */
export declare enum AbiSerializationType {
    Json = "json",
    Borsh = "borsh"
}
/** A list of function parameters sharing the same serialization type. */
export declare type AbiParameters = {
    args: AbiJsonParameter[];
    serialization_type: AbiSerializationType.Json;
} | {
    args: AbiBorshParameter[];
    serialization_type: AbiSerializationType.Borsh;
};
/** Information about a single named JSON function parameter. */
export interface AbiJsonParameter {
    /** Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`). */
    name: string;
    /**
     * JSON Subschema that represents this type (can be an inline primitive, a reference to the root
     * schema and a few other corner-case things).
     */
    type_schema: JSONSchema7;
}
/** Information about a single named Borsh function parameter. */
export interface AbiBorshParameter {
    /** Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`). */
    name: string;
    /** Inline Borsh schema that represents this type. */
    type_schema: any;
}
/** Information about a single type (e.g. function return type). */
export interface AbiType {
    /** The serialization format to be used for values of this type. */
    serialization_type: AbiSerializationType;
    /** Schema describing the type (the actual schema format depends on `serialization_type`). */
    type_schema: any;
}
/** ABI type which values are serialized using JSON format. */
export interface AbiJsonType extends AbiType {
    serialization_type: AbiSerializationType.Json;
    /** JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things). */
    type_schema: JSONSchema7;
}
/** ABI type which values are serialized using Borsh format. */
export interface AbiBorshType extends AbiType {
    serialization_type: AbiSerializationType.Borsh;
    /** Borsh schema that represents this type. */
    type_schema: any;
}

'''
'''--- lib/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiSerializationType = exports.AbiFunctionModifier = exports.AbiFunctionKind = exports.SCHEMA_VERSION = void 0;
exports.SCHEMA_VERSION = "0.3.0";
/**
 * Function kind regulates whether this function's invocation requires a transaction (so-called
 * call functions) or not (view functions).
 */
var AbiFunctionKind;
(function (AbiFunctionKind) {
    AbiFunctionKind["View"] = "view";
    AbiFunctionKind["Call"] = "call";
})(AbiFunctionKind = exports.AbiFunctionKind || (exports.AbiFunctionKind = {}));
/** Function can have multiple modifiers that can change its semantics. */
var AbiFunctionModifier;
(function (AbiFunctionModifier) {
    /** Init functions can be used to initialize the state of the contract. */
    AbiFunctionModifier["Init"] = "init";
    /**
     * Private functions can only be called from the contract containing them. Usually, when a
     * contract has to have a callback for a remote cross-contract call, this callback method
     * should only be called by the contract itself.
     */
    AbiFunctionModifier["Private"] = "private";
    /** Payable functions can accept token transfer together with the function call.
     * This is done so that contracts can define a fee in tokens that needs to be payed when
     * they are used.
     */
    AbiFunctionModifier["Payable"] = "payable";
})(AbiFunctionModifier = exports.AbiFunctionModifier || (exports.AbiFunctionModifier = {}));
/** Supported serialization formats. */
var AbiSerializationType;
(function (AbiSerializationType) {
    AbiSerializationType["Json"] = "json";
    AbiSerializationType["Borsh"] = "borsh";
})(AbiSerializationType = exports.AbiSerializationType || (exports.AbiSerializationType = {}));

'''
'''--- package.json ---
{
  "name": "near-abi",
  "version": "0.1.1",
  "description": "Typescript library providing NEAR smart contract ABI primitives",
  "main": "lib/index.js",
  "browser": "lib/index.js",
  "types": "lib/index.d.ts",
  "author": "Pagoda",
  "license": "(MIT AND Apache-2.0)",
  "dependencies": {
    "@types/json-schema": "^7.0.11"
  },
  "devDependencies": {
    "@types/jest": "^27.5.1",
    "@typescript-eslint/eslint-plugin": "^5.30.1",
    "@typescript-eslint/parser": "^5.30.1",
    "bundlewatch": "^0.3.1",
    "eslint": "^8.18.0",
    "in-publish": "^2.0.0",
    "jest": "^28.1.0",
    "ts-jest": "^28.0.3",
    "ts-jest-resolver": "^2.0.0",
    "ts-morph": "^11.0.3",
    "typedoc": "^0.23.11",
    "typedoc-neo-theme": "^1.1.1",
    "typescript": "^4.8.2",
    "uglifyify": "^5.0.1"
  },
  "scripts": {
    "dist": "yarn doc",
    "prepublish": "not-in-install && yarn build || in-install",
    "compile": "tsc -p ./tsconfig.json",
    "dev": "yarn compile -w",
    "doc": "typedoc src && touch docs/.nojekyll",
    "build": "yarn compile",
    "test": "jest test",
    "lint": "eslint \"src/**/*.ts\"",
    "fix": "eslint \"src/**/*.ts\" --fix",
    "prefuzz": "yarn build",
    "fuzz": "jsfuzz test/fuzz/borsh-roundtrip.js test/fuzz/corpus/"
  },
  "bundlewatch": {
    "files": [
      {
        "path": "dist/near-abi.min.js",
        "maxSize": "105kB"
      }
    ]
  },
  "files": [
    "lib",
    "dist",
    "browser-exports.js"
  ]
}
'''
'''--- src/index.ts ---
import { JSONSchema7 } from 'json-schema';

export const SCHEMA_VERSION = "0.3.0";

/** Root model representing the entire contract ABI with all its functions and custom types. */
export interface AbiRoot {
    /** Semver of the ABI schema format. */
    schema_version: string;
    /** Metadata information about the contract. */
    metadata: AbiMetadata;
    /** Core ABI information (functions and types). */
    body: AbiBody;
}

/** Metadata information about the contract. */
export interface AbiMetadata {
    /** The name of the smart contract. */
    name?: string;
    /** The version of the smart contract. */
    version?: string;
    /** The authors of the smart contract. */
    authors?: string[];
    /** The information about how this contract was built. */
    build?: BuildInfo;
    /** The SHA-256 hash of the contract WASM code in Base58 format. */
    wasm_hash?: string,
}

export interface BuildInfo {
    /** The compiler (versioned) that was used to build the contract. */
    compiler: string;
    /** The build tool (versioned) that was used to build the contract. */
    builder: string,
    /** The docker image (versioned) where the contract was built. */
    image?: string,
}

/** Core ABI information. */
export interface AbiBody {
    /** ABIs of all contract's functions. */
    functions: AbiFunction[];
    /** Root JSON schema for the ABI. */
    root_schema: JSONSchema7;
}

/** ABI of a single function. */
export interface AbiFunction {
    name: string;
    /** Human-readable documentation parsed from the source file. */
    doc?: string;
    /** Function kind that regulates whether the function has to be invoked from a transaction. */
    kind: AbiFunctionKind,
    /** List of modifiers affecting the function. */
    modifiers?: AbiFunctionModifier[],
    /** Type identifiers of the function parameters. */
    params?: AbiParameters;
    /** Type identifiers of the callbacks of the function. */
    callbacks?: AbiType[];
    /** Type identifier of the vararg callbacks of the function. */
    callbacks_vec?: AbiType;
    /** Return type identifier. */
    result?: AbiType;
}

/**
 * Function kind regulates whether this function's invocation requires a transaction (so-called 
 * call functions) or not (view functions).
 */
export enum AbiFunctionKind {
    View = "view",
    Call = "call"
}

/** Function can have multiple modifiers that can change its semantics. */
export enum AbiFunctionModifier {
    /** Init functions can be used to initialize the state of the contract. */
    Init = "init",
    /** 
     * Private functions can only be called from the contract containing them. Usually, when a
     * contract has to have a callback for a remote cross-contract call, this callback method
     * should only be called by the contract itself.
     */
    Private = "private",
    /** Payable functions can accept token transfer together with the function call.
     * This is done so that contracts can define a fee in tokens that needs to be payed when
     * they are used.
     */
    Payable = "payable"
}

/** Supported serialization formats. */
export enum AbiSerializationType {
    Json = "json",
    Borsh = "borsh"
}

/** A list of function parameters sharing the same serialization type. */
export type AbiParameters =
    | {
        args: AbiJsonParameter[];
        serialization_type: AbiSerializationType.Json;
    }
    | {
        args: AbiBorshParameter[];
        serialization_type: AbiSerializationType.Borsh;
    };

/** Information about a single named JSON function parameter. */
export interface AbiJsonParameter {
    /** Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`). */
    name: string;
    /**
     * JSON Subschema that represents this type (can be an inline primitive, a reference to the root
     * schema and a few other corner-case things).
     */
    type_schema: JSONSchema7;
}

/** Information about a single named Borsh function parameter. */
export interface AbiBorshParameter {
    /** Parameter name (e.g. `p1` in `fn foo(p1: u32) {}`). */
    name: string;
    /** Inline Borsh schema that represents this type. */
    type_schema: any;
}

/** Information about a single type (e.g. function return type). */
export interface AbiType {
    /** The serialization format to be used for values of this type. */
    serialization_type: AbiSerializationType;
    /** Schema describing the type (the actual schema format depends on `serialization_type`). */
    type_schema: any;
}

/** ABI type which values are serialized using JSON format. */
export interface AbiJsonType extends AbiType {
    serialization_type: AbiSerializationType.Json;
    /** JSON Subschema that represents this type (can be an inline primitive, a reference to the root schema and a few other corner-case things). */
    type_schema: JSONSchema7;
}

/** ABI type which values are serialized using Borsh format. */
export interface AbiBorshType extends AbiType {
    serialization_type: AbiSerializationType.Borsh;
    // TODO: Add a TS model for Borsh schema to borsh-js
    /** Borsh schema that represents this type. */
    type_schema: any;
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "esModuleInterop": true,
    "lib": [
      "es2015",
      "esnext",
      "dom"
    ],
    "module": "commonjs",
    "target": "es2015",
    "moduleResolution": "node",
    "alwaysStrict": true,
    "outDir": "./lib",
    "declaration": true,
    "preserveSymlinks": true,
    "preserveWatchOutput": true,
    "pretty": false,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "experimentalDecorators": true,
    "resolveJsonModule": true
  },
  "files": [
    "src/index.ts",
  ],
}
'''