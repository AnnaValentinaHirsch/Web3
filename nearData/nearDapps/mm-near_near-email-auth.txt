*GitHub Repository "mm-near/near-email-auth"*

'''--- README.md ---
# Proof-of-Concept for email-based authentication for NEAR

The goal of this repo is to show the Proof of concept of using the DKIM signatures (added by default to emails) as a way to authenticate transactions.

This would allow users to control their NEAR account via email - by setting the command that they would like to execute in the subject, and then sending the email to one of the recipients.

Email would be signed by the sender's server (in current design, we only support gmail) - and this signature can be verified by the contract.

## High level design

The setup consists of 3 sub-projects: worker contract, auth contract and server.

### workers
This is the contract that is running on the 'users' account - to handle delegated requests coming from the auth account.
If NEP 342 is approved, this will no longer be needed.

### auth
This is the main contract that takes are of validating DKIM messages - and passing them to workers (and creating workers accounts).

### server
This is the job that gets emails from the imap server - and sends them as transactions.

IMPORTANT: server doesn't actually have any special powers. It is acting more like a relayer - that takes the incoming email and executes the Near function call. If it tried to change anything in the email contents, then the signature verification in contract would have failed.

'''
'''--- auth/Cargo.toml ---

[package]
name = "contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
mail-parser = "0.7.0"
mailparse = "0.13.7"
getrandom = { version = "0.2", features = ["custom"] }

cfdkim = { path = "../../dkim"}
slog = "2.7.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- auth/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build -p contract --target wasm32-unknown-unknown --release
'''
'''--- auth/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

NEAR_ENV=localnet near deploy  --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm --account_id shard0
'''
'''--- auth/src/lib.rs ---
use mailparse::{addrparse_header, parse_mail, MailHeaderMap};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use near_sdk::{
    env, near_bindgen, AccountId, Balance, Gas, GasWeight, PanicOnDefault, Promise, PublicKey,
    ONE_NEAR,
};
use std::collections::HashMap;

use cfdkim::verify_email_with_resolver;

pub fn always_fail(_: &mut [u8]) -> Result<(), getrandom::Error> {
    unimplemented!()
}

use getrandom::register_custom_getrandom;
register_custom_getrandom!(always_fail);

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct AuthManager {}

const MIN_STORAGE: Balance = 4_200_000_000_000_000_000_000_000; //11.1â“ƒ
const WORKER_CODE: &[u8] = include_bytes!("worker.wasm");

#[derive(Debug, PartialEq)]
pub enum CommandEnum {
    Init,
    AddKey(String),
    DeleteKey,
    Transfer(AccountId, Balance),
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct AddKeyArgs {
    public_key: PublicKey,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct TransferArgs {
    to: AccountId,
    amount: Balance,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct NewContractArgs {
    owner_id: AccountId,
}

// Implement the contract structure
#[near_bindgen]
impl AuthManager {
    #[init]
    pub fn new_contract() -> Self {
        Self {}
    }

    fn create_new_subaccount(prefix: String) {
        let account_id = prefix + "." + &env::current_account_id().to_string();
        let create_args = near_sdk::serde_json::to_vec(&NewContractArgs {
            owner_id: env::current_account_id(),
        })
        .unwrap();

        Promise::new(account_id.parse().unwrap())
            .create_account()
            .transfer(MIN_STORAGE)
            .deploy_contract(WORKER_CODE.to_vec())
            .function_call(
                "new_contract".to_owned(),
                create_args,
                0,
                Gas(200_000_000_000_000),
            );
    }

    fn add_key(prefix: String, key: String) {
        let account_id = prefix + "." + &env::current_account_id().to_string();
        let public_key: PublicKey = key.parse().unwrap();
        let add_key_args = near_sdk::serde_json::to_vec(&AddKeyArgs { public_key }).unwrap();

        Promise::new(account_id.parse().unwrap()).function_call_weight(
            "add_key".to_owned(),
            add_key_args,
            0,
            Gas(200_000_000_000_000),
            GasWeight(1),
        );
    }

    fn transfer(prefix: String, to: AccountId, amount: Balance) {
        let account_id = prefix + "." + &env::current_account_id().to_string();
        let transfer_args = near_sdk::serde_json::to_vec(&TransferArgs { to, amount }).unwrap();

        Promise::new(account_id.parse().unwrap()).function_call_weight(
            "transfer".to_owned(),
            transfer_args,
            0,
            Gas(200_000_000_000_000),
            GasWeight(1),
        );
    }
    fn verify_email(full_email: Vec<u8>) -> (String, String) {
        let email = parse_mail(full_email.as_slice()).unwrap();
        let logger = &slog::Logger::root(slog::Discard, slog::o!());
        //let resolver = Arc::new(MockResolver::new());
        let mut resolver: HashMap<String, String> = HashMap::new();
        resolver.insert(
            "20210112._domainkey.gmail.com".to_owned(), "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq8JxVBMLHZRj1WvIMSHApRY3DraE/EiFiR6IMAlDq9GAnrVy0tDQyBND1G8+1fy5RwssQ9DgfNe7rImwxabWfWxJ1LSmo/DzEdOHOJNQiP/nw7MdmGu+R9hEvBeGRQ Amn1jkO46KIw/p2lGvmPSe3+AVD+XyaXZ4vJGTZKFUCnoctAVUyHjSDT7KnEsaiND2rVsDvyisJUAH+EyRfmHSBwfJVHAdJ9oD8cn9NjIun/EHLSIwhCxXmLJlaJeNAFtcGeD2aRGbHaS7M6aTFP+qk4f2ucRx31cyCxbu50CDVfU+d4JkIDNBFDiV+MIpaDFXIf11bGoS08oBBQiyPXgX0wIDAQAB".to_owned());
        resolver.insert(
            "google._domainkey.near.org".to_owned(), "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvp9AC5ykeX9XfNDcv3lKLft21MpXUTb45fOvSyjArMjmVCJT8mQCkehardajVAFvcBYOk0I9DJtvclvFnDBYV8T69HMGzCmuIibHrw4ImB+VCwLFk7M7lsBgSo5FDS1z8swgMyTsKKFmsLOFmvMXwF+arLIQRNYLwTs/JyPl6ExjQJqfNhVu/A1SqAc2wm1Tg n2i0m+9oj0HI5HZ5VX23T4f2Aew2AxascByQx6ue47avziBtV9c84IpnpFTbrozPkXWKlyjXEY9YArw6LqKg1mn7iQAWoeVQOvC8Kv6O2CVCw+RCLzHiZs8lpu/vwtyJ8hhNoI+tJLKm/Va5C9ZnwIDAQAB".to_owned());

        let result = verify_email_with_resolver(logger, &email, &resolver).unwrap();
        assert!(result.summary() == "pass");

        let from_list =
            addrparse_header(email.get_headers().get_first_header("From").unwrap()).unwrap();

        let addr = match &from_list[0] {
            mailparse::MailAddr::Single(single_email) => single_email.addr.clone(),
            _ => panic!("invalid From header"),
        };

        (
            addr,
            email
                .get_headers()
                .get_first_header("Subject")
                .unwrap()
                .get_value(),
        )
    }

    fn validate_key(key: &String) {
        assert!(key.starts_with("ed25519:"));
        assert_eq!(key.len(), 52);
        assert!(key
            .strip_prefix("ed25519:")
            .unwrap()
            .chars()
            .all(|x| match x {
                'A'..='Z' => true,
                'a'..='z' => true,
                '0'..='9' => true,
                _ => panic!("invalid char {}", x),
            }));
    }

    fn parse_command(header: String) -> CommandEnum {
        if header == "init" {
            return CommandEnum::Init;
        }

        if header.starts_with("add_key") {
            let key = header.strip_prefix("add_key").unwrap().trim().to_owned();
            AuthManager::validate_key(&key);
            return CommandEnum::AddKey(key);
        }

        if header.starts_with("delete_key") {
            return CommandEnum::DeleteKey;
        }

        if header.starts_with("transfer") {
            let data: Vec<&str> = header.split_whitespace().collect();
            assert_eq!(3, data.len());
            assert_eq!("transfer", data[0]);
            //let amount: Balance = data[2].parse().unwrap();
            let fraction: f64 = data[2].parse().unwrap();
            assert!(fraction > 0.0);

            let amount = ((fraction * 100.0) as u128) * (ONE_NEAR / 100);

            let account: AccountId = data[1].parse().unwrap();

            return CommandEnum::Transfer(account, amount);
        }
        panic!("Wrong header");
    }

    fn sender_to_account(sender: String) -> String {
        sender
            .chars()
            .map(|x| match x {
                'a'..='z' => x,
                'A'..='Z' => x,
                '0'..='9' => x,
                '@' => '_',
                '.' => '_',
                '_' => x,
                '-' => x,
                _ => panic!("Unsupported char {}", x),
            })
            .collect()
    }

    pub fn receive_email(full_email: Vec<u8>) {
        // verify email
        let (sender, header) = AuthManager::verify_email(full_email);
        env::log_str(format!("Email verified: {}", sender).as_str());
        let prefix = AuthManager::sender_to_account(sender);
        env::log_str(format!("Account prefix is: {}", prefix).as_str());
        let cmd = AuthManager::parse_command(header);
        match cmd {
            CommandEnum::Init => AuthManager::create_new_subaccount(prefix),
            CommandEnum::AddKey(key) => AuthManager::add_key(prefix, key),
            CommandEnum::Transfer(to, amount) => AuthManager::transfer(prefix, to, amount),
            _ => todo!(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_parse_command() {
        assert_eq!(
            AuthManager::parse_command("init".to_owned()),
            CommandEnum::Init
        );

        assert_eq!(
            AuthManager::parse_command(
                "add_key ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD".to_owned()
            ),
            CommandEnum::AddKey("ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD".to_owned())
        );
        assert_eq!(
            AuthManager::parse_command(
                "add_key     ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD
                \n"
                .to_owned()
            ),
            CommandEnum::AddKey("ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD".to_owned())
        );
        assert_eq!(
            AuthManager::parse_command("transfer foobar.near 134".to_owned()),
            CommandEnum::Transfer("foobar.near".parse().unwrap(), 134 * ONE_NEAR)
        );
    }

    #[test]
    pub fn verify_email() {
        assert_eq!(
            AuthManager::verify_email(include_bytes!("message.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Another message".to_owned()
            )
        );
        assert_eq!(
            AuthManager::verify_email(include_bytes!("empty_email.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Empty email".to_owned()
            )
        );
    }
    #[test]
    #[should_panic]
    pub fn verify_invalid_email() {
        assert_eq!(
            AuthManager::verify_email(include_bytes!("invalid_message.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Another message".to_owned()
            )
        );
    }
}

'''
'''--- sender/Cargo.toml ---
[package]
name = "sender"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-jsonrpc-client = "0.4.1"
near-crypto = "0.15.0"
near-primitives = "0.15.0"
near-chain-configs = "0.15.0"
near-jsonrpc-primitives = "0.15.0"
serde_json = "1.0.85"
native-tls = "0.2.2"
imap = "2.4.1"
itertools = "0.10.5"

tokio = { version = "1.21.2", features = ["macros", "rt-multi-thread"] }

'''
'''--- sender/src/main.rs ---
use std::{env, time::Duration};

use near_crypto::SecretKey;
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::{
    transaction::{Action, FunctionCallAction, Transaction},
    types::{AccountId, BlockReference},
};

use serde_json::json;

extern crate imap;
extern crate native_tls;

fn fetch_inbox_from(
    min_value: u32,
    username: &str,
    password: &str,
) -> imap::error::Result<(u32, Vec<String>)> {
    let domain = "imap.gmail.com";
    let tls = native_tls::TlsConnector::builder().build().unwrap();

    // we pass in the domain twice to check that the server's TLS
    // certificate is valid for the domain we're connecting to.
    let client = imap::connect((domain, 993), domain, &tls).unwrap();

    // the client we have here is unauthenticated.
    // to do anything useful with the e-mails, we need to log in
    let mut imap_session = client.login(username, password).map_err(|e| e.0)?;

    // we want to fetch the first email in the INBOX mailbox
    let mailbox = imap_session.select("INBOX")?;

    let result = if mailbox.exists > min_value {
        let max_value = mailbox.exists;
        let foo = (min_value + 1..=max_value).map(|x| format!("{}", x));

        let messages = imap_session.fetch(itertools::join(foo, ","), "RFC822")?;

        Ok((
            max_value,
            messages
                .iter()
                .map(|message| {
                    let body = message.body().expect("message did not have a body!");
                    std::str::from_utf8(body)
                        .expect("message was not valid utf-8")
                        .to_string()
                })
                .collect(),
        ))
    } else {
        Ok((min_value, vec![]))
    };
    imap_session.logout()?;

    result
}

async fn send_mail_to_near(
    mail: String,
    signer_account_id: &AccountId,
    signer_secret_key: &SecretKey,
    nonce: Option<u64>,
) -> Result<u64, Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect("http://localhost:3030");

    let signer = near_crypto::InMemorySigner::from_secret_key(
        signer_account_id.clone(),
        signer_secret_key.clone(),
    );

    let access_key_query_response = client
        .call(methods::query::RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: signer.account_id.clone(),
                public_key: signer.public_key.clone(),
            },
        })
        .await?;
    let current_nonce = match access_key_query_response.kind {
        QueryResponseKind::AccessKey(access_key) => access_key.nonce,
        _ => Err("failed to extract current nonce")?,
    };

    let nonce = if let Some(nonce) = nonce {
        std::cmp::max(nonce, current_nonce)
    } else {
        current_nonce
    };

    println!("Will use nonce {}", nonce + 1);

    let payload = mail.as_bytes().to_vec();

    let transaction = Transaction {
        signer_id: signer.account_id.clone(),
        public_key: signer.public_key.clone(),
        nonce: nonce + 1,
        receiver_id: signer_account_id.clone(),
        block_hash: access_key_query_response.block_hash,
        actions: vec![Action::FunctionCall(FunctionCallAction {
            method_name: "receive_email".to_string(),
            args: json!({ "full_email": payload }).to_string().into_bytes(),
            gas: 300_000_000_000_000, // 100 TeraGas
            deposit: 0,
        })],
    };

    let request = methods::broadcast_tx_async::RpcBroadcastTxAsyncRequest {
        signed_transaction: transaction.sign(&signer),
    };

    let tx_hash = client.call(request).await?;

    println!("Sent request {}", tx_hash);

    Ok(nonce + 1)
}

#[tokio::main]

async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let near_account: AccountId = env::var("SENDER_NEAR_ACCOUNT")?.parse().unwrap();
    let near_account_secret_key: SecretKey = env::var("SENDER_SECRET_KEY")?.parse().unwrap();
    let imap_username = env::var("SENDER_IMAP_USERNAME")?;
    let imap_password = env::var("SENDER_IMAP_PASSWORD")?;

    println!("Starting...");

    // CHANGE.
    let mut min_value = 0;
    let (value, _) =
        fetch_inbox_from(min_value, imap_username.as_str(), imap_password.as_str()).unwrap();
    min_value = value;
    println!("Already {} email present - ignoring.", min_value);

    loop {
        let (value, mails) =
            fetch_inbox_from(min_value, imap_username.as_str(), imap_password.as_str()).unwrap();
        min_value = value;
        let mut nonce = None;
        if mails.len() > 0 {
            println!("Got new mail: {:?}", mails.len());
            for mail in mails.iter() {
                let result =
                    send_mail_to_near(mail.clone(), &near_account, &near_account_secret_key, nonce)
                        .await?;
                nonce = Some(result);
            }
        }
        tokio::time::sleep(Duration::from_secs(10)).await;
    }
}

'''
'''--- worker/Cargo.toml ---

[package]
name = "contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- worker/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- worker/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

NEAR_ENV=localnet near deploy  --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm --account_id shard0
'''
'''--- worker/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise, PublicKey};

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_contract(owner_id: AccountId) -> Self {
        Self { owner_id }
    }

    pub fn add_key(self, public_key: PublicKey) {
        assert!(env::predecessor_account_id() == self.owner_id);
        Promise::new(env::current_account_id()).add_full_access_key(public_key);
    }

    pub fn delete_key(self, public_key: PublicKey) {
        assert!(env::predecessor_account_id() == self.owner_id);
        Promise::new(env::current_account_id()).delete_key(public_key);
    }

    pub fn transfer(self, to: AccountId, amount: Balance) {
        assert!(env::predecessor_account_id() == self.owner_id);
        Promise::new(to).transfer(amount);
    }
}

'''