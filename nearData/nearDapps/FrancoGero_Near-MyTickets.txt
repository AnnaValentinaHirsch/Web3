*GitHub Repository "FrancoGero/Near-MyTickets"*

'''--- README.md ---
WinWin
==================

This app was initialized with [create-near-app]

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

Exploring The Code
==================

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contrato. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `WinWin.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `WinWin.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account WinWin.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contrato. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'WinWin.YOUR-NAME.testnet'

Step 3: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- contract/Cargo.toml ---
[package]
name = "my_tickets"
version = "0.1.0"
authors = ["franco-geroli.near"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"
bs58 = "0.4.0"
wee_alloc = { version = "0.4.5", default-features = false, features = [] }
near-env = "0.1.10"
uint = { version = "0.9.1", default-features = false }
sha2 = "0.10.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- contract/README.md ---
WinWin Smart ContratoNft
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/src/context.rs ---
use std::convert::TryInto;

use near_sdk::{bs58, json_types::ValidAccountId};
use sha2::{Digest, Sha256};

use crate::ValidGateId;

#[macro_export]
macro_rules! mock_context {
    () => {
        use near_sdk::{testing_env, MockedBlockchain};

        pub struct MockedContext<T> {
            contract: T,
            pub context: ::near_sdk::VMContext,
        }

        impl<T> ::std::ops::Deref for MockedContext<T> {
            type Target = T;

            fn deref(&self) -> &Self::Target {
                &self.contract
            }
        }

        impl<T> ::std::ops::DerefMut for MockedContext<T> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                self.update_context();
                &mut self.contract
            }
        }

        impl<T> MockedContext<T> {
            pub fn new<F>(init: F) -> Self
            where
                F: FnOnce() -> T,
            {
                let context = ::near_sdk::test_utils::VMContextBuilder::new().build();
                testing_env!(context.clone());
                Self { contract: init(), context }
            }

            /// Runs the given `action` as account `account_id`.
            pub fn run_as<S, F>(&mut self, account_id: S, action: F) -> &mut Self
            where
                F: FnOnce(&mut MockedContext<T>) -> (),
                S: AsRef<String>,
            {
                self.context.predecessor_account_id = account_id.as_ref().clone();
                self.update_context();
                action(self);
                self
            }

            pub fn attach_deposit(&mut self, attached_deposit: u128) -> &mut Self {
                self.context.attached_deposit = attached_deposit;
                self
            }

            pub fn pred_id(&self) -> ValidAccountId {
                self.context.predecessor_account_id.clone().try_into().unwrap()
            }

            fn update_context(&mut self) {
                use std::convert::TryInto;

                self.context.random_seed =
                    (u128::from_le_bytes(self.context.random_seed[..16].try_into().unwrap()) + 1)
                        .to_ne_bytes()
                        .to_vec();
                self.context.block_timestamp += 1;
                testing_env!(self.context.clone());
            }
        }
    };
}

pub fn any() -> ValidAccountId {
    "any".try_into().unwrap()
}

pub fn mintgate_admin() -> ValidAccountId {
    "admin".try_into().unwrap()
}

pub fn fee_reventa_id_address() -> ValidAccountId {
    "fee_reventa_id_address".try_into().unwrap()
}

pub fn alice() -> ValidAccountId {
    "alice".try_into().unwrap()
}

pub fn bob() -> ValidAccountId {
    "bob".try_into().unwrap()
}

pub fn charlie() -> ValidAccountId {
    "charlie".try_into().unwrap()
}

pub fn nft() -> ValidAccountId {
    "nft".try_into().unwrap()
}

pub fn market() -> ValidAccountId {
    "market".try_into().unwrap()
}

pub fn gate_id(n: u16) -> ValidGateId {
    let mut hasher = Sha256::new();
    hasher.update((n as u64).to_ne_bytes());
    let result = hasher.finalize();
    let data: &[u8] = result[..16].try_into().unwrap();
    bs58::encode(data).into_string().try_into().unwrap()
}

'''
'''--- contract/src/core_nft.rs ---
#[cfg(not(target_arch = "wasm"))]
pub use crate::context::*;
//mod context;

use fraction::Fraction;
use gate::{GateId, ValidGateId};
use near_env::PanicMessage;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::{U128, U64},
    serde::{Deserialize, Serialize},
    AccountId, CryptoHash,
};
use std::collections::HashMap;

#[derive(Serialize, PanicMessage)]
#[serde(crate = "near_sdk::serde", tag = "err")]
pub enum CorePanics {
    /// Thrown when a denominator in a `Fraction` is `0`.
    #[panic_msg = "Denominator must be a positive number, but was 0"]
    ZeroDenominatorFraction,
    /// Thrown when a `Fraction` is more than `1`.
    #[panic_msg = "The fraction must be less or equal to 1"]
    FractionGreaterThanOne,
}

pub mod fraction {

    use super::CorePanics;
    use near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        serde::{Deserialize, Serialize},
        Balance,
    };
    use std::{fmt::Display, num::ParseIntError, str::FromStr, u128};

    uint::construct_uint! {
        /// 256-bit unsigned integer.
        struct U256(4);
    }

    /// Represents a number between `0` and `1`.
    /// It is meant to be used as percentage to calculate both fees and royalties.
    /// As with usual fractions, `den`ominator cannot be `0`.
    /// Morever, `num` must be less or equal than `den`.
    #[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq)]
    #[cfg_attr(not(target_arch = "wasm"), derive(Debug, Clone, Copy))]
    #[serde(crate = "near_sdk::serde")]
    pub struct Fraction {
        /// The *numerator* of this `Fraction`.
        pub num: u32,
        /// The *denominator* of this `Fraction`.
        pub den: u32,
    }

    impl Fraction {
        /// Checks the given `Fraction` is valid, *i.e.*,
        /// - Has a non-zero denominator, and
        /// - The `num` is less or equal than `den`ominator.
        pub fn check(&self) {
            if self.den == 0 {
                CorePanics::ZeroDenominatorFraction.panic();
            }
            if self.num > self.den {
                CorePanics::FractionGreaterThanOne.panic();
            }
        }

        /// Multiplies this `Fraction` by the given `value`.
        pub fn mult(&self, value: Balance) -> Balance {
            (U256::from(self.num) * U256::from(value) / U256::from(self.den)).as_u128()
        }
    }

    impl PartialEq for Fraction {
        fn eq(&self, other: &Self) -> bool {
            self.mult(u128::MAX) == other.mult(u128::MAX)
        }
    }

    impl PartialOrd for Fraction {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            self.mult(u128::MAX).partial_cmp(&other.mult(u128::MAX))
        }
    }

    impl Ord for Fraction {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            self.mult(u128::MAX).cmp(&other.mult(u128::MAX))
        }
    }

    impl Display for Fraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}/{}", self.num, self.den)
        }
    }

    #[cfg(not(target_arch = "wasm"))]
    impl FromStr for Fraction {
        type Err = ParseIntError;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let parts = s.split("/").collect::<Vec<&str>>();
            Ok(Self { num: parts[0].parse::<u32>()?, den: parts[1].parse::<u32>()? })
        }
    }
}

pub mod gate {

    use near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        serde::{self, Serialize},
    };
    use std::convert::{TryFrom, TryInto};
    use std::fmt;

     pub type GateId = String;

    #[derive(Debug, Clone, PartialEq, PartialOrd, BorshDeserialize, BorshSerialize, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    pub struct ValidGateId(GateId);

    impl ValidGateId {
        fn is_valid(&self) -> bool {
            let gate_id = self.0.as_bytes();

            if gate_id.len() == 0 || gate_id.len() > 32 {
                return false;
            }

            for c in gate_id {
                match *c {
                    b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_' | b'-' => {}
                    _ => return false,
                }
            }
            true
        }

        pub fn to_string(&self) -> String {
            self.0.clone()
        }
    }

    impl fmt::Display for ValidGateId {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.0)
        }
    }

    impl AsRef<GateId> for ValidGateId {
        fn as_ref(&self) -> &GateId {
            &self.0
        }
    }

    impl<'de> serde::Deserialize<'de> for ValidGateId {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as serde::Deserializer<'de>>::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let s = <String as serde::Deserialize>::deserialize(deserializer)?;
            s.try_into().map_err(|err: Box<dyn std::error::Error>| {
                serde::de::Error::custom(err.to_string())
            })
        }
    }

    impl TryFrom<&str> for ValidGateId {
        type Error = Box<dyn std::error::Error>;

        fn try_from(value: &str) -> Result<Self, Self::Error> {
            Self::try_from(value.to_string())
        }
    }

    impl TryFrom<String> for ValidGateId {
        type Error = Box<dyn std::error::Error>;

        fn try_from(value: String) -> Result<Self, Self::Error> {
            let res = Self(value);
            if res.is_valid() {
                Ok(res)
            } else {
                Err("The gate ID is invalid".into())
            }
        }
    }

    impl From<ValidGateId> for GateId {
        fn from(value: ValidGateId) -> Self {
            value.0
        }
    }
}

/// The `TokenId` type represents the identifier of each `Token`.
/// This type can be used in both public interfaces and internal `struct`s.
/// See https://github.com/near-examples/NFT/issues/117 for background.
pub type TokenId = U64;

/// Unix epoch, expressed in miliseconds.
/// Note that 64 bits `number`s cannot be represented in JavaScript,
/// thus maximum number allowed is `2^53`.
pub type Timestamp = u64;

/// Mapping from `AccountId`s to balance (in NEARs).
/// The balance indicates the amount a Marketplace contract should pay when a Token is being sold.
pub type Payout = HashMap<AccountId, U128>;

/// Returns the sha256 of `value`.
pub fn crypto_hash(value: &String) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(value.as_bytes()));
    hash
}

/// A `Collectible` represents something of value.
/// `Token`s can be then minted from a given ticket.
/// A ticket is identified by `gate_id`.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Collectible {
    /// The unique identifier of this `Collectible`.
    pub gate_id: GateId,
    /// The account id that created this `Collectible`.
    pub id_creador: AccountId,
    /// Indicates how many `Token`s can be minted out of this `Collectible`.
    pub cantidad_actual: u16,
    /// The list of `TokenId`s actually minted out of this `Collectible`.
    pub tokens_creados: Vec<TokenId>,
    /// Indicates the comision as percentage (in NEARs) to be paid to `id_creador`
    /// every time a minted token out of this `Collectible` is reselled.
    pub comision: Fraction,
    /// Additional info provided by NEP-177.
    pub metadata: Metadata,
}

/// Represents a copy made out of a given ticket.
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm"), derive(PartialEq, Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    /// The unique identifier for a `Token`.
    /// Any two different tokens, will have different `token_id`s,
    /// even if they belong to different `gate_id`s.
    pub token_id: TokenId,
    /// The ticket identifier for this `Token`.
    pub gate_id: GateId,
    /// The owner of this token.
    pub owner_id: AccountId,
    /// Represents when this `Token` was minted, in nanoseconds.
    /// Once this `Token` is minted, this field remains unchanged.
    pub created_at: Timestamp,
    /// Represents when this `Token` was last modified, in nanoseconds.
    /// Either when created or transferred.
    pub modified_at: Timestamp,
    /// Holds the list of accounts that can `transfer_token`s on behalf of the token's owner.
    /// It is mapped to the approval id and minimum amount that this token should be transfer for.
    pub approvals: HashMap<AccountId, TokenApproval>,
    /// Counter to assign next approval ID.
    pub approval_counter: U64,

    #[borsh_skip]
    /// Additional info defined by NEP-177.
    /// This `metadata` effectively joins fields from its respective `gate_id`.
    pub metadata: Metadata,
}

/// Associated metadata with a `GateId` as defined by NEP-177
///
/// Doc-comments for these fields were taken from:
/// <https://nomicon.io/Standards/NonFungibleToken/Metadata.html#interface>
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Default)]
#[cfg_attr(not(target_arch = "wasm"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Metadata {
    /// ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055".
    pub titulo: Option<String>,
    /// Free-form descripcion.
    pub descripcion: Option<String>,
    /// URL to associated media, preferably to decentralized, content-addressed storage.
    pub media: Option<String>,
    /// Base64-encoded sha256 hash of content referenced by the `media` field.
    /// Required if `media` is included.
    pub media_hash: Option<String>,
    /// Number of copias of this set of metadata in existence when token was minted.
    pub copias: Option<u16>,
    /// UNIX epoch datetime (in miliseconds) when token was issued or minted.
    pub emitido_en: Option<Timestamp>,
    /// UNIX epoch datetime (in miliseconds) when token expires.
    pub expira_en: Option<Timestamp>,
    /// UNIX epoch datetime (in miliseconds) when token starts being valid.
    pub comienzo_en: Option<Timestamp>,
    /// UNIX epoch datetime (in miliseconds) when token was last updated.
    pub actualizado_en: Option<Timestamp>,
    /// Anything extra the NFT wants to store on-chain.
    /// It can be stringified JSON.
    pub extra: Option<String>,
    /// URL to an off-chain JSON file with more info.
    pub referencia: Option<String>,
    /// Base64-encoded sha256 hash of JSON from referencia field.
    /// Required if `referencia` is included.
    pub referencia_hash: Option<String>,
}

/// Represents an individual approval by some marketplace account id.
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm"), derive(PartialEq, Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct TokenApproval {
    /// Id used to avoid selling the same token more than once.
    pub aprobados_id: U64,
    /// Minimum price a token should be sell for.
    pub min_precio: U128,
}

impl TokenApproval {
    #[cfg(not(target_arch = "wasm"))]
    pub fn new(aprobados_id: u64, min_precio: U128) -> Self {
        Self { aprobados_id: aprobados_id.into(), min_precio }
    }
}

/// Non-Fungible Token (NEP-171) v1.0.0
/// https://nomicon.io/Standards/NonFungibleToken/Core.html
///
/// Payouts is part of an ongoing (yet not settled) NEP spec:
/// <https://github.com/thor314/NEPs/blob/patch-5/specs/Standards/NonFungibleToken/payouts.md>
pub mod nep171 {

    use super::{Payout, Token, TokenId};
    use near_env::near_ext;
    use near_sdk::ext_contract;
    use near_sdk::json_types::{ValidAccountId, U128, U64};

    #[near_ext]
    #[ext_contract(nft)]
    pub trait NonFungibleTokenCore {
        fn nft_transfer(
            &mut self,
            receiver_id: ValidAccountId,
            token_id: TokenId,
            enforce_approval_id: Option<U64>,
            memo: Option<String>,
        );

        fn nft_payout(&self, token_id: U64, balance: U128) -> Payout;

        fn nft_transfer_payout(
            &mut self,
            receiver_id: ValidAccountId,
            token_id: TokenId,
            aprobados_id: Option<U64>,
            memo: Option<String>,
            balance: Option<U128>,
        ) -> Option<Payout>;

        fn nft_token(&self, token_id: TokenId) -> Option<Token>;
    }
}

/// Non-Fungible Token Metadata (NEP-177) v1.0.0
///
/// <https://nomicon.io/Standards/NonFungibleToken/Metadata.html>
pub mod nep177 {

    use near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        serde::{Deserialize, Serialize},
    };

    /// Associated metadata for the NFT contract as defined by NEP-177
    ///
    /// Doc-comments for these fields were taken from:
    /// <https://nomicon.io/Standards/NonFungibleToken/Metadata.html#interface>
    #[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone)]
    #[cfg_attr(not(target_arch = "wasm"), derive(PartialEq, Debug))]
    #[serde(crate = "near_sdk::serde", deny_unknown_fields)]
    pub struct NFTContractMetadata {
        /// Required, essentially a version like "nft-1.0.0".
        pub spec: String,
        /// Required, ex. "Mochi Rising — Digital Edition" or "Metaverse 3".
        pub name: String,
        /// Required, ex. "MOCHI".
        pub symbol: String,
        /// Data URL.
        pub icon: Option<String>,
        /// Centralized gateway known to have reliable access to decentralized storage assets referenced by `referencia` or `media` URLs.
        pub base_uri: Option<String>,
        /// URL to a JSON file with more info.
        pub referencia: Option<String>,
        /// Base64-encoded sha256 hash of JSON from referencia field. Required if `referencia` is included.
        pub referencia_hash: Option<String>,
    }

    pub trait NonFungibleTokenMetadata {
        fn nft_metadata(&self) -> NFTContractMetadata;
    }
}

/// Non-Fungible Token Approval Management (NEP-178) v1.0.0
///
/// <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
pub mod nep178 {

    use super::{MarketApproveMsg, TokenId};
    use near_env::near_ext;
    use near_sdk::{
        ext_contract,
        json_types::{ValidAccountId, U64},
        Promise,
    };

    pub trait NonFungibleTokenApprovalMgmt {
        fn nft_approve(
            &mut self,
            token_id: TokenId,
            account_id: ValidAccountId,
            msg: Option<String>,
        ) -> Promise;

        fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId) -> Promise;

        fn nft_revoke_all(&mut self, token_id: TokenId);
    }

    /// This interface defines methods to be called
    /// when approval or removal happened in a NFT contrato.
    #[near_ext]
    #[ext_contract(market)]
    pub trait NonFungibleTokenApprovalsReceiver {
        fn nft_on_approve(
            &mut self,
            token_id: TokenId,
            owner_id: ValidAccountId,
            aprobados_id: U64,
            msg: String,
        );

        fn batch_on_approve(
            &mut self,
            tokens: Vec<(TokenId, MarketApproveMsg)>,
            owner_id: ValidAccountId,
        );

        fn nft_on_revoke(&mut self, token_id: TokenId);
    }
}

/// Non-Fungible Token Enumeration (NEP-181) v1.0.0
///
/// <https://nomicon.io/Standards/NonFungibleToken/Enumeration.html>
pub mod nep181 {

    use super::{Token, TokenId};
    use near_sdk::json_types::{ValidAccountId, U64};

    pub trait NonFungibleTokenEnumeration {
        fn nft_total_supply(&self) -> U64;

        fn nft_tokens(&self, from_index: Option<U64>, limit: Option<u32>) -> Vec<Token>;

        fn nft_supply_for_owner(&self, account_id: ValidAccountId) -> U64;

        fn nft_tokens_for_owner(
            &self,
            account_id: ValidAccountId,
            from_index: Option<U64>,
            limit: Option<u32>,
        ) -> Vec<Token>;

        fn nft_token_uri(&self, token_id: TokenId) -> Option<String>;
    }
}

/// In our implementation of the standard,
/// The `nft_approve` method must conform with the following:
/// - The `msg` argument must contain a value, *i.e.*, cannot be `None`.
/// - The value of `msg` must be a valid JSON,
///   that deserializes to this struct.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NftApproveMsg {
    /// Indicates the minimum price (in NEARs) requested by owner to pay for the token.
    pub min_precio: U128,
}

/// Represents the payload that arrives to the Marketplace contract,
/// from our NFT implementation.
/// It contains the `min_precio` of the token.
/// Additionally it is augmented with `gate_id` and `id_creador`
/// so the Marketplace can lookup by this fields.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketApproveMsg {
    /// Indicates the minimum price (in NEARs) that an account must pay to buy a token.
    pub min_precio: U128,
    /// Represents the `gate_id` of the token being approved if present.
    pub gate_id: Option<ValidGateId>,
    /// Represents the `id_creador` of the ticket of the token being approved if present.
    pub id_creador: Option<AccountId>,
}

'''
'''--- contract/src/lib.rs ---
/// NEAR DAPP, My Ticket
/// @Dev Franco Geroli
/// 
/// - Las funciones relacionadas a un token retornan su metadata para su 
/// posterior uso en una API

/// Importación de librerías y módulos
pub use crate::core_nft::*;
pub use crate::market::*;
pub use crate::context::*;
mod core_nft;
mod market;
mod context;

use fraction::Fraction;
use nep171::NonFungibleTokenCore;
use nep177::{NFTContractMetadata, NonFungibleTokenMetadata};
use nep178::NonFungibleTokenApprovalMgmt;
use nep181::NonFungibleTokenEnumeration;
use near_env::{near_ext, near_log, PanicMessage};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, UnorderedMap, UnorderedSet},
    env, ext_contract,
    json_types::{ValidAccountId, U128, U64},
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    serde_json, setup_alloc, AccountId, Balance, BorshStorageKey, CryptoHash, Gas, PanicOnDefault,
    Promise, PromiseResult,
};
use std::{collections::HashMap, convert::TryInto, fmt::Display};

setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContratoNft {
    /// La coleccion de tickets se guardan en mappings
    tickets: UnorderedMap<GateId, Collectible>,
    tickets_de_creador: LookupMap<AccountId, UnorderedSet<GateId>>,
    tokens: UnorderedMap<TokenId, Token>,
    tokens_de_address: LookupMap<AccountId, UnorderedSet<TokenId>>,

    id_admin: AccountId,
    metadata: NFTContractMetadata,
    fee_reventa: Fraction,
    fee_reventa_id_address: AccountId,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum Keys {
    Tickets,
    TicketsPorCreador,
    TicketsPorCreadorValor { hash_id_creador: CryptoHash },
    Tokens,
    TokensPorDueño,
    TokensPorDueñoValor { hash_id_dueño: CryptoHash },
}

/// Metodos del contrato principal
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl ContratoNft {
    /// Inicializa el contrato, si no se le llama explicitamente retorna un Panic
    ///
    /// `id_admin` es la cuenta del contrato
    /// `min_comision` y `max_comision` indicates what must be the max and min comision respectively when creating a ticket.
    /// `fee_reventa` es el porcentaje que se paga a `fee_reventa_id_address` al revender
    #[init]
    pub fn init(
        id_admin: ValidAccountId,
        metadata: NFTContractMetadata,
        min_comision: Fraction,
        max_comision: Fraction,
        fee_reventa: Fraction,
        fee_reventa_id_address: ValidAccountId,
    ) -> Self {
        min_comision.check();
        max_comision.check();
        fee_reventa.check();

        Self {
            tickets: UnorderedMap::new(Keys::Tickets),
            tickets_de_creador: LookupMap::new(Keys::TicketsPorCreador),
            tokens: UnorderedMap::new(Keys::Tokens),
            tokens_de_address: LookupMap::new(Keys::TokensPorDueño),
            id_admin: id_admin.as_ref().to_string(),
            metadata,
            fee_reventa,
            fee_reventa_id_address: fee_reventa_id_address.to_string(),
        }
    }

    /// Crea una nueva seri de tickets indentificando por IDs
    /// `cantidad` indica la cantidad maxima
    /// `comision` indica la comision, en porcentaje, que se paga al creador al momento de la venta
    ///
    /// Entre comision y fee no pueden superar 1, de lo contrario da error
    pub fn crear_ticket(
        &mut self,
        id_creador: ValidAccountId,
        gate_id: ValidGateId,
        titulo: String,
        descripcion: String,
        cantidad: u16,
        comision: Fraction,
        media: Option<String>,
        media_hash: Option<String>,
        referencia: Option<String>,
        referencia_hash: Option<String>,
    ) {
        let gate_id = gate_id.to_string();

        let bn = 1_000_000_000_000_000_000_000;
        if self.fee_reventa.mult(bn) + comision.mult(bn) >= bn {
            Panic::RoyaltyTooLarge { comision, fee_reventa: self.fee_reventa }.panic();
        }
        if self.tickets.get(&gate_id).is_some() {
            Panic::GateIdAlreadyExists { gate_id }.panic();
        }
        if cantidad == 0 {
            Panic::ZeroSupplyNotAllowed { gate_id }.panic();
        }
        if titulo.len() > 140 {
            Panic::InvalidArgument { gate_id, reason: "Titulo no puede tener mas de 140 caracteres".to_string() }
                .panic();
        }
        if descripcion.len() > 1024 {
            Panic::InvalidArgument {
                gate_id,
                reason: "`La descripcion no puede sobrepasar los 1024 caracteres".to_string(),
            }
            .panic();
        }

        macro_rules! check {
            ($arg:ident) => {{
                if let Some(val) = &$arg {
                    if val.len() > 1024 {
                        Panic::InvalidArgument {
                            gate_id,
                            reason: concat!("`", stringify!($arg), "` exceeds 1024 chars")
                                .to_string(),
                        }
                        .panic();
                    }
                }
            }};
        }

        check!(media);
        check!(media_hash);
        check!(referencia);
        check!(referencia_hash);

        if env::predecessor_account_id() != self.id_admin {
            Panic::AdminRestrictedOperation.panic();
        }

        let id_creador = AccountId::from(id_creador);
        let ahora = env::block_timestamp() / 1_000_000;

        let ticket = Collectible {
            gate_id,
            id_creador,
            cantidad_actual: cantidad,
            tokens_creados: Vec::new(),
            comision,
            metadata: Metadata {
                titulo: Some(titulo),
                descripcion: Some(descripcion),
                media,
                media_hash,
                copias: Some(cantidad),
                emitido_en: Some(ahora),
                expira_en: None,
                comienzo_en: Some(ahora),
                actualizado_en: None,
                extra: None,
                referencia,
                referencia_hash,
            },
        };
        self.tickets.insert(&ticket.gate_id, &ticket);

        let mut guia =
            self.tickets_de_creador.get(&ticket.id_creador).unwrap_or_else(|| {
                UnorderedSet::new(Keys::TicketsPorCreadorValor {
                    hash_id_creador: crypto_hash(&ticket.id_creador),
                })
            });
        guia.insert(&ticket.gate_id);

        self.tickets_de_creador.insert(&ticket.id_creador, &guia);
    }

    /// Retona un ticket indicado segun ID
    pub fn get_ticket_por_id(&self, gate_id: ValidGateId) -> Option<Collectible> {
        let gate_id = gate_id.to_string();

        match self.tickets.get(&gate_id) {
            None => None,
            Some(ticket) => {
                assert!(ticket.gate_id == gate_id);
                Some(ticket)
            }
        }
    }

    /// Retorna los ticket de un creador
    pub fn get_tickets_de_creador(&self, id_creador: ValidAccountId) -> Vec<Collectible> {
        match self.tickets_de_creador.get(id_creador.as_ref()) {
            None => Vec::new(),
            Some(list) => list
                .iter()
                .map(|gate_id| {
                    let ticket = self.tickets.get(&gate_id).expect("Gate Id not found");
                    assert!(ticket.gate_id == gate_id);
                    assert!(&ticket.id_creador == id_creador.as_ref());
                    ticket
                })
                .collect(),
        }
    }

    /// Elimina ticket segun ID indicado
    /// Puede ejecutarse solo por `id_creador` y `id_admin` 
    pub fn borrar_ticket(&mut self, gate_id: ValidGateId) {
        let gate_id: GateId = From::from(gate_id);
        match self.tickets.get(&gate_id) {
            None => Panic::GateIdNotFound { gate_id }.panic(),
            Some(ticket) => {
                assert!(ticket.gate_id == gate_id);
                if !ticket.tokens_creados.is_empty() {
                    Panic::GateIdHasTokens { gate_id }.panic();
                }
                let pred_id = env::predecessor_account_id();
                if pred_id == ticket.id_creador || pred_id == self.id_admin {
                    self.tickets.remove(&gate_id).unwrap();

                    let mut cs = self.tickets_de_creador.get(&ticket.id_creador).unwrap();
                    let removed = cs.remove(&gate_id);
                    assert!(removed);
                    self.tickets_de_creador.insert(&ticket.id_creador, &cs);
                } else {
                    Panic::NotAuthorized { gate_id }.panic();
                }
            }
        }
    }

    /// Permite la comprar de un token y retorna token ID
    pub fn comprar_token(&mut self, gate_id: ValidGateId) -> TokenId {
        let gate_id = gate_id.to_string();

        match self.tickets.get(&gate_id) {
            None => Panic::GateIdNotFound { gate_id }.panic(),
            Some(mut ticket) => {
                if ticket.cantidad_actual == 0 {
                    Panic::GateIdExhausted { gate_id }.panic()
                }

                let owner_id = env::predecessor_account_id();
                let ahora = env::block_timestamp() / 1_000_000;

                let token_id = self.tokens.len();
                let token = Token {
                    token_id: U64::from(token_id),
                    gate_id: gate_id.clone(),
                    owner_id,
                    created_at: ahora,
                    modified_at: ahora,
                    approvals: HashMap::new(),
                    approval_counter: U64::from(0),
                    metadata: Metadata::default(),
                };
                self.insertar_token(&token);

                ticket.cantidad_actual = ticket.cantidad_actual - 1;
                ticket.tokens_creados.push(U64(token_id));
                self.tickets.insert(&gate_id, &ticket);

                U64::from(token_id)
            }
        }
    }

    /* 
     *   Funciones internas 
     */

    /// Retorna todos los tokens de un dueño indicado por ID
    pub fn get_tokens_de_dueno(&self, owner_id: ValidAccountId) -> Vec<Token> {
        match self.tokens_de_address.get(owner_id.as_ref()) {
            None => Vec::new(),
            Some(list) => list
                .iter()
                .map(|token_id| {
                    let token = self.get_token(token_id).expect("No se encuentra el token indicado");
                    assert!(token.token_id == token_id);
                    assert!(&token.owner_id == owner_id.as_ref());
                    token
                })
                .collect(),
        }
    }

    /// Retorna un token según `token_id`, o un None si no existe
    fn get_token(&self, token_id: TokenId) -> Option<Token> {
        match self.tokens.get(&token_id) {
            None => None,
            Some(mut token) => {
                assert!(token.token_id == token_id);
                let ticket = self.tickets.get(&token.gate_id).expect("ID no encontrado");
                token.metadata = ticket.metadata;
                Some(token)
            }
        }
    }

    /// Funcion interna que retorna el token segun ID o da un Panic error
    fn get_token_int(&self, token_id: TokenId) -> Token {
        match self.get_token(token_id) {
            None => Panic::TokenIdNotFound { token_id }.panic(),
            Some(token) => token,
        }
    }

    /// Añade un token en `tokens` y en `tokens_de_address`.
    fn insertar_token(&mut self, token: &Token) {
        self.tokens.insert(&token.token_id, token);

        let mut tids = self.tokens_de_address.get(&token.owner_id).unwrap_or_else(|| {
            UnorderedSet::new(Keys::TokensPorDueñoValor {
                hash_id_dueño: crypto_hash(&token.owner_id),
            })
        });
        tids.insert(&token.token_id);

        self.tokens_de_address.insert(&token.owner_id, &tids);
    }

    /// Metodo interno llamado por borrar token
    fn borrar_token_int(&mut self, token_id: TokenId, owner_id: &AccountId) {
        match self.tokens_de_address.get(&owner_id) {
            None => Panic::TokenIdNotOwnedBy { token_id, owner_id: owner_id.clone() }.panic(),
            Some(mut list) => {
                if !list.remove(&token_id) {
                    Panic::TokenIdNotOwnedBy { token_id, owner_id: owner_id.clone() }.panic();
                }
                self.tokens_de_address.insert(&owner_id, &list);

                let was_removed = self.tokens.remove(&token_id);
                assert!(was_removed.is_some());
            }
        }
    }

    /// Aprobar un token por lote
    pub fn aprobar_por_lote(
        &mut self,
        tokens: Vec<(TokenId, U128)>,
        account_id: ValidAccountId,
    ) -> Promise {
        if tokens.len() > 10 {
            Panic::ExceedTokensToBatchApprove.panic();
        }

        let owner_id = env::predecessor_account_id();
        let mut oks = Vec::new();
        let mut errs = Vec::new();
        for (token_id, min_precio) in tokens {
            match self.aprobar_token(token_id, &owner_id, account_id.to_string(), min_precio) {
                Ok(msg) => oks.push((token_id, msg)),
                Err(err) => errs.push((token_id, err)),
            }
        }
        core_nft::nep178::market::batch_on_approve(
            oks,
            owner_id.try_into().unwrap(),
            account_id.as_ref(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        )
        .then(self_callback::resolve_batch_approve(
            errs,
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))
    }

    fn aprobar_token(
        &mut self,
        token_id: TokenId,
        owner_id: &AccountId,
        account_id: AccountId,
        min_precio: U128,
    ) -> Result<MarketApproveMsg, Panic> {
        let mut token = match self.tokens.get(&token_id) {
            None => return Err(Panic::TokenIdNotFound { token_id }),
            Some(token) => token,
        };
        if owner_id != &token.owner_id {
            return Err(Panic::TokenIdNotOwnedBy { token_id, owner_id: owner_id.clone() });
        }
        if token.approvals.len() > 0 {
            return Err(Panic::OneApprovalAllowed);
        }

        token.approval_counter.0 = token.approval_counter.0 + 1;
        token
            .approvals
            .insert(account_id, TokenApproval { aprobados_id: token.approval_counter, min_precio });
        self.tokens.insert(&token_id, &token);
        match self.tickets.get(&token.gate_id) {
            None => Err(Panic::GateIdNotFound { gate_id: token.gate_id }),
            Some(ticket) => Ok(MarketApproveMsg {
                min_precio,
                gate_id: Some(token.gate_id.try_into().unwrap()),
                id_creador: Some(ticket.id_creador),
            }),
        }
    }
}

/// Implementacion Token no fungible según NEP 171
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl NonFungibleTokenCore for ContratoNft {
    fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        enforce_approval_id: Option<U64>,
        memo: Option<String>,
    ) {
        let sender_id = env::predecessor_account_id();
        let mut token = self.get_token_int(token_id);

        if sender_id != token.owner_id && token.approvals.get(&sender_id).is_none() {
            Panic::SenderNotAuthToTransfer { sender_id }.panic();
        }

        if &token.owner_id == receiver_id.as_ref() {
            Panic::ReceiverIsOwner.panic();
        }

        if let Some(enforce_approval_id) = enforce_approval_id {
            let TokenApproval { aprobados_id, min_precio: _ } = token
                .approvals
                .get(receiver_id.as_ref())
                .expect("Receiver not an approver of this token.");
            if aprobados_id != &enforce_approval_id {
                Panic::EnforceApprovalFailed.panic();
            }
        }
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }

        self.borrar_token_int(token_id, &token.owner_id);

        token.owner_id = receiver_id.as_ref().to_string();
        token.modified_at = env::block_timestamp() / 1_000_000;
        token.approvals.clear();
        self.insertar_token(&token);
    }

    fn nft_payout(&self, token_id: TokenId, balance: U128) -> Payout {
        let token = self.get_token_int(token_id);
        match self.tickets.get(&token.gate_id) {
            None => Panic::GateIdNotFound { gate_id: token.gate_id }.panic(),
            Some(ticket) => {
                let royalty_amount = ticket.comision.mult(balance.0);
                let fee_amount = self.fee_reventa.mult(balance.0);
                let owner_amount = balance.0 - royalty_amount - fee_amount;
                let entries = vec![
                    (ticket.id_creador, royalty_amount),
                    (self.fee_reventa_id_address.clone(), fee_amount),
                    (token.owner_id, owner_amount),
                ];

                let mut payout = HashMap::new();
                for (account_id, amount) in entries {
                    payout.entry(account_id).or_insert(U128(0)).0 += amount;
                }
                payout
            }
        }
    }

    fn nft_transfer_payout(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        aprobados_id: Option<U64>,
        memo: Option<String>,
        balance: Option<U128>,
    ) -> Option<Payout> {
        let payout = balance.map(|balance| self.nft_payout(token_id, balance));
        self.nft_transfer(receiver_id, token_id, aprobados_id, memo);
        payout
    }

    fn nft_token(&self, token_id: TokenId) -> Option<Token> {
        self.get_token(token_id)
    }
}

/// Implementacion Token no fungible según NEP 177
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl NonFungibleTokenMetadata for ContratoNft {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.clone()
    }
}

/// Implementacion Token no fungible según NEP 178
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl NonFungibleTokenApprovalMgmt for ContratoNft {
    fn nft_approve(
        &mut self,
        token_id: TokenId,
        account_id: ValidAccountId,
        msg: Option<String>,
    ) -> Promise {
        let min_precio = {
            if let Some(msg) = msg.clone() {
                match serde_json::from_str::<NftApproveMsg>(&msg) {
                    Ok(approve_msg) => approve_msg.min_precio,
                    Err(err) => Panic::MsgFormatMinPriceMissing { reason: err.to_string() }.panic(),
                }
            } else {
                Panic::MsgFormatNotRecognized.panic();
            }
        };

        let owner_id = env::predecessor_account_id();
        let mut token = self.get_token_int(token_id);
        if &owner_id != &token.owner_id {
            Panic::TokenIdNotOwnedBy { token_id, owner_id }.panic();
        }
        if token.approvals.len() > 0 {
            Panic::OneApprovalAllowed.panic();
        }

        token.approval_counter.0 = token.approval_counter.0 + 1;
        token.approvals.insert(
            account_id.clone().into(),
            TokenApproval { aprobados_id: token.approval_counter, min_precio },
        );
        self.tokens.insert(&token_id, &token);

        match self.tickets.get(&token.gate_id) {
            None => Panic::GateIdNotFound { gate_id: token.gate_id }.panic(),
            Some(ticket) => {
                let market_msg = MarketApproveMsg {
                    min_precio,
                    gate_id: Some(token.gate_id.try_into().unwrap()),
                    id_creador: Some(ticket.id_creador),
                };
                core_nft::nep178::market::nft_on_approve(
                    token_id,
                    owner_id.try_into().unwrap(),
                    U64::from(token.approval_counter),
                    serde_json::to_string(&market_msg).unwrap(),
                    account_id.as_ref(),
                    0,
                    env::prepaid_gas() / 2,
                )
            }
        }
    }

    fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId) -> Promise {
        let owner_id = env::predecessor_account_id();
        let mut token = self.get_token_int(token_id);
        if &owner_id != &token.owner_id {
            Panic::TokenIdNotOwnedBy { token_id, owner_id }.panic();
        }
        if token.approvals.remove(account_id.as_ref()).is_none() {
            Panic::RevokeApprovalFailed { account_id: account_id.to_string() }.panic();
        }
        self.tokens.insert(&token_id, &token);
        core_nft::nep178::market::nft_on_revoke(
            token_id,
            account_id.as_ref(),
            0,
            env::prepaid_gas() / 2,
        )
    }

    fn nft_revoke_all(&mut self, token_id: TokenId) {
        let owner_id = env::predecessor_account_id();
        let mut token = self.get_token_int(token_id);
        if &owner_id != &token.owner_id {
            Panic::TokenIdNotOwnedBy { token_id, owner_id }.panic();
        }
        for (nft_id, _) in &token.approvals {
            core_nft::nep178::market::nft_on_revoke(token_id, nft_id, 0, env::prepaid_gas() / 2);
        }
        token.approvals.clear();
        self.tokens.insert(&token_id, &token);
    }
}

/// Implementacion Token no fungible según NEP 181
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl NonFungibleTokenEnumeration for ContratoNft {
    /// Returns the total token cantidad.
    fn nft_total_supply(&self) -> U64 {
        U64::from(self.tokens.len())
    }

    fn nft_tokens(&self, from_index: Option<U64>, limit: Option<u32>) -> Vec<Token> {
        let mut i = from_index.map_or(0, |s| s.0);
        let mut result = Vec::new();
        while result.len() < limit.unwrap_or(u32::MAX) as usize {
            if let Some(mut token) = self.tokens.values_as_vector().get(i) {
                let ticket = self.tickets.get(&token.gate_id).expect("Gate id not found");
                token.metadata = ticket.metadata;
                result.push(token);
                i += 1
            } else {
                break;
            }
        }
        result
    }

    fn nft_supply_for_owner(&self, account_id: ValidAccountId) -> U64 {
        match self.tokens_de_address.get(account_id.as_ref()) {
            None => 0.into(),
            Some(list) => list.len().into(),
        }
    }

    fn nft_tokens_for_owner(
        &self,
        account_id: ValidAccountId,
        from_index: Option<U64>,
        limit: Option<u32>,
    ) -> Vec<Token> {
        match self.tokens_de_address.get(account_id.as_ref()) {
            None => Vec::new(),
            Some(list) => {
                let mut i = from_index.map_or(0, |s| s.0);
                let mut result = Vec::new();
                while result.len() < limit.unwrap_or(u32::MAX) as usize {
                    if let Some(token_id) = list.as_vector().get(i) {
                        let token = self.get_token(token_id).expect("Token not found");
                        assert!(token.token_id == token_id);
                        assert!(&token.owner_id == account_id.as_ref());
                        result.push(token);
                        i += 1
                    } else {
                        break;
                    }
                }
                result
            }
        }
    }

    fn nft_token_uri(&self, token_id: TokenId) -> Option<String> {
        self.metadata.base_uri.clone().and_then(|uri| {
            self.tokens.get(&token_id).map(|t| {
                let sep = if uri.ends_with("/") { "" } else { "/" };
                format!("{}{}{}", uri, sep, t.gate_id)
            })
        })
    }
}

const GAS_FOR_ROYALTIES: Gas = 120_000_000_000_000;
const NO_DEPOSIT: Balance = 0;

#[near_ext]
#[ext_contract(self_callback)]
trait SelfCallback {
    fn resolve_batch_approve(&mut self, errs: Vec<(TokenId, Panic)>);
}

#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl SelfCallback for ContratoNft {
    #[private]
    fn resolve_batch_approve(&mut self, errs: Vec<(TokenId, Panic)>) {
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => unreachable!(),
            PromiseResult::Successful(_) => {
                if !errs.is_empty() {
                    Panic::Errors { panics: Panics(errs) }.panic()
                }
            }
        }
    }
}

/// Posibles errores que se usan posteriormente como Panic error
#[derive(Serialize, Deserialize, PanicMessage)]
#[serde(crate = "near_sdk::serde", tag = "err")]
pub enum Panic {
    #[panic_msg = "Royalty `{}` of `{}` is less than min"]
    RoyaltyMinThanAllowed { comision: Fraction, gate_id: String },
    #[panic_msg = "Royalty `{}` of `{}` is greater than max"]
    RoyaltyMaxThanAllowed { comision: Fraction, gate_id: String },
    #[panic_msg = "Royalty `{}` is too large for the given NFT fee `{}`"]
    RoyaltyTooLarge { comision: Fraction, fee_reventa: Fraction },
    #[panic_msg = "Gate ID `{}` already exists"]
    GateIdAlreadyExists { gate_id: GateId },
    #[panic_msg = "Gate ID `{}` must have a positive cantidad"]
    ZeroSupplyNotAllowed { gate_id: GateId },
    #[panic_msg = "Invalid argument for gate ID `{}`: {}"]
    InvalidArgument { gate_id: GateId, reason: String },
    #[panic_msg = "Operation is allowed only for admin"]
    AdminRestrictedOperation,
    #[panic_msg = "Gate ID `{}` was not found"]
    GateIdNotFound { gate_id: GateId },
    #[panic_msg = "Tokens for gate id `{}` have already been claimed"]
    GateIdExhausted { gate_id: GateId },
    #[panic_msg = "Gate ID `{}` has already some claimed tokens"]
    GateIdHasTokens { gate_id: GateId },
    #[panic_msg = "Unable to delete gate ID `{}`"]
    NotAuthorized { gate_id: GateId },
    #[panic_msg = "Token ID `{:?}` was not found"]
    TokenIdNotFound { token_id: U64 },
    #[panic_msg = "Token ID `{:?}` does not belong to account `{}`"]
    TokenIdNotOwnedBy { token_id: U64, owner_id: AccountId },
    #[panic_msg = "At most one approval is allowed per Token"]
    OneApprovalAllowed,
    #[panic_msg = "Sender `{}` is not authorized to make transfer"]
    SenderNotAuthToTransfer { sender_id: AccountId },
    #[panic_msg = "The token owner and the receiver should be different"]
    ReceiverIsOwner,
    #[panic_msg = "The aprobados_id is different from enforce_approval_id"]
    EnforceApprovalFailed,
    #[panic_msg = "The msg argument must contain the minimum price"]
    MsgFormatNotRecognized,
    #[panic_msg = "Could not find min_precio in msg: {}"]
    MsgFormatMinPriceMissing { reason: String },
    #[panic_msg = "Could not revoke approval for `{}`"]
    RevokeApprovalFailed { account_id: AccountId },
    #[panic_msg = "At most 10 tokens are allowed to approve in batch"]
    ExceedTokensToBatchApprove,
    #[panic_msg = "{} error(s) detected, see `panics` fields for a full list of errors"]
    Errors { panics: Panics },
}

/// Almacena los errores identificando por `TokenId`
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Panics(pub Vec<(TokenId, Panic)>);

impl Display for Panics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0.len())
    }
}

'''
'''--- contract/src/market.rs ---
use std::{convert::TryInto, fmt::{Debug, Display},};
pub use crate::core_nft::{
    crypto_hash,
    gate::{GateId, ValidGateId},
    nep178::NonFungibleTokenApprovalsReceiver,
    nep171,
    MarketApproveMsg, Payout, TokenId,
};
use near_env::{near_ext, near_log, PanicMessage};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, UnorderedMap, UnorderedSet},
    env, ext_contract,
    json_types::{ValidAccountId, U128, U64},
    near_bindgen,
    serde::{Deserialize, Serialize},
    serde_json, AccountId, Balance, BorshStorageKey, CryptoHash, Gas, PanicOnDefault,
    Promise, PromiseResult,
};

const GAS_FOR_ROYALTIES: Gas = 120_000_000_000_000;
const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContratoMercado {
    tokens_en_venta: UnorderedMap<TokenKey, TokenEnVenta>,
    tokens_por_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
    tokens_por_id_gate: LookupMap<GateId, UnorderedSet<TokenKey>>,
    tokens_por_id_owner: LookupMap<AccountId, UnorderedSet<TokenKey>>,
    tokens_por_id_creador: LookupMap<AccountId, UnorderedSet<TokenKey>>,
}

/// Cada token debe estar identificado por `<nft contract id, token id>`.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenKey(AccountId, TokenId);

impl Display for TokenKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{:?}", self.0, self.1)
    }
}

/// Estructura que representa los tickets en venta
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct TokenEnVenta {
    pub contrato_id: AccountId,
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub aprobados_id: U64,
    pub min_precio: U128,
    pub gate_id: Option<GateId>,
    pub id_creador: Option<AccountId>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum Keys {
    TokensEnVenta,
    TokensPorID,
    TokensPorIdValor(CryptoHash),
    TokensPorIdGate,
    TokensPorIdGateValor(CryptoHash),
    TokensPorIdOwner,
    TokensPorIdOwnerValor(CryptoHash),
    TokensPorIdCreador,
    TokensPorIdCreadorValor(CryptoHash),
}

/// Métodos del contrato market
#[near_log(skip_args, only_pub)]
// #[near_bindgen]
impl ContratoMercado {
    /// Inicializa el contrato
    // #[init]
    pub fn init() -> Self {
        Self {
            tokens_en_venta: UnorderedMap::new(Keys::TokensEnVenta),
            tokens_por_id: LookupMap::new(Keys::TokensPorID),
            tokens_por_id_gate: LookupMap::new(Keys::TokensPorIdGate),
            tokens_por_id_owner: LookupMap::new(Keys::TokensPorIdOwner),
            tokens_por_id_creador: LookupMap::new(Keys::TokensPorIdCreador),
        }
    }

    /// Retorna todos los tokens en venta
    pub fn get_tokens_en_venta(&self) -> Vec<TokenEnVenta> {
        let mut result = Vec::new();
        for (_, token) in self.tokens_en_venta.iter() {
            result.push(token);
        }
        result
    }

    /// Retorna todos los tokens en venta para un `owner_id`
    pub fn get_tokens_by_owner_id(&self, owner_id: ValidAccountId) -> Vec<TokenEnVenta> {
        get_tokens_by(&self.tokens_en_venta, &self.tokens_por_id_owner, owner_id.as_ref())
    }

    /// Retorna todos los tokens en venta para un `id_creador`
    pub fn get_tokens_by_creator_id(&self, id_creador: ValidAccountId) -> Vec<TokenEnVenta> {
        get_tokens_by(&self.tokens_en_venta, &self.tokens_por_id_creador, id_creador.as_ref())
    }

    // #[payable]
    pub fn buy_token(&mut self, contrato_id: ValidAccountId, token_id: TokenId) {
        let token_key = TokenKey(contrato_id.to_string(), token_id);
        if let Some(TokenEnVenta { owner_id, min_precio, gate_id, id_creador, .. }) =
            self.tokens_en_venta.get(&token_key)
        {
            let buyer_id = env::predecessor_account_id();
            if buyer_id == owner_id {
                Panics::BuyOwnTokenNotAllowed.panic();
            }
            let deposit = env::attached_deposit();
            if deposit < min_precio.0 {
                Panics::NotEnoughDepositToBuyToken.panic();
            }
            self.remove_token_por_id(&token_key, &owner_id, &gate_id, &id_creador);
            nep171::nft::nft_transfer_payout(
                buyer_id.try_into().unwrap(),
                token_id,
                None,
                None,
                Some(U128(deposit)),
                &contrato_id,
                0,
                env::prepaid_gas() / 3,
            )
            .then(self_callback::pago(
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_ROYALTIES,
            ));
        } else {
            Panics::TokenKeyNotFound { token_key }.panic();
        }
    }

    fn remove_token_por_id(
        &mut self,
        token_key: &TokenKey,
        owner_id: &AccountId,
        gate_id: &Option<GateId>,
        id_creador: &Option<AccountId>,
    ) {
        self.tokens_en_venta.remove(&token_key);
        remove_token_por_id_int(&mut self.tokens_por_id, &token_key, &token_key.0, &token_key.1);
        remove_token_por_id_int(&mut self.tokens_por_id_owner, &token_key, &owner_id, token_key);
        if let Some(gate_id) = gate_id {
            remove_token_por_id_int(&mut self.tokens_por_id_gate, &token_key, &gate_id, token_key);
        }
        if let Some(id_creador) = id_creador {
            remove_token_por_id_int(
                &mut self.tokens_por_id_creador,
                &token_key,
                &id_creador,
                token_key,
            );
        }
    }
}

#[near_ext]
#[ext_contract(self_callback)]
trait SelfCallback {
    fn pago(&mut self);
}

#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl SelfCallback for ContratoMercado {
    #[private]
    fn pago(&mut self) {
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(payout) = serde_json::from_slice::<Payout>(&value) {
                    for (receiver_id, amount) in payout {
                        Promise::new(receiver_id).transfer(amount.0);
                    }
                } else {
                    unreachable!();
                }
            }
        }
    }
}

/// Implementacion extraida del NEP 171
#[near_log(skip_args, only_pub)]
#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for ContratoMercado {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: ValidAccountId,
        aprobados_id: U64,
        msg: String,
    ) {
        match serde_json::from_str::<MarketApproveMsg>(&msg) {
            Ok(approve_msg) => {
                let contrato_id = env::predecessor_account_id();
                let owner_id = owner_id.to_string();
                self.add_token(&owner_id, &contrato_id, token_id, approve_msg, aprobados_id);
            }
            Err(err) => {
                let reason = err.to_string();
                Panics::MsgFormatMinPriceMissing { reason }.panic();
            }
        }
    }

    fn nft_on_revoke(&mut self, token_id: TokenId) {
        let contrato_id = env::predecessor_account_id();
        let token_key = TokenKey(contrato_id, token_id);

        if let Some(token) = self.tokens_en_venta.get(&token_key) {
            assert_eq!(token.contrato_id, token_key.0);
            self.remove_token_por_id(&token_key, &token.owner_id, &token.gate_id, &token.id_creador);
        } else {
            Panics::TokenKeyNotFound { token_key }.panic();
        }
    }

    fn batch_on_approve(
        &mut self,
        tokens: Vec<(TokenId, MarketApproveMsg)>,
        owner_id: ValidAccountId,
    ) {
        let contrato_id = env::predecessor_account_id();
        let owner_id = owner_id.to_string();
        for (token_id, approve_msg) in tokens {
            self.add_token(&owner_id, &contrato_id, token_id, approve_msg, U64(0));
        }
    }
}

/// Implementacion del contrato
impl ContratoMercado {
    fn add_token(
        &mut self,
        owner_id: &AccountId,
        contrato_id: &String,
        token_id: TokenId,
        approve_msg: MarketApproveMsg,
        aprobados_id: U64,
    ) {
        let token_key = TokenKey(contrato_id.clone(), token_id);
        self.tokens_en_venta.insert(
            &token_key,
            &TokenEnVenta {
                contrato_id: contrato_id.clone(),
                token_id,
                owner_id: owner_id.clone().into(),
                aprobados_id,
                min_precio: approve_msg.min_precio,
                gate_id: approve_msg.gate_id.clone().map(|g| g.to_string()),
                id_creador: approve_msg.id_creador.clone(),
            },
        );

        insert_token_id_to(
            &mut self.tokens_por_id,
            &contrato_id,
            &token_id,
            Keys::TokensPorIdValor,
        );
        insert_token_id_to(
            &mut self.tokens_por_id_owner,
            &owner_id.into(),
            &token_key,
            Keys::TokensPorIdOwnerValor,
        );
        if let Some(gate_id) = approve_msg.gate_id {
            insert_token_id_to(
                &mut self.tokens_por_id_gate,
                gate_id.as_ref(),
                &token_key,
                Keys::TokensPorIdGateValor,
            );
        }
        if let Some(id_creador) = approve_msg.id_creador {
            insert_token_id_to(
                &mut self.tokens_por_id_creador,
                &id_creador,
                &token_key,
                Keys::TokensPorIdCreadorValor,
            );
        }
    }
}

fn insert_token_id_to<T: BorshSerialize + BorshDeserialize, F: FnOnce(CryptoHash) -> Keys>(
    tokens_map: &mut LookupMap<String, UnorderedSet<T>>,
    key: &String,
    token_key: &T,
    f: F,
) {
    let mut tids = tokens_map.get(&key).unwrap_or_else(|| UnorderedSet::new(f(crypto_hash(key))));
    tids.insert(token_key);
    tokens_map.insert(key, &tids);
}

fn get_tokens_by<K: BorshSerialize>(
    ts: &UnorderedMap<TokenKey, TokenEnVenta>,
    tokens_map: &LookupMap<K, UnorderedSet<TokenKey>>,
    key: &K,
) -> Vec<TokenEnVenta> {
    match tokens_map.get(&key) {
        None => Vec::new(),
        Some(tids) => {
            tids.iter().map(|token_id| ts.get(&token_id).expect("Token not found")).collect()
        }
    }
}

fn remove_token_por_id_int<T: BorshSerialize + BorshDeserialize + Clone, K: BorshSerialize>(
    tokens_map: &mut LookupMap<K, UnorderedSet<T>>,
    t: &TokenKey,
    key: &K,
    token_key: &T,
) {
    match tokens_map.get(&key) {
        None => Panics::TokenKeyNotFound { token_key: t.clone() }.panic(),
        Some(mut tids) => {
            if !tids.remove(token_key) {
                Panics::TokenKeyNotFound { token_key: t.clone() }.panic();
            }

            tokens_map.insert(&key, &tids);
        }
    }
}

/// Posibles errores de tipo Panic
#[derive(Serialize, PanicMessage)]
#[serde(crate = "near_sdk::serde", tag = "err")]
pub enum Panics {
    /// Thrown when `nft_on_approve` does not find `min_precio`.
    #[panic_msg = "Could not find min_precio in msg: {}"]
    MsgFormatMinPriceMissing { reason: String },
    /// Thrown when the `token_key` was not found.
    #[panic_msg = "Token Key `{}` was not found"]
    TokenKeyNotFound { token_key: TokenKey },
    /// Thrown when buyer attempts to buy own token.
    #[panic_msg = "Buyer cannot buy own token"]
    BuyOwnTokenNotAllowed,
    /// Thrown when deposit is not enough to buy a token.
    #[panic_msg = "Not enough deposit to cover token minimum price"]
    NotEnoughDepositToBuyToken,
}
'''
'''--- contract/src/tests.rs ---
use core_nft::{
    gate::{GateId, ValidGateId},
    mock_context,
    mocked_context::{
        alice, any, bob, charlie, gate_id, market, mintgate_admin, mintgate_fee_account_id,
    },
    nep171::NonFungibleTokenCore,
    nep177::NFTContractMetadata,
    nep177::NonFungibleTokenMetadata,
    nep178::NonFungibleTokenApprovalMgmt,
    nep181::NonFungibleTokenEnumeration,
    NftApproveMsg, TokenApproval, TokenId,
};
use mg_nft::NftContract;
use near_sdk::{
    json_types::{ValidAccountId, U128, U64},
    serde_json,
};
use std::{
    convert::TryInto,
    ops::{Deref, DerefMut},
};

// mock_context!();

struct NftContractChecker {
    contrato: NftContract,
    claimed_tokens: Vec<TokenId>,
}

impl MockedContext<NftContractChecker> {

    fn inicializar_contrato(
        min_royalty: &str,
        max_royalty: &str,
        metadata: NFTContractMetadata,
    ) -> MockedContext<NftContractChecker> {
        MockedContext::new(|| NftContractChecker {
            contrato: NftContract::init(
                mintgate_admin(),
                metadata,
                min_royalty.parse().unwrap(),
                max_royalty.parse().unwrap(),
                "25/1000".parse().unwrap(),
                mintgate_fee_account_id(),
            ),
            claimed_tokens: Vec::new(),
        })
    }
    
    fn init() -> MockedContext<NftContractChecker> {
        init_contract("5/100", "30/100", metadata(base_uri()))
    }
    
    fn metadata(base_uri: Option<String>) -> NFTContractMetadata {
        NFTContractMetadata {
            spec: "my-tickets".to_string(),
            name: "Tickets App".to_string(),
            symbol: "MTK".to_string(),
            icon: None,
            base_uri,
            reference: None,
            reference_hash: None,
        }
    }
    fn crear_tickets(
        &mut self,
        creador_id: ValidAccountId,
        gate_id: ValidGateId,
        cantidad: u16,
        comision: &str,
    ) {
        let tickets_por_owner = self.get_collectibles_by_creator(creator_id.clone());

        println!("Tickets: `{}`, supply {}", gate_id, cantidad);

        let comision = comision.parse().unwrap();
        self.contrato.crear_tickets(
            creador_id.clone(),
            gate_id.clone(),
            "My tickets".to_string(),
            "descripcion".to_string(),
            cantidad,
            comision,
            Some("texto".to_string()),
            Some("111".to_string()),
            Some("ref".to_string()),
            Some("222".to_string()),
        );

        let ticket = self.contrato.get_collectible_by_gate_id(gate_id.clone()).unwrap();
        assert_eq!(ticket.creator_id, creator_id.to_string());
        assert_eq!(&ticket.gate_id, gate_id.as_ref());
        assert_eq!(ticket.current_supply, supply);
        assert_eq!(ticket.minted_tokens.len(), 0);
        assert_eq!(ticket.royalty, royalty);
        assert_eq!(ticket.metadata.media, Some("media".to_string()));
        assert_eq!(ticket.metadata.media_hash, Some("111".to_string()));
        assert_eq!(ticket.metadata.reference, Some("ref".to_string()));
        assert_eq!(ticket.metadata.reference_hash, Some("222".to_string()));

        assert_eq!(
            self.get_collectibles_by_creator(creador_id).len(),
            tickets_por_owner.len() + 1
        );
    }

    fn comprar_tickets(&mut self, gate_id: ValidGateId) -> TokenId {
        let total_supply = self.
        .nft_total_supply().0;
        let supply_por_owner = self.contrato.nft_supply_for_owner(self.pred_id()).0;

        let token_id = self.contrato.claim_token(gate_id.clone());

        assert_eq!(self.contrato.nft_total_supply(), U64(total_supply + 1));
        assert_eq!(self.contrato.nft_supply_for_owner(self.pred_id()), U64(supply_por_owner + 1));

        let token = self.nft_token(token_id).unwrap();
        assert_eq!(&token.gate_id, gate_id.as_ref());
        assert_eq!(token.owner_id, self.pred_id().to_string());
        assert_eq!(token.approvals.len(), 0);
        assert_eq!(token.approval_counter, U64(0));

        let ticket = self.contrato.get_collectible_by_gate_id(gate_id.clone()).unwrap();
        assert_eq!(token.metadata, ticket.metadata);

        self.claimed_tokens.insert(0, token_id);
        token_id
    }

}

'''
'''--- deployar.sh ---
#!/bin/bash

# compilar el contrato y desplogarlo a la testnet
echo "Compilando el contrato y desplegandolo a la testnet"
npm run build:contract
npm run dev:deploy:contract

echo "Exportanto la cuenta de test a la variable ID"

# export la cuenta de test creada al hacer deploy
old_IFS=$IFS
IFS=$'\n'
for i in `cat ./neardev/dev-account`
do
    export ID=$i
done
IFS=$old_IFS
'''
'''--- limpiar.sh ---
set -e

echo "Inicio"

rm -rf ./out
rm -rf ./neardev
rm -rf ./dist
rm -rf ./.cache
rm -rf ./contract/build

echo "Archivos eliminados"
'''
'''--- package.json ---
{
  "name": "WinWin",
  "version": "0.0.1",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch contract/src -e rs --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && cargo test -- --nocapture && cd .. && jest test --runInBand"
  },
  "devDependencies": {
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~2.1.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "shelljs": "~0.8.4"
  },
  "dependencies": {
    "near-api-js": "~0.43.1",
    "regenerator-runtime": "~0.13.5"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'WinWin'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 25em;
}

h1 {
  background-image: url(assets/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(assets/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="./assets/favicon.ico" />
  <link rel="apple-touch-icon" href="./assets/favicon.ico" />
  <titulo>Welcome to NEAR</titulo>
  <link rel="stylesheet" href="global.css">
</head>
<body>
  <main id="signed-out-flow" style="display: none">
    <h1>Welcome to NEAR!</h1>
    <p>
      To make use of the NEAR blockchain, you need to sign in. The button
      below will sign you in using NEAR Wallet.
    </p>
    <p>
      By default, when your app runs in "development" mode, it connects
      to a test network ("testnet") wallet. This works just like the main
      network ("mainnet") wallet, but the NEAR Tokens on testnet aren't
      convertible to other currencies – they're just for testing!
    </p>
    <p>
      Go ahead and click the button below to try it out:
    </p>
    <p style="text-align: center; margin-top: 2.5em">
      <button id="sign-in-button">Sign in</button>
    </p>
  </main>

  <div id="signed-in-flow" style="display: none">
    <button class="link" style="float: right" id="sign-out-button">
      Sign out
    </button>
    <main>
      <h1>
        <label
          for="greeting"
          data-behavior="greeting"
          style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
        >
        </label>
        <span data-behavior="account-id"></span>!
      </h1>
      <form>
        <fieldset id="fieldset">
          <label
            for="greeting"
            style="display: block; color: var(--gray); margin-bottom: 0.5em"
          >
            Change greeting
          </label>
          <div style="display: flex">
            <input
              style="flex: 1"
              autocomplete="off"
              id="greeting"
              data-behavior="greeting"
            />
            <button disabled style="border-radius: 0 5px 5px 0">Save</button>
          </div>
        </fieldset>
      </form>
      <p>
        Look at that! A Hello World app! This greeting is stored on the NEAR blockchain. Check it out:
      </p>
      <ol>
        <li>
          Look in <code>src/index.js</code> and <code>src/utils.js</code> – you'll see <code>get_greeting</code>
          and <code>set_greeting</code> being called on <code>contract</code>.
          What's this?
        </li>
        <li>
          Ultimately, this <code>contract</code> code is defined in
          <code>assembly/index.ts</code> – this is the source code for your
          <a target="_blank" href="https://docs.near.org/docs/develop/contracts/overview">smart contract</a>.
        </li>
        <li>
          When you run <code>yarn dev</code>, the code in
          <code>assembly/index.ts</code> gets deployed to the NEAR testnet. You
          can see how this happens by looking in <code>package.json</code> at the
          <code>scripts</code> section to find the <code>dev</code> command.
        </li>
      </ol>
      <hr>
      <p>
        To keep learning, check out
        <a target="_blank" href="https://docs.near.org">the NEAR docs</a>
        or look through some
        <a target="_blank" href="https://examples.near.org">example apps</a>.
      </p>
    </main>
  </div>

  <aside data-behavior="notification" style="display: none">
    <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
    called method: 'set_greeting' in contract:
    <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
    <footer>
      <div>✔ Succeeded</div>
      <div>Just ahora</div>
    </footer>
  </aside>

  <script src="./index.js"></script>
</body>
</html>

'''
'''--- src/index.js ---
import 'regenerator-runtime/runtime'

import { initContract, login, logout } from './utils'

import getConfig from './config'
const { networkId } = getConfig(process.env.NODE_ENV || 'development')

// global variable used throughout
let currentGreeting

const submitButton = document.querySelector('form button')

document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, greeting } = event.target.elements

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    // make an update call to the smart contract
    await window.contrato.set_greeting({
      // pass the value that the user entered in the greeting field
      message: greeting.value
    })
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  } finally {
    // re-enable the form, whether the call succeeded or failed
    fieldset.disabled = false
  }

  // disable the save button, since it ahora matches the persisted value
  submitButton.disabled = true

  // update the greeting in the UI
  await fetchGreeting()

  // show notification
  document.querySelector('[data-behavior=notification]').style.display = 'block'

  // remove notification again after css animation completes
  // this allows it to be shown again next time the form is submitted
  setTimeout(() => {
    document.querySelector('[data-behavior=notification]').style.display = 'none'
  }, 11000)
}

document.querySelector('input#greeting').oninput = (event) => {
  if (event.target.value !== currentGreeting) {
    submitButton.disabled = false
  } else {
    submitButton.disabled = true
  }
}

document.querySelector('#sign-in-button').onclick = login
document.querySelector('#sign-out-button').onclick = logout

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('#signed-out-flow').style.display = 'block'
}

// Displaying the signed in flow container and fill in account-specific data
function signedInFlow() {
  document.querySelector('#signed-in-flow').style.display = 'block'

  document.querySelectorAll('[data-behavior=account-id]').forEach(el => {
    el.innerText = window.accountId
  })

  // populate links in the notification box
  const accountLink = document.querySelector('[data-behavior=notification] a:nth-of-type(1)')
  accountLink.href = accountLink.href + window.accountId
  accountLink.innerText = '@' + window.accountId
  const contractLink = document.querySelector('[data-behavior=notification] a:nth-of-type(2)')
  contractLink.href = contractLink.href + window.contrato.contractId
  contractLink.innerText = '@' + window.contrato.contractId

  // update with selected networkId
  accountLink.href = accountLink.href.replace('testnet', networkId)
  contractLink.href = contractLink.href.replace('testnet', networkId)

  fetchGreeting()
}

// update global currentGreeting variable; update DOM with it
async function fetchGreeting() {
  currentGreeting = await contrato.get_greeting({ account_id: window.accountId })
  document.querySelectorAll('[data-behavior=greeting]').forEach(el => {
    // set divs, spans, etc
    el.innerText = currentGreeting

    // set input elements
    el.value = currentGreeting
  })
}

// `nearInitPromise` gets called on page load
window.nearInitPromise = initContract()
  .then(() => {
    if (window.walletConnection.isSignedIn()) signedInFlow()
    else signedOutFlow()
  })
  .catch(console.error)

'''
'''--- src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['get_greeting'],
    changeMethods: [],
    sender: window.accountId
  })
})

test('get_greeting', async () => {
  const message = await window.contrato.get_greeting({ account_id: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- src/utils.js ---
import { connect, ContratoNft, keyStores, WalletConnection } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new ContratoNft(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['get_greeting'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['set_greeting'],
  })
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>Please run the following command in NEAR CLI, then enter account id here. masterAccountId default: test.near
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''