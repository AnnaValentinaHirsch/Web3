*GitHub Repository "leohhhn/near_escrow"*

'''--- README.md ---
# NEAR Escrow
'''
'''--- contract/Cargo.toml ---
[package]
name = "near_escrow"
version = "1.0.0"
authors = ["MVPW"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
log = "0.4.17"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
Hello NEAR!
=================================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. There are two functions to the smart contract: `get_greeting` and `set_greeting`.
3. Tests: You can run smart contract tests with the `cargo test`.

  [smart contract]: https://docs.near.org/develop/welcome
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://docs.near.org/develop/prerequisites#rust-and-wasm
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1662110242255-27619549391671
'''
'''--- contract/src/external.rs ---
use near_sdk::{ext_contract, AccountId};
use near_contract_standards::fungible_token::metadata::FungibleTokenMetadata;

#[ext_contract(this_contract)]
trait Callbacks {
  fn get_metadata_callback(&self) -> FungibleTokenMetadata;
  fn get_balance_of_callback(&self) -> String;
  fn on_transfer(&mut self, owner_id: AccountId, token_contract: AccountId, amount: String) -> bool;
}

#[ext_contract(ft)]
trait FT {
  fn ft_balance_of(&self, account_id: AccountId) -> String;
  fn transfer_from(&self, owner_id: AccountId, new_owner_id: AccountId, amount: String) -> Result<(), &'static str>;
}
'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{log, near_bindgen, env, PromiseError};

pub mod external;
pub use crate::external::*;

// Define the default message
const DEFAULT_MESSAGE: &str = "Hello From Cross Communication Contract";

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    message: String,
}

// Define the default, which automatically initializes the contract
impl Default for Contract{
    fn default() -> Self{
        Self{message: DEFAULT_MESSAGE.to_string()}
    }
}

// Implement the contract structure
#[near_bindgen]
impl Contract {

    pub fn ft_on_transfer(&mut self, _sender_id: String, amount: String, _memo: Option<String>, _msg: String) -> String {
        log!("Called ft_on_transfer {}", env::current_account_id());
        let _escrow_contract = env::current_account_id();
        
        // let balance_of_first_token = ft::ext(sender_id.parse().unwrap())
        //         .ft_balance_of(escrow_contract.clone())
        //     .then(Self::ext(escrow_contract.clone())
        //             .get_balance_of_callback()
        // );
        
        // let balance_of_second_token = ft::ext(sender_id.parse().unwrap())
        //         .ft_balance_of(escrow_contract.clone())
        //     .then(Self::ext(escrow_contract.clone())
        //             .get_balance_of_callback()
        // );
        //log!("Balance of first token: {} is {:?}", sender_id, balance_of_first_token);    

        amount
    }

    #[private]
    pub fn get_balance_of_callback(&self, #[callback_result] call_result: Result<String, PromiseError>) -> String {
        if call_result.is_err() {
            panic!("There was an error contacting My FT contract");
        }
    
        let balance: String = call_result.unwrap();
        balance
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 */
#[cfg(test)]
mod tests {
    use super::*;
}

'''
'''--- package.json ---
{
  "name": "near-escrow",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deploy": "npm run build:contract && cd contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/near_escrow.wasm",
    "build": "npm run build:contract",
    "build:contract": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "npm run build:contract && cd integration-tests && cargo run --example integration-tests \"../contract/target/wasm32-unknown-unknown/release/near_escrow.wasm\"",
    "deps-install": "npm install"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}
'''