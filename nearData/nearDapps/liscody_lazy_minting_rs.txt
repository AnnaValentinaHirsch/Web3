*GitHub Repository "liscody/lazy_minting_rs"*

'''--- .cargo/config.toml ---
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]

'''
'''--- .github/workflows/docs.yml ---
# This workflow builds the docs and deploys them to GitHub Pages on every commit to the master branch
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions

name: Build & Deploy Docs

on:
  push:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    
    - uses: actions/checkout@v2
    - uses: actions-rs/toolchain@v1
      with:
          toolchain: stable
    - uses: actions-rs/cargo@v1
      with:
        command: install
        args: witme --version 0.2.0
    - uses: actions/setup-node@v1
      with:
        node-version: '16.x'
    - run: npm i && npm run docs
    - name: Deploy ðŸš€
      uses: JamesIves/github-pages-deploy-action@3.7.1
      with:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        BRANCH: gh-pages # The branch the action should deploy to.
        FOLDER: docs # The folder the action should deploy.

'''
'''--- .github/workflows/testnet.yml ---
name: Linkdrop
on: push
jobs:
  tests:
    strategy:
      matrix:
        set: ['"*/linkdrop/succ*"', "*/link*/fail*"]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: "stable with rustfmt, and wasm32"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          target: wasm32-unknown-unknown
      - uses: Swatinem/rust-cache@v1
      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown
      - name: install node
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Run tests
        run: npm i && npm run test:testnet ${{ matrix.set }}
'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        node-version: ['16']
        toolchain: [stable]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: "${{ matrix.toolchain }} with rustfmt, and wasm32"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ matrix.toolchain }}
          target: wasm32-unknown-unknown
      - uses: Swatinem/rust-cache@v1
      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown
      - name: install node
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Run tests
        run: npm i && npm run test:ci
'''
'''--- Cargo.toml ---
[workspace]
members = [
  "contracts/*"
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Tenk NFT

This contract publishes collections of NFT for example 10,000, hence TenK.  Each time a token is minted it is randomly chosen from the remaining tokens. The core mechanism for this is a `Raffle` collection type, which allows randomly picking from a range without replacement. This contract also introduces the idea of using a linkdrop proxy to allow the owner or a normal user to "pre-mint" an item.

## Details

Each `token_id` is numbered in a range, e.g. `0-10,000`.  This each asset and its metadata then named correspondingly, e.g. `0.png`, `0.json`. These files are placed into a flat directory and added to IPFS.  This hash is used as the `base_uri` for the contract and all minted `token_id` can be used to find its corresponding file.

For example,

- [https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link](https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link)
- [https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link/42.png](https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link/42.png)
- [https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link/42.json](https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link/42.json)

## Linkdrop proxy

Currently this project wraps its own linkdrop-proxy, but in the future it this will be its own contract that any contract use for the same ability to add a callback to be used when the linkdrop is claimed. When a linkdrop is created it reserves a raffle draw to be made when claiming. This allows the token to be a surprise (unless it's the last one).

## API

TypeScript docs are found at [https://tenk-dao.github.io/tenk/](https://tenk-dao.github.io/tenk/).

Currently there is no standard format to describe the types of a contract. One proposal is to use the [`wit` format](https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md),
which while intended as a tool to generate bindings that act as polyfill for [`WebAssembly Interface Types`](https://github.com/WebAssembly/interface-types), it provides a language agnostic
way to describe types for the API of a Wasm Binary.

This work has led to the creation of [`witme`](https://github.com/ahalabs/witme), a tool for both generating a `.wit` document describing a Rust smart contract and generating a TypeScript file
from a `.wit` document.  The generated TS file also includes a `Contract` class which handles calling the corresponding methods.

For example, `nft_transfer` generates the following three functions:

```typescript

// Will throw if there is an error and parse result if it exist.
nft_transfer(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
}, options?: ChangeMethodOptions): Promise<void>;

// Will return the response from the server regardless of it succeeded
nft_transferRaw(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
}, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;

// Creates a function call action that can be added to a transaction
// See the `./scripts/deploy.ts` for how this can be used
nft_transferTx(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
}, options?: ChangeMethodOptions): transactions.Action;
```

Having the types mean that your contract calls will be type checked and prevent failed transactions from missing or malformed arguments.

View calls also generate a function.

```typescript
/// makes a view call and parses the result
nft_payout(args: {
    token_id: string;
    balance: U128;
    max_len_payout?: number;
}, options?: ViewFunctionOptions): Promise<Payout>;

nft_token(args: { token_id: TokenId;}, options?: ViewFunctionOptions): Promise<Token | null>;
```

### Using the contract's types

The main file and types of this package are found `./contracts/tenk/dist/*`
and specified in the `package.json`. These

From another TS project:

```ts
import { Contract } from "tenk-nft"

...

async function main({account}) {
  const contract = new Contract(account, "tenkv0.testnet.tenk");

  await contract.nft_transfer({receiver_id: "eve.testnet", token_id: "0"});
  const token = await contract.nft_token({token_id: "0"})
  console.log(`token ${token}`);
}
```

## Using scripts with `near-cli`

A recent update to `near-cli` allows passing a script the current context of the current `near` environment. This includes the account that is signing the transactions, access to the same `near-api-js` that the cli is using, and an array of arguments passed to the script.

For example, from the script [`update_royalties.ts`](./scripts/update_royalties.ts):

```typescript
import {Context} from "near-cli/context";
import {Contract} from "..";

export async function main({ account, argv }: Context) {
  let [contractId] = argv;
  if (contractId === null) {
    console.error("need to supply contract's accountId")
    console.error("... -- <contractId>")
  }
  let contract = new Contract(account, contractId);
  const royalties = {
    percent: 690,
    accounts: {
      "tenk.sputnik-dao.near": 2500,
      "bob.near": 7500,
    }
  };
  let res = await contract.update_royalties({ royalties });
}
```

Run the script with `near-cil`'s `repl` command using the option `-s` to pass a script.  Other arguments of near-cli can be passed 
and any arguments after the `--` are collected in the passed `argv`.

```bash
near repl -s ./scripts/update_royalties.ts --accountId owner.testnet -- contract.testnet
```

This makes it easy to create your own near scripts, while still getting the benefit of type checking parameters.

## Uploading Assets

1. Have `NFT_STORAGE_API_TOKEN` env var set to api key from https://nft.storage
1. Have assets numbered `0-x` with matching names `0.png` `0.json` in all in the same directory. E.g. `dir/0.png` `dir/0.json`.
1. Pack assets with `yarn pack-car --pack <dir> --output nfts.car`
1. Upload to nft.storage with `yarn upload-car nfts.car`

## Aspects of Near that prevents hacks on this method of minting

Here is [one example](https://cointelegraph.com/news/85-million-meebits-nft-project-exploited-attacker-nabs-700-000-collectible) of a "hack" that stole $85 million worth of nfts minted in a similar fasion. The "attacker" was able to map the NFT's id (our index) to its worth (its rarity). Then made a contract that made a cross contract call to mint an NFT, then canceling the transaction if it's not rare enough.  Though this cost the "attacker" $20K fees per hour, they were able to see the rare items and reap the reward.

The key aspect that this hack and others like it on Ethereum rely on is that a series of cross contract calls either succeed or fail. This way you can opt out of it before the end and goods never change hands.  On Near this is not the case.  Each cross contract call is asynchronous and can change the state.  This means when you use a cross contract call to mint a token and it succeeds, any money spent is gone and the token minted. Thus unlike the Ethereum example if you aren't satisfied with the token you received you can't choose to not receive it and not pay the owner.

## NFT Standards

For more information about the API provided by the NFT standard see [nomicon.io](https://nomicon.io/Standards/NonFungibleToken).

## Development

This project also aims to highlight the newest way to test smart contracts on near using [`near-workspaces`](https://github.com/near/workspaces-js).  See example tests in [`__test__`](./__test__).

Node must be installed. And Rust must be install see [Getting Started in near-sdk.io](https://www.near-sdk.io/).

To build docs `witme` must be installed.

```bash
cargo install witme
```

'''
'''--- __test__/allowance.ava.ts ---
import { Workspace } from "near-workspaces-ava";
import { NEAR } from "near-units";
import {
  DEFAULT_SALE,
  deploy,
  getTokens,
  mint,
  mint_raw,
  now,
  totalCost,
} from "./util";

const price = NEAR.parse("0.8 N");
const allowance = 2;

const runner = Workspace.init(
  { initialBalance: NEAR.parse("20 N").toString() },
  async ({ root }) => {
    const alice = await root.createAccount("alice");
    const tenk = await deploy(root, "tenk", {
      sale: {
        ...DEFAULT_SALE,
        price: price.toJSON(),
        allowance,
      }
    });
    return { tenk, alice };
  }
);

runner.test("allowance should allow only 2 tokens", async (t, { root, tenk, alice }) => {
  const cost = await totalCost(tenk, 1, alice.accountId);
  await mint(tenk, alice, cost);
  await mint(tenk, alice, cost);
  let last_try = await mint_raw(tenk, alice, cost);
  t.assert(last_try.failed, "tx didn't fail");
  const tokens = await getTokens(tenk, alice);
  t.assert(tokens.length == 2);
});

runner.test("owner has no allowance", async (t, { root, tenk, alice }) => {
  const cost = await totalCost(tenk, 1, alice.accountId);
  await mint(tenk, root, cost);
  await mint(tenk, root, cost);
  let last_try = await mint_raw(tenk, root, cost);
  t.assert(last_try.succeeded);
  const tokens = await getTokens(tenk, root);
  t.assert(tokens.length == 3);
});
'''
'''--- __test__/linkdrop/fail.ava.ts ---
import {
  Workspace,
  NearAccount,
  randomAccountId,
} from "near-workspaces-ava";
import {
  ava
} from "near-workspaces-ava";
import { NEAR, Gas } from "near-units";
import { readFile } from "fs/promises";
import {
  ActualTestnet,
  createLinkdrop,
  getTokens,
  checkKey,
  BalanceDelta,
  claim,
  claim_raw,
  // repeat,
  // zeroDelta,
  hasDelta,
  getDelta,
  create_account_and_claim,
  deploy,
  linkdropCost,
  sleep,
} from "../util";

const base_cost = NEAR.parse("1 N");
const min_cost = NEAR.parse("0.01 N");

if (Workspace.networkIsTestnet()) {
  const runner = Workspace.init(
    { initialBalance: NEAR.parse("15 N").toString() },
    async ({ root }) => {
      const tenk = await deploy(root, "tenk");
      if (Workspace.networkIsSandbox()) {
        const testnet = root.getFullAccount("testnet");
        await testnet.updateAccount({
          amount: NEAR.parse("1000 N").toString(),
          code_hash: "12XoaQ18TQYJhj9SaZR3MGUjcvgkE8rtKn4ZMCnVG8Lq",
        });
        await testnet.updateContract(
          await readFile(`${__dirname}/contracts/testnet.wasm`)
        );
      }
      return { tenk };
    }
  );

  runner.test(
    "Use `claim` to send to existing account without enough gas",
    async (t, { root, tenk }) => {
      const alice = await root.createAccount("alice");
      await sleep(2000);
      // Create temporary keys for access key on linkdrop
      const [delta, _] = await getDelta(t, tenk, async () => {
        let [linkDelta, senderKey] = await getDelta(t, root, () =>
          createLinkdrop(t, tenk, root)
        );
        t.log(await linkDelta.toHuman());
        await claim_raw(tenk, alice, senderKey, Gas.parse("50 Tgas"));
        t.assert(
          await checkKey(senderKey.getPublicKey(), tenk),
          "key should still exist"
        );
      });
      await delta.isGreaterOrEqual(NEAR.from(0));

      const tokens = await getTokens(tenk, alice);
      t.assert(tokens.length == 0, "should contain not token");
      t.log(
        `Balance to contract ${
          tenk.accountId
        } after linkdrop is claimed ${await delta.toHuman()}`
      );

      // await deployEmpty(tenk);
    }
  );

  runner.test(
    "claim_account_and_claim to create an claim account with not enough gas",
    async (t, { root, tenk }) => {
      const senderKey = await createLinkdrop(t, tenk, root);

      // Create a random subaccount
      const new_account_id = `${randomAccountId("d", 10, 10)}.testnet`;

      // Claim account
      const new_account = await create_account_and_claim(
        t,
        tenk,
        new_account_id,
        senderKey,
        Gas.parse("50 Tgas"),
        false
      );

      t.assert(await checkKey(senderKey.getPublicKey(), tenk));
      const tokens = await getTokens(tenk, new_account);
      t.assert(tokens.length == 0, "should contain only one token");
      await sleep(2000);

      // await new_account.delete(root.accountId);
    }
  );

  // TODO: there is a race condition on the key store.  Either need multiple keys per account,
  // runner.test(
  //   "Use `claim` to send to existing account back-to-back",
  //   async (t, { root, tenk }) => {
  //     const contractDelta = await BalanceDelta.create(tenk, t);
  //     // Create temporary keys for access key on linkdrop
  //     const senderKey = await createLinkdrop(t, tenk, root);
  //     t.log("linkdrop cost", await contractDelta.toHuman());
  //     const alice = await root.createAccount("alice");
  //     const delta = await BalanceDelta.create(root, t);
  //     claim_raw(tenk, alice, senderKey);
  //     claim_raw(tenk, root, senderKey);
  //     await claim_raw(tenk, alice, senderKey);
  //     const tokens = await getTokens(tenk, alice);
  //     t.log(tokens);
  //     t.is(tokens.length, 1, "should contain at least one token");
  //     t.assert(
  //       !(await checkKey(senderKey.getPublicKey(), tenk)),
  //       "key should not exist"
  //     );
  //     await delta.isGreater();
  //     await contractDelta.isZero();
  //     // await deployEmpty(tenk);
  //   }
  // );

  runner.test(
    "Use `claim` to send to non-existent account",
    async (t, { root, tenk }) => {
      // Create temporary keys for access key on linkdrop
      const delta = await BalanceDelta.create(tenk, t);
      const senderKey = await createLinkdrop(t, tenk, root);
      // Bad account invalid accountid
      const alice = await root.getFullAccount("alice--");
      t.log(`Delta ${await delta.toHuman()}`);
      await claim_raw(tenk, alice, senderKey);
      t.assert(
        await checkKey(senderKey.getPublicKey(), tenk),
        "key should still exist"
      );
    }
  );

  const GAS_COST_ON_FAILURE = NEAR.parse("570 Î¼N").neg();

  runner.test("Call `claim` with invalid key", async (t, { root, tenk }) => {
    // Create temporary keys for access key on linkdrop
    // const senderKey = await createLinkdrop(t, tenk, root);
    // Bad account invalid accountid
    // const alice = await root.createAccount("alice");
    const senderKey = await root.getKey();
    const res = await paidFailureGas(t, tenk, async () => {
      try {
        await claim_raw(tenk, root, senderKey);
      } catch {}
    });

    // TODO: add back after fix in api -js is released
    // t.assert(res.failed, `${root.accountId} claiming from ${tenk.accountId}`);
  });

  // runner.test(
  //   "Spam `claim` to send to non-existent account",
  //   async (t, { root, tenk }) => {
  //     // Create temporary keys for access key on linkdrop
  //     const senderKey = await createLinkdrop(t, tenk, root);
  //     // Bad account invalid accountid
  //     const alice = await root.getFullAccount("alice--");
  //     const delta = await BalanceDelta.create(tenk, t);

  //     await repeat(5, () => claim_raw(tenk, alice, senderKey));
  //     debugger;
  //     t.log(`Delta ${await delta.toHuman()}`);
  //     t.assert(
  //       await checkKey(senderKey.getPublicKey(), tenk),
  //       "key should still exist"
  //     );
  //   }
  // );

  // TODO figure out why this fails on sandbox

  
  function paidFailureGas<T>(t, tenk, fn: () => Promise<T>): Promise<T> {
    return hasDelta<T>(t, tenk, GAS_COST_ON_FAILURE, false, fn);
  }
  
} else {
  ava("skipped on sandbox", (t) => t.assert(true));
}
// Only relevant when not using feature "for_sale"
// runner.test("Owner can create links for free", async (t, { root, tenk }) => {
//   const tenkDelta = await BalanceDelta.create(tenk, t);
//   t.log(tenk.accountId);
//   const [delta, res] = await getDelta(t, root, () =>
//     createLinkdrop(t, tenk, root, NEAR.from(0))
//   );
//   t.log(await tenkDelta.toHuman());
//   await delta.isGreater(NEAR.parse("1.3 mN").neg());
//   ///  Currentyl failed linkdrop claims cause the contract to lose funds to gas.
//   // t.assert(
//   //   !(await checkKey(senderKey.getPublicKey(), tenk)),
//   //   "key should not exist"
//   // );

//   // await deployEmpty(tenk);
// });

'''
'''--- __test__/linkdrop/success.ava.ts ---
import { Workspace, randomAccountId } from "near-workspaces-ava";
import { ava } from "near-workspaces-ava";
import { NEAR } from "near-units";
import { readFile } from "fs/promises";
import {
  createLinkdrop,
  getTokens,
  checkKey,
  claim,
  hasDelta,
  getDelta,
  create_account_and_claim,
  deploy,
  linkdropCost,
  sleep,
} from "../util";

const base_cost = NEAR.parse("1 N");
const min_cost = NEAR.parse("0.01 N");

if (Workspace.networkIsTestnet()) {
  const runner = Workspace.init(
    { initialBalance: NEAR.parse("15 N").toString() },
    async ({ root }) => {
      const tenk = await deploy(root, "tenk");
      if (Workspace.networkIsSandbox()) {
        const testnet = root.getFullAccount("testnet");
        await testnet.updateAccount({
          amount: NEAR.parse("1000 N").toString(),
          code_hash: "12XoaQ18TQYJhj9SaZR3MGUjcvgkE8rtKn4ZMCnVG8Lq",
        });
        await testnet.updateContract(
          await readFile(`${__dirname}/contracts/testnet.wasm`)
        );
      }
      return { tenk };
    }
  );

  runner.test(
    "Use `claim` to send to existing account with link created with root",
    async (t, { root, tenk }) => {
      const alice = await root.createAccount("alice");
      await sleep(2000);
      t.log(NEAR.from(await tenk.view("token_storage_cost")).toHuman());

      // Create temporary keys for access key on linkdrop
      const [delta, _] = await getDelta(t, tenk, async () => {
        const owner_cost = await linkdropCost(tenk, root.accountId);
        t.log(owner_cost.toHuman());
        const senderKey = await createLinkdrop(t, tenk, root);
        await claim(t, tenk, alice, senderKey);
        t.assert(
          !(await checkKey(senderKey.getPublicKey(), tenk)),
          "key should not exist"
        );
      });
      await delta.isGreaterOrEqual(NEAR.from(0));
      const tokens = await getTokens(tenk, alice);
      t.assert(tokens.length == 1, "should contain only one token");
      t.log(
        `Balance to contract ${
          tenk.accountId
        } after linkdrop is claimed ${await delta.toHuman()}`
      );

      // await deployEmpty(tenk);
    }
  );

  runner.test(
    "Use `claim` to send to existing account with normal account",
    async (t, { root, tenk }) => {
      const alice = await root.createAccount("alice");
      await sleep(2000);
      t.log(NEAR.from(await tenk.view("token_storage_cost")).toHuman());

      // Create temporary keys for access key on linkdrop
      const [delta, _] = await getDelta(t, tenk, async () => {
        const owner_cost = await linkdropCost(tenk, alice.accountId);
        t.log(owner_cost.toHuman());
        const senderKey = await createLinkdrop(t, tenk, alice);
        await claim(t, tenk, alice, senderKey);
        t.assert(
          !(await checkKey(senderKey.getPublicKey(), tenk)),
          "key should not exist"
        );
      });
      await delta.isGreaterOrEqual(NEAR.from(0));
      t.log(await delta.toHuman());
      const tokens = await getTokens(tenk, alice);
      t.assert(tokens.length == 1, "should contain only one token");
      t.log(
        `Balance to contract ${
          tenk.accountId
        } after linkdrop is claimed ${await delta.toHuman()}`
      );

      // await deployEmpty(tenk);
    }
  );

  // runner.test(
  //   "Spam `claim` to send to non-existent account",
  //   async (t, { root, tenk }) => {
  //     // Create temporary keys for access key on linkdrop
  //     const senderKey = await createLinkdrop(t, tenk, root);
  //     // Bad account invalid accountid
  //     const alice = await root.getFullAccount("alice--");
  //     const delta = await BalanceDelta.create(tenk, t);

  //     await repeat(5, () => claim_raw(tenk, alice, senderKey));
  //     debugger;
  //     t.log(`Delta ${await delta.toHuman()}`);
  //     t.assert(
  //       await checkKey(senderKey.getPublicKey(), tenk),
  //       "key should still exist"
  //     );
  //   }
  // );

  // TODO figure out why this fails on sandbox

  runner.test(
    "Use `create_account_and_claim` with existent account",
    async (t, { root, tenk }) => {
      t.log(root);
      // Create temporary keys for access key on linkdrop
      const senderKey = await createLinkdrop(t, tenk, root);
      // Bad account invalid accountid
      const alice = root;
      const [delta, res] = await getDelta(t, tenk, () =>
        create_account_and_claim(t, tenk, alice.accountId, senderKey)
      );
      await delta.isLessOrEqual(NEAR.parse("1.02 N"));
      const tokens = await getTokens(tenk, root);
      t.log(tokens);

      ///  Currentyl failed linkdrop claims cause the contract to lose funds to gas.
      t.false(
        await checkKey(senderKey.getPublicKey(), tenk),
        "key should not exist"
      );

      // await deployEmpty(tenk);
    }
  );

  runner.test(
    "claim_account_and_claim to create an claim account",
    async (t, { root, tenk }) => {
      const senderKey = await createLinkdrop(t, tenk, root);

      // Create a random subaccount
      const new_account_id = `${randomAccountId("d", 10, 10)}.testnet`;

      // Claim account
      const new_account = await create_account_and_claim(
        t,
        tenk,
        new_account_id,
        senderKey
      );

      t.assert(!(await checkKey(senderKey.getPublicKey(), tenk)));
      const tokens = await getTokens(tenk, new_account);
      t.assert(tokens.length == 1, "should contain only one token");

      // await new_account.delete(root.accountId);
    }
  );
} else {
  ava("skipped on sandbox", (t) => t.assert(true));
}
// Only relevant when not using feature "for_sale"
// runner.test("Owner can create links for free", async (t, { root, tenk }) => {
//   const tenkDelta = await BalanceDelta.create(tenk, t);
//   t.log(tenk.accountId);
//   const [delta, res] = await getDelta(t, root, () =>
//     createLinkdrop(t, tenk, root, NEAR.from(0))
//   );
//   t.log(await tenkDelta.toHuman());
//   await delta.isGreater(NEAR.parse("1.3 mN").neg());
//   ///  Currentyl failed linkdrop claims cause the contract to lose funds to gas.
//   // t.assert(
//   //   !(await checkKey(senderKey.getPublicKey(), tenk)),
//   //   "key should not exist"
//   // );

//   // await deployEmpty(tenk);
// });

'''
'''--- __test__/mintbase.ts ---
import { Workspace, NearAccount, ONE_NEAR } from "near-workspaces-ava";
import { NEAR, Gas } from "near-units";
import { nftTokensForOwner } from "./util";

const base_cost = NEAR.parse("0 N");
const min_cost = NEAR.parse("0 N");

async function deployEmpty(account: NearAccount): Promise<void> {
  const empty = account.getFullAccount("empty.tn");
  const bytes = await empty.viewCode();
  await account.createTransaction(account).deployContract(bytes).signAndSend();
}

function getRoyalties({ root, alice, bob, eve }) {
  return {
    accounts: {
      [root.accountId]: 10,
      [alice.accountId]: 10,
      [bob.accountId]: 10,
      [eve.accountId]: 70,
    },
    percent: 20,
  };
}

const network = "sandbox";

const PRICE = NEAR.parse("3 N");

const runner = Workspace.init(
  { initialBalance: NEAR.parse("15 N").toString() },
  async ({ root }) => {
    const owner_id = root;
    const alice = await root.createAccount("alice");
    const bob = await root.createAccount("bob");
    const eve = await root.createAccount("eve");
    const royalties = getRoyalties({ root, bob, alice, eve });
    const tenk = await root.createAndDeploy(
      "tenk",
      `${__dirname}/../target/wasm32-unknown-unknown/release/tenk.wasm`,
      {
        method: "new_default_meta",
        args: {
          owner_id,
          name: "meerkats",
          symbol: "N/A",
          uri: "QmaDR7ozkawfnmEirvErfcJm27FEyFv5U1KQDfWkHGj5qD",
          size: 10_000,
          base_cost,
          min_cost,
          royalties,
        },
        gas: Gas.parse("20 TGas"),
      }
    );

    const token_id = (
      (await root.call(
        tenk,
        "nft_mint_one",
        {},
        {
          attachedDeposit: ONE_NEAR,
        }
      )) as any
    ).token_id;

    const mintbase = await root.createAndDeploy(
      "mintbase-market",
      `${__dirname}/contracts/mintbase_marketplace_contract.wasm`,
      {
        method: "new",
        args: {
          init_allowlist: [tenk],
        },
      }
    );

    // await root.call(
    //   mintbase,
    //   "storage_deposit",
    //   {},
    //   {
    //     attachedDeposit: ONE_NEAR,
    //   }
    // );
    const msg = JSON.stringify({
      price: PRICE,
      autotransfer: true,
    });
    await root.call(
      tenk,
      "nft_approve",
      {
        token_id,
        account_id: mintbase,
        msg,
      },
      {
        attachedDeposit: ONE_NEAR,
      }
    );
    return { mintbase, eve, tenk };
  }
);

runner.test("buy one", async (t, { root, tenk, mintbase, eve }) => {
  const bob = await root.createAccount("bob2");
  const ids = await nftTokensForOwner(root, tenk);
  t.is(ids.length, 1);
  const token_id = ids[0].token_id;
  t.log(token_id);
  // t.log(
  //   await mintbase.view("get_market_data", {
  //     nft_contract_id: tenk.accountId,
  //     token_id,
  //   })
  // );

  const balance = await root.availableBalance();
  const eveBalance = await eve.availableBalance();

  await bob.call(
    mintbase,
    "make_offer",
    {
      price: PRICE,
      token_key: `${token_id}:${tenk.accountId}`,
      token_id,
      timeout: {
        Hours: 24,
      },
    },
    {
      gas: Gas.parse("100 Tgas"),
      attachedDeposit: ONE_NEAR,
    }
  );
  t.log(await nftTokensForOwner(bob, tenk));
  const newBalance = await root.availableBalance();
  t.assert(newBalance.gt(balance));
  t.log(newBalance.sub(balance).toHuman());
  const newEveBalance = await eve.availableBalance();
  t.assert(newEveBalance.gt(eveBalance));
  t.log(newEveBalance.sub(eveBalance).toHuman());
  // t.assert(balance.lt(newBalance));
});

'''
'''--- __test__/nft.ava.ts ---
import { Workspace, NearAccount } from "near-workspaces-ava";
import { NEAR } from "near-units";
import {
  costPerToken,
  tokenStorageCost,
  totalCost,
  MINT_ONE_GAS,
  nftTokensForOwner,
  deployEmpty,
  InitArgs,
  binPath,
  DEFAULT_SALE,
} from "./util";

const price = NEAR.parse("1 N");
// const min_cost = NEAR.parse("0.01 N");

const runner = Workspace.init(
  { initialBalance: NEAR.parse("15 N").toString() },
  async ({ root }) => {
    let tenk = await root.createAndDeploy("tenk", binPath("tenk"));
    let args: InitArgs = {
      owner_id: root.accountId,
      metadata: {
        name: "TENK NFT",
        symbol: "TENK",
        uri: "https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link",
      },
      size: 100,
      sale: DEFAULT_SALE,
    };
    await root.call(tenk, "new_default_meta", args);
    return { tenk };
  }
);

runner.test("can get cost per token", async (t, { tenk }) => {
  const cost = await costPerToken(tenk, 1);
  t.deepEqual(cost.toBigInt(), price.toBigInt());
});

async function assertXTokens(t, root: NearAccount, tenk, num) {
  const method = num == 1 ? "nft_mint_one" : "nft_mint_many";
  let args = num == 1 ? {} : { num };
  const res = await root.call_raw(tenk, method, args, {
    attachedDeposit: await totalCost(tenk, num),
    gas: MINT_ONE_GAS,
  });
  t.true(res.succeeded, [res.Failure, ...res.promiseErrorMessages].join("\n"));
  t.is(num, (await nftTokensForOwner(root, tenk)).length);
  if (num == 30 && Workspace.networkIsTestnet()) {
    await deployEmpty(tenk);
  }
}

[
  ["one", 1],
  ["two", 2],
  ["five", 5],
  ["ten", 10],
  // ["thirty", 30],
].forEach(async ([num, x]) => {
  runner.test("mint " + num, async (t, { root, tenk }) => {
    await assertXTokens(t, root, tenk, x);
  });
});

'''
'''--- __test__/paras.ava.ts ---
import { Workspace, NearAccount, ONE_NEAR } from "near-workspaces-ava";
import { NEAR, Gas } from "near-units";
import {
  nftTokensForOwner,
  mint,
  BalanceDelta,
  deploy,
  totalCost,
  now,
  DEFAULT_SALE,
} from "./util";

function getRoyalties({ root, alice, eve }) {
  return {
    accounts: {
      [root.accountId]: 1_000,
      [alice.accountId]: 2_000,
      [eve.accountId]: 7_000,
    },
    percent: 2_000,
  };
}

function delpoyParas(
  root: NearAccount,
  owner_id: NearAccount,
  treasury_id: NearAccount,
  approved_nft_contract_ids: NearAccount[]
): Promise<NearAccount> {
  return root.createAndDeploy(
    "paras-market",
    `${__dirname}/contracts/paras.wasm`,
    {
      method: "new",
      args: {
        owner_id,
        treasury_id,
        // approved_ft_token_ids: Option<Vec<ValidAccountId>>,
        approved_nft_contract_ids,
      },
    }
  );
}

const runner = Workspace.init(
  { initialBalance: NEAR.parse("15 N").toString() },
  async ({ root }) => {
    const owner_id = root;
    const alice = await root.createAccount("alice");
    const bob = await root.createAccount("bob");
    const eve = await root.createAccount("eve");
    const royalties = getRoyalties({ root, alice, eve });
    const tenk = await deploy(root, "tenk", {
      sale: { ...DEFAULT_SALE, royalties },
    });
    const token_id = await mint(tenk, bob, await totalCost(tenk, 1));

    const paras = await delpoyParas(root, root, root, [tenk]);

    await bob.call(
      paras,
      "storage_deposit",
      {},
      {
        attachedDeposit: ONE_NEAR,
      }
    );
    const msg = JSON.stringify({
      market_type: "sale",
      price: ONE_NEAR.toString(),
      ft_token_ids: "near",
    });
    await bob.call(
      tenk,
      "nft_approve",
      {
        token_id,
        account_id: paras,
        msg,
      },
      {
        attachedDeposit: ONE_NEAR,
      }
    );
    return { tenk, paras, eve, bob };
  }
);

runner.test("buy one", async (t, { root, tenk, paras, bob, eve }) => {
  const bob2 = await root.createAccount("bob2");
  const ids = await nftTokensForOwner(bob, tenk);
  t.is(ids.length, 1);
  const token_id = ids[0].token_id;
  t.log(
    await paras.view("get_market_data", {
      nft_contract_id: tenk.accountId,
      token_id,
    })
  );

  const balance = await root.availableBalance();
  const eveBalance = await eve.availableBalance();
  const bobDelta = await BalanceDelta.create(bob, t);
  const bob2Delta = await BalanceDelta.create(bob2, t);

  const res = await bob2.call_raw(
    paras,
    "buy",
    {
      nft_contract_id: tenk,
      token_id,
    },
    {
      gas: Gas.parse("100 Tgas"),
      attachedDeposit: ONE_NEAR,
    }
  );

  await bob2Delta.log();
  await bob2Delta.isLessOrEqual(ONE_NEAR.neg());
  await bobDelta.isGreaterOrEqual(NEAR.parse("750 mN"));

  t.assert(
    res.logsContain("EVENT_JSON"),
    `Expected EVENT_JSON got ${res.logs}`
  );
  t.log(res.logs);
  t.log(await nftTokensForOwner(bob2, tenk));
  const newBalance = await root.availableBalance();
  t.assert(newBalance.gt(balance));
  t.log(newBalance.sub(balance).toHuman());
  const newEveBalance = await eve.availableBalance();
  t.assert(newEveBalance.gt(eveBalance));
  t.log(newEveBalance.sub(eveBalance).toHuman());
  // t.assert(balance.lt(newBalance));
});

'''
'''--- __test__/premint.ava.ts ---
import { ONE_NEAR, Workspace } from "near-workspaces-ava";
import { NEAR } from "near-units";
import {
  claim,
  createLinkdrop,
  deploy,
  getTokens,
  mint,
  mint_raw,
  now,
  sleep,
  start_presale_args,
  totalCost,
} from "./util";

const presale_price = NEAR.parse("0.8 N").toJSON();
const allowance = 2;

const runner = Workspace.init(
  { initialBalance: NEAR.parse("20 N").toString() },
  async ({ root }) => {
    const alice = await root.createAccount("alice");
    const tenk = await deploy(root, "tenk", {
      sale: {
        allowance,
        price: ONE_NEAR.toJSON(),
        presale_price,
      },
    });
    return { tenk, alice };
  }
);

async function premint_period<T>(
  { tenk, root, duration },
  fn: () => Promise<T>
): Promise<T> {
  const public_sale_start = now() + duration * 1_000;
  const args: start_presale_args = { public_sale_start };
  await root.call(tenk, "start_presale", args);
  const sleepTimer = sleep(1000 * duration);
  const res = await fn();
  await sleepTimer;
  return res;
}

runner.test("premint", async (t, { root, tenk, alice }) => {
  const cost = await totalCost(tenk, 1, alice.accountId);
  const token = await mint(tenk, root);
  const duration = 20;
  const linkkeys = await createLinkdrop(t, tenk, root);
  await claim(t, tenk, alice, linkkeys);

  await premint_period({ tenk, root, duration }, async () => {
    // await t.throwsAsync(
    //   root.call(tenk, "end_premint", {
    //     base_cost,
    //     min_cost: base_cost,
    //   })
    // );

    let initial_try = await mint_raw(tenk, alice, cost);
    t.assert(initial_try.failed);
    // owner can still mint
    const second_token = await mint_raw(tenk, root);
    t.assert(second_token.succeeded);

    await root.call(tenk, "add_whitelist_accounts", {
      accounts: [alice],
      allowance: 2,
    });
    await mint(tenk, alice, cost);
    await mint(tenk, alice, cost);
    let last_try = await mint_raw(tenk, alice, cost);
    t.assert(last_try.failed);
    const tokens = await getTokens(tenk, alice);
    t.assert(tokens.length == 3);
  });
  t.log(await tenk.view("get_sale_info"));
  const sale_price = await totalCost(tenk, 1, alice.accountId);
  t.log(sale_price.toHuman(), cost.toHuman());
  t.assert(sale_price.gt(cost), "actual sale price has increased");

  t.assert((await mint_raw(tenk, alice, sale_price)).failed);
  t.assert((await mint_raw(tenk, root, sale_price)).succeeded);
});

'''
'''--- __test__/royalties.ava.ts ---
import { Workspace, NearAccount } from "near-workspaces-ava";
import { NEAR } from "near-units";
import { DEFAULT_SALE, deploy, getDelta, mint, now, totalCost } from "./util";
import { Royalties, Sale } from "..";

if (Workspace.networkIsSandbox()) {
  function createRoyalties({ root, alice, bob, eve }) {
    return {
      accounts: {
        [root.accountId]: 1_000,
        [alice.accountId]: 1_000,
        [bob.accountId]: 1_000,
        [eve.accountId]: 7_000,
      },
      percent: 2_000,
    };
  }

  function subaccounts(root: NearAccount): Promise<NearAccount[]> {
    return Promise.all(
      ["bob", "alice", "eve"].map((n) => root.createAccount(n))
    );
  }

  const runner = Workspace.init(
    { initialBalance: NEAR.parse("20 N").toString() },
    async ({ root }) => {
      const [bob, alice, eve] = await subaccounts(root);
      const royalties = createRoyalties({ root, bob, alice, eve });
      const tenk = await deploy(root, "tenk", {
        sale: {
          ...DEFAULT_SALE,
          royalties,
          initial_royalties: royalties,
        }
      });
      return { tenk, bob, alice, eve };
    }
  );

  runner.test("Get Payout", async (t, { root, tenk, eve, alice, bob }) => {
    const balance = NEAR.parse("500 N");
    const token_id = await mint(tenk, root);
    const payouts = await tenk.view("nft_payout", {
      token_id,
      balance,
      max_len_payout: 10,
    });
    t.log(payouts);
    t.log(
      (
        await tenk.view_raw("nft_payout", {
          token_id,
          balance,
          max_len_payout: 10,
        })
      ).logs
    );
    let innerPayout = createRoyalties({ root, bob, alice, eve }).accounts;
    t.log(innerPayout);
    Object.keys(innerPayout).map(
      (key) =>
        (innerPayout[key] = NEAR.parse(`${innerPayout[key]}cN`).toString())
    );
    innerPayout[root.accountId] = balance
      .mul(NEAR.from(4))
      .div(NEAR.from(5))
      .add(NEAR.from(innerPayout[root.accountId]))
      .toString();
    const payout = { payout: innerPayout };
    t.deepEqual(payouts, payout);
  });

  runner.test("Initial Payout", async (t, { root, tenk, eve }) => {
    let charlie = await root.createAccount("charlie");
    const cost = await totalCost(tenk, 1);
    let [delta, token_id] = await getDelta(t, eve, async () =>
      mint(tenk, charlie, cost)
    );
    t.log(
      cost.toHuman(),
      await delta.toHuman(),
      cost.mul(NEAR.from(1)).div(NEAR.from(5)).toHuman()
    );
  });

  function sale(royalties: Royalties): Sale{
    return {...DEFAULT_SALE, royalties}
  }

  runner.test("bad initial payout", async (t, { root }) => {
    let bad_royalties: Royalties = {
      percent: 10000,
      accounts: {
        bob: 10,
      },
    };
    await t.throwsAsync(
      () =>
        deploy(root, "tenk1", {
          sale: sale(bad_royalties)
        }),
      null,
      "too little"
    );
    const [bob, alice, eve] = await subaccounts(root);
    const royalties = createRoyalties({ root, bob, alice, eve });

    await t.throwsAsync(
      () =>
        deploy(root, "tenk2", {
          sale: {
            ...DEFAULT_SALE,
            initial_royalties: bad_royalties,
          }
        }),
      null,
      "too little initial"
    );
  });

  runner.test("too much", async (t, { root }) => {
    let bad_royalties = {
      percent: 10_000,
      accounts: {
        bob: 9_000,
        alice: 1_100,
      },
    };
    await t.throwsAsync(
      () =>
        deploy(root, "tenk1", {
          sale: sale(bad_royalties)
        }),
      null,
      "secondary"
    );
    const [bob, alice, eve] = await subaccounts(root);
    const royalties = createRoyalties({ root, bob, alice, eve });

    await t.throwsAsync(
      () =>
        deploy(root, "tenk2", {
          sale: {
            ...DEFAULT_SALE,
            initial_royalties: bad_royalties,
          }
        }),
      null,
      "initial"
    );
  });
}

'''
'''--- __test__/start_at_one.ts ---
// import { Workspace, NearAccount } from "near-workspaces-ava";
// import { NEAR } from "near-units";
// import {
//   costPerToken,
//   tokenStorageCost,
//   totalCost,
//   MINT_ONE_GAS,
//   nftTokensForOwner,
//   deployEmpty,
//   deploy,
// } from "./util";

// const base_cost = NEAR.parse("1 N");
// const min_cost = NEAR.parse("0.01 N");

// const runner = Workspace.init(
//   { initialBalance: NEAR.parse("15 N").toString() },
//   async ({ root }) => {
//     const tenk = await deploy(root, "tenk", { price_structure: {base_cost, min_cost}, size: 2 });
//     return { tenk };
//   }
// );

// runner.test("token ids start at 1", async (t, { root, tenk }) => {
//   const tokens: { token_id: string }[] = await root.call(
//     tenk,
//     "nft_mint_many",
//     { num: 2 },
//     { attachedDeposit: NEAR.parse("2.1 N") }
//   );
//   const token_ids = tokens.map((t) => t.token_id);
//   t.is(token_ids.length, 2);
//   t.true(token_ids.includes("1"));
//   t.true(token_ids.includes("2"));
// });

'''
'''--- __test__/util/bin.ts ---
import { join } from "path";

const RUST_BIN_FOLDER = ["target", "wasm32-unknown-unknown", "release"];

export function binPath(name: string): string {
  return join(__dirname, "..", "..", ...RUST_BIN_FOLDER, `${name}.wasm`);
}

export const CONTRACT_PATH = binPath("tenk");

'''
'''--- __test__/util/delta.ts ---
import { NEAR, NearAccount } from "near-workspaces-ava";

export class NEARDelta {
  static readonly ZERO_NEAR = NEAR.from(0);
  constructor(public readonly amount: NEAR) {}

  toHuman(): string {
    if (this.isZero()) {
      return `0 N`;
    }
    const absAmount = this.amount.abs();
    return `${this.amount.isNeg() ? "-" : ""}${absAmount.toHuman()}`;
  }

  isZero(): boolean {
    return this.amount.isZero();
  }

  gt(by = NEARDelta.ZERO_NEAR): boolean {
    return this.amount.gt(by);
  }

  gte(by = NEARDelta.ZERO_NEAR): boolean {
    return this.amount.gte(by);
  }

  lt(by = NEARDelta.ZERO_NEAR): boolean {
    return this.amount.lt(by);
  }

  lte(by = NEARDelta.ZERO_NEAR): boolean {
    return this.amount.lte(by);
  }
}

export class BalanceDelta {
  private constructor(
    public readonly initial: NEAR,
    public readonly account: NearAccount,
    private t: any
  ) {}

  static async create(account: NearAccount, t): Promise<BalanceDelta> {
    return new BalanceDelta(await account.availableBalance(), account, t);
  }

  async delta(): Promise<NEARDelta> {
    const newBalance = await this.account.availableBalance();
    return new NEARDelta(newBalance.sub(this.initial));
  }

  async isZero(): Promise<void> {
    return this.assert((delta) => delta.isZero(), "zero");
  }

  async isGreater(by?: NEAR): Promise<void> {
    return this.assert((delta) => delta.gt(by), "greater");
  }
  async isGreaterOrEqual(by?: NEAR): Promise<void> {
    return this.assert((delta) => delta.gte(by), "greater or equal");
  }

  async isLess(by?: NEAR): Promise<void> {
    return this.assert((delta) => delta.lt(by), "less");
  }

  async isLessOrEqual(by?: NEAR): Promise<void> {
    return this.assert((delta) => delta.lte(by), "less or equal");
  }

  private async assert(
    fn: (d: NEARDelta) => boolean,
    innerString: string
  ): Promise<void> {
    const delta = await this.delta();
    this.t.assert(
      fn(delta),
      `Account ${
        this.account.accountId
      } expected ${innerString} got: ${delta.toHuman()}`
    );
  }

  async toHuman(): Promise<string> {
    return (await this.delta()).toHuman();
  }

  async log(): Promise<void> {
    this.t.log(`${this.account.accountId} has delta ${await this.toHuman()}`);
  }
}

function isZero(bd: BalanceDelta): Promise<void> {
  return bd.isZero();
}

function gt(bd: BalanceDelta, by?: NEAR): Promise<void> {
  return bd.isGreater(by);
}
function gte(bd: BalanceDelta, by?: NEAR): Promise<void> {
  return bd.isGreaterOrEqual(by);
}
function lt(bd: BalanceDelta, by?: NEAR): Promise<void> {
  return bd.isLess(by);
}
function lte(bd: BalanceDelta, by?: NEAR): Promise<void> {
  return bd.isLessOrEqual(by);
}

type DeltaFn = (bd: BalanceDelta, by?: NEAR) => Promise<void>;

export async function applyDelta<T>(
  t,
  account: NearAccount,
  txns: () => Promise<T>,
  deltaFn: DeltaFn,
  by?: NEAR
): Promise<T> {
  const deltaBalance = await BalanceDelta.create(account, t);
  const res = await txns();
  await deltaFn(deltaBalance, by);
  return res;
}

export function zeroDelta<T>(
  t,
  account: NearAccount,
  txns: () => Promise<T>
): Promise<T> {
  return applyDelta(t, account, txns, isZero);
}

/* 
  Asserts that the delata is within the bounds passed
*/
export function hasDelta<T>(
  t,
  account: NearAccount,
  amount: NEAR,
  // Whether to include equal to
  inclusive: boolean,
  txns: () => Promise<T>
): Promise<T> {
  let fn: DeltaFn;

  if (amount.isNeg()) {
    fn = inclusive ? gte : gt;
  } else {
    fn = inclusive ? lte : lt;
  }

  return applyDelta(t, account, txns, fn, amount);
}

export function repeat<T>(
  iterations: number,
  fn: (i: number) => Promise<T>
): Promise<T[]> {
  return Promise.all(Array.from({ length: iterations }).map(fn));
}

export async function getDelta<T>(
  t,
  account: NearAccount,
  txns: () => Promise<T>
): Promise<[BalanceDelta, T]> {
  const delta = await BalanceDelta.create(account, t);
  return [delta, await txns()];
}

'''
'''--- __test__/util/index.ts ---
import { Gas, NEAR } from "near-units";
import {
  Account,
  BN,
  createKeyPair,
  NearAccount,
  Workspace,
  randomAccountId,
  KeyPair,
  PublicKey,
  AccountManager,
} from "near-workspaces";
import { ONE_NEAR, TransactionResult } from "near-workspaces-ava";
import { binPath } from "./bin";
import { BalanceDelta, getDelta } from "./delta";
import {Contract} from "../..";

let c: Contract;
type f = typeof c.new_default_meta;
type NewfuncArgs = Parameters<f>;
export type InitArgs = NewfuncArgs[0];

export type start_presale_args = Parameters<typeof c.start_presale>[0];

export * from "./bin";

// This will allow the contract account to be deleted since the size is reduced
export async function deployEmpty(account: NearAccount): Promise<void> {
  if (!Workspace.networkIsTestnet()) {
    return;
  }
  const empty = account.getFullAccount("empty.tn");
  const bytes = await empty.viewCode();
  await account.createTransaction(account).deployContract(bytes).signAndSend();
}

export function now() {
  return Date.now();
}
export const DEFAULT_SALE = {
  price: NEAR.parse("1 N").toJSON(),
  public_sale_start: now(),
}

export async function deploy(
  owner: NearAccount,
  name = "tenk",
  args: Partial<InitArgs> = {}
): Promise<NearAccount> {
  const account =  await  owner.createAndDeploy(name, binPath("tenk"));
  let passed_args: InitArgs = {
    owner_id: owner.accountId,
    metadata: {
      name: "TENK NFT",
      symbol: "TENK",
      uri: "https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link",
    },
    size: 100,
    sale: DEFAULT_SALE,
    ...args,
  };
  await owner.call(account, "new_default_meta", passed_args);
  return account;
}

export async function nftTokensForOwner(
  root,
  tenk,
  from_index = null,
  limit = null
) {
  return tenk.view("nft_tokens_for_owner", {
    account_id: root,
    from_index,
    limit,
  });
}

// export const ONE_NEAR = NEAR.parse("1 N")

export const DEFAULT_BASE_COST = NEAR.parse("10 N");
export const DEFAULT_MIN_COST = NEAR.parse("1 N");

export function DEFAULT_INIT_ARGS(
  owner_id: string,
  base_cost = DEFAULT_BASE_COST,
  min_cost = DEFAULT_MIN_COST
) {
  return {
    owner_id,
    name: "minimo",
    symbol: "MIMO",
    uri: "https://ipfs.io/ipfs/bafybeifxzm547rdsckq2crw4dipjvsw4togrnhwzb7gy7ae4anqqgjt264",
    size: 10000,
    base_cost,
    min_cost,
  };
}

export async function costPerToken(
  tenk: NearAccount,
  num: number,
  minter: string = "alice.near"
): Promise<NEAR> {
  return NEAR.from(await tenk.view("cost_per_token", { num, minter }));
}

export async function totalCost(
  tenk: NearAccount,
  num: number,
  minter: string = "alice.near"
): Promise<NEAR> {
  return NEAR.from(await tenk.view("total_cost", { num, minter }));
}

export async function linkdropCost(
  tenk: NearAccount,
  minter: string = "alice.near"
): Promise<NEAR> {
  return NEAR.from(await tenk.view("cost_of_linkdrop", { minter }));
}

export async function discount(tenk: NearAccount, num: number): Promise<NEAR> {
  return NEAR.from(await tenk.view("discount", { num }));
}

export async function tokenStorageCost(tenk: NearAccount): Promise<NEAR> {
  return NEAR.from(await tenk.view("token_storage_cost"));
}

export class ActualTestnet extends Account {
  constructor(private name: string) {
    super(null as any, null as any);
  }

  get accountId(): string {
    return this.name;
  }
}
// const KEY_ALLOWANCE = NEAR.parse("0.69 N");
const ONE_NFT_STORAGE_COST_BN: NEAR = Workspace.networkIsTestnet()
  ? NEAR.parse("320 Î¼N")
  : NEAR.parse("7.56 mN");

export const MINT_ONE_GAS = Gas.parse("300 TGas");

function costOfMinting(num: number): string {
  return ONE_NFT_STORAGE_COST_BN.mul(new BN(num)).toString();
}

export async function checkKey(
  key: PublicKey,
  contract: NearAccount
): Promise<boolean> {
  const provider = ((contract as any).manager as AccountManager).provider;
  try {
    const res = await provider.view_access_key(contract.accountId, key);
    return res.permission.FunctionCall.method_names[0] === "claim";
    // return true;
  } catch (_) {
    return false;
  }
}

export async function createLinkdrop(
  t,
  contract: NearAccount,
  root: NearAccount,
  attachedDeposit?: NEAR
): Promise<KeyPair> {
  // Create temporary keys for access key on linkdrop
  const senderKey = createKeyPair();
  const public_key = senderKey.getPublicKey().toString();
  // const linkdrop_cost
  attachedDeposit =
    attachedDeposit ?? (await linkdropCost(contract, root.accountId));
  const contract_delta = await BalanceDelta.create(contract, t);
  // This adds the key as a function access key on `create_account_and_claim`
  const root_delta = await BalanceDelta.create(root, t);
  const [delta, res] = await getDelta(t, root, async () => {
    let res = await root.call_raw(
      contract,
      "create_linkdrop",
      {
        public_key,
      },
      {
        attachedDeposit,
        gas: Gas.parse("40 Tgas"),
      }
    );
    return res;
  });
  // await contract_delta.log();
  // t.log(res.logs);
  // await delta.log();
  t.assert(res.succeeded);
  t.assert(await checkKey(senderKey.getPublicKey(), contract));
  return senderKey;
}

export async function claim(
  t,
  tenk: NearAccount,
  alice: NearAccount,
  signWithKey: KeyPair
): Promise<TransactionResult> {
  return tenk.call_raw(
    tenk,
    "claim",
    {
      account_id: alice,
    },
    {
      signWithKey,
      gas: Gas.parse("100 Tgas"),
    }
  )
}

export function claim_raw(
  tenk: NearAccount,
  account_id: NearAccount,
  signWithKey: KeyPair,
  gas = Gas.parse("100 Tgas")
) {
  return tenk.call_raw(
    tenk,
    "claim",
    {
      account_id,
    },
    {
      signWithKey,
      gas,
    }
  );
}

export function get_gas_profile(res) {
  return res.result.receipts_outcome
    .map((outcome) => {
      const gas_profile = outcome.outcome["metadata"].gas_profile;
      return gas_profile.map((info) => {
        info.gas_used = Gas.parse(info.gas_used).toHuman();
        return JSON.stringify(info, null, 2);
      });
    })
    .join("\n");
}

export async function create_account_and_claim(
  t,
  contract: NearAccount,
  new_account_id: string,
  signWithKey,
  gas = Gas.parse("100 Tgas"),
  testAccount = true
): Promise<NearAccount> {
  const actualKey = createKeyPair();
  const new_public_key = actualKey.getPublicKey().toString();
  const res = await contract.call_raw(
    contract,
    "create_account_and_claim",
    {
      new_account_id,
      new_public_key,
    },
    {
      signWithKey,
      gas,
    }
  );

  let new_account = contract.getFullAccount(new_account_id);
  if (testAccount) {
    // t.log(res.errors, res.promiseErrorMessages);
    if (res.failed) {
      t.log(get_gas_profile(res));
    }
    t.assert(
      await new_account.exists(),
      `account ${new_account_id} does not exist`
    );
    await new_account.setKey(actualKey);
  }
  return new_account;
}

export async function createLinkAndNewAccount(
  t,
  contract: NearAccount,
  root: NearAccount,
  gas
): Promise<NearAccount> {
  const senderKey = await createLinkdrop(t, contract, root);

  // Create a random subaccount
  const new_account_id = `${randomAccountId("d", 10, 10)}.testnet`;

  // Claim account
  const new_account = await create_account_and_claim(
    t,
    contract,
    new_account_id,
    senderKey,
    gas
  );

  // Add roots key to ensure it can be deleted later
  const res = await new_account
    .createTransaction(new_account)
    .addKey((await root.getKey()).getPublicKey())
    .signAndSend();
  t.assert(res.succeeded);
  return new_account;
}

export async function getTokens(
  contract: NearAccount,
  account_id: NearAccount
): Promise<any[]> {
  return contract.view("nft_tokens_for_owner", { account_id });
}

export async function mint(
  tenk: NearAccount,
  root: NearAccount,
  attachedDeposit = ONE_NEAR
): Promise<string> {
  let res = await mint_raw(tenk, root, attachedDeposit);
  return res.parseResult<any>().token_id;
}

export function mint_raw(
  tenk: NearAccount,
  root: NearAccount,
  attachedDeposit = ONE_NEAR
): Promise<TransactionResult> {
  return root.call_raw(
    tenk,
    "nft_mint_one",
    {},
    {
      attachedDeposit,
    }
  );
}

export * from "./delta";

export function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

'''
'''--- api_token.ts ---
export const API_TOKEN: string | null = process.env["NFT_STORAGE_API_TOKEN"]
'''
'''--- contracts/tenk/Cargo.toml ---
[package]
name = "tenk"
version = "0.1.0"
authors = ["Willem Wyndham <willem@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
# near-sdk = { path = "../../../near-sdk-rs/near-sdk"}
# near-contract-standards = { path = "../../../near-sdk-rs/near-contract-standards" }
near-sdk = { git = "https://github.com/ahalabs/near-sdk-rs", tag = "v4.0.0-3"}
near-contract-standards = { git = "https://github.com/ahalabs/near-sdk-rs", tag = "v4.0.0-3" }
near-units = "0.2.0"
serde_with = "1.0.0"

[dev-dependencies]
rand = "0.7.2"
rand_xorshift = "0.2.0"

[features]
default = []
testnet = []
airdrop = []

'''
'''--- contracts/tenk/dist/helper.d.ts ---
export { Account, transactions, providers, DEFAULT_FUNCTION_CALL_GAS } from 'near-api-js';
import BN from 'bn.js';
export { BN };
export interface ChangeMethodOptions {
    gas?: BN;
    attachedDeposit?: BN;
    walletMeta?: string;
    walletCallbackUrl?: string;
}
/**
 * Options for view contract calls
 */
export interface ViewFunctionOptions {
    parse?: (response: Uint8Array) => any;
    stringify?: (input: any) => any;
}
/**
* @minimum 0
* @maximum 18446744073709551615
* @asType integer
*/
export declare type u64 = number;
/**
* @minimum -9223372036854775808
* @maximum 9223372036854775807
* @asType integer
*/
export declare type i64 = number;
/**
* @minimum  0
* @maximum 255
* @asType integer
* */
export declare type u8 = number;
/**
* @minimum  -128
* @maximum 127
* @asType integer
* */
export declare type i8 = number;
/**
* @minimum  0
* @maximum 65535
* @asType integer
* */
export declare type u16 = number;
/**
* @minimum -32768
* @maximum 32767
* @asType integer
* */
export declare type i16 = number;
/**
* @minimum 0
* @maximum 4294967295
* @asType integer
* */
export declare type u32 = number;
/**
* @minimum 0
* @maximum 4294967295
* @asType integer
* */
export declare type usize = number;
/**
* @minimum  -2147483648
* @maximum 2147483647
* @asType integer
* */
export declare type i32 = number;
/**
* @minimum -3.40282347E+38
* @maximum 3.40282347E+38
*/
export declare type f32 = number;
/**
* @minimum -1.7976931348623157E+308
* @maximum 1.7976931348623157E+308
*/
export declare type f64 = number;

'''
'''--- contracts/tenk/dist/helper.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = exports.DEFAULT_FUNCTION_CALL_GAS = exports.providers = exports.transactions = exports.Account = void 0;
//@ts-ignore for ts-json-schema-generator
var near_api_js_1 = require("near-api-js");
Object.defineProperty(exports, "Account", { enumerable: true, get: function () { return near_api_js_1.Account; } });
Object.defineProperty(exports, "transactions", { enumerable: true, get: function () { return near_api_js_1.transactions; } });
Object.defineProperty(exports, "providers", { enumerable: true, get: function () { return near_api_js_1.providers; } });
Object.defineProperty(exports, "DEFAULT_FUNCTION_CALL_GAS", { enumerable: true, get: function () { return near_api_js_1.DEFAULT_FUNCTION_CALL_GAS; } });
//@ts-ignore for ts-json-schema-generator
var bn_js_1 = __importDefault(require("bn.js"));
exports.BN = bn_js_1.default;

'''
'''--- contracts/tenk/dist/index.d.ts ---
import { Account, transactions, providers, u8, u16, u32, u64, ChangeMethodOptions, ViewFunctionOptions } from './helper';
/**
* StorageUsage is used to count the amount of storage used by a contract.
*/
export declare type StorageUsage = u64;
/**
* Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
*/
export declare type Balance = U128;
/**
* String representation of a u128-bit integer
* @pattern ^[0-9]+$
* Note: largest u128 is "340282366920938463463374607431768211455"
*/
export declare type U128 = string;
/**
* Represents the amount of NEAR tokens in "gas units" which are used to fund transactions.
*/
export declare type Gas = u64;
/**
* base64 string.
*/
export declare type Base64VecU8 = string;
/**
* Raw type for duration in nanoseconds
*/
export declare type Duration = u64;
/**
* @minLength 2
* @maxLength 64
* @pattern ^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$
*/
export declare type AccountId = string;
/**
* Public key in a binary format with base58 string serialization with human-readable curve.
* The key types currently supported are `secp256k1` and `ed25519`.
*
* Ed25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.
*/
export declare type PublicKey = string;
/**
* Raw type for timestamp in nanoseconds
*/
export declare type Timestamp = u64;
/**
* In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
*/
export interface Token {
    token_id: TokenId;
    owner_id: AccountId;
    metadata?: TokenMetadata;
    approved_account_ids?: Record<AccountId, u64>;
}
export interface FungibleTokenMetadata {
    spec: string;
    name: string;
    symbol: string;
    icon?: string;
    reference?: string;
    reference_hash?: Base64VecU8;
    decimals: u8;
}
/**
* Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
*/
export declare type TokenId = string;
/**
* Metadata for the NFT contract itself.
*/
export interface NftContractMetadata {
    spec: string;
    name: string;
    symbol: string;
    icon?: string;
    base_uri?: string;
    reference?: string;
    reference_hash?: Base64VecU8;
}
export interface StorageBalanceBounds {
    min: U128;
    max?: U128;
}
/**
* Metadata on the individual token level.
*/
export interface TokenMetadata {
    title?: string;
    description?: string;
    media?: string;
    media_hash?: Base64VecU8;
    copies?: u64;
    issued_at?: string;
    expires_at?: string;
    starts_at?: string;
    updated_at?: string;
    extra?: string;
    reference?: string;
    reference_hash?: Base64VecU8;
}
export interface StorageBalance {
    total: U128;
    available: U128;
}
export declare type WrappedDuration = string;
/**
* Current state of contract
*/
export declare enum Status {
    /**
    * Not open for any sales
    */
    Closed = "Closed",
    /**
    * VIP accounts can mint
    */
    Presale = "Presale",
    /**
    * Any account can mint
    */
    Open = "Open",
    /**
    * No more tokens to be minted
    */
    SoldOut = "SoldOut"
}
/**
* Information about the current sale from user perspective
*/
export interface UserSaleInfo {
    sale_info: SaleInfo;
    is_vip: boolean;
    remaining_allowance?: u32;
}
export interface Royalties {
    accounts: Record<AccountId, BasisPoint>;
    percent: BasisPoint;
}
export interface Sale {
    royalties?: Royalties;
    initial_royalties?: Royalties;
    presale_start?: TimestampMs;
    public_sale_start?: TimestampMs;
    allowance?: u32;
    presale_price?: U128;
    price: U128;
    mint_rate_limit?: u32;
}
/**
* milliseconds elapsed since the UNIX epoch
*/
export declare type TimestampMs = u64;
export interface InitialMetadata {
    name: string;
    symbol: string;
    uri: string;
    icon?: string;
    spec?: string;
    reference?: string;
    reference_hash?: Base64VecU8;
}
export declare type BasisPoint = u16;
/**
* Information about the current sale
*/
export interface SaleInfo {
    /**
    * Current state of contract
    */
    status: Status;
    /**
    * Start of the VIP sale
    */
    presale_start: TimestampMs;
    /**
    * Start of public sale
    */
    sale_start: TimestampMs;
    /**
    * Total tokens that could be minted
    */
    token_final_supply: u64;
    /**
    * Current price for one token
    */
    price: U128;
}
/**
* Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation
* A mapping of NEAR accounts to the amount each should be paid out, in
* the event of a token-sale. The payout mapping MUST be shorter than the
* maximum length specified by the financial contract obtaining this
* payout data. Any mapping of length 10 or less MUST be accepted by
* financial contracts, so 10 is a safe upper limit.
* This currently deviates from the standard but is in the process of updating to use this type
*/
export interface Payout {
    payout: Record<AccountId, U128>;
}
export declare class Contract {
    account: Account;
    readonly contractId: string;
    constructor(account: Account, contractId: string);
    check_key(args: {
        public_key: PublicKey;
    }, options?: ViewFunctionOptions): Promise<boolean>;
    update_allowance(args: {
        allowance: u32;
    }, options?: ChangeMethodOptions): Promise<void>;
    update_allowanceRaw(args: {
        allowance: u32;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    update_allowanceTx(args: {
        allowance: u32;
    }, options?: ChangeMethodOptions): transactions.Action;
    whitelisted(args: {
        account_id: AccountId;
    }, options?: ViewFunctionOptions): Promise<boolean>;
    get_sale_info(args?: {}, options?: ViewFunctionOptions): Promise<SaleInfo>;
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    nft_revoke_all(args: {
        token_id: TokenId;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    nft_revoke_allRaw(args: {
        token_id: TokenId;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    nft_revoke_allTx(args: {
        token_id: TokenId;
    }, options?: ChangeMethodOptions): transactions.Action;
    cost_per_token(args: {
        minter: AccountId;
    }, options?: ViewFunctionOptions): Promise<U128>;
    transfer_ownership(args: {
        new_owner: AccountId;
    }, options?: ChangeMethodOptions): Promise<void>;
    transfer_ownershipRaw(args: {
        new_owner: AccountId;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    transfer_ownershipTx(args: {
        new_owner: AccountId;
    }, options?: ChangeMethodOptions): transactions.Action;
    start_presale(args: {
        public_sale_start?: TimestampMs;
        presale_price?: U128;
    }, options?: ChangeMethodOptions): Promise<void>;
    start_presaleRaw(args: {
        public_sale_start?: TimestampMs;
        presale_price?: U128;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    start_presaleTx(args: {
        public_sale_start?: TimestampMs;
        presale_price?: U128;
    }, options?: ChangeMethodOptions): transactions.Action;
    close_contract(args?: {}, options?: ChangeMethodOptions): Promise<void>;
    close_contractRaw(args?: {}, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    close_contractTx(args?: {}, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    nft_transfer(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    nft_transferRaw(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    nft_transferTx(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
    }, options?: ChangeMethodOptions): transactions.Action;
    start_sale(args: {
        price?: U128;
    }, options?: ChangeMethodOptions): Promise<void>;
    start_saleRaw(args: {
        price?: U128;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    start_saleTx(args: {
        price?: U128;
    }, options?: ChangeMethodOptions): transactions.Action;
    nft_mint_many(args: {
        num: u32;
    }, options?: ChangeMethodOptions): Promise<Token[]>;
    nft_mint_manyRaw(args: {
        num: u32;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    nft_mint_manyTx(args: {
        num: u32;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Check if a token is approved for transfer by a given account, optionally
    * checking an approval_id
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `approved_account_id`: the account to check the existence of in `approvals`
    * * `approval_id`: an optional approval ID to check against current approval ID for given account
    *
    * Returns:
    * if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
    * otherwise, `true` if `approved_account_id` is in list of approved accounts
    */
    nft_is_approved(args: {
        token_id: TokenId;
        approved_account_id: AccountId;
        approval_id?: u64;
    }, options?: ViewFunctionOptions): Promise<boolean>;
    update_uri(args: {
        uri: string;
    }, options?: ChangeMethodOptions): Promise<void>;
    update_uriRaw(args: {
        uri: string;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    update_uriTx(args: {
        uri: string;
    }, options?: ChangeMethodOptions): transactions.Action;
    nft_payout(args: {
        token_id: string;
        balance: U128;
        max_len_payout?: u32;
    }, options?: ViewFunctionOptions): Promise<Payout>;
    /**
    * Get a list of all tokens
    *
    * Arguments:
    * * `from_index`: a string representing an unsigned 128-bit integer,
    * representing the starting index of tokens to return. (default 0)
    * * `limit`: the maximum number of tokens to return (default total supply)
    * Could fail on gas
    *
    * Returns an array of Token objects, as described in Core standard
    */
    nft_tokens(args: {
        from_index?: U128;
        limit?: u64;
    }, options?: ViewFunctionOptions): Promise<Token[]>;
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    nft_transfer_call(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
        msg: string;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    nft_transfer_callRaw(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
        msg: string;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    nft_transfer_callTx(args: {
        receiver_id: AccountId;
        token_id: TokenId;
        approval_id?: u64;
        memo?: string;
        msg: string;
    }, options?: ChangeMethodOptions): transactions.Action;
    nft_transfer_payout(args: {
        receiver_id: AccountId;
        token_id: string;
        approval_id?: u64;
        memo?: string;
        balance: U128;
        max_len_payout?: u32;
    }, options?: ChangeMethodOptions): Promise<Payout>;
    nft_transfer_payoutRaw(args: {
        receiver_id: AccountId;
        token_id: string;
        approval_id?: u64;
        memo?: string;
        balance: U128;
        max_len_payout?: u32;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    nft_transfer_payoutTx(args: {
        receiver_id: AccountId;
        token_id: string;
        approval_id?: u64;
        memo?: string;
        balance: U128;
        max_len_payout?: u32;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Returns the balance associated with given key.
    */
    get_key_balance(args?: {}, options?: ViewFunctionOptions): Promise<U128>;
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    nft_revoke(args: {
        token_id: TokenId;
        account_id: AccountId;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    nft_revokeRaw(args: {
        token_id: TokenId;
        account_id: AccountId;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    nft_revokeTx(args: {
        token_id: TokenId;
        account_id: AccountId;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    create_linkdrop(args: {
        public_key: PublicKey;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    create_linkdropRaw(args: {
        public_key: PublicKey;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    create_linkdropTx(args: {
        public_key: PublicKey;
    }, options?: ChangeMethodOptions): transactions.Action;
    add_whitelist_accounts(args: {
        accounts: AccountId[];
        allowance?: u32;
    }, options?: ChangeMethodOptions): Promise<void>;
    add_whitelist_accountsRaw(args: {
        accounts: AccountId[];
        allowance?: u32;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    add_whitelist_accountsTx(args: {
        accounts: AccountId[];
        allowance?: u32;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Returns the token with the given `token_id` or `null` if no such token.
    */
    nft_token(args: {
        token_id: TokenId;
    }, options?: ViewFunctionOptions): Promise<Token | null>;
    new(args: {
        owner_id: AccountId;
        metadata: NftContractMetadata;
        size: u32;
        sale: Sale;
    }, options?: ChangeMethodOptions): Promise<void>;
    newRaw(args: {
        owner_id: AccountId;
        metadata: NftContractMetadata;
        size: u32;
        sale: Sale;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    newTx(args: {
        owner_id: AccountId;
        metadata: NftContractMetadata;
        size: u32;
        sale: Sale;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Returns the total supply of non-fungible tokens as a string representing an
    * unsigned 128-bit integer to avoid JSON number limit of 2^53.
    */
    nft_total_supply(args?: {}, options?: ViewFunctionOptions): Promise<U128>;
    token_storage_cost(args?: {}, options?: ViewFunctionOptions): Promise<U128>;
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    nft_approve(args: {
        token_id: TokenId;
        account_id: AccountId;
        msg?: string;
    }, options?: ChangeMethodOptions): Promise<void>;
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    nft_approveRaw(args: {
        token_id: TokenId;
        account_id: AccountId;
        msg?: string;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    nft_approveTx(args: {
        token_id: TokenId;
        account_id: AccountId;
        msg?: string;
    }, options?: ChangeMethodOptions): transactions.Action;
    cost_of_linkdrop(args: {
        minter: AccountId;
    }, options?: ViewFunctionOptions): Promise<U128>;
    total_cost(args: {
        num: u32;
        minter: AccountId;
    }, options?: ViewFunctionOptions): Promise<U128>;
    get_linkdrop_contract(args?: {}, options?: ViewFunctionOptions): Promise<AccountId>;
    new_default_meta(args: {
        owner_id: AccountId;
        metadata: InitialMetadata;
        size: u32;
        sale?: Sale;
    }, options?: ChangeMethodOptions): Promise<void>;
    new_default_metaRaw(args: {
        owner_id: AccountId;
        metadata: InitialMetadata;
        size: u32;
        sale?: Sale;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    new_default_metaTx(args: {
        owner_id: AccountId;
        metadata: InitialMetadata;
        size: u32;
        sale?: Sale;
    }, options?: ChangeMethodOptions): transactions.Action;
    /**
    * Get number of tokens owned by a given account
    *
    * Arguments:
    * * `account_id`: a valid NEAR account
    *
    * Returns the number of non-fungible tokens owned by given `account_id` as
    * a string representing the value as an unsigned 128-bit integer to avoid JSON
    * number limit of 2^53.
    */
    nft_supply_for_owner(args: {
        account_id: AccountId;
    }, options?: ViewFunctionOptions): Promise<U128>;
    nft_metadata(args?: {}, options?: ViewFunctionOptions): Promise<NftContractMetadata>;
    mint_rate_limit(args?: {}, options?: ViewFunctionOptions): Promise<u32 | null>;
    remaining_allowance(args: {
        account_id: AccountId;
    }, options?: ViewFunctionOptions): Promise<u32 | null>;
    /**
    * Get list of all tokens owned by a given account
    *
    * Arguments:
    * * `account_id`: a valid NEAR account
    * * `from_index`: a string representing an unsigned 128-bit integer,
    * representing the starting index of tokens to return. (default 0)
    * * `limit`: the maximum number of tokens to return. (default unlimited)
    * Could fail on gas
    *
    * Returns a paginated list of all tokens owned by this account
    */
    nft_tokens_for_owner(args: {
        account_id: AccountId;
        from_index?: U128;
        limit?: u64;
    }, options?: ViewFunctionOptions): Promise<Token[]>;
    nft_mint(args: {
        token_id: TokenId;
        token_owner_id: AccountId;
        token_metadata: TokenMetadata;
    }, options?: ChangeMethodOptions): Promise<Token>;
    nft_mintRaw(args: {
        token_id: TokenId;
        token_owner_id: AccountId;
        token_metadata: TokenMetadata;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    nft_mintTx(args: {
        token_id: TokenId;
        token_owner_id: AccountId;
        token_metadata: TokenMetadata;
    }, options?: ChangeMethodOptions): transactions.Action;
    get_user_sale_info(args: {
        account_id: AccountId;
    }, options?: ViewFunctionOptions): Promise<UserSaleInfo>;
    initial(args?: {}, options?: ViewFunctionOptions): Promise<u64>;
    add_whitelist_account_ungaurded(args: {
        account_id: AccountId;
        allowance: u32;
    }, options?: ChangeMethodOptions): Promise<void>;
    add_whitelist_account_ungaurdedRaw(args: {
        account_id: AccountId;
        allowance: u32;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    add_whitelist_account_ungaurdedTx(args: {
        account_id: AccountId;
        allowance: u32;
    }, options?: ChangeMethodOptions): transactions.Action;
    tokens_left(args?: {}, options?: ViewFunctionOptions): Promise<u32>;
    update_royalties(args: {
        royalties: Royalties;
    }, options?: ChangeMethodOptions): Promise<void>;
    update_royaltiesRaw(args: {
        royalties: Royalties;
    }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    update_royaltiesTx(args: {
        royalties: Royalties;
    }, options?: ChangeMethodOptions): transactions.Action;
    nft_mint_one(args?: {}, options?: ChangeMethodOptions): Promise<Token>;
    nft_mint_oneRaw(args?: {}, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome>;
    nft_mint_oneTx(args?: {}, options?: ChangeMethodOptions): transactions.Action;
}
/**
*
* @contractMethod view
*/
export interface CheckKey {
    public_key: PublicKey;
}
/**
*
* @contractMethod change
*/
export interface UpdateAllowance {
    allowance: u32;
}
/**
*
* @contractMethod view
*/
export interface Whitelisted {
    account_id: AccountId;
}
/**
*
* @contractMethod view
*/
export interface GetSaleInfo {
}
/**
* Revoke all approved accounts for a specific token.
*
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * If contract requires >1yN deposit on `nft_approve`, contract
* MUST refund all associated storage deposit when owner revokes approvals
* * Contract MUST panic if called by someone other than token owner
*
* Arguments:
* * `token_id`: the token with approvals to revoke
*
* @contractMethod change
*/
export interface NftRevokeAll {
    token_id: TokenId;
}
/**
*
* @contractMethod view
*/
export interface CostPerToken {
    minter: AccountId;
}
/**
*
* @contractMethod change
*/
export interface TransferOwnership {
    new_owner: AccountId;
}
/**
*
* @contractMethod change
*/
export interface StartPresale {
    public_sale_start?: TimestampMs;
    presale_price?: U128;
}
/**
*
* @contractMethod change
*/
export interface CloseContract {
}
/**
* Simple transfer. Transfer a given `token_id` from current owner to
* `receiver_id`.
*
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
* * Contract MUST panic if called by someone other than token owner or,
* if using Approval Management, one of the approved accounts
* * `approval_id` is for use with Approval Management,
* see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
* * If using Approval Management, contract MUST nullify approved accounts on
* successful transfer.
* * TODO: needed? Both accounts must be registered with the contract for transfer to
* succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
*
* Arguments:
* * `receiver_id`: the valid NEAR account receiving the token
* * `token_id`: the token to transfer
* * `approval_id`: expected approval ID. A number smaller than
* 2^53, and therefore representable as JSON. See Approval Management
* standard for full explanation.
* * `memo` (optional): for use cases that may benefit from indexing or
* providing information for a transfer
*
* @contractMethod change
*/
export interface NftTransfer {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
}
/**
*
* @contractMethod change
*/
export interface StartSale {
    price?: U128;
}
/**
*
* @contractMethod change
*/
export interface NftMintMany {
    num: u32;
}
/**
* Check if a token is approved for transfer by a given account, optionally
* checking an approval_id
*
* Arguments:
* * `token_id`: the token for which to revoke an approval
* * `approved_account_id`: the account to check the existence of in `approvals`
* * `approval_id`: an optional approval ID to check against current approval ID for given account
*
* Returns:
* if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
* otherwise, `true` if `approved_account_id` is in list of approved accounts
*
* @contractMethod view
*/
export interface NftIsApproved {
    token_id: TokenId;
    approved_account_id: AccountId;
    approval_id?: u64;
}
/**
*
* @contractMethod change
*/
export interface UpdateUri {
    uri: string;
}
/**
*
* @contractMethod view
*/
export interface NftPayout {
    token_id: string;
    balance: U128;
    max_len_payout?: u32;
}
/**
* Get a list of all tokens
*
* Arguments:
* * `from_index`: a string representing an unsigned 128-bit integer,
* representing the starting index of tokens to return. (default 0)
* * `limit`: the maximum number of tokens to return (default total supply)
* Could fail on gas
*
* Returns an array of Token objects, as described in Core standard
*
* @contractMethod view
*/
export interface NftTokens {
    from_index?: U128;
    limit?: u64;
}
/**
* Transfer token and call a method on a receiver contract. A successful
* workflow will end in a success execution outcome to the callback on the NFT
* contract at the method `nft_resolve_transfer`.
*
* You can think of this as being similar to attaching native NEAR tokens to a
* function call. It allows you to attach any Non-Fungible Token in a call to a
* receiver contract.
*
* Requirements:
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * Contract MUST panic if called by someone other than token owner or,
* if using Approval Management, one of the approved accounts
* * The receiving contract must implement `ft_on_transfer` according to the
* standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
* with the resulting failed cross-contract call and roll back the transfer.
* * Contract MUST implement the behavior described in `ft_resolve_transfer`
* * `approval_id` is for use with Approval Management extension, see
* that document for full explanation.
* * If using Approval Management, contract MUST nullify approved accounts on
* successful transfer.
*
* Arguments:
* * `receiver_id`: the valid NEAR account receiving the token.
* * `token_id`: the token to send.
* * `approval_id`: expected approval ID. A number smaller than
* 2^53, and therefore representable as JSON. See Approval Management
* standard for full explanation.
* * `memo` (optional): for use cases that may benefit from indexing or
* providing information for a transfer.
* * `msg`: specifies information needed by the receiving contract in
* order to properly handle the transfer. Can indicate both a function to
* call and the parameters to pass to that function.
*
* @contractMethod change
*/
export interface NftTransferCall {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
    msg: string;
}
/**
*
* @contractMethod change
*/
export interface NftTransferPayout {
    receiver_id: AccountId;
    token_id: string;
    approval_id?: u64;
    memo?: string;
    balance: U128;
    max_len_payout?: u32;
}
/**
* Returns the balance associated with given key.
*
* @contractMethod view
*/
export interface GetKeyBalance {
}
/**
* Revoke an approved account for a specific token.
*
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * If contract requires >1yN deposit on `nft_approve`, contract
* MUST refund associated storage deposit when owner revokes approval
* * Contract MUST panic if called by someone other than token owner
*
* Arguments:
* * `token_id`: the token for which to revoke an approval
* * `account_id`: the account to remove from `approvals`
*
* @contractMethod change
*/
export interface NftRevoke {
    token_id: TokenId;
    account_id: AccountId;
}
/**
* Create a pending token that can be claimed with corresponding private key
*
* @contractMethod change
*/
export interface CreateLinkdrop {
    public_key: PublicKey;
}
/**
*
* @contractMethod change
*/
export interface AddWhitelistAccounts {
    accounts: AccountId[];
    allowance?: u32;
}
/**
* Returns the token with the given `token_id` or `null` if no such token.
*
* @contractMethod view
*/
export interface NftToken {
    token_id: TokenId;
}
/**
*
* @contractMethod change
*/
export interface New {
    owner_id: AccountId;
    metadata: NftContractMetadata;
    size: u32;
    sale: Sale;
}
/**
* Returns the total supply of non-fungible tokens as a string representing an
* unsigned 128-bit integer to avoid JSON number limit of 2^53.
*
* @contractMethod view
*/
export interface NftTotalSupply {
}
/**
*
* @contractMethod view
*/
export interface TokenStorageCost {
}
/**
* Add an approved account for a specific token.
*
* Requirements
* * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
* security purposes
* * Contract MAY require caller to attach larger deposit, to cover cost of
* storing approver data
* * Contract MUST panic if called by someone other than token owner
* * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
* single-block gas limit
* * Contract MUST increment approval ID even if re-approving an account
* * If successfully approved or if had already been approved, and if `msg` is
* present, contract MUST call `nft_on_approve` on `account_id`. See
* `nft_on_approve` description below for details.
*
* Arguments:
* * `token_id`: the token for which to add an approval
* * `account_id`: the account to add to `approvals`
* * `msg`: optional string to be passed to `nft_on_approve`
*
* Returns void, if no `msg` given. Otherwise, returns promise call to
* `nft_on_approve`, which can resolve with whatever it wants.
*
* @contractMethod change
*/
export interface NftApprove {
    token_id: TokenId;
    account_id: AccountId;
    msg?: string;
}
/**
*
* @contractMethod view
*/
export interface CostOfLinkdrop {
    minter: AccountId;
}
/**
*
* @contractMethod view
*/
export interface TotalCost {
    num: u32;
    minter: AccountId;
}
/**
*
* @contractMethod view
*/
export interface GetLinkdropContract {
}
/**
*
* @contractMethod change
*/
export interface NewDefaultMeta {
    owner_id: AccountId;
    metadata: InitialMetadata;
    size: u32;
    sale?: Sale;
}
/**
* Get number of tokens owned by a given account
*
* Arguments:
* * `account_id`: a valid NEAR account
*
* Returns the number of non-fungible tokens owned by given `account_id` as
* a string representing the value as an unsigned 128-bit integer to avoid JSON
* number limit of 2^53.
*
* @contractMethod view
*/
export interface NftSupplyForOwner {
    account_id: AccountId;
}
/**
*
* @contractMethod view
*/
export interface NftMetadata {
}
/**
*
* @contractMethod view
*/
export interface MintRateLimit {
}
/**
*
* @contractMethod view
*/
export interface RemainingAllowance {
    account_id: AccountId;
}
/**
* Get list of all tokens owned by a given account
*
* Arguments:
* * `account_id`: a valid NEAR account
* * `from_index`: a string representing an unsigned 128-bit integer,
* representing the starting index of tokens to return. (default 0)
* * `limit`: the maximum number of tokens to return. (default unlimited)
* Could fail on gas
*
* Returns a paginated list of all tokens owned by this account
*
* @contractMethod view
*/
export interface NftTokensForOwner {
    account_id: AccountId;
    from_index?: U128;
    limit?: u64;
}
/**
*
* @contractMethod change
*/
export interface NftMint {
    token_id: TokenId;
    token_owner_id: AccountId;
    token_metadata: TokenMetadata;
}
/**
*
* @contractMethod view
*/
export interface GetUserSaleInfo {
    account_id: AccountId;
}
/**
*
* @contractMethod view
*/
export interface Initial {
}
/**
*
* @contractMethod change
*/
export interface AddWhitelistAccountUngaurded {
    account_id: AccountId;
    allowance: u32;
}
/**
*
* @contractMethod view
*/
export interface TokensLeft {
}
/**
*
* @contractMethod change
*/
export interface UpdateRoyalties {
    royalties: Royalties;
}
/**
*
* @contractMethod change
*/
export interface NftMintOne {
}

'''
'''--- contracts/tenk/dist/index.js ---
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = exports.Status = void 0;
var helper_1 = require("./helper");
/**
* Current state of contract
*/
var Status;
(function (Status) {
    /**
    * Not open for any sales
    */
    Status["Closed"] = "Closed";
    /**
    * VIP accounts can mint
    */
    Status["Presale"] = "Presale";
    /**
    * Any account can mint
    */
    Status["Open"] = "Open";
    /**
    * No more tokens to be minted
    */
    Status["SoldOut"] = "SoldOut";
})(Status = exports.Status || (exports.Status = {}));
var Contract = /** @class */ (function () {
    function Contract(account, contractId) {
        this.account = account;
        this.contractId = contractId;
    }
    Contract.prototype.check_key = function (args, options) {
        return this.account.viewFunction(this.contractId, "check_key", args, options);
    };
    Contract.prototype.update_allowance = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.update_allowanceRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.update_allowanceRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "update_allowance", args: args }, options));
    };
    Contract.prototype.update_allowanceTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("update_allowance", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.whitelisted = function (args, options) {
        return this.account.viewFunction(this.contractId, "whitelisted", args, options);
    };
    Contract.prototype.get_sale_info = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "get_sale_info", args, options);
    };
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    Contract.prototype.nft_revoke_all = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_revoke_allRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    Contract.prototype.nft_revoke_allRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_revoke_all", args: args }, options));
    };
    /**
    * Revoke all approved accounts for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund all associated storage deposit when owner revokes approvals
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token with approvals to revoke
    */
    Contract.prototype.nft_revoke_allTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_revoke_all", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.cost_per_token = function (args, options) {
        return this.account.viewFunction(this.contractId, "cost_per_token", args, options);
    };
    Contract.prototype.transfer_ownership = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.transfer_ownershipRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.transfer_ownershipRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "transfer_ownership", args: args }, options));
    };
    Contract.prototype.transfer_ownershipTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("transfer_ownership", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.start_presale = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.start_presaleRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.start_presaleRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "start_presale", args: args }, options));
    };
    Contract.prototype.start_presaleTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("start_presale", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.close_contract = function (args, options) {
        if (args === void 0) { args = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.close_contractRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.close_contractRaw = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "close_contract", args: args }, options));
    };
    Contract.prototype.close_contractTx = function (args, options) {
        var _a, _b;
        if (args === void 0) { args = {}; }
        return helper_1.transactions.functionCall("close_contract", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    Contract.prototype.nft_transfer = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_transferRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    Contract.prototype.nft_transferRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_transfer", args: args }, options));
    };
    /**
    * Simple transfer. Transfer a given `token_id` from current owner to
    * `receiver_id`.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * `approval_id` is for use with Approval Management,
    * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    * * TODO: needed? Both accounts must be registered with the contract for transfer to
    * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token
    * * `token_id`: the token to transfer
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer
    */
    Contract.prototype.nft_transferTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_transfer", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.start_sale = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.start_saleRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.start_saleRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "start_sale", args: args }, options));
    };
    Contract.prototype.start_saleTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("start_sale", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.nft_mint_many = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_mint_manyRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.nft_mint_manyRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_mint_many", args: args }, options));
    };
    Contract.prototype.nft_mint_manyTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_mint_many", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Check if a token is approved for transfer by a given account, optionally
    * checking an approval_id
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `approved_account_id`: the account to check the existence of in `approvals`
    * * `approval_id`: an optional approval ID to check against current approval ID for given account
    *
    * Returns:
    * if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
    * otherwise, `true` if `approved_account_id` is in list of approved accounts
    */
    Contract.prototype.nft_is_approved = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_is_approved", args, options);
    };
    Contract.prototype.update_uri = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.update_uriRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.update_uriRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "update_uri", args: args }, options));
    };
    Contract.prototype.update_uriTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("update_uri", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.nft_payout = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_payout", args, options);
    };
    /**
    * Get a list of all tokens
    *
    * Arguments:
    * * `from_index`: a string representing an unsigned 128-bit integer,
    * representing the starting index of tokens to return. (default 0)
    * * `limit`: the maximum number of tokens to return (default total supply)
    * Could fail on gas
    *
    * Returns an array of Token objects, as described in Core standard
    */
    Contract.prototype.nft_tokens = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_tokens", args, options);
    };
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    Contract.prototype.nft_transfer_call = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_transfer_callRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    Contract.prototype.nft_transfer_callRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_transfer_call", args: args }, options));
    };
    /**
    * Transfer token and call a method on a receiver contract. A successful
    * workflow will end in a success execution outcome to the callback on the NFT
    * contract at the method `nft_resolve_transfer`.
    *
    * You can think of this as being similar to attaching native NEAR tokens to a
    * function call. It allows you to attach any Non-Fungible Token in a call to a
    * receiver contract.
    *
    * Requirements:
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * Contract MUST panic if called by someone other than token owner or,
    * if using Approval Management, one of the approved accounts
    * * The receiving contract must implement `ft_on_transfer` according to the
    * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    * with the resulting failed cross-contract call and roll back the transfer.
    * * Contract MUST implement the behavior described in `ft_resolve_transfer`
    * * `approval_id` is for use with Approval Management extension, see
    * that document for full explanation.
    * * If using Approval Management, contract MUST nullify approved accounts on
    * successful transfer.
    *
    * Arguments:
    * * `receiver_id`: the valid NEAR account receiving the token.
    * * `token_id`: the token to send.
    * * `approval_id`: expected approval ID. A number smaller than
    * 2^53, and therefore representable as JSON. See Approval Management
    * standard for full explanation.
    * * `memo` (optional): for use cases that may benefit from indexing or
    * providing information for a transfer.
    * * `msg`: specifies information needed by the receiving contract in
    * order to properly handle the transfer. Can indicate both a function to
    * call and the parameters to pass to that function.
    */
    Contract.prototype.nft_transfer_callTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_transfer_call", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.nft_transfer_payout = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_transfer_payoutRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.nft_transfer_payoutRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_transfer_payout", args: args }, options));
    };
    Contract.prototype.nft_transfer_payoutTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_transfer_payout", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Returns the balance associated with given key.
    */
    Contract.prototype.get_key_balance = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "get_key_balance", args, options);
    };
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    Contract.prototype.nft_revoke = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_revokeRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    Contract.prototype.nft_revokeRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_revoke", args: args }, options));
    };
    /**
    * Revoke an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    * purposes
    * * If contract requires >1yN deposit on `nft_approve`, contract
    * MUST refund associated storage deposit when owner revokes approval
    * * Contract MUST panic if called by someone other than token owner
    *
    * Arguments:
    * * `token_id`: the token for which to revoke an approval
    * * `account_id`: the account to remove from `approvals`
    */
    Contract.prototype.nft_revokeTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_revoke", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    Contract.prototype.create_linkdrop = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.create_linkdropRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    Contract.prototype.create_linkdropRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "create_linkdrop", args: args }, options));
    };
    /**
    * Create a pending token that can be claimed with corresponding private key
    */
    Contract.prototype.create_linkdropTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("create_linkdrop", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.add_whitelist_accounts = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.add_whitelist_accountsRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.add_whitelist_accountsRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "add_whitelist_accounts", args: args }, options));
    };
    Contract.prototype.add_whitelist_accountsTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("add_whitelist_accounts", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Returns the token with the given `token_id` or `null` if no such token.
    */
    Contract.prototype.nft_token = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_token", args, options);
    };
    Contract.prototype.new = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.newRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.newRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "new", args: args }, options));
    };
    Contract.prototype.newTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("new", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Returns the total supply of non-fungible tokens as a string representing an
    * unsigned 128-bit integer to avoid JSON number limit of 2^53.
    */
    Contract.prototype.nft_total_supply = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "nft_total_supply", args, options);
    };
    Contract.prototype.token_storage_cost = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "token_storage_cost", args, options);
    };
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    Contract.prototype.nft_approve = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_approveRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    Contract.prototype.nft_approveRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_approve", args: args }, options));
    };
    /**
    * Add an approved account for a specific token.
    *
    * Requirements
    * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    * security purposes
    * * Contract MAY require caller to attach larger deposit, to cover cost of
    * storing approver data
    * * Contract MUST panic if called by someone other than token owner
    * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    * single-block gas limit
    * * Contract MUST increment approval ID even if re-approving an account
    * * If successfully approved or if had already been approved, and if `msg` is
    * present, contract MUST call `nft_on_approve` on `account_id`. See
    * `nft_on_approve` description below for details.
    *
    * Arguments:
    * * `token_id`: the token for which to add an approval
    * * `account_id`: the account to add to `approvals`
    * * `msg`: optional string to be passed to `nft_on_approve`
    *
    * Returns void, if no `msg` given. Otherwise, returns promise call to
    * `nft_on_approve`, which can resolve with whatever it wants.
    */
    Contract.prototype.nft_approveTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_approve", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.cost_of_linkdrop = function (args, options) {
        return this.account.viewFunction(this.contractId, "cost_of_linkdrop", args, options);
    };
    Contract.prototype.total_cost = function (args, options) {
        return this.account.viewFunction(this.contractId, "total_cost", args, options);
    };
    Contract.prototype.get_linkdrop_contract = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "get_linkdrop_contract", args, options);
    };
    Contract.prototype.new_default_meta = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.new_default_metaRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.new_default_metaRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "new_default_meta", args: args }, options));
    };
    Contract.prototype.new_default_metaTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("new_default_meta", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    /**
    * Get number of tokens owned by a given account
    *
    * Arguments:
    * * `account_id`: a valid NEAR account
    *
    * Returns the number of non-fungible tokens owned by given `account_id` as
    * a string representing the value as an unsigned 128-bit integer to avoid JSON
    * number limit of 2^53.
    */
    Contract.prototype.nft_supply_for_owner = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_supply_for_owner", args, options);
    };
    Contract.prototype.nft_metadata = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "nft_metadata", args, options);
    };
    Contract.prototype.mint_rate_limit = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "mint_rate_limit", args, options);
    };
    Contract.prototype.remaining_allowance = function (args, options) {
        return this.account.viewFunction(this.contractId, "remaining_allowance", args, options);
    };
    /**
    * Get list of all tokens owned by a given account
    *
    * Arguments:
    * * `account_id`: a valid NEAR account
    * * `from_index`: a string representing an unsigned 128-bit integer,
    * representing the starting index of tokens to return. (default 0)
    * * `limit`: the maximum number of tokens to return. (default unlimited)
    * Could fail on gas
    *
    * Returns a paginated list of all tokens owned by this account
    */
    Contract.prototype.nft_tokens_for_owner = function (args, options) {
        return this.account.viewFunction(this.contractId, "nft_tokens_for_owner", args, options);
    };
    Contract.prototype.nft_mint = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_mintRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.nft_mintRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_mint", args: args }, options));
    };
    Contract.prototype.nft_mintTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("nft_mint", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.get_user_sale_info = function (args, options) {
        return this.account.viewFunction(this.contractId, "get_user_sale_info", args, options);
    };
    Contract.prototype.initial = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "initial", args, options);
    };
    Contract.prototype.add_whitelist_account_ungaurded = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.add_whitelist_account_ungaurdedRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.add_whitelist_account_ungaurdedRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "add_whitelist_account_ungaurded", args: args }, options));
    };
    Contract.prototype.add_whitelist_account_ungaurdedTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("add_whitelist_account_ungaurded", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.tokens_left = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.viewFunction(this.contractId, "tokens_left", args, options);
    };
    Contract.prototype.update_royalties = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.update_royaltiesRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.update_royaltiesRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "update_royalties", args: args }, options));
    };
    Contract.prototype.update_royaltiesTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("update_royalties", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    Contract.prototype.nft_mint_one = function (args, options) {
        if (args === void 0) { args = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.nft_mint_oneRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Contract.prototype.nft_mint_oneRaw = function (args, options) {
        if (args === void 0) { args = {}; }
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "nft_mint_one", args: args }, options));
    };
    Contract.prototype.nft_mint_oneTx = function (args, options) {
        var _a, _b;
        if (args === void 0) { args = {}; }
        return helper_1.transactions.functionCall("nft_mint_one", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    return Contract;
}());
exports.Contract = Contract;

'''
'''--- contracts/tenk/index.schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AccountId": {
      "maxLength": 64,
      "minLength": 2,
      "pattern": "^(([a-z\\d]+[-_])*[a-z\\d]+\\.)*([a-z\\d]+[-_])*[a-z\\d]+$",
      "type": "string"
    },
    "AddWhitelistAccountUngaurded": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "allowance": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "account_id",
        "allowance"
      ],
      "type": "object"
    },
    "AddWhitelistAccounts": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "accounts": {
          "items": {
            "$ref": "#/definitions/AccountId"
          },
          "type": "array"
        },
        "allowance": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "accounts"
      ],
      "type": "object"
    },
    "Balance": {
      "$ref": "#/definitions/U128",
      "description": "Balance is a type for storing amounts of tokens, specified in yoctoNEAR."
    },
    "Base64VecU8": {
      "description": "base64 string.",
      "type": "string"
    },
    "BasisPoint": {
      "$ref": "#/definitions/u16"
    },
    "CheckKey": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "public_key": {
          "$ref": "#/definitions/PublicKey"
        }
      },
      "required": [
        "public_key"
      ],
      "type": "object"
    },
    "CloseContract": {
      "additionalProperties": false,
      "contractMethod": "change",
      "type": "object"
    },
    "CostOfLinkdrop": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "minter": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "minter"
      ],
      "type": "object"
    },
    "CostPerToken": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "minter": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "minter"
      ],
      "type": "object"
    },
    "CreateLinkdrop": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Create a pending token that can be claimed with corresponding private key",
      "properties": {
        "public_key": {
          "$ref": "#/definitions/PublicKey"
        }
      },
      "required": [
        "public_key"
      ],
      "type": "object"
    },
    "Duration": {
      "$ref": "#/definitions/u64",
      "description": "Raw type for duration in nanoseconds"
    },
    "FungibleTokenMetadata": {
      "additionalProperties": false,
      "properties": {
        "decimals": {
          "$ref": "#/definitions/u8"
        },
        "icon": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "reference": {
          "type": "string"
        },
        "reference_hash": {
          "$ref": "#/definitions/Base64VecU8"
        },
        "spec": {
          "type": "string"
        },
        "symbol": {
          "type": "string"
        }
      },
      "required": [
        "spec",
        "name",
        "symbol",
        "decimals"
      ],
      "type": "object"
    },
    "Gas": {
      "$ref": "#/definitions/u64",
      "description": "Represents the amount of NEAR tokens in \"gas units\" which are used to fund transactions."
    },
    "GetKeyBalance": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Returns the balance associated with given key.",
      "type": "object"
    },
    "GetLinkdropContract": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "GetSaleInfo": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "GetUserSaleInfo": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "account_id"
      ],
      "type": "object"
    },
    "Initial": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "InitialMetadata": {
      "additionalProperties": false,
      "properties": {
        "icon": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "reference": {
          "type": "string"
        },
        "reference_hash": {
          "$ref": "#/definitions/Base64VecU8"
        },
        "spec": {
          "type": "string"
        },
        "symbol": {
          "type": "string"
        },
        "uri": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "symbol",
        "uri"
      ],
      "type": "object"
    },
    "MintRateLimit": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "New": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/NftContractMetadata"
        },
        "owner_id": {
          "$ref": "#/definitions/AccountId"
        },
        "sale": {
          "$ref": "#/definitions/Sale"
        },
        "size": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "owner_id",
        "metadata",
        "size",
        "sale"
      ],
      "type": "object"
    },
    "NewDefaultMeta": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/InitialMetadata"
        },
        "owner_id": {
          "$ref": "#/definitions/AccountId"
        },
        "sale": {
          "$ref": "#/definitions/Sale"
        },
        "size": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "owner_id",
        "metadata",
        "size"
      ],
      "type": "object"
    },
    "NftApprove": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Add an approved account for a specific token.\n\nRequirements\n* Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for security purposes\n* Contract MAY require caller to attach larger deposit, to cover cost of storing approver data\n* Contract MUST panic if called by someone other than token owner\n* Contract MUST panic if addition would cause `nft_revoke_all` to exceed single-block gas limit\n* Contract MUST increment approval ID even if re-approving an account\n* If successfully approved or if had already been approved, and if `msg` is present, contract MUST call `nft_on_approve` on `account_id`. See `nft_on_approve` description below for details.\n\nArguments:\n* `token_id`: the token for which to add an approval\n* `account_id`: the account to add to `approvals`\n* `msg`: optional string to be passed to `nft_on_approve`\n\nReturns void, if no `msg` given. Otherwise, returns promise call to `nft_on_approve`, which can resolve with whatever it wants.",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "msg": {
          "type": "string"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id",
        "account_id"
      ],
      "type": "object"
    },
    "NftContractMetadata": {
      "additionalProperties": false,
      "description": "Metadata for the NFT contract itself.",
      "properties": {
        "base_uri": {
          "type": "string"
        },
        "icon": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "reference": {
          "type": "string"
        },
        "reference_hash": {
          "$ref": "#/definitions/Base64VecU8"
        },
        "spec": {
          "type": "string"
        },
        "symbol": {
          "type": "string"
        }
      },
      "required": [
        "spec",
        "name",
        "symbol"
      ],
      "type": "object"
    },
    "NftIsApproved": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Check if a token is approved for transfer by a given account, optionally checking an approval_id\n\nArguments:\n* `token_id`: the token for which to revoke an approval\n* `approved_account_id`: the account to check the existence of in `approvals`\n* `approval_id`: an optional approval ID to check against current approval ID for given account\n\nReturns: if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id` otherwise, `true` if `approved_account_id` is in list of approved accounts",
      "properties": {
        "approval_id": {
          "$ref": "#/definitions/u64"
        },
        "approved_account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id",
        "approved_account_id"
      ],
      "type": "object"
    },
    "NftMetadata": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "NftMint": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "token_id": {
          "$ref": "#/definitions/TokenId"
        },
        "token_metadata": {
          "$ref": "#/definitions/TokenMetadata"
        },
        "token_owner_id": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "token_id",
        "token_owner_id",
        "token_metadata"
      ],
      "type": "object"
    },
    "NftMintMany": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "num": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "num"
      ],
      "type": "object"
    },
    "NftMintOne": {
      "additionalProperties": false,
      "contractMethod": "change",
      "type": "object"
    },
    "NftPayout": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "balance": {
          "$ref": "#/definitions/U128"
        },
        "max_len_payout": {
          "$ref": "#/definitions/u32"
        },
        "token_id": {
          "type": "string"
        }
      },
      "required": [
        "token_id",
        "balance"
      ],
      "type": "object"
    },
    "NftRevoke": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Revoke an approved account for a specific token.\n\nRequirements\n* Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes\n* If contract requires >1yN deposit on `nft_approve`, contract MUST refund associated storage deposit when owner revokes approval\n* Contract MUST panic if called by someone other than token owner\n\nArguments:\n* `token_id`: the token for which to revoke an approval\n* `account_id`: the account to remove from `approvals`",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id",
        "account_id"
      ],
      "type": "object"
    },
    "NftRevokeAll": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Revoke all approved accounts for a specific token.\n\nRequirements\n* Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes\n* If contract requires >1yN deposit on `nft_approve`, contract MUST refund all associated storage deposit when owner revokes approvals\n* Contract MUST panic if called by someone other than token owner\n\nArguments:\n* `token_id`: the token with approvals to revoke",
      "properties": {
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id"
      ],
      "type": "object"
    },
    "NftSupplyForOwner": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Get number of tokens owned by a given account\n\nArguments:\n* `account_id`: a valid NEAR account\n\nReturns the number of non-fungible tokens owned by given `account_id` as a string representing the value as an unsigned 128-bit integer to avoid JSON number limit of 2^53.",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "account_id"
      ],
      "type": "object"
    },
    "NftToken": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Returns the token with the given `token_id` or `null` if no such token.",
      "properties": {
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id"
      ],
      "type": "object"
    },
    "NftTokens": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Get a list of all tokens\n\nArguments:\n* `from_index`: a string representing an unsigned 128-bit integer, representing the starting index of tokens to return. (default 0)\n* `limit`: the maximum number of tokens to return (default total supply) Could fail on gas\n\nReturns an array of Token objects, as described in Core standard",
      "properties": {
        "from_index": {
          "$ref": "#/definitions/U128"
        },
        "limit": {
          "$ref": "#/definitions/u64"
        }
      },
      "type": "object"
    },
    "NftTokensForOwner": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Get list of all tokens owned by a given account\n\nArguments:\n* `account_id`: a valid NEAR account\n* `from_index`: a string representing an unsigned 128-bit integer, representing the starting index of tokens to return. (default 0)\n* `limit`: the maximum number of tokens to return. (default unlimited) Could fail on gas\n\nReturns a paginated list of all tokens owned by this account",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "from_index": {
          "$ref": "#/definitions/U128"
        },
        "limit": {
          "$ref": "#/definitions/u64"
        }
      },
      "required": [
        "account_id"
      ],
      "type": "object"
    },
    "NftTotalSupply": {
      "additionalProperties": false,
      "contractMethod": "view",
      "description": "Returns the total supply of non-fungible tokens as a string representing an unsigned 128-bit integer to avoid JSON number limit of 2^53.",
      "type": "object"
    },
    "NftTransfer": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Simple transfer. Transfer a given `token_id` from current owner to `receiver_id`.\n\nRequirements\n* Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes\n* Contract MUST panic if called by someone other than token owner or, if using Approval Management, one of the approved accounts\n* `approval_id` is for use with Approval Management, see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>\n* If using Approval Management, contract MUST nullify approved accounts on successful transfer.\n* TODO: needed? Both accounts must be registered with the contract for transfer to succeed. See see <https://nomicon.io/Standards/StorageManagement.html>\n\nArguments:\n* `receiver_id`: the valid NEAR account receiving the token\n* `token_id`: the token to transfer\n* `approval_id`: expected approval ID. A number smaller than 2^53, and therefore representable as JSON. See Approval Management standard for full explanation.\n* `memo` (optional): for use cases that may benefit from indexing or providing information for a transfer",
      "properties": {
        "approval_id": {
          "$ref": "#/definitions/u64"
        },
        "memo": {
          "type": "string"
        },
        "receiver_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "receiver_id",
        "token_id"
      ],
      "type": "object"
    },
    "NftTransferCall": {
      "additionalProperties": false,
      "contractMethod": "change",
      "description": "Transfer token and call a method on a receiver contract. A successful workflow will end in a success execution outcome to the callback on the NFT contract at the method `nft_resolve_transfer`.\n\nYou can think of this as being similar to attaching native NEAR tokens to a function call. It allows you to attach any Non-Fungible Token in a call to a receiver contract.\n\nRequirements:\n* Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes\n* Contract MUST panic if called by someone other than token owner or, if using Approval Management, one of the approved accounts\n* The receiving contract must implement `ft_on_transfer` according to the standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal with the resulting failed cross-contract call and roll back the transfer.\n* Contract MUST implement the behavior described in `ft_resolve_transfer`\n* `approval_id` is for use with Approval Management extension, see that document for full explanation.\n* If using Approval Management, contract MUST nullify approved accounts on successful transfer.\n\nArguments:\n* `receiver_id`: the valid NEAR account receiving the token.\n* `token_id`: the token to send.\n* `approval_id`: expected approval ID. A number smaller than 2^53, and therefore representable as JSON. See Approval Management standard for full explanation.\n* `memo` (optional): for use cases that may benefit from indexing or providing information for a transfer.\n* `msg`: specifies information needed by the receiving contract in order to properly handle the transfer. Can indicate both a function to call and the parameters to pass to that function.",
      "properties": {
        "approval_id": {
          "$ref": "#/definitions/u64"
        },
        "memo": {
          "type": "string"
        },
        "msg": {
          "type": "string"
        },
        "receiver_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "receiver_id",
        "token_id",
        "msg"
      ],
      "type": "object"
    },
    "NftTransferPayout": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "approval_id": {
          "$ref": "#/definitions/u64"
        },
        "balance": {
          "$ref": "#/definitions/U128"
        },
        "max_len_payout": {
          "$ref": "#/definitions/u32"
        },
        "memo": {
          "type": "string"
        },
        "receiver_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "type": "string"
        }
      },
      "required": [
        "receiver_id",
        "token_id",
        "balance"
      ],
      "type": "object"
    },
    "Payout": {
      "additionalProperties": false,
      "description": "Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation A mapping of NEAR accounts to the amount each should be paid out, in the event of a token-sale. The payout mapping MUST be shorter than the maximum length specified by the financial contract obtaining this payout data. Any mapping of length 10 or less MUST be accepted by financial contracts, so 10 is a safe upper limit. This currently deviates from the standard but is in the process of updating to use this type",
      "properties": {
        "payout": {
          "additionalProperties": {
            "$ref": "#/definitions/U128"
          },
          "type": "object"
        }
      },
      "required": [
        "payout"
      ],
      "type": "object"
    },
    "PublicKey": {
      "description": "Public key in a binary format with base58 string serialization with human-readable curve. The key types currently supported are `secp256k1` and `ed25519`.\n\nEd25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.",
      "type": "string"
    },
    "RemainingAllowance": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "account_id"
      ],
      "type": "object"
    },
    "Royalties": {
      "additionalProperties": false,
      "properties": {
        "accounts": {
          "additionalProperties": {
            "$ref": "#/definitions/BasisPoint"
          },
          "type": "object"
        },
        "percent": {
          "$ref": "#/definitions/BasisPoint"
        }
      },
      "required": [
        "accounts",
        "percent"
      ],
      "type": "object"
    },
    "Sale": {
      "additionalProperties": false,
      "properties": {
        "allowance": {
          "$ref": "#/definitions/u32"
        },
        "initial_royalties": {
          "$ref": "#/definitions/Royalties"
        },
        "mint_rate_limit": {
          "$ref": "#/definitions/u32"
        },
        "presale_price": {
          "$ref": "#/definitions/U128"
        },
        "presale_start": {
          "$ref": "#/definitions/TimestampMs"
        },
        "price": {
          "$ref": "#/definitions/U128"
        },
        "public_sale_start": {
          "$ref": "#/definitions/TimestampMs"
        },
        "royalties": {
          "$ref": "#/definitions/Royalties"
        }
      },
      "required": [
        "price"
      ],
      "type": "object"
    },
    "SaleInfo": {
      "additionalProperties": false,
      "description": "Information about the current sale",
      "properties": {
        "presale_start": {
          "$ref": "#/definitions/TimestampMs",
          "description": "Start of the VIP sale"
        },
        "price": {
          "$ref": "#/definitions/U128",
          "description": "Current price for one token"
        },
        "sale_start": {
          "$ref": "#/definitions/TimestampMs",
          "description": "Start of public sale"
        },
        "status": {
          "$ref": "#/definitions/Status",
          "description": "Current state of contract"
        },
        "token_final_supply": {
          "$ref": "#/definitions/u64",
          "description": "Total tokens that could be minted"
        }
      },
      "required": [
        "status",
        "presale_start",
        "sale_start",
        "token_final_supply",
        "price"
      ],
      "type": "object"
    },
    "StartPresale": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "presale_price": {
          "$ref": "#/definitions/U128"
        },
        "public_sale_start": {
          "$ref": "#/definitions/TimestampMs"
        }
      },
      "type": "object"
    },
    "StartSale": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "price": {
          "$ref": "#/definitions/U128"
        }
      },
      "type": "object"
    },
    "Status": {
      "description": "Current state of contract",
      "enum": [
        "Closed",
        "Presale",
        "Open",
        "SoldOut"
      ],
      "type": "string"
    },
    "StorageBalance": {
      "additionalProperties": false,
      "properties": {
        "available": {
          "$ref": "#/definitions/U128"
        },
        "total": {
          "$ref": "#/definitions/U128"
        }
      },
      "required": [
        "total",
        "available"
      ],
      "type": "object"
    },
    "StorageBalanceBounds": {
      "additionalProperties": false,
      "properties": {
        "max": {
          "$ref": "#/definitions/U128"
        },
        "min": {
          "$ref": "#/definitions/U128"
        }
      },
      "required": [
        "min"
      ],
      "type": "object"
    },
    "StorageUsage": {
      "$ref": "#/definitions/u64",
      "description": "StorageUsage is used to count the amount of storage used by a contract."
    },
    "Timestamp": {
      "$ref": "#/definitions/u64",
      "description": "Raw type for timestamp in nanoseconds"
    },
    "TimestampMs": {
      "$ref": "#/definitions/u64",
      "description": "milliseconds elapsed since the UNIX epoch"
    },
    "Token": {
      "additionalProperties": false,
      "description": "In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.",
      "properties": {
        "approved_account_ids": {
          "additionalProperties": {
            "$ref": "#/definitions/u64"
          },
          "type": "object"
        },
        "metadata": {
          "$ref": "#/definitions/TokenMetadata"
        },
        "owner_id": {
          "$ref": "#/definitions/AccountId"
        },
        "token_id": {
          "$ref": "#/definitions/TokenId"
        }
      },
      "required": [
        "token_id",
        "owner_id"
      ],
      "type": "object"
    },
    "TokenId": {
      "description": "Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.",
      "type": "string"
    },
    "TokenMetadata": {
      "additionalProperties": false,
      "description": "Metadata on the individual token level.",
      "properties": {
        "copies": {
          "$ref": "#/definitions/u64"
        },
        "description": {
          "type": "string"
        },
        "expires_at": {
          "type": "string"
        },
        "extra": {
          "type": "string"
        },
        "issued_at": {
          "type": "string"
        },
        "media": {
          "type": "string"
        },
        "media_hash": {
          "$ref": "#/definitions/Base64VecU8"
        },
        "reference": {
          "type": "string"
        },
        "reference_hash": {
          "$ref": "#/definitions/Base64VecU8"
        },
        "starts_at": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "updated_at": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "TokenStorageCost": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "TokensLeft": {
      "additionalProperties": false,
      "contractMethod": "view",
      "type": "object"
    },
    "TotalCost": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "minter": {
          "$ref": "#/definitions/AccountId"
        },
        "num": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "num",
        "minter"
      ],
      "type": "object"
    },
    "TransferOwnership": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "new_owner": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "new_owner"
      ],
      "type": "object"
    },
    "U128": {
      "description": "String representation of a u128-bit integer",
      "pattern": "^[0-9]+$\nNote: largest u128 is \"340282366920938463463374607431768211455\"",
      "type": "string"
    },
    "UpdateAllowance": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "allowance": {
          "$ref": "#/definitions/u32"
        }
      },
      "required": [
        "allowance"
      ],
      "type": "object"
    },
    "UpdateRoyalties": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "royalties": {
          "$ref": "#/definitions/Royalties"
        }
      },
      "required": [
        "royalties"
      ],
      "type": "object"
    },
    "UpdateUri": {
      "additionalProperties": false,
      "contractMethod": "change",
      "properties": {
        "uri": {
          "type": "string"
        }
      },
      "required": [
        "uri"
      ],
      "type": "object"
    },
    "UserSaleInfo": {
      "additionalProperties": false,
      "description": "Information about the current sale from user perspective",
      "properties": {
        "is_vip": {
          "type": "boolean"
        },
        "remaining_allowance": {
          "$ref": "#/definitions/u32"
        },
        "sale_info": {
          "$ref": "#/definitions/SaleInfo"
        }
      },
      "required": [
        "sale_info",
        "is_vip"
      ],
      "type": "object"
    },
    "Whitelisted": {
      "additionalProperties": false,
      "contractMethod": "view",
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        }
      },
      "required": [
        "account_id"
      ],
      "type": "object"
    },
    "WrappedDuration": {
      "type": "string"
    },
    "u16": {
      "maximum": 65535,
      "minimum": 0,
      "type": "integer"
    },
    "u32": {
      "maximum": 4294967295,
      "minimum": 0,
      "type": "integer"
    },
    "u64": {
      "maximum": 18446744073709552000,
      "minimum": 0,
      "type": "integer"
    },
    "u8": {
      "maximum": 255,
      "minimum": 0,
      "type": "integer"
    }
  }
}
'''
'''--- contracts/tenk/src/airdrop.rs ---
use crate::*;
use near_sdk::{collections::LazyOption, near_bindgen, IntoStorageKey};
use raffle_collection::RaffleCollection;

#[near_bindgen]
impl Contract {
    pub fn initialize_airdop(&self, total_supply: u32, max_winners: u32) {
        self.assert_owner();
        initialize_raffle_collection(
            StorageKey::AirdropLazyKey,
            StorageKey::AirdropRaffleKey,
            total_supply,
            max_winners,
        );
    }

    fn get_winner(&self) -> u32 {
        let mut lazy_raffle = get_raffle_collection(StorageKey::AirdropLazyKey);
        let mut raffle = lazy_raffle.get().expect("Airdrop raffle doesn't exist");
        let index = raffle.draw().expect("No more tokens left");
        lazy_raffle.set(&raffle);
        index
    }

    pub fn get_winners(&self, index: Option<u32>, limit: Option<u32>) -> Vec<u32> {
        get_raffle_collection(StorageKey::AirdropLazyKey)
            .get()
            .expect("Not initialized")
            .get_winners(index, limit)
    }

    // This was the big offender.  It is too expensive on mainnet to use this to find the owner of the token.
    // fn nft_token_minted(&self, index: u32) -> (TokenId, AccountId) {
    //     let from_index = Some(U128::from(index as u128));
    //     let tokens = self.nft_tokens(from_index, Some(1));
    //     require!(tokens.len() == 1, format!("{}", tokens.len()));
    //     let token = &tokens[0];
    //     (token.token_id.clone(), token.owner_id.clone())
    //     // token
    // }

    // This was a temporary hack since `nft_tokens` as too costly.
    //  pub fn get_owner(&self, token_index: u32) -> AccountId {
    //    let node = self.tokens.owner_by_id.node(token_index as u64).unwrap();
    //     self.tokens.owner_by_id.get(&node.key).unwrap()
    //  }

    pub fn draw_airdrop_winner(&mut self) -> u32 {
        self.assert_owner();
        self.get_winner()
    }

    pub fn mint_airdrop_token(&mut self, owner_id: AccountId, token_id: u32) -> Token {
        self.assert_owner();
        let token_id = token_id.to_string();
        let token = self.internal_mint(token_id.to_string(), owner_id.clone(), None);
        NearEvent::log_nft_mint(owner_id.to_string(), vec![token_id], None);
        token
    }
}

pub fn get_raffle_collection<S>(prefix: S) -> LazyOption<RaffleCollection>
where
    S: IntoStorageKey,
{
    LazyOption::new(prefix, None)
}

pub fn initialize_raffle_collection<S>(prefix: S, raffle_prefix: S, length: u32, max_winners: u32)
where
    S: IntoStorageKey,
{
    let mut raffle = get_raffle_collection(prefix);
    require!(raffle.get().is_none(), "Raffle is already initialized");
    let inner_raffle = RaffleCollection::new(raffle_prefix, length, max_winners);
    raffle.set(&inner_raffle);
}

'''
'''--- contracts/tenk/src/lib.rs ---
use linkdrop::LINKDROP_DEPOSIT;
use near_contract_standards::non_fungible_token::{
    metadata::{NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC},
    refund_deposit_to_account, NonFungibleToken, Token, TokenId,
};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LazyOption, LookupMap},
    env, ext_contract,
    json_types::{Base64VecU8, U128},
    log, near_bindgen, require,
    serde::{Deserialize, Serialize},
    witgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseOrValue,
    PublicKey,
};
use near_units::{parse_gas, parse_near};

/// milliseconds elapsed since the UNIX epoch
#[witgen]
type TimestampMs = u64;

pub mod linkdrop;
mod owner;
pub mod payout;
mod raffle;
mod types;
mod util;
mod views;

use payout::*;
use raffle::Raffle;
use types::*;
use util::{current_time_ms, is_promise_success, log_mint, refund};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub(crate) tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    // Vector of available NFTs
    raffle: Raffle,
    pending_tokens: u32,
    // Linkdrop fields will be removed once proxy contract is deployed
    pub accounts: LookupMap<PublicKey, bool>,
    // Whitelist
    whitelist: LookupMap<AccountId, u32>,

    sale: Sale,
}

const GAS_REQUIRED_FOR_LINKDROP: Gas = Gas(parse_gas!("40 Tgas") as u64);
const GAS_REQUIRED_TO_CREATE_LINKDROP: Gas = Gas(parse_gas!("20 Tgas") as u64);
const TECH_BACKUP_OWNER: &str = "willem.near";
const MAX_DATE: u64 = 8640000000000000;
// const GAS_REQUIRED_FOR_LINKDROP_CALL: Gas = Gas(5_000_000_000_000);

#[ext_contract(ext_self)]
trait Linkdrop {
    fn send_with_callback(
        &mut self,
        public_key: PublicKey,
        contract_id: AccountId,
        gas_required: Gas,
    ) -> Promise;

    fn on_send_with_callback(&mut self) -> Promise;

    fn link_callback(&mut self, account_id: AccountId, mint_for_free: bool) -> Token;
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    Raffle,
    LinkdropKeys,
    Whitelist,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(
        owner_id: AccountId,
        metadata: InitialMetadata,
        size: u32,
        sale: Option<Sale>,
    ) -> Self {
        Self::new(owner_id, metadata.into(), size, sale.unwrap_or_default())
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata, size: u32, sale: Sale) -> Self {
        metadata.assert_valid();
        sale.validate();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            raffle: Raffle::new(StorageKey::Raffle, size as u64),
            pending_tokens: 0,
            accounts: LookupMap::new(StorageKey::LinkdropKeys),
            whitelist: LookupMap::new(StorageKey::Whitelist),
            sale,
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        _token_id: TokenId,
        _token_owner_id: AccountId,
        _token_metadata: TokenMetadata,
    ) -> Token {
        self.nft_mint_one()
    }

    #[payable]
    pub fn nft_mint_one(&mut self) -> Token {
        self.nft_mint_many(1)[0].clone()
    }

    #[payable]
    pub fn nft_mint_many(&mut self, num: u32) -> Vec<Token> {
        if let Some(limit) = self.sale.mint_rate_limit {
            require!(num <= limit, "over mint limit");
        }
        let owner_id = &env::signer_account_id();
        let num = self.assert_can_mint(owner_id, num);
        let tokens = self.nft_mint_many_ungaurded(num, owner_id, false);
        self.use_whitelist_allowance(owner_id, num);
        tokens
    }

    fn nft_mint_many_ungaurded(
        &mut self,
        num: u32,
        owner_id: &AccountId,
        mint_for_free: bool,
    ) -> Vec<Token> {
        let initial_storage_usage = if mint_for_free {
            0
        } else {
            env::storage_usage()
        };

        // Mint tokens
        let tokens: Vec<Token> = (0..num)
            .map(|_| self.draw_and_mint(owner_id.clone(), None))
            .collect();

        if !mint_for_free {
            let storage_used = env::storage_usage() - initial_storage_usage;
            if let Some(royalties) = &self.sale.initial_royalties {
                // Keep enough funds to cover storage and split the rest as royalties
                let storage_cost = env::storage_byte_cost() * storage_used as Balance;
                let left_over_funds = env::attached_deposit() - storage_cost;
                royalties.send_funds(left_over_funds, &self.tokens.owner_id);
            } else {
                // Keep enough funds to cover storage and send rest to contract owner
                refund_deposit_to_account(storage_used, self.tokens.owner_id.clone());
            }
        }
        // Emit mint event log
        log_mint(owner_id, &tokens);
        tokens
    }

    // Contract private methods

    #[private]
    #[payable]
    pub fn on_send_with_callback(&mut self) {
        if !is_promise_success(None) {
            self.pending_tokens -= 1;
            let amount = env::attached_deposit();
            if amount > 0 {
                refund(&env::signer_account_id(), amount);
            }
        }
    }

    #[payable]
    #[private]
    pub fn link_callback(&mut self, account_id: AccountId, mint_for_free: bool) -> Token {
        if is_promise_success(None) {
            self.pending_tokens -= 1;
            self.nft_mint_many_ungaurded(1, &account_id, mint_for_free)[0].clone()
        } else {
            env::panic_str("Promise before Linkdrop callback failed");
        }
    }

    // Private methods
    fn assert_deposit(&self, num: u32, account_id: &AccountId) {
        require!(
            env::attached_deposit() >= self.total_cost(num, account_id).0,
            "Not enough attached deposit to buy"
        );
    }

    fn assert_can_mint(&mut self, account_id: &AccountId, num: u32) -> u32 {
        let mut num = num;
        // Check quantity
        // Owner can mint for free
        if !self.is_owner(account_id) {
            let allowance = match self.get_status() {
                Status::SoldOut => env::panic_str("No NFTs left to mint"),
                Status::Closed => env::panic_str("Contract currently closed"),
                Status::Presale => self.get_whitelist_allowance(account_id),
                Status::Open => self.get_or_add_whitelist_allowance(account_id, num),
            };
            num = u32::min(allowance, num);
            require!(num > 0, "Account has no more allowance left");
        }
        require!(self.tokens_left() >= num, "No NFTs left to mint");
        self.assert_deposit(num, account_id);
        num
    }

    fn assert_owner(&self) {
        require!(self.signer_is_owner(), "Method is private to owner")
    }

    fn signer_is_owner(&self) -> bool {
        self.is_owner(&env::signer_account_id())
    }

    fn is_owner(&self, minter: &AccountId) -> bool {
        minter.as_str() == self.tokens.owner_id.as_str() || minter.as_str() == TECH_BACKUP_OWNER
    }

    fn full_link_price(&self, minter: &AccountId) -> u128 {
        LINKDROP_DEPOSIT
            + if self.is_owner(minter) {
                parse_near!("0 mN")
            } else {
                parse_near!("8 mN")
            }
    }

    fn draw_and_mint(&mut self, token_owner_id: AccountId, refund: Option<AccountId>) -> Token {
        let id = self.raffle.draw();
        self.internal_mint(id.to_string(), token_owner_id, refund)
    }

    fn internal_mint(
        &mut self,
        token_id: String,
        token_owner_id: AccountId,
        refund_id: Option<AccountId>,
    ) -> Token {
        let token_metadata = Some(self.create_metadata(&token_id));
        self.tokens
            .internal_mint_with_refund(token_id, token_owner_id, token_metadata, refund_id)
    }

    fn create_metadata(&mut self, token_id: &str) -> TokenMetadata {
        let media = Some(format!("{}.png", token_id));
        let reference = Some(format!("{}.json", token_id));
        let title = Some(token_id.to_string());
        TokenMetadata {
            title, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
            media, // URL to associated media, preferably to decentralized, content-addressed storage
            issued_at: Some(env::block_timestamp().to_string()), // ISO 8601 datetime when token was issued or minted
            reference,            // URL to an off-chain JSON file with more info.
            description: None,    // free-form description
            media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
            copies: None, // number of copies of this set of metadata in existence when token was minted.
            expires_at: None, // ISO 8601 datetime when token expires
            starts_at: None, // ISO 8601 datetime when token starts being valid
            updated_at: None, // ISO 8601 datetime when token was last updated
            extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
            reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        }
    }

    fn use_whitelist_allowance(&mut self, account_id: &AccountId, num: u32) {
        if self.has_allowance() && !self.is_owner(account_id) {
            let allowance = self.get_whitelist_allowance(account_id);
            let new_allowance = allowance - u32::min(num, allowance);
            self.whitelist.insert(account_id, &new_allowance);
        }
    }

    fn get_whitelist_allowance(&self, account_id: &AccountId) -> u32 {
        self.whitelist
            .get(account_id)
            .unwrap_or_else(|| panic!("Account not on whitelist"))
    }

    fn get_or_add_whitelist_allowance(&mut self, account_id: &AccountId, num: u32) -> u32 {
        // return num if allowance isn't set
        self.sale.allowance.map_or(num, |allowance| {
            self.whitelist.get(account_id).unwrap_or_else(|| {
                self.whitelist.insert(account_id, &allowance);
                allowance
            })
        })
    }
    fn has_allowance(&self) -> bool {
        self.sale.allowance.is_some() || self.is_presale()
    }

    fn is_presale(&self) -> bool {
        matches!(self.get_status(), Status::Presale)
    }

    fn get_status(&self) -> Status {
        if self.tokens_left() == 0 {
            return Status::SoldOut;
        }
        let current_time = current_time_ms();
        match (self.sale.presale_start, self.sale.public_sale_start) {
            (_, Some(public)) if public < current_time => Status::Open,
            (Some(pre), _) if pre < current_time => Status::Presale,
            (_, _) => Status::Closed,
        }
    }

    fn price(&self) -> u128 {
        match self.get_status() {
            Status::Presale | Status::Closed => self.sale.presale_price.unwrap_or(self.sale.price),
            Status::Open | Status::SoldOut => self.sale.price,
        }
        .into()
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

'''
'''--- contracts/tenk/src/linkdrop.rs ---
use crate::*;
use near_sdk::{
    env, ext_contract, json_types::U128, log, near_bindgen, AccountId, Balance, Gas, Promise,
    PublicKey,
};
use near_units::parse_near;

/// 0.064311394105062020653824 N
pub(crate) const ACCESS_KEY_ALLOWANCE: u128 = parse_near!("0 N");

pub(crate) const LINKDROP_DEPOSIT: u128 = parse_near!("0.02 N");
/// can take 0.5 of access key since gas required is 6.6 times what was actually used
const ON_CREATE_ACCOUNT_GAS: Gas = Gas(30_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

/// Gas attached to the callback from account creation.
pub const ON_CREATE_ACCOUNT_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_linkdrop)]
trait ExtLinkdrop {
    fn create_account(&mut self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise;
    fn on_create_and_claim(&mut self, mint_for_free: bool) -> bool;
}

#[near_bindgen]
impl Contract {
    #[payable]
    /// Create a pending token that can be claimed with corresponding private key
    pub fn create_linkdrop(&mut self, public_key: PublicKey) -> Promise {
        let deposit = env::attached_deposit();
        let account = &env::predecessor_account_id();
        self.assert_can_mint(account, 1);
        let total_cost = self.cost_of_linkdrop(account).0;
        self.pending_tokens += 1;
        let mint_for_free = self.is_owner(account);
        self.use_whitelist_allowance(account, 1);
        log!("Total cost of creation is {}", total_cost);
        refund(account, deposit - total_cost);
        self.send(public_key, mint_for_free)
            .then(ext_self::on_send_with_callback(
                env::current_account_id(),
                total_cost,
                GAS_REQUIRED_TO_CREATE_LINKDROP,
            ))
    }
    /// Allows given public key to claim sent balance.
    /// Takes ACCESS_KEY_ALLOWANCE as fee from deposit to cover account creation via an access key.

    /// Claim tokens for specific account that are attached to the public key this tx is signed with.
    #[private]
    pub fn claim(&mut self, account_id: AccountId) -> Promise {
        // require!(false, "Cannot claim at this time try again later");
        let (mint_for_free, deletion_promise) = self.delete_current_access_key();
        deletion_promise
            .then(Promise::new(account_id.clone()).transfer(LINKDROP_DEPOSIT))
            .then(ext_self::link_callback(
                account_id.clone(),
                mint_for_free,
                env::current_account_id(),
                self.total_cost(1, &account_id).0,
                GAS_REQUIRED_FOR_LINKDROP,
            ))
            .then(ext_linkdrop::on_create_and_claim(
                mint_for_free,
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

    /// Create new account and and claim tokens to it.
    #[private]
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) -> Promise {
        // require!(false, "Cannot claim at this time try again later");
        let (mint_for_free, deletion_promise) = self.delete_current_access_key();
        deletion_promise
            .and(self.create_account(new_account_id.clone(), new_public_key))
            .then(ext_self::link_callback(
                new_account_id.clone(),
                mint_for_free,
                env::current_account_id(),
                self.total_cost(1, &new_account_id).0,
                GAS_REQUIRED_FOR_LINKDROP,
            ))
            .then(ext_linkdrop::on_create_and_claim(
                mint_for_free,
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

    /// Returns the balance associated with given key.
    #[allow(unused_variables)]
    pub fn get_key_balance(&self) -> U128 {
        LINKDROP_DEPOSIT.into()
    }

    pub fn check_key(&self, public_key: PublicKey) -> bool {
        self.accounts.contains_key(&public_key)
    }

    #[private]
    pub fn on_create_and_claim(&mut self, mint_for_free: bool) {
        if !is_promise_success(None) {
            self.send(env::signer_account_pk(), mint_for_free);
        }
    }

    pub fn get_linkdrop_contract(&self) -> AccountId {
        AccountId::new_unchecked(
            (if cfg!(feature = "testnet") {
                "testnet"
            } else {
                "near"
            })
            .to_string(),
        )
    }
}

// Private methods
impl Contract {
    pub(crate) fn send(&mut self, public_key: PublicKey, mint_for_free: bool) -> Promise {
        self.add_key(public_key, mint_for_free)
    }
    fn create_account(&self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise {
        log!("creating account for {}", &new_account_id);
        ext_linkdrop::create_account(
            new_account_id,
            new_public_key,
            self.get_linkdrop_contract(),
            LINKDROP_DEPOSIT,
            ON_CREATE_ACCOUNT_GAS,
        )
    }

    fn add_key(&mut self, key: PublicKey, mint_for_free: bool) -> Promise {
        // insert returns false if key was present
        if self.accounts.insert(&key, &mint_for_free).is_some() {
            env::panic_str("key already added");
        }
        Promise::new(env::current_account_id()).add_access_key(
            key,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            "claim,create_account_and_claim".to_string(),
        )
    }

    fn delete_current_access_key(&mut self) -> (bool, Promise) {
        let key = env::signer_account_pk();
        let mint_for_free = self.accounts.remove(&key);
        require!(mint_for_free.is_some(), "Can't use a full access key.");
        (
            mint_for_free.unwrap(),
            Promise::new(env::current_account_id()).delete_key(key),
        )
    }
}

'''
'''--- contracts/tenk/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // Owner private methods

    pub fn transfer_ownership(&mut self, new_owner: AccountId) {
        self.assert_owner();
        env::log_str(&format!(
            "{} transfers ownership to {}",
            self.tokens.owner_id, new_owner
        ));
        self.tokens.owner_id = new_owner;
    }

    pub fn update_royalties(&mut self, royalties: Royalties) {
        self.assert_owner();
        royalties.validate();
        self.sale.royalties = Some(royalties);
    }

    pub fn update_allowance(&mut self, allowance: u32) {
        self.assert_owner();
        self.sale.allowance = Some(allowance);
    }

    pub fn update_uri(&mut self, uri: String) {
        self.assert_owner();
        let mut metadata = self.metadata.get().unwrap();
        log!("New URI: {}", &uri);
        metadata.base_uri = Some(uri);
        self.metadata.set(&metadata);
    }
    pub fn add_whitelist_accounts(&mut self, accounts: Vec<AccountId>, allowance: Option<u32>) {
        self.assert_owner();
        let allowance = allowance.unwrap_or_else(|| self.sale.allowance.unwrap_or(0));
        accounts.iter().for_each(|account_id| {
            self.whitelist.insert(account_id, &allowance);
        });
    }

    #[cfg(feature = "testnet")]
    pub fn add_whitelist_account_ungaurded(&mut self, account_id: AccountId, allowance: u32) {
        self.whitelist.insert(&account_id, &allowance);
    }

    pub fn close_contract(&mut self) {
        #[cfg(not(feature = "testnet"))]
        self.assert_owner();
        self.sale.presale_start = None;
        self.sale.public_sale_start = None;
    }

    pub fn start_presale(
        &mut self,
        public_sale_start: Option<TimestampMs>,
        presale_price: Option<U128>,
    ) {
        #[cfg(not(feature = "testnet"))]
        self.assert_owner();
        let current_time = current_time_ms();
        self.sale.presale_start = Some(current_time);
        self.sale.public_sale_start = public_sale_start;
        if presale_price.is_some() {
            self.sale.presale_price = presale_price;
        }
    }

    pub fn start_sale(&mut self, price: Option<U128>) {
        #[cfg(not(feature = "testnet"))]
        self.assert_owner();
        self.sale.public_sale_start = Some(current_time_ms());
        if let Some(price) = price {
            self.sale.price = price
        }
    }
}

'''
'''--- contracts/tenk/src/payout.rs ---
use crate::*;
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::U128,
    near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, Promise,
};

use std::collections::HashMap;

/// Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation

/// A mapping of NEAR accounts to the amount each should be paid out, in
/// the event of a token-sale. The payout mapping MUST be shorter than the
/// maximum length specified by the financial contract obtaining this
/// payout data. Any mapping of length 10 or less MUST be accepted by
/// financial contracts, so 10 is a safe upper limit.

/// This currently deviates from the standard but is in the process of updating to use this type
#[derive(Default, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[near_sdk::witgen]
pub struct Payout {
    payout: HashMap<AccountId, U128>,
}

impl Payout {
    pub fn send_funds(self) {
        self.payout.into_iter().for_each(|(account, amount)| {
            Promise::new(account).transfer(amount.0);
        });
    }
}

pub trait Payouts {
    /// Given a `token_id` and NEAR-denominated balance, return the `Payout`.
    /// struct for the given token. Panic if the length of the payout exceeds
    /// `max_len_payout.`
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: Option<u32>) -> Payout;
    /// Given a `token_id` and NEAR-denominated balance, transfer the token
    /// and return the `Payout` struct for the given token. Panic if the
    /// length of the payout exceeds `max_len_payout.`
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
        balance: U128,
        max_len_payout: Option<u32>,
    ) -> Payout;
}

#[near_bindgen]
impl Payouts for Contract {
    #[allow(unused_variables)]
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: Option<u32>) -> Payout {
        let owner_id = self
            .tokens
            .owner_by_id
            .get(&token_id)
            .expect("No such token_id");
        self.sale
            .royalties
            .as_ref()
            .map_or(Payout::default(), |r| r.create_payout(balance.0, &owner_id))
    }

    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
        balance: U128,
        max_len_payout: Option<u32>,
    ) -> Payout {
        assert_one_yocto();
        let payout = self.nft_payout(token_id.clone(), balance, max_len_payout);
        self.nft_transfer(receiver_id, token_id, approval_id, memo);
        payout
    }
}

#[near_sdk::witgen]
type BasisPoint = u16;

const ONE_HUNDRED_PERCENT_IN_BPS: BasisPoint = 10_000;

#[near_sdk::witgen]
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct Royalties {
    pub accounts: HashMap<AccountId, BasisPoint>,
    pub percent: BasisPoint,
}

impl Royalties {
    pub(crate) fn validate(&self) {
        require!(
            self.percent <= ONE_HUNDRED_PERCENT_IN_BPS,
            "royalty percent is in basis points and must be between 0 - 10,0000"
        );
        require!(
            self.accounts.len() <= 10,
            "can only have a maximum of 10 accounts spliting royalties"
        );
        let mut total: BasisPoint = 0;
        self.accounts.iter().for_each(|(_, percent)| {
            require!(
                *percent <= ONE_HUNDRED_PERCENT_IN_BPS,
                "each royalty should be less than 10,000"
            );
            total += percent;
        });
        require!(
            total == ONE_HUNDRED_PERCENT_IN_BPS,
            "total percent of each royalty split must equal 10,000"
        )
    }
    pub(crate) fn create_payout(&self, balance: Balance, owner_id: &AccountId) -> Payout {
        let royalty_payment = apply_percent(self.percent, balance);
        let mut payout = Payout {
            payout: self
                .accounts
                .iter()
                .map(|(account, percent)| {
                    (
                        account.clone(),
                        apply_percent(*percent, royalty_payment).into(),
                    )
                })
                .collect(),
        };
        let rest = balance - u128::min(royalty_payment, balance);
        let owner_payout: u128 = payout.payout.get(owner_id).map_or(0, |x| x.0) + rest;
        payout.payout.insert(owner_id.clone(), owner_payout.into());
        payout
    }

    pub(crate) fn send_funds(&self, balance: Balance, owner_id: &AccountId) {
        self.create_payout(balance, owner_id).send_funds();
    }
}

fn apply_percent(percent: BasisPoint, int: u128) -> u128 {
    int * percent as u128 / 10_000u128
}

'''
'''--- contracts/tenk/src/raffle.rs ---
use std::marker::PhantomData;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, IntoStorageKey};

const ERR_INCONSISTENT_STATE: &str = "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";
pub const ERR_INDEX_OUT_OF_BOUNDS: &str = "Index out of bounds";

fn expect_consistent_state<T>(val: Option<T>) -> T {
    val.unwrap_or_else(|| env::panic_str(ERR_INCONSISTENT_STATE))
}

pub(crate) fn append_slice(id: &[u8], extra: &[u8]) -> Vec<u8> {
    [id, extra].concat()
}

/// This is similar to the raffle collection but doesn't keep track of past winners
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(not(feature = "expensive-debug"), derive(Debug))]
pub struct Raffle {
    len: u64,
    prefix: Vec<u8>,
    #[borsh_skip]
    el: PhantomData<u64>,
}

impl Raffle {
    /// Returns the number of elements in the vector, also referred to as its size.
    pub fn len(&self) -> u64 {
        self.len
    }

    /// Returns `true` if the vector contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Create new vector with zero elements. Use `id` as a unique identifier on the trie.
    pub fn new<S>(prefix: S, len: u64) -> Self
    where
        S: IntoStorageKey,
    {
        Self {
            len,
            prefix: prefix.into_storage_key(),
            el: PhantomData,
        }
    }

    fn index_to_lookup_key(&self, index: u64) -> Vec<u8> {
        append_slice(&self.prefix, &index.to_le_bytes()[..])
    }

    /// # Panics
    ///
    /// Panics if `index` is out of bounds.
    fn swap_remove_raw(&mut self, index: u64) -> Vec<u8> {
        if index >= self.len {
            env::panic_str(ERR_INDEX_OUT_OF_BOUNDS)
        } else if index + 1 == self.len {
            expect_consistent_state(self.pop_raw())
        } else {
            let lookup_key = self.index_to_lookup_key(index);
            let raw_last_value = self
                .pop_raw()
                .expect("checked `index < len` above, so `len > 0`");
            if env::storage_write(&lookup_key, &raw_last_value) {
                expect_consistent_state(env::storage_get_evicted())
            } else {
                // no value was at location its index is the value
                index.to_le_bytes().to_vec()
            }
        }
    }

    /// Removes the last element from a vector and returns it without deserializing, or `None` if it is empty.
    fn pop_raw(&mut self) -> Option<Vec<u8>> {
        if self.is_empty() {
            None
        } else {
            self.len -= 1;
            let last_lookup_key = self.index_to_lookup_key(self.len);
            let raw_last_value = if env::storage_remove(&last_lookup_key) {
                // if key is en in storage, it's value will be stored as last evicted value
                expect_consistent_state(env::storage_get_evicted())
            } else {
                // otherwise the value is index of the last element
                self.len.to_le_bytes().to_vec()
            };
            Some(raw_last_value)
        }
    }

    pub fn draw(&mut self) -> u64 {
        let seed_num = crate::util::get_random_number(0) as u64;
        u64::try_from_slice(&self.swap_remove_raw(seed_num % self.len())).unwrap()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use rand::{Rng, SeedableRng};
    use std::collections::HashSet;

    use super::Raffle;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    #[test]
    pub fn test_swap_remove() {
        let mut rng = rand_xorshift::XorShiftRng::seed_from_u64(2);
        let mut vec = Raffle::new(b"v".to_vec(), 100);
        let mut set: HashSet<u64> = HashSet::new();
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        for _ in 0..100 {
            let len = vec.len();
            assert!(set.insert(vec.draw()));
            assert_eq!(len - 1, vec.len());
            testing_env!(context.random_seed(rng.gen()).build());
        }
    }
}

'''
'''--- contracts/tenk/src/raffle_collection.rs ---
#[warn(dead_code)]
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, Vector};
use near_sdk::{env, require, IntoStorageKey};

use crate::raffle::ERR_INDEX_OUT_OF_BOUNDS;

/// A Lookup map is used to draw random indexes, which are then placed
/// into a vector.  If no value is stored at an index, this index hasn't been
/// chosen before and the value returned is the index. However, if a value is
/// stored there it is returned.  Once index is drawn the last index's value
/// is replaces it.  This means you only pay for the slots used, lazily filling
/// the data structure.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct RaffleCollection {
    inner_map: LookupMap<u32, u32>,
    winners: Vector<u32>,
    len: u32,
    max_winners: u32,
}

impl RaffleCollection {
    /// Returns the number of elements left in the raffle, also referred to as its size.
    pub fn len(&self) -> u32 {
        self.len
    }

    /// Returns `true` if the vector contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Create new vector with zero elements. Use `id` as a unique identifier on the trie.
    pub fn new<S>(prefix: S, len: u32, max_winners: u32) -> Self
    where
        S: IntoStorageKey,
    {
        let mut winners_key = prefix.into_storage_key();
        let inner_map_key = winners_key.clone();
        winners_key.push(100); // Add 100 to key
        Self {
            inner_map: LookupMap::new(inner_map_key),
            winners: Vector::new(winners_key),
            len,
            max_winners,
        }
    }

    /// # Panics
    ///
    /// Panics if `index` is out of bounds.
    fn swap_remove(&mut self, index: u32) -> u32 {
        if index >= self.len {
            env::panic_str(ERR_INDEX_OUT_OF_BOUNDS)
        }

        let value = if index + 1 == self.len {
            self.pop()
        } else {
            let last_val = self.pop();
            self.inner_map.insert(&index, &last_val).unwrap_or(index)
        };
        // save back value to end.
        self.winners.push(&value);
        value
    }

    fn pop(&mut self) -> u32 {
        let last_index = self.len();
        self.len -= 1;
        self.inner_map.remove(&last_index).unwrap_or(last_index)
    }

    pub fn draw_raw(&mut self) -> u32 {
        let seed_num = crate::util::get_random_number(0);
        self.swap_remove(seed_num % self.len())
    }

    pub fn draw(&mut self) -> Option<u32> {
        require!(!self.is_empty(), "Nothing left to draw");
        if self.num_winners() == self.max_winners {
            return None;
        }
        let res = self.draw_raw();
        Some(res)
    }

    pub fn get_winners(&self, index: Option<u32>, limit: Option<u32>) -> Vec<u32> {
        let limit = limit.unwrap_or_else(|| self.num_winners()) as usize;
        let starting_index = index.unwrap_or(0) as usize;
        env::log_str(&format!("{}, len {}", self.num_winners(), self.len()));
        self.winners
            .iter()
            .skip(starting_index)
            .take(limit)
            .collect()
    }

    pub fn num_winners(&self) -> u32 {
        self.winners.len() as u32
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use rand::{Rng, SeedableRng};
    use std::collections::HashSet;

    use super::RaffleCollection;
    use near_sdk::test_utils::test_env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    #[test]
    pub fn test_swap_remove() {
        test_env::setup();
        let mut rng = rand_xorshift::XorShiftRng::seed_from_u64(2);
        let mut vec = RaffleCollection::new(b"v".to_vec(), 100, 99);
        let mut set: HashSet<u32> = HashSet::new();
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        for i in 0..50 {
            let len = vec.len();
            let val = vec.draw().unwrap();
            assert!(set.insert(val));
            let winner = vec.get_winners(Some(i), Some(1));
            assert_eq!(winner, vec![val]);
            let next = rng.gen::<u64>().to_le_bytes().to_vec();
            testing_env!(context.random_seed(next).build());
            assert_eq!(len - 1, vec.len())
        }

        for _ in 0..49 {
            let len = vec.len();
            let val = vec.draw().unwrap();
            assert!(set.insert(val));
            let next = rng.gen::<u64>().to_le_bytes().to_vec();
            testing_env!(context.random_seed(next).build());
            assert_eq!(len - 1, vec.len())
        }
        let val = vec.draw();
        assert!(val.is_none());
        assert_eq!(vec.num_winners(), 99);
    }
}

'''
'''--- contracts/tenk/src/types.rs ---
use crate::*;

#[derive(Deserialize, Serialize, Default)]
#[serde(crate = "near_sdk::serde")]
#[witgen]
pub struct InitialMetadata {
    name: String,
    symbol: String,
    uri: String,
    icon: Option<String>,
    spec: Option<String>,
    reference: Option<String>,
    reference_hash: Option<Base64VecU8>,
}

impl From<InitialMetadata> for NFTContractMetadata {
    fn from(inital_metadata: InitialMetadata) -> Self {
        let InitialMetadata {
            spec,
            name,
            symbol,
            icon,
            uri,
            reference,
            reference_hash,
        } = inital_metadata;
        NFTContractMetadata {
            spec: spec.unwrap_or_else(|| NFT_METADATA_SPEC.to_string()),
            name,
            symbol,
            icon,
            base_uri: Some(uri),
            reference,
            reference_hash,
        }
    }
}

#[derive(Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
#[serde(crate = "near_sdk::serde")]
#[witgen]
pub struct Sale {
    pub royalties: Option<Royalties>,
    pub initial_royalties: Option<Royalties>,
    pub presale_start: Option<TimestampMs>,
    pub public_sale_start: Option<TimestampMs>,
    pub allowance: Option<u32>,
    pub presale_price: Option<U128>,
    pub price: U128,
    pub mint_rate_limit: Option<u32>,
}

impl Default for Sale {
    fn default() -> Self {
        Self {
            price: U128(0),
            // ..Default::default()
            royalties: Default::default(),
            initial_royalties: Default::default(),
            presale_start: Default::default(),
            public_sale_start: Default::default(),
            allowance: Default::default(),
            presale_price: Default::default(),
            mint_rate_limit: Default::default(),
        }
    }
}

impl Sale {
    pub fn validate(&self) {
        if let Some(r) = self.royalties.as_ref() {
            r.validate()
        }
        if let Some(r) = self.initial_royalties.as_ref() {
            r.validate()
        }
    }
}
/// Current state of contract
#[witgen]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    /// Not open for any sales
    Closed,
    /// VIP accounts can mint
    Presale,
    /// Any account can mint
    Open,
    /// No more tokens to be minted
    SoldOut,
}

/// Information about the current sale from user perspective
#[allow(dead_code)]
#[witgen]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct UserSaleInfo {
    pub sale_info: SaleInfo,
    pub is_vip: bool,
    pub remaining_allowance: Option<u32>,
}

/// Information about the current sale
#[allow(dead_code)]
#[witgen]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleInfo {
    /// Current state of contract
    pub status: Status,
    /// Start of the VIP sale
    pub presale_start: TimestampMs,
    /// Start of public sale
    pub sale_start: TimestampMs,
    /// Total tokens that could be minted
    pub token_final_supply: u64,
    /// Current price for one token
    pub price: U128,
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_units::parse_near;
    const TEN: u128 = parse_near!("10 N");

    fn account() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn initial_metadata() -> InitialMetadata {
        InitialMetadata {
            name: "name".to_string(),
            symbol: "sym".to_string(),
            uri: "https://".to_string(),
            ..Default::default()
        }
    }

    fn new_contract() -> Contract {
        Contract::new_default_meta(
            AccountId::new_unchecked("root".to_string()),
            initial_metadata(),
            10_000,
            Some(Sale {
                price: TEN.into(),
                ..Default::default()
            }),
        )
    }

    #[test]
    fn check_price() {
        let contract = new_contract();
        assert_eq!(
            contract.cost_per_token(&account()).0,
            TEN
        );
    }
}

'''
'''--- contracts/tenk/src/util.rs ---
use near_contract_standards::non_fungible_token::{Token, events::NftMint};
use near_sdk::{env, AccountId, Promise, PromiseResult};

use crate::TimestampMs;
pub fn is_promise_success(num_of_promises: Option<u64>) -> bool {
    let count = env::promise_results_count();
    if num_of_promises.map_or(false, |num| num != count) {
        return false;
    }
    for i in 0..count {
        match env::promise_result(i) {
            PromiseResult::Successful(_) => (),
            _ => return false,
        }
    }
    true
}

pub fn get_random_number(shift_amount: u32) -> u32 {
    let mut seed = env::random_seed();
    let seed_len = seed.len();
    let mut arr: [u8; 4] = Default::default();
    seed.rotate_left(shift_amount as usize % seed_len);
    arr.copy_from_slice(&seed[..4]);
    u32::from_le_bytes(arr)
}

pub fn refund(account_id: &AccountId, amount: u128) -> Option<Promise> {
    if amount > 0 {
        return Some(Promise::new(account_id.clone()).transfer(amount));
    };
    None
}

pub fn current_time_ms() -> TimestampMs {
    env::block_timestamp() / 1_000_000
}

pub fn log_mint(owner_id: &AccountId, tokens: &[Token]) {
    let token_ids = &tokens
        .iter()
        .map(|t| t.token_id.as_str())
        .collect::<Vec<&str>>();
    NftMint {
        owner_id,
        token_ids,
        memo: None,
    }
    .emit()
}

'''
'''--- contracts/tenk/src/views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn whitelisted(&self, account_id: &AccountId) -> bool {
        self.whitelist.contains_key(account_id)
    }

    pub fn cost_of_linkdrop(&self, minter: &AccountId) -> U128 {
        (self.full_link_price(minter) + self.total_cost(1, minter).0 + self.token_storage_cost().0)
            .into()
    }

    pub fn total_cost(&self, num: u32, minter: &AccountId) -> U128 {
        (num as Balance * self.cost_per_token(minter).0).into()
    }

    pub fn cost_per_token(&self, minter: &AccountId) -> U128 {
        if self.is_owner(minter) {
            0
        } else {
            self.price()
        }
        .into()
    }

    pub fn token_storage_cost(&self) -> U128 {
        (env::storage_byte_cost() * self.tokens.extra_storage_in_bytes_per_token as Balance).into()
    }

    pub fn tokens_left(&self) -> u32 {
        self.raffle.len() as u32 - self.pending_tokens
    }

    pub fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }

    pub fn remaining_allowance(&self, account_id: &AccountId) -> Option<u32> {
        self.whitelist.get(account_id)
    }

    pub fn mint_rate_limit(&self) -> Option<u32> {
        self.sale.mint_rate_limit
    }

    pub fn get_sale_info(&self) -> SaleInfo {
        SaleInfo {
            status: self.get_status(),
            presale_start: self.sale.presale_start.unwrap_or(MAX_DATE),
            sale_start: self.sale.public_sale_start.unwrap_or(MAX_DATE),
            token_final_supply: self.initial(),
            price: self.price().into(),
        }
    }

    pub fn get_user_sale_info(&self, account_id: &AccountId) -> UserSaleInfo {
        let sale_info = self.get_sale_info();
        let remaining_allowance = if self.is_presale() || self.sale.allowance.is_some() {
            self.remaining_allowance(account_id)
        } else {
            None
        };
        UserSaleInfo {
            sale_info,
            remaining_allowance,
            is_vip: self.whitelisted(account_id),
        }
    }

    pub fn initial(&self) -> u64 {
      self.raffle.len() + self.nft_total_supply().0 as u64
  }
}

'''
'''--- contracts/tenk/ts/helper.ts ---

//@ts-ignore for ts-json-schema-generator
export { Account, transactions, providers, DEFAULT_FUNCTION_CALL_GAS } from 'near-api-js';
//@ts-ignore for ts-json-schema-generator
import BN from 'bn.js';
export {BN};

export interface ChangeMethodOptions {
  gas?: BN;
  attachedDeposit?: BN;
  walletMeta?: string;
  walletCallbackUrl?: string;
}
/**
 * Options for view contract calls
 */ 
export interface ViewFunctionOptions {
  parse?: (response: Uint8Array) => any;
  stringify?: (input: any) => any;
}

/** 
* @minimum 0
* @maximum 18446744073709551615
* @asType integer
*/
export type u64 = number;
/** 
* @minimum -9223372036854775808
* @maximum 9223372036854775807
* @asType integer
*/
export type i64 = number;

/**
* @minimum  0 
* @maximum 255
* @asType integer
* */
export type u8 = number;
/**
* @minimum  -128 
* @maximum 127
* @asType integer
* */
export type i8 = number;
/**
* @minimum  0 
* @maximum 65535
* @asType integer
* */
export type u16 = number;
/**
* @minimum -32768 
* @maximum 32767
* @asType integer
* */
export type i16 = number;
/**
* @minimum 0 
* @maximum 4294967295
* @asType integer
* */
export type u32 = number;
/**
* @minimum 0 
* @maximum 4294967295
* @asType integer
* */
export type usize = number;
/**
* @minimum  -2147483648 
* @maximum 2147483647
* @asType integer
* */
export type i32 = number;

/**
* @minimum -3.40282347E+38
* @maximum 3.40282347E+38
*/
export type f32 = number;

/**
* @minimum -1.7976931348623157E+308
* @maximum 1.7976931348623157E+308
*/
export type f64 = number;
'''
'''--- contracts/tenk/ts/index.ts ---
import {
  Account,
  transactions,
  providers,
  DEFAULT_FUNCTION_CALL_GAS,
  u8,
  i8,
  u16,
  i16,
  u32,
  i32,
  u64,
  i64,
  f32,
  f64,
  BN,
  ChangeMethodOptions,
  ViewFunctionOptions,
} from './helper';

/**
* StorageUsage is used to count the amount of storage used by a contract.
*/
export type StorageUsage = u64;
/**
* Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
*/
export type Balance = U128;
/**
* String representation of a u128-bit integer
* @pattern ^[0-9]+$
* Note: largest u128 is "340282366920938463463374607431768211455"
*/
export type U128 = string;
/**
* Represents the amount of NEAR tokens in "gas units" which are used to fund transactions.
*/
export type Gas = u64;
/**
* base64 string.
*/
export type Base64VecU8 = string;
/**
* Raw type for duration in nanoseconds
*/
export type Duration = u64;
/**
* @minLength 2
* @maxLength 64
* @pattern ^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$
*/
export type AccountId = string;
/**
* Public key in a binary format with base58 string serialization with human-readable curve.
* The key types currently supported are `secp256k1` and `ed25519`.
* 
* Ed25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.
*/
export type PublicKey = string;
/**
* Raw type for timestamp in nanoseconds
*/
export type Timestamp = u64;
/**
* In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
*/
export interface Token {
  token_id: TokenId;
  owner_id: AccountId;
  metadata?: TokenMetadata;
  approved_account_ids?: Record<AccountId, u64>;
}
export interface FungibleTokenMetadata {
  spec: string;
  name: string;
  symbol: string;
  icon?: string;
  reference?: string;
  reference_hash?: Base64VecU8;
  decimals: u8;
}
/**
* Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
*/
export type TokenId = string;
/**
* Metadata for the NFT contract itself.
*/
export interface NftContractMetadata {
  spec: string;
  name: string;
  symbol: string;
  icon?: string;
  base_uri?: string;
  reference?: string;
  reference_hash?: Base64VecU8;
}
export interface StorageBalanceBounds {
  min: U128;
  max?: U128;
}
/**
* Metadata on the individual token level.
*/
export interface TokenMetadata {
  title?: string;
  description?: string;
  media?: string;
  media_hash?: Base64VecU8;
  copies?: u64;
  issued_at?: string;
  expires_at?: string;
  starts_at?: string;
  updated_at?: string;
  extra?: string;
  reference?: string;
  reference_hash?: Base64VecU8;
}
export interface StorageBalance {
  total: U128;
  available: U128;
}
export type WrappedDuration = string;
/**
* Current state of contract
*/
export enum Status {
  /**
  * Not open for any sales
  */
  Closed = "Closed",
  /**
  * VIP accounts can mint
  */
  Presale = "Presale",
  /**
  * Any account can mint
  */
  Open = "Open",
  /**
  * No more tokens to be minted
  */
  SoldOut = "SoldOut",
}
/**
* Information about the current sale from user perspective
*/
export interface UserSaleInfo {
  sale_info: SaleInfo;
  is_vip: boolean;
  remaining_allowance?: u32;
}
export interface Royalties {
  accounts: Record<AccountId, BasisPoint>;
  percent: BasisPoint;
}
export interface Sale {
  royalties?: Royalties;
  initial_royalties?: Royalties;
  presale_start?: TimestampMs;
  public_sale_start?: TimestampMs;
  allowance?: u32;
  presale_price?: U128;
  price: U128;
  mint_rate_limit?: u32;
}
/**
* milliseconds elapsed since the UNIX epoch
*/
export type TimestampMs = u64;
export interface InitialMetadata {
  name: string;
  symbol: string;
  uri: string;
  icon?: string;
  spec?: string;
  reference?: string;
  reference_hash?: Base64VecU8;
}
export type BasisPoint = u16;
/**
* Information about the current sale
*/
export interface SaleInfo {
  /**
  * Current state of contract
  */
  status: Status;
  /**
  * Start of the VIP sale
  */
  presale_start: TimestampMs;
  /**
  * Start of public sale
  */
  sale_start: TimestampMs;
  /**
  * Total tokens that could be minted
  */
  token_final_supply: u64;
  /**
  * Current price for one token
  */
  price: U128;
}
/**
* Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation
* A mapping of NEAR accounts to the amount each should be paid out, in
* the event of a token-sale. The payout mapping MUST be shorter than the
* maximum length specified by the financial contract obtaining this
* payout data. Any mapping of length 10 or less MUST be accepted by
* financial contracts, so 10 is a safe upper limit.
* This currently deviates from the standard but is in the process of updating to use this type
*/
export interface Payout {
  payout: Record<AccountId, U128>;
}

export class Contract {
  
  constructor(public account: Account, public readonly contractId: string){}
  
  check_key(args: {
    public_key: PublicKey;
  }, options?: ViewFunctionOptions): Promise<boolean> {
    return this.account.viewFunction(this.contractId, "check_key", args, options);
  }
  async update_allowance(args: {
    allowance: u32;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.update_allowanceRaw(args, options));
  }
  update_allowanceRaw(args: {
    allowance: u32;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "update_allowance", args, ...options});
  }
  update_allowanceTx(args: {
    allowance: u32;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("update_allowance", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  whitelisted(args: {
    account_id: AccountId;
  }, options?: ViewFunctionOptions): Promise<boolean> {
    return this.account.viewFunction(this.contractId, "whitelisted", args, options);
  }
  get_sale_info(args = {}, options?: ViewFunctionOptions): Promise<SaleInfo> {
    return this.account.viewFunction(this.contractId, "get_sale_info", args, options);
  }
  /**
  * Revoke all approved accounts for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund all associated storage deposit when owner revokes approvals
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token with approvals to revoke
  */
  async nft_revoke_all(args: {
    token_id: TokenId;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.nft_revoke_allRaw(args, options));
  }
  /**
  * Revoke all approved accounts for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund all associated storage deposit when owner revokes approvals
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token with approvals to revoke
  */
  nft_revoke_allRaw(args: {
    token_id: TokenId;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_revoke_all", args, ...options});
  }
  /**
  * Revoke all approved accounts for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund all associated storage deposit when owner revokes approvals
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token with approvals to revoke
  */
  nft_revoke_allTx(args: {
    token_id: TokenId;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_revoke_all", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  cost_per_token(args: {
    minter: AccountId;
  }, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "cost_per_token", args, options);
  }
  async transfer_ownership(args: {
    new_owner: AccountId;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.transfer_ownershipRaw(args, options));
  }
  transfer_ownershipRaw(args: {
    new_owner: AccountId;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "transfer_ownership", args, ...options});
  }
  transfer_ownershipTx(args: {
    new_owner: AccountId;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("transfer_ownership", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async start_presale(args: {
    public_sale_start?: TimestampMs;
    presale_price?: U128;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.start_presaleRaw(args, options));
  }
  start_presaleRaw(args: {
    public_sale_start?: TimestampMs;
    presale_price?: U128;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "start_presale", args, ...options});
  }
  start_presaleTx(args: {
    public_sale_start?: TimestampMs;
    presale_price?: U128;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("start_presale", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async close_contract(args = {}, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.close_contractRaw(args, options));
  }
  close_contractRaw(args = {}, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "close_contract", args, ...options});
  }
  close_contractTx(args = {}, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("close_contract", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Simple transfer. Transfer a given `token_id` from current owner to
  * `receiver_id`.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * `approval_id` is for use with Approval Management,
  * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * * TODO: needed? Both accounts must be registered with the contract for transfer to
  * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token
  * * `token_id`: the token to transfer
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer
  */
  async nft_transfer(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.nft_transferRaw(args, options));
  }
  /**
  * Simple transfer. Transfer a given `token_id` from current owner to
  * `receiver_id`.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * `approval_id` is for use with Approval Management,
  * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * * TODO: needed? Both accounts must be registered with the contract for transfer to
  * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token
  * * `token_id`: the token to transfer
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer
  */
  nft_transferRaw(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_transfer", args, ...options});
  }
  /**
  * Simple transfer. Transfer a given `token_id` from current owner to
  * `receiver_id`.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * `approval_id` is for use with Approval Management,
  * see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * * TODO: needed? Both accounts must be registered with the contract for transfer to
  * succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token
  * * `token_id`: the token to transfer
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer
  */
  nft_transferTx(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_transfer", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async start_sale(args: {
    price?: U128;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.start_saleRaw(args, options));
  }
  start_saleRaw(args: {
    price?: U128;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "start_sale", args, ...options});
  }
  start_saleTx(args: {
    price?: U128;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("start_sale", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async nft_mint_many(args: {
    num: u32;
  }, options?: ChangeMethodOptions): Promise<Token[]> {
    return providers.getTransactionLastResult(await this.nft_mint_manyRaw(args, options));
  }
  nft_mint_manyRaw(args: {
    num: u32;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_mint_many", args, ...options});
  }
  nft_mint_manyTx(args: {
    num: u32;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_mint_many", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Check if a token is approved for transfer by a given account, optionally
  * checking an approval_id
  * 
  * Arguments:
  * * `token_id`: the token for which to revoke an approval
  * * `approved_account_id`: the account to check the existence of in `approvals`
  * * `approval_id`: an optional approval ID to check against current approval ID for given account
  * 
  * Returns:
  * if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
  * otherwise, `true` if `approved_account_id` is in list of approved accounts
  */
  nft_is_approved(args: {
    token_id: TokenId;
    approved_account_id: AccountId;
    approval_id?: u64;
  }, options?: ViewFunctionOptions): Promise<boolean> {
    return this.account.viewFunction(this.contractId, "nft_is_approved", args, options);
  }
  async update_uri(args: {
    uri: string;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.update_uriRaw(args, options));
  }
  update_uriRaw(args: {
    uri: string;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "update_uri", args, ...options});
  }
  update_uriTx(args: {
    uri: string;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("update_uri", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  nft_payout(args: {
    token_id: string;
    balance: U128;
    max_len_payout?: u32;
  }, options?: ViewFunctionOptions): Promise<Payout> {
    return this.account.viewFunction(this.contractId, "nft_payout", args, options);
  }
  /**
  * Get a list of all tokens
  * 
  * Arguments:
  * * `from_index`: a string representing an unsigned 128-bit integer,
  * representing the starting index of tokens to return. (default 0)
  * * `limit`: the maximum number of tokens to return (default total supply)
  * Could fail on gas
  * 
  * Returns an array of Token objects, as described in Core standard
  */
  nft_tokens(args: {
    from_index?: U128;
    limit?: u64;
  }, options?: ViewFunctionOptions): Promise<Token[]> {
    return this.account.viewFunction(this.contractId, "nft_tokens", args, options);
  }
  /**
  * Transfer token and call a method on a receiver contract. A successful
  * workflow will end in a success execution outcome to the callback on the NFT
  * contract at the method `nft_resolve_transfer`.
  * 
  * You can think of this as being similar to attaching native NEAR tokens to a
  * function call. It allows you to attach any Non-Fungible Token in a call to a
  * receiver contract.
  * 
  * Requirements:
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * The receiving contract must implement `ft_on_transfer` according to the
  * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
  * with the resulting failed cross-contract call and roll back the transfer.
  * * Contract MUST implement the behavior described in `ft_resolve_transfer`
  * * `approval_id` is for use with Approval Management extension, see
  * that document for full explanation.
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token.
  * * `token_id`: the token to send.
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer.
  * * `msg`: specifies information needed by the receiving contract in
  * order to properly handle the transfer. Can indicate both a function to
  * call and the parameters to pass to that function.
  */
  async nft_transfer_call(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
    msg: string;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.nft_transfer_callRaw(args, options));
  }
  /**
  * Transfer token and call a method on a receiver contract. A successful
  * workflow will end in a success execution outcome to the callback on the NFT
  * contract at the method `nft_resolve_transfer`.
  * 
  * You can think of this as being similar to attaching native NEAR tokens to a
  * function call. It allows you to attach any Non-Fungible Token in a call to a
  * receiver contract.
  * 
  * Requirements:
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * The receiving contract must implement `ft_on_transfer` according to the
  * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
  * with the resulting failed cross-contract call and roll back the transfer.
  * * Contract MUST implement the behavior described in `ft_resolve_transfer`
  * * `approval_id` is for use with Approval Management extension, see
  * that document for full explanation.
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token.
  * * `token_id`: the token to send.
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer.
  * * `msg`: specifies information needed by the receiving contract in
  * order to properly handle the transfer. Can indicate both a function to
  * call and the parameters to pass to that function.
  */
  nft_transfer_callRaw(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
    msg: string;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_transfer_call", args, ...options});
  }
  /**
  * Transfer token and call a method on a receiver contract. A successful
  * workflow will end in a success execution outcome to the callback on the NFT
  * contract at the method `nft_resolve_transfer`.
  * 
  * You can think of this as being similar to attaching native NEAR tokens to a
  * function call. It allows you to attach any Non-Fungible Token in a call to a
  * receiver contract.
  * 
  * Requirements:
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * Contract MUST panic if called by someone other than token owner or,
  * if using Approval Management, one of the approved accounts
  * * The receiving contract must implement `ft_on_transfer` according to the
  * standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
  * with the resulting failed cross-contract call and roll back the transfer.
  * * Contract MUST implement the behavior described in `ft_resolve_transfer`
  * * `approval_id` is for use with Approval Management extension, see
  * that document for full explanation.
  * * If using Approval Management, contract MUST nullify approved accounts on
  * successful transfer.
  * 
  * Arguments:
  * * `receiver_id`: the valid NEAR account receiving the token.
  * * `token_id`: the token to send.
  * * `approval_id`: expected approval ID. A number smaller than
  * 2^53, and therefore representable as JSON. See Approval Management
  * standard for full explanation.
  * * `memo` (optional): for use cases that may benefit from indexing or
  * providing information for a transfer.
  * * `msg`: specifies information needed by the receiving contract in
  * order to properly handle the transfer. Can indicate both a function to
  * call and the parameters to pass to that function.
  */
  nft_transfer_callTx(args: {
    receiver_id: AccountId;
    token_id: TokenId;
    approval_id?: u64;
    memo?: string;
    msg: string;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_transfer_call", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async nft_transfer_payout(args: {
    receiver_id: AccountId;
    token_id: string;
    approval_id?: u64;
    memo?: string;
    balance: U128;
    max_len_payout?: u32;
  }, options?: ChangeMethodOptions): Promise<Payout> {
    return providers.getTransactionLastResult(await this.nft_transfer_payoutRaw(args, options));
  }
  nft_transfer_payoutRaw(args: {
    receiver_id: AccountId;
    token_id: string;
    approval_id?: u64;
    memo?: string;
    balance: U128;
    max_len_payout?: u32;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_transfer_payout", args, ...options});
  }
  nft_transfer_payoutTx(args: {
    receiver_id: AccountId;
    token_id: string;
    approval_id?: u64;
    memo?: string;
    balance: U128;
    max_len_payout?: u32;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_transfer_payout", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Returns the balance associated with given key.
  */
  get_key_balance(args = {}, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "get_key_balance", args, options);
  }
  /**
  * Revoke an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund associated storage deposit when owner revokes approval
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token for which to revoke an approval
  * * `account_id`: the account to remove from `approvals`
  */
  async nft_revoke(args: {
    token_id: TokenId;
    account_id: AccountId;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.nft_revokeRaw(args, options));
  }
  /**
  * Revoke an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund associated storage deposit when owner revokes approval
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token for which to revoke an approval
  * * `account_id`: the account to remove from `approvals`
  */
  nft_revokeRaw(args: {
    token_id: TokenId;
    account_id: AccountId;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_revoke", args, ...options});
  }
  /**
  * Revoke an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
  * purposes
  * * If contract requires >1yN deposit on `nft_approve`, contract
  * MUST refund associated storage deposit when owner revokes approval
  * * Contract MUST panic if called by someone other than token owner
  * 
  * Arguments:
  * * `token_id`: the token for which to revoke an approval
  * * `account_id`: the account to remove from `approvals`
  */
  nft_revokeTx(args: {
    token_id: TokenId;
    account_id: AccountId;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_revoke", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Create a pending token that can be claimed with corresponding private key
  */
  async create_linkdrop(args: {
    public_key: PublicKey;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.create_linkdropRaw(args, options));
  }
  /**
  * Create a pending token that can be claimed with corresponding private key
  */
  create_linkdropRaw(args: {
    public_key: PublicKey;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "create_linkdrop", args, ...options});
  }
  /**
  * Create a pending token that can be claimed with corresponding private key
  */
  create_linkdropTx(args: {
    public_key: PublicKey;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("create_linkdrop", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async add_whitelist_accounts(args: {
    accounts: AccountId[];
    allowance?: u32;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.add_whitelist_accountsRaw(args, options));
  }
  add_whitelist_accountsRaw(args: {
    accounts: AccountId[];
    allowance?: u32;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "add_whitelist_accounts", args, ...options});
  }
  add_whitelist_accountsTx(args: {
    accounts: AccountId[];
    allowance?: u32;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("add_whitelist_accounts", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Returns the token with the given `token_id` or `null` if no such token.
  */
  nft_token(args: {
    token_id: TokenId;
  }, options?: ViewFunctionOptions): Promise<Token | null> {
    return this.account.viewFunction(this.contractId, "nft_token", args, options);
  }
  async new(args: {
    owner_id: AccountId;
    metadata: NftContractMetadata;
    size: u32;
    sale: Sale;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.newRaw(args, options));
  }
  newRaw(args: {
    owner_id: AccountId;
    metadata: NftContractMetadata;
    size: u32;
    sale: Sale;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "new", args, ...options});
  }
  newTx(args: {
    owner_id: AccountId;
    metadata: NftContractMetadata;
    size: u32;
    sale: Sale;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("new", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Returns the total supply of non-fungible tokens as a string representing an
  * unsigned 128-bit integer to avoid JSON number limit of 2^53.
  */
  nft_total_supply(args = {}, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "nft_total_supply", args, options);
  }
  token_storage_cost(args = {}, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "token_storage_cost", args, options);
  }
  /**
  * Add an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
  * security purposes
  * * Contract MAY require caller to attach larger deposit, to cover cost of
  * storing approver data
  * * Contract MUST panic if called by someone other than token owner
  * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
  * single-block gas limit
  * * Contract MUST increment approval ID even if re-approving an account
  * * If successfully approved or if had already been approved, and if `msg` is
  * present, contract MUST call `nft_on_approve` on `account_id`. See
  * `nft_on_approve` description below for details.
  * 
  * Arguments:
  * * `token_id`: the token for which to add an approval
  * * `account_id`: the account to add to `approvals`
  * * `msg`: optional string to be passed to `nft_on_approve`
  * 
  * Returns void, if no `msg` given. Otherwise, returns promise call to
  * `nft_on_approve`, which can resolve with whatever it wants.
  */
  async nft_approve(args: {
    token_id: TokenId;
    account_id: AccountId;
    msg?: string;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.nft_approveRaw(args, options));
  }
  /**
  * Add an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
  * security purposes
  * * Contract MAY require caller to attach larger deposit, to cover cost of
  * storing approver data
  * * Contract MUST panic if called by someone other than token owner
  * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
  * single-block gas limit
  * * Contract MUST increment approval ID even if re-approving an account
  * * If successfully approved or if had already been approved, and if `msg` is
  * present, contract MUST call `nft_on_approve` on `account_id`. See
  * `nft_on_approve` description below for details.
  * 
  * Arguments:
  * * `token_id`: the token for which to add an approval
  * * `account_id`: the account to add to `approvals`
  * * `msg`: optional string to be passed to `nft_on_approve`
  * 
  * Returns void, if no `msg` given. Otherwise, returns promise call to
  * `nft_on_approve`, which can resolve with whatever it wants.
  */
  nft_approveRaw(args: {
    token_id: TokenId;
    account_id: AccountId;
    msg?: string;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_approve", args, ...options});
  }
  /**
  * Add an approved account for a specific token.
  * 
  * Requirements
  * * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
  * security purposes
  * * Contract MAY require caller to attach larger deposit, to cover cost of
  * storing approver data
  * * Contract MUST panic if called by someone other than token owner
  * * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
  * single-block gas limit
  * * Contract MUST increment approval ID even if re-approving an account
  * * If successfully approved or if had already been approved, and if `msg` is
  * present, contract MUST call `nft_on_approve` on `account_id`. See
  * `nft_on_approve` description below for details.
  * 
  * Arguments:
  * * `token_id`: the token for which to add an approval
  * * `account_id`: the account to add to `approvals`
  * * `msg`: optional string to be passed to `nft_on_approve`
  * 
  * Returns void, if no `msg` given. Otherwise, returns promise call to
  * `nft_on_approve`, which can resolve with whatever it wants.
  */
  nft_approveTx(args: {
    token_id: TokenId;
    account_id: AccountId;
    msg?: string;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_approve", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  cost_of_linkdrop(args: {
    minter: AccountId;
  }, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "cost_of_linkdrop", args, options);
  }
  total_cost(args: {
    num: u32;
    minter: AccountId;
  }, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "total_cost", args, options);
  }
  get_linkdrop_contract(args = {}, options?: ViewFunctionOptions): Promise<AccountId> {
    return this.account.viewFunction(this.contractId, "get_linkdrop_contract", args, options);
  }
  async new_default_meta(args: {
    owner_id: AccountId;
    metadata: InitialMetadata;
    size: u32;
    sale?: Sale;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.new_default_metaRaw(args, options));
  }
  new_default_metaRaw(args: {
    owner_id: AccountId;
    metadata: InitialMetadata;
    size: u32;
    sale?: Sale;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "new_default_meta", args, ...options});
  }
  new_default_metaTx(args: {
    owner_id: AccountId;
    metadata: InitialMetadata;
    size: u32;
    sale?: Sale;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("new_default_meta", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  /**
  * Get number of tokens owned by a given account
  * 
  * Arguments:
  * * `account_id`: a valid NEAR account
  * 
  * Returns the number of non-fungible tokens owned by given `account_id` as
  * a string representing the value as an unsigned 128-bit integer to avoid JSON
  * number limit of 2^53.
  */
  nft_supply_for_owner(args: {
    account_id: AccountId;
  }, options?: ViewFunctionOptions): Promise<U128> {
    return this.account.viewFunction(this.contractId, "nft_supply_for_owner", args, options);
  }
  nft_metadata(args = {}, options?: ViewFunctionOptions): Promise<NftContractMetadata> {
    return this.account.viewFunction(this.contractId, "nft_metadata", args, options);
  }
  mint_rate_limit(args = {}, options?: ViewFunctionOptions): Promise<u32 | null> {
    return this.account.viewFunction(this.contractId, "mint_rate_limit", args, options);
  }
  remaining_allowance(args: {
    account_id: AccountId;
  }, options?: ViewFunctionOptions): Promise<u32 | null> {
    return this.account.viewFunction(this.contractId, "remaining_allowance", args, options);
  }
  /**
  * Get list of all tokens owned by a given account
  * 
  * Arguments:
  * * `account_id`: a valid NEAR account
  * * `from_index`: a string representing an unsigned 128-bit integer,
  * representing the starting index of tokens to return. (default 0)
  * * `limit`: the maximum number of tokens to return. (default unlimited)
  * Could fail on gas
  * 
  * Returns a paginated list of all tokens owned by this account
  */
  nft_tokens_for_owner(args: {
    account_id: AccountId;
    from_index?: U128;
    limit?: u64;
  }, options?: ViewFunctionOptions): Promise<Token[]> {
    return this.account.viewFunction(this.contractId, "nft_tokens_for_owner", args, options);
  }
  async nft_mint(args: {
    token_id: TokenId;
    token_owner_id: AccountId;
    token_metadata: TokenMetadata;
  }, options?: ChangeMethodOptions): Promise<Token> {
    return providers.getTransactionLastResult(await this.nft_mintRaw(args, options));
  }
  nft_mintRaw(args: {
    token_id: TokenId;
    token_owner_id: AccountId;
    token_metadata: TokenMetadata;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_mint", args, ...options});
  }
  nft_mintTx(args: {
    token_id: TokenId;
    token_owner_id: AccountId;
    token_metadata: TokenMetadata;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_mint", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  get_user_sale_info(args: {
    account_id: AccountId;
  }, options?: ViewFunctionOptions): Promise<UserSaleInfo> {
    return this.account.viewFunction(this.contractId, "get_user_sale_info", args, options);
  }
  initial(args = {}, options?: ViewFunctionOptions): Promise<u64> {
    return this.account.viewFunction(this.contractId, "initial", args, options);
  }
  async add_whitelist_account_ungaurded(args: {
    account_id: AccountId;
    allowance: u32;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.add_whitelist_account_ungaurdedRaw(args, options));
  }
  add_whitelist_account_ungaurdedRaw(args: {
    account_id: AccountId;
    allowance: u32;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "add_whitelist_account_ungaurded", args, ...options});
  }
  add_whitelist_account_ungaurdedTx(args: {
    account_id: AccountId;
    allowance: u32;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("add_whitelist_account_ungaurded", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  tokens_left(args = {}, options?: ViewFunctionOptions): Promise<u32> {
    return this.account.viewFunction(this.contractId, "tokens_left", args, options);
  }
  async update_royalties(args: {
    royalties: Royalties;
  }, options?: ChangeMethodOptions): Promise<void> {
    return providers.getTransactionLastResult(await this.update_royaltiesRaw(args, options));
  }
  update_royaltiesRaw(args: {
    royalties: Royalties;
  }, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "update_royalties", args, ...options});
  }
  update_royaltiesTx(args: {
    royalties: Royalties;
  }, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("update_royalties", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
  async nft_mint_one(args = {}, options?: ChangeMethodOptions): Promise<Token> {
    return providers.getTransactionLastResult(await this.nft_mint_oneRaw(args, options));
  }
  nft_mint_oneRaw(args = {}, options?: ChangeMethodOptions): Promise<providers.FinalExecutionOutcome> {
    return this.account.functionCall({contractId: this.contractId, methodName: "nft_mint_one", args, ...options});
  }
  nft_mint_oneTx(args = {}, options?: ChangeMethodOptions): transactions.Action {
    return transactions.functionCall("nft_mint_one", args, options?.gas ?? DEFAULT_FUNCTION_CALL_GAS, options?.attachedDeposit ?? new BN(0))
  }
}
/**
* 
* @contractMethod view
*/
export interface CheckKey {
  public_key: PublicKey;
}
/**
* 
* @contractMethod change
*/
export interface UpdateAllowance {
  allowance: u32;
}
/**
* 
* @contractMethod view
*/
export interface Whitelisted {
  account_id: AccountId;
}
/**
* 
* @contractMethod view
*/
export interface GetSaleInfo {
}
/**
* Revoke all approved accounts for a specific token.
* 
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * If contract requires >1yN deposit on `nft_approve`, contract
* MUST refund all associated storage deposit when owner revokes approvals
* * Contract MUST panic if called by someone other than token owner
* 
* Arguments:
* * `token_id`: the token with approvals to revoke
* 
* @contractMethod change
*/
export interface NftRevokeAll {
  token_id: TokenId;
}
/**
* 
* @contractMethod view
*/
export interface CostPerToken {
  minter: AccountId;
}
/**
* 
* @contractMethod change
*/
export interface TransferOwnership {
  new_owner: AccountId;
}
/**
* 
* @contractMethod change
*/
export interface StartPresale {
  public_sale_start?: TimestampMs;
  presale_price?: U128;
}
/**
* 
* @contractMethod change
*/
export interface CloseContract {
}
/**
* Simple transfer. Transfer a given `token_id` from current owner to
* `receiver_id`.
* 
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
* * Contract MUST panic if called by someone other than token owner or,
* if using Approval Management, one of the approved accounts
* * `approval_id` is for use with Approval Management,
* see <https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html>
* * If using Approval Management, contract MUST nullify approved accounts on
* successful transfer.
* * TODO: needed? Both accounts must be registered with the contract for transfer to
* succeed. See see <https://nomicon.io/Standards/StorageManagement.html>
* 
* Arguments:
* * `receiver_id`: the valid NEAR account receiving the token
* * `token_id`: the token to transfer
* * `approval_id`: expected approval ID. A number smaller than
* 2^53, and therefore representable as JSON. See Approval Management
* standard for full explanation.
* * `memo` (optional): for use cases that may benefit from indexing or
* providing information for a transfer
* 
* @contractMethod change
*/
export interface NftTransfer {
  receiver_id: AccountId;
  token_id: TokenId;
  approval_id?: u64;
  memo?: string;
}
/**
* 
* @contractMethod change
*/
export interface StartSale {
  price?: U128;
}
/**
* 
* @contractMethod change
*/
export interface NftMintMany {
  num: u32;
}
/**
* Check if a token is approved for transfer by a given account, optionally
* checking an approval_id
* 
* Arguments:
* * `token_id`: the token for which to revoke an approval
* * `approved_account_id`: the account to check the existence of in `approvals`
* * `approval_id`: an optional approval ID to check against current approval ID for given account
* 
* Returns:
* if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
* otherwise, `true` if `approved_account_id` is in list of approved accounts
* 
* @contractMethod view
*/
export interface NftIsApproved {
  token_id: TokenId;
  approved_account_id: AccountId;
  approval_id?: u64;
}
/**
* 
* @contractMethod change
*/
export interface UpdateUri {
  uri: string;
}
/**
* 
* @contractMethod view
*/
export interface NftPayout {
  token_id: string;
  balance: U128;
  max_len_payout?: u32;
}
/**
* Get a list of all tokens
* 
* Arguments:
* * `from_index`: a string representing an unsigned 128-bit integer,
* representing the starting index of tokens to return. (default 0)
* * `limit`: the maximum number of tokens to return (default total supply)
* Could fail on gas
* 
* Returns an array of Token objects, as described in Core standard
* 
* @contractMethod view
*/
export interface NftTokens {
  from_index?: U128;
  limit?: u64;
}
/**
* Transfer token and call a method on a receiver contract. A successful
* workflow will end in a success execution outcome to the callback on the NFT
* contract at the method `nft_resolve_transfer`.
* 
* You can think of this as being similar to attaching native NEAR tokens to a
* function call. It allows you to attach any Non-Fungible Token in a call to a
* receiver contract.
* 
* Requirements:
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * Contract MUST panic if called by someone other than token owner or,
* if using Approval Management, one of the approved accounts
* * The receiving contract must implement `ft_on_transfer` according to the
* standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
* with the resulting failed cross-contract call and roll back the transfer.
* * Contract MUST implement the behavior described in `ft_resolve_transfer`
* * `approval_id` is for use with Approval Management extension, see
* that document for full explanation.
* * If using Approval Management, contract MUST nullify approved accounts on
* successful transfer.
* 
* Arguments:
* * `receiver_id`: the valid NEAR account receiving the token.
* * `token_id`: the token to send.
* * `approval_id`: expected approval ID. A number smaller than
* 2^53, and therefore representable as JSON. See Approval Management
* standard for full explanation.
* * `memo` (optional): for use cases that may benefit from indexing or
* providing information for a transfer.
* * `msg`: specifies information needed by the receiving contract in
* order to properly handle the transfer. Can indicate both a function to
* call and the parameters to pass to that function.
* 
* @contractMethod change
*/
export interface NftTransferCall {
  receiver_id: AccountId;
  token_id: TokenId;
  approval_id?: u64;
  memo?: string;
  msg: string;
}
/**
* 
* @contractMethod change
*/
export interface NftTransferPayout {
  receiver_id: AccountId;
  token_id: string;
  approval_id?: u64;
  memo?: string;
  balance: U128;
  max_len_payout?: u32;
}
/**
* Returns the balance associated with given key.
* 
* @contractMethod view
*/
export interface GetKeyBalance {
}
/**
* Revoke an approved account for a specific token.
* 
* Requirements
* * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
* purposes
* * If contract requires >1yN deposit on `nft_approve`, contract
* MUST refund associated storage deposit when owner revokes approval
* * Contract MUST panic if called by someone other than token owner
* 
* Arguments:
* * `token_id`: the token for which to revoke an approval
* * `account_id`: the account to remove from `approvals`
* 
* @contractMethod change
*/
export interface NftRevoke {
  token_id: TokenId;
  account_id: AccountId;
}
/**
* Create a pending token that can be claimed with corresponding private key
* 
* @contractMethod change
*/
export interface CreateLinkdrop {
  public_key: PublicKey;
}
/**
* 
* @contractMethod change
*/
export interface AddWhitelistAccounts {
  accounts: AccountId[];
  allowance?: u32;
}
/**
* Returns the token with the given `token_id` or `null` if no such token.
* 
* @contractMethod view
*/
export interface NftToken {
  token_id: TokenId;
}
/**
* 
* @contractMethod change
*/
export interface New {
  owner_id: AccountId;
  metadata: NftContractMetadata;
  size: u32;
  sale: Sale;
}
/**
* Returns the total supply of non-fungible tokens as a string representing an
* unsigned 128-bit integer to avoid JSON number limit of 2^53.
* 
* @contractMethod view
*/
export interface NftTotalSupply {
}
/**
* 
* @contractMethod view
*/
export interface TokenStorageCost {
}
/**
* Add an approved account for a specific token.
* 
* Requirements
* * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
* security purposes
* * Contract MAY require caller to attach larger deposit, to cover cost of
* storing approver data
* * Contract MUST panic if called by someone other than token owner
* * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
* single-block gas limit
* * Contract MUST increment approval ID even if re-approving an account
* * If successfully approved or if had already been approved, and if `msg` is
* present, contract MUST call `nft_on_approve` on `account_id`. See
* `nft_on_approve` description below for details.
* 
* Arguments:
* * `token_id`: the token for which to add an approval
* * `account_id`: the account to add to `approvals`
* * `msg`: optional string to be passed to `nft_on_approve`
* 
* Returns void, if no `msg` given. Otherwise, returns promise call to
* `nft_on_approve`, which can resolve with whatever it wants.
* 
* @contractMethod change
*/
export interface NftApprove {
  token_id: TokenId;
  account_id: AccountId;
  msg?: string;
}
/**
* 
* @contractMethod view
*/
export interface CostOfLinkdrop {
  minter: AccountId;
}
/**
* 
* @contractMethod view
*/
export interface TotalCost {
  num: u32;
  minter: AccountId;
}
/**
* 
* @contractMethod view
*/
export interface GetLinkdropContract {
}
/**
* 
* @contractMethod change
*/
export interface NewDefaultMeta {
  owner_id: AccountId;
  metadata: InitialMetadata;
  size: u32;
  sale?: Sale;
}
/**
* Get number of tokens owned by a given account
* 
* Arguments:
* * `account_id`: a valid NEAR account
* 
* Returns the number of non-fungible tokens owned by given `account_id` as
* a string representing the value as an unsigned 128-bit integer to avoid JSON
* number limit of 2^53.
* 
* @contractMethod view
*/
export interface NftSupplyForOwner {
  account_id: AccountId;
}
/**
* 
* @contractMethod view
*/
export interface NftMetadata {
}
/**
* 
* @contractMethod view
*/
export interface MintRateLimit {
}
/**
* 
* @contractMethod view
*/
export interface RemainingAllowance {
  account_id: AccountId;
}
/**
* Get list of all tokens owned by a given account
* 
* Arguments:
* * `account_id`: a valid NEAR account
* * `from_index`: a string representing an unsigned 128-bit integer,
* representing the starting index of tokens to return. (default 0)
* * `limit`: the maximum number of tokens to return. (default unlimited)
* Could fail on gas
* 
* Returns a paginated list of all tokens owned by this account
* 
* @contractMethod view
*/
export interface NftTokensForOwner {
  account_id: AccountId;
  from_index?: U128;
  limit?: u64;
}
/**
* 
* @contractMethod change
*/
export interface NftMint {
  token_id: TokenId;
  token_owner_id: AccountId;
  token_metadata: TokenMetadata;
}
/**
* 
* @contractMethod view
*/
export interface GetUserSaleInfo {
  account_id: AccountId;
}
/**
* 
* @contractMethod view
*/
export interface Initial {
}
/**
* 
* @contractMethod change
*/
export interface AddWhitelistAccountUngaurded {
  account_id: AccountId;
  allowance: u32;
}
/**
* 
* @contractMethod view
*/
export interface TokensLeft {
}
/**
* 
* @contractMethod change
*/
export interface UpdateRoyalties {
  royalties: Royalties;
}
/**
* 
* @contractMethod change
*/
export interface NftMintOne {
}

'''
'''--- contracts/tenk/tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Basic Options */
    // "incremental": true,                   /* Enable incremental compilation */
    "target": "es5",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    "module": "commonjs",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    // "lib": [],                             /* Specify library files to be included in the compilation. */
    // "allowJs": true,                       /* Allow javascript files to be compiled. */
    // "checkJs": true,                       /* Report errors in .js files. */
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */
    "declaration": true,                   /* Generates corresponding '.d.ts' file. */
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */
    // "sourceMap": true,                     /* Generates corresponding '.map' file. */
    // "outFile": "./",                       /* Concatenate and emit output to single file. */
    "outDir": "dist/",                        /* Redirect output structure to the directory. */
    // "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                     /* Enable project compilation */
    // "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */
    // "removeComments": true,                /* Do not emit comments to output. */
    // "noEmit": true,                        /* Do not emit outputs. */
    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    "strict": true,                           /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,              /* Enable strict null checks. */
    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */
    // "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */

    /* Additional Checks */
    // "noUnusedLocals": true,                /* Report errors on unused locals. */
    // "noUnusedParameters": true,            /* Report errors on unused parameters. */
    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */

    /* Module Resolution Options */
    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */
    // "paths": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                       /* List of folders to include type definitions from. */
    // "types": [],                           /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */

    /* Source Map Options */
    // "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */

    /* Advanced Options */
    "skipLibCheck": true,                     /* Skip type checking of declaration files. */
    "forceConsistentCasingInFileNames": true  /* Disallow inconsistently-cased references to the same file. */
  },
  "include": ["ts/index.ts"]
}

'''
'''--- package.json ---
{
  "name": "tenk-nft",
  "version": "0.1.0",
  "license": "MIT",
  "main": "./contracts/tenk/dist/index.js",
  "types": "./contracts/tenk/dist/index.d.ts",
  "scripts": {
    "pretest": "yarn build:testnet && yarn lint",
    "upload:nft": "ts-node ./scripts/nft-uploader.ts",
    "build:testnet": "yarn build --features testnet",
    "build": "cargo build --target wasm32-unknown-unknown --release",
    "test": "ava",
    "test:testnet": "NEAR_WORKSPACES_NETWORK=testnet yarn test",
    "test:linkdrop": "yarn test:testnet '*/linkdrop/*'",
    "deploy:testnet": "yarn build:testnet && near repl -s ./scripts/deploy.ts",
    "deploy": "yarn build && near repl -s ./scripts/deploy.ts",
    "createKeys": "ts-node ./scripts/create-keys.ts",
    "createLinkUrls": "ts-node ./scripts/create-linkdrops-urls.ts",
    "createLinkdrops": "near repl -s ./scripts/create-linkdrops.ts",
    "addWhitelist": "near repl -s ./scripts/add-whitelist.js",
    "test:unit": "cargo test",
    "test:ci": "yarn test:unit && yarn test",
    "lint": "yarn eslint . --ext .ts",
    "wit": "(cd contracts/tenk; witme near wit -t ts/ --standards && tsc)",
    "schema": "(cd contracts/tenk; ts-json-schema-generator -f ./tsconfig.json --validation-keywords contractMethod -o index.schema.json)",
    "wit:schema": "yarn wit && yarn schema",
    "docs": "yarn wit && typedoc contracts/tenk/ts/index.ts --tsconfig contracts/tenk/tsconfig.json",
    "pack-car": "ipfs-car --wrapWithDirectory false",
    "upload-car": "ts-node ./scripts/car-uploader.ts"
  },
  "devDependencies": {
    "@types/glob": "^7.2.0",
    "@typescript-eslint/eslint-plugin": "^5.4.0",
    "@typescript-eslint/parser": "^5.4.0",
    "acquit": "^1.2.1",
    "acquit-markdown": "^0.1.0",
    "eslint": "^7.29.0",
    "glob": "^7.2.0",
    "near-api-js": "git+https://github.com/ahalabs/near-api-js#beta",
    "near-cli": "git+https://github.com/ahalabs/near-cli#beta",
    "near-units": "^0.1.9",
    "near-workspaces-ava": "^1.1.0",
    "nft.storage": "^5.0.0",
    "ts-node": "^10.4.0",
    "typedoc": "^0.22.11",
    "typescript": "^4.5.5"
  },
  "dependencies": {
    "ipfs-car": "^0.6.2"
  }
}

'''
'''--- scripts/add-whitelist.ts ---
import { Gas } from "near-units";
import { readFile } from "fs/promises";
import { Context } from "near-cli/context";
import { Contract } from "..";
import { valid_account_id } from "./utils";

async function isWhitelisted(
  contract: Contract,
  account_id: string
): Promise<boolean> {
  try {
    return contract.whitelisted({ account_id });
  } catch (e) {
    console.log(e);
    console.log(`Problem with ${account_id}`);
    return true;
  }
}

const DEFAULT_PER_TX = 200;

export async function main({ account, argv }: Context) {
  if (argv.length < 3) {
    console.error(
      `Help:\n<input file> <contractId> <allowance> <amount per tx? (default ${DEFAULT_PER_TX})>`
    );
    process.exit(1);
  }
  const [file, contractId, allowance_str, number] = argv;
  let whitelist = filter_accounts(JSON.parse(await readFile(file, "utf8")));

  const allowance = parseInt(allowance_str);
  let atATime = number ? parseInt(number) : DEFAULT_PER_TX;
  const contract = new Contract(account, contractId);

  for (let i = 0; i < whitelist.length; i = i + atATime) {
    let account_ids = whitelist.slice(i, i + atATime);
    let notInWl = new Set<string>();
    await Promise.all(
      account_ids.map(async (account_id) => {
        try {
          if (!(await isWhitelisted(contract, account_id))) {
            notInWl.add(account_id);
          }

        }catch(e) {
          console.error(`issue with account: ${account_id}`);
        }
      })
    );
    const accounts = Array.from(notInWl);
    const gas = Gas.parse("250 Tgas");
    if (accounts.length > 0) {
      try {
        await contract.add_whitelist_accounts({ accounts, allowance }, { gas });
      } catch (e) {
        console.log(`Failed ${accounts}`);
        continue;
      }
      console.log(`Added ${accounts}`);
    }
  }
}

function filter_accounts(raw_account_ids: string[]): string[] {
  const account_ids = raw_account_ids.map(s => s.trim().toLowerCase());
  let invalid_account_ids = account_ids.filter(
    (id) => !valid_account_id.test(id)
  );
  if (invalid_account_ids.length > 0) {
    console.log(`invalid Ids "${invalid_account_ids}"`);
  }
  return account_ids.filter((id) => valid_account_id.test(id));
}

'''
'''--- scripts/addFunds.ts ---
import { Workspace, NEAR } from "near-willem-workspaces";

const network = "testnet";
const args = process.argv.slice(2);

if (args.length < 1) {
  console.error("Fund a testnet acount with 200N");
  console.error("<testnetAccount>");
  process.exit(1);
}

const rootAccount = args[0];

void Workspace.open(
  { network, rootAccount },
  async ({ root }) => {
    const rootBalance = await root.availableBalance();
    if (rootBalance.lt(NEAR.parse("350 N"))) {
      // @ts-expect-error is private
      await root.manager.addFundsFromNetwork();
    }
  }
);

'''
'''--- scripts/car-uploader.ts ---
#!/usr/bin/env node -r ts-node/register --max-old-space-size=16000
import { createReadStream } from 'fs'
import { CarReader } from '@ipld/car'
import { NFTStorage } from "nft.storage";
import * as fs from "fs/promises";

const API_TOKEN = process.env["NFT_STORAGE_API_TOKEN"];

async function storeCarFile(filename) {
  var stats = await fs.stat(filename);
  const car = await CarReader.fromIterable(createReadStream(filename));
  let total = 0;
  function onStoredChunk(i) {
    total += i;
    console.log(`${(total/stats.size * 100).toFixed(1)}%`);
  }
  
  const client = new NFTStorage({ token: API_TOKEN });
  return client.storeCar(car, {onStoredChunk});
}

function makeLink(s: string): string {
  return `https://${s}.ipfs.dweb.link`;
}

async function main() {
  const [carFile] = process.argv.slice(2); 
  const CID = await storeCarFile(carFile);
  const link = makeLink(CID);
  console.log(CID);
  console.log(link);
  console.log(link + "/0.png");
  console.log(link + "/0.json");
}

void main();
'''
'''--- scripts/check_key.ts ---
import { Context } from "near-cli/context";
import { Contract } from "../contracts/tenk/dist";
import { getPublicKey } from "./utils";

export async function main({ account, argv }: Context) {
  let [public_key, is_link] = argv;
  if (is_link) {
    public_key = getPublicKey(public_key).toString();
  }
  let contract = new Contract(account, account.accountId);
  console.log(`key: ${public_key} - ${await contract.check_key({public_key})}`);
}

'''
'''--- scripts/create-keys.ts ---
import {createKeyPair, KeyPairEd25519} from "near-willem-workspaces";
import * as fs from "fs";

const res = process.argv.slice(2);

if (res.length < 2) {
  console.error("Create list of keys for linkdrop:\n<num of links> <output file>");
  process.exit(1);
}

const [numStr, file]  = res;

const num = parseInt(numStr);

const keys = [];

for (let i = 0; i < num; i++) {
  let key = createKeyPair() as KeyPairEd25519;
  keys.push({ 
    publicKey: key.getPublicKey().toString(), secretKey: key.secretKey
  })
}

const keysString = JSON.stringify(keys, null, 1);
fs.writeFileSync(file, keysString);

'''
'''--- scripts/create-linkdrops-urls.ts ---
import * as fs from "fs/promises";

const res = process.argv.slice(2);

if (res.length < 4) {
  console.error("Create linkdrop urls:\n<input file> <contractId> <redirectUrl> <output file>?\n\nIf no output file, output to stdout");
  process.exit(1);
}

const [file, contractId, url, outputFile] = res;
const walletUrl = (contractId, key, url) =>
  `https://wallet.near.org/linkdrop/${contractId}/${key}?redirectUrl=${url}`;

async function main() {
  let keys = JSON.parse(await fs.readFile(file, "utf8"));
  const output = keys
    .map(({ secretKey }) => walletUrl(contractId, secretKey, url))
    .join("\n");
  if (outputFile) {
    await fs.writeFile(outputFile, output);
  } else {
    console.log(output);
  }
}

void main();

'''
'''--- scripts/create-linkdrops.ts ---
import { NEAR, Gas } from "near-units";
import { readFile } from "fs/promises";
import { Contract } from "..";

export async function main({ account, argv }) {
  if (argv.length < 2) {
    console.error("Help:\n<input file> <contractId>");
    process.exit(1);
  }

  const [file, contractId] = argv;
  const contract = new Contract(account, contractId);
  let keys = JSON.parse(await readFile(file, "utf8"));

  for (let i = 0; i < keys.length; i++) {
    const { publicKey } = keys[i];
    const public_key = publicKey;
    const keyAdded = await contract.check_key({ public_key });
    if (!keyAdded) {
      await contract.create_linkdrop(
        { public_key },
        { gas: Gas.parse("30Tgas"), attachedDeposit: NEAR.parse("36mN") }
      );
    }
  }
}

'''
'''--- scripts/deploy.ts ---
import { NEAR, Gas } from "near-units";
import { readFile } from "fs/promises";
import { Context } from "near-cli/context";
import * as tenk from "..";
import { binPath } from "./utils";

const metadata: tenk.InitialMetadata = {
  uri: "https://bafybeiehqz6vklvxkopg3un3avdtevch4cywuihgxrb4oio2qgxf4764bi.ipfs.dweb.link/",
  name: "TENK NFT",
  symbol: "TENK",
};
 
const price = NEAR.parse("1 N").toJSON();

const sale: tenk.Sale = {
  price,
  mint_rate_limit: 3,
  public_sale_start: Date.now(),
  // public_sale_start: Date.now() + 1000 * 3600,
  // is_premint_over: true,
  // initial_royalties: {
  //   percent: 10_000,
  //   accounts: {
  //     "tenk.sputnik-dao.near": 1_500,
  //     "kokumo.near": 8_500,
  //   },
  // },
  // royalties: {
  //   percent: 690,
  //   accounts: {
  //     "tenk.sputnik-dao.near": 2500,
  //     "kukumo.near": 2900,
  //     "clownpoop.near": 2300,
  //     "supermariorpg.near": 2300,
  //   },
  // },
};

export async function main({ account, nearAPI, argv, near }: Context) {
  let { Account } = nearAPI;
  const contractBytes = await readFile(binPath("tenk"));

  let [contractId] = argv ?? [];
  contractId = contractId ?? account.accountId;
  let contractAccount = new Account(near.connection, contractId);

  const isTestnet = contractId.endsWith("testnet");
  if (isTestnet) {
    sale.initial_royalties = null;
  }
  const initialArgs = {
    owner_id: account.accountId,
    metadata,
    size: 100,
    sale,
    price,
  };

  const contract = new tenk.Contract(account, contractId);

  const tx = account
    .createTransaction(contractId)
    .deployContract(contractBytes);

  if (await contractAccount.hasDeployedContract()) {
    console.log(`initializing with: \n${JSON.stringify(initialArgs, null, 2)}`);
    tx.actions.push(
      contract.new_default_metaTx(initialArgs, { gas: Gas.parse("50Tgas") })
    );
  }
  let res = await tx.signAndSend();
  console.log(
    `https://explorer${isTestnet ? ".testnet" : ""}.near.org/transactions/${
      res.transaction_outcome.id
    }`
  );
  //@ts-ignore
  if (res.status.SuccessValue != undefined) {
    console.log(`deployed ${contractId}`);
  } else {
    console.log(res);
  }
}

'''
'''--- scripts/downloadContract.ts ---
import { JsonRpcProvider } from "near-willem-workspaces";
import * as path from "path";
import * as fs from "fs/promises";

let network: "testnet" | "mainnet" = "testnet";
const args = process.argv.slice(2);

if (args.length < 1) {
  console.error("Download the binary of a contract");
  console.error("<contract> <network = testnet>");
  process.exit(1);
}

const contract = args[0];

let filePath; // = args[1] || path.join(__dirname,"..", "__test__", "contracts", `${contract}.wasm`);

if (args.length > 1) {
  if (args[1] == "mainnet" || args[1] == "testnet") {
    network = args[1];
  } else {
    filePath = path.join(args[1], `${contract}.wasm`);
  }
}

async function main() {
  const provider = JsonRpcProvider.fromNetwork(network);
  const binary = await provider.viewCode(contract);
  if (filePath) {
    await fs.writeFile(filePath, binary);
  } else {
    process.stdout.write(binary);
  }
}

void main();

'''
'''--- scripts/nft-uploader.ts ---
#!/usr/bin/env node -r ts-node/register --max-old-space-size=16000

import { File, NFTStorage } from "nft.storage";
import * as fs from "fs/promises";
import * as path from "path";
import { API_TOKEN } from "../api_token";
import { glob as g } from "glob";
import { promisify } from "util";

const glob = promisify(g);

declare interface File {
  _parts: any[];
}

const id_regex = /^(?<id>[0-9]+)/;

async function getInfo(
  fullPath: string,
  rootDir: string
): Promise<{ id: string; info: any }> {
  const [dir, file] = [path.dirname(fullPath), path.basename(fullPath)];
  let first_bit = file.split(".")[0];
  const { id } = file.match(id_regex).groups;
  if (!id) {
    console.error(`Failed to find the id in ${fullPath}`);
  }
  const infoFiles = await glob(`${rootDir}/**/${first_bit}.json`);
  if (infoFiles.length == 0) {
    throw new Error(`Can't find metadata for ${fullPath}`);
  }

  if (infoFiles.length != 1) {
    throw new Error(
      `Found multiple metadata files for ${fullPath}: ${JSON.stringify(
        infoFiles
      )}`
    );
  }
  const info = await fs.readFile(infoFiles[0], { encoding: "utf8" });
  return {
    id: parseInt(id).toString(),
    info,
  };
}

async function parseFiles(
  directory: string,
  asset_extension: string,
  num: number
): Promise<typeof File[]> {
  const directoryFiles = await (await glob(`${directory}/**/*${asset_extension}`)).slice(num);
  const total = directoryFiles.length;
  console.log(`about to load ${total} files with extension: ${asset_extension}`);
  const twentieth = Math.floor(total / 20);
  let length = directory.length;
  let id_set = new Set(Array.from({ length }).map((_, i) => `${i}`));
  let finished = 0;
  const files = [];

  for (let file of directoryFiles) {
    finished++;
    if (finished % twentieth == 0) {
      console.log(`Read ${Math.floor((finished / total) * 100)}%`);
    }
    const { id, info } = await getInfo(file, directory);
    id_set.delete(id);
    let res = [
      new File([await fs.readFile(file)], `${id}${asset_extension}`),
      new File([info], `${id}.json`),
    ];
    files.push(...res);
  }
  if (id_set.size > 0) {
    throw new Error(
      `The following ids are missing: ${Array.from(id_set).join(", ")}`
    );
  }

  return files.flat();
}

function makeLink(s: string): string {
  return `https://${s}.ipfs.dweb.link`;
}

async function main() {
  const [directory, asset_extension, count] = process.argv.slice(2);
  if (!directory) {
    console.error("Upload NFT assets to nft.storage");
    console.error("Usage: <directory> <assetExtension>? <count?>");
    console.error(
      "directory where images and metadata that are numbered starting at zero.\n\t\t\t\t e.g. '0.png', '0.json'"
    );
    console.error("assetExtension is optional (default: '.png')");
    process.exit(1);
  }
  let num = parseInt(count ?? "0");
  const initialFiles = await parseFiles(directory, asset_extension ?? ".png", -num);
  if (num !=  0) {
    console.log(initialFiles)
    return;
  }
  if (!API_TOKEN) {
    console.error("Environment variable `NFT_STORAGE_API_TOKEN` is not set");
    return;
  }
  const client = new NFTStorage({ token: API_TOKEN });
  const CID = await client.storeDirectory(initialFiles);
  const link = makeLink(CID);
  console.log(CID);
  console.log(link);
  console.log(link + "/0.png");
  console.log(link + "/0.json");
}

void main();

'''
'''--- scripts/update_royalites.ts ---
import { Context } from "near-cli/context";
import { Contract } from "..";

export async function main({ account, argv }: Context) {
  let [contractId] = argv;
  if (contractId === null) {
    console.error("need to supply contract's accountId")
    console.error("... -- <contractId>")
  }
  let contract = new Contract(account, contractId);
  const royalties = {
    percent: 690,
    accounts: {
      "tenk.sputnik-dao.near": 2500,
      "bob.near": 7500,
    }
  };
  let res = await contract.update_royalties({ royalties });
  console.log("Old royalties");
  console.log(res);
  console.log(
    await contract.nft_payout({
      balance: "14285",
      token_id: "1533",
    })
  );
}

'''
'''--- scripts/utils.ts ---
import { KeyPairEd25519 } from "near-api-js/lib/utils";
import { join } from "path";

export function binPath(name) {
  const RUST_BIN_FOLDER = ["target", "wasm32-unknown-unknown", "release"];
  return join(__dirname, "..", ...RUST_BIN_FOLDER, `${name}.wasm`);
}

export const valid_account_id = /^(([a-z\d]+[\-_])*[a-z\d]+\.)*([a-z\d]+[\-_])*[a-z\d]+$/;

const linkmatcher =
  /https:\/\/wallet.near.org\/linkdrop\/[^/]+\/(?<key>.+)\?redirectUrl=/;

export function getPublicKey(link) {
  const m = link.match(linkmatcher).groups.key;
  return KeyPairEd25519.fromString(m).getPublicKey();
}
'''
'''--- tsconfig.json ---
{
  "extends": "near-workspaces-ava/tsconfig.ava.json"
}

'''