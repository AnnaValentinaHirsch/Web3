*GitHub Repository "Omhet/secret-ingredient"*

'''--- .eslintrc.js ---
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.json',
  },
  plugins: ['@typescript-eslint'],
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  rules: {
    'react/prop-types': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-empty-interface': 'off',
    '@typescript-eslint/ban-types': [
      'error',
      {
        extendDefaults: true,
        types: {
          '{}': false,
        },
      },
    ],
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
};

'''
'''--- .prettierrc.js ---
module.exports = {
  semi: true,
  printWidth: 120,
  singleQuote: true,
  arrowParens: 'always',
  proseWrap: 'preserve',
};

'''
'''--- .stylelintrc.json ---
{
  "extends": ["stylelint-config-standard", "stylelint-config-prettier"],
  "rules": {
    "block-no-empty": null
  }
}

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/index.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- assembly/index.ts ---
import { context, MapEntry, PersistentUnorderedMap } from 'near-sdk-as';

const rankings = new PersistentUnorderedMap<string, i32>('r');

export function updateRankings(score: i32): void {
  rankings.set(context.sender, score);
}

export function getRankings(): MapEntry<string, i32>[] {
  return rankings.entries();
}

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="monetization" content="$ilp.uphold.com/k4eJGQUDF9nw" />
    <title>Secret Ingredient</title>
  </head>
  <body>
    <div id="root"></div>
    <div id="modal-root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ438P4XFN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'G-DQ438P4XFN');
    </script>
  </body>
</html>

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1650888802724-27747003947333
'''
'''--- package.json ---
{
  "name": "vite-react-redux-template",
  "version": "0.0.1",
  "license": "MIT",
  "private": true,
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "serve": "vite preview",
    "typecheck": "tsc -p ./tsconfig.json --noEmit",
    "lint": "eslint \"src/**/*.{ts,tsx}\"",
    "lint:fix": "yarn lint --fix",
    "lint:style": "stylelint \"src/**/*.scss\"",
    "lint:style:fix": "yarn lint:style --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,scss}\"",
    "prepare": "husky install",
    "pre-commit": "yarn lint-staged",
    "pre-push": "run-p lint lint:style typecheck",
    "make:component": "hygen component new --name",
    "make:page": "hygen page new --name",
    "make:container": "hygen container new --name",
    "make:slice": "hygen slice new --name"
  },
  "dependencies": {
    "@pixi/particle-emitter": "^5.0.5",
    "@tonejs/midi": "^2.0.28",
    "big.js": "^6.1.1",
    "effector": "^22.2.0",
    "effector-react": "^22.0.6",
    "framer-motion": "^6.3.1",
    "near-api-js": "^0.44.2",
    "pixi-keyboard": "^1.0.0",
    "pixi.js": "^6.3.0",
    "react": "17.0.0",
    "react-dom": "17.0.0",
    "react-router-dom": "5.2.0",
    "react-use": "^17.3.2"
  },
  "devDependencies": {
    "@babel/core": "7.14.2",
    "@types/react": "17.0.5",
    "@types/react-dom": "17.0.5",
    "@types/react-router-dom": "5.1.7",
    "@typescript-eslint/eslint-plugin": "4.20.0",
    "@typescript-eslint/parser": "4.20.0",
    "@vitejs/plugin-react-refresh": "1.3.1",
    "autoprefixer": "9.0.0",
    "babel-loader": "8.2.2",
    "classnames": "^2.3.1",
    "css-loader": "5.2.4",
    "eslint": "7.23.0",
    "eslint-config-prettier": "8.1.0",
    "eslint-plugin-react": "7.23.1",
    "husky": "6.0.0",
    "hygen": "5.0.3",
    "lint-staged": "10.5.4",
    "near-sdk-as": "^3.2.3",
    "npm-run-all": "4.1.5",
    "postcss": "8.2.15",
    "postcss-preset-env": "6.7.0",
    "postcss-scss": "3.0.5",
    "prettier": "2.2.1",
    "sass": "1.32.8",
    "sass-loader": "10.1.1",
    "style-loader": "2.0.0",
    "stylelint": "13.12.0",
    "stylelint-config-prettier": "8.0.2",
    "stylelint-config-standard": "21.0.0",
    "typescript": "4.1.2",
    "vite": "2.9.5",
    "vite-plugin-react-svg": "0.2.0",
    "vite-tsconfig-paths": "^3.3.12"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "yarn lint:fix",
      "yarn format",
      "git add ."
    ],
    "*.{css,scss}": [
      "yarn lint:style:fix",
      "yarn format",
      "git add ."
    ]
  }
}

'''
'''--- postcss.config.js ---
module.exports = () => {
  return {
    parser: 'postcss-scss',
    plugins: [require('postcss-preset-env')(), require('autoprefixer')()],
  };
};

'''
'''--- public/favicon.svg ---
<svg width="144" height="164" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.6 48.5c-1.7 4.5-3 7-3.6 11.7-1 6.1-2 10.5 1 16 3.6 6.5 9.8 6.3 16.6 9.4A126.2 126.2 0 0 0 75.2 96c10.4 0 16.3-.6 26.5-2.1 9-1.3 14.6-.5 22.6-4.6 7.5-4 12.8-6.8 16.2-14.7 1.9-4.3 1.7-7.2 2.1-12 .4-4.5.7-7.1 0-11.6-1-7.3-3.3-11.2-7-17.4-4.5-7.5-8-11.1-14.6-16.6a61.6 61.6 0 0 0-19.3-11.7 61 61 0 0 0-18-4.6C77-.1 73.1-.3 66.4.7 60.2 1.7 56.8 3 51 5.3a75.7 75.7 0 0 0-30.3 19.4 71 71 0 0 0-14 23.8Z" fill="#A95627"/><path fill-rule="evenodd" clip-rule="evenodd" d="m2.5 63.2 5.2 2a53 53 0 0 1 5.8 2 127.5 127.5 0 0 0 54.9 10.4c10.4 0 16.3-.6 26.6-2.1 2.5-.4 4.7-.6 6.8-.8 5.5-.5 10-.9 15.9-3.8 7.6-4 12.8-6.8 16.2-14.7 1.6-3.5 1.7-6 2-9.5 0-.8 0-1.6.2-2.5v-.5c.3-4 .6-6.4 0-10.2h.1c3.8 6.3 6 10.2 7 17.5.7 4.3.5 6.9.1 11v.6l-.2 2.5c-.2 3.4-.4 6-2 9.5-3.4 7.9-8.6 10.8-16.2 14.7-5.8 3-10.4 3.3-15.8 3.8-2.2.2-4.4.4-6.9.8A161.4 161.4 0 0 1 75.6 96c-10.8 0-17-.2-27.6-2.1-11-2-17.2-3.7-27.3-8.3-2-.9-4-1.5-5.7-2C10.4 82 6.5 80.7 4 76c-2.6-4.5-2.2-8.3-1.5-13Z" fill="#000" fill-opacity=".1"/><path d="M0 64v9.1l8.8 19.8 24.5 11.7 43.6 4.4 43-8.6 20.3-15.8 2.8-11.3V64l-5.4 11.2L135 71l-6.4 13.6-5.4-9.4-6 13.2-6.5-8-7.2 10.4-6.4-6.2-6 10-8.3-10-6 10-6.3-8.5-5.9 8.4-6-9.9-5 10-8-12-3.2 8.2-9.1-12.7-5 8-9-15.1-8 7.1L0 64Z" fill="#9DB9D2"/><path d="M17.8 149.4 0 74l17.8 11.9 21.2 9 24 2.6h22.7l19.6-2.6 16.3-5.1 12-7.4L143 74l-9.4 72.1s-6.9 5.4-12 7.8c-6 2.8-9.9 5-16.3 6.7-7.6 2-11.8 1.7-19.6 2.7-8.7 1.2-13.8.7-22.6 0a120 120 0 0 1-20-2.7c-6.5-1.5-10.6-1.7-16.6-5-3.7-2-8.7-6.2-8.7-6.2Z" fill="#9DB9D2"/><path fill-rule="evenodd" clip-rule="evenodd" d="m14.6 135.3 3.3 14s5 4.3 8.7 6.3c4.7 2.5 8.2 3.2 12.6 4l4.2 1a120 120 0 0 0 20 2.7l1.6.1c7.9.6 12.8 1 21.1 0l6.8-.8a69 69 0 0 0 12.9-2c5.3-1.5 9-3.2 13.5-5.4l2.9-1.4c5-2.4 12-7.8 12-7.8l5.3-40.8c-3 9.5-7.2 18-13.2 23.2a45.7 45.7 0 0 1-15 9.2c-4.4 2.2-8 4-13.4 5.3a69 69 0 0 1-13 2.1l-6.7.7c-8.2 1.1-13.2.7-21.1.1h-1.6a120 120 0 0 1-20-2.9l-4.2-.8c-4.4-.9-7.9-1.5-12.5-4-1.4-.8-2.8-1.8-4.2-2.8Z" fill="#000" fill-opacity=".1"/><path d="m64.3 39.5-2.2 2.9s-1.3 1.1-2.3 1.6c-.9.4-1.5.8-2.4.6a3 3 0 0 1-2.3-1.8c-.6-1.3 0-2.4.6-3.7a6.2 6.2 0 0 1 2.9-3.4c1.1-.6 2-1.1 3.3-.8 1 .2 1.7.6 2.3 1.5.6 1 .7 2.3.1 3.1ZM103.1 58l-2.2 2.8s-1.3 1.1-2.3 1.6c-.9.4-1.5.8-2.5.6a3 3 0 0 1-2.2-1.8c-.7-1.3 0-2.4.6-3.7a6.2 6.2 0 0 1 2.9-3.4c1.1-.6 2-1.1 3.2-.8 1.1.2 1.8.6 2.4 1.5.6 1 .6 2.3.1 3.1ZM131.7 59.2l-2.2 2.9s-1.3 1.2-2.3 1.6c-.9.4-1.5.8-2.5.6a3 3 0 0 1-2.2-1.8c-.7-1.3 0-2.3.6-3.7a6.2 6.2 0 0 1 2.8-3.4c1.2-.6 2-1 3.3-.8 1.1.2 1.8.6 2.4 1.5.6 1 .6 2.4.1 3.1Z" fill="#692D0B"/><path d="m122.2 31.3-2.2 2.9s-1.3 1.1-2.3 1.6c-1 .4-1.5.7-2.5.5a3 3 0 0 1-2.3-1.7c-.6-1.3 0-2.4.7-3.7a6.2 6.2 0 0 1 2.8-3.4c1.2-.7 2-1.1 3.3-.8 1 .2 1.8.6 2.3 1.5.6 1 .7 2.3.2 3.1ZM73.5 63.2c-.5.8-2.2 2.8-2.2 2.8S70 67.2 69 67.6c-.9.4-1.5.8-2.4.6a3 3 0 0 1-2.3-1.7c-.6-1.4 0-2.4.6-3.7a6.2 6.2 0 0 1 2.9-3.4c1.1-.7 2-1.1 3.3-.9 1 .3 1.7.7 2.3 1.6.6 1 .7 2.3.1 3Z" fill="#84390F"/><path d="m38.7 60.2-2.2 2.9s-1.3 1.1-2.3 1.6c-1 .4-1.5.8-2.5.6a3 3 0 0 1-2.2-1.8c-.7-1.3 0-2.4.6-3.7a6.2 6.2 0 0 1 2.8-3.4c1.2-.6 2-1.1 3.3-.8 1 .2 1.8.6 2.3 1.5.7 1 .7 2.3.2 3.1ZM28.8 38.2l-2.2 2.9s-1.3 1.1-2.3 1.6c-.9.4-1.5.7-2.4.6a3 3 0 0 1-2.3-1.8c-.6-1.3 0-2.4.6-3.7a6.2 6.2 0 0 1 2.9-3.4c1.1-.7 2-1.1 3.3-.8 1 .2 1.7.6 2.3 1.5.6 1 .7 2.3.1 3.1Z" fill="#692D0B"/><path d="M57.1 19.1 55 22s-1.3 1.2-2.3 1.6c-1 .4-1.5.8-2.5.6a3 3 0 0 1-2.2-1.8c-.7-1.3 0-2.3.6-3.7a6.2 6.2 0 0 1 2.8-3.4c1.2-.6 2-1 3.3-.8 1 .2 1.8.6 2.3 1.6.7 1 .7 2.3.2 3Z" fill="#84390F"/><path d="m89.6 13.2-2.1 2.9s-1.3 1.1-2.4 1.6c-.9.4-1.5.8-2.4.6a3 3 0 0 1-2.3-1.8c-.6-1.3 0-2.4.6-3.7A6.2 6.2 0 0 1 84 9.4c1.1-.6 2-1 3.3-.8 1 .2 1.7.6 2.3 1.5.6 1 .7 2.3.1 3.1ZM96.2 37.5 94 40.4s-1.3 1.2-2.3 1.6c-.9.4-1.5.8-2.5.6a3 3 0 0 1-2.2-1.8c-.7-1.3 0-2.3.6-3.7a6.2 6.2 0 0 1 2.9-3.4c1.1-.6 2-1 3.2-.8 1.1.2 1.8.6 2.4 1.6.6 1 .6 2.3.1 3Z" fill="#692D0B"/><path d="M42.3 91 33 78l6.7 82.2 4.3.8-1.7-70ZM53.9 94.2 46 82l4.2 79.3a208.7 208.7 0 0 0 4.8.7l-1.1-67.8ZM65.4 95 59 85l2 77.7 6 .3-1.6-68ZM77.7 94.7 71 86l1.9 78H78l-.3-69.3ZM91.3 95 83 85l3.6 78 5.4-.7-.7-67.3ZM103.8 91.1 97 85l2.9 77 3-.5 3.1-.7-2.2-69.7ZM118 89.3l-6.5-8.3-.5 78 5-2.1 2-67.6ZM129 84.6l-5.6-9.6-2.4 79 4.3-2 3.7-67.4ZM138 75.3l-2.8-4.3-7.2 79 1.9-1.3 8.1-73.4ZM143 73.3V64l-11 83 2-1.5 9-72.2ZM31.5 157 19 71l9.2 15.2L35 158l-1.8-.3-1.7-.7ZM22 152 0 64l11.4 14.3L28 156s-2.2-1.1-3.5-2l-2.6-2Z" fill="#000" fill-opacity=".1"/></svg>
'''
'''--- public/mockServiceWorker.js ---
/**
 * Mock Service Worker.
 * @see https://github.com/mswjs/msw
 * - Please do NOT modify this file.
 * - Please do NOT serve this file on production.
 */
/* eslint-disable */
/* tslint:disable */

const INTEGRITY_CHECKSUM = '82ef9b96d8393b6da34527d1d6e19187'
const bypassHeaderName = 'x-msw-bypass'
const activeClientIds = new Set()

self.addEventListener('install', function () {
  return self.skipWaiting()
})

self.addEventListener('activate', async function (event) {
  return self.clients.claim()
})

self.addEventListener('message', async function (event) {
  const clientId = event.source.id

  if (!clientId || !self.clients) {
    return
  }

  const client = await self.clients.get(clientId)

  if (!client) {
    return
  }

  const allClients = await self.clients.matchAll()

  switch (event.data) {
    case 'KEEPALIVE_REQUEST': {
      sendToClient(client, {
        type: 'KEEPALIVE_RESPONSE',
      })
      break
    }

    case 'INTEGRITY_CHECK_REQUEST': {
      sendToClient(client, {
        type: 'INTEGRITY_CHECK_RESPONSE',
        payload: INTEGRITY_CHECKSUM,
      })
      break
    }

    case 'MOCK_ACTIVATE': {
      activeClientIds.add(clientId)

      sendToClient(client, {
        type: 'MOCKING_ENABLED',
        payload: true,
      })
      break
    }

    case 'MOCK_DEACTIVATE': {
      activeClientIds.delete(clientId)
      break
    }

    case 'CLIENT_CLOSED': {
      activeClientIds.delete(clientId)

      const remainingClients = allClients.filter((client) => {
        return client.id !== clientId
      })

      // Unregister itself when there are no more clients
      if (remainingClients.length === 0) {
        self.registration.unregister()
      }

      break
    }
  }
})

// Resolve the "master" client for the given event.
// Client that issues a request doesn't necessarily equal the client
// that registered the worker. It's with the latter the worker should
// communicate with during the response resolving phase.
async function resolveMasterClient(event) {
  const client = await self.clients.get(event.clientId)

  if (client.frameType === 'top-level') {
    return client
  }

  const allClients = await self.clients.matchAll()

  return allClients
    .filter((client) => {
      // Get only those clients that are currently visible.
      return client.visibilityState === 'visible'
    })
    .find((client) => {
      // Find the client ID that's recorded in the
      // set of clients that have registered the worker.
      return activeClientIds.has(client.id)
    })
}

async function handleRequest(event, requestId) {
  const client = await resolveMasterClient(event)
  const response = await getResponse(event, client, requestId)

  // Send back the response clone for the "response:*" life-cycle events.
  // Ensure MSW is active and ready to handle the message, otherwise
  // this message will pend indefinitely.
  if (client && activeClientIds.has(client.id)) {
    ;(async function () {
      const clonedResponse = response.clone()
      sendToClient(client, {
        type: 'RESPONSE',
        payload: {
          requestId,
          type: clonedResponse.type,
          ok: clonedResponse.ok,
          status: clonedResponse.status,
          statusText: clonedResponse.statusText,
          body:
            clonedResponse.body === null ? null : await clonedResponse.text(),
          headers: serializeHeaders(clonedResponse.headers),
          redirected: clonedResponse.redirected,
        },
      })
    })()
  }

  return response
}

async function getResponse(event, client, requestId) {
  const { request } = event
  const requestClone = request.clone()
  const getOriginalResponse = () => fetch(requestClone)

  // Bypass mocking when the request client is not active.
  if (!client) {
    return getOriginalResponse()
  }

  // Bypass initial page load requests (i.e. static assets).
  // The absence of the immediate/parent client in the map of the active clients
  // means that MSW hasn't dispatched the "MOCK_ACTIVATE" event yet
  // and is not ready to handle requests.
  if (!activeClientIds.has(client.id)) {
    return await getOriginalResponse()
  }

  // Bypass requests with the explicit bypass header
  if (requestClone.headers.get(bypassHeaderName) === 'true') {
    const cleanRequestHeaders = serializeHeaders(requestClone.headers)

    // Remove the bypass header to comply with the CORS preflight check.
    delete cleanRequestHeaders[bypassHeaderName]

    const originalRequest = new Request(requestClone, {
      headers: new Headers(cleanRequestHeaders),
    })

    return fetch(originalRequest)
  }

  // Send the request to the client-side MSW.
  const reqHeaders = serializeHeaders(request.headers)
  const body = await request.text()

  const clientMessage = await sendToClient(client, {
    type: 'REQUEST',
    payload: {
      id: requestId,
      url: request.url,
      method: request.method,
      headers: reqHeaders,
      cache: request.cache,
      mode: request.mode,
      credentials: request.credentials,
      destination: request.destination,
      integrity: request.integrity,
      redirect: request.redirect,
      referrer: request.referrer,
      referrerPolicy: request.referrerPolicy,
      body,
      bodyUsed: request.bodyUsed,
      keepalive: request.keepalive,
    },
  })

  switch (clientMessage.type) {
    case 'MOCK_SUCCESS': {
      return delayPromise(
        () => respondWithMock(clientMessage),
        clientMessage.payload.delay,
      )
    }

    case 'MOCK_NOT_FOUND': {
      return getOriginalResponse()
    }

    case 'NETWORK_ERROR': {
      const { name, message } = clientMessage.payload
      const networkError = new Error(message)
      networkError.name = name

      // Rejecting a request Promise emulates a network error.
      throw networkError
    }

    case 'INTERNAL_ERROR': {
      const parsedBody = JSON.parse(clientMessage.payload.body)

      console.error(
        `\
[MSW] Request handler function for "%s %s" has thrown the following exception:

${parsedBody.errorType}: ${parsedBody.message}
(see more detailed error stack trace in the mocked response body)

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error.
If you wish to mock an error response, please refer to this guide: https://mswjs.io/docs/recipes/mocking-error-responses\
`,
        request.method,
        request.url,
      )

      return respondWithMock(clientMessage)
    }
  }

  return getOriginalResponse()
}

self.addEventListener('fetch', function (event) {
  const { request } = event

  // Bypass navigation requests.
  if (request.mode === 'navigate') {
    return
  }

  // Opening the DevTools triggers the "only-if-cached" request
  // that cannot be handled by the worker. Bypass such requests.
  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
    return
  }

  // Bypass all requests when there are no active clients.
  // Prevents the self-unregistered worked from handling requests
  // after it's been deleted (still remains active until the next reload).
  if (activeClientIds.size === 0) {
    return
  }

  const requestId = uuidv4()

  return event.respondWith(
    handleRequest(event, requestId).catch((error) => {
      console.error(
        '[MSW] Failed to mock a "%s" request to "%s": %s',
        request.method,
        request.url,
        error,
      )
    }),
  )
})

function serializeHeaders(headers) {
  const reqHeaders = {}
  headers.forEach((value, name) => {
    reqHeaders[name] = reqHeaders[name]
      ? [].concat(reqHeaders[name]).concat(value)
      : value
  })
  return reqHeaders
}

function sendToClient(client, message) {
  return new Promise((resolve, reject) => {
    const channel = new MessageChannel()

    channel.port1.onmessage = (event) => {
      if (event.data && event.data.error) {
        return reject(event.data.error)
      }

      resolve(event.data)
    }

    client.postMessage(JSON.stringify(message), [channel.port2])
  })
}

function delayPromise(cb, duration) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(cb()), duration)
  })
}

function respondWithMock(clientMessage) {
  return new Response(clientMessage.payload.body, {
    ...clientMessage.payload,
    headers: clientMessage.payload.headers,
  })
}

function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0
    const v = c == 'x' ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })
}

'''
'''--- src/config.ts ---
export const config = import.meta.env;

'''
'''--- src/env.d.ts ---
interface ImportMetaEnv {
  VITE_API_DOMAIN: string;
}

'''
'''--- src/lib/auth/near.ts ---
/* eslint-disable @typescript-eslint/ban-ts-comment */
import Big from 'big.js';
import 'near-api-js/dist/near-api-js.min.js';

const BOATLOAD_OF_GAS = Big(3)
  .times(10 ** 13)
  .toFixed();

// @ts-ignore
const { keyStores, connect, WalletConnection, Contract } = window.nearApi;

const contractName = 'secret-ingredient-rankings.testnet';
// const contractName = 'dev-1650888802724-27747003947333';

const config = {
  networkId: 'testnet',
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  contractName,
  nodeUrl: 'https://rpc.testnet.near.org',
  walletUrl: 'https://wallet.testnet.near.org',
  helperUrl: 'https://helper.testnet.near.org',
  headers: {},
};

// @ts-ignore
let near: any, wallet: any, contract: any;

export const initNear = async () => {
  near = await connect(config);
  wallet = new WalletConnection(near, null);

  contract = await new Contract(wallet.account(), contractName, {
    viewMethods: ['getRankings'],
    changeMethods: ['updateRankings'],
    sender: wallet.getAccountId(),
  });
};

initNear();

export const updateRankings = async (score: number) => {
  if (!contract) {
    return;
  }

  return contract.updateRankings({ score }, BOATLOAD_OF_GAS);
};

export const getRankings = () => {
  if (!contract) {
    return;
  }

  return contract.getRankings();
};

export const signIn = (withUpdate = false) => {
  if (!wallet) {
    return;
  }

  let redirectSuccessUrl = document.location.origin;
  if (withUpdate) {
    redirectSuccessUrl = `${redirectSuccessUrl}?withUpdate=true`;
  }

  wallet.requestSignIn(contractName, 'Secret Ingredient | Rhythm Game', redirectSuccessUrl);
};

export const signOut = () => {
  if (!wallet) {
    return;
  }

  wallet.signOut();
};

export const isNEARSignedIn = (): boolean => {
  if (!wallet) {
    return false;
  }

  return wallet.isSignedIn();
};

export const getWalletAccountId = (): string | undefined => {
  if (!wallet) {
    return;
  }

  return wallet.getAccountId();
};

export const getWalletAccountNickname = (): string | undefined => {
  const id = getWalletAccountId();

  if (!id) {
    return undefined;
  }

  return id.split('.')[0] || id;
};

'''
'''--- src/lib/levels/AudioManager.ts ---
export class AudioManager {
  tracks: HTMLAudioElement[] = [];

  constructor(public urls: string[]) {}

  async loadLevelTrack(levelNumber: number): Promise<HTMLAudioElement> {
    return new Promise((resolve, reject) => {
      const index = levelNumber - 1;

      const url = this.urls[index];

      if (!url) {
        reject(Error('No audio url for this level'));
      }

      // audio is already loading/loaded
      const track = this.tracks[index];
      if (track) {
        if (track.readyState === 4) {
          resolve(track);
        } else {
          track.addEventListener('canplaythrough', () => {
            resolve(track);
          });
        }
        return;
      }

      const audio = new Audio(url);
      this.tracks[index] = audio;
      audio.addEventListener('canplaythrough', () => {
        resolve(audio);
      });
    });
  }

  getLevelTrack(levelNumber: number) {
    const index = levelNumber - 1;
    const audio = this.tracks[index];

    if (!audio) {
      throw Error('No audio for this level');
    }

    return audio;
  }

  playLevelTrack(levelNumber: number) {
    const index = levelNumber - 1;

    const audio = this.tracks[index];

    if (audio) {
      audio.volume = 0;
      audio.play();
      adjustVolume(audio, 1);
    }
  }

  async stopLevelTrack(levelNumber: number) {
    const index = levelNumber - 1;

    const audio = this.tracks[index];

    if (audio) {
      await adjustVolume(audio, 0);
      audio.pause();
      audio.currentTime = 0;
    }
  }
}

export async function adjustVolume(
  element: HTMLMediaElement,
  newVolume: number,
  {
    duration = 1000,
    easing = swing,
    interval = 13,
  }: {
    duration?: number;
    easing?: typeof swing;
    interval?: number;
  } = {}
): Promise<void> {
  const originalVolume = element.volume;
  const delta = newVolume - originalVolume;

  if (!delta || !duration || !easing || !interval) {
    element.volume = newVolume;
    return Promise.resolve();
  }

  const ticks = Math.floor(duration / interval);
  let tick = 1;

  return new Promise((resolve) => {
    const timer = setInterval(() => {
      element.volume = originalVolume + easing(tick / ticks) * delta;

      if (++tick === ticks + 1) {
        clearInterval(timer);
        resolve();
      }
    }, interval);
  });
}

export function swing(p: number) {
  return 0.5 - Math.cos(p * Math.PI) / 2;
}

'''
'''--- src/lib/levels/ImagesManager.ts ---
type LevelImageTypes<T> = {
  back: {
    vertical: T;
    horizontal: T;
  };
  food: T[];
  particles: T[];
  master: T;
  ingredient: T;
  table: T;
  zone: T;
};

export type LevelImageUrls = LevelImageTypes<string>;
export type LevelImages = LevelImageTypes<HTMLImageElement>;

export class ImagesManager {
  images: LevelImages[] = [];

  constructor(public levelImageUrls: LevelImageUrls[]) {}

  async loadLevelImages(levelNumber: number): Promise<LevelImages> {
    const index = levelNumber - 1;

    const levelImageUrl = this.levelImageUrls[index];
    if (!levelImageUrl) {
      throw Error('No images url for this level');
    }

    const { back, food, master, ingredient, table, zone, particles } = levelImageUrl;
    const [
      backHorizImg,
      backVertImg,
      foodImgs,
      masterImg,
      ingredientImg,
      tableImg,
      zoneImg,
      particlesImgs,
    ] = await Promise.all([
      this.loadImage(back.horizontal),
      this.loadImage(back.vertical),
      this.loadImages(food),
      this.loadImage(master),
      this.loadImage(ingredient),
      this.loadImage(table),
      this.loadImage(zone),
      this.loadImages(particles),
    ]);

    return {
      back: {
        horizontal: backHorizImg,
        vertical: backVertImg,
      },
      food: foodImgs,
      particles: particlesImgs,
      master: masterImg,
      ingredient: ingredientImg,
      table: tableImg,
      zone: zoneImg,
    };
  }

  async loadImages(urls: string[]): Promise<HTMLImageElement[]> {
    const arr = urls.map((url) => this.loadImage(url));
    const resolvedArr = await Promise.allSettled(arr);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return resolvedArr.filter((res) => res.status === 'fulfilled').map((res) => res.value);
  }

  async loadImage(url: string): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = url;

      img.onload = () => {
        resolve(img);
      };

      img.onerror = (err) => {
        reject(err);
      };
    });
  }
}

'''
'''--- src/lib/levels/LevelDataManager.ts ---
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { Markup } from '@app-types/music';
import { AudioManager } from './AudioManager';
import { ImagesManager, LevelImages, LevelImageUrls } from './ImagesManager';
import { MarkupManager } from './MarkupManager';

const LEVELS_DATA = [
  {
    name: 'Japan',
    maxScore: 66,
    ingredientColors: ['#4B2507', '#C1956B'],
  },
  {
    name: 'Mexico',
    maxScore: 76,
    ingredientColors: ['#FF4D00'],
  },
  {
    name: 'Russia',
    maxScore: 153,
    ingredientColors: ['#FFF5E9', '#5C9E69'],
  },
  {
    name: 'Grandma',
    maxScore: 102,
    ingredientColors: ['#C55350', '#DE9D81'],
  },
];

const LEVELS_FROM_STORAGE = JSON.parse(localStorage.getItem('levels') ?? '[]');

const LEVELS = LEVELS_DATA.map(({ name, maxScore, ingredientColors }, index) => {
  const number = index + 1;
  const score = LEVELS_FROM_STORAGE[index]?.score ?? 0;

  const imgPath = `pics/levels/${number}`;
  const imgUrls: LevelImageUrls = {
    back: {
      horizontal: `${imgPath}/back_h.jpg`,
      vertical: `${imgPath}/back_v.jpg`,
    },
    food: [`${imgPath}/food/1.png`, `${imgPath}/food/2.png`, `${imgPath}/food/3.png`],
    particles: [`${imgPath}/particles/1.png`, `${imgPath}/particles/2.png`],
    master: `${imgPath}/master.png`,
    ingredient: `${imgPath}/ingredient.png`,
    table: `${imgPath}/table.png`,
    zone: '/pics/zone.png',
  };

  return {
    name,
    number,
    score,
    maxScore,
    ingredientColors,
    musicUrl: `music/${number}.mp3`,
    midiUrl: `midi/${number}.mid`,
    imgUrls,
  };
});

type LevelType = {
  name: string;
  score: number;
  maxScore: number;
  number: number;
  ingredientColors: string[];
  audio: HTMLAudioElement;
  markup: Markup;
  images: LevelImages;
  imgUrls: LevelImageUrls;
};

class LevelDataManager {
  currentLevel = 1;
  levels: LevelType[] = [];

  constructor(
    public audioManager: AudioManager,
    public markupManager: MarkupManager,
    public imagesManager: ImagesManager
  ) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    this.levels = [...LEVELS];
  }

  async loadLevelData(levelNumber: number) {
    this.currentLevel = levelNumber;

    const requests: [Promise<HTMLAudioElement>, Promise<Markup>, Promise<LevelImages>] = [
      this.audioManager.loadLevelTrack(levelNumber),
      this.markupManager.loadLevelMarkup(levelNumber),
      this.imagesManager.loadLevelImages(levelNumber),
    ];

    const [audio, markup, images] = await Promise.all(requests);
    const data = {
      audio,
      markup,
      images,
    };

    const index = levelNumber - 1;

    this.levels[levelNumber - 1] = {
      ...LEVELS[index],
      ...data,
    };

    return data;
  }

  getLevelMusic() {
    return this.audioManager.getLevelTrack(this.currentLevel);
  }

  playLevelMusic() {
    this.audioManager.playLevelTrack(this.currentLevel);
  }

  stopLevelMusic() {
    this.audioManager.stopLevelTrack(this.currentLevel);
  }

  getAllLevels() {
    return this.levels;
  }

  getCurrentLevelData() {
    return this.levels[this.currentLevel - 1];
  }

  getLevelData(number: number) {
    return this.levels[number - 1];
  }
}

const musicUrls = LEVELS.map(({ musicUrl }) => musicUrl);
const audioManager = new AudioManager(musicUrls);

const midiUrls = LEVELS.map(({ midiUrl }) => midiUrl);
const markupManager = new MarkupManager(midiUrls);

const imageUrls = LEVELS.map(({ imgUrls }) => imgUrls);
const imagesManager = new ImagesManager(imageUrls);

export const levelDataManager = new LevelDataManager(audioManager, markupManager, imagesManager);
// @ts-ignore
window.getCurrentLevelData = levelDataManager.getCurrentLevelData.bind(levelDataManager);

'''
'''--- src/lib/levels/MarkupManager.ts ---
import { Markup } from '@app-types/music';
import { Midi } from '@tonejs/midi';

export class MarkupManager {
  markups: Markup[] = [];

  constructor(public urls: string[]) {}

  async loadLevelMarkup(levelNumber: number): Promise<Markup> {
    const index = levelNumber - 1;

    const url = this.urls[index];
    if (!url) {
      throw Error('No markup url for this level');
    }

    const midi = await Midi.fromUrl(url);
    const bpm = midi.header.tempos[0]?.bpm;
    const track = midi.tracks.find((track) => track.name === 'lead');

    if (!track) {
      throw Error('No midi track');
    }

    const bps = bpm / 60;
    const spb = 1 / bps;
    const barDuration = 4 / bps;

    return {
      bpm,
      bps,
      spb,
      barDuration,
      notes: track.notes.map((note) => note.time * bps + 8),
    };
  }
}

'''
'''--- src/monetization.d.ts ---
interface BaseMonetizationEventDetail {
  paymentPointer: string;
  requestId: string;
}

export interface MonetizationPendingEvent extends CustomEvent<BaseMonetizationEventDetail> {
  type: 'monetizationpending';
}

export interface MonetizationStartEvent extends CustomEvent<BaseMonetizationEventDetail> {
  type: 'monetizationstart';
}

interface MonetizationStopEventDetail extends BaseMonetizationEventDetail {
  finalized: boolean;
}

export interface MonetizationStopEvent extends CustomEvent<MonetizationStopEventDetail> {
  type: 'monetizationstop';
}

interface MonetizationProgressEventDetail extends BaseMonetizationEventDetail {
  amount: string;
  assetCode: string;
  assetScale: number;
  receipt?: string;
}

export interface MonetizationProgressEvent extends CustomEvent<MonetizationProgressEventDetail> {
  type: 'monetizationprogress';
}

export interface MonetizationEventMap {
  monetizationpending: MonetizationPendingEvent;
  monetizationstart: MonetizationStartEvent;
  monetizationstop: MonetizationStopEvent;
  monetizationprogress: MonetizationProgressEvent;
}

export type MonetizationEvent = MonetizationEventMap[keyof MonetizationEventMap];

export type MonetizationState = 'stopped' | 'pending' | 'started';

type EventListener<T, E extends Event = Event> = (this: T, evt: E) => any;

interface EventListenerObject<T, E extends Event = Event> {
  handleEvent(this: T, evt: E): void;
}

type EventListenerOrListenerObject<T, E extends Event = Event> = EventListener<T, E> | EventListenerObject<T, E>;

// Note: The Coil extension uses a <div> instead of an EventTarget
export interface Monetization extends EventTarget {
  state: MonetizationState;

  addEventListener<K extends keyof MonetizationEventMap>(
    type: K,
    listener: EventListenerOrListenerObject<Monetization, MonetizationEventMap[K]> | null,
    options?: boolean | AddEventListenerOptions
  ): void;

  removeEventListener<K extends keyof MonetizationEventMap>(
    type: K,
    listener: EventListenerOrListenerObject<Monetization, MonetizationEventMap[K]> | null,
    options?: boolean | EventListenerOptions
  ): void;
}

declare global {
  interface Document {
    monetization?: Monetization;
  }
}

'''
'''--- src/motions/motions.ts ---
export const menuVariants = {
  hidden: {
    clipPath: 'circle(0% at top left)',
  },
  visible: {
    clipPath: `circle(150% at top left)`,
    transition: { type: 'tween', duration: 1.5, ease: 'easeOut' },
  },
  exit: {
    clipPath: 'circle(0% at top left)',
    transition: {
      type: 'tween',
      duration: 1.5,
      ease: 'easeInOut',
    },
  },
};
export const buttonVariants = {
  hover: { scale: 1.1, transition: { type: 'spring', stiffness: 300 } },
};
export const button2Variants = {
  hover: { scale: 0.9, transition: { type: 'spring', stiffness: 300 } },
};
export const navItemVariants = {
  hover: {
    rotate: [0, -2, 0, 2, 0],
    transition: {
      repeat: Infinity,
      duration: 0.3,
    },
  },
};
export const levelContainerVariants = {
  hover: {
    scale: 0.95,
    transition: { type: 'spring', stiffness: 120, duration: 1.5 },
  },
};
export const levelVariants = {
  hover: {
    scale: 1.15,
    transition: { type: 'spring', stiffness: 120, duration: 1.5 },
  },
};
export const authorLinkVariants = {
  animate: (delay: number) => ({
    scale: [1, 1.02, 1, 0.98, 1],
    transition: {
      repeat: Infinity,
      duration: 0.7,
      delay,
    },
  }),
};

export const authorVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { type: 'tween', ease: 'easeOut', duration: 0.5, delay: 0.2 },
  },
  exit: {
    opacity: 0,
    transition: { type: 'tween', duration: 0.3, ease: 'easeInOut' },
  },
};

export const mobileNavItemVariants = {
  hover: {
    scale: 1.3,
    transition: { type: 'spring', stiffness: 300 },
  },
};

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/createPixiApp.ts ---
import { Application } from 'pixi.js';
import { pixiGame } from './pixiGame';

const SCALE_FACTOR = 3;

export const createPixiApp = () => {
  const app = new Application({
    width: document.documentElement.clientWidth * SCALE_FACTOR,
    height: document.documentElement.clientHeight * SCALE_FACTOR,
    resolution: 1,
    backgroundAlpha: 0,
  });

  const disableContextMenu = (e: Event) => {
    e.preventDefault();
  };

  app.view.addEventListener('contextmenu', disableContextMenu);

  const removeEventListeners = () => {
    app.view.removeEventListener('contextmenu', disableContextMenu);
  };

  const game = pixiGame(app);

  return {
    app,
    game,
    removeEventListeners,
  };
};

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/input/HotKey.ts ---
import Key from './Key';
import KeyboardManager from './KeyboardManager';

export default class HotKey {
  isPressed = false;
  isDown = false;
  isReleased = false;

  ctrl = false;
  shift = false;
  alt = false;

  constructor(public key: Key, public manager: KeyboardManager) {}

  update() {
    this.isDown = this.manager.isDown(this.key);
    this.isPressed = this.manager.isPressed(this.key);
    this.isReleased = this.manager.isReleased(this.key);
    this.ctrl = this.manager.isDown(Key.CTRL);
    this.shift = this.manager.isDown(Key.SHIFT);
    this.alt = this.manager.isDown(Key.ALT);
  }

  remove() {
    this.manager.removeHotKey(this.key);
  }
}

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/input/Key.ts ---
enum Key {
  BACKSPACE = 8,
  TAB = 9,
  ENTER = 13,
  SHIFT = 16,
  PAUSE = 19,
  CTRL = 17,
  ALT = 18,
  CAPS_LOCK = 20,
  ESCAPE = 27,
  SPACE = 32,
  PAGE_UP = 33,
  PAGE_DOWN = 34,
  END = 35,
  HOME = 36,
  LEFT = 37,
  UP = 38,
  RIGHT = 39,
  DOWN = 40,
  PRINT_SCREEN = 44,
  INSERT = 45,
  DELETE = 46,
  _0 = 48,
  _1 = 49,
  _2 = 50,
  _3 = 51,
  _4 = 52,
  _5 = 53,
  _6 = 54,
  _7 = 55,
  _8 = 56,
  _9 = 57,
  A = 65,
  B = 66,
  C = 67,
  D = 68,
  E = 69,
  F = 70,
  G = 71,
  H = 72,
  I = 73,
  J = 74,
  K = 75,
  L = 76,
  M = 77,
  N = 78,
  O = 79,
  P = 80,
  Q = 81,
  R = 82,
  S = 83,
  T = 84,
  U = 85,
  V = 86,
  W = 87,
  X = 88,
  Y = 89,
  Z = 90,
  CMD = 91,
  CMD_RIGHT = 93,
  NUM_0 = 96,
  NUM_1 = 97,
  NUM_2 = 98,
  NUM_3 = 99,
  NUM_4 = 100,
  NUM_5 = 101,
  NUM_6 = 102,
  NUM_7 = 103,
  NUM_8 = 104,
  NUM_9 = 105,
  MULTIPLY = 106,
  ADD = 107,
  SUBTRACT = 109,
  DECIMAL_POINT = 110,
  DIVIDE = 111,
  F1 = 112,
  F2 = 113,
  F3 = 114,
  F4 = 115,
  F5 = 116,
  F6 = 117,
  F7 = 118,
  F8 = 119,
  F9 = 120,
  F10 = 121,
  F11 = 122,
  F12 = 123,
  NUM_LOCK = 144,
  SCROLL_LOCK = 145,
  SEMI_COLON = 186,
  EQUAL = 187,
  COMMA = 188,
  DASH = 189,
  PERIOD = 190,
  FORWARD_SLASH = 191,
  OPEN_BRACKET = 219,
  BACK_SLASH = 220,
  CLOSE_BRACKET = 221,
  SINGLE_QUOTE = 222,
}

export default Key;

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/input/KeyboardManager.ts ---
import * as PIXI from 'pixi.js';
import HotKey from './HotKey';
import Key from './Key';

export default class KeyboardManager extends PIXI.utils.EventEmitter {
  isEnabled = false;
  private pressedKeys: boolean[] = [];
  private releasedKeys: boolean[] = [];
  private downKeys: { [key: number]: number } = {};

  private hotKeys: HotKey[] = [];
  private preventDefaultKeys: boolean[] = [];
  onDownCallback: (evt: any) => void;
  onUpCallback: (evt: any) => void;

  constructor() {
    super();
    this.onDownCallback = this._onKeyDown.bind(this);
    this.onUpCallback = this._onKeyUp.bind(this);
  }

  enable() {
    if (!this.isEnabled) {
      this.isEnabled = true;
      this._enableEvents();
    }
  }

  _enableEvents() {
    window.addEventListener('keydown', this.onDownCallback, true);
    window.addEventListener('keyup', this.onUpCallback, true);
  }

  disable() {
    if (this.isEnabled) {
      this.isEnabled = false;
      this._disableEvents();
    }
  }

  _disableEvents() {
    window.removeEventListener('keydown', this.onDownCallback, true);
    window.removeEventListener('keyup', this.onUpCallback, true);
  }

  setPreventDefault(key: any, value = true) {
    if (_isArray(key)) {
      for (let i = 0; i < key.length; i++) {
        this.preventDefaultKeys[key[i]] = value;
      }
    } else {
      this.preventDefaultKeys[key] = value;
    }
  }

  _onKeyDown(evt: any) {
    const key = evt.which || evt.keyCode;
    if (this.preventDefaultKeys[key]) {
      evt.preventDefault();
    }

    if (!this.isDown(key)) {
      this.downKeys[key] = 0;
      this.pressedKeys[key] = true;
      this.emit('pressed', key);
    }
  }

  _onKeyUp(evt: any) {
    const key = evt.which || evt.keyCode;
    if (this.preventDefaultKeys[key]) {
      evt.preventDefault();
    }

    if (this.isDown(key)) {
      this.pressedKeys[key] = false;
      this.releasedKeys[key] = true;

      delete this.downKeys[key];
      this.emit('released', key);
    }
  }

  downTime(key: Key): number {
    return this.downKeys[key] || 0;
  }

  isDown(key: Key): boolean {
    return this.downKeys.hasOwnProperty(key);
  }

  isPressed(key: Key): boolean {
    return !!this.pressedKeys[key];
  }

  isReleased(key: Key): boolean {
    return !!this.releasedKeys[key];
  }

  update(delta = 0) {
    this.hotKeys.forEach((key) => key.update());

    for (const key in this.downKeys) {
      if (!this.downKeys.hasOwnProperty(key)) {
        continue;
      }

      this.downKeys[key] += delta;
      this.emit('down', key);
    }

    this.pressedKeys.length = 0;
    this.releasedKeys.length = 0;
  }

  getHotKey(key: Key) {
    const hotKey = this.hotKeys[key] || new HotKey(key, this);
    this.hotKeys[key] = hotKey;
    return hotKey;
  }

  removeHotKey(key: Key) {
    if (this.hotKeys[key]) {
      delete this.hotKeys[key];
    }
  }
}

function _isArray(obj: any) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/input/MouseManager.ts ---
import * as PIXI from 'pixi.js';

export default class MouseManager extends PIXI.utils.EventEmitter {
  isEnabled = false;
  private isDown = false;
  onDownCallback: (evt: any) => void;
  onUpCallback: (evt: any) => void;

  constructor() {
    super();
    this.onDownCallback = this.onMouseDown.bind(this);
    this.onUpCallback = this.onMouseUp.bind(this);
  }

  enable() {
    if (!this.isEnabled) {
      this.isEnabled = true;
      this._enableEvents();
    }
  }

  _enableEvents() {
    window.addEventListener('mousedown', this.onDownCallback);
    window.addEventListener('mouseup', this.onUpCallback);
    window.addEventListener('touchstart', this.onDownCallback);
    window.addEventListener('touchend', this.onUpCallback);
  }

  disable() {
    if (this.isEnabled) {
      this.isEnabled = false;
      this._disableEvents();
    }
  }

  _disableEvents() {
    window.removeEventListener('mousedown', this.onDownCallback);
    window.removeEventListener('mouseup', this.onUpCallback);
    window.removeEventListener('touchstart', this.onDownCallback);
    window.removeEventListener('touchend', this.onUpCallback);
  }

  onMouseDown(evt: any) {
    evt.preventDefault();

    if (!this.isDown) {
      this.isDown = true;
    }
  }

  onMouseUp(evt: any) {
    evt.preventDefault();

    if (this.isDown) {
      this.isDown = false;
    }
  }

  update() {
    if (this.isDown) {
      this.emit('down');
      this.isDown = false;
    }
  }
}

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/particles/particleEmitter.ts ---
import { Emitter, EmitterConfigV3 } from '@pixi/particle-emitter';
import { ParticleContainer } from 'pixi.js';

const getConfig = (images: string[]): EmitterConfigV3 => ({
  lifetime: {
    min: 1,
    max: 2,
  },
  frequency: 0.008,
  emitterLifetime: 0.3,
  maxParticles: 500,
  addAtBack: true,
  pos: {
    x: 0,
    y: 0,
  },
  behaviors: [
    {
      type: 'alpha',
      config: {
        alpha: {
          list: [
            {
              time: 0,
              value: 1,
            },
            {
              time: 0.5,
              value: 0.5,
            },
            {
              time: 1,
              value: 0.2,
            },
          ],
        },
      },
    },
    {
      type: 'moveSpeed',
      config: {
        speed: {
          list: [
            {
              time: 0,
              value: 700,
            },
            {
              time: 1,
              value: 100,
            },
          ],
        },
      },
    },
    {
      type: 'scaleStatic',
      config: {
        min: 1,
        max: 2,
      },
    },
    {
      type: 'rotation',
      config: {
        accel: 0,
        minSpeed: 0,
        maxSpeed: 10,
        minStart: 180,
        maxStart: 360,
      },
    },
    {
      type: 'textureRandom',
      config: {
        textures: images,
      },
    },
    {
      type: 'spawnPoint',
      config: {},
    },
  ],
});

export function createParticlesEmitter(particleParent: ParticleContainer, images: string[]) {
  const emitter = new Emitter(particleParent, getConfig(images));

  return emitter;
}

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/pixiGame.ts ---
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { levelDataManager } from '@lib/levels/LevelDataManager';
import { Emitter } from '@pixi/particle-emitter';
import { decreaseBlastCount, decreaseNoteCount, increaseHitCount } from '@store/game';
import { Application, ParticleContainer, Sprite, Texture } from 'pixi.js';
import { createNotRepeatingRandomArrayItemFn, getRandomAngle, getRandomArrayItem } from '../../../utils';
import KeyboardManager from './input/KeyboardManager';
import MouseManager from './input/MouseManager';
import { createParticlesEmitter } from './particles/particleEmitter';
import { CreateFoodItemProps, Food, FoodItem } from './types';
import { checkHit } from './util';

const IS_VERTICAL = innerHeight > innerWidth;

export const pixiGame = (app: Application) => {
  const keyboardManager = new KeyboardManager();
  keyboardManager.enable();
  const mouseManager = new MouseManager();
  mouseManager.enable();

  const {
    images,
    number: levelNumber,
    markup: { bps, notes: markupNotes },
  } = levelDataManager.getCurrentLevelData();
  const music = levelDataManager.getLevelMusic();
  const notes = markupNotes.map((beat) => ({ beat, isSpawned: false }));

  const beatSize = app.screen.height / 4;
  const unitSize = beatSize / 2;

  const foodTextures = images.food.map((img) => {
    return Texture.from(img);
  });
  let food: Food = [];

  const { zone, table } = createZone();
  const zoneRect = zone.getBounds();

  function createParticleContainer() {
    const particlesContainer = new ParticleContainer();
    const particlesEmitter = createParticlesEmitter(particlesContainer, [images.particles[0].src]);
    particlesEmitter.autoUpdate = true;
    app.stage.addChild(particlesContainer);

    return {
      particlesContainer,
      particlesEmitter,
    };
  }

  function createTableParticleContainer({ isLeft }: { isLeft: boolean }) {
    const { particlesEmitter, particlesContainer } = createParticleContainer();

    const xOffset = zoneRect.width * 0.4;
    let x = isLeft ? zoneRect.left - (zoneRect.width / 2 + xOffset) : zoneRect.right + (zoneRect.width / 2 + xOffset);
    let y = zoneRect.bottom - zoneRect.height * 0.2;
    if (IS_VERTICAL) {
      x = isLeft ? 0 : app.screen.width;
      y = app.screen.height;
    }

    const angle = isLeft ? 45 : -45;

    particlesContainer.position.set(x, y);
    particlesContainer.angle = angle;

    particlesEmitter.minLifetime = 1;
    particlesEmitter.maxLifetime = 1;
    particlesEmitter.frequency *= 2;

    return { particlesEmitter, particlesContainer };
  }

  const { particlesEmitter: foodParticlesEmitter } = createParticleContainer();
  const { particlesEmitter: tableLeftParticlesEmitter } = createTableParticleContainer({ isLeft: true });
  const { particlesEmitter: tableRightParticlesEmitter } = createTableParticleContainer({ isLeft: false });

  function removeFoodItem(foodItem: FoodItem) {
    app.stage.removeChild(foodItem.sprite);
    food = food.filter((item) => item.beat !== foodItem.beat);
    decreaseNoteCount();
  }

  function emitParticles(emitter: Emitter, x?: number, y?: number) {
    emitter.emit = true;

    if (x === undefined || y === undefined) {
      return;
    }
    emitter.updateOwnerPos(x, y);
    emitter.resetPositionTracking();
  }

  // Tap
  function handleTap() {
    const foodItem = checkHit(zone, food, app.screen.height);

    if (foodItem) {
      emitParticles(
        foodParticlesEmitter,
        foodItem.sprite.x,
        Math.max(foodItem.sprite.y + foodItem.sprite.height * 0.2, zoneRect.top + zoneRect.height * 0.1)
      );
      removeFoodItem(foodItem);
      increaseHitCount();
    }

    emitParticles(tableLeftParticlesEmitter);
    emitParticles(tableRightParticlesEmitter);

    decreaseBlastCount();
  }

  keyboardManager.on('pressed', handleTap);
  mouseManager.on('down', handleTap);

  // Game Loop
  app.ticker.add(gameLoop);

  const minZoneScale = 3;
  const maxZoneScale = 3.06;
  const minFoodScale = levelNumber >= 2 ? 0.15 : 0.18;
  const maxFoodScale = levelNumber >= 2 ? 0.18 : 0.21;

  let elapsed = 0.0;
  function gameLoop() {
    elapsed += app.ticker.elapsedMS;

    keyboardManager.update();
    mouseManager.update();

    const currentBeat = bps * music.currentTime;

    // Spawn food on time
    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      if (note.beat <= currentBeat && !note.isSpawned) {
        spawnFood(note.beat);
        note.isSpawned = true;
      }
    }

    const beatAnimationValue = getBeatAnimationValue(elapsed, bps);

    table.scale.set(getScaledBeatAnimationValue(beatAnimationValue, minZoneScale, maxZoneScale));
    zone.scale.set(getScaledBeatAnimationValue(beatAnimationValue, minZoneScale, maxZoneScale));

    // Move food
    const foodDist = (beatSize * bps) / app.ticker.FPS;
    for (let i = 0; i < food.length; i++) {
      const foodItem = food[i];
      foodItem.sprite.x += foodDist * foodItem.vx;
      foodItem.sprite.y += foodDist * foodItem.vy;

      foodItem.sprite.scale.set(getScaledBeatAnimationValue(beatAnimationValue, minFoodScale, maxFoodScale));

      foodItem.sprite.angle += elapsed / 20000;

      if (foodItem.sprite.y > app.screen.height + foodItem.sprite.height * 2) {
        removeFoodItem(foodItem);
      }
    }
  }

  function createZone() {
    const zoneImg = levelDataManager.getCurrentLevelData().images.zone;
    zoneImg.width /= 5;
    zoneImg.height /= 6;
    const tableImg = levelDataManager.getCurrentLevelData().images.table;
    tableImg.width /= 6;
    tableImg.height /= 6;

    const zone = Sprite.from(zoneImg);
    zone.anchor.set(0.5, 1);
    const table = Sprite.from(tableImg);
    table.anchor.set(0.5, 1);

    const x = app.screen.width / 2;
    const y = app.screen.height + zoneImg.height * 0.2;

    zone.position.x = x;
    zone.position.y = y;
    table.position.x = x;
    table.position.y = y;

    app.stage.addChild(zone);
    app.stage.addChild(table);

    return { zone, table };
  }

  const zoneWidth = zoneRect.width;
  const zoneHeight = zoneRect.height;
  const getRandomTargetX = createNotRepeatingRandomArrayItemFn([
    zoneRect.left,
    zoneRect.left + zoneWidth * 0.45,
    zoneRect.right,
  ]);
  const targetY = zoneRect.top + zoneHeight * 0.1;

  function spawnFood(beat: number) {
    const angle = getRandomAngle() * (Math.PI / 180);
    const dist = beatSize * 8;

    const targetX = getRandomTargetX();

    const x = dist * Math.cos(angle) + targetX;
    const y = dist * Math.sin(angle) + targetY;

    const dx = targetX - x;
    const dy = targetY - y;
    const d = Math.sqrt(dx * dx + dy * dy);
    const vx = dx / d;
    const vy = dy / d;

    const foodSprite = createFoodSprite({
      texture: getRandomArrayItem(foodTextures),
      size: unitSize,
      x,
      y,
    });
    app.stage.addChild(foodSprite);
    food.push({
      sprite: foodSprite,
      beat,
      vx,
      vy,
    });
  }

  return {
    mouseManager,
    keyboardManager,
  };
};

function createFoodSprite({ texture, size, x, y }: CreateFoodItemProps) {
  const sprite = Sprite.from(texture);
  sprite.anchor.set(0.5);
  sprite.x = x;
  sprite.y = y;
  sprite.width = size;
  sprite.height = size;
  sprite.angle = Math.random() * 360;

  return sprite;
}

function getBeatAnimationValue(elapsed: number, bps: number) {
  return Math.abs(Math.sin((elapsed / 1000) * (Math.PI / 2) * bps));
}

function getScaledBeatAnimationValue(animValue: number, min = 1, max = 1) {
  return animValue * (max - min) + min;
}

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/types.ts ---
import { Sprite, Texture } from 'pixi.js';

export type FoodItem = {
  sprite: Sprite;
  beat: number;
  vx: number;
  vy: number;
};

export type CreateFoodItemProps = {
  texture: Texture;
  size: number;
  x: number;
  y: number;
};

export type Food = Array<FoodItem>;

'''
'''--- src/pages/GamePage/components/Game/components/Scene/PixiApp/util.ts ---
import { Sprite } from 'pixi.js';
import { Food, FoodItem } from './types';

export const checkHit = (zone: Sprite, food: Food, worldHeight: number) => {
  for (const foodItem of food) {
    if (foodItem) {
      const hitFoodItem = checkFoodHit(foodItem, zone, worldHeight);
      if (hitFoodItem !== undefined) {
        return hitFoodItem;
      }
    }
  }

  return undefined;
};

export const checkFoodHit = (foodItem: FoodItem, zone: Sprite, worldHeight: number) => {
  const foodItemRect = foodItem.sprite.getBounds();
  const zoneRect = zone.getBounds();

  if (foodItemRect.bottom > zoneRect.top && foodItemRect.top < worldHeight) {
    return foodItem;
  }
};

'''
'''--- src/pages/GamePage/components/Game/constants.ts ---
export const HALF_BEAT_SIZE = innerHeight / 8;
export const BEAT_SIZE = HALF_BEAT_SIZE * 2;

'''
'''--- src/pages/GamePage/components/Game/utils.ts ---
const getRandomIndex = (arr: any[]) => {
  return Math.floor(Math.random() * arr.length);
};

const getCycledArrayItem = (arr: any[], index: number) => {
  return arr[Math.min(Math.max(index, 0), arr.length - 1)];
};

export const getRandomArrayItem = <T>(arr: T[]) => {
  return arr[getRandomIndex(arr)];
};

export const createNotRepeatingRandomArrayItemFn = <T>(arr: T[]) => {
  let prevIndex: number | undefined;

  return () => {
    const randomIndex = getRandomIndex(arr);

    if (prevIndex === randomIndex) {
      const offset = Math.random() > 0.5 ? 1 : -1;
      return getCycledArrayItem(arr, randomIndex + offset);
    } else {
      prevIndex = randomIndex;
      return arr[randomIndex];
    }
  };
};

const IS_VERTICAL = innerHeight > innerWidth;
const VERTICAL_ANGLES = [260, 270, 280];
const HORIZONTAL_ANGLES = [225, 240, 270, 300, 315];
const ANGLES = IS_VERTICAL ? VERTICAL_ANGLES : HORIZONTAL_ANGLES;
export const getRandomAngle = () => {
  return getRandomArrayItem(ANGLES);
};

'''
'''--- src/store/game/index.ts ---
import { GameStatus } from '@app-types/game';
import { NotesType } from '@app-types/music';
import { createEffect, createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

type GameStore = {
  isLoading: boolean;
  status: GameStatus;
  hitCount: number;
  blastCount: number;
  noteCount: number;
  notes: NotesType;
};

export const gameStoreInitial = {
  isLoading: true,
  status: GameStatus.NotStarted,
  notes: [],
  hitCount: 0,
  noteCount: Infinity,
  blastCount: Infinity,
};

export const gameStore = createStore<GameStore>(gameStoreInitial);

export const blastCountStore = gameStore.map((state) => state.blastCount);
export const gameStatusStore = gameStore.map((state) => state.status);

export const setIsLoading = createEvent<boolean>();
export const setGameStatus = createEvent<GameStatus>();
export const setNoteCount = createEvent<number>();
export const setBlastCount = createEvent<number>();
export const removeNote = createEvent<number>();
export const decreaseNoteCount = createEvent();
export const increaseHitCount = createEvent();
export const decreaseBlastCount = createEvent();
export const resetGameData = createEvent();

export const startGame = createEvent();
export const endGame = createEvent();

export const loadGame = createEffect<number, void, void>();

export const useGame = () => {
  const state = useStore(gameStore);

  return {
    isGameStarted: state.status === GameStatus.InProgress,
    isGameEnd: state.status === GameStatus.End,
    ...state,
  };
};

'''
'''--- src/store/game/init.ts ---
import { GameStatus } from '@app-types/game';
import { levelDataManager } from '@lib/levels/LevelDataManager';
import {
  currentLevelStore,
  rewriteCurrentLevelScore,
  setCurrentLevelNumber,
  setCurrentLevelScore,
  setIsBetterScoreThanEarlier,
} from '@store/levels';
import { openGameEndModal, openGameStartModal } from '@store/modals';
import { createEvent, guard } from 'effector';
import {
  decreaseBlastCount,
  decreaseNoteCount,
  endGame,
  gameStatusStore,
  gameStore,
  gameStoreInitial,
  increaseHitCount,
  loadGame,
  resetGameData,
  setBlastCount,
  setGameStatus,
  setIsLoading,
  setNoteCount,
  startGame,
} from './index';

gameStore
  .on(setIsLoading, (state, isLoading) => ({ ...state, isLoading }))
  .on(setGameStatus, (state, status) => ({ ...state, status }))
  .on(setBlastCount, (state, blastCount) => ({ ...state, blastCount }))
  .on(setNoteCount, (state, noteCount) => ({ ...state, noteCount }))
  .on(increaseHitCount, (state) => ({ ...state, hitCount: state.hitCount + 1 }))
  .on(decreaseBlastCount, (state) => ({ ...state, blastCount: state.blastCount > 0 ? state.blastCount - 1 : 0 }))
  .on(decreaseNoteCount, (state) => ({ ...state, noteCount: state.noteCount > 0 ? state.noteCount - 1 : 0 }))
  .on(resetGameData, () => ({ ...gameStoreInitial }));

loadGame.use(async (levelNumber: number) => {
  setIsLoading(true);

  resetGameData();

  setCurrentLevelNumber(levelNumber);

  const { markup } = await levelDataManager.loadLevelData(levelNumber);

  setNoteCount(markup.notes.length);
  setBlastCount(Math.round(markup.notes.length * 1.05));

  setIsLoading(false);

  openGameStartModal();
});

startGame.watch(() => {
  setGameStatus(GameStatus.InProgress);
  levelDataManager.playLevelMusic();
});

const preGameEnd = createEvent();
// Set end game status
guard({
  source: gameStore,
  filter: ({ status, blastCount, noteCount }) =>
    status === GameStatus.InProgress && (blastCount === 0 || noteCount === 0),
  target: preGameEnd,
});
preGameEnd.watch(() => {
  setTimeout(() => {
    setGameStatus(GameStatus.End);
  }, 300);
});
// Call end game
guard({
  source: gameStatusStore,
  filter: (status) => status === GameStatus.End,
  target: endGame,
});

// Do end game stuff
endGame.watch(() => {
  const { hitCount, noteCount } = gameStore.getState();
  const { score: oldScore } = currentLevelStore.getState();

  const newScore = hitCount;
  setCurrentLevelScore(newScore);
  if (newScore > oldScore) {
    setIsBetterScoreThanEarlier(true);
    rewriteCurrentLevelScore(newScore);
  } else {
    setIsBetterScoreThanEarlier(false);
  }

  openGameEndModal();
  // Do not stop music at the end of the whole level. Let it play till the end
  if (noteCount !== 0) {
    levelDataManager.stopLevelMusic();
  }
});

'''
'''--- src/store/init.ts ---
import './game/init';
import './levels/init';
import './modals/init';
import './monetization/init';
import './rankings/init';
import './user/init';

'''
'''--- src/store/levels/index.ts ---
import { levelDataManager } from '@lib/levels/LevelDataManager';
import { combine, createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

type Level = {
  number: number;
  maxScore: number;
  score: number;
};

type LevelsStore = {
  currentLevelNumber: number;
  currentLevelScore: number;
  isBetterScoreThanEarlier: boolean;
  levels: Level[];
};

export const levelsStore = createStore<LevelsStore>({
  currentLevelNumber: 1,
  currentLevelScore: 0,
  isBetterScoreThanEarlier: false,
  levels: levelDataManager.getAllLevels().map(({ score, maxScore, number }) => ({ score, maxScore, number })),
});

export const globalScoreStore = levelsStore.map(({ levels }) => levels.reduce((a, b) => a + b.score, 0));

const getIsEnoughScore = (score: number, maxScore: number) => score >= Math.floor(maxScore * 0.3);

export const levelsListStore = combine(levelsStore, (levelsState) => {
  return levelsState.levels.map((level, index, levelsArray) => {
    const prevLevel = levelsArray[index - 1];

    const isEnoughScore = getIsEnoughScore(level.score, level.maxScore);
    const isOpen = prevLevel ? getIsEnoughScore(prevLevel.score, prevLevel.maxScore) : true;

    return {
      isOpen,
      isEnoughScore,
      ...level,
    };
  });
});

const currentLevelNumberStore = levelsStore.map(({ currentLevelNumber }) => currentLevelNumber);

export const currentLevelStore = combine(currentLevelNumberStore, levelsListStore, (currentLevelNumber, levelsList) => {
  return levelsList[currentLevelNumber - 1];
});

export const nextLevelStore = combine(currentLevelNumberStore, levelsListStore, (currentLevelNumber, levelsList) => {
  return levelsList[currentLevelNumber] ?? null;
});

export const useLevels = () => {
  const levels = useStore(levelsStore);
  const levelsList = useStore(levelsListStore);
  const globalScore = useStore(globalScoreStore);

  return {
    ...levels,
    globalScore,
    levels: levelsList,
  };
};

export const useCurrentLevel = () => {
  const state = useStore(currentLevelStore);

  return state;
};

export const useNextLevel = () => {
  const state = useStore(nextLevelStore);

  return state;
};

export const setCurrentLevelNumber = createEvent<number>();
export const setCurrentLevelScore = createEvent<number>();
export const rewriteCurrentLevelScore = createEvent<number>();
export const setIsBetterScoreThanEarlier = createEvent<boolean>();

'''
'''--- src/store/levels/init.ts ---
import {
  levelsStore,
  rewriteCurrentLevelScore,
  setCurrentLevelNumber,
  setCurrentLevelScore,
  setIsBetterScoreThanEarlier,
} from './index';

levelsStore
  .on(setCurrentLevelNumber, (state, currentLevelNumber) => ({ ...state, currentLevelNumber }))
  .on(setCurrentLevelScore, (state, score) => ({ ...state, currentLevelScore: score }))
  .on(setIsBetterScoreThanEarlier, (state, isBetter) => ({ ...state, isBetterScoreThanEarlier: isBetter }))
  .on(rewriteCurrentLevelScore, (state, score) => ({
    ...state,
    levels: state.levels.map((level) => {
      if (level.number === state.currentLevelNumber) {
        return {
          ...level,
          score,
        };
      }
      return level;
    }),
  }));

levelsStore.watch(({ levels }) => {
  localStorage.setItem('levels', JSON.stringify(levels));
});

'''
'''--- src/store/modals/index.ts ---
import { createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

export enum ModalId {
  GameEnd = 'GameEnd',
  GameStart = 'GameStart',
}

type ModalsStore = {
  id?: ModalId;
};

export const modalsStore = createStore<ModalsStore>({
  id: undefined,
});

export const useModals = () => {
  const state = useStore(modalsStore);

  return state;
};

export const openModal = createEvent<ModalId>();
export const closeModal = createEvent();

export const openGameEndModal = openModal.prepend(() => ModalId.GameEnd);
export const openGameStartModal = openModal.prepend(() => ModalId.GameStart);

'''
'''--- src/store/modals/init.ts ---
import { closeModal, modalsStore, openModal } from './index';

modalsStore
  //
  .on(openModal, (state, id) => ({ ...state, id }))
  .on(closeModal, (state) => ({ ...state, id: undefined }));

'''
'''--- src/store/monetization/index.ts ---
import { createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

type MonetizationStore = {
  isEnabled: boolean;
  status?: 'pending' | 'start' | 'stop';
};

export const monetizationStore = createStore<MonetizationStore>({
  isEnabled: document.monetization !== undefined,
  status: undefined,
});

export const useMonetization = () => {
  const state = useStore(monetizationStore);

  return state;
};

export const monetizationStart = createEvent();
export const monetizationPending = createEvent();
export const monetizationStop = createEvent();

'''
'''--- src/store/monetization/init.ts ---
import { monetizationPending, monetizationStart, monetizationStop, monetizationStore } from './index';

monetizationStore
  //
  .on(monetizationStart, (state) => ({ ...state, status: 'start' }))
  .on(monetizationPending, (state) => ({ ...state, status: 'pending' }))
  .on(monetizationStop, (state) => ({ ...state, status: 'stop' }));

if (document.monetization) {
  document.monetization.addEventListener('monetizationpending', () => {
    monetizationPending();
  });
  document.monetization.addEventListener('monetizationstart', () => {
    monetizationStart();
  });
  document.monetization.addEventListener('monetizationstop', () => {
    monetizationStop();
  });
}

'''
'''--- src/store/rankings/index.ts ---
import { getRankings, updateRankings } from '@lib/auth/near';
import { userStore } from '@store/user';
import { createEffect, createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

export type Ranking = {
  name: string;
  score: number;
  isCurrentUser: boolean;
};

export type Rankings = Ranking[];

export type UpdateStatus = 'Init' | 'InProgress' | 'Done';

type RankingsStore = {
  rankings: Rankings;
  userRankingScore: number | undefined;
  updateStatus: UpdateStatus;
};

export const rankingsStore = createStore<RankingsStore>({
  rankings: [],
  userRankingScore: undefined,
  updateStatus: 'Init',
});

export const useRankings = () => {
  const state = useStore(rankingsStore);
  const isRankingsLoading = useStore(loadRankings.pending);

  return {
    ...state,
    isRankingsLoading,
  };
};

export const setUpdateStatus = createEvent<UpdateStatus>();
export const setUserRankingScore = createEvent<number>();

export const loadRankings = createEffect<void, Rankings, Error>(async () => {
  const rankingsEntries = await getRankings();

  const user = userStore.getState();

  const rankings: Rankings = rankingsEntries.map(({ key, value }: { key: string; value: number }) => {
    const name = key.split('.')[0];

    return {
      name,
      score: value,
      isCurrentUser: name === user.name,
    };
  });

  const userRankingScore = rankings.find(({ name }) => name === user.name)?.score;
  if (userRankingScore) {
    setUserRankingScore(userRankingScore);
  }

  return rankings.sort((a, b) => b.score - a.score);
});
export const updateUserRankings = createEffect<number, void, Error>(async (score) => {
  setUpdateStatus('InProgress');
  await updateRankings(score);
  setUpdateStatus('Done');

  loadRankings();
});

'''
'''--- src/store/rankings/init.ts ---
import { loadRankings, rankingsStore, setUpdateStatus, setUserRankingScore, updateUserRankings } from './index';

rankingsStore
  //
  .on(loadRankings.doneData, (state, rankings) => ({ ...state, rankings }))
  .on(setUpdateStatus, (state, updateStatus) => ({ ...state, updateStatus }))
  .on(setUserRankingScore, (state, userRankingScore) => ({ ...state, userRankingScore }))
  .on(updateUserRankings.done, (state) => ({ ...state, updateStatus: 'Done' }));

'''
'''--- src/store/user/index.ts ---
import { getWalletAccountNickname, isNEARSignedIn } from '@lib/auth/near';
import { createEffect, createEvent, createStore } from 'effector';
import { useStore } from 'effector-react';

type UserStore = {
  isSignedIn: boolean;
  name?: string;
  isError: boolean;
};

export const userStore = createStore<UserStore>({
  isSignedIn: isNEARSignedIn(),
  name: getWalletAccountNickname(),
  isError: false,
});

export const useUser = () => {
  const state = useStore(userStore);
  const isLoading = useStore(initUser.pending);

  return {
    ...state,
    isLoading,
  };
};

export const resetUser = createEvent();

export const signIn = createEvent<{ withUpdate?: boolean } | undefined>();
export const signOut = createEvent();

export const initUser = createEffect<void, void, Error>();

'''
'''--- src/store/user/init.ts ---
import {
  getWalletAccountNickname,
  initNear,
  isNEARSignedIn,
  signIn as nearSignIn,
  signOut as nearSignOut,
} from '@lib/auth/near';
import { initUser, resetUser, signIn, signOut, userStore } from './index';

userStore
  //
  .on(initUser.done, (state) => ({
    ...state,
    isSignedIn: isNEARSignedIn(),
    name: getWalletAccountNickname(),
    isError: false,
  }))
  .on(initUser.fail, (state) => ({ ...state, isSignedIn: false, name: undefined, isError: true }))
  .on(resetUser, () => ({ isSignedIn: false, name: undefined, isError: false }));

signOut.watch(() => {
  nearSignOut();
  resetUser();
});

signIn.watch((props) => {
  nearSignIn(props?.withUpdate);
});

initUser.use(() => initNear());

'''
'''--- src/types/common.ts ---
export type WithClassName = {
  className?: string;
};

'''
'''--- src/types/game.ts ---
export type Position = {
  x: number;
  y: number;
};

export enum GameStatus {
  NotStarted = 'NotStarted',
  InProgress = 'InProgress',
  End = 'End',
}

'''
'''--- src/types/music.ts ---
export type Markup = {
  bpm: number;
  bps: number;
  spb: number;
  barDuration: number;
  notes: number[];
};

export type NotesType = Markup['notes'];

'''
'''--- src/types/navigationItem.ts ---
export type NavigationItem = {
  id: string;
  title: string;
};

'''
'''--- src/typings.d.ts ---
/// <reference lib="dom" />

interface ImportMeta {
  url: string;

  readonly hot?: {
    readonly data: unknown;

    accept(): void;
    accept(cb: (mod: unknown) => void): void;
    accept(dep: string, cb: (mod: unknown) => void): void;
    accept(deps: readonly string[], cb: (mods: unknown[]) => void): void;

    /**
     * @deprecated
     */
    acceptDeps(): never;

    dispose(cb: (data: unknown) => void): void;
    decline(): void;
    invalidate(): void;

    on(event: string, cb: (...args: unknown[]) => void): void;
  };

  readonly env: ImportMetaEnv;

  glob(
    pattern: string
  ): Record<
    string,
    () => Promise<{
      [key: string]: unknown;
    }>
  >;

  globEager(
    pattern: string
  ): Record<
    string,
    {
      [key: string]: unknown;
    }
  >;
}
interface ImportMetaEnv {
  [key: string]: string | boolean | undefined;
  BASE_URL: string;
  MODE: string;
  DEV: boolean;
  PROD: boolean;
}

// CSS modules
type CSSModuleClasses = { readonly [key: string]: string };

declare module '*.module.css' {
  const s: CSSModuleClasses;
  export default s;
}
declare module '*.module.scss' {
  const s: CSSModuleClasses;
  export default s;
}
declare module '*.module.sass' {
  const s: CSSModuleClasses;
  export default s;
}
declare module '*.module.less' {
  const s: CSSModuleClasses;
  export default s;
}
declare module '*.module.styl' {
  const s: CSSModuleClasses;
  export default s;
}
declare module '*.module.stylus' {
  const s: CSSModuleClasses;
  export default s;
}

// CSS
declare module '*.css' {
  const css: string;
  export default css;
}
declare module '*.scss' {
  const css: string;
  export default css;
}
declare module '*.sass' {
  const css: string;
  export default css;
}
declare module '*.less' {
  const css: string;
  export default css;
}
declare module '*.styl' {
  const css: string;
  export default css;
}
declare module '*.stylus' {
  const css: string;
  export default css;
}

// Built-in asset types
// see `src/constants.ts`

// images
declare module '*.jpg' {
  const src: string;
  export default src;
}
declare module '*.jpeg' {
  const src: string;
  export default src;
}
declare module '*.png' {
  const src: string;
  export default src;
}
declare module '*.gif' {
  const src: string;
  export default src;
}
declare module '*.svg' {
  import { ReactElement, SVGProps } from 'react';
  const src: (props: SVGProps<SVGElement>) => ReactElement;
  export default src;
}
declare module '*.ico' {
  const src: string;
  export default src;
}
declare module '*.webp' {
  const src: string;
  export default src;
}

// media
declare module '*.mp4' {
  const src: string;
  export default src;
}
declare module '*.webm' {
  const src: string;
  export default src;
}
declare module '*.ogg' {
  const src: string;
  export default src;
}
declare module '*.mp3' {
  const src: string;
  export default src;
}
declare module '*.wav' {
  const src: string;
  export default src;
}
declare module '*.flac' {
  const src: string;
  export default src;
}
declare module '*.aac' {
  const src: string;
  export default src;
}

// fonts
declare module '*.woff' {
  const src: string;
  export default src;
}
declare module '*.woff2' {
  const src: string;
  export default src;
}
declare module '*.eot' {
  const src: string;
  export default src;
}
declare module '*.ttf' {
  const src: string;
  export default src;
}
declare module '*.otf' {
  const src: string;
  export default src;
}

// web worker
declare module '*?worker' {
  const workerConstructor: {
    new (): Worker;
  };
  export default workerConstructor;
}

declare module '*?worker&inline' {
  const workerConstructor: {
    new (): Worker;
  };
  export default workerConstructor;
}

declare module '*?raw' {
  const src: string;
  export default src;
}

declare module '*?url' {
  const src: string;
  export default src;
}

declare module 'big.js';

'''
'''--- src/utils/toggleFreezePage.ts ---
export const toggleFreezePage = (): void => {
  document.body.classList.toggle('frozen');
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react",
    "baseUrl": "src",
    "paths": {
      "@components/*": ["components/*"],
      "@containers/*": ["containers/*"],
      "@data/*": ["data/*"],
      "@lib/*": ["lib/*"],
      "@pages/*": ["pages/*"],
      "@hooks/*": ["hooks/*"],
      "@icons/*": ["icons/*"],
      "@style/*": ["style/*"],
      "@store/*": ["store/*"],
      "@api/*": ["api/*"],
      "@mocks/*": ["mocks/*"],
      "@app-types/*": ["types/*"],
      "@config": ["config.ts"]
    }
  },
  "include": ["./src/**/*"],
  "exclude": ["node_modules"]
}

'''
'''--- vercel.json ---
{
  "routes": [{ "src": "/[^.]+", "dest": "/", "status": 200 }]
}

'''
'''--- vite.config.ts ---
import reactRefresh from '@vitejs/plugin-react-refresh';
import { defineConfig } from 'vite';
import reactSvgPlugin from 'vite-plugin-react-svg';
import tsconfigPaths from 'vite-tsconfig-paths';

// https://vitejs.dev/config/
export default ({ command }) => {
  const isDev = command === 'serve';

  return defineConfig({
    base: '',
    css: {
      modules: {
        generateScopedName: isDev ? '[name]__[local]___[hash:base64:5]' : undefined,
      },
    },
    plugins: [
      reactRefresh(),
      reactSvgPlugin({
        defaultExport: 'component',
        expandProps: 'end',
      }),
      tsconfigPaths(),
    ],
  });
};

'''