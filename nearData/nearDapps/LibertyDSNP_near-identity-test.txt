*GitHub Repository "LibertyDSNP/near-identity-test"*

'''--- README.md ---
# Experimental Repo for NEAR

Testing some ideas around DSNP Identity concepts and how it could work on NEAR.

'''
'''--- dsnp-identity-assembly/README.md ---
Indentity example in AssemblyScript
=================================

## Description

'''
'''--- dsnp-identity-assembly/as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- dsnp-identity-assembly/asconfig.js ---
const compile = require("near-sdk-as/compiler").compile

compile("assembly/main.ts", // input file
        "out/main.wasm",    // output file
        [
        //   "-O1",          // Optional arguments
        // "--debug",
        "--measure",         // Shows compiler runtime
        "--validate"         // Validate the generated wasm module
        ], {
          verbose: true     // Output the cli args passed to asc
        });

'''
'''--- dsnp-identity-assembly/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- dsnp-identity-assembly/assembly/__tests__/context.json ---
{
    "current_account_id": "eve",
    "signer_account_id": "bob",
    "signer_account_pk": "15T",
    "predecessor_account_id": "carol",
    "input": "{\"name\":\"Alice\"}",
    "block_index": 0,
    "epoch_height": 43,
    "account_balance": "0",
    "account_locked_balance": "0",
    "attached_deposit": "0",
    "prepaid_gas": 100000000000000,
    "random_seed": "15T",
    "free_of_charge": false,
    "storage_usage": 0,
    "output_data_receivers": [],
    "block_timestamp": 1,
    "is_view": false
}

'''
'''--- dsnp-identity-assembly/assembly/__tests__/main.spec.ts ---
import {
    getCounter,
    resetCounter,
    incrementCounter,
    decrementCounter
} from '../main';

import { context, storage, VM } from 'near-sdk-as';

describe("Counter ", () => {
    it("should increment by one", () => {
        incrementCounter(1);
        expect(getCounter()).toBe(1, "counter should be one after a single increment.");
    });

    it("getCounter is the same as reading from storage", () => {
        expect(storage.getPrimitive<i32>("counter", 0)).toBe(getCounter(), "storage.getPrimitive<i32>(\"counter\", 0) = getCounter()");
    });

    it("should decrement by one", () => {
        incrementCounter(1);
        decrementCounter(1);
        expect(getCounter()).toBe(0, "counter should be zero after a single decrement.");
    });

    it("should be resetable", () => {
        incrementCounter(1);
        incrementCounter(1);
        resetCounter(); // reset to zero
        expect(getCounter()).toBe(0, "counter should be zero after it is reset."); 
    });
    
    it("should increment multiple times and decrement back to zero", () => {
        incrementCounter(1);
        expect(getCounter()).toBe(1, "0 + 1 = 1");
        incrementCounter(3);
        expect(getCounter()).toBe(4, "1 + 3 = 4");
        decrementCounter(4);
        expect(getCounter()).toBe(0, "4 - 4 = 0");
    });

    it("should be eve's account", () => {
        expect(context.contractName).toBe("eve");
    });
});

'''
'''--- dsnp-identity-assembly/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- dsnp-identity-assembly/assembly/main.ts ---
import {
  storage,
  logging,
  PersistentMap,
  ContractPromise,
  u128,
} from "near-sdk-as";

import { IdentityContract, Delegate } from "./model";

let contract: IdentityContract;

@nearBindgen
class AddDelegateParam {
  account_id: string;
  public_key: string;
  end_block: string;

  constructor(account_id: string, public_key: string, end_block: string) {
    account_id = this.account_id;
    public_key = this.public_key;
    end_block = this.end_block;
  }
}

export function initContract(ownerId: string): IdentityContract {
  assert(!storage.hasKey("init"), "Already initialized");

  let delegates = new PersistentMap<string, Delegate>("d");

  contract = new IdentityContract(ownerId, delegates);

  storage.set("init", true);

  return contract;
}

@nearBindgen
class Ed25519VerifyArgs {
  constructor(
    public signature: string,
    public public_key: string,
    public serialize_message: string
  ) {}
}

export function upsertDelegateViaSig(
  signature: string,
  sigPK: string,
  message: AddDelegateParam
): void {
  logging.log("signature: " + signature);

  let serialize_message = "[".concat([message.account_id,message.end_block,message.public_key].join()).concat("]");

  let sigArg = new Ed25519VerifyArgs(signature, sigPK, serialize_message);
  let promise = ContractPromise.create(
    "ed25519-verification.testnet",
    "ed25519_verify",
    sigArg.encode(),
    50000000000,
    u128.Zero
  );

  // let callbackPromise = promise.then(
  //   context.contractName,
  //   "_onVerify",
  //   new Uint8Array(0),
  //   5000000000000
  // );
}

export function _onVerify(isSuccess: u64): void {
  logging.log("Successsis now");
}

'''
'''--- dsnp-identity-assembly/assembly/model.ts ---
import { PersistentMap, u128, PersistentSet, storage, base58, env, Context } from "near-sdk-as";
import { AccountId, PublicKey } from './types'

@nearBindgen
export class Delegate {
  end_block: u64;
  nonce: u32;

  constructor(end_block: u64, nonce: u32) {
      end_block = this.end_block;
      nonce = this.nonce;
  }
}

@nearBindgen
export class IdentityContract {
    owner_id: string;
    delegates: PersistentMap<AccountId, Delegate>;
    
    constructor(owner_id: AccountId, delegates: PersistentMap<AccountId, Delegate>) {
        owner_id = this.owner_id;
        delegates = this.delegates;

    }
}

'''
'''--- dsnp-identity-assembly/assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts",
    "../node_modules/**/*/as_types.d.ts"
  ]
}

'''
'''--- dsnp-identity-assembly/assembly/types.ts ---
export type AccountId = string
export type PublicKey = Uint8Array
'''
'''--- dsnp-identity-assembly/deployAndIntialize.sh ---
#!/bin/bash
set -e

# cargo build --target wasm32-unknown-unknown --release
# RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

# near dev-deploy --wasmFile out/main.wasm
# near deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm --accountId dsnp.testnet
# dev-1638480602878-94256636952712

# near deploy dev-1638572594110-70584534561471 --wasmFile out/main.wasm --accountId dev-1638572594110-70584534561471
near call dev-1638572594110-70584534561471 "upsertDelegateViaSig" '{"signature":  "2dcfbeaa399cddbb07cea7227a4b9b30b49ce7d8f7b72bd5046dffe8083b9c24c9862983254bc0c4297ca93729f4b737f8b5c26c33ef7ac205eb97ee5bdc190f", "sigPK": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": {"account_id": "dsnp.testnet", "end_block": "0", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz"}}' --accountId dev-1638572594110-70584534561471
# near call dev-1638572594110-70584534561471 "initContract" '{"ownerId":  "dsnp.testnet"}' --accountId dev-1638572594110-70584534561471
# $1,655.56 
# $1,497.59

# add delegate 2 pennies
# add registration 2 pennies
# transfer ownership 2 pennies
# deploy identity

# 1,667.55

# 196625 // 2 Near
# 143967

'''
'''--- dsnp-identity-assembly/package.json ---
{
  "name": "counter",
  "description": "identity assembly",
  "version": "0.0.1",
  "scripts": {
    "build": "node asconfig.js",
    "asp": "asp --verbose"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "near-sdk-as": "0.4.2",
    "parcel-bundler": "~1.12.5"
  }
}

'''
'''--- dsnp-identity-ecrecover-experiment/Cargo.toml ---
[package]
edition = "2018"
name = "ecrecover-experiments"
version = "0.1.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sys = "0.1.0"
near-sdk = "3.1.0"
ed25519-dalek = "1.0.1"
bs58= "0.4.0"
serde = { version = "1.0", features = ["derive"] }
hex = { version = "0.4", features = ["serde"] }
borsh = { version = "0.9", default-features = false }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
debug = false
lto = true
opt-level = "z"
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- dsnp-identity-ecrecover-experiment/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};
use near_sys as other_sys;
use std::convert::TryInto;
extern crate hex;

near_sdk::setup_alloc!();

// pub extern "C" fn cool_function(
//   i: cty::c_int,
//   c: cty::c_char,
//   cs: *mut CoolStruct
// );

// pub fn ecrecover(
//   hash_len: u64,
//   hash_ptr: u64,
//   sig_len: u64,
//   sig_ptr: u64,
//   v: u64,
//   malleability_flag: u64,
//   register_id: u64,
// ) -> u64;

// #[derive(Deserialize)]
// struct ECData {
//     #[serde(with = "hex::serde")]
//     message: [u8; 32],
//     #[serde(with = "hex::serde")]
//     signature: [u8; 64],
// }

pub fn ecrecover(
  hash_buffer: [u8; 32],
  sig_buffer: [u8; 64],
  // v: u64,
) -> u64 {
  unsafe { other_sys::ecrecover(32, hash_buffer.as_ptr() as _, 64, sig_buffer.as_ptr() as _, 0, 0, 0) } 
}

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Store {
}

#[near_bindgen]
impl Store {
  pub fn verify (message_hash: String, signature: String) -> String {
    let hash_decode: [u8; 32] = match hex::decode(&message_hash).unwrap().try_into() {
      Ok(hc) => hc,
      Err(o) => panic!("Expected a Vec of length {} but it was {}", 32, o.len()),
    };

    let hash_sig: [u8; 64]  = match hex::decode(&signature).unwrap().try_into() {
      Ok(hs) => hs,
      Err(o) => panic!("Expected a Vec of length {} but it was {}", 64, o.len()),
    };

    env::log(format!("public key {}", hex::encode(env::signer_account_pk())).as_bytes());

    // let data = ECData { signature: hashSig , message: hashDecode };
    ecrecover(hash_decode, hash_sig );

    match env::read_register(0) {
      None => panic!("Could not read from register 0"),
      Some(ba) => hex::encode(ba),
    }
  }
}
'''
'''--- dsnp-identity-ecrecover-experiment/src/sys.rs ---
#![no_std]

extern "C" {
    // ############
    // # Math API #
    // ############
    pub fn ecrecover(
        hash_len: u64,
        hash_ptr: u64,
        sig_len: u64,
        sig_ptr: u64,
        v: u64,
        malleability_flag: u64,
        register_id: u64,
    ) -> u64;
    // #############
    // # Alt BN128 #
    // #############
    pub fn alt_bn128_g1_multiexp(value_len: u64, value_ptr: u64, register_id: u64);
    pub fn alt_bn128_g1_sum(value_len: u64, value_ptr: u64, register_id: u64);
    pub fn alt_bn128_pairing_check(value_len: u64, value_ptr: u64) -> u64;
}

'''
'''--- dsnp-identity-ecrecover-experiment/test-verify.sh ---
#!/bin/bash
set -e

# near deploy ecrecover.testnet target/wasm32-unknown-unknown/release/ecrecover_experiemnts.wasm

# near call ecrecover.testnet "verify" '{"message_hash": "ce0677bb30baa8cf067c88db9811f4333d131bf8bcf12fe7065d211dce971008", "signature": "90f27b8b488db00b00606796d2987f6a5f59ae62ea05effe84fef5b8b0e549984a691139ad57a3f0b906637673aa2f63d1f55cb1a69199d4009eea23ceaddc93" }' --accountId ecrecover.testnet
# near call ecrecover.testnet "verify" '{"message_hash": "60be35518133bb945595a87176455ea5cb358f0768edf67855fd8b4317486a61", "signature": "0000000000000000000000000000000000000000000000000000000000000000443a4b19c24abdace71770faad25665fbc5b00450ec0b76c6e87e9a4383747fd" }' --accountId ecrecover.testnet

near call ecrecover.testnet "verify" '{"message_hash": "a727ef196c4ed856629b4274297ae7a7b6225043defbde6cd30c0d78f30d6d0b", "signature": "000000000000000000000000000000000000000000000000000000000000000188785d53d67fe3cfff690d4c8785c5facef3a19e9bec59933d352973a5da554a" }' --accountId dsnp.testnet
'''
'''--- dsnp-identity-no-verification/Cargo.toml ---
[package]
name = "dsnp-identity-no-verifcation"
version = "0.1.0"
authors = ["TEAM"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- dsnp-identity-no-verification/add_delegate.sh ---
#!/bin/bash
set -e

near call dsnp.testnet "upsert_delegate_via_sig" '{"signature":  "2dcfbeaa399cddbb07cea7227a4b9b30b49ce7d8f7b72bd5046dffe8083b9c24c9862983254bc0c4297ca93729f4b737f8b5c26c33ef7ac205eb97ee5bdc190f", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": {"account_id": "dsnp.testnet", "end_block": "0", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz"}}' --accountId dsnp.testnet
'''
'''--- dsnp-identity-no-verification/build_and_deploy.sh ---
#!/bin/bash
set -e

# cargo build --target wasm32-unknown-unknown --release
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

# near dev-deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm
# near deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm --accountId dsnp.testnet
# dev-1638480602878-94256636952712

# near call dsnp.testnet "new" '{"owner_id":  "dsnp.testnet"}' --accountId dsnp.testnet
# $1,655.56 
# $1,497.59

# add delegate 2 pennies
# add registration 2 pennies
# transfer ownership 2 pennies
# deploy identity

# 1,667.55

# 196625 // 2 Near
# 143967

'''
'''--- dsnp-identity-no-verification/minifier.sh ---
#!/usr/bin/env bash

for p in "$@"; do
  w=$(basename -- $p)
  echo "Minifying $w, make sure it is not stripped"
  wasm-snip $p --snip-rust-fmt-code --snip-rust-panicking-code -p core::num::flt2dec::.* -p core::fmt::float::.*  \
     --output temp-$w
  wasm-gc temp-$w
  wasm-strip temp-$w
  wasm-opt -Oz temp-$w --output minified-$w
  rm temp-$w
  echo $w `stat -c "%s" $p` "bytes ->" `stat -c "%s" minified-$w` "bytes, see minified-$w"
done
'''
'''--- dsnp-identity-no-verification/size_all.sh ---

   
#!/bin/bash
set -e

pushd $(dirname ${BASH_SOURCE[0]})

cargo install twiggy

for contract in */; do
    (
      cd "$contract";
      contract=$(basename "$contract")
      echo "Size contract $contract"
      RUSTFLAGS='-C debuginfo=2' cargo build --release --target wasm32-unknown-unknown
      for wasm in target/wasm32-unknown-unknown/release/*.wasm; do
        twiggy dominators -d 4 -r 100 "$wasm"
      done
    )
done

popd
'''
'''--- dsnp-identity-no-verification/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U64;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey,
    Gas, PanicOnDefault,
};

near_sdk::setup_alloc!();

const VERIFICATION_ACCOUNT_ID: &str = "ed25519-verification.testnet";
const NO_DEPOSIT: Balance = 0;
const BASE_GAS: Gas = 5_000_000_000_000;

#[ext_contract(ext_verification)]
trait ExVerification {
    fn ed25519_verification(
        &self,
        signature: String,
        public_key: String,
        serialize_message: String,
    ) -> Option<u64>;
    // fn callback_arg_macro(#[callback] account_id: Option<AccountId>) -> Option<AccountId>;
}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn callback_arg_macro(#[callback] is_valid: Option<AccountId>);
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    AccountsIdMap,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AddDelegateParam {
    account_id: AccountId,
    public_key: String,
    end_block: u64,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Delegate {
    end_block: u64,
    nonce: u32,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DelegateStore {
    owner_id: AccountId,
    pub delegates: LookupMap<AccountId, Delegate>,
}

#[near_bindgen]
impl DelegateStore {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let mut this = Self {
            owner_id: owner_id.clone(),
            delegates: LookupMap::new(StorageKeys::AccountsIdMap),
        };

        this.delegates.insert(
            &owner_id,
            &Delegate {
                end_block: 0,
                nonce: 1,
            },
        );

        this
    }

    pub fn get_delegate(&self, account_id: &AccountId) -> (U64, u32) {
        let delegate = self.delegates.get(&account_id).unwrap();
        (delegate.end_block.into(), delegate.nonce)
    }

    pub fn upsert_delegate_via_sig(
        &mut self,
        signature: String,
        sig_public_key: String,
        message: (AccountId, U64, String),
    ) {
        let account_id: AccountId = message.0.clone();
        let end_block: u64 = message.1.into();
        let public_key: String = message.2;
    
        let serialize_message = format!(
            "[\"{}\",\"{}\",\"{}\"]",
            account_id,
            end_block,
            public_key
        );

        let verification_account_id: AccountId = VERIFICATION_ACCOUNT_ID.to_string();
        ext_verification::ed25519_verification(
            signature,
            sig_public_key.clone(),
            serialize_message,
            &verification_account_id,
            NO_DEPOSIT,
            BASE_GAS,
        )
        .then(ext_self::callback_arg_macro(
            &env::current_account_id(),
            0,                 // yocto NEAR to attach to the callback
            5_000_000_000_000, // gas to attach to the callback
        ));

        let delegate = &self.get_delegate(&message.0);
        let nonce: u32 = delegate.1.into();

        self.delegates.insert(
            &message.0,
            &Delegate {
                end_block: message.1.into(),
                nonce: nonce + 1,
            },
        );
    }

    #[private]
    pub fn callback_arg_macro(&mut self, #[callback] is_valid: Option<u64>) -> bool {
        match is_valid {
            Some(_u) => env::log("YASSSSSS!!!!!!!!!".as_bytes()),
            None => env::log("ooooh shittt".as_bytes()),
        }

        true
    }
}

'''
'''--- dsnp-identity-with-verification/Cargo.toml ---
[package]
name = "dsnp-identity"
version = "0.1.0"
authors = ["TEAM"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
ed25519-dalek = "1.0.1"
bs58= "0.4.0"
hex = { version = "0.4", features = ["serde"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- dsnp-identity-with-verification/add_delegate.sh ---

#!/bin/bash
set -e

# near call dsnp.testnet "ed25519_verify" '{"signature":  "d52884038ee9d5af3311a39faa48ead7f044b1154bde9b23e0935b5bf9b3a2f3afc528b56b2a56a440159ff1d944113763dc9d65d7a004d744ba23103bb68a0e", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": "dsnp.testnet"}' --accountId dsnp.testnet
# near call dsnp.testnet "ed25519_verify" '{"signature":  "044ecb44c5c1ba9f723e747cc7bfb884d7dbe2a80598d2455403581e7ace8ecaaae1ffb43cb32b93c34cbc09722128e5f8012967e725a91051037cb257b46a0c", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": "dsnp.testnet"}' --accountId dsnp.testnet
# near call dsnp.testnet "ed25519_verify" '{"signature":  "2dcfbeaa399cddbb07cea7227a4b9b30b49ce7d8f7b72bd5046dffe8083b9c24c9862983254bc0c4297ca93729f4b737f8b5c26c33ef7ac205eb97ee5bdc190f", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": {"account_id": "dsnp.testnet", "end_block": "0", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz"}}' --accountId dsnp.testnet
near call dsnp.testnet "upsert_delegate_via_sig" '{"signature":  "2dcfbeaa399cddbb07cea7227a4b9b30b49ce7d8f7b72bd5046dffe8083b9c24c9862983254bc0c4297ca93729f4b737f8b5c26c33ef7ac205eb97ee5bdc190f", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz", "message": {"account_id": "dsnp.testnet", "end_block": "0", "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz"}}' --accountId dsnp.testnet
'''
'''--- dsnp-identity-with-verification/build_and_deploy.sh ---
#!/bin/bash
set -e

# cargo build --target wasm32-unknown-unknown --release
# RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

# near dev-deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm
near deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm --accountId dsnp.testnet
# dev-1638480602878-94256636952712

# near call dsnp.testnet "new" '{"owner_id":  "dsnp.testnet"}' --accountId dsnp.testnet
# $1,655.56 
# $1,497.59

# add delegate 2 pennies
# add registration 2 pennies
# transfer ownership 2 pennies
# deploy identity

# 1,667.55

# 196625 // 2 Near
# 143967

'''
'''--- dsnp-identity-with-verification/src/lib.rs ---
use bs58;
use ed25519_dalek::Signature;
use ed25519_dalek::{PublicKey, Verifier};
use hex::FromHex;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U64};
use near_sdk::{
  collections::LookupMap, env::sha256, near_bindgen, AccountId,
  BorshStorageKey, PanicOnDefault,
};

use near_sdk::serde::{Deserialize, Serialize};

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
  AccountsIdMap,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AddDelegateParam {
  account_id: AccountId,
  public_key: String,
  end_block: U64,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Delegate {
  end_block: u64,
  nonce: u32,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DelegateStore {
  owner_id: AccountId,
  pub delegates: LookupMap<AccountId, Delegate>,
}

#[near_bindgen]
impl DelegateStore {
  #[init]
  pub fn new(owner_id: AccountId) -> Self {
    let mut this = Self {
      owner_id: owner_id.clone(),
      delegates: LookupMap::new(StorageKeys::AccountsIdMap),
    };

    this.delegates.insert(
      &owner_id,
      &Delegate {
        end_block: 0,
        nonce: 1,
      },
    );

    this
  }

  pub fn get_delegate(&self, account_id: &AccountId) -> Delegate {
    self.delegates.get(&account_id).unwrap()
  }

  pub fn upsert_delegate_via_sig(
    &mut self,
    signature: String,
    public_key: String,
    message: AddDelegateParam,
  ) {

    let serialize_message = format!(
      "[\"{}\",\"{}\",\"{}\"]",
      message.account_id,
      message.end_block.0.to_string(),
      message.public_key
    );

    /// verify public key exist in delegates
  
    DelegateStore::ed25519_verify(signature, public_key, serialize_message);

    let delegate = &self.get_delegate(&message.account_id);
  
    self.delegates.insert(
      &message.account_id,
      &Delegate {
        end_block: message.end_block.into(),
        nonce: delegate.nonce + 1,
      },
    );
  }

  fn ed25519_verify(signature: String, public_key: String, serialize_message: String) -> u64 {
    let sig_bytes: Vec<u8> = FromHex::from_hex(&signature).unwrap();
    let sig: Signature = Signature::from_bytes(&sig_bytes[..64]).unwrap();

    let public_key = PublicKey::from_bytes(&bs58::decode(public_key).into_vec().unwrap()).unwrap();

    near_sdk::env::log(
      format!(
        "Verifiying validity of signature ('{:?}') for string '{}'...",
        signature, "taco"
      )
      .as_bytes(),
    );

    near_sdk::env::log(format!("json param account:'{}'", serialize_message).as_bytes());

    let hash_message: Vec<u8> = sha256(serialize_message.as_bytes());
    if let Ok(_) = public_key.verify(hash_message.as_slice(), &sig) {
      return 1 as u64;
    }

    panic!("message verification failed");
  }
}

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::test_utils::{get_logs, VMContextBuilder};
  use near_sdk::{testing_env, AccountId};

  // part of writing unit tests is setting up a mock context
  // provide a `predecessor` here, it'll modify the default context
  fn get_context(predecessor: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder.predecessor_account_id(predecessor);
    builder
  }

  // TESTS HERE
}

'''
'''--- dsnp-identity-with-verification/temp.sh ---
#!/bin/bash
set -e

near call dsnp.testnet "get_delegate" '{"account_id":  "dsnp.testnet"}' --accountId dsnp.testnet
'''
'''--- ed25519_verification/Cargo.toml ---
[package]
name = "ed25519-verification"
version = "0.1.0"
authors = ["TEAM"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
ed25519-dalek = "1.0.1"
bs58= "0.4.0"
hex = { version = "0.4", features = ["serde"] }

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- ed25519_verification/build_and_deploy.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
near deploy --wasmFile target/wasm32-unknown-unknown/release/ed25519_verification.wasm --accountId ed25519-verification.testnet

# near dev-deploy --wasmFile target/wasm32-unknown-unknown/release/dsnp_identity.wasm
'''
'''--- ed25519_verification/src/lib.rs ---
use bs58;
use ed25519_dalek::Signature;
use ed25519_dalek::{PublicKey, Verifier};
use hex::FromHex;
use near_sdk::{env::sha256, near_bindgen};

near_sdk::setup_alloc!();

#[near_bindgen]
pub struct Ed25519 {}

#[near_bindgen]
impl Ed25519 {
  pub fn ed25519_verify(signature: String, public_key: String, serialize_message: String) -> u64 {
    let sig_bytes: Vec<u8> = FromHex::from_hex(&signature).unwrap();
    let sig: Signature = Signature::from_bytes(&sig_bytes[..64]).unwrap();

    let public_key = PublicKey::from_bytes(&bs58::decode(public_key).into_vec().unwrap()).unwrap();

    near_sdk::env::log(
      format!(
        "Verifiying validity of signature ('{:?}') for string '{}'...",
        signature, "taco"
      )
      .as_bytes(),
    );

    near_sdk::env::log(format!("json param account:'{}'", serialize_message).as_bytes());

    let hash_message: Vec<u8> = sha256(serialize_message.as_bytes());
    if let Ok(_) = public_key.verify(hash_message.as_slice(), &sig) {
      return 1 as u64;
    }

    panic!("message verification failed");
  }
}

// // use the attribute below for unit tests
// #[cfg(test)]
// mod tests {
//   use super::*;
//   use near_sdk::test_utils::{get_logs, VMContextBuilder};
//   use near_sdk::{testing_env, AccountId};

  // part of writing unit tests is setting up a mock context
  // provide a `predecessor` here, it'll modify the default context
//   fn get_context(predecessor: AccountId) -> VMContextBuilder {
//     let mut builder = VMContextBuilder::new();
//     builder.predecessor_account_id(predecessor);
//     builder
//   }

  // TESTS HERE
// }

'''
'''--- ed25519_verification/verification_test.sh ---
near call ed25519-verification.testnet "ed25519_verify" '{"signature":  "d52884038ee9d5af3311a39faa48ead7f044b1154bde9b23e0935b5bf9b3a2f3afc528b56b2a56a440159ff1d944113763dc9d65d7a004d744ba23103bb68a0e", "serialize_message": "" , "public_key": "3YjRJM8h1cNPL3JXvkDrWCTXtXA9EhSsbdi3LA9NacCz"}' --accountId ed25519-verification.testnet

# 196625 // 2 Near
# 196625 - 143967
'''
'''--- identity-experiments/Cargo.toml ---
[package]
name = "identity-experiments"
version = "0.1.1"
edition = "2018"

[lib]
crate-type = ["cdylib","rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
hex = "0.4.2"
# slip10 = "0.4.3"
# ed25519-dalek = { version = "1" }
# bip39 = { version = "1.0.1"}
# getrandom = { version = "0.2.3", features = ["js"]}

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- identity-experiments/README.md ---
# NEAR protocol miniature test contract

## Run Tests

```
cargo test -- --nocapture
```

## Compile

```
cargo build --target wasm32-unknown-unknown --release
```

## Deploy to testnet

Login to your own testnet account with `near login` 

```
near deploy --wasmFile target/wasm32-unknown-unknown/release/near_identity.wasm --accountId YOUR_ACCOUNT_HERE
```

## Invoke Methods

```
near call YOUR_ACCOUNT_HERE new_registration --accountId YOUR_ACCOUNT_HERE
```
'''
'''--- identity-experiments/src/lib.rs ---
// use std::str::FromStr;
// use bip39::{Language, Mnemonic, Error};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::*;
use near_sdk::{
    // bs58,
    PanicOnDefault};
use near_sdk::{env, near_bindgen, Balance, Promise};
use near_sdk::json_types::Base58PublicKey;

near_sdk::setup_alloc!();

const INITIAL_BALANCE: Balance = 500_000_000_000_000_000_000_000; // 1e24yN, 0.5N

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ImplicitAccount {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    // latest_dsnp_id: u32,
    pub accounts: UnorderedMap<String, String>,
}

#[near_bindgen]
impl ImplicitAccount {

    #[init]
    pub fn new() -> Self {
        Self {
            // latest_dsnp_id: 0,
            accounts: UnorderedMap::new(b"s".to_vec()),
        }
    }

    // pub fn get_latest_dsnp(&self) -> u32 {
    //     return self.latest_dsnp_id;
    // }

    // pub fn new_registration(&mut self) {
    //     // note: adding one like this is an easy way to accidentally overflow
    //     // real smart contracts will want to have safety checks
    //     // e.g. self.val = i8::wrapping_add(self.val, 1);
    //     // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
    //     self.latest_dsnp_id += 1;
    //     let log_message = format!("Created DSNP Id: {}", self.latest_dsnp_id);
    //     //self.registrations.insert(self.latest_dsnp_id, handle);
    //     env::log(log_message.as_bytes());
    //     //after_registration();
    // }

    pub fn get_accounts_count(&self) -> u64 {
        return self.accounts.len();
    }

    // #[payable]
    // pub fn create_and_transfer_account(&mut self) {
    //     assert!(
    //         env::attached_deposit() >= INITIAL_BALANCE,
    //         "Attached deposit must be greater than INITIAL_BALANCE of .5 NEAR"
    //     );
    //     let new_public_key = ImplicitAccount::generate_pub_key();
    //     let public_key_string = bs58::encode(&new_public_key).into_string();
    //     let implicit_id = &hex::encode(new_public_key)[2..];
    //     env::log(format!("implicit id: {:?}", &implicit_id).as_bytes());
    //     let key = public_key_string.clone();
    //     Promise::new(implicit_id.into())
    //         .transfer(INITIAL_BALANCE);
    //     self.accounts.insert(&String::from(implicit_id), &key);
    //     println!("created new account {:?} with key {:?}", &implicit_id, key);
    // }

    //before calling this you must generate a keypair from a 12 word phrase 
    // generate an account from a public key
    #[payable]
    pub fn generate_implicit_account_from_key(&mut self, new_public_key: Base58PublicKey) {
        env::log(format!("deposit {}, balance limit {}", env::attached_deposit() , INITIAL_BALANCE).as_bytes());
        assert!(
            env::attached_deposit() >= INITIAL_BALANCE,
            "Attached deposit must be greater than INITIAL_BALANCE of .5 NEAR"
        );
        env::log(format!("key received: {:?}", new_public_key).as_bytes());
        let key = new_public_key.clone();
        let implicit_id = &hex::encode(new_public_key.0)[2..];
        env::log(format!("implicit id: {:?}", &implicit_id).as_bytes());
        Promise::new(implicit_id.into()) // skipping starting 00
            .transfer(INITIAL_BALANCE); // sending tokens will create the implicit account with used public key as a full access key
        self.accounts.insert(&String::from(implicit_id), &format!("{:?}", &key));
        env::log(format!("created new account {:?} with key {:?}", &implicit_id, key).as_bytes());
    }

    //from https://github.com/near/near-cli-rs/blob/12dfa268b72ba4778aedf898361f46c5136fc75f/src/commands/add_command/implicit_account/generate_keypair/mod.rs
    // fn generate_pub_key() -> ed25519_dalek::PublicKey {
    //     let seed_phrase_hd_path = slip10::BIP32Path::from_str("m/44'/397'/0'").unwrap();
    //
    //     let (master_seed_phrase, master_seed) = ImplicitAccount::generate_seed_phrase();
    //     env::log(format!("generated seed phrase {:?}", master_seed_phrase).as_bytes());
    //
    //     let derived_private_key = slip10::derive_key_from_path(
    //         &master_seed,
    //         slip10::Curve::Ed25519,
    //         &seed_phrase_hd_path,
    //     ).map_err(|err| {
    //         // color_eyre::Report::msg(format!("Key derivation from path failed: {:?}", err))
    //         env::log(format!("Error: {:?}", &err).as_bytes());
    //     })
    //     .unwrap();
    //
    //     let secret_keypair = {
    //         let secret = ed25519_dalek::SecretKey::from_bytes(&derived_private_key.key).unwrap();
    //         let public = ed25519_dalek::PublicKey::from(&secret);
    //         ed25519_dalek::Keypair { secret, public }
    //     };
    //     return secret_keypair.public;
    // }

    // fn generate_seed_phrase() -> (String, [u8; 64]) {
    //     let mnemonic = ImplicitAccount::generate_in_with(Language::English,12).unwrap();
    //     // let mnemonic = bip39::Mnemonic::generate_in_with(&mut rand::rngs::ThreadRng(),Language::English,12).unwrap();
    //     let mut master_seed_phrase = String::new();
    //     for (index, word) in mnemonic.word_iter().enumerate() {
    //         if index != 0 {
    //             master_seed_phrase.push(' ');
    //         }
    //         master_seed_phrase.push_str(word);
    //     }
    //     (master_seed_phrase, mnemonic.to_seed(""))
    // }
    //
    // fn generate_in_with(
    //     language: Language,
    //     word_count: usize,
    // ) -> Result<Mnemonic, Error>
    // {
    //     let entropy_bytes = (word_count / 3) * 4;
    //     let mut entropy = [0u8; (24 / 3) * 4];
    //
    //     getrandom::getrandom(&mut entropy[0..entropy_bytes]);
    //     // my_rng.fill_bytes( &mut entropy[0..entropy_bytes]);
    //     Mnemonic::from_entropy_in(language, &entropy[0..entropy_bytes])
    // }
}

#[cfg(test)]
mod tests {
    use std::convert::TryInto;
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // part of writing unit tests is setting up a mock context
    // in this example, this is only needed for env::log in the contract
    // this is also a useful list to peek at when wondering what's available in env::*
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 700_000_000_000_000_000_000_000,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn create_and_transfer_account() {
        // set up the mock context into the testing environment
        let context = get_context(vec![], false);
        testing_env!(context);
        // instantiate a contract variable with the counter at zero
        let mut contract = ImplicitAccount::new();

        //near generate-key --seedPhrase "silk thank piano other pull forum sure group dignity spend sun potato"
        //Key pair with ed25519:2uy3CUJo3tB3fvDoozoenrYR2Ub4zQBVMx98VkjYpXue public key for an account "1c6d40519f3ccf17e81bab51cb1f7daeeda6cc2c93ade2d9510f2dfd9bad2a6d"
        contract.generate_implicit_account_from_key( "ed25519:2uy3CUJo3tB3fvDoozoenrYR2Ub4zQBVMx98VkjYpXue".try_into().unwrap());
        // confirm that we added an account to the array
        assert_eq!(1, contract.get_accounts_count());
    }
}
'''
'''--- modified-linkdrop/Cargo.toml ---
[package]
name = "modified-linkdrop"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "=3.1.0"

[workspace]
members = []

'''
'''--- modified-linkdrop/README.md ---
# Modified LinkDrop contract (Allows creation of top level accounts)

LinkDrop contract allows any user to create a link that their friends can use to claim tokens even if they don't have an account yet.

The way it works:

Sender, that has NEAR:
- Creates a new key pair `(pk1, privkey1)`.
- Calls `linkdrop.send(pk1)` with attached balance of NEAR that they want to send.
- Sends a link to any supported wallet app with `privkey1` as part of URL.

Receiver, that doesn't have NEAR:
- Receives link to the wallet with `privkey1`.
- Wallet creates new key pair for this user (or they generate it via HSM) `(pk2, privkey2)`.
- Enters the `new_account_id` receiver want for their new account.
- Wallet creates a transaction to `linkdrop.create_account_and_claim(new_account_id, pk2)`.
- Contract creates new account with `new_account_id` name and `pk2` as full access key and transfers NEAR that Sender sent.

If Receiver already has account (or Sender wants to get back the money):
- Sign tx with `privkey1` to call `linkdrop.claim()`, which transfers money to signer's account.

'''
'''--- modified-linkdrop/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/modified_linkdrop.wasm ./res/

'''
'''--- modified-linkdrop/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde_json::json;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, Promise, PromiseResult, PublicKey, Gas
};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LinkDrop {
    pub accounts: LookupMap<PublicKey, Balance>,
    pub deploy_keys: UnorderedSet<PublicKey>,
}

/// Access key allowance for linkdrop keys.
const ACCESS_KEY_ALLOWANCE: u128 = 100_000_000_000_000_000_000_000;

/// Gas attached to the callback from account creation or contract deployment.
pub const ON_CALLBACK_GAS: u64 = 20_000_000_000_000;

/// Indicates there are no deposit for a callback for better readability.
const NO_DEPOSIT: u128 = 0;

/// process ran out of Gas with 20_000_000_000_000
const GAS: Gas = 40_000_000_000_000;

/// should ideally get from environment variables
const NET_CONTRACT_ID: &str = "testnet";

#[ext_contract(ext_self)]
pub trait ExtLinkDrop {
    /// Callback after plain account creation.
    fn on_account_created(&mut self, predecessor_account_id: AccountId, amount: U128) -> bool;

    /// Callback after creating account and claiming linkdrop.
    fn on_account_created_and_claimed(&mut self, amount: U128) -> bool;
}

fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}
impl Default for LinkDrop {
    fn default() -> Self {
        let this = Self {
            accounts: LookupMap::new(b'a'.try_to_vec().unwrap()),
            deploy_keys: UnorderedSet::new(b'c'.try_to_vec().unwrap()),
        };
        this
    }
}

#[near_bindgen]
impl LinkDrop {
    /// Allows given public key to claim sent balance.
    /// Takes ACCESS_KEY_ALLOWANCE as fee from deposit to cover account creation via an access key.
    #[payable]
    pub fn send(&mut self, public_key: Base58PublicKey) -> Promise {
        assert!(
            env::attached_deposit() > ACCESS_KEY_ALLOWANCE,
            "Attached deposit must be greater than ACCESS_KEY_ALLOWANCE"
        );
        let pk = public_key.into();
        let value = self.accounts.get(&pk).unwrap_or(0);
        self.accounts.insert(
            &pk,
            &(value + env::attached_deposit() - ACCESS_KEY_ALLOWANCE),
        );
        Promise::new(env::current_account_id()).add_access_key(
            pk,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            b"claim,create_account_and_claim".to_vec(),
        )
    }

    /// Claim tokens for specific account that are attached to the public key this tx is signed with.
    pub fn claim(&mut self, account_id: AccountId) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );
        let amount = self
            .accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");
        Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());
        Promise::new(account_id).transfer(amount)
    }

    /// Create new account and and claim tokens to it.
    /// We can not deploy contract from this method since we don't have access key of new created account
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: Base58PublicKey,
    ) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Create account and claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(new_account_id.as_bytes()),
            "Invalid account id"
        );
        let amount = self
            .accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");

        // calling system contract to delegate account creation
        Promise::new( NET_CONTRACT_ID.to_string())
            .function_call(
                b"create_account".to_vec(),
                json!({ "new_account_id": new_account_id, "new_public_key": new_public_key}).to_string().as_bytes().to_vec(),
                amount,
                GAS,
            )
            .then(
            ext_self::on_account_created_and_claimed(
                amount.into(),
                &env::current_account_id(),
                NO_DEPOSIT,
                ON_CALLBACK_GAS
            ))
    }

    /// Create new account without linkdrop and deposit passed funds (used for creating sub accounts directly).
    #[payable]
    pub fn create_account(
        &mut self,
        new_account_id: AccountId,
        new_public_key: Base58PublicKey,
    ) -> Promise {
        assert!(
            env::is_valid_account_id(new_account_id.as_bytes()),
            "Invalid account id"
        );
        let amount = env::attached_deposit();
        Promise::new(new_account_id)
            .create_account()
            .add_full_access_key(new_public_key.into())
            .transfer(amount)
            .then(ext_self::on_account_created(
                env::predecessor_account_id(),
                amount.into(),
                &env::current_account_id(),
                NO_DEPOSIT,
                ON_CALLBACK_GAS,
            ))
    }

    /// Callback after executing `create_account`.
    pub fn on_account_created(&mut self, predecessor_account_id: AccountId, amount: U128) -> bool {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Callback can only be called from the contract"
        );
        let creation_succeeded = is_promise_success();
        if !creation_succeeded {
            // In case of failure, send funds back.
            Promise::new(predecessor_account_id).transfer(amount.into());
        }
        creation_succeeded
    }

    /// Callback after execution `create_account_and_claim`.
    pub fn on_account_created_and_claimed(&mut self, amount: U128) -> bool {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Callback can only be called from the contract"
        );
        let creation_succeeded = is_promise_success();
        if creation_succeeded {
            Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());
        } else {
            // In case of failure, put the amount back.
            self.accounts
                .insert(&env::signer_account_pk(), &amount.into());
        }
        creation_succeeded
    }

    /// Returns the balance associated with given key.
    pub fn get_key_balance(&self, key: Base58PublicKey) -> U128 {
        self.accounts.get(&key.into()).expect("Key is missing").into()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, BlockHeight, PublicKey, VMContext};

    use super::*;

    pub struct VMContextBuilder {
        context: VMContext,
    }

    impl VMContextBuilder {
        pub fn new() -> Self {
            Self {
                context: VMContext {
                    current_account_id: "".to_string(),
                    signer_account_id: "".to_string(),
                    signer_account_pk: vec![0, 1, 2],
                    predecessor_account_id: "".to_string(),
                    input: vec![],
                    block_index: 0,
                    epoch_height: 0,
                    block_timestamp: 0,
                    account_balance: 0,
                    account_locked_balance: 0,
                    storage_usage: 10u64.pow(6),
                    attached_deposit: 0,
                    prepaid_gas: 10u64.pow(18),
                    random_seed: vec![0, 1, 2],
                    is_view: false,
                    output_data_receivers: vec![],
                },
            }
        }

        pub fn current_account_id(mut self, account_id: AccountId) -> Self {
            self.context.current_account_id = account_id;
            self
        }

        #[allow(dead_code)]
        pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
            self.context.signer_account_id = account_id;
            self
        }

        pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
            self.context.predecessor_account_id = account_id;
            self
        }

        #[allow(dead_code)]
        pub fn block_index(mut self, block_index: BlockHeight) -> Self {
            self.context.block_index = block_index;
            self
        }

        pub fn attached_deposit(mut self, amount: Balance) -> Self {
            self.context.attached_deposit = amount;
            self
        }

        pub fn account_balance(mut self, amount: Balance) -> Self {
            self.context.account_balance = amount;
            self
        }

        #[allow(dead_code)]
        pub fn account_locked_balance(mut self, amount: Balance) -> Self {
            self.context.account_locked_balance = amount;
            self
        }

        pub fn signer_account_pk(mut self, pk: PublicKey) -> Self {
            self.context.signer_account_pk = pk;
            self
        }

        pub fn finish(self) -> VMContext {
            self.context
        }
    }

    fn linkdrop() -> String {
        "linkdrop".to_string()
    }

    fn bob() -> String {
        "bob".to_string()
    }

    #[test]
    fn test_create_account() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        let deposit = 1_000_000;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.create_account(bob(), pk);
        // TODO: verify that promise was created with funds for given username.
    }

    #[test]
    #[should_panic]
    fn test_create_invalid_account() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        let deposit = 1_000_000;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.create_account("XYZ".to_string(), pk);
    }

    #[test]
    #[should_panic]
    fn test_get_missing_balance_panics() {
        let contract = LinkDrop::default();
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .finish());
        contract.get_key_balance("qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz".try_into().unwrap());
    }

    #[test]
    fn test_get_missing_balance_success() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        let deposit = ACCESS_KEY_ALLOWANCE * 100;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.send(pk.clone());
        // try getting the balance of the key
        let balance:u128 = contract.get_key_balance(pk.try_into().unwrap()).try_into().unwrap();
        assert_eq!(
            balance,
            deposit - ACCESS_KEY_ALLOWANCE
        );
    }

    #[test]
    #[should_panic]
    fn test_claim_invalid_account() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        // Deposit money to linkdrop contract.
        let deposit = ACCESS_KEY_ALLOWANCE * 100;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.send(pk.clone());
        // Now, send new transaction to link drop contract.
        let context = VMContextBuilder::new()
            .current_account_id(linkdrop())
            .predecessor_account_id(linkdrop())
            .signer_account_pk(pk.into())
            .account_balance(deposit)
            .finish();
        testing_env!(context);
        let pk2 = "2S87aQ1PM9o6eBcEXnTR5yBAVRTiNmvj8J8ngZ6FzSca"
            .try_into()
            .unwrap();
        contract.create_account_and_claim("XYZ".to_string(), pk2);
    }

    #[test]
    fn test_drop_claim() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        // Deposit money to linkdrop contract.
        let deposit = ACCESS_KEY_ALLOWANCE * 100;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.send(pk.clone());
        // Now, send new transaction to link drop contract.
        let context = VMContextBuilder::new()
            .current_account_id(linkdrop())
            .predecessor_account_id(linkdrop())
            .signer_account_pk(pk.into())
            .account_balance(deposit)
            .finish();
        testing_env!(context);
        let pk2 = "2S87aQ1PM9o6eBcEXnTR5yBAVRTiNmvj8J8ngZ6FzSca"
            .try_into()
            .unwrap();
        contract.create_account_and_claim(bob(), pk2);
        // TODO: verify that proper promises were created.
    }

    #[test]
    fn test_send_two_times() {
        let mut contract = LinkDrop::default();
        let pk: Base58PublicKey = "qSq3LoufLvTCTNGC3LJePMDGrok8dHMQ5A1YD9psbiz"
            .try_into()
            .unwrap();
        // Deposit money to linkdrop contract.
        let deposit = ACCESS_KEY_ALLOWANCE * 100;
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .attached_deposit(deposit)
            .finish());
        contract.send(pk.clone());
        assert_eq!(contract.get_key_balance(pk.clone()), (deposit - ACCESS_KEY_ALLOWANCE).into());
        testing_env!(VMContextBuilder::new()
            .current_account_id(linkdrop())
            .account_balance(deposit)
            .attached_deposit(deposit + 1)
            .finish());
        contract.send(pk.clone());
        assert_eq!(
            contract.accounts.get(&pk.into()).unwrap(),
            deposit + deposit + 1 - 2 * ACCESS_KEY_ALLOWANCE
        );
    }
}

'''
'''--- registry/Cargo.toml ---
[package]
name = "registry"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- registry/README.md ---
# Registry contract

Example smart contract to hold registry information (handle, dsnpId, address?)
'''
'''--- registry/build.sh ---
#!/bin/bash
set -e

if [ -d "res" ]; then
  echo ""
else
  mkdir res
fi

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- registry/src/lib.rs ---
mod storage_impl;

use near_contract_standards::storage_management::StorageManagement;
use near_sdk::{
    env, near_bindgen, AccountId, PanicOnDefault, BorshStorageKey,StorageUsage, Balance, Promise,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, UnorderedMap},
    json_types::{U128, ValidAccountId},
    serde::{Deserialize, Serialize}
};

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    Registrations,
    AccountsIdMap,
}

#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct User {
    // registered account id
    pub account_id: AccountId,

    // storage balance
    pub balance: U128,
}

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Registry {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    registration_map: UnorderedMap<u32, User>,
    account_id_map: LookupMap<AccountId, u32>,
    dsnp_id_index: u32,

    // Storage
    account_storage_usage: StorageUsage,
}

#[near_bindgen]
impl Registry {

    #[init]
    pub fn new() -> Self {
        // Initializing `status_updates` with unique key prefix.
        let mut this = Self {
            registration_map: UnorderedMap::new(StorageKeys::Registrations),
            account_id_map: LookupMap::new(StorageKeys::AccountsIdMap),
            dsnp_id_index: 0,
            account_storage_usage: 0,
        };
        this.measure_account_storage_usage();
        this
    }

    /// Measure the storage an registry will take and need to provide
    fn measure_account_storage_usage(&mut self) {
        let initial_storage_usage = env::storage_usage();
        // Create a temporary, dummy entry and measure the storage used.
        let tmp_dsnp_id = 0; // using zero since valid ones starts from 1
        let tmp_account_id = "0".repeat(64);
        self.register_account_internal(&tmp_account_id.clone().into(), Some(tmp_dsnp_id));
        self.account_storage_usage = env::storage_usage() - initial_storage_usage;
        // Remove the temporary entry.
        self.remove_account_internal(&tmp_account_id.into());
    }

    // Register a new dsnpId
    // param account_id - account id to register (contains handle)
    // saves dsnp id to map of handle records
    #[payable]
    pub fn register(&mut self, account_id: ValidAccountId) -> u32 {
        let deposit: Balance = env::attached_deposit();
        let required_deposit: Balance = Balance::from(self.account_storage_usage) * env::storage_byte_cost();

        assert!(
            deposit >= required_deposit,
            "Insufficient deposit. Please deposit {} yoctoⓃ to register an agent.",
            required_deposit.clone()
        );

        // check that account isn't already added
        if let Some(account) = self.account_id_map.get(&account_id.as_ref().into()) {
            let panic_msg = format!("Account already exists: {:?}. Refunding the deposit.", account);
            env::panic(panic_msg.as_bytes());
        };

        let new_id = self.register_account_internal(account_id.as_ref().into(), None);
        env::log(format!("Registered {} to DSNP ID: {}", &account_id, new_id).as_bytes());

        // If the user deposited more than needed, refund them.
        let refund = deposit - required_deposit;
        if refund > 0 {
            Promise::new(env::predecessor_account_id()).transfer(refund);
        }

        new_id
    }

    /// Removes the account fro registered list
    /// Withdraws storage balances to the account.
    /// Requires attaching 1 yoctoⓃ ensure it comes from a full-access key.
    #[payable]
    pub fn unregister(&mut self) {
        // This method name is quite explicit, so calling storage_unregister and setting the 'force' option to true.
        self.storage_unregister(Some(true));
    }

    pub fn get_account_storage(self) -> StorageUsage {
        self.account_storage_usage
    }

    pub fn get_address(self, dsnp_id: u32) -> Option<User> {
        self.registration_map.get(&dsnp_id)
    }

    pub fn get_registration(self, account_id: ValidAccountId) -> Option<u32> {
        self.account_id_map.get(&account_id.into())
    }

    fn register_account_internal(&mut self, account_id: &AccountId, optional_id: Option<u32>) -> u32 {

        let new_id = match optional_id {
            Some(id) => id,
            None => {
                self.dsnp_id_index += 1;
                self.dsnp_id_index
            }
        };

        let user = User {
            balance: U128(Balance::from(self.account_storage_usage) * env::storage_byte_cost()),
            account_id: account_id.into(),
        };

        self.registration_map.insert(&new_id, &user);
        self.account_id_map.insert( account_id, &new_id);
        new_id
    }

    fn remove_account_internal(&mut self, account_id: &AccountId) {
        if let Some(registration_id) = self.account_id_map.get(account_id) {
            self.registration_map.remove(&registration_id);
            self.account_id_map.remove(account_id);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // part of writing unit tests is setting up a mock context
    // in this example, this is only needed for env::log in the contract
    // this is also a useful list to peek at when wondering what's available in env::*
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // mark individual unit tests with #[test] for them to be registered and fired
    #[test]
    fn new_registration() {
        // arrange
        let mut context = get_context(vec![], false);
        context.attached_deposit = 10u128.pow(22).into();
        testing_env!(context);

        // act
        let mut contract = Registry::new();
        let id = contract.register("ashley.dsnp.testnet".try_into().unwrap());
        let received = contract.get_address(id);

        // assert
        assert!(received.is_some());
        assert_eq!("ashley.dsnp.testnet", received.as_ref().unwrap().account_id);
        assert!(received.as_ref().unwrap().balance.0 > 0);
    }

    // test panics due to some unknown issue in deserializing the value inside
    // self.registration_map.remove(&registration_id) call
    // this issue does not exists in testnet and only happens in local tests
    // #[test]
    // fn register_unregister() {
    //     // arrange
    //     let mut context = get_context(vec![], false);
    //     context.attached_deposit = 10u128.pow(22).into();
    //     testing_env!(context);
    //
    //     // act
    //     let mut contract = Registry::new();
    //     let id = contract.register("ashley.dsnp.testnet".try_into().unwrap());
    //
    //     context = get_context(vec![], false);
    //     context.attached_deposit = 1u128;
    //     context.predecessor_account_id = "ashley.dsnp.testnet".try_into().unwrap();
    //     testing_env!(context);
    //     contract.unregister();
    //     let received = contract.get_address(id);
    //
    //     // assert
    //     assert!(received.is_none(), "Account should not exists");
    // }
}
'''
'''--- registry/src/storage_impl.rs ---
use crate::{Registry};
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{assert_one_yocto, env, log, AccountId, Balance, Promise};

impl Registry {
    fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        if self.account_id_map.contains_key(account_id) {
            // The "available" balance is always zero because the storage isn't
            // variable for this contract.
            let user = self.registration_map.get(&self.account_id_map.get(account_id).unwrap()).unwrap();
            Some(StorageBalance {
                total: user.balance,
                available: 0.into(),
            })
        } else {
            None
        }
    }
}

impl StorageManagement for Registry {
    // `registration_only` doesn't affect the implementation here, as there's no need to add additional
    // storage, so there's only one balance to attach.
    #[allow(unused_variables)]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        self.register(account_id.clone().try_into().unwrap());
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    /// While storage_withdraw normally allows the caller to retrieve `available` balance, this
    /// contract sets storage_balance_bounds.min = storage_balance_bounds.max,
    /// which means available balance will always be 0. So this implementation:
    /// * panics if `amount > 0`
    /// * never transfers Ⓝ to caller
    /// * returns a `storage_balance` struct if `amount` is 0
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let predecessor = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&predecessor) {
            match amount {
                Some(amount) if amount.0 > 0 => {
                    let panic_msg = format!("The amount is greater than the available storage balance. Remember there's a minimum balance needed for an account's storage. That minimum is {}. To unregister an account, use the 'unregister' or 'storage_unregister' with the 'force' option.", self.account_storage_usage);
                    env::panic(panic_msg.as_bytes());
                }
                _ => storage_balance,
            }
        } else {
            env::panic(format!("The account {} is not registered", &predecessor).as_bytes());
        }
    }

    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let force = force.unwrap_or(false);
        if let Some(registration_id) = self.account_id_map.get(&account_id) {
            let user = self.registration_map.get(&registration_id).unwrap();
            let balance = user.balance.0;
            if balance == 0 || force {

                self.remove_account_internal(&account_id.clone());

                // We add 1 to reimburse for the 1 yoctoⓃ used to call this method
                Promise::new(account_id).transfer(balance + 1);
                log!(
                    "Agent has been removed and refunded the storage cost of {}",
                    balance + 1
                );
                true
            } else {
                env::panic(b"Can't unregister the account with the positive balance. Must use the 'force' parameter if desired.")
            }
        } else {
            log!("The account {} is not registered", &account_id);
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        let required_storage_balance =
            Balance::from(self.account_storage_usage) * env::storage_byte_cost();
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(account_id.as_ref())
    }
}

'''
'''--- self-upgrade/Cargo.toml ---
[package]
name = "self-upgrade"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = {version = "4.0.0-pre.4", features = ["unstable"]}

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = true
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- self-upgrade/README.md ---
# Self upgrading contract

This contract is able to get contract wasm file in a function call and upgrade itself
'''
'''--- self-upgrade/build.sh ---
#!/bin/bash
set -e

if [ -d "res" ]; then
  echo ""
else
  mkdir res
fi

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- self-upgrade/file-uploader/index.js ---
const nearApi = require('near-api-js');
const fs = require("fs");
const os = require("os");

const accountId = 'dev-1637796671006-59179411080268';
const contractId = 'dev-1637796671006-59179411080268';
const method = 'store_blob';
const gas = '100000000000000';
const network = 'testnet';
const rpc = 'https://rpc.testnet.near.org';
const contractPath = '../res/self_upgrade.wasm';
const near_cred = os.homedir() + '/.near-credentials';

async function GetAccount(account_id) {
    try {
        console.log(near_cred);
        const fileKeyStore = new nearApi.keyStores.UnencryptedFileSystemKeyStore(near_cred);
        const keyPair = await fileKeyStore.getKey(network, accountId);
        console.log(keyPair);
        const keyStore = new nearApi.keyStores.InMemoryKeyStore();
        await keyStore.setKey("testnet", account_id, keyPair);
        const near = await nearApi.connect({
            networkId: network,
            deps: {keyStore},
            masterAccount: account_id,
            nodeUrl: rpc
        });

        return await near.account(account_id);
    } catch (e) {
        console.log(e);
    }
}

async function upload(account_id, recipient) {
    try {
        const data = Uint8Array.from([...fs.readFileSync(contractPath)]);
        const account = await GetAccount(account_id);
        return await account.functionCall(
            recipient,
            method,
            data,
            gas,
            0);
    } catch (e) {
        console.log(e);
    }
}

upload(accountId, contractId).then(v => console.log(v));

'''
'''--- self-upgrade/file-uploader/package-lock.json ---
{
  "name": "file-uploader",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "file-uploader",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "fs": "*",
        "near-api-js": "~0.38.0",
        "os": "^0.1.2"
      }
    },
    "node_modules/@types/bn.js": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-5.1.0.tgz",
      "integrity": "sha512-QSSVYj7pYFN49kW77o2s9xTCwZ8F2xLbjLLSEVh8D2F4JUhZtPAGOFLTD+ffqksBx/u4cE/KImFjyhqCjn/LIA==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "16.11.10",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-16.11.10.tgz",
      "integrity": "sha512-3aRnHa1KlOEEhJ6+CvyHKK5vE9BcLGjtUpwvqYLRvYNQKMfabu3BwfJaA/SLW8dxe28LsNDjtHwePTuzn3gmOA=="
    },
    "node_modules/base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "node_modules/borsh": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.3.1.tgz",
      "integrity": "sha512-gJoSTnhwLxN/i2+15Y7uprU8h3CKI+Co4YKZKvrGYUy0FwHWM20x5Sx7eU8Xv4HQqV+7rb4r3P7K1cBIQe3q8A==",
      "dependencies": {
        "@types/bn.js": "^4.11.5",
        "bn.js": "^5.0.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "node_modules/borsh/node_modules/@types/bn.js": {
      "version": "4.11.6",
      "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-4.11.6.tgz",
      "integrity": "sha512-pqr857jrp2kPuO9uRjZ3PwnJTjoQy+fcdxvBTvHm6dkmEL9q+hDD/2j/0ELOBPtPnS8LjCX0gI9nbl8lVkadpg==",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
      "dependencies": {
        "base-x": "^3.0.2"
      }
    },
    "node_modules/capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE="
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "dependencies": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "node_modules/fs": {
      "version": "0.0.1-security",
      "resolved": "https://registry.npmjs.org/fs/-/fs-0.0.1-security.tgz",
      "integrity": "sha1-invTcYa23d84E/I4WLV+yq9eQdQ="
    },
    "node_modules/http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "dependencies": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-errors/node_modules/depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "node_modules/mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
      "bin": {
        "mustache": "bin/mustache"
      }
    },
    "node_modules/near-api-js": {
      "version": "0.38.0",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.38.0.tgz",
      "integrity": "sha512-y6N5eRyUQvVKkUUYCPl5P2a8xG7bQXU6D7aiUyiPv8VILhaIPvXRdC0QR+cpkEw4X+OH1FWbSB+VFTByQe3hZQ==",
      "dependencies": {
        "@types/bn.js": "^5.1.0",
        "bn.js": "^5.0.0",
        "borsh": "^0.3.1",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.2",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.6.6",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.6.tgz",
      "integrity": "sha512-Z8/6vRlTUChSdIgMa51jxQ4lrw/Jy5SOW10ObaA47/RElsAN2c5Pn8bTgFGWn/ibwzXTE8qwr1Yzx28vsecXEA==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      }
    },
    "node_modules/o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
      "dependencies": {
        "capability": "^0.2.5"
      }
    },
    "node_modules/os": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/os/-/os-0.1.2.tgz",
      "integrity": "sha512-ZoXJkvAnljwvc56MbvhtKVWmSkzV712k42Is2mA0+0KTSRakq5XXuXpjZjgAt9ctzl51ojhQWakQQpmOvXWfjQ=="
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha1-gYT9NH2snNwYWZLzpmIuFLnZq2o="
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "node_modules/u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha1-JFNCdeKnvGvnvIZhHMFq4KVlSHE="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha1-lmRU6HZUYuN2RNNib2dCzotwll0=",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  },
  "dependencies": {
    "@types/bn.js": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-5.1.0.tgz",
      "integrity": "sha512-QSSVYj7pYFN49kW77o2s9xTCwZ8F2xLbjLLSEVh8D2F4JUhZtPAGOFLTD+ffqksBx/u4cE/KImFjyhqCjn/LIA==",
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/node": {
      "version": "16.11.10",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-16.11.10.tgz",
      "integrity": "sha512-3aRnHa1KlOEEhJ6+CvyHKK5vE9BcLGjtUpwvqYLRvYNQKMfabu3BwfJaA/SLW8dxe28LsNDjtHwePTuzn3gmOA=="
    },
    "base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "borsh": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.3.1.tgz",
      "integrity": "sha512-gJoSTnhwLxN/i2+15Y7uprU8h3CKI+Co4YKZKvrGYUy0FwHWM20x5Sx7eU8Xv4HQqV+7rb4r3P7K1cBIQe3q8A==",
      "requires": {
        "@types/bn.js": "^4.11.5",
        "bn.js": "^5.0.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      },
      "dependencies": {
        "@types/bn.js": {
          "version": "4.11.6",
          "resolved": "https://registry.npmjs.org/@types/bn.js/-/bn.js-4.11.6.tgz",
          "integrity": "sha512-pqr857jrp2kPuO9uRjZ3PwnJTjoQy+fcdxvBTvHm6dkmEL9q+hDD/2j/0ELOBPtPnS8LjCX0gI9nbl8lVkadpg==",
          "requires": {
            "@types/node": "*"
          }
        }
      }
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw=="
    },
    "error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "requires": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "fs": {
      "version": "0.0.1-security",
      "resolved": "https://registry.npmjs.org/fs/-/fs-0.0.1-security.tgz",
      "integrity": "sha1-invTcYa23d84E/I4WLV+yq9eQdQ="
    },
    "http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "dependencies": {
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
        }
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ=="
    },
    "near-api-js": {
      "version": "0.38.0",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.38.0.tgz",
      "integrity": "sha512-y6N5eRyUQvVKkUUYCPl5P2a8xG7bQXU6D7aiUyiPv8VILhaIPvXRdC0QR+cpkEw4X+OH1FWbSB+VFTByQe3hZQ==",
      "requires": {
        "@types/bn.js": "^5.1.0",
        "bn.js": "^5.0.0",
        "borsh": "^0.3.1",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.2",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node-fetch": {
      "version": "2.6.6",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.6.tgz",
      "integrity": "sha512-Z8/6vRlTUChSdIgMa51jxQ4lrw/Jy5SOW10ObaA47/RElsAN2c5Pn8bTgFGWn/ibwzXTE8qwr1Yzx28vsecXEA==",
      "requires": {
        "whatwg-url": "^5.0.0"
      }
    },
    "o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
      "requires": {
        "capability": "^0.2.5"
      }
    },
    "os": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/os/-/os-0.1.2.tgz",
      "integrity": "sha512-ZoXJkvAnljwvc56MbvhtKVWmSkzV712k42Is2mA0+0KTSRakq5XXuXpjZjgAt9ctzl51ojhQWakQQpmOvXWfjQ=="
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA=="
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha1-gYT9NH2snNwYWZLzpmIuFLnZq2o="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha1-JFNCdeKnvGvnvIZhHMFq4KVlSHE="
    },
    "whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha1-lmRU6HZUYuN2RNNib2dCzotwll0=",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  }
}

'''
'''--- self-upgrade/file-uploader/package.json ---
{
  "name": "file-uploader",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "fs": "*",
    "near-api-js": "~0.38.0",
    "os": "^0.1.2"
  }
}

'''
'''--- self-upgrade/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, Gas, PromiseOrValue};
use near_sdk::json_types::{Base58CryptoHash};

pub const VERSION: u32 = 1;

/// Raw type for 32 bytes of the hash.
pub type CryptoHash = [u8; 32];

/// Gas for upgrading this contract on promise creation + deploying new contract.
pub const GAS_FOR_UPGRADE_SELF_DEPLOY: Gas = Gas(30_000_000_000_000);

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Identity {
    handle: String,
}

impl Default for Identity {
    fn default() -> Self {
        env::panic_str("SubAccountFactory should be initialized before usage")
    }
}

#[near_bindgen]
impl Identity {
    #[init]
    pub fn new(handle: String) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        Self {
            handle,
        }
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    /// After migrate goes live on MainNet, return this implementation for next updates.
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "ERR_NOT_ALLOWED"
        );
        let this: Identity = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        this
    }

    pub fn upgrade(hash: &Base58CryptoHash) -> PromiseOrValue<()> {
        upgrade_self(&CryptoHash::from(hash.clone()));
        PromiseOrValue::Value(())
    }

    pub fn get_handle(&self) -> &String {
        &self.handle
    }

    pub fn get_version() -> u32 {
        VERSION
    }
}

// Stores attached data into blob store and returns hash of it.
/// Implemented to avoid loading the data into WASM for optimal gas usage.
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn store_blob() {
    use near_sdk::sys;
    env::setup_panic_hook();
    // let mut identity: Identity = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    let identity: Identity = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
    unsafe {
        // Load input into register 0.
        sys::input(0);
        // Compute sha256 hash of register 0 and store in 1.
        sys::sha256(u64::MAX as _, 0 as _, 1);
        // Check if such blob already stored.
        assert_eq!(
            sys::storage_has_key(u64::MAX as _, 1 as _),
            0,
            "ERR_ALREADY_EXISTS"
        );
        // Get length of the input argument and check that enough $NEAR has been attached.
        let blob_len = near_sdk::sys::register_len(0);
        let storage_cost = ((blob_len + 32) as u128) * env::storage_byte_cost();
        env::log_str(format!("storage cost {}", storage_cost).as_str());
        // assert!(
        //     env::attached_deposit() >= storage_cost,
        //     "ERR_NOT_ENOUGH_DEPOSIT:{}",
        //     storage_cost
        // );
        // identity.locked_amount += storage_cost;
        // Store value of register 0 into key = register 1.
        sys::storage_write(u64::MAX as _, 1 as _, u64::MAX as _, 0 as _, 2);
        // Load register 1 into blob_hash and save into LookupMap.
        let blob_hash = [0u8; 32];
        sys::read_register(1, blob_hash.as_ptr() as _);
        // identity
        //     .blobs
        //     .insert(&blob_hash, &env::predecessor_account_id());
        // Return from function value of register 1.
        let blob_hash_str = near_sdk::serde_json::to_string(&Base58CryptoHash::from(blob_hash))
            .unwrap()
            .into_bytes();
        sys::value_return(blob_hash_str.len() as _, blob_hash_str.as_ptr() as _);
    }
    env::state_write(&identity);
}

/// Self upgrade, optimizes gas by not loading into memory the code.
pub fn upgrade_self(hash: &[u8]) {
    let current_id = env::current_account_id();
    let method_name = "migrate".as_bytes().to_vec();
    let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_UPGRADE_SELF_DEPLOY;
    use near_sdk::sys;
    unsafe {
        // Load input (wasm code) into register 0.
        sys::storage_read(hash.len() as _, hash.as_ptr() as _, 0);
        // schedule a Promise tx to this same contract
        let promise_id = sys::promise_batch_create(
            current_id.as_bytes().len() as _,
            current_id.as_bytes().as_ptr() as _,
        );
        // 1st item in the Tx: "deploy contract" (code is taken from register 0)
        sys::promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
        // 2nd item in the Tx: call this_contract.migrate() with remaining gas
        sys::promise_batch_action_function_call(
            promise_id,
            method_name.len() as _,
            method_name.as_ptr() as _,
            0 as _,
            0 as _,
            0 as _,
            attached_gas.0,
        );
    }
}
'''
'''--- sub-account-factory/Cargo.toml ---
[package]
name = "sub-account-factory"
version = "0.1.0"
edition = "2021"
publish = false

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.4"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = true
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- sub-account-factory/README.md ---
# Sub-Account Factory

Creates sub-accounts using a counter (starting from 1001).

![Factory diagram](sub_account_factory.png?raw=true "Factory Diagram")

This is directly adapted from **[Sputnikdao-factory2](https://github.com/near-daos/sputnik-dao-contract/tree/main/sputnikdao-factory2)**

## TestNet

```
near dev-deploy --wasmFile=res/sub_account_factory.wasm

# bash
CONTRACT_ID="<generated dev account>"

# Initialize the factory.
near call $CONTRACT_ID new '{}' --accountId $CONTRACT_ID 

# Create a new SubAccount with the given parameters.
near call $CONTRACT_ID create '{"public_key": null}'  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# Create a new SubAccount with the given parameters while having Full Access Key to the account (trusted, but useful in case of testing or upgrades)
near call $CONTRACT_ID create '{"public_key": "<public key>"}'  --accountId $CONTRACT_ID --amount 30 --gas 100000000000000

# List all created accounts.
near view $CONTRACT_ID get_accounts_list
```

'''
'''--- sub-account-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/sub_account_factory.wasm ./res/

'''
'''--- sub-account-factory/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::{
    // Base64VecU8,
    U128};
use near_sdk::{assert_self, env, ext_contract, near_bindgen, AccountId, Gas, Promise, PublicKey, Balance};

const CODE: &[u8] = include_bytes!("../identity/rust_counter_tutorial.wasm");

/// Gas spent on the call & account creation.
// const CREATE_CALL_GAS: Gas = Gas(75_000_000_000_000);

/// Gas allocated on the callback.
const ON_CREATE_CALL_GAS: Gas = Gas(10_000_000_000_000);

const FUNCTION_KEY_ALLOWANCE: Balance = 250_000_000_000_000_000_000_000;

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_create(
        &mut self,
        account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool;
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct SubAccountFactory {
    accounts: UnorderedSet<AccountId>,
    dsnp_id: u64,
}

impl Default for SubAccountFactory {
    fn default() -> Self {
        env::panic_str("SubAccountFactory should be initialized before usage")
    }
}

#[near_bindgen]
impl SubAccountFactory {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        Self {
            accounts: UnorderedSet::new(b"d".to_vec()),
            dsnp_id: 1000,
        }
    }

    pub fn get_accounts_list(&self) -> Vec<AccountId> {
        self.accounts.to_vec()
    }

    /// Get number of created accounts.
    pub fn get_number_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Get accounts in paginated view.
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<AccountId> {
        let elements = self.accounts.as_vector();
        (from_index..std::cmp::min(from_index + limit, elements.len()))
            .filter_map(|index| elements.get(index))
            .collect()
    }

    #[payable]
    pub fn create(
        &mut self,
        public_key: Option<PublicKey>,
        function_key: Option<PublicKey>,
        deploy: bool,
        // args: Base64VecU8,
    ) -> Promise {
        // todo: should use atomic counter
        self.dsnp_id += 1;
        let account_id: AccountId = format!("{}.{}", self.dsnp_id, env::current_account_id())
            .parse()
            .unwrap();
        let mut promise = Promise::new(account_id.clone())
            .create_account()
            .transfer(env::attached_deposit());
        if deploy {
            promise = promise.deploy_contract(CODE.to_vec())
        }
        if let Some(key) = public_key {
            promise = promise.add_full_access_key(key.into())
        }
        if let Some(key) = function_key {
            promise = promise.add_access_key(key.into(), FUNCTION_KEY_ALLOWANCE, env::current_account_id(),"".into());
        }
        promise
            // TODO: enable when identity has init function
            // .function_call(
            //     "new".to_string(),
            //     args.into(),
            //     0,
            //     env::prepaid_gas() - CREATE_CALL_GAS - ON_CREATE_CALL_GAS,
            // )
            .then(ext_self::on_create(
                account_id,
                U128(env::attached_deposit()),
                env::predecessor_account_id(),
                env::current_account_id(),
                0,
                ON_CREATE_CALL_GAS,
            ))
    }

    pub fn on_create(
        &mut self,
        account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool {
        assert_self();
        if near_sdk::is_promise_success() {
            self.accounts.insert(&account_id);
            true
        } else {
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, testing_env_with_promise_results, VMContextBuilder};
    use near_sdk::{testing_env, PromiseResult};

    use super::*;

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.current_account_id(accounts(0)).build());
        let mut factory = SubAccountFactory::new();
        testing_env!(context.attached_deposit(10).build());
        factory.create(
            Some(
                "ed25519:6E8sCci9badyRkXb3JoRpBj5p8C6Tw41ELDZoiihKEtp"
                    .parse()
                    .unwrap(),
            ),
            // "{}".as_bytes().to_vec().into(),
        );
        testing_env_with_promise_results(
            context.predecessor_account_id(accounts(0)).build(),
            PromiseResult::Successful(vec![]),
        );
        factory.on_create(
            format!("1000.{}", accounts(0)).parse().unwrap(),
            U128(10),
            accounts(0),
        );
        assert_eq!(
            factory.get_accounts_list(),
            vec![format!("1000.{}", accounts(0)).parse().unwrap()]
        );
        assert_eq!(
            factory.get_accounts(0, 100),
            vec![format!("1000.{}", accounts(0)).parse().unwrap()]
        );
    }
}

'''
'''--- ui/README.md ---
# NEAR Identity UI

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

NOTE: replace the contract name in config.js with the account ID where the smart contract is deployed.

'''
'''--- ui/package.json ---
{
  "name": "ui",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "bootstrap": "^5.1.3",
    "near-api-js": "^0.43.1",
    "react": "^17.0.2",
    "react-bootstrap": "^2.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "4.0.3",
    "web-vitals": "^1.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- ui/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- ui/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- ui/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- ui/src/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- ui/src/App.js ---
import './App.css';
import Button from 'react-bootstrap/Button';
import PropTypes from 'prop-types';

function App({ contract, currentUser, nearConfig, wallet }) {
  
  function createAccount() {
    console.log("calling contract");
    const resp = await contract.view_method_name();
    console.log(resp);
  }

  return (
    <div className="App">
      <header className="App-header">
        <p>
          NEAR Identity Playground
        </p>
        <Button variant="light" onClick={createAccount}>Create Account</Button>
      </header>
      
    </div>
  );
}

App.propTypes = {
  contract: PropTypes.shape({
    addMessage: PropTypes.func.isRequired,
    getMessages: PropTypes.func.isRequired
  }).isRequired,
  currentUser: PropTypes.shape({
    accountId: PropTypes.string.isRequired,
    balance: PropTypes.string.isRequired
  }),
  nearConfig: PropTypes.shape({
    contractName: PropTypes.string.isRequired
  }).isRequired,
  wallet: PropTypes.shape({
    requestSignIn: PropTypes.func.isRequired,
    signOut: PropTypes.func.isRequired
  }).isRequired
};

export default App;

'''
'''--- ui/src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- ui/src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'dsnp.testnet';

function getConfig(env) {
  switch(env) {
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;
'''
'''--- ui/src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- ui/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import 'bootstrap/dist/css/bootstrap.min.css';
import getConfig from './config.js';
import * as nearAPI from 'near-api-js';

// Initializing contract
async function initContract() {
  // get network configuration values from config.js
  // based on the network ID we pass to getConfig()
  const nearConfig = getConfig(process.env.NODE_ENV || 'testnet');

  // create a keyStore for signing transactions using the user's key
  // which is located in the browser local storage after user logs in
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();

  // Initializing connection to the NEAR testnet
  const near = await nearAPI.connect({ keyStore, ...nearConfig });

  // Initialize wallet connection
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in user's account data
  let currentUser;
  if (walletConnection.getAccountId()) {
    currentUser = {
      // Gets the accountId as a string
      accountId: walletConnection.getAccountId(),
      // Gets the user's token balance
      balance: (await walletConnection.account().state()).amount,
    };
  }

  // Initializing our contract APIs by contract name and configuration
  const contract = await new nearAPI.Contract(
    // User's accountId as a string
    walletConnection.account(),
    // accountId of the contract we will be loading
    // NOTE: All contracts on NEAR are deployed to an account and
    // accounts can only have one contract deployed to them. 
    nearConfig.contractName,
    {
      // View methods are read-only – they don't modify the state, but usually return some value
      viewMethods: ['getMessages'],
      // Change methods can modify the state, but you don't receive the returned value when called
      changeMethods: ['addMessage'],
      // Sender is the account ID to initialize transactions.
      // getAccountId() will return empty string if user is still unauthorized
      sender: walletConnection.getAccountId(),
    }
  );

  return { contract, currentUser, nearConfig, walletConnection };
}

window.nearInitPromise = initContract().then(
  ({ contract, currentUser, nearConfig, walletConnection }) => {
    ReactDOM.render(
      <App
        contract={contract}
        currentUser={currentUser}
        nearConfig={nearConfig}
        wallet={walletConnection}
      />,
      document.getElementById('root')
    );
  }
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

'''
'''--- ui/src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- ui/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- ui/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''