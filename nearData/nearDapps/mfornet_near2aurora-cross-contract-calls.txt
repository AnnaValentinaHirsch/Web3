*GitHub Repository "mfornet/near2aurora-cross-contract-calls"*

'''--- README.md ---
# NEAR to Aurora contract calls

Status Message application using cross contract calls.

'''
'''--- near-proxy/Cargo.toml ---
[package]
name = "near-proxy"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
borsh = "0.9.3"
hex = "0.4.3"
ethabi = "17.1.0"
getrandom = { version = "0.2", features = ["js"] }

'''
'''--- near-proxy/build.sh ---
#!/bin/bash
env RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/near_proxy.wasm res/
ls -la res/near_proxy.wasm

'''
'''--- near-proxy/src/aurora.rs ---
use borsh::BorshSerialize;
use near_sdk::{Gas, Promise};

type Address = [u8; 20];
type Wei = [u8; 32];

#[derive(BorshSerialize)]
struct CallArgs {
    /// Contract to be called
    pub contract: Address,
    /// Amount of wei to attach
    pub value: Wei,
    /// Input data to pass to the contract
    pub input: Vec<u8>,
}

impl CallArgs {
    fn serialize(&self) -> Vec<u8> {
        // Prepend byte one to signal enum version
        vec![vec![0], self.try_to_vec().unwrap()].concat()
    }
}

const AURORA_ACCOUNT_ID: &str = "aurora";
const CALL_GAS: Gas = Gas(20_000_000_000_000);

pub fn call(contract: Address, value: Wei, input: Vec<u8>) -> Promise {
    Promise::new(AURORA_ACCOUNT_ID.parse().unwrap()).function_call(
        "call".to_string(),
        CallArgs {
            contract,
            value,
            input,
        }
        .serialize(),
        0,
        CALL_GAS,
    )
}

'''
'''--- near-proxy/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, require, PanicOnDefault, Promise};

mod aurora;
mod utils;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    pub status_message_address: Vec<u8>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            status_message_address: vec![],
        }
    }

    #[private]
    pub fn set_status_message_address(&mut self, status_message_address: String) {
        require!(
            status_message_address.len() == 40,
            "Invalid status message address"
        );
        self.status_message_address = hex::decode(status_message_address).unwrap().to_vec();
    }

    pub fn set_message(&mut self, message: String) -> Promise {
        require!(
            self.status_message_address.len() == 20,
            "Status message address not set"
        );

        let mut contract = [0; 20];
        contract.copy_from_slice(&self.status_message_address);

        aurora::call(
            contract,
            [0; 32],
            utils::abi_encode(
                near_sdk::env::predecessor_account_id().as_str().to_string(),
                message,
            ),
        )
    }
}

'''
'''--- near-proxy/src/utils.rs ---
#[derive(Eq, PartialEq)]
enum PadDirection {
    Prefix,
    Suffix,
}

fn pad(mut buffer: Vec<u8>, direction: PadDirection) -> Vec<u8> {
    if direction == PadDirection::Prefix {
        buffer.reverse();
    }

    buffer.resize((buffer.len() + 31) / 32 * 32, 0);

    if direction == PadDirection::Prefix {
        buffer.reverse();
    }
    buffer
}

/// Custom encoder for `setNearAccountIdStatus`
pub fn abi_encode(key: String, value: String) -> Vec<u8> {
    let offset1: usize = 64;
    let offset2: usize = 32 * (3 + (key.len() + 31) / 32);
    let len1 = key.len();
    let len2 = value.len();

    return vec![
        // `cast sig "setNearAccountIdStatus(string, string)"`
        hex::decode("18bf50cd").unwrap(),
        pad(offset1.to_be_bytes().to_vec(), PadDirection::Prefix),
        pad(offset2.to_be_bytes().to_vec(), PadDirection::Prefix),
        pad(len1.to_be_bytes().to_vec(), PadDirection::Prefix),
        pad(key.as_bytes().to_vec(), PadDirection::Suffix),
        pad(len2.to_be_bytes().to_vec(), PadDirection::Prefix),
        pad(value.as_bytes().to_vec(), PadDirection::Suffix),
    ]
    .concat();
}

'''
'''--- status-message/README.md ---
# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a sample contract, a test for that contract, and a script that deploys that contract.

Try running some of the following tasks:

```shell
npx hardhat help
npx hardhat test
GAS_REPORT=true npx hardhat test
npx hardhat node
npx hardhat run scripts/deploy.js
```

'''
'''--- status-message/hardhat.config.js ---
require("@nomicfoundation/hardhat-toolbox");
const { keccak256 } = require("ethers/lib/utils");
const { task } = require("hardhat/config");

const statusMessageAddress = '0x8ECe66a07b872d1f0353e313a8329EcA11924815';

task("deploy", "Deploy contract").addParam("nearProxyAccountId").setAction(async (taskArgs) => {
  const address = '0x' + keccak256(Buffer.from(taskArgs.nearProxyAccountId)).slice(26);
  console.log({ nearProxyAddress: address });
  const statusMessageFactory = await ethers.getContractFactory("StatusMessage");
  const statusMessage = await statusMessageFactory.deploy(address);
  await statusMessage.deployed();
  console.log("Deployed contract to:", statusMessage.address);
});

task("evm-address", "EVM Address for specific NEAR account id").addParam("nearAccountId").setAction(async (taskArgs) => {
  const address = '0x' + keccak256(Buffer.from(taskArgs.nearAccountId)).slice(26);
  console.log({ nearAccountId: taskArgs.nearAccountId, nearProxyAddress: address });
});

task("list-messages", "List status messages").setAction(async () => {
  const statusMessageFactory = await ethers.getContractFactory("StatusMessage");
  const statusMessage = statusMessageFactory.attach(statusMessageAddress);

  const resultBN = await statusMessage.totalKeys();
  const total = resultBN.toNumber();

  console.log(`Found ${total} status`);

  for (let i = 0; i < total; i++) {
    const key = await statusMessage.getKey(i);
    const status = await statusMessage.getStatus(key);
    console.log(`${key}: ${status}`);
  }
});

task("add-status", "Add status message").addParam("statusMessage").setAction(async (taskArgs) => {
  const statusMessageFactory = await ethers.getContractFactory("StatusMessage");
  const statusMessage = statusMessageFactory.attach(statusMessageAddress);
  const result = await statusMessage.setAuroraAddressStatus(taskArgs.statusMessage);
  console.log({ result });
});

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.13",
  defaultNetwork: 'aurora',
  networks: {
    aurora: {
      url: "https://mainnet.aurora.dev/",
      accounts: ['']
    },
    auroraTestnet: {
      url: "https://testnet.aurora.dev",
      // TODO: Some free TEST tokens :) go grab them
      accounts: ['0x1311143f626d916df89a3f8829146fe1c606b6efced2901448eff84e4853ca56']
    }
  }
};

'''
'''--- status-message/package.json ---
{
  "name": "cli",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "devDependencies": {
    "@ethersproject/abi": "^5.4.7",
    "@ethersproject/providers": "^5.4.7",
    "@nomicfoundation/hardhat-chai-matchers": "^1.0.0",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.0",
    "@nomicfoundation/hardhat-toolbox": "^1.0.1",
    "@nomiclabs/hardhat-ethers": "^2.0.0",
    "@nomiclabs/hardhat-etherscan": "^3.0.0",
    "@typechain/ethers-v5": "^10.1.0",
    "@typechain/hardhat": "^6.1.2",
    "chai": "^4.2.0",
    "ethers": "^5.4.7",
    "hardhat": "^2.10.1",
    "hardhat-gas-reporter": "^1.0.8",
    "solidity-coverage": "^0.7.21",
    "typechain": "^8.1.0"
  }
}

'''