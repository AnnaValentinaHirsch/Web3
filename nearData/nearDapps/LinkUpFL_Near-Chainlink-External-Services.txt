*GitHub Repository "LinkUpFL/Near-Chainlink-External-Services"*

'''--- .eslintrc.js ---
module.exports = {
  root: true,
  env: {
    node: true,
  },
  parser: '@typescript-eslint/parser', // Specifies the ESLint parser
  plugins: ['@typescript-eslint'],
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended', // Uses the recommended rules from the @typescript-eslint/eslint-plugin
    'prettier/@typescript-eslint', // Uses eslint-config-prettier to disable ESLint rules from @typescript-eslint/eslint-plugin that would conflict with prettier
    'plugin:prettier/recommended', // Enables eslint-plugin-prettier and eslint-config-prettier. This will display prettier errors as ESLint errors. Make sure this is always the last configuration in the extends array.
  ],
}

'''
'''--- .github/workflows/ci-workflow.yml ---
# .github/workflows/nodejs.yml
name: Node CI

on: [push, pull_request] # Run on Push and Pull Requests

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [10.x] # Only run the 10.x build

    steps:
      - uses: actions/checkout@v1
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install -g yarn
      - name: yarn install, lint, build, and test
        run: |
          yarn
          yarn lint
          yarn build
          yarn test
      - name: yarn pack:zip
        run: yarn pack:zip
      - name: get-npm-version
        id: package-version
        uses: martinbeentjes/npm-get-version-action@master
      - name: Upload package
        uses: actions/upload-artifact@v2
        with:
          name: near-protocol-adapter-${{steps.package-version.outputs.current-version}}
          path: near-protocol-adapter-${{steps.package-version.outputs.current-version}}.zip

'''
'''--- .prettierrc.js ---
module.exports = {
  semi: false,
  singleQuote: true,
  printWidth: 80,
  endOfLine: 'auto',
  trailingComma: 'all',
}

'''
'''--- .vim/coc-settings.json ---
{
  "eslint.packageManager": "yarn",
  "eslint.nodePath": ".yarn/sdks",
  "tsserver.tsdk": ".yarn/sdks/typescript/lib"
}

'''
'''--- .vscode/extensions.json ---
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "arcanis.vscode-zipfs"
  ]
}

'''
'''--- .vscode/settings.json ---
{
  "eslint.nodePath": ".yarn/sdks",
  "prettier.prettierPath": ".yarn/sdks/prettier/index.js",
  "typescript.tsdk": ".yarn/sdks/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}

'''
'''--- .yarn/sdks/eslint/bin/eslint.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.js";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require eslint/bin/eslint.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real eslint/bin/eslint.js your application uses
module.exports = absRequire(`eslint/bin/eslint.js`);

'''
'''--- .yarn/sdks/eslint/lib/api.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.js";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require eslint/lib/api.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real eslint/lib/api.js your application uses
module.exports = absRequire(`eslint/lib/api.js`);

'''
'''--- .yarn/sdks/eslint/package.json ---
{
  "name": "eslint",
  "version": "7.2.0-pnpify",
  "main": "./lib/api.js",
  "type": "commonjs"
}
'''
'''--- .yarn/sdks/integrations.yml ---
# This file is automatically generated by PnPify.
# Manual changes will be lost!

integrations:
  - vscode
  - vim

'''
'''--- .yarn/sdks/prettier/index.js ---
#!/usr/bin/env node

const { existsSync } = require(`fs`)
const { createRequire, createRequireFromPath } = require(`module`)
const { resolve } = require(`path`)

const relPnpApiPath = '../../../.pnp.js'

const absPnpApiPath = resolve(__dirname, relPnpApiPath)
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath)

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require prettier/index.js
    require(absPnpApiPath).setup()
  }
}

// Defer to the real prettier/index.js your application uses
module.exports = absRequire(`prettier/index.js`)

'''
'''--- .yarn/sdks/prettier/package.json ---
{
  "name": "prettier",
  "version": "2.0.5-pnpify",
  "main": "./index.js",
  "type": "commonjs"
}
'''
'''--- .yarn/sdks/typescript/lib/tsc.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.js";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/tsc.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/tsc.js your application uses
module.exports = absRequire(`typescript/lib/tsc.js`);

'''
'''--- .yarn/sdks/typescript/lib/tsserver.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.js";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

const moduleWrapper = tsserver => {
  // VSCode sends the zip paths to TS using the "zip://" prefix, that TS
  // doesn't understand. This layer makes sure to remove the protocol
  // before forwarding it to TS, and to add it back on all returned paths.

  const {isAbsolute} = require(`path`);

  const Session = tsserver.server.Session;
  const {onMessage: originalOnMessage, send: originalSend} = Session.prototype;

  return Object.assign(Session.prototype, {
    onMessage(/** @type {string} */ message) {
      return originalOnMessage.call(this, JSON.stringify(JSON.parse(message), (key, value) => {
        return typeof value === 'string' ? removeZipPrefix(value) : value;
      }));
    },

    send(/** @type {any} */ msg) {
      return originalSend.call(this, JSON.parse(JSON.stringify(msg, (key, value) => {
        return typeof value === 'string' ? addZipPrefix(value) : value;
      })));
    }
  });

  function addZipPrefix(str) {
    // We add the `zip:` prefix to both `.zip/` paths and virtual paths
    if (isAbsolute(str) && !str.match(/^zip:/) && (str.match(/\.zip\//) || str.match(/\$\$virtual\//))) {
      // Absolute VSCode `Uri.fsPath`s need to start with a slash.
      // VSCode only adds it automatically for supported schemes,
      // so we have to do it manually for the `zip` scheme.
      return `zip:${str.replace(/^\/?/, `/`)}`;
    } else {
      return str;
    }
  }

  function removeZipPrefix(str) {
    return str.replace(/^zip:/, ``);
  }
};

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/tsserver.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/tsserver.js your application uses
module.exports = moduleWrapper(absRequire(`typescript/lib/tsserver.js`));

'''
'''--- .yarn/sdks/typescript/lib/typescript.js ---
#!/usr/bin/env node

const {existsSync} = require(`fs`);
const {createRequire, createRequireFromPath} = require(`module`);
const {resolve} = require(`path`);

const relPnpApiPath = "../../../../.pnp.js";

const absPnpApiPath = resolve(__dirname, relPnpApiPath);
const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);

if (existsSync(absPnpApiPath)) {
  if (!process.versions.pnp) {
    // Setup the environment to be able to require typescript/lib/typescript.js
    require(absPnpApiPath).setup();
  }
}

// Defer to the real typescript/lib/typescript.js your application uses
module.exports = absRequire(`typescript/lib/typescript.js`);

'''
'''--- .yarn/sdks/typescript/package.json ---
{
  "name": "typescript",
  "version": "3.9.5-pnpify",
  "main": "./lib/typescript.js",
  "type": "commonjs"
}
'''
'''--- .yarnrc.yml ---
# We use legacy Yarn v1.22.4 by default:
yarnPath: .yarn/releases/yarn-1.22.4.cjs

# Switch to this path if want to use Yarn v2.
# Please remember to run `yarn install` when switching
#  between versions because of differences in `yarn.lock` file.
# yarnPath: .yarn/releases/yarn-2.0.0-rc.36.cjs

'''
'''--- LICENCE.md ---
MIT License

Copyright (c) 2020 SmartContract Chainlink Limited SEZC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- README.md ---
# NEAR Protocol Write Adapter

This service is used by a Chainlink node as an external adapter for writing to [NEAR Blockchain](https://near.org/).

The external adapter allows you to configure an endpoint, account and private key to sign and send transactions.

## Prerequisite

- Yarn v1.22+: You will need to have [Yarn v1.22+ installed](https://yarnpkg.com/getting-started/install) locally.
  - This repo also activates the Berry release (codename for the Yarn 2), disabled by default.
  - To switch between versions use the `yarnPath` release path in [.yarnrc.yml](.yarnrc.yml) file, and run `yarn install` because of differences in `yarn.lock` file.
- Node v12+: [n](https://github.com/tj/n) is a great interactive manager for your Node.js versions.

## Install

If using Yarn v1.22+ (default), or when switching between versions (from v1.22+ -> v2, and back), please run:

```bash
yarn install
```

## Set up NEAR accout

### Prerequisite

- NEAR account: Please create one with [NEAR Wallet](https://wallet.nearprotocol.com).
- NEAR CLI: Please install it following the [NEAR docs instructions](https://docs.near.org/docs/development/near-cli).

### NEAR login

In the project root, login with `near-cli` by following the instructions after this command:

```bash
near login
```

This step is required to get to the NEAR account private key which can be found at `~/.near-credentials/default/${ACCOUNT_ID}.json`:

```json
{ "account_id": "${ACCOUNT_ID}", "private_key": "ed25519:..." }
```

## Start

Supported environment variables:

- ACCOUNT_ID: NEAR account that this service will use
- PRIVATE_KEY: NEAR account private key
- PORT: (optional) defaults to `3000`
- NODE_ENV: (optional) one of `[production|mainnet|development|testnet|devnet|betanet|local]`, defaults to `development`
- NETWORK_ID: (optional) custom network id, `NODE_URL` must also be set
- NODE_URL: (optional) custom node url, `NETWORK_ID` must also be set

Set the required environment, and run from the project root:

```bash
yarn start
```

Alternatively you can set the environment inline:

```bash
env \
  ACCOUNT_ID=dummy.testnet \
  PRIVATE_KEY=ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2 \
  NODE_ENV=testnet \
yarn start
```

Or for a custom connection:

```bash
env \
  ACCOUNT_ID=dummy.acmenet \
  PRIVATE_KEY=ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2 \
  NETWORK_ID=acmenet \
  NODE_URL=https://rpc.acmenet.acme.org \
yarn start
```

This service can be started as a standalone service or as a **[Chainlink node adapter](#chainlink-node-integration)**.

## API

The standalone service exposes all endpoints discussed next, while the service started as a [Chainlink node adapter](#chainlink-node-integration) exposes just one endpoint `POST /call`, but it's mapped as root endpoint `POST /`.

### HTTP `GET /` endpoint

Read NEAR network connection status.

Output:

```json
{
  "chain_id": "testnet",
  "latest_protocol_version": 22,
  "protocol_version": 22,
  "rpc_addr": "0.0.0.0:3030",
  "sync_info": {
    "latest_block_hash": "7nWiri3qx9G2h2qG2KCX9N2ChDPDgWjgzo5V31HTMxxf",
    "latest_block_height": 7626572,
    "latest_block_time": "2020-06-25T10:36:40.696884241Z",
    "latest_state_root": "FMwXSxgkgvtxdMZaHMrsLsZVKcxDJi2mBk9nbrz4CxWN",
    "syncing": false
  },
  "validators": [
    {
      "account_id": "bisontrails.stakingpool",
      "is_slashed": false
    },
    ... // more validators
  ],
  "version": {
    "build": "ebe21b33",
    "version": "1.0.0"
  }
}
```

### HTTP `GET /account` endpoint

Read configured NEAR account.

Output:

```json
{
  "accessKey": "ed25519:6J9NoFmr4mzBLch3tzKDfetY4YVNGQG74urLHeUDfCcw",
  "accountId": "krebernisak_1.testnet"
}
```

### HTTP `GET /view` endpoint

Read contract state from NEAR network.

Input:

- `contractId`: account where the contract is deployed
- `methodName`: function name to call on the contract
- `args`: (optional) function arguments

```json
{ "contractId": "counter.testnet", "methodName": "getCounter" }
```

Output:

```json
{
  "data": ..., // View function output data
  "statusCode": 200
}
```

### HTTP `POST /call` endpoint

**Available as `POST /` when started as Chainlink node adapter**

Send transaction and write state to the NEAR network.

Input:

- `contractId`: account where the contract is deployed
- `methodName`: function name to call on the contract
- `args`: (optional) function arguments
- `gas`: (optional) gas amount allocated for transaction execution
- `amount`: (optional) amount of NEAR sent with the transaction

```json
{
  "contractId": "counter.testnet",
  "methodName": "decrementCounter",
  "args": { "value": 13 },
  "gas": 5000000000000,
  "amount": 50
}
```

Output:

```json
{
  "data": {
    ... // Transaction result data
  },
  "statusCode": 200
}
```

### Errors

API will return a `HTTP 400` for client errors:

```json
{
  "message": "Missing required fields: contractId or methodName",
  "status": "BadRequest",
  "statusCode": 400,
  "type": "UntypedError"
}
```

Or `HTTP 500` for server errors:

```json
{
  "message": "Exceeded the prepaid gas",
  "status": "Error",
  "statusCode": 500,
  "type": "GasExceeded"
}
```

## Test

### Unit tests

Run from the project root:

```bash
yarn test
```

### Integration tests

#### Step 1: Deploy contract to NEAR network

For this test we are going to use [NEAR counter example](https://github.com/near-examples/counter) deployed to `@counter.testnet`.

Please follow their instructions to:

- Set up a new NEAR account where the contract will be deployed
- Login to NEAR CLI with your new account
- Deploy the contract

#### Step 2: Interact with contracts

To interact with the contracts, we are going to use [HTTPie](https://httpie.org/), a user-friendly command-line HTTP client, as an alternative to CURL.

Make sure the counter contract is deployed and the adapter service is started.

##### Read contract state

Use the `/view` endpoint to read contract state:

```bash
echo '{"contractId": "counter.testnet", "methodName": "getCounter"}' | http GET :3000/view
```

Example output:

```json
{
  "data": 0,
  "statusCode": 200
}
```

##### Write contract state

Use the `/call` endpoint to write contract state:

```bash
echo '{"contractId": "counter.testnet", "methodName": "incrementCounter", "args": {"value": 4}}' | http POST :3000/call
```

The `/call` endpoint also lets you control the `gas` and `amount` sent to the contract:

```bash
echo '{"contractId": "counter.testnet", "methodName": "decrementCounter", "args": {"value": 13}, "gas": 5000000000000, "amount": 50}' | http POST :3000/call
```

Example output:

```json
{
  "data": {
    "receipts_outcome": [
      {
        "block_hash": "9fdLpAdoPKoxwETaycVvwT5Lm2zy28fLGPKj2f4pkAVP",
        "id": "DeJ1GKwsRTfW63DBJBnAZPC4T8mnVgkkpvconBtfsWzM",
        "outcome": {
          "gas_burnt": 2757914274712,
          "logs": ["Counter is now: -9"],
          "receipt_ids": ["FeGwwskgZ95NQ6Pg9z745uq8sRJyyw83xYEXfJP4qoCe"],
          "status": {
            "SuccessValue": ""
          }
        },
        "proof": []
      },
      {
        "block_hash": "HEs6d5HkTCojADaw2DHJgXMEBGNkn3GuLfNDVjWqV3Qx",
        "id": "FeGwwskgZ95NQ6Pg9z745uq8sRJyyw83xYEXfJP4qoCe",
        "outcome": {
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          }
        },
        "proof": []
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJ2YWx1ZSI6MTN9",
            "deposit": "50",
            "gas": 5000000000000,
            "method_name": "decrementCounter"
          }
        }
      ],
      "hash": "EGMf4L6YvinLpjeCbfVVVXEPcfRMZ2HrvcHbDfiNiRMN",
      "nonce": 37,
      "public_key": "ed25519:6J9NoFmr4mzBLch3tzKDfetY4YVNGQG74urLHeUDfCcw",
      "receiver_id": "counter.testnet",
      "signature": "ed25519:21zN5PZKVueb79oUwKMkhshrwqw7uGzh7vgGCqkr8K1CF5XL6G6NtciYyU4xochHFXm4WY3pcHACPfnKUXSh7EvU",
      "signer_id": "krebernisak_1.testnet"
    },
    "transaction_outcome": {
      "block_hash": "GDZGu1P2Ff983WgiVuDkMVULZs5ED85L99TJaQE62pyL",
      "id": "EGMf4L6YvinLpjeCbfVVVXEPcfRMZ2HrvcHbDfiNiRMN",
      "outcome": {
        "gas_burnt": 2427983606152,
        "logs": [],
        "receipt_ids": ["DeJ1GKwsRTfW63DBJBnAZPC4T8mnVgkkpvconBtfsWzM"],
        "status": {
          "SuccessReceiptId": "DeJ1GKwsRTfW63DBJBnAZPC4T8mnVgkkpvconBtfsWzM"
        }
      },
      "proof": []
    }
  },
  "statusCode": 200
}
```

## Chainlink node integration

The Chainlink node expects a specific adapter API - we only expose the call function (send tx) on `/` endpoint.

Chainlink adapter requires and supports additional environment variables:

- CONTRACT_ID: NEAR account where the contract is deployed
- METHOD_NAME: Method name that will be called by the adapter
- GAS: (optional) Gas sent with the transaction, defaults to `300000000000000`
- AMOUNT: (optional) Amount sent with the transaction, defaults to `0`

To start the service as Chainlink node adapter:

```bash
env \
 NODE_ENV=testnet \
 PORT=3000 \
 ACCOUNT_ID=dummy.testnet \
 PRIVATE_KEY=ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2 \
 CONTRACT_ID=oracle.oracle.testnet \
 METHOD_NAME=fulfill_request \
yarn start:adapter
```

In this configuration the `/` endpoint connects directly to [NEAR oracle contract](https://github.com/smartcontractkit/near-protocol-contracts/), and expects a slightly different input. We need to include the job spec id:

```json
{
  "id": 1, // job spec id
  "data": {...} // input to our call function (specified in the env)
}
```

Example for adapter set up to call the `fulfill_request` function:

```json
echo '{"id": 1, "data": {"nonce":"1", "account": "client.oracle.testnet", "value": 17}}' | http POST :3000/
```

Output:

```json
{
  "data": {
    "result": "6yTpkCW3UqVtpGj766Wvr73zEambzL2n44CDYiB4TpVP" // tx hash
  },
  "jobRunID": 1,
  "result": "6yTpkCW3UqVtpGj766Wvr73zEambzL2n44CDYiB4TpVP", // tx hash
  "statusCode": 200
}
```

### Deployment

To deploy a container, build the Docker image:

```bash
docker build -t near-protocol-adapter .
```

Run the Docker container:

```bash
docker run -d \
  --name near-protocol-adapter \
  -p 3000:3000 \
  -e NODE_ENV=testnet \
  -e PORT=3000 \
  -e ACCOUNT_ID=dummy.testnet \
  -e PRIVATE_KEY=ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2 \
  -e CONTRACT_ID=oracle.oracle.testnet \
  -e METHOD_NAME=fulfill_request \
  near-protocol-adapter
```

#### Serverless deployment

Package the adapter:

```json
yarn build:package
```

#### Install to AWS Lambda

- In Lambda Functions, create function
- On the Create function page:
  - Give the function a name
  - Use Node.js 12.x for the runtime
  - Choose an existing role or create a new one
  - Click Create Function
- Under Function code, select "Upload a .zip file" from the Code entry type drop-down
- Click Upload and select the `near-protocol-adapter-0.0.1.zip` file
- Handler should be set as `dist/index.handler`
- Add the environment variables as required
- Save

#### Install to GCP

- In Functions, create a new function, choose to ZIP upload
- Click Browse and select the `near-protocol-adapter-0.0.1.zip` file
- Select a Storage Bucket to keep the zip in
- Function to execute: gcpservice
- Click More, add the environment variables as required

'''
'''--- package.json ---
{
  "name": "near-protocol-adapter",
  "version": "0.0.1",
  "description": "NEAR Protocol adapter to be used by a Chainlink node.",
  "keywords": [
    "Chainlink",
    "LINK",
    "NEAR Protocol",
    "blockchain",
    "oracle"
  ],
  "main": "./dist/index.js",
  "repository": {
    "url": "https://github.com/smartcontractkit/near-protocol-adapter",
    "type": "git"
  },
  "author": "Kristijan Rebernisak <kristijan.rebernisak@smartcontract.com>",
  "license": "MIT",
  "scripts": {
    "build": "yarn && tsc",
    "build:package": "yarn build && yarn pack:zip",
    "pack:zip": "./scripts/pack",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "test": "mocha --exit -r ts-node/register 'test/**/*.test.ts'",
    "start": "node dist/app.js",
    "start:adapter": "node -e \"require('./dist/index.js').server()\""
  },
  "devDependencies": {
    "@types/chai": "^4.2.11",
    "@types/express": "^4.17.6",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.0.13",
    "@typescript-eslint/eslint-plugin": "^3.3.0",
    "@typescript-eslint/parser": "^3.3.0",
    "chai": "^4.2.0",
    "chai-http": "^4.3.0",
    "eslint": "^7.2.0",
    "eslint-config-prettier": "^6.11.0",
    "eslint-plugin-prettier": "^3.1.4",
    "husky": "^4.2.5",
    "lint-staged": "^10.2.11",
    "mocha": "^8.0.1",
    "prettier": "^2.0.5",
    "ts-node": "^8.10.2",
    "typescript": "^3.9.5"
  },
  "dependencies": {
    "@chainlink/ea-bootstrap": "^0.0.1",
    "@chainlink/external-adapter": "^0.2.3",
    "express": "^4.17.1",
    "express-async-handler": "^1.1.4",
    "near-api-js": "^0.25.1"
  },
  "resolutions": {
    "**/lodash": "^4.17.20",
    "**/serialize-javascript": "^3.1.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "src/**/*.{js,jsx,ts,tsx}": "yarn lint"
  }
}

'''
'''--- src/adapter.ts ---
import BN from 'bn.js'
import * as nearApi from 'near-api-js'
import { Requester, Validator } from '@chainlink/external-adapter'

import {
  connectionConfig,
  getRequiredEnv,
  ENV_CONTRACT_ID,
  ENV_METHOD_NAME,
  ENV_GAS,
  ENV_AMOUNT,
  DEFAULT_ENV_GAS,
  DEFAULT_ENV_AMOUNT,
} from './config'
import { connectAccount, Call, call, logConfig, AccountConfig } from './near'

type Base64String = string
type RequestFulfillmentArgs = {
  account: string
  nonce: string
}

// ChainlinkRequestFulfillmentArgs contains the input arguments received from the Chainlink node
type ChainlinkRequestFulfillmentArgs = RequestFulfillmentArgs & {
  value: number
}
// OracleRequestFulfillmentArgs contains the arguments for oracle 'fulfill_request' function
type OracleRequestFulfillmentArgs = RequestFulfillmentArgs & {
  data: Base64String
}
type JobSpecRequest = { id: string; data: ChainlinkRequestFulfillmentArgs }
type FinalExecutionOutcome = nearApi.providers.FinalExecutionOutcome
type Callback = (statusCode: number, data: Record<string, unknown>) => void

const inputParams = {
  account: true,
  nonce: true,
  value: ['result', 'value'],
}

type AdapterConfig = AccountConfig & {
  adapter: {
    contractId: string
    methodName: string
    gas: BN
    amount: BN
  }
}

const config: AdapterConfig = {
  ...connectionConfig(),
  adapter: {
    contractId: getRequiredEnv(ENV_CONTRACT_ID),
    methodName: getRequiredEnv(ENV_METHOD_NAME),
    gas: new BN(process.env[ENV_GAS] || DEFAULT_ENV_GAS),
    amount: new BN(process.env[ENV_AMOUNT] || DEFAULT_ENV_AMOUNT),
  },
}
logConfig(config)

// Export function to integrate with Chainlink node
export const createRequest = (
  request: JobSpecRequest,
  callback: Callback,
): void => {
  const validator = new Validator(callback, request, inputParams)
  const jobRunID = validator.validated.id

  const _handleResponse = (out: FinalExecutionOutcome) =>
    callback(
      200,
      Requester.success(jobRunID, {
        data: { result: out.transaction.hash },
        result: out.transaction.hash,
        status: 200,
      }),
    )

  const _handleError = (err: Error) =>
    callback(500, Requester.errored(jobRunID, err.message))

  const { data } = validator.validated
  const args: OracleRequestFulfillmentArgs = {
    account: data.account,
    nonce: data.nonce,
    data: Buffer.from(data.value.toString()).toString('base64'),
  }

  const input: Call = {
    contractId: config.adapter.contractId,
    methodName: config.adapter.methodName,
    args,
    gas: config.adapter.gas,
    amount: config.adapter.amount,
  }

  connectAccount(config)
    .then((account) => call(account, input))
    .then(_handleResponse)
    .catch(_handleError)
}

'''
'''--- src/app.ts ---
import express, { Request, Response } from 'express'
import asyncHandler from 'express-async-handler'

import { handleNotFound, handleErrors, BadRequest } from './errors'
import { connectionConfig, ENV_PORT } from './config'
import {
  connect,
  connectAccount,
  ContractCall,
  View,
  Call,
  view,
  call,
  logConfig,
} from './near'

const config = connectionConfig()
logConfig(config)

const app = express()
app.use(express.json())

// Connect to the network and check status
app.get(
  '/',
  asyncHandler(async (_, res: Response) => {
    const near = await connect(config)
    const networkStatus = await near.connection.provider.status()
    res.send(networkStatus)
  }),
)

// Get the configured master account details
app.get(
  '/account',
  asyncHandler(async (_, res: Response) => {
    const { networkId, masterAccount, keyStore } = config
    const keyPair = await keyStore.getKey(networkId, masterAccount)
    res.send({
      accountId: masterAccount,
      accessKey: keyPair.getPublicKey().toString(),
    })
  }),
)

// TODO: improve Validator from '@chainlink/external-adapter' to work synchronously and use it here
// Validate API input
const validate = (input: ContractCall) => {
  const { contractId, methodName } = input
  if (!contractId || !methodName)
    throw new BadRequest('Missing required fields: contractId or methodName')
}

// Read contract call which can view state
app.get(
  '/view',
  asyncHandler(async (req: Request, res: Response) => {
    const input: View = req.body
    validate(input)

    const account = await connectAccount(config)
    const result = await view(account, input)

    console.log('View result: ', result)
    res.status(200).json({
      data: result,
      statusCode: 200,
    })
  }),
)

// Write contract call which can modify state
app.post(
  '/call',
  asyncHandler(async (req: Request, res: Response) => {
    const input: Call = req.body
    validate(input)

    const account = await connectAccount(config)
    const result = await call(account, input)

    console.log('Call result: ', result)
    res.status(200).json({
      data: result,
      statusCode: 200,
    })
  }),
)

// Error handling middleware
app.use(handleNotFound)
app.use(handleErrors)

const port = parseInt(process.env[ENV_PORT] as string) || 3000

app.listen(port, (err: Error) => {
  if (err) return console.error(err)
  return console.log(`Server is listening on port:${port}`)
})

// Export our app for testing purposes
export default app

'''
'''--- src/config.ts ---
import BN from 'bn.js'
import { configFrom, configFromEnv, AccountConfig, EnvType } from './near'

export const ENV_NODE_ENV = 'NODE_ENV'

// NEAR connection config
export const ENV_PORT = 'PORT'
export const ENV_NETWORK_ID = 'NETWORK_ID'
export const ENV_NODE_URL = 'NODE_URL'
export const ENV_ACCOUNT_ID = 'ACCOUNT_ID'
export const ENV_PRIVATE_KEY = 'PRIVATE_KEY'

// Chainlink adapter config
export const ENV_CONTRACT_ID = 'CONTRACT_ID'
export const ENV_METHOD_NAME = 'METHOD_NAME'
export const ENV_GAS = 'GAS'
export const ENV_AMOUNT = 'AMOUNT'

// Chainlink adapter config defaults
export const DEFAULT_ENV_GAS = new BN('300000000000000')
export const DEFAULT_ENV_AMOUNT = new BN('0')

// Custom error for required env variable.
export class RequiredEnvError extends Error {
  constructor(name: string) {
    super(`Please set the required env ${name}.`)
    this.name = RequiredEnvError.name
  }
}

/**
 * Get variable from environments
 * @param name The name of environment variable
 * @throws {RequiredEnvError} Will throw an error if environment variable is not defined.
 * @returns {string}
 */
export const getRequiredEnv = (name: string): string => {
  const val = process.env[name]
  if (!val) throw new RequiredEnvError(name)
  return val
}

// Build  NEAR config form environment
export const connectionConfig = (): AccountConfig => {
  const accountId = getRequiredEnv(ENV_ACCOUNT_ID)
  const pk = getRequiredEnv(ENV_PRIVATE_KEY)

  const networkId = process.env[ENV_NETWORK_ID]
  const nodeUrl = process.env[ENV_NODE_URL]
  if (networkId && nodeUrl) {
    const connectConfig = { networkId, nodeUrl }
    return configFrom(connectConfig, accountId, pk)
  }

  const envType = (process.env[ENV_NODE_ENV] as EnvType) || undefined
  return configFromEnv(envType, accountId, pk)
}

'''
'''--- src/errors.ts ---
import { Request, Response, NextFunction } from 'express'
import { utils } from 'near-api-js'

const { ServerError } = utils.rpc_errors

const CODE_CLIENT_ERROR = 400
const CODE_CLIENT_ERROR_NOT_FOUND = 404
const CODE_SERVER_ERROR = 500

export class GeneralError extends Error {
  statusCode: number
  constructor(statusCode = CODE_SERVER_ERROR, ...args: any[]) {
    super(...args)
    this.statusCode = statusCode
    this.name = this.constructor.name
  }
}

export class BadRequest extends GeneralError {
  constructor(...args: any[]) {
    super(CODE_CLIENT_ERROR, ...args)
  }
}

type ErrorResponse = {
  statusCode: number
  status: string
  type?: string
  message?: string
}

/* eslint-disable @typescript-eslint/no-unused-vars */
export const handleNotFound = (
  _req: Request,
  res: Response,
  _next: NextFunction,
): Response<ErrorResponse> => {
  return res.status(CODE_CLIENT_ERROR_NOT_FOUND).json({
    statusCode: CODE_CLIENT_ERROR_NOT_FOUND,
    status: 'Error',
    type: 'NotFound',
    message: '404 Not Found',
  })
}

/* eslint-disable @typescript-eslint/no-unused-vars */
export const handleErrors = (
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction,
): Response<ErrorResponse> => {
  // Log the error to the console
  console.error(err)

  const errorResponse = {
    status: err.name,
    type: err instanceof ServerError ? err.type : 'UntypedError',
    message: err.message,
  }

  if (err instanceof GeneralError) {
    return res.status(err.statusCode).json({
      statusCode: err.statusCode,
      ...errorResponse,
    })
  }

  return res.status(CODE_SERVER_ERROR).json({
    statusCode: CODE_SERVER_ERROR,
    ...errorResponse,
  })
}

'''
'''--- src/global.d.ts ---
// Declare missing type definitions
declare module '@chainlink/ea-bootstrap'
declare module '@chainlink/external-adapter'

'''
'''--- src/index.ts ---
import * as bootstrap from '@chainlink/ea-bootstrap'
import { createRequest } from './adapter'

module.exports = {
  server: bootstrap.server.init(createRequest),

  gcpservice: bootstrap.serverless.initGcpService(createRequest),
  handler: bootstrap.serverless.initHandler(createRequest),
  handlerv2: bootstrap.serverless.initHandlerV2(createRequest),
}

'''
'''--- src/near/config.ts ---
import { keyStores, KeyPair } from 'near-api-js'
import { SingleKeyStore } from './single_key_store'

const DEFAULT_ENV_NODE_ENV = 'development'

type KeyStore = keyStores.KeyStore
type NearConfig = {
  keyStore?: KeyStore
  deps?: { keyStore: KeyStore }
  helperUrl?: string
  masterAccount?: string
  walletUrl?: string
  networkId: string
  nodeUrl: string
}
export type ConnectConfig = NearConfig & {
  keyPath?: string
}
export type AccountConfig = NearConfig & {
  keyStore: KeyStore
  deps: { keyStore: KeyStore }
  masterAccount: string
  masterAccessKey: string
}

export type EnvType =
  | 'production'
  | 'mainnet'
  | 'development'
  | 'testnet'
  | 'devnet'
  | 'betanet'
  | 'local'

function getConfig(env: EnvType): ConnectConfig {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
      }
    case 'devnet':
      return {
        networkId: 'devnet',
        nodeUrl: 'https://rpc.devnet.near.org',
        walletUrl: 'https://wallet.devnet.near.org',
        helperUrl: 'https://helper.devnet.near.org',
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
      }
    default:
      throw Error(
        `Unknown environment '${env}'. Can be configured in src/config.js.`,
      )
  }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
const cloneNoSecrets = (config: NearConfig): NearConfig =>
  (({ keyStore, deps, ...o }) => o)(config)

export const logConfig = (config: AccountConfig): void => {
  console.log('NEAR Protocol connection configuration:')
  console.log(cloneNoSecrets(config))
}

export const configFromEnv = (
  env: EnvType | undefined,
  accountId: string,
  pk: string,
): AccountConfig => {
  const config = getConfig(env || DEFAULT_ENV_NODE_ENV)
  return configFrom(config, accountId, pk)
}

export const configFrom = (
  connectConfig: ConnectConfig,
  accountId: string,
  pk: string,
): AccountConfig => {
  const keyPair = KeyPair.fromString(pk)
  const { networkId } = connectConfig
  const keyStore = new SingleKeyStore(networkId, accountId, keyPair)

  return {
    ...connectConfig,
    keyStore,
    deps: { keyStore },
    masterAccount: accountId,
    masterAccessKey: keyPair.getPublicKey().toString(),
  }
}

'''
'''--- src/near/index.ts ---
import BN from 'bn.js'
import * as nearApi from 'near-api-js'
import { ConnectConfig, AccountConfig } from './config'

export * from './config'

type Near = nearApi.Near
type Account = nearApi.Account
type FinalExecutionOutcome = nearApi.providers.FinalExecutionOutcome
type ViewOutcome = any

export type ContractCall = {
  contractId: string
  methodName: string
  args?: Record<string, unknown>
}
// Read state API input
export type View = ContractCall
// Write state API input
export type Call = ContractCall & {
  gas?: BN
  amount?: BN
}

// Initialize connection to the NEAR node.
export const connect = async (config: ConnectConfig): Promise<Near> =>
  await nearApi.connect(config)

// Initialize connection with account.
export const connectAccount = async (
  config: AccountConfig,
): Promise<Account> => {
  const near = await connect(config)
  return await near.account(config.masterAccount)
}

// View function using NEAR account
export const view = async (
  account: Account,
  input: View,
): Promise<ViewOutcome> =>
  await account.viewFunction(
    input.contractId,
    input.methodName,
    input.args || {},
  )

// Call function using NEAR account
export const call = async (
  account: Account,
  input: Call,
): Promise<FinalExecutionOutcome> =>
  await account.functionCall(
    input.contractId,
    input.methodName,
    input.args || {},
    input.gas,
    input.amount,
  )

'''
'''--- src/near/single_key_store.ts ---
import { keyStores, KeyPair } from 'near-api-js'

const { KeyStore } = keyStores

/**
 * Custom error for not supported functionality.
 */
class NotSupportedError extends Error {
  constructor(fnName: string) {
    super(`${fnName}() function is not supported for ${SingleKeyStore.name}.`)
    this.name = NotSupportedError.name
  }
}

/**
 * Simple in-memory keystore that holds a single key.
 */
export class SingleKeyStore extends KeyStore {
  private keys: { [key: string]: string }

  constructor(networkId: string, accountId: string, keyPair: KeyPair) {
    super()
    this.keys = {
      [`${accountId}:${networkId}`]: keyPair.toString(),
    }
  }

  /**
   * Not supported
   */
  async setKey(): Promise<void> {
    throw new NotSupportedError(this.setKey.name)
  }

  /**
   * Gets a key from in-memory storage
   * @param networkId The targeted network. (ex. default, devnet, betanet, etc…)
   * @param accountId The NEAR account tied to the key pair
   * @returns {Promise<KeyPair>}
   */
  async getKey(networkId: string, accountId: string): Promise<KeyPair> {
    const value = this.keys[`${accountId}:${networkId}`]
    if (!value) {
      return null as any
    }
    return KeyPair.fromString(value)
  }

  /**
   * Not supported
   */
  async removeKey(): Promise<void> {
    throw new NotSupportedError(this.removeKey.name)
  }

  /**
   * Not supported
   */
  async clear(): Promise<void> {
    throw new NotSupportedError(this.clear.name)
  }

  /**
   * Get the network(s) from in-memory storage
   * @returns {Promise<string[]>}
   */
  async getNetworks(): Promise<string[]> {
    const result = new Set<string>()
    Object.keys(this.keys).forEach((key) => {
      const parts = key.split(':')
      result.add(parts[1])
    })
    return Array.from(result.values())
  }

  /**
   * Gets the account(s) from in-memory storage
   * @param networkId The targeted network. (ex. default, devnet, betanet, etc…)
   * @returns{Promise<string[]>}
   */
  async getAccounts(networkId: string): Promise<string[]> {
    const result = new Array<string>()
    Object.keys(this.keys).forEach((key) => {
      const parts = key.split(':')
      if (parts[parts.length - 1] === networkId) {
        result.push(parts.slice(0, parts.length - 1).join(':'))
      }
    })
    return result
  }
}

'''
'''--- test/app.test.ts ---
import chai from 'chai'
import chaiHttp = require('chai-http')

chai.use(chaiHttp)

const { expect, request } = chai

import { ENV_ACCOUNT_ID, ENV_PRIVATE_KEY } from '../src/config'

describe('app', () => {
  context('when environment is set', () => {
    beforeEach(() => {
      process.env[ENV_ACCOUNT_ID] = 'dummy.testnet'
      process.env[ENV_PRIVATE_KEY] =
        'ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2'
    })

    it('server responds to /"', async () => {
      const app = await import('../src/app')
      const res = await request(app.default).get('/')
      expect(res).to.have.status(200)
      expect(res).to.have.header(
        'content-type',
        'application/json; charset=utf-8',
      )
      expect(res.body).not.null
      expect(res.body.chain_id).to.equal('testnet')
    })

    it('server responds to /account"', async () => {
      const app = await import('../src/app')
      const res = await request(app.default).get('/account')
      expect(res).to.have.status(200)
      expect(res).to.have.header(
        'content-type',
        'application/json; charset=utf-8',
      )
      expect(res.body).not.null
      expect(res.body.accountId).to.equal('dummy.testnet')
      expect(res.body.accessKey).to.equal(
        'ed25519:BZGHidhWFSKXUmHo2d6arxeJgthxECyFdgjW4P2GH4J4',
      )
    })
  })
})

'''
'''--- test/config.test.ts ---
import { expect } from 'chai'

import {
  ENV_ACCOUNT_ID,
  ENV_PRIVATE_KEY,
  RequiredEnvError,
  connectionConfig,
  getRequiredEnv,
} from '../src/config'

describe('incorrect app config', () => {
  beforeEach(() => {
    delete process.env[ENV_ACCOUNT_ID]
    delete process.env[ENV_PRIVATE_KEY]
  })

  context('when no env is set', () => {
    it(`throws RequiredEnvError for ${ENV_ACCOUNT_ID}`, () => {
      expect(() => getRequiredEnv(ENV_ACCOUNT_ID)) //
        .throws(RequiredEnvError, ENV_ACCOUNT_ID)
    })
  })

  context(`when ${ENV_ACCOUNT_ID} is set but not ${ENV_PRIVATE_KEY}`, () => {
    beforeEach(() => {
      process.env[ENV_ACCOUNT_ID] = 'dummy.testnet'
    })

    it(`throws RequiredEnvError for ${ENV_PRIVATE_KEY}`, () => {
      expect(() => connectionConfig()) //
        .throws(RequiredEnvError, ENV_PRIVATE_KEY)
    })
  })

  context(
    `when ${ENV_ACCOUNT_ID} is set but invalid ${ENV_PRIVATE_KEY}`,
    () => {
      beforeEach(() => {
        process.env[ENV_ACCOUNT_ID] = 'dummy.testnet'
      })

      it('throws Error because "Unknown curve"', () => {
        process.env[ENV_PRIVATE_KEY] = 'dummy:key'
        expect(() => connectionConfig()) //
          .throws(Error, 'Unknown curve:')
      })

      it('throws Error because "bad secret key size"', () => {
        process.env[ENV_PRIVATE_KEY] = '12345'
        expect(() => connectionConfig()) //
          .throws(Error, 'bad secret key size')
      })

      it('throws Error because "bad secret key size" for ed25519 curve', () => {
        process.env[ENV_PRIVATE_KEY] =
          'ed25519:EsjyvmBb2ESGiyjPHMBUnTGCe1P6hPjmxxY2b2hrTBAv'
        expect(() => connectionConfig()) //
          .throws(Error, 'bad secret key size')
      })
    },
  )
})

'''
'''--- test/near/config.test.ts ---
import { expect } from 'chai'
import { configFromEnv, EnvType } from '../../src/near'

describe('config', () => {
  const accountId = 'dummy.testnet'

  context(`when invalid environment`, () => {
    const env = 'dummy' as EnvType // force incorrect type

    it('throws Error because "Unknown environment"', () => {
      const pk = 'dummy:key'
      expect(() => configFromEnv(env, accountId, pk)) //
        .throws(Error, 'Unknown environment')
    })
  })

  context(`when invalid private key`, () => {
    const env = 'development'

    it('throws Error because "Unknown curve"', () => {
      const pk = 'dummy:key'
      expect(() => configFromEnv(env, accountId, pk)) //
        .throws(Error, 'Unknown curve:')
    })

    it('throws Error because "bad secret key size"', () => {
      const pk = '12345'
      expect(() => configFromEnv(env, accountId, pk)) //
        .throws(Error, 'bad secret key size')
    })

    it('throws Error because "bad secret key size" for ed25519 curve', () => {
      const pk = 'ed25519:EsjyvmBb2ESGiyjPHMBUnTGCe1P6hPjmxxY2b2hrTBAv'
      expect(() => configFromEnv(env, accountId, pk)) //
        .throws(Error, 'bad secret key size')
    })
  })

  context(`when valid params`, () => {
    const private_key =
      'ed25519:3Zo9bWRC7vUoDHMaXdMd6osajUktbgGWxL3P89QxR8VguVPnFa7BXd5brw6tBa6RASn8YCVjPgkhpujnorCF7FR2'
    const public_key = 'ed25519:BZGHidhWFSKXUmHo2d6arxeJgthxECyFdgjW4P2GH4J4'

    const _testConfig = async (
      _env: EnvType | undefined,
      _networkId: string,
      _nodeUrl: string,
    ) => {
      const c = configFromEnv(_env, accountId, private_key)
      expect(c).not.null
      expect(c.networkId).not.null
      expect(c.networkId).to.equal(_networkId)
      expect(c.nodeUrl).not.null
      expect(c.nodeUrl).to.equal(_nodeUrl)
      expect(c.masterAccount).not.null
      expect(c.masterAccount).to.equal(accountId)
      expect(c.deps).not.null
      expect(c.deps.keyStore).not.null

      const key = await c.deps.keyStore.getKey(_networkId, accountId)
      expect(key).not.null
      expect(key.getPublicKey().toString()).to.equal(public_key)
    }

    it('configuration is successful for undefined"', async () => {
      const env = undefined
      const networkId = 'default'
      const nodeUrl = 'https://rpc.testnet.near.org'
      _testConfig(env, networkId, nodeUrl)
    })

    it('configuration is successful for development"', async () => {
      const env = 'development'
      const networkId = 'default'
      const nodeUrl = 'https://rpc.testnet.near.org'
      _testConfig(env, networkId, nodeUrl)
    })

    it('configuration is successful for testnet"', async () => {
      const env = 'testnet'
      const networkId = 'default'
      const nodeUrl = 'https://rpc.testnet.near.org'
      _testConfig(env, networkId, nodeUrl)
    })

    it('configuration is successful for production"', async () => {
      const env = 'production'
      const networkId = 'mainnet'
      const nodeUrl = 'https://rpc.mainnet.near.org'
      _testConfig(env, networkId, nodeUrl)
    })

    it('configuration is successful for mainnet"', async () => {
      const env = 'mainnet'
      const networkId = 'mainnet'
      const nodeUrl = 'https://rpc.mainnet.near.org'
      _testConfig(env, networkId, nodeUrl)
    })
  })
})

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "target": "es2019",
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "dist"
  },
  "lib": [
    "es2019",
    "es2020.bigint",
    "es2020.string",
    "es2020.symbol.wellknown"
  ],
  "include": ["src/**/*"],
  "exclude": ["dist", "**/*.spec.ts", "**/*.test.ts"]
}

'''