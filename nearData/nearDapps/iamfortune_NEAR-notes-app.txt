*GitHub Repository "iamfortune/NEAR-notes-app"*

'''--- README.md ---
## Unit Tests
- Unit tests can be run from the top level directory using the following command:
  ```
  yarn test:unit
  ```
  
  ### Tests for Contract in index.unit.spec.ts
 

[Describe]: Notes

 [Success]: ✔ verifies a note is added from addNote
 [Success]: ✔ deletes contact by calling deleteNote()

    [File]: src/sample/__tests__/index.unit.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 2 pass,  0 fail, 2 total
    [Time]: 10.657ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 2 pass, 0 fail, 2 total
    [Time]: 15673.723ms
Done in 16.13s.

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/sample"
  ]
}

'''
'''--- package.json ---
{
  "name": "notes-app",
  "version": "0.0.1",
  "description": "A Notes application built on the NEAR blockchain ",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit && yarn test:simulate",
    "test:simulate": "cargo test -- --nocapture",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target"
  },
  "keywords": [],
  "author": "Fortune Ikechi",
  "license": "ISC",
  "devDependencies": {},
  "dependencies": {
    "near-sdk-as": "^3.0.0"
  }
}

'''
'''--- scripts/1.init.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/sample.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo

exit 0

'''
'''--- scripts/2.run.sh ---
#!/usr/bin/env bash
set -e

echo
echo \$CONTRACT is $CONTRACT
echo \$OWNER is $OWNER
echo

# these functions are all "view" functions so they don't require a signature
near view $CONTRACT showYouKnow     # this one returns false (function return value is void)
near view $CONTRACT showYouKnow2    # this one returns true
near view $CONTRACT sayHello        # this one returns a literal string

# ------------------------
# the next method uses a host function to retrieve the caller's name so it needs to be a CHANGE function (using "call" here)
# you can read more about host function restrictions here: https://docs.near.org/docs/develop/contracts/as/intro#view-and-change-functions
# ----
# near view $CONTRACT sayMyName
# ----
# so this is the solution, to replace "view" with "call" and include a signer
near call $CONTRACT sayMyName --account_id $OWNER
# ------------------------

# ------------------------
# the next method writes to storage.  storage is structured as key-value pairs
near call $CONTRACT saveMyName --account_id $OWNER
# ------------------------

# ------------------------
# these methods use a collection wrapper around blockchain storage
# you can read more about collections here: https://docs.near.org/docs/concepts/data-storage
near call $CONTRACT saveMyMessage '{"message":"hey again"}' --account_id $OWNER
near call $CONTRACT getAllMessages --account_id $OWNER
# ------------------------

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder support a simple demonstration of the contract.

It uses the following setup:

```txt
┌───────────────────────────────────────┬───────────────────────────────────────┐
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                   A                   │                   B                   │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
│                                       │                                       │
└───────────────────────────────────────┴───────────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands
  ```sh
  1.init.sh               # cleanup, compile and deploy contract
  2.run.sh                # call methods on the deployed contract
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linux-watch-command#191068)

'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/sample/README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

## Design

### Interface

```ts
export function showYouKnow(): void;
```

- "View" function (ie. a function that does NOT alter contract state)
- Takes no parameters
- Returns nothing

```ts
export function showYouKnow2(): bool;
```

- "View" function (ie. a function that does NOT alter contract state)
- Takes no parameters
- Returns true

```ts
export function sayHello(): string;
```

- "View" function
- Takes no parameters
- Returns a string

```ts
export function sayMyName(): string;
```

- "Change" function (although it does NOT alter state, it DOES read from `context`, [see docs for details](https://docs.near.org/docs/develop/contracts/as/intro))
- Takes no parameters
- Returns a string

```ts
export function saveMyName(): void;
```

- "Change" function (ie. a function that alters contract state)
- Takes no parameters
- Saves the sender account name to contract state
- Returns nothing

```ts
export function saveMyMessage(message: string): bool;
```

- "Change" function
- Takes a single parameter message of type string
- Saves the sender account name and message to contract state
- Returns nothing

```ts
export function getAllMessages(): Array<string>;
```

- "Change" function
- Takes no parameters
- Reads all recorded messages from contract state (this can become expensive!)
- Returns an array of messages if any are found, otherwise empty array

'''
'''--- src/sample/__tests__/README.md ---
## Unit tests

Unit tests can be run from the top level folder using the following command:

```
yarn test:unit
```

### Tests for Contract in `index.unit.spec.ts`

```
[Describe]: Greeting

 [Success]: ✔ should respond to showYouKnow()
 [Success]: ✔ should respond to showYouKnow2()
 [Success]: ✔ should respond to sayHello()
 [Success]: ✔ should respond to sayMyName()
 [Success]: ✔ should respond to saveMyName()
 [Success]: ✔ should respond to saveMyMessage()
 [Success]: ✔ should respond to getAllMessages()

    [File]: src/sample/__tests__/index.unit.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 7 pass,  0 fail, 7 total
    [Time]: 19.164ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 7 pass, 0 fail, 7 total
    [Time]: 8217.768ms
✨  Done in 8.86s.
```

'''
'''--- src/sample/__tests__/index.unit.spec.ts ---
import { addNote, deleteNote, getNotes } from "../assembly";
import { context, PersistentMap, VMContext } from "near-sdk-as";
import { notes } from "../assembly/model";

const contract = "note_app";

describe("Notes", () => {
  beforeEach(() => {
    if (notes.contains(context.sender)) {
      notes.delete(context.sender);
    }
    addNote("I am a note");
  });

  it("verifies a note is added from addNote", () => {
    expect(notes.get(context.sender)).toBeTruthy("The user key has been created on the map with a new note");
  });

  
  it("deletes contact by calling deleteNote()", () => {
    deleteNote(0);
    expect(notes.get(context.sender)).toStrictEqual([], 'Message at index "0" deleted');
  });
});
'''
'''--- src/sample/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/sample/assembly/index.ts ---
import { context, logging } from "near-sdk-as";
import {  notes } from "./model";

/* 
  Created a new function getNotes, with context.sender, 
  To get the user's AccountId
*/

export function getNotes(): string[] | null {
  return notes.get(context.sender);
}

// This takes a value, note and each note is added to an array of notes

export function addNote(note: string): void {
  const sender = context.sender;
  let notesArray: string[] = []
  // Check is a key for the current user already exists
  if (notes.contains(sender)) {
    // Assign the already existing notes to a user who's already logged in or has a key
    notesArray = notes.get(sender) as string[];
  }

  // we push the new note to an array of note and set it in the notesArray
  notesArray !== null && notesArray.push(note);
  notes.set(sender, notesArray);

  logging.log("Note added successfully");
}

export function deleteNote(noteIndex: u32): void {
  // assign the notes array of current acoount
  let notesArray = notes.get(context.sender);
  if (notesArray != null) {
    const newNotes: string[] = [];
    for (let index = 0; index < notesArray.length; index++) {
      if (index != noteIndex) {
        newNotes.push(notesArray[index]);
      }
    }

    // set the value of the account phonebook to the new array
    // phonebooks.delete(context.sender);
    notes.set(context.sender, newNotes);
    logging.log("Note deleted!");
  }
}
'''
'''--- src/sample/assembly/model.ts ---
import { PersistentMap } from "near-sdk-as";

// exporting a constant notes so it can be used outside of this file ./models file.
// Also defined a key value for our notes, in our case we used 'n'and assigned a type of `sring`
export const notes = new PersistentMap<string, string[]>("n");
'''
'''--- src/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true
},
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''