*GitHub Repository "lhjokg/rust-near"*

'''--- MyContract/Cargo.toml ---
[package]
name = "fungible-token"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- MyContract/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Lillard NEAR fungible token".to_string(),
                symbol: "lillard.li".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 6,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
            .emit();
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- README.md ---
# rust-near
'''
'''--- okx-dex/Cargo.toml ---
[package]
name = "okx-dex"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- okx-dex/src/action.rs ---
use crate::errors::ERR41_WRONG_ACTION_RESULT;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, json_types::U128, AccountId, Balance};
use std::collections::HashSet;

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapAction {
    /// Pool which should be used for swapping.
    pub pool_id: u64,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Action {
    Swap(SwapAction),
}

impl Action {
    /// Returns involved tokens in this action. Useful for checking permissions and storage.
    pub fn tokens(&self) -> Vec<AccountId> {
        match self {
            Action::Swap(swap_action) => {
                vec![swap_action.token_in.clone(), swap_action.token_out.clone()]
            }
        }
    }
}

/// Result from action execution.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ActionResult {
    /// No result.
    None,
    /// Amount of token was received.
    /// [AUDIT_02]
    Amount(U128),
}

impl ActionResult {
    pub fn to_amount(self) -> Balance {
        match self {
            // [AUDIT_02]
            ActionResult::Amount(result) => result.0,
            _ => env::panic(ERR41_WRONG_ACTION_RESULT.as_bytes()),
        }
    }
}

/// return involved tokens in an action array
pub fn get_tokens_in_actions(actions: &[Action]) -> HashSet<AccountId> {
    let mut tokens: HashSet<AccountId> = HashSet::new();
    for action in actions {
        match action {
            Action::Swap(swap_action) => {
                tokens.insert(swap_action.token_in.clone());
                tokens.insert(swap_action.token_out.clone());
            }
        }
    }
    tokens
}

'''
'''--- okx-dex/src/errors.rs ---
// Storage errors.

pub const ERR10_ACC_NOT_REGISTERED: &str = "E10: account not registered";
pub const ERR11_INSUFFICIENT_STORAGE: &str = "E11: insufficient $NEAR storage deposit";
pub const ERR12_TOKEN_NOT_WHITELISTED: &str = "E12: token not whitelisted";
pub const ERR13_LP_NOT_REGISTERED: &str = "E13: LP not registered";
pub const ERR14_LP_ALREADY_REGISTERED: &str = "E14: LP already registered";
pub const ERR15_NO_STORAGE_CAN_WITHDRAW: &str = "E15: no storage can withdraw";
pub const ERR16_STORAGE_WITHDRAW_TOO_MUCH: &str = "E16: storage withdraw too much";
pub const ERR17_DEPOSIT_LESS_THAN_MIN_STORAGE: &str = "E17: deposit less than min storage";
pub const ERR18_TOKENS_NOT_EMPTY: &str = "E18: storage unregister tokens not empty";

// Accounts.

pub const ERR21_TOKEN_NOT_REG: &str = "E21: token not registered";
pub const ERR22_NOT_ENOUGH_TOKENS: &str = "E22: not enough tokens in deposit";
// pub const ERR23_NOT_ENOUGH_NEAR: &str = "E23: not enough NEAR in deposit";
pub const ERR24_NON_ZERO_TOKEN_BALANCE: &str = "E24: non-zero token balance";
pub const ERR25_CALLBACK_POST_WITHDRAW_INVALID: &str =
    "E25: expected 1 promise result from withdraw";
// [AUDIT_05]
// pub const ERR26_ACCESS_KEY_NOT_ALLOWED: &str = "E26: access key not allowed";
pub const ERR27_DEPOSIT_NEEDED: &str = 
    "E27: attach 1yN to swap tokens not in whitelist";
pub const ERR28_WRONG_MSG_FORMAT: &str = "E28: Illegal msg in ft_transfer_call";
pub const ERR29_ILLEGAL_WITHDRAW_AMOUNT: &str = "E29: Illegal withdraw amount";

// Liquidity operations.

pub const ERR31_ZERO_AMOUNT: &str = "E31: adding zero amount";
pub const ERR32_ZERO_SHARES: &str = "E32: minting zero shares";
// [AUDIT_07]
pub const ERR33_TRANSFER_TO_SELF: &str = "E33: transfer to self";
pub const ERR34_INSUFFICIENT_LP_SHARES: &str = "E34: insufficient lp shares";
pub const ERR35_AT_LEAST_ONE_YOCTO: &str = "E35: requires attached deposit of at least 1 yoctoNEAR";
pub const ERR36_SHARES_TOTAL_SUPPLY_OVERFLOW: &str = "E36: shares_total_supply overflow";

// Action result.

pub const ERR41_WRONG_ACTION_RESULT: &str = "E41: wrong action result type";

// Contract Level
pub const ERR51_CONTRACT_PAUSED: &str = "E51: contract paused";
pub const ERR52_FROZEN_TOKEN: &str = "E52: token frozen";
pub const ERR53_TOKEN_NOT_IN_LIST: &str = "E53: token not in list";

// Swap
pub const ERR60_DECIMAL_ILLEGAL: &str = "E60: illegal decimal";
pub const ERR61_AMP_ILLEGAL: &str = "E61: illegal amp";
pub const ERR62_FEE_ILLEGAL: &str = "E62: illegal fee";
pub const ERR63_MISSING_TOKEN: &str = "E63: missing token";
pub const ERR64_TOKENS_COUNT_ILLEGAL: &str = "E64: illegal tokens count";
pub const ERR65_INIT_TOKEN_BALANCE: &str = "E65: init token balance should be non-zero";
pub const ERR66_INVARIANT_CALC_ERR: &str = "E66: encounter err when calc invariant D";
pub const ERR67_LPSHARE_CALC_ERR: &str = "E67: encounter err when calc lp shares";
pub const ERR68_SLIPPAGE: &str = "E68: slippage error";
pub const ERR69_MIN_RESERVE: &str = "E69: pool reserved token balance less than MIN_RESERVE";
pub const ERR70_SWAP_OUT_CALC_ERR: &str = "E70: encounter err when calc swap out";
pub const ERR71_SWAP_DUP_TOKENS: &str = "E71: illegal swap with duplicated tokens";
pub const ERR72_AT_LEAST_ONE_SWAP: &str = "E72: at least one swap";
pub const ERR73_SAME_TOKEN: &str = "E73: same token swap";
pub const ERR75_INVARIANT_REDUCE: &str = "E75: invariant can not reduce ";
pub const ERR76_INVALID_PARAMS: &str = "E76: invalid params";

// pool manage
pub const ERR81_AMP_IN_LOCK: &str = "E81: amp is currently in lock";
pub const ERR82_INSUFFICIENT_RAMP_TIME: &str = "E82: insufficient ramp time";
pub const ERR83_INVALID_AMP_FACTOR: &str = "E83: invalid amp factor";
pub const ERR84_AMP_LARGE_CHANGE: &str = "E84: amp factor change is too large";
pub const ERR85_NO_POOL: &str = "E85: invalid pool id";
pub const ERR86_MIN_AMOUNT: &str = "E86: amount need above min amount";
pub const ERR87_ILLEGAL_POOL_ID: &str = "E87: illegal pool id";
pub const ERR88_NOT_STABLE_POOL: &str = "E88: not stable pool";
pub const ERR89_WRONG_TOKEN_COUNT: &str = "E89: wrong token count";
pub const ERR90_FEE_TOO_LARGE: &str = "E90: fee too large";
pub const ERR91_NOT_ENOUGH_SHARES: &str = "E91: not enough shares";
pub const ERR92_TOKEN_DUPLICATES: &str = "E92: token duplicated";
pub const ERR89_WRONG_AMOUNT_COUNT: &str = "E89: wrong amount count";

// owner
pub const ERR100_NOT_ALLOWED: &str = "E100: no permission to invoke this";
pub const ERR101_ILLEGAL_FEE: &str = "E101: illegal fee";
pub const ERR102_INVALID_TOKEN_ID: &str = "E102: invalid token id";
pub const ERR103_NOT_INITIALIZED: &str = "E103: contract is not initialized";
pub const ERR104_GUARDIAN_NOT_IN_LIST: &str = "E104: guardian not in list";

//mft
pub const ERR110_INVALID_REGISTER: &str = "E110: Invalid register";

// rated pool
pub const ERR120_RATES_EXPIRED: &str = "E120: Rates expired";
// pub const ERR122_FAILED_TO_UPDATE_RATES: &str = "E122: Failed to update rates";
pub const ERR123_ONE_PROMISE_RESULT: &str = "E123: Cross-contract call should have exactly one promise result";
pub const ERR124_CROSS_CALL_FAILED: &str = "E124: Cross-contract call failed";
// pub const ERR125_FAILED_TO_APPLY_RATES: &str = "E125: Failed to apply new rates";
pub const ERR126_FAILED_TO_PARSE_RESULT: &str = "E126: Failed to parse cross-contract call result";
pub const ERR127_INVALID_RATE_TYPE: &str = "E127: Invalid rate type";

// referrals
pub const ERR130_REFERRAL_EXIST: &str = "E130: Referral already exist";
pub const ERR131_REFERRAL_NOT_EXIST: &str = "E131: Referral not exist";
pub const ERR132_ILLEGAL_REFERRAL_FEE: &str = "E132: Illegal referral fee";
'''
'''--- okx-dex/src/lib.rs ---
mod errors;
mod action;

use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue, Promise, Gas, PromiseError};
use near_sdk::utils::assert_one_yocto;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{ONE_NEAR, ONE_YOCTO};
use action::{Action};
use std::fmt;
use errors::*;

const XCC_GAS: Gas = Gas(10u64.pow(13));
const GAS: Gas = Gas(10u64.pow(14));

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Account of the owner.
    owner_id: AccountId,
    state: RunningState,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        // assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id: env::current_account_id(),
            state: RunningState::Running,
        }
    }

    #[payable]
    pub fn set_owner(&mut self, owner_id: AccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.owner_id = owner_id.clone();
    }

    //修改数据结构用这个升级
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: Contract = env::state_read().expect("failed");
        old_state.assert_owner();
        Self {
            owner_id: old_state.owner_id,
            state: RunningState::Running,
        }
    }

    #[payable]
    pub fn smart_swap(&mut self, from_token: AccountId, to_token: AccountId, amount_in: U128, min_return: U128, exchange: Vec<String>, data: Vec<String>) -> Promise {
        // assert_ne!(actions.len(), 0, "{}", ERR72_AT_LEAST_ONE_SWAP);
        //
        // let user_account = env::predecessor_account_id().to_string();
        //
        // Promise::new(to_token.clone()).function_call(
        //     "ft_balance_of".to_owned(),
        //     json!({ "account_id": user_account }).to_string().into_bytes(),
        //     0,
        //     XCC_GAS,
        // ).then(Self::ext(env::current_account_id()).balance_callback());
        //
        // let balance_before = match env::promise_result(0) {
        //     PromiseResult::NotReady => unreachable!(),
        //     PromiseResult::Successful(value) => {
        //         if let Ok(amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
        //             amount.0
        //         } else {
        //             assert!(false, "{}", ERR41_WRONG_ACTION_RESULT);
        //         }
        //     }
        //     PromiseResult::Failed => assert!(false, "{}", ERR41_WRONG_ACTION_RESULT),
        // };
        // log!("balance_before {}", balance_before);
        // let mut dex_promise = Promise::new(from_token.clone()).function_call(
        //     "ft_transfer_call".to_owned(),
        //     data.get(i).to_string().into_bytes(),
        //     to_yocto("1"),
        //     XCC_GAS,
        // );
        // for i in 1..exchange.len() {
        //     dex_promise.and(Promise::new(from_token.clone()).function_call(
        //         "ft_transfer_call".to_owned(),
        //         data.get(i).to_string().into_bytes(),
        //         to_yocto("1"),
        //         XCC_GAS,
        //     ));
        // }
        //
        //
        // log!("Swapped {} {} to {} {}", amount_in.0, from_token, amount_out.0, to_token);
        // amount_out
        let user_account = env::predecessor_account_id().to_string();
        log!("user_account {}",user_account);
        Promise::new(from_token.clone()).function_call(
            "ft_transfer_call".to_owned(),
            data.get(0).unwrap().to_string().into_bytes(),
            to_yocto("1"),
            XCC_GAS,
        ).function_call(
            "ft_balance_of".to_owned(),
            json!({ "account_id": user_account }).to_string().into_bytes(),
            to_yocto("1"),
            XCC_GAS,
        ).then(Self::ext(env::current_account_id()).balance_callback())
    }

    #[payable]
    pub fn smart_swap1(&mut self, from_token: AccountId, to_token: AccountId, amount_in: U128, min_return: U128, exchange: Vec<String>, data: Vec<String>) -> Promise {
        // amount_out
        let user_account = env::predecessor_account_id().to_string();
        let current_account_id = env::current_account_id();
        log!("user_account {} ,current_account_id {} ",user_account,current_account_id);
        let transfer_promise = Promise::new(from_token.clone())
            .function_call(
                "internal_transfer".to_owned(),
                json!({ "sender_id": user_account, "receiver_id": current_account_id,"amount":amount_in}).to_string().into_bytes(),
                ONE_YOCTO,
                GAS);
        let balancer_before = Promise::new(to_token.clone())
            .function_call(
                "ft_balance_of".to_owned(),
                json!({ "account_id": current_account_id }).to_string().into_bytes(),
                0,
                XCC_GAS);

        let swap_balancer = Promise::new(from_token.clone())
            .function_call(
                "ft_transfer_call".to_owned(),
                data.get(0).unwrap().to_string().into_bytes(),
                ONE_YOCTO,
                GAS);

        let balancer_after = Promise::new(to_token.clone())
            .function_call(
                "ft_balance_of".to_owned(),
                json!({ "account_id": current_account_id }).to_string().into_bytes(),
                0,
                XCC_GAS);

        transfer_promise
            .and(balancer_before)
            .and(swap_balancer)
            .and(balancer_after)
            .then(Self::ext(env::current_account_id()).balance_callback())
    }

    #[private]
    pub fn balance_callback(
        &self,
        #[callback_result] callback_result: Result<U128, PromiseError>,
    ) -> U128 {
        log!("The call results count {}",env::promise_results_count());
        // The callback only has access to the last action's result
        if let Ok(result) = callback_result {
            log!("The call result is {}",result.0);
            result
        } else {
            log!("The call failed and all calls got reverted");
            U128(0)
        }
    }

    pub fn get_owner(&self) -> String {
        self.owner_id.clone().to_string()
    }

    fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "{}", "E100: no permission to invoke this"
        );
    }

    fn assert_contract_running(&self) {
        match self.state {
            RunningState::Running => (),
            _ => env::panic_str(ERR51_CONTRACT_PAUSED),
        };
    }
}

pub fn to_yocto(value: &str) -> u128 {
    let vals: Vec<_> = value.split('.').collect();
    let part1 = vals[0].parse::<u128>().unwrap() * 10u128.pow(24);
    if vals.len() > 1 {
        let power = vals[1].len() as u32;
        let part2 = vals[1].parse::<u128>().unwrap() * 10u128.pow(24 - power);
        part1 + part2
    } else {
        part1
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum RunningState {
    Running,
    Paused,
}

impl fmt::Display for RunningState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RunningState::Running => write!(f, "Running"),
            RunningState::Paused => write!(f, "Paused"),
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''