*GitHub Repository "keypom/ft-contract"*

'''--- finished-contract/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- finished-contract/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- finished-contract/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- finished-contract/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;

    /// Mint FTs to a given account thus increasing the total supply.
    fn ft_mint(&mut self, account_id: AccountId, amount: U128);
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the user wants to withdraw
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the sender wants to transfer
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for ft transfer call.
        ext_ft_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
            .ft_on_transfer(sender_id.clone(), amount.into(), msg)
            // We then resolve the promise and call ft_resolve_transfer on our own contract
            // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
            )
            .into()
    }

    fn ft_mint(&mut self, account_id: AccountId, amount: U128) {
        self.internal_deposit(&account_id, amount.into());
        self.total_supply += amount.0;

        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &account_id,
            amount: &amount,
            memo: Some("FTs Minted"),
        }
        .emit();
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, get the return value and cast it to a U128.
            PromiseResult::Successful(value) => {
                // If we can properly parse the value, the unused amount is equal to whatever is smaller - the unused amount or the original amount (to prevent malicious contracts)
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                // If we can't properly parse the value, the original amount is returned.
                } else {
                    amount
                }
            }
            // If the promise wasn't successful, return the original amount.
            PromiseResult::Failed => amount,
        };

        // If there is some unused amount, we should refund the sender
        if unused_amount > 0 {
            // Get the receiver's balance. We can only refund the sender if the receiver has enough balance.
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                // The amount to refund is the smaller of the unused amount and the receiver's balance as we can only refund up to what the receiver currently has.
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                
                // Refund the sender for the unused amount.
                self.internal_transfer(&receiver_id, &sender_id, refund_amount, Some("Refund".to_string()));
                
                // Return what was actually used (the amount sent - refund)
                let used_amount = amount
                    .checked_sub(refund_amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow"));
                return used_amount.into();
            }
        }

        // If the unused amount is 0, return the original amount.
        amount.into()
    }
}

'''
'''--- finished-contract/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for force getting the balance of an account. If the account doesn't have a balance, panic with a custom message.
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Internal method for withdrawing some amount of FTs from an account. 
    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Decrease the amount from the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    /// Internal method for performing a transfer of FTs from one account to another.
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        // Ensure the sender can't transfer to themselves
        require!(sender_id != receiver_id, "Sender and receiver should be different");
        // Ensure the sender can't transfer 0 tokens
        require!(amount > 0, "The amount should be a positive number");
        
        // Withdraw from the sender and deposit into the receiver
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        
        // Emit a Transfer event
        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }

    /// Internal method for registering an account with the contract.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }

    /// Internal method for measuring how many bytes it takes to insert the longest possible account ID into our map
    /// This will insert the account, measure the storage, and remove the account. It is called in the initialization function.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}
'''
'''--- finished-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract 
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Set the bytes for the longest account ID to 0 temporarily until it's calculated later
            bytes_for_longest_account_id: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Measure the bytes for the longest account ID and store it in the contract.
        this.measure_bytes_for_longest_account_id();

        // Register the owner's account and set their balance to the total supply.
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());
        
        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- finished-contract/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- finished-contract/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of $NEAR to deposit
        let amount: Balance = env::attached_deposit();
        // If an account was specified, use that. Otherwise, use the predecessor account.
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        
        // If the account is already registered, refund the deposit.
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } 
        // Register the account and refund any excess $NEAR
        } else {
            // Get the minimum required storage and ensure the deposit is at least that amount
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            // Register the account
            self.internal_register_account(&account_id);
            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes for the longest account ID and multiplying by the current byte cost
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();
        
        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account. Available will always be 0 since you can't overpay for storage.
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}

'''
'''--- package.json ---
{
    "name": "ft-tutorial",
    "version": "1.0.0",
    "description": "Zero to Hero FT Tutorial",
    "author": "Ben Kurrek",
    "license": "ISC",
    "scripts": {
        "build": "cd finished-contract && ./build.sh && cd .."
    }
}

'''