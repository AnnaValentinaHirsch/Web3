*GitHub Repository "near/multichain-relayer-server"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
      - name: Run tests
        run: cargo test --all-targets --all-features

  linting:
    name: Linting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Check formatting
        run: |
          cargo fmt --check

      - name: Run Clippy
        if: always()
        run: cargo clippy --all-targets --all-features -- -D warnings

'''
'''--- Cargo.toml ---
[package]
name = "multichain-relayer-server"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# ethers dependencies for EVM txn sending and RPC calls
async-trait = "0.1.73"
ethers = "2.0.10"
ethers-core = "2.0.10"
ethers-providers = "2.0.10"
thiserror = "1.0.48"

# server dependencies
axum = "0.6.20"
lazy_static = "1.4.0"
reqwest = "0.11.20"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.55"
tokio = { version = "1", features = ["full"] }
toml = "0.8.0"
tower = "0.4.13"
tower-http = { version = "0.4.4", features = ["trace"] }
tracing = "0.1"
tracing-flame = "0.2.0"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

[dev-dependencies]
hex = "0.4.3"

'''
'''--- README.md ---
# multichain-relayer-server
Pagoda Implementation of Multichain Relayer Server facilitating cross chain transactions enabling Chain Abstraction.

NOTE: this is not production ready yet. Production ready version will be available by March 31. Feel free to experiment in the meantime. 

## Technical System Design
Below is a Design Diagram of the entire multichain relayer system.

- The [gas station contract](https://github.com/near/multichain-gas-station-contract) and the [mpc signing service contract](https://github.com/near/mpc-recovery/tree/main/contract) are in the green box which take place on NEAR.
- This multichain relayer server repo focuses on the purple/blue Multichain Relayer Core Backend Services Box in the middle and the connections to the XChain systems in the red box via RPCs.
- The XChain Settlement that's happening in the yellow box is currently manual and will be automated in the future.

![multichain_relayer_technical_design.png](multichain_relayer_technical_design.png)

## Technical System Description
1. The wallet sends a NEAR transaction to the gas station contract that contains 2 actions
   1. A transfer of NEAR (or FT Transfer in the future) to cover gas on the foreign chain
   2. A `create_transaction` function call to the gas station contract `canhazgas.testnet` containing the unsigned foreign chain transaction to be signed by the MPC signing service, assuming the unsigned transaction passes validation.
2. The Gas Station Contract calls the MPC signing service to sign both a funding transaction, which ensures the user's foreign chain account has sufficient gas to execute the desired transaction, and signs the unsigned foreign chain transaction.
3. Upon receipt of both the signed transactions, the Gas Station Contract emits an event which is picked up by the indexer, which then calls the `/send_funding_and_user_signed_txns` with the 2 signed transactions from the indexer.
4. The multichain relayer server sends the funding transaction to the foreign chain RPC to fund the user's account with gas.
5. After the gas funding transaction is confirmed, the multichain relayer server calls the foreign chain RPC again to send the signed transaction initiated by the user in step 1.
6. The Cross Chain Settlement takes care of selling the extra NEAR being sent to the gas station contract for gas tokens on foreign chains as well as bridging the tokens to the other chains. This process is currently manual, but will be automated in partnership with market makers in the future.

## Supported Chains
- BSC testnet
- BSC Mainnet 
- ETH Sepolia Testnet 
- ETH Mainnet 
- More chains coming soon!

## Multichain Relayer Description
- The main function of this server is interfacing with foreign chain RPCs sending both presigned funding transactions to cover gas and the actual presigned transaction once the funding is done. 
- The Multichain relayer is meant to be deployed alongside the [gas-station-event-indexer](https://github.com/near/gas-station-event-indexer) on the same server so that the gas station event indexer can call the multichain relayer server via IPC instead of having to send the request over the network introducing extra latency to the system.
- Although the multichain relayer is a server in current design of this system, the goal is to package this as a library that can be called on the client side of the wallet. This will make the system more decentralized.
 

## Functionality
1. `/send_funding_and_user_signed_txns` which handles both
   1. Funding the user's xchain account with gas from the paymaster treasury account, which is provided as a raw signed transaction
   2. Sending the user's raw signed transaction (in hexadecimal in EVM case) after the funding transaction has been confirmed on the foreign chain
2. (MVP only) `/get_balance_for_account` endpoint that gets the native gas token (BNB) balance for an account. AKA Poor man's indexing

## Total Time Expectations for the End User
It depends on the chain, but in our current estimation 50-90% of the time will be on NEAR calling and waiting for the signing to complete on the MPC service. 
The signing service will take 15-30 seconds. 
We assume that both the signing of the foreign chain transaction and the gas funding transaction happen in parallel. 
On BSC mainnet (not beaconchain which has 1 second finality) with 3 second blocktimes there should be 2 blocks for confirmation optimistically bringing the total to 6 seconds optimistically/transaction on BSC. 
We need to make 2 transactions, so that's 12-24 seconds on BSC assuming 2-4 blocks for finality. Add in some network overhead for each step in the process, especially the indexer picking up the emitted event (~5-7 seconds), and we're at 30-60 seconds/transaction on BSC. 
For Solana it would be closer to 20-30 seconds (0.4 second block time, 1 block confirmation). See table 1 of https://usa.visa.com/solutions/crypto/deep-dive-on-solana.html for more confirmation times. 

L2 real finality times can over a day for finality unless we trust a centralized sequencer for soft confirmations, which may be as fast as a few seconds as in the case of zksync era https://era.zksync.io/docs/reference/concepts/finality.html#instant-confirmations.

The difference between optimistic or soft confirmations vs real finality is something we should consider. We may get better finalized guarantees when the Eigenlayer-Near Partnership is live https://pages.near.org/blog/near-foundation-and-eigen-labs-partner-to-enable-faster-cheaper-web3-transactions-for-ethereum-rollups-via-eigenlayer/. 3-4 second finality for all ETH L2s is much more manageable.

## Future Directions
### Scale:
- Moar Chainzzz
- Better Capital Efficiency with ~real-time settlement using Orderly + professional Market Makers
### Decentralization:
- Replace Multichain Relayer Server with Client Side Libraries
- Multiple Market Makers running Relayer Servers
- Txn Trie Inclusion Proofs
### Broader Wallet Support:
- Provide Chain Abstraction Services to wallets that donâ€™t implement MPC
### Intent Relayers
- AI is able to execute appropriate transactions on behalf of the user getting them the best price across all chains. 
  - This involves aggregating and indexing FT, NFT market dapps.
  - i.e. User has **_SWEAT_** they'd like to **_swap_** for **_BTC_**. From these keywords, AI calls multichain relayer services to execute this action on their behalf. The actual execution may look like the user's SWEAT is sold on Orderly on the NEAR chain and they end up receiving WBTC on SOL account. 

'''
'''--- config.toml ---
flametrace_performance = true

# EVM chain reference: https://github.com/alloy-rs/chains/blob/main/assets/chains.json
# chains: https://chainlist.org/
# Free RPC: https://www.ankr.com/rpc/
[chains]

# Ethereum L2 Networks - Mainnets
"42161" = { name = "ARBITRUM_ONE_MAINNET", rpc_url = "https://arb1.arbitrum.io/rpc", supported = false }
"10" = { name = "OPTIMISM_MAINNET", rpc_url = "https://mainnet.optimism.io", supported = false }
"zksync-mainnet" = { name = "ZKSYNC_MAINNET", rpc_url = "https://rpc.zksync.io", supported = false }
"starknet-mainnet" = { name = "STARKNET_MAINNET", rpc_url = "https://starknet.io", supported = false }
"loopring-mainnet" = { name = "LOOPRING_MAINNET", rpc_url = "https://rpc.loopring.io", supported = false }

# Ethereum L2 Networks - Testnets
"421611" = { name = "ARBITRUM_RINKEBY", rpc_url = "https://rinkeby.arbitrum.io/rpc", supported = false }
"69" = { name = "OPTIMISM_KOVAN", rpc_url = "https://kovan.optimism.io", supported = false }
"zksync-testnet" = { name = "ZKSYNC_TESTNET", rpc_url = "https://rinkeby-api.zksync.io/jsrpc", supported = false }
"starknet-testnet" = { name = "STARKNET_TESTNET", rpc_url = "https://goerli.starknet.io", supported = false }
"loopring-testnet" = { name = "LOOPRING_TESTNET", rpc_url = "https://testnet.loopring.io", supported = false }

# Solana Network
"solana" = { name = "SOLANA_MAINNET", rpc_url = "https://api.mainnet-beta.solana.com", supported = false }
"solana-testnet" = { name = "SOLANA_TESTNET", rpc_url = "https://api.testnet.solana.com", supported = false }

# Bitcoin Network
"bitcoin" = { name = "BITCOIN_MAINNET", rpc_url = "https://your-bitcoin-node.example.com", supported = false }
"bitcoin-testnet" = { name = "BITCOIN_TESTNET", rpc_url = "https://your-bitcoin-testnet-node.example.com", supported = false }

# Ethereum Networks
"1" = { name = "ETH_MAINNET", rpc_url = "https://rpc.ankr.com/eth", supported = true }
"11155111" = { name = "SEPOLIA_TESTNET", rpc_url = "https://rpc.sepolia.dev", supported = true }
"5" = { name = "ETH_GOERLI", rpc_url = "https://goerli.gateway.tenderly.co", supported = false }

# Binance Smart Chain
"56" = { name = "BSC_MAINNET", rpc_url = "https://bsc-dataseed.binance.org", supported = true }
"97" = { name = "BSC_TESTNET", rpc_url = "https://data-seed-prebsc-1-s1.binance.org:8545", supported = true }

# Polygon (MATIC) Networks
"137" = { name = "POLYGON_MAINNET", rpc_url = "https://polygon-rpc.com/", supported = false }
"80001" = { name = "MUMBAI_TESTNET", rpc_url = "https://rpc-mumbai.maticvigil.com", supported = false }

# Avalanche Networks
"43114" = { name = "AVAX_MAINNET", rpc_url = "https://api.avax.network/ext/bc/C/rpc", supported = false }
"43113" = { name = "FUJI_TESTNET", rpc_url = "https://api.avax-test.network/ext/bc/C/rpc", supported = false }

'''
'''--- integration_tests/README.md ---
Instructions on how to run end-to-end tests on the entire multichain relayer system.  
# Run
1. Update the transaction details of the EVM transaction you want to send in `generate_rlp_evm_txn.py` then run the script and save the RLP hex string output. 
   1. If that doesn't work, try running the `generate_eip1559_rlp_hex()` test in tests/tests.rs - python and rust output different hex rlp excoded txns :/  
   
2. Ensure the [gas station indexer](https://github.com/near/gas-station-event-indexer/tree/main) is running locally
3. Ensure the multichain server is configured correctly (`config.toml`) and running: `cargo run`

4. Construct the signed transaction using the [near-cli-rs](https://github.com/near/near-cli-rs).
   The receiver account ID should be the gas station contract.
   You will need 2 actions if you want the gas station to cover your gas cost on the foreign chain:
   1 to send the NEAR equivalent and 1 function call to the gas station.
   You should transfer the amount of NEAR that's needed to cover gas both on NEAR and on the foreign chain.
   You also need to paste in the RLP generated hex for the EVM transaction you want on the other chain generated in step 1.
   When it asks you to send or display, choose send.
   Example below:
```shell
near contract call-function as-transaction canhazgas.testnet create_transaction json-args '{"transaction_rlp_hex":"eb80851bf08eb000825208947b965bdb7f0464843572eb2b8c17bdf27b720b14872386f26fc1000080808080","use_paymaster":true}' prepaid-gas '100.000 TeraGas' attached-deposit '0.5 NEAR' sign-as nomnomnom.testnet network-config testnet sign-with-keychain send
```
5. Get the `"id"` from the receipts from the call in step 4, and use that to call `sign_next` twice:
- `near contract call-function as-transaction canhazgas.testnet sign_next json-args '{"id":"16"}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as nomnomnom.testnet network-config testnet sign-with-keychain send`

Optional for testing purposes:
- Instead of creating the signed txn and calling the gas station contract to sign the transaction, you can get the recently signed transactions by calling: 
  - `near contract call-function as-read-only canhazgas.testnet list_signed_transaction_sequences_after json-args '{"block_height":"157111000"}' network-config testnet now` replacing the blockheight with a more recent blockheight
  - This will return something like the output below. Take an individual entry in the list of jsons and send that as the payload of a POST request to the `/send_funding_and_user_signed_txns` endpoint:
```json
[
  {
    "created_by_account_id": "b807806adcb73f6aecb5ed98bb8bd7bbe7bbf8ed342596ab700ef6b050abc4c3",
    "foreign_chain_id": "97",
    "signed_transactions": [
      "0x02f873610385174876e80085174876e80082520894c89663ac6d169bc3e2e0a99d9fe96f2e82bcc307870eebe0b40e800080c080a0712d44ba4cd7567764231e21f054c5e7d008055222820e9d5ba148ede48755f7a06e8b812d37047593fc51fce7254ea7aef89927cada729bc903cd36fa9659dce4",
      "0x02f873618085174876e80085174876e80082520894ef55a8bdf4498ea0af88bc54efb29608bb25e130872aa1efb94e000080c080a017d7024fe9e32ad8da1181729fac7e6a45311c47bf59f2b5a8b5e9fe002c0617a04ad725b362cf12c6e066c5b0b7ecbbf08f5e4d0a240337e6ddc8076f0528e3e5"
    ]
  },
...
  {
    "created_by_account_id": "b807806adcb73f6aecb5ed98bb8bd7bbe7bbf8ed342596ab700ef6b050abc4c3",
    "foreign_chain_id": "97",
    "signed_transactions": [
      "0x02f873610185174876e80085174876e80082520894c89663ac6d169bc3e2e0a99d9fe96f2e82bcc307870eebe0b40e800080c001a0ff19fe769246de8483b986e5aeaa3360bfb74f238e2a91ea353dac9aad9e24a0a020485dcd2c64172b9bc058b7813646dafbf2f27d51aae388b074e514fdb6de05",
      "0x02f873618085174876e80085174876e80082520894ef55a8bdf4498ea0af88bc54efb29608bb25e130872e2f6e5e14800080c001a0dac67c383e8de3211f3c5d360cc2e9a21d160711fc3f80113ac525169317e2eca07140a1d0d1528b6eaf9fac4bb1bd44c1c4f63bb956292b0211a0dad1748e2eea"
    ]
  }
]
```

'''
'''--- integration_tests/__init__.py ---

'''
'''--- integration_tests/generate_rlp_evm_txn.py ---
from eth_account._utils.legacy_transactions import encode_transaction, serializable_unsigned_transaction_from_dict
import rlp
from rlp.sedes import List, BigEndianInt, Binary, binary
from web3 import Web3

def generate_rlp_encoded_transaction(is_eip_1559: bool = False):
    # BSC Testnet parameters
    # This example assumes a network that supports EIP-1559.
    chain_id = 97  # Update accordingly
    nonce = 0  # Increment accordingly
    to = '0x7b965bDB7F0464843572Eb2B8c17BdF27B720b14'  # Recipient address
    value = Web3.to_wei(0.01, 'ether')  # Amount to send

    if is_eip_1559:
        # EIP-1559 transaction parameters
        max_priority_fee_per_gas = Web3.to_wei(2, 'gwei')  # Tip for the miner
        max_fee_per_gas = Web3.to_wei(100, 'gwei')  # Max fee per gas
        gas_limit = 21000  # Standard gas limit for a simple transaction
        data = b''  # No data for a simple transfer

        tx_fields = {
            'chainId': chain_id,
            'nonce': nonce,
            'maxPriorityFeePerGas': max_priority_fee_per_gas,
            'maxFeePerGas': max_fee_per_gas,
            'gas': gas_limit,
            'to': to,
            'value': value,
            'data': data,
            'type': '0x2',  # Indicates an EIP-1559 transaction
            'accessList': [],  # Optional access list
        }

        # Init the sedes for the transaction
        tx_sedes = List([
            BigEndianInt(),  # chainId
            BigEndianInt(),  # nonce
            BigEndianInt(),  # maxPriorityFeePerGas
            BigEndianInt(),  # maxFeePerGas
            BigEndianInt(),  # gas
            Binary.fixed_length(20),  # to address, fixed length of 20 bytes
            BigEndianInt(),  # value
            Binary(),  # data, variable length
            List([]),  # accessList
        ])

        # Assuming the rest of your transaction data is correctly defined in tx_list
        tx_list = [
            tx_fields['chainId'],
            tx_fields['nonce'],
            tx_fields['maxPriorityFeePerGas'],
            tx_fields['maxFeePerGas'],
            tx_fields['gas'],
            Web3.to_bytes(hexstr=tx_fields['to']),
            tx_fields['value'],
            tx_fields['data'],
            tx_fields['accessList'],
        ]

        # Now encode with the corrected sedes
        encoded_tx = rlp.encode(tx_list, sedes=tx_sedes)
        print(encoded_tx)

        # Convert to hex
        encoded_tx_hex = '0x' + encoded_tx.hex()

        # Output the hex RLP-encoded transaction
        print(f'RLP-Encoded Transaction: {encoded_tx_hex}')

    else:
        # Legacy transaction parameters
        gas_price = Web3.to_wei(120, 'gwei')
        gas_limit = 21000
        data = ''  # No data for a simple transfer

        tx_dict = {
            'nonce': nonce,
            'gasPrice': gas_price,
            'gas': gas_limit,
            'to': to,
            'value': value,
            'data': data,
            'chainId': chain_id,
        }

        # Create a serializable unsigned transaction
        unsigned_tx = serializable_unsigned_transaction_from_dict(tx_dict)

        # RLP-encode the transaction (EIP-1559 transactions require passing the correct transaction type to the encoder)
        rlp_encoded_tx = encode_transaction(unsigned_tx, vrs=(0, 0, 0))

        # Output the hex RLP-encoded transaction
        print(f'RLP-Encoded Transaction: {rlp_encoded_tx.hex()}')

if __name__ == '__main__':
    generate_rlp_encoded_transaction(is_eip_1559=True)

'''
'''--- integration_tests/integration_test.py ---
import json
import requests
from typing import List

def get_account_balance(address: str):
    url = "http://localhost:3030/get_balance_for_account"
    payload = {"address": address}
    response = requests.get(url, json=payload)
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception("Failed to fetch account balance.")

def send_transaction_to_near_rpc(b64_txn: str, use_paymaster: bool, chain_id: str):
    near_rpc_url = "https://rpc.testnet.near.org"
    payload = {
        "jsonrpc": "2.0",
        "id": "1",
        "method": "broadcast_tx_commit",
        "params": [
            b64_txn
        ]
    }
    response = requests.post(near_rpc_url, json=payload)
    if response.status_code == 200:
        return response.json()  # Assuming this returns the required list of signed_transactions and chain_id
    else:
        raise Exception("Failed to interact with NEAR RPC.")

def send_signed_transactions(signed_transactions: List[str], chain_id: str):
    url = "http://localhost:3030/send_funding_and_user_signed_txns"
    payload = {
        "signed_transactions": signed_transactions,
        "chain_id": chain_id
    }
    response = requests.post(url, json=payload)
    if response.status_code != 200:
        raise Exception("Failed to send raw transactions.")

# Step 1: Get initial balance
initial_balance = get_account_balance("0x48cf9dA81d8c9FE834093eCE58ea7221aBc19DB2")
print("Initial balance:", initial_balance)

# Step 2: Prepare and encode RLP transaction
# paste this in from output of running `near` rust cli to construct the transaction
# b64_near_transaction_with_rlp_hex = "TODO_rlp_encoded_transaction_here"
b64_near_transaction_with_rlp_hex = "EQAAAG5vbW5vbW5vbS50ZXN0bmV0AK/HILx7aUbcVWUI9LVl4fD6vaMK5nOJVBHhhhjW0aGqmKlrbzd9AAARAAAAY2FuaGF6Z2FzLnRlc3RuZXTaAUuW61F2txi/BQsX8PbB59NV7LuUHiu0n9mFKitd7wEAAAACEgAAAGNyZWF0ZV90cmFuc2FjdGlvbocAAAB7InRyYW5zYWN0aW9uX3JscF9oZXgiOiJlYjgwODUxYmYwOGViMDAwODI1MjA4OTQ3Yjk2NWJkYjdmMDQ2NDg0MzU3MmViMmI4YzE3YmRmMjdiNzIwYjE0ODcyMzg2ZjI2ZmMxMDAwMDgwODA4MDgwIiwidXNlX3BheW1hc3RlciI6dHJ1ZX0AQHoQ81oAAAAAgNB2ZucN4WkAAAAAAAAAcYC44wS99M6jz6pjBxekk3DT5uSG0AHmpg90j1WZ3k1WVRFUIVolVRzoMk7SAUWLzBpgYEmnFqAI/7zRa1tMBw=="
chain_id = "97"

# Step 3: Use NEAR RPC to submit the transaction
near_rpc_result = send_transaction_to_near_rpc(
    b64_txn=b64_near_transaction_with_rlp_hex,
    use_paymaster=True,
    chain_id=chain_id
)
print("Near RPC Result:", json.dumps(near_rpc_result, indent=4))

# Step 4: Send the signed_transactions to localhost
foreign_chain_tx_result = send_signed_transactions(near_rpc_result["signed_transactions"], near_rpc_result["chain_id"])
print("Foreign Chain Tx Result:", foreign_chain_tx_result)

# Step 5: Get updated balance
updated_balance = get_account_balance("0x48cf9dA81d8c9FE834093eCE58ea7221aBc19DB2")
print("Updated balance:", updated_balance)

# Step 6: Compare balances and assert the condition
# TODO :
#  this integration test is outdated and only tests part of the flow
#  either change the response format of get_balance_for_address or change the parsing of response
# assert 0.01 < (initial_balance - updated_balance) / 10**18 < 0.015, "The balance difference does not match expected."

print("Transaction processed successfully. Balance difference is within the expected range.")

'''
'''--- integration_tests/requirements.txt ---
eth_account
rlp
web3

'''
'''--- src/main.rs ---
mod structs;
mod util;

#[macro_use]
extern crate lazy_static;

use axum::{
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post},
    Json, Router,
};
use ethers::core::types::U256;
use serde_json::json;
use std::collections::HashSet;
use std::fs;
use std::net::SocketAddr;
use structs::{
    BalanceRequestPayload, Config, EvmResponse, EvmRpcRequest, RpcError, TransactionRequest,
};
use tower_http::trace::TraceLayer;
use tracing::{error, info, instrument};
use tracing_flame::FlameLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// Constants
lazy_static! {
    static ref CONFIG: Config = load_config();
    static ref SUPPORTED_CHAINS: HashSet<String> = {
        CONFIG
            .chains
            .iter()
            .filter_map(|(key, value)| {
                if value.supported {
                    Some(key.clone())
                } else {
                    None
                }
            })
            .collect()
    };
}

fn load_config() -> Config {
    let config_str = fs::read_to_string("config.toml").expect("Failed to read config.toml");
    toml::from_str(&config_str).expect("Failed to parse config.toml")
}
// TODO utoipa and OpenApi docs

#[tokio::main]
async fn main() {
    // initialize tracing (aka logging)
    if CONFIG.flametrace_performance {
        setup_global_subscriber();
        info!("default tracing setup with flametrace performance ENABLED");
    } else {
        tracing_subscriber::registry()
            .with(tracing_subscriber::fmt::layer())
            .init();
        info!("default tracing setup with flametrace performance DISABLED");
    }
    info!("Configured support for {} chain(s)", SUPPORTED_CHAINS.len());

    let app = Router::new()
        .route(
            "/send_funding_and_user_signed_txns",
            post(send_funding_and_user_signed_txns),
        )
        .route("/get_balance_for_account", get(get_balance_for_account))
        // See https://docs.rs/tower-http/0.1.1/tower_http/trace/index.html for more details.
        .layer(TraceLayer::new_for_http());

    let addr = SocketAddr::from(([0, 0, 0, 0], 3030));
    println!("Listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

fn setup_global_subscriber() -> impl Drop {
    let fmt_layer = tracing_subscriber::fmt::Layer::default();

    let (flame_layer, _guard) = FlameLayer::with_file("./tracing.folded").unwrap();

    tracing_subscriber::registry()
        .with(fmt_layer)
        .with(flame_layer)
        .init();
    _guard
}

#[instrument]
async fn send_funding_and_user_signed_txns(
    Json(payload): Json<TransactionRequest>,
) -> impl IntoResponse {
    info!("Received /send_funding_and_user_signed_txns request: {payload:#?}");

    let funding_txn_str: String = payload.signed_transactions[0].clone();
    let user_txn_str: String = payload.signed_transactions[1].clone();
    let chain_id: String = payload.foreign_chain_id.clone();
    if !SUPPORTED_CHAINS.contains(&chain_id) {
        let error_msg = format!("Unsupported chain_id: {chain_id}");
        error!("{error_msg}");
        return (StatusCode::BAD_REQUEST, error_msg).into_response();
    }
    let rpc_url: String = CONFIG.chains.get(&chain_id).unwrap().rpc_url.clone();

    // Send the first transaction (funding)
    let evm_funding_request = EvmRpcRequest {
        jsonrpc: "2.0".to_string(),
        method: "eth_sendRawTransaction".to_string(),
        params: vec![funding_txn_str.clone()],
        id: 1, // if needed change id
    };
    info!("Sending Funding Transaction: {evm_funding_request:#?}");

    let client = reqwest::Client::new();
    let evm_funding_http_response = match client
        .post(rpc_url.clone())
        .json(&evm_funding_request)
        .send()
        .await
    {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse EVM funding response");
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send EVM funding request",
            )
                .into_response();
        }
    };

    let evm_funding_response: EvmResponse = match evm_funding_http_response.json().await {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse funding response");
            return (StatusCode::BAD_REQUEST, "Failed to parse funding response").into_response();
        }
    };
    info!("Funding Response: {evm_funding_response:#?}");
    if evm_funding_response.error.is_some() {
        let result: RpcError = evm_funding_response.error.unwrap();
        let result_str = json!(result).to_string();
        return (StatusCode::BAD_REQUEST, result_str).into_response();
    }

    // Send the second transaction (actual user txn)
    let evm_user_txn_request = EvmRpcRequest {
        jsonrpc: "2.0".to_string(),
        method: "eth_sendRawTransaction".to_string(),
        params: vec![user_txn_str.clone()],
        id: 1, // if needed change id
    };
    info!("Sending User Transaction: {evm_user_txn_request:#?}");

    let client = reqwest::Client::new();
    let response = match client
        .post(rpc_url.clone())
        .json(&evm_user_txn_request)
        .send()
        .await
    {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse user foreign chain txn response");
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send user foreign chain txn request",
            )
                .into_response();
        }
    };

    let evm_user_txn_response: EvmResponse = match response.json().await {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse user foreign chain txn response");
            return (
                StatusCode::BAD_REQUEST,
                "Failed to parse user foreign chain txn response",
            )
                .into_response();
        }
    };
    info!("User Foreign Chain Txn Response: {evm_user_txn_response:#?}");
    return if evm_user_txn_response.result.is_some() {
        let result: String = evm_user_txn_response.result.unwrap();
        (StatusCode::OK, result).into_response()
    } else {
        let result: RpcError = evm_user_txn_response.error.unwrap();
        let result_str = json!(result).to_string();
        (StatusCode::BAD_REQUEST, result_str).into_response()
    };
}

// TODO Post MVP remove
#[instrument]
async fn get_balance_for_account(Json(payload): Json<BalanceRequestPayload>) -> impl IntoResponse {
    let address = payload.address;
    let evm_balance_request = EvmRpcRequest {
        jsonrpc: "2.0".to_string(),
        method: "eth_getBalance".to_string(),
        params: vec![address.clone(), "latest".to_string()],
        id: 1, // if needed change id
    };
    info!("Balance Request: {evm_balance_request:#?}");

    let client = reqwest::Client::new();
    let evm_balance_http_response = match client
        .post("https://data-seed-prebsc-1-s1.binance.org:8545")
        .json(&evm_balance_request)
        .send()
        .await
    {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse EVM balance response");
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send EVM balance request",
            )
                .into_response();
        }
    };

    let evm_balance_response: EvmResponse = match evm_balance_http_response.json().await {
        Ok(res) => res,
        Err(_) => {
            error!("Failed to parse response");
            return (StatusCode::BAD_REQUEST, "Failed to parse response").into_response();
        }
    };
    // default to 0 balance if not found
    let hex_str: String = evm_balance_response.result.unwrap_or("0x0".to_string());
    let balance: U256 = util::convert_hex_to_u256(&hex_str).unwrap();
    info!("balance: {balance:#?} for account: {address:#?}");

    (StatusCode::OK, balance.to_string()).into_response()
}

'''
'''--- src/structs.rs ---
use serde::{Deserialize, Serialize};

use std::collections::HashMap;

#[derive(Deserialize)]
pub struct Config {
    pub(crate) flametrace_performance: bool,
    pub(crate) chains: HashMap<String, ChainConfig>,
}

#[derive(Deserialize)]
pub struct ChainConfig {
    #[allow(dead_code)] // may want to use this in the future
    pub(crate) name: String,
    pub(crate) rpc_url: String,
    pub(crate) supported: bool,
}

#[derive(Clone, Debug, Deserialize)]
pub struct TransactionRequest {
    pub(crate) signed_transactions: [String; 2],
    pub(crate) foreign_chain_id: String,
}

#[derive(Clone, Debug, Serialize)]
pub struct TransactionResponse {
    pub(crate) status: String,
    pub(crate) transaction_hash: Option<String>,
}

#[derive(Clone, Debug, Deserialize)]
pub struct BalanceRequestPayload {
    pub(crate) address: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EvmRpcRequest {
    pub jsonrpc: String,
    pub(crate) method: String,
    pub(crate) params: Vec<String>,
    pub(crate) id: u32,
}

#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct RpcError {
    pub(crate) code: i32,
    pub(crate) message: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EvmResponse {
    pub(crate) jsonrpc: String,
    pub(crate) id: u32,
    pub(crate) result: Option<String>,
    pub(crate) error: Option<RpcError>,
}

'''
'''--- src/util.rs ---
use ethers::core::types::U256;

pub(crate) fn convert_hex_to_u256(hex_str: &str) -> Result<U256, &'static str> {
    // Remove the '0x' prefix if present
    let clean_hex = hex_str.strip_prefix("0x").unwrap_or(hex_str);

    // Convert to U256
    U256::from_str_radix(clean_hex, 16).map_err(|_| "Invalid hex string")
}

'''
'''--- tests/tests.rs ---
use ethers_core::types::transaction::eip1559::Eip1559TransactionRequest;
use ethers_core::types::{TransactionRequest, U256};

// from https://github.com/near/multichain-gas-station-contract/blob/3e544fa5f4fa383f8026d528c7a7c6c7c12432f8/tests/tests.rs#L160-L173
#[test]
//#[ignore = "generate a payload signable by the contract"]
fn generate_eth_rlp_hex() {
    let bsc_testnet_legacy_transaction = TransactionRequest {
        chain_id: Some(97.into()),
        from: None,
        to: Some("0x7b965bDB7F0464843572Eb2B8c17BdF27B720b14".into()),
        data: None,
        gas: Some(21000.into()),
        gas_price: Some(120.into()),
        value: Some(U256::from(10000000000000000_i64)), // 0.01 BNB
        nonce: Some(0.into()),
    };

    println!("{}", hex::encode(bsc_testnet_legacy_transaction.rlp()));
}

// from https://github.com/near/multichain-gas-station-contract/blob/edc252a07bc1c7e09538c56b9703cfe7dd70a353/contract/tests/tests.rs#L96
#[test]
fn generate_eip1559_rlp_hex() {
    let bsc_testnet_eip1559_transaction = Eip1559TransactionRequest {
        chain_id: Some(97.into()),
        from: None,
        to: Some("0x7b965bDB7F0464843572Eb2B8c17BdF27B720b14".into()),
        data: None,
        gas: Some(21000.into()),
        max_fee_per_gas: Some(100.into()),
        max_priority_fee_per_gas: Some(100.into()),
        access_list: vec![].into(),
        value: Some(U256::from(10000000000000000_i64)), // 0.01 BNB
        nonce: Some(0.into()),
    };
    println!("{}", hex::encode(bsc_testnet_eip1559_transaction.rlp()));
}

// NOTE: this generates a different output than the python script generate_rlp_evm_txn.py

'''