*GitHub Repository "pvolnov/ca-evm-wallet"*

'''--- README.md ---

# Chain abstraction EVM wallet

## Concept

The "Chain Signature" feature in smart contracts revolutionizes transaction signing and management. It allows smart contracts to sign transactions using a private key, which is distributed and securely held by a group of validators. The "CA EVM Wallet" leverages this technology, offering a wallet for any EVM-compatible network. Unlike traditional wallets, it permits users to give third parties full or limited rights to sign transactions on their behalf, enhancing security and flexibility. Trusted apps can verify arguments and sign transactions for users, providing a secure and versatile transaction environment.

Key use cases of this approach include:
- Account sales: Facilitating the secure transfer EVM account ownership.
- Seed phrase modification: Allowing users to change their seed phrases for enhanced security.
- Native token swaps across networks
- Delayed and limited orders on DEXs
- Subscriptions and regular payments
- NFT trading: Streamlining the process of buying, selling, and exchanging Non-Fungible Tokens at special time / conditions

## Introduction

This smart contract is designed to implement an Ethereum wallet interface on the NEAR blockchain. Its primary functionalities include the creation of Ethereum wallets within the contract with various paths (addresses), transferring access to these wallets, and signing Ethereum transactions.

## Core Functions

### 1. Create Wallet (`create_wallet`)
- **Description**: Creates a new Ethereum wallet.
- **NEAR CLI Command**:

```bash
near call [contract] create_wallet --accountId [your NEAR account]
```

- **Example**:
Creates a wallet with a unique path and grants access to the creator.

### 2. Sign Transaction (`sign`)
- **Description**: Signs a transaction with the given payload.
- **NEAR CLI Command**:

```bash
near call [contract] sign '{"payload": "[payload]", "wallet_id": "[wallet ID]"}' --accountId [your NEAR account]
```

- **Example**:
Signs a provided payload for a specified wallet.

### 3. Grant Access (`grant_assess`)
- **Description**: Grants access to the wallet to another NEAR account.
- **NEAR CLI Command**:

```bash
near call [contract] grant_assess '{"wallet_id": "[wallet ID]", "account_id": "[NEAR account]"}' --accountId [your NEAR account]
```

- **Example**:
Grants a user access to a specific wallet (other dapp) or sell account

### 4. Revoke Access (`revoke_assess`)
- **Description**: Revokes access to the wallet from a specified NEAR account.
- **NEAR CLI Command**:

```bash
near call [contract] revoke_assess '{"wallet_id": "[wallet ID]", "account_id": "[NEAR account]"}' --accountId [your NEAR account]
```

- **Example**:
Revokes a user's access to a specific wallet.

### 5. Ethereum Transfer (`eth_transfer_call`)
- **Description**: Initiates an Ethereum transaction.
- **NEAR CLI Command**:

```bash
near call [contract] eth_transfer_call '{"wallet_id": "[wallet ID]", "recipient": "[recipient]", "amount": [amount], "nonce": [nonce], "gas_price": [gas price], "gas_limit": [gas limit], "data": "[data]"}' --accountId [your NEAR account]
```

## Security and Future Perspectives

### Security
- **Authentication**: Each signature requires validation by NEAR Validators
- **Private Key**: All private keys storing distributed on the MPC node network
- **Access Management**: The `grant_assess` and `revoke_assess` functions allow for control over wallet access.

## Next steps

For a complete wallet, it lacks implementation of some key methods, which was impossible to do due to weak CA documentation. They will be added in the future during the project development

- get_public_key(path) - method to retrieve public key and eth address by path
- check the network on which the transaction will be executed
- possibility to give access to signatures of certain methods and sum limits

This smart contract on the NEAR blockchain provides a secure and efficient way to manage Ethereum wallets and transactions, paving the way for broader blockchain interoperability and enhanced user experience in the crypto ecosystem.
# hot-wallet-contract

'''
'''--- client/cli.js ---
const bs58 = require('bs58');
const crypto = require('crypto');
const elliptic = require('elliptic');
const EC = elliptic.ec;
const ec = new EC('secp256k1');
const secp256k1 = new EC('secp256k1');

function deriveEpsilon(accountId, walletId) {
    // Implementation for deriving epsilon. 
    // Replace this with the actual implementation.
    // This is just a placeholder as the specific method of derivation is not provided.
    return crypto.createHash('sha256').update(accountId + walletId).digest();
}

function deriveKey(publicKey, epsilon) {
    // Decode base58 public key
    const publicKeyBuffer = bs58.decode(publicKey);

    // Derive a key using HMAC and the provided epsilon
    const key = crypto.createHmac('sha256', epsilon).update(publicKeyBuffer).digest();

    // Convert key to a point on the curve
    const keyPoint = secp256k1.keyFromPublic("022e0ab4358780d72a4cac22ab75b257757663e5b204d96ccdce62f780536dac6a", 'hex').getPublic();

    // const EC = require('elliptic').ec
    // const pk = ec.keyFromPublic()

    return keyPoint;
}

// Example usage
const accountId = 'mydev.near'; // Replace with actual account ID
const walletId = "m/44'/397'/0'/0'/1"; // Replace with actual wallet ID
const publicKey = 'JCt63KiFDFm3c2ZVQaV45ySNAdCKbpd8ErPuUVyr2jiV'; // Replace with actual public key

const epsilon = deriveEpsilon(accountId, walletId);
const pk = deriveKey(publicKey, epsilon);

console.log(epsilon);

'''
'''--- client/package.json ---
{
  "name": "aps-wal",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bs58": "^5.0.0",
    "crypto": "^1.0.1",
    "elliptic": "^6.5.4",
    "secp256k1": "^5.0.0"
  }
}

'''
'''--- contract/Cargo.toml ---
[package]
name = "abs-wallet"
version = "1.2.0"
authors = ["HERE Wallet Inc <petr@herewallet.app>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
sha2 = "0.10.8"
serde = "1.0.36"
serde_json = "1.0"
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
bs58 = { version="0.4.0", features=["check"] }
sha3 = "0.10"
rlp = "0.4"
hex = "0.4"

'''
'''--- contract/src/eth.rs ---
use std::convert::TryInto;

use sha3::{Digest, Keccak256};
use rlp::{RlpStream, Encodable};

pub struct EthAddress([u8; 20]);

impl EthAddress {
    pub fn from(hex_address: &str) -> Result<Self, &'static str> {
        if hex_address.len() != 40 {
            return Err("Invalid length for Ethereum address");
        }

        let decoded = hex::decode(hex_address).map_err(|_| "Invalid Hex")?;
        let address = decoded.try_into().unwrap();
        Ok(EthAddress(address))
    }
}

impl Encodable for EthAddress {
    fn rlp_append(&self, s: &mut RlpStream) {
        s.encoder().encode_value(&self.0);
    }
}

pub struct EthereumTransaction {
    nonce: u64,
    gas_price: u64,
    gas_limit: u64,
    to: EthAddress,
    value: u64,
    data: Vec<u8>,
}

impl EthereumTransaction {
    pub fn new(nonce: u64, gas_price: u64, gas_limit: u64, to: EthAddress, value: u64, data: Vec<u8>) -> Self {
        EthereumTransaction {
            nonce,
            gas_price,
            gas_limit,
            to,
            value,
            data,
        }
    }
    

    pub fn rlp_encode(&self) -> Vec<u8> {
        let mut stream = RlpStream::new();
        stream.begin_list(6);
        stream.append(&self.nonce);
        stream.append(&self.gas_price);
        stream.append(&self.gas_limit);
        stream.append(&self.to);
        stream.append(&self.value);
        stream.append(&self.data);
        stream.out()
    }

    pub fn calculate_hash(&self) -> Vec<u8> {
        let encoded = self.rlp_encode();
        Keccak256::digest(&encoded).to_vec()
    }
}
'''
'''--- contract/src/lib.rs ---
mod eth;

use eth::EthAddress;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::assert_one_yocto;
use near_sdk::store::LookupSet;
use near_sdk::{env, near_bindgen, AccountId, Gas, PanicOnDefault, Promise};
use serde_json::json;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    mpc_account_id: AccountId,
    total_wallets: u64,
    wallet_owners: UnorderedMap<String, LookupSet<AccountId>>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(mpc_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            mpc_account_id: mpc_account_id,
            total_wallets: 0,
            wallet_owners: UnorderedMap::new(b"w"),
        }
    }

    #[payable]
    pub fn create_wallet(&mut self) {
        assert_one_yocto();
        let path = format!("m/44'/397'/0'/0'/{}", self.total_wallets);

        let mut key = b"o".to_vec();
        key.extend_from_slice(path.as_bytes());

        let mut owners = LookupSet::new(key);
        owners.insert(env::predecessor_account_id());
        self.wallet_owners.insert(&path, &owners);

        self.total_wallets += 1;
        env::log_str(format!("New wallet: {path}").as_str());
        env::log_str(
            format!(
                "Assess to wallet {path} has been granted to {}",
                env::predecessor_account_id()
            )
            .as_str(),
        );
    }

    #[payable]
    pub fn sign(&mut self, payload: [u8; 32], wallet_id: String) -> Promise {

        // self.assert_wallet_owner(&wallet_id);

        env::log_str(
            format!(
                "Transaction from {wallet_id} has been signed by {}",
                env::predecessor_account_id()
            )
            .as_str(),
        );

        Promise::new(self.mpc_account_id.clone()).function_call(
            "sign".to_string(),
            json!({
                "path": wallet_id,
                "payload": payload,
            })
            .to_string()
            .into_bytes(),
            0,
            Gas(50_000_000_000_000),
        )
    }

    fn assert_wallet_owner(&self, wallet_id: &String) {
        let wallet_owners = self.wallet_owners.get(wallet_id);
        assert!(wallet_owners.is_none(), "Wallet not found");
        assert_one_yocto();
        assert!(
            wallet_owners.unwrap()
                .contains(&env::predecessor_account_id()),
            "Predecessor is not owner of this wallet"
        );
    }

    #[payable]
    pub fn grant_assess(&mut self, wallet_id: String, account_id: AccountId) {
        self.assert_wallet_owner(&wallet_id);

        env::log_str(
            format!("Assess to wallet {wallet_id} has been granted to {account_id}").as_str(),
        );

        self.wallet_owners
            .get(&wallet_id)
            .unwrap()
            .insert(account_id);
    }

    #[payable]
    pub fn revoke_assess(&mut self, wallet_id: String, account_id: AccountId) {
        self.assert_wallet_owner(&wallet_id);
        env::log_str(
            format!("Assess to wallet {wallet_id} has been revoked from {account_id}").as_str(),
        );

        self.wallet_owners
            .get(&wallet_id)
            .unwrap()
            .remove(&account_id);
    }

    // ETH Api
    #[payable]
    pub fn eth_transfer_call(&mut self, wallet_id: String, recipient: String, amount: u64, nonce: u64, gas_price: u64, gas_limit: u64, data: Vec<u8>) -> Promise {
        // self.assert_wallet_owner(&wallet_id);

        let transaction = eth::EthereumTransaction::new(
            nonce,           
            gas_price,  
            gas_limit,
            EthAddress::from(recipient.as_str()).unwrap(),  
            amount,  
            vec![],      
        );
    
        let tx_hash = transaction.calculate_hash();
        env::log_str(format!("Transaction hash: {:?}", tx_hash).as_str());
    }

    pub fn get_wallets_in_range(&self, from: usize, to: usize) -> Vec<String> {
        let wallets: Vec<String> = self.wallet_owners.keys().collect();
        wallets.into_iter().skip(from).take(to - from).collect()
    }

}

'''