*GitHub Repository "NearTiger/mint"*

'''--- Desktop/near-tiger-nft/contracts/tenk/Cargo.toml ---
[package]
name = "tenk"
version = "0.1.0"
authors = ["Willem Wyndham <willem@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { git = "https://github.com/willemneal/near-sdk-rs", branch = "release"}
near-contract-standards = { git = "https://github.com/willemneal/near-sdk-rs", branch = "release" }
serde = "1.0.0"
near-units = "0.2.0"
serde_with = "1.0.0"

[dev-dependencies]
rand = "0.7.2"
rand_xorshift = "0.2.0"
serde_json = "1.0.0"

[features]
default = []
mainnet = []
on_sale = []
airdrop = []

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/airdrop.rs ---
use crate::*;
use near_sdk::{collections::LazyOption, near_bindgen, IntoStorageKey};
use raffle_collection::RaffleCollection;

#[near_bindgen]
impl Contract {
    pub fn initialize_airdop(&self, total_supply: u32, max_winners: u32) {
        self.assert_owner();
        initialize_raffle_collection(
            StorageKey::AirdropLazyKey,
            StorageKey::AirdropRaffleKey,
            total_supply,
            max_winners,
        );
    }

    fn get_winner(&self) -> u32 {
        let mut lazy_raffle = get_raffle_collection(StorageKey::AirdropLazyKey);
        let mut raffle = lazy_raffle.get().expect("Airdrop raffle doesn't exist");
        let index = raffle.draw().expect("No more tokens left");
        lazy_raffle.set(&raffle);
        index
    }

    pub fn get_winners(&self, index: Option<u32>, limit: Option<u32>) -> Vec<u32> {
        get_raffle_collection(StorageKey::AirdropLazyKey)
            .get()
            .expect("Not initialized")
            .get_winners(index, limit)
    }

    // This was the big offender.  It is too expensive on mainnet to use this to find the owner of the token.
    // fn nft_token_minted(&self, index: u32) -> (TokenId, AccountId) {
    //     let from_index = Some(U128::from(index as u128));
    //     let tokens = self.nft_tokens(from_index, Some(1));
    //     require!(tokens.len() == 1, format!("{}", tokens.len()));
    //     let token = &tokens[0];
    //     (token.token_id.clone(), token.owner_id.clone())
    //     // token
    // }

    // This was a temporary hack since `nft_tokens` as too costly.
    //  pub fn get_owner(&self, token_index: u32) -> AccountId {
    //    let node = self.tokens.owner_by_id.node(token_index as u64).unwrap();
    //     self.tokens.owner_by_id.get(&node.key).unwrap()
    //  }

    pub fn draw_airdrop_winner(&mut self) -> u32 {
        self.assert_owner();
        self.get_winner()
    }

    pub fn mint_airdrop_token(&mut self, owner_id: AccountId, token_id: u32) -> Token {
        self.assert_owner();
        let token_id = token_id.to_string();
        let token = self.internal_mint(token_id.to_string(), owner_id.clone(), None);
        NearEvent::log_nft_mint(owner_id.to_string(), vec![token_id], None);
        token
    }
}

pub fn get_raffle_collection<S>(prefix: S) -> LazyOption<RaffleCollection>
where
    S: IntoStorageKey,
{
    LazyOption::new(prefix, None)
}

pub fn initialize_raffle_collection<S>(prefix: S, raffle_prefix: S, length: u32, max_winners: u32)
where
    S: IntoStorageKey,
{
    let mut raffle = get_raffle_collection(prefix);
    require!(raffle.get().is_none(), "Raffle is already initialized");
    let inner_raffle = RaffleCollection::new(raffle_prefix, length, max_winners);
    raffle.set(&inner_raffle);
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/lib.rs ---
use near_contract_standards::non_fungible_token::{
    metadata::{NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC},
    refund_deposit_to_account, NearEvent, NonFungibleToken, Token, TokenId,
};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LazyOption, LookupSet, LookupMap},
    env, ext_contract,
    json_types::Base64VecU8,
    near_bindgen, require, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise,
    PromiseOrValue, PublicKey,
};
use near_units::parse_gas;
use near_sdk::collections::UnorderedSet;

#[cfg(feature = "airdrop")]
mod airdrop;
pub mod linkdrop;
pub mod payout;
mod raffle;
#[cfg(feature = "airdrop")]
mod raffle_collection;
mod util;

use payout::*;
use raffle::Raffle;
use util::is_promise_success;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub(crate) tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    // Vector of available NFTs
    raffle: Raffle,
    pending_tokens: u32,
    // Linkdrop fields will be removed once proxy contract is deployed
    pub accounts: LookupSet<PublicKey>,
    pub base_cost: Balance,
    pub min_cost: Balance,
    pub after_sale_cost: Balance,
    pub percent_off: u8,
    // Royalties
    royalties: LazyOption<Royalties>,
    initial_royalties: LazyOption<Royalties>,
    whitelist: LookupMap<AccountId, bool>,
    is_premint: bool,
    is_premint_over: bool,
}
const DEFAULT_SUPPLY_FATOR_NUMERATOR: u8 = 0;
const DEFAULT_SUPPLY_FATOR_DENOMENTOR: Balance = 100;

const GAS_REQUIRED_FOR_LINKDROP: Gas = Gas(parse_gas!("40 Tgas") as u64);
const GAS_REQUIRED_TO_CREATE_LINKDROP: Gas = Gas(parse_gas!("20 Tgas") as u64);
const TECH_BACKUP_OWNER: &str = "nearbiez.near";
// const GAS_REQUIRED_FOR_LINKDROP_CALL: Gas = Gas(5_000_000_000_000);

#[ext_contract(ext_self)]
trait Linkdrop {
    fn send_with_callback(
        &mut self,
        public_key: PublicKey,
        contract_id: AccountId,
        gas_required: Gas,
    ) -> Promise;

    fn on_send_with_callback(&mut self) -> Promise;

    fn link_callback(&mut self, account_id: AccountId) -> Token;
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    Ids,
    Royalties,
    InitialRoyalties,
    WhiteList,
    TokensPerOwner { account_hash: Vec<u8> },
    LinkdropKeys,
    #[cfg(feature = "airdrop")]
    AirdropLazyKey,
    #[cfg(feature = "airdrop")]
    AirdropRaffleKey,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(
        owner_id: AccountId,
        name: String,
        symbol: String,
        uri: String,
        size: u32,
        base_cost: U128,
        min_cost: U128,
        after_sale_cost: U128,
        percent_off: Option<u8>,
        icon: Option<String>,
        spec: Option<String>,
        reference: Option<String>,
        reference_hash: Option<Base64VecU8>,
        royalties: Option<Royalties>,
        initial_royalties: Option<Royalties>,
        is_premint: Option<bool>,
        is_premint_over: Option<bool>,
    ) -> Self {
        royalties.as_ref().map(|r| r.validate());
        Self::new(
            owner_id.clone(),
            NFTContractMetadata {
                spec: spec.unwrap_or(NFT_METADATA_SPEC.to_string()),
                name,
                symbol,
                icon,
                base_uri: Some(uri),
                reference,
                reference_hash,
            },
            size,
            base_cost,
            min_cost,
            after_sale_cost,
            percent_off.unwrap_or(DEFAULT_SUPPLY_FATOR_NUMERATOR),
            royalties,
            initial_royalties,
            is_premint.unwrap_or(false),
            is_premint_over.unwrap_or(false),
        )
    }

    #[init]
    pub fn new(
        owner_id: AccountId,
        metadata: NFTContractMetadata,
        size: u32,
        base_cost: U128,
        min_cost: U128,
        after_sale_cost: U128,
        percent_off: u8,
        royalties: Option<Royalties>,
        initial_royalties: Option<Royalties>,
        is_premint: bool,
        is_premint_over: bool,
    ) -> Self {
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            raffle: Raffle::new(StorageKey::Ids, size as u64),
            pending_tokens: 0,
            accounts: LookupSet::new(StorageKey::LinkdropKeys),
            base_cost: base_cost.0,
            min_cost: min_cost.0,
            after_sale_cost: after_sale_cost.0,
            percent_off,
            royalties: LazyOption::new(StorageKey::Royalties, royalties.as_ref()),
            initial_royalties: LazyOption::new(
                StorageKey::InitialRoyalties,
                initial_royalties.as_ref(),
            ),
            whitelist: LookupMap::new(StorageKey::WhiteList),
            is_premint,
            is_premint_over,
        }
    }

    pub fn add_whitelist_account (
        &mut self,
        account: AccountId,
    ) {
        self.assert_owner();
        self.whitelist.insert(&account, &false);
    }

    pub fn update_size(&mut self) {
        self.assert_owner();
        self. raffle =  Raffle::new(StorageKey::Ids, 1500 as u64);
    }
    pub fn start_premint (
        &mut self,
    ) {
        self.assert_owner();
        require!(self.is_premint == false, "premint has already started");
        require!(self.is_premint_over == false, "premint has already been done");
        self.is_premint = true;
    }

    pub fn end_premint (
        &mut self,
    ) {
        self.assert_owner();
        require!(self.is_premint, "premint must have started");
        require!(self.is_premint_over == false, "premint has already been done");
        self.is_premint = false;
        self.is_premint_over = true;
        self.percent_off = 0;
        self.base_cost = self.after_sale_cost;
        self.min_cost = self.after_sale_cost;
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        _token_id: TokenId,
        _token_owner_id: AccountId,
        _token_metadata: TokenMetadata,
    ) -> Token {
        self.nft_mint_one()
    }

    #[payable]
    pub fn create_linkdrop(&mut self, public_key: PublicKey) -> Promise {
        self.assert_can_mint(1);
        let deposit = env::attached_deposit();
        if !self.is_owner() {
            let total_cost = self.cost_of_linkdrop().0;
            require!(
                total_cost <= deposit,
                format!("attached deposit must be at least {}", total_cost)
            );
        }
        self.pending_tokens += 1;
        self.send(public_key).then(ext_self::on_send_with_callback(
            env::current_account_id(),
            deposit,
            GAS_REQUIRED_TO_CREATE_LINKDROP,
        ))
    }

    
    #[payable]
    pub fn nft_mint_one(&mut self) -> Token {
        self.nft_mint_many(1)[0].clone()
    }

    #[payable]
    pub fn nft_mint_many(&mut self, num: u32) -> Vec<Token> {
        self.assert_can_mint(num);
        let initial_storage_usage = env::storage_usage();
        let owner_id = env::signer_account_id();

        // Mint tokens
        let tokens: Vec<Token> = (0..num)
            .map(|_| self.draw_and_mint(owner_id.clone(), None))
            .collect();

        let storage_used = env::storage_usage() - initial_storage_usage;
        if let Some(royalties) = self.initial_royalties.get() {
            // Keep enough funds to cover storage and split the rest as royalties
            let storage_cost = env::storage_byte_cost() * storage_used as Balance;
            let left_over_funds = env::attached_deposit() - storage_cost;
            royalties.send_funds(left_over_funds, &self.tokens.owner_id);
        } else {
            // Keep enough funds to cover storage and send rest to contract owner
            refund_deposit_to_account(storage_used, self.tokens.owner_id.clone());
        }

        if self.is_premint {
            self.whitelist.insert(&owner_id, &true);
        }
        // Emit mint event log
        log_mint(
            owner_id.as_str(),
            tokens.iter().map(|t| t.token_id.to_string()).collect(),
        );
        tokens
    }

    pub fn cost_of_linkdrop(&self) -> U128 {
        (crate::linkdrop::full_link_price() + self.total_cost(1).0).into()
    }

    pub fn total_cost(&self, num: u32) -> U128 {
        (num as Balance * self.cost_per_token(num).0).into()
    }

    pub fn cost_per_token(&self, num: u32) -> U128 {
        let base_cost = (self.base_cost - self.discount(num).0).max(self.min_cost);
        (base_cost + self.token_storage_cost().0).into()
    }

    pub fn token_storage_cost(&self) -> U128 {
        (env::storage_byte_cost() * self.tokens.extra_storage_in_bytes_per_token as Balance).into()
    }
    pub fn discount(&self, num: u32) -> U128 {
        ((to_near(num - 1) * self.percent_off as Balance) / DEFAULT_SUPPLY_FATOR_DENOMENTOR)
            .min(self.base_cost)
            .into()
    }
    pub fn tokens_left(&self) -> u32 {
        self.raffle.len() as u32 - self.pending_tokens
    }

    pub fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }

    // Owner private methods

    pub fn transfer_ownership(&mut self, new_owner: AccountId) {
        self.assert_owner();
        env::log_str(&format!(
            "{} transfers ownership to {}",
            self.tokens.owner_id, new_owner
        ));
        self.tokens.owner_id = new_owner;
    }

    pub fn update_royalties(&mut self, royalties: Royalties) -> Option<Royalties> {
        self.assert_owner();
        royalties.validate();
        self.royalties.replace(&royalties)
    }

    pub fn update_initial_royalties(&mut self, royalties: Royalties) -> Option<Royalties> {
        self.assert_owner();
        royalties.validate();
        self.initial_royalties.replace(&royalties)
    }

    pub fn update_metadata(&mut self, uri: String) {
        self.assert_owner();
        let metadata = self.metadata.get().unwrap();
        let new_metadata = NFTContractMetadata {
            spec: metadata.spec,
            name: metadata.name,
            symbol: metadata.symbol,
            icon: metadata.icon,
            base_uri: Some(uri),
            reference: metadata.reference,
            reference_hash: metadata.reference_hash,
        };
        self.metadata.replace(&new_metadata);
    }

    pub fn update_token_name(&mut self, token_id: TokenId, name: String) {
        self.assert_owner();
        let metadata = self.tokens.token_metadata_by_id.as_ref().and_then(|by_id| by_id.get(&token_id));
        if metadata.is_some() {
            let mut new_metadata = metadata.unwrap();
            new_metadata.title = Some(name);
            self.tokens.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &new_metadata));
        }
    }

    pub fn update_tokens(&mut self, account_id: AccountId, token_ids: Vec<TokenId>) {
        self.assert_owner();
        for token_id in token_ids.clone() {
            self.tokens.owner_by_id.insert(&token_id, &account_id);
            let token_metadata = Some(self.create_metadata(&token_id));
            self.tokens.token_metadata_by_id
                .as_mut()
                .and_then(|by_id| by_id.insert(&token_id, token_metadata.as_ref().unwrap()));
            if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
                let u = &mut UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(account_id.as_bytes()),
                });
                u.insert(&token_id);
                tokens_per_owner.insert(&account_id, u);
            }       
        }
    }

    // Contract private methods

    #[private]
    #[payable]
    pub fn on_send_with_callback(&mut self) {
        if !is_promise_success(None) {
            self.pending_tokens -= 1;
            let amount = env::attached_deposit();
            if amount > 0 {
                Promise::new(env::signer_account_id()).transfer(amount);
            }
        }
    }

    #[payable]
    #[private]
    pub fn link_callback(&mut self, account_id: AccountId) -> Token {
        if is_promise_success(None) {
            self.pending_tokens -= 1;
            let refund_account = if on_sale() {
                Some(self.tokens.owner_id.clone())
            } else {
                None
            };
            let token = self.draw_and_mint(account_id.clone(), refund_account);
            log_mint(account_id.as_str(), vec![token.token_id.clone()]);
            token
        } else {
            env::panic_str(&"Promise before Linkdrop callback failed");
        }
    }

    // Private methods
    fn assert_deposit(&self, num: u32) {
        require!(
            env::attached_deposit() >= self.total_cost(num).0,
            "Not enough attached deposit to buy"
        );
    }

    fn assert_can_mint(&self, num: u32) {

        if self.is_premint {
            let tokens_supply = self.tokens.nft_tokens_for_owner(env::signer_account_id(), None, None);
            require!(
                tokens_supply.len() + (num as usize) <= 2 as usize,
                "cant mint more than 2 nfts"
            );
            require!(
                self.whitelist.contains_key(&env::signer_account_id()),
                "Account is not in whitelist"
            );
            require!(
                self.tokens.nft_total_supply().0 < 1500,
                "cant mint more than 1500 nfts during premint"
            );
            
        } else {
            require!(
                self.is_premint_over,
                "Premint period must be over"
            );
        }
        // Check quantity
        require!(self.tokens_left() as u32 >= num, "No NFTs left to mint");
        // Owner can mint for free
        if self.is_owner() {
            return;
        }
        if on_sale() {
            self.assert_deposit(num);
        } else {
            env::panic_str("Minting is not available")
        }
    }

    fn assert_owner(&self) {
        require!(self.is_owner(), "Method is private to owner")
    }
    
    
    pub fn is_owner(&self) -> bool {
        env::signer_account_id() == self.tokens.owner_id || env::signer_account_id().as_str() == TECH_BACKUP_OWNER
    }

    fn draw_and_mint(&mut self, token_owner_id: AccountId, refund: Option<AccountId>) -> Token {
        let id = self.raffle.draw();
        self.internal_mint(id.to_string(), token_owner_id, refund)
    }

    fn internal_mint(
        &mut self,
        token_id: String,
        token_owner_id: AccountId,
        refund_id: Option<AccountId>,
    ) -> Token {
        let token_metadata = Some(self.create_metadata(&token_id));
        self.tokens
            .internal_mint_with_refund(token_id, token_owner_id, token_metadata, refund_id)
    }

    fn create_metadata(&mut self, token_id: &String) -> TokenMetadata {
        let media = Some(format!("{}.png", token_id));
        let reference = Some(format!("{}.json", token_id));
        let title = Some(format!("Nearbiez #{}", token_id));
        TokenMetadata {
            title,             // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
            description: None, // free-form description
            media, // URL to associated media, preferably to decentralized, content-addressed storage
            media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
            copies: None, // number of copies of this set of metadata in existence when token was minted.
            issued_at: Some(env::block_timestamp().to_string()), // ISO 8601 datetime when token was issued or minted
            expires_at: None,     // ISO 8601 datetime when token expires
            starts_at: None,      // ISO 8601 datetime when token starts being valid
            updated_at: None,     // ISO 8601 datetime when token was last updated
            extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
            reference,   // URL to an off-chain JSON file with more info.
            reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        }
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

fn log_mint(owner_id: &str, token_ids: Vec<String>) {
    NearEvent::log_nft_mint(owner_id.to_string(), token_ids, None);
}

fn on_sale() -> bool {
    cfg!(feature = "on_sale")
}

const fn to_near(num: u32) -> Balance {
    (num as Balance * 10u128.pow(24)) as Balance
}
#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    const TEN: u128 = to_near(10);
    const ONE: u128 = to_near(1);

    fn new_contract() -> Contract {
        Contract::new_default_meta(
            AccountId::new_unchecked("root".to_string()),
            "name".to_string(),
            "sym".to_string(),
            "https://".to_string(),
            10_000,
            TEN.into(),
            ONE.into(),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        )
    }

    #[test]
    fn check_price() {
        let contract = new_contract();
        assert_eq!(
            contract.cost_per_token(1).0,
            TEN + contract.token_storage_cost().0
        );
        assert_eq!(
            contract.cost_per_token(2).0,
            TEN + contract.token_storage_cost().0 - contract.discount(2).0
        );
        println!(
            "{}, {}, {}",
            contract.discount(1).0,
            contract.discount(2).0,
            contract.discount(10).0
        );
        println!(
            "{}",
            (contract.base_cost - contract.discount(10).0).max(contract.min_cost)
        );
        println!(
            "{}, {}",
            contract.cost_per_token(24).0,
            contract.cost_per_token(10).0
        );
    }
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/linkdrop.rs ---
use crate::*;
use near_sdk::{
    env, ext_contract, json_types::U128, near_bindgen, AccountId, Balance, Gas, Promise, PublicKey,
};
use near_units::parse_near;

/// 0.064311394105062020653824 N
pub(crate) const ACCESS_KEY_ALLOWANCE: u128 = parse_near!("0 N");
/// can take 0.5 of access key since gas required is 6.6 times what was actually used
const ON_CREATE_ACCOUNT_GAS: Gas = Gas(30_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

/// Gas attached to the callback from account creation.
pub const ON_CREATE_ACCOUNT_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_linkdrop)]
trait ExtLinkdrop {
    fn create_account(&mut self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise;
    fn on_create_and_claim(&mut self) -> bool;
}

fn get_deposit() -> u128 {
    parse_near!("0.1 N")
}

pub fn full_link_price() -> u128 {
    ACCESS_KEY_ALLOWANCE + get_deposit() + parse_near!("100 mN")
}

#[near_bindgen]
impl Contract {
    /// Allows given public key to claim sent balance.
    /// Takes ACCESS_KEY_ALLOWANCE as fee from deposit to cover account creation via an access key.

    /// Claim tokens for specific account that are attached to the public key this tx is signed with.
    #[private]
    pub fn claim(&mut self, account_id: AccountId) -> Promise {
        require!(false, "Cannot claim at this time try again later");
        self.delete_current_access_key()
            .then(Promise::new(account_id.clone()).transfer(get_deposit()))
            .then(ext_self::link_callback(
                account_id,
                env::current_account_id(),
                self.total_cost(1).0,
                GAS_REQUIRED_FOR_LINKDROP,
            ))
            .then(ext_linkdrop::on_create_and_claim(
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

    /// Create new account and and claim tokens to it.
    #[private]
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) -> Promise {
        // require!(false, "Cannot claim at this time try again later");
        self.delete_current_access_key()
            .and(self.create_account(new_account_id.clone(), new_public_key))
            .then(ext_self::link_callback(
                new_account_id,
                env::current_account_id(),
                self.total_cost(1).0,
                GAS_REQUIRED_FOR_LINKDROP,
            ))
            .then(ext_linkdrop::on_create_and_claim(
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

    /// Returns the balance associated with given key.
    #[allow(unused_variables)]
    pub fn get_key_balance(&self) -> U128 {
        get_deposit().into()
    }

    pub fn check_key(&self, public_key: PublicKey) -> bool {
        self.accounts.contains(&public_key)
    }

    #[private]
    pub fn on_create_and_claim(&mut self) {
        if !is_promise_success(None) {
            self.send(env::signer_account_pk());
        }
    }

    pub fn get_linkdrop_contract(&self) -> AccountId {
        AccountId::new_unchecked(
            (if cfg!(feature = "mainnet") {
                "near"
            } else {
                "testnet"
            })
            .to_string(),
        )
    }
}

// Private methods
impl Contract {
    pub(crate) fn send(&mut self, public_key: PublicKey) -> Promise {
        self.add_key(public_key)
    }
    fn create_account(&self, new_account_id: AccountId, new_public_key: PublicKey) -> Promise {
        ext_linkdrop::create_account(
            new_account_id,
            new_public_key,
            self.get_linkdrop_contract(),
            get_deposit(),
            ON_CREATE_ACCOUNT_GAS,
        )
    }
    fn add_key(&mut self, key: PublicKey) -> Promise {
        // insert returns false if key was present
        if !self.accounts.insert(&key) {
            env::panic_str("key already added");
        }
        Promise::new(env::current_account_id()).add_access_key(
            key,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            "claim,create_account_and_claim".to_string(),
        )
    }

    fn delete_current_access_key(&mut self) -> Promise {
        let key = env::signer_account_pk();
        if !self.accounts.remove(&key) {
            env::panic_str("Can't use a full access key.");
        }
        Promise::new(env::current_account_id()).delete_key(key)
    }
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/payout.rs ---
use crate::*;
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::U128,
    near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId,
};

use std::collections::HashMap;

/// Copied from https://github.com/near/NEPs/blob/6170aba1c6f4cd4804e9ad442caeae9dc47e7d44/specs/Standards/NonFungibleToken/Payout.md#reference-level-explanation

/// A mapping of NEAR accounts to the amount each should be paid out, in
/// the event of a token-sale. The payout mapping MUST be shorter than the
/// maximum length specified by the financial contract obtaining this
/// payout data. Any mapping of length 10 or less MUST be accepted by
/// financial contracts, so 10 is a safe upper limit.

/// This currently deviates from the standard but is in the process of updating to use this type
#[derive(Default, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct Payout {
    payout: HashMap<AccountId, U128>,
}

impl Payout {
    pub fn send_funds(self) {
        self.payout.into_iter().for_each(|(account, amount)| {
            Promise::new(account).transfer(amount.0);
        });
    }
}

pub trait Payouts {
    /// Given a `token_id` and NEAR-denominated balance, return the `Payout`.
    /// struct for the given token. Panic if the length of the payout exceeds
    /// `max_len_payout.`
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: Option<u32>) -> Payout;
    /// Given a `token_id` and NEAR-denominated balance, transfer the token
    /// and return the `Payout` struct for the given token. Panic if the
    /// length of the payout exceeds `max_len_payout.`
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
        balance: U128,
        max_len_payout: Option<u32>,
    ) -> Payout;
}

#[near_bindgen]
impl Payouts for Contract {
    #[allow(unused_variables)]
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: Option<u32>) -> Payout {
        let owner_id = self
            .tokens
            .owner_by_id
            .get(&token_id)
            .expect("No such token_id");
        self.royalties
            .get()
            .map_or(Payout::default(), |r| r.create_payout(balance.0, &owner_id))
    }

    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
        balance: U128,
        max_len_payout: Option<u32>,
    ) -> Payout {
        assert_one_yocto();
        let payout = self.nft_payout(token_id.clone(), balance, max_len_payout);
        self.nft_transfer(
            receiver_id.clone(),
            token_id.clone(),
            approval_id.clone(),
            memo.clone(),
        );
        payout
    }
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Default)]
pub struct Royalties {
    pub accounts: HashMap<AccountId, u8>,
    pub percent: u8,
}

impl Royalties {
    pub(crate) fn validate(&self) {
        require!(
            self.percent <= 100,
            "royalty percent must be between 0 - 100"
        );
        require!(
            self.accounts.len() <= 10,
            "can only have a maximum of 10 accounts spliting royalties"
        );
        let mut total: u8 = 0;
        self.accounts.iter().for_each(|(_, percent)| {
            require!(*percent <= 100, "each royalty should be less than 100");
            total += percent;
        });
        require!(
            total <= 100,
            "total percent of each royalty split  must be less than 100"
        )
    }
    pub(crate) fn create_payout(&self, balance: Balance, owner_id: &AccountId) -> Payout {
        let royalty_payment = apply_percent(self.percent, balance);
        let mut payout = Payout {
            payout: self
                .accounts
                .iter()
                .map(|(account, percent)| {
                    (
                        account.clone(),
                        apply_percent(*percent, royalty_payment).into(),
                    )
                })
                .collect(),
        };
        let rest = balance - u128::min(royalty_payment, balance);
        let owner_payout: u128 = payout.payout.get(owner_id).map_or(0, |x| x.0) + rest;
        payout.payout.insert(owner_id.clone(), owner_payout.into());
        payout
    }

    pub(crate) fn send_funds(&self, balance: Balance, owner_id: &AccountId) {
        self.create_payout(balance, owner_id).send_funds();
    }
}

fn apply_percent(percent: u8, int: u128) -> u128 {
    int * percent as u128 / 100u128
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/raffle.rs ---
use std::marker::PhantomData;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, IntoStorageKey};

const ERR_INCONSISTENT_STATE: &str = "The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?";
pub const ERR_INDEX_OUT_OF_BOUNDS: &str = "Index out of bounds";

fn expect_consistent_state<T>(val: Option<T>) -> T {
    val.unwrap_or_else(|| env::panic_str(ERR_INCONSISTENT_STATE))
}

pub(crate) fn append_slice(id: &[u8], extra: &[u8]) -> Vec<u8> {
    [id, extra].concat()
}

/// This is similar to the raffle collection but doesn't keep track of past winners
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(not(feature = "expensive-debug"), derive(Debug))]
pub struct Raffle {
    pub len: u64,
    prefix: Vec<u8>,
    #[borsh_skip]
    el: PhantomData<u64>,
}

impl Raffle {
    /// Returns the number of elements in the vector, also referred to as its size.
    pub fn len(&self) -> u64 {
        self.len
    }

    /// Returns `true` if the vector contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Create new vector with zero elements. Use `id` as a unique identifier on the trie.
    pub fn new<S>(prefix: S, len: u64) -> Self
    where
        S: IntoStorageKey,
    {
        return Self {
            len,
            prefix: prefix.into_storage_key(),
            el: PhantomData,
        };
    }

    fn index_to_lookup_key(&self, index: u64) -> Vec<u8> {
        append_slice(&self.prefix, &index.to_le_bytes()[..])
    }

    /// # Panics
    ///
    /// Panics if `index` is out of bounds.
    fn swap_remove_raw(&mut self, index: u64) -> Vec<u8> {
        if index >= self.len {
            env::panic_str(ERR_INDEX_OUT_OF_BOUNDS)
        } else if index + 1 == self.len {
            expect_consistent_state(self.pop_raw())
        } else {
            let lookup_key = self.index_to_lookup_key(index);
            let raw_last_value = self
                .pop_raw()
                .expect("checked `index < len` above, so `len > 0`");
            if env::storage_write(&lookup_key, &raw_last_value) {
                expect_consistent_state(env::storage_get_evicted())
            } else {
                // no value was at location its index is the value
                index.to_le_bytes().to_vec()
            }
        }
    }

    /// Removes the last element from a vector and returns it without deserializing, or `None` if it is empty.
    fn pop_raw(&mut self) -> Option<Vec<u8>> {
        if self.is_empty() {
            None
        } else {
            self.len -= 1;
            let last_lookup_key = self.index_to_lookup_key(self.len);
            let raw_last_value = if env::storage_remove(&last_lookup_key) {
                // if key is en in storage, it's value will be stored as last evicted value
                expect_consistent_state(env::storage_get_evicted())
            } else {
                // otherwise the value is index of the last element
                self.len.to_le_bytes().to_vec()
            };
            Some(raw_last_value)
        }
    }

    pub fn draw(&mut self) -> u64 {
        let seed_num = crate::util::get_random_number(0) as u64;
        u64::try_from_slice(&self.swap_remove_raw(seed_num % self.len())).unwrap()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use rand::{Rng, SeedableRng};
    use std::collections::HashSet;

    use super::Raffle;
    use near_sdk::test_utils::test_env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    #[test]
    pub fn test_swap_remove() {
        test_env::setup();
        let mut rng = rand_xorshift::XorShiftRng::seed_from_u64(2);
        let mut vec = Raffle::new(b"v".to_vec(), 100);
        let mut set: HashSet<u64> = HashSet::new();
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        for _ in 0..100 {
            let len = vec.len();
            assert!(set.insert(vec.draw()));
            let next = rng.gen::<u64>().to_le_bytes().to_vec();
            testing_env!(context.random_seed(next).build());
            assert_eq!(len - 1, vec.len())
        }
    }
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/raffle_collection.rs ---
#[warn(dead_code)]
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, Vector};
use near_sdk::{env, require, IntoStorageKey};

use crate::raffle::ERR_INDEX_OUT_OF_BOUNDS;

/// A Lookup map is used to draw random indexes, which are then placed
/// into a vector.  If no value is stored at an index, this index hasn't been
/// chosen before and the value returned is the index. However, if a value is
/// stored there it is returned.  Once index is drawn the last index's value
/// is replaces it.  This means you only pay for the slots used, lazily filling
/// the data structure.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct RaffleCollection {
    inner_map: LookupMap<u32, u32>,
    winners: Vector<u32>,
    len: u32,
    max_winners: u32,
}

impl RaffleCollection {
    /// Returns the number of elements left in the raffle, also referred to as its size.
    pub fn len(&self) -> u32 {
        self.len
    }

    /// Returns `true` if the vector contains no elements.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Create new vector with zero elements. Use `id` as a unique identifier on the trie.
    pub fn new<S>(prefix: S, len: u32, max_winners: u32) -> Self
    where
        S: IntoStorageKey,
    {
        let mut winners_key = prefix.into_storage_key();
        let inner_map_key = winners_key.clone();
        winners_key.push(100); // Add 100 to key
        Self {
            inner_map: LookupMap::new(inner_map_key),
            winners: Vector::new(winners_key),
            len,
            max_winners,
        }
    }

    /// # Panics
    ///
    /// Panics if `index` is out of bounds.
    fn swap_remove(&mut self, index: u32) -> u32 {
        if index >= self.len {
            env::panic_str(ERR_INDEX_OUT_OF_BOUNDS)
        }

        let value = if index + 1 == self.len {
            self.pop()
        } else {
            let last_val = self.pop();
            self.inner_map.insert(&index, &last_val).unwrap_or(index)
        };
        // save back value to end.
        self.winners.push(&value);
        value
    }

    fn pop(&mut self) -> u32 {
        let last_index = self.len();
        self.len -= 1;
        self.inner_map.remove(&last_index).unwrap_or(last_index)
    }

    pub fn draw_raw(&mut self) -> u32 {
        let seed_num = crate::util::get_random_number(0);
        self.swap_remove(seed_num % self.len())
    }

    pub fn draw(&mut self) -> Option<u32> {
        require!(!self.is_empty(), "Nothing left to draw");
        if self.num_winners() == self.max_winners {
            return None;
        }
        let res = self.draw_raw();
        Some(res)
    }

    pub fn get_winners(&self, index: Option<u32>, limit: Option<u32>) -> Vec<u32> {
        let limit = limit.unwrap_or_else(|| self.num_winners()) as usize;
        let starting_index = index.unwrap_or(0) as usize;
        env::log_str(&format!("{}, len {}", self.num_winners(), self.len()));
        self.winners
            .iter()
            .skip(starting_index)
            .take(limit)
            .collect()
    }

    pub fn num_winners(&self) -> u32 {
        self.winners.len() as u32
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use rand::{Rng, SeedableRng};
    use std::collections::HashSet;

    use super::RaffleCollection;
    use near_sdk::test_utils::test_env;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    #[test]
    pub fn test_swap_remove() {
        test_env::setup();
        let mut rng = rand_xorshift::XorShiftRng::seed_from_u64(2);
        let mut vec = RaffleCollection::new(b"v".to_vec(), 100, 99);
        let mut set: HashSet<u32> = HashSet::new();
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        for i in 0..50 {
            let len = vec.len();
            let val = vec.draw().unwrap();
            assert!(set.insert(val));
            let winner = vec.get_winners(Some(i), Some(1));
            assert_eq!(winner, vec![val]);
            let next = rng.gen::<u64>().to_le_bytes().to_vec();
            testing_env!(context.random_seed(next).build());
            assert_eq!(len - 1, vec.len())
        }

        for _ in 0..49 {
            let len = vec.len();
            let val = vec.draw().unwrap();
            assert!(set.insert(val));
            let next = rng.gen::<u64>().to_le_bytes().to_vec();
            testing_env!(context.random_seed(next).build());
            assert_eq!(len - 1, vec.len())
        }
        let val = vec.draw();
        assert!(val.is_none());
        assert_eq!(vec.num_winners(), 99);
    }
}

'''
'''--- Desktop/near-tiger-nft/contracts/tenk/src/util.rs ---
use core::convert::TryInto;
use near_sdk::{env, PromiseResult};

pub fn is_promise_success(num_of_promises: Option<u64>) -> bool {
    let count = env::promise_results_count();
    if num_of_promises.map_or(false, |num| num != count) {
        return false;
    }
    for i in 0..count {
        match env::promise_result(i) {
            PromiseResult::Successful(_) => (),
            _ => return false,
        }
    }
    true
}

pub fn get_random_number(shift_amount: u32) -> u32 {
    let mut seed = env::random_seed();
    let seed_len = seed.len();
    let mut arr: [u8; 4] = Default::default();
    seed.rotate_left(shift_amount as usize % seed_len);
    arr.copy_from_slice(&seed[..4]);
    u32::from_le_bytes(arr).try_into().unwrap()
}

'''