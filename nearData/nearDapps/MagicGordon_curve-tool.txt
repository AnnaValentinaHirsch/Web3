*GitHub Repository "MagicGordon/curve-tool"*

'''--- Cargo.toml ---
[package]
name = "curve-tool"
version = "0.1.0"
authors = ["Gordon"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
clap     = { version = "2.33", features = [ "yaml" ] }
near-sdk = "3.1.0"
uint     = { version = "0.9.0", default-features = false }
'''
'''--- README.md ---
# curve-tool

计算invariant D
```
$ curve-tool calc_d -a 240 -c 23739540956798478700217,23693993795556946583088,12799207746085091106157

calc_d : 60231588734883860151122
```
计算Xtoken新值之下的Ytoken新值(保证 invariant D 不变)
```
$ curve-tool  calc_y -a 240 -x 100000000000000000000 -c 23739540956798478700217,23693993795556946583088,12799207746085091106157 -i 0 -o 1 

compute_y : 48534043600605104365063
```
计算添加流动性
```
$ curve-tool calc_add_liquidity -a 240 -d 100000000000000000000,0,0 -o 23739540956798478700217,23693993795556946583088,12799207746085091106157 -p 60229882460024116126568 -t 5 -e 2000 

fee 0 : 6059017140754929
fee 1 : 3933421610185250
fee 2 : 2124786592589641
minted : 99975046215242192434
fee_part : 12116477271572430
```
计算按份额移除流动性
```
$ curve-tool calc_remove_liquidity -s 100000000000000000000 -c 23739540956798478700217,23693993795556946583088,12799207746085091106157 -o 60229882460024119712683

calc_remove_liquidity : [39414888402870331522, 39339266204417988939, 21250593929981854266]
```
计算按token移除流动性
```
$ curve-tool calc_remove_liquidity_by_tokens -a 240 -r 100000000000000000000,0,0 -o 23739540956798478700217,23693993795556946583088,12799207746085091106157 -p 60229882460024116126568 -t 5 -e 2000 

fee 0 : 6059011948075237
fee 1 : 3933426792902162
fee 2 : 2124789392230386
burned : 99999410922274146210
fee_part : 12116485642804691
```
计算swap
```
curve-tool calc_swap -a 240 -x 0 -c 100000000000000000000 -y 1 -o 23739540956798478700217,23693993795556946583088,12799207746085091106157 -t 5 -e 2000   

swap_out : 99949729878143970601
fee_part : 49999864871507739
```
'''
'''--- src/admin_fee.rs ---
use near_sdk::{env, AccountId};

/// Maintain information about fees.
pub struct AdminFees {
    /// Basis points of the fee for exchange.
    pub exchange_fee: u32,
    /// Basis points of the fee for referrer.
    pub referral_fee: u32,
    pub exchange_id: AccountId,
    pub referral_id: Option<AccountId>,
}

impl AdminFees {
    pub fn new(exchange_fee: u32) -> Self {
        AdminFees {
            exchange_fee,
            exchange_id: env::current_account_id(),
            referral_fee: 0,
            referral_id: None,
        }
    }

    pub fn zero() -> Self {
        Self::new(0)
    }
}

'''
'''--- src/cli.yml ---
name: curve-tool
version: "0.1.0"
author: Gordon
about: Used to verify the curve algorithm

settings:
    - ColoredHelp
    - SubcommandRequired

subcommands:
    - calc_d:
        about: 计算invariant D
        args:
            - amp:
                short: a
                help: 即A值,可从get_pool接口获取
                takes_value: true
                required: true
            - c_amounts:
                short: c
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
    - calc_y:
        about: 计算Xtoken新值之下的Ytoken新值(保证 invariant D 不变)
        args:
            - amp:
                short: a
                help: 即A值,可从get_pool接口获取
                takes_value: true
                required: true
            - x_c_amount:
                short: x
                help: Xtoken的新的可比精度余额
                takes_value: true
                required: true
            - current_c_amounts:
                short: c
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
            - index_x:
                short: i
                help: Xtoken index
                takes_value: true
                required: true
            - index_y:
                short: o
                help: Ytoken index
                takes_value: true
                required: true
    - calc_add_liquidity:
        about: 计算添加流动性
        args:
            - amp:
                short: a
                help: 即A值,可从get_pool接口获取
                takes_value: true
                required: true
            - deposit_c_amounts:
                short: d
                help: 冲入的各个token的可比精度余额
                takes_value: true
                required: true
            - old_c_amounts:
                short: o
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
            - pool_token_supply:
                short: p
                help: 当前总流动性
                takes_value: true
                required: true
            - total_fee:
                short: t
                help: 费率
                takes_value: true
                required: true
            - exchange_fee:
                short: e
                help: 费率
                takes_value: true
                required: true
    - calc_remove_liquidity:
        about: 计算按份额移除流动性
        args:
            - shares:
                short: s
                help: 待移除的流动性
                takes_value: true
                required: true
            - c_amounts:
                short: c
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
            - pool_token_supply:
                short: o
                help: 当前总流动性
                takes_value: true
                required: true
    - calc_remove_liquidity_by_tokens:
        about: 计算按token移除流动性
        args:
            - amp:
                short: a
                help: 即A值,可从get_pool接口获取
                takes_value: true
                required: true
            - removed_c_amounts:
                short: r
                help: 待移除的各个token的可比精度余额
                takes_value: true
                required: true
            - old_c_amounts:
                short: o
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
            - pool_token_supply:
                short: p
                help: 当前总流动性
                takes_value: true
                required: true
            - total_fee:
                short: t
                help: 费率
                takes_value: true
                required: true
            - exchange_fee:
                short: e
                help: 费率
                takes_value: true
                required: true
    - calc_swap:
        about: 计算swap
        args:
            - amp:
                short: a
                help: 即A值,可从get_pool接口获取
                takes_value: true
                required: true
            - in_token_idx:
                short: x
                help: 冲入的token的idx
                takes_value: true
                required: true
            - in_c_amount:
                short: c
                help: 冲入的token的可比精度余额
                takes_value: true
                required: true
            - out_token_idx:
                short: y
                help: 换出的token的idx
                takes_value: true
                required: true
            - old_c_amounts:
                short: o
                help: 池中各个token的可比精度余额
                takes_value: true
                required: true
            - total_fee:
                short: t
                help: 费率
                takes_value: true
                required: true
            - exchange_fee:
                short: e
                help: 费率
                takes_value: true
                required: true
'''
'''--- src/main.rs ---
use near_sdk::test_utils::{accounts, VMContextBuilder};
use near_sdk::{testing_env, MockedBlockchain};
use clap::{load_yaml, App};

mod math;
use math::*;
mod admin_fee;
use admin_fee::AdminFees;

fn main(){
    let yaml = load_yaml!("cli.yml");
    let matches = App::from_yaml(yaml).get_matches();

    if let Some(matches) = matches.subcommand_matches("calc_d") {
        let amp_string: String = matches.value_of("amp").unwrap().into();
        let amp = amp_string.parse::<u128>().unwrap();
        let c_amounts_str = matches.value_of("c_amounts").unwrap();
        let c_amounts_str_vec = c_amounts_str.split(",").collect::<Vec<&str>>();
        let c_amounts = c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let ss = StableSwap::new( amp, amp, 0, 0, 0);
        let d = ss.compute_d(&c_amounts).unwrap();
        println!("calc_d : {}", d);
    }else if let Some(matches) = matches.subcommand_matches("calc_y") {
        let amp_string: String = matches.value_of("amp").unwrap().into();
        let amp = amp_string.parse::<u128>().unwrap();
        let x_c_amount_string: String = matches.value_of("x_c_amount").unwrap().into();
        let x_c_amount = x_c_amount_string.parse::<u128>().unwrap();
        let current_c_amounts_str = matches.value_of("current_c_amounts").unwrap();
        let current_c_amounts_str_vec = current_c_amounts_str.split(",").collect::<Vec<&str>>();
        let current_c_amounts = current_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let index_x_string: String = matches.value_of("index_x").unwrap().into();
        let index_x = index_x_string.parse::<u128>().unwrap() as usize;
        let index_y_string: String = matches.value_of("index_y").unwrap().into();
        let index_y = index_y_string.parse::<u128>().unwrap() as usize;

        let ss = StableSwap::new( amp, amp, 0, 0, 0);
        let y = ss.compute_y(x_c_amount, &current_c_amounts, index_x, index_y).unwrap();
        println!("compute_y : {}", y);
    }else if let Some(matches) = matches.subcommand_matches("calc_add_liquidity") {
        let amp_string: String = matches.value_of("amp").unwrap().into();
        let amp = amp_string.parse::<u128>().unwrap();
        let deposit_c_amounts_str = matches.value_of("deposit_c_amounts").unwrap();
        let deposit_c_amounts_str_vec = deposit_c_amounts_str.split(",").collect::<Vec<&str>>();
        let deposit_c_amounts = deposit_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let old_c_amounts_str = matches.value_of("old_c_amounts").unwrap();
        let old_c_amounts_str_vec = old_c_amounts_str.split(",").collect::<Vec<&str>>();
        let old_c_amounts = old_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let pool_token_supply_string: String = matches.value_of("pool_token_supply").unwrap().into();
        let pool_token_supply = pool_token_supply_string.parse::<u128>().unwrap();
        let total_fee_string: String = matches.value_of("total_fee").unwrap().into();
        let total_fee = total_fee_string.parse::<u32>().unwrap();
        let exchange_fee_string: String = matches.value_of("exchange_fee").unwrap().into();
        let exchange_fee = exchange_fee_string.parse::<u32>().unwrap();

        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let ss = StableSwap::new( amp, amp, 0, 0, 0);
        let (minted, fee_part) = ss.compute_lp_amount_for_deposit(&deposit_c_amounts, &old_c_amounts, pool_token_supply, &Fees::new(total_fee, &AdminFees::new(exchange_fee))).unwrap();
        println!("minted : {}", minted);
        println!("fee_part : {}", fee_part);
    }else if let Some(matches) = matches.subcommand_matches("calc_remove_liquidity") {
        let shares_string: String = matches.value_of("shares").unwrap().into();
        let shares = shares_string.parse::<u128>().unwrap();
        let c_amounts_str = matches.value_of("c_amounts").unwrap();
        let c_amounts_str_vec = c_amounts_str.split(",").collect::<Vec<&str>>();
        let c_amounts = c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let pool_token_supply_string: String = matches.value_of("pool_token_supply").unwrap().into();
        let pool_token_supply = pool_token_supply_string.parse::<u128>().unwrap();

        let mut result = vec![0u128; c_amounts.len()];
        for i in 0..c_amounts.len() {
            result[i] = U256::from(c_amounts[i])
                .checked_mul(shares.into())
                .unwrap()
                .checked_div(pool_token_supply.into())
                .unwrap()
                .as_u128();
        }

        println!("calc_remove_liquidity : {:?}", result);
    }else if let Some(matches) = matches.subcommand_matches("calc_remove_liquidity_by_tokens") {
        let amp_string: String = matches.value_of("amp").unwrap().into();
        let amp = amp_string.parse::<u128>().unwrap();
        let removed_c_amounts_str = matches.value_of("removed_c_amounts").unwrap();
        let removed_c_amounts_str_vec = removed_c_amounts_str.split(",").collect::<Vec<&str>>();
        let removed_c_amounts = removed_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let old_c_amounts_str = matches.value_of("old_c_amounts").unwrap();
        let old_c_amounts_str_vec = old_c_amounts_str.split(",").collect::<Vec<&str>>();
        let old_c_amounts = old_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let pool_token_supply_string: String = matches.value_of("pool_token_supply").unwrap().into();
        let pool_token_supply = pool_token_supply_string.parse::<u128>().unwrap();
        let total_fee_string: String = matches.value_of("total_fee").unwrap().into();
        let total_fee = total_fee_string.parse::<u32>().unwrap();
        let exchange_fee_string: String = matches.value_of("exchange_fee").unwrap().into();
        let exchange_fee = exchange_fee_string.parse::<u32>().unwrap();

        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let ss = StableSwap::new( amp, amp, 0, 0, 0);
        let (burned, fee_part) = ss.compute_lp_amount_for_withdraw(&removed_c_amounts, &old_c_amounts, pool_token_supply, &Fees::new(total_fee, &AdminFees::new(exchange_fee))).unwrap();
        println!("burned : {}", burned);
        println!("fee_part : {}", fee_part);
    }else if let Some(matches) = matches.subcommand_matches("calc_swap") {
        let amp_string: String = matches.value_of("amp").unwrap().into();
        let amp = amp_string.parse::<u128>().unwrap();
        let in_token_idx_string: String = matches.value_of("in_token_idx").unwrap().into();
        let in_token_idx = in_token_idx_string.parse::<u128>().unwrap() as usize;
        let in_c_amount_string: String = matches.value_of("in_c_amount").unwrap().into();
        let in_c_amount = in_c_amount_string.parse::<u128>().unwrap();
        let out_token_idx_string: String = matches.value_of("out_token_idx").unwrap().into();
        let out_token_idx = out_token_idx_string.parse::<u128>().unwrap() as usize;
        let old_c_amounts_str = matches.value_of("old_c_amounts").unwrap();
        let old_c_amounts_str_vec = old_c_amounts_str.split(",").collect::<Vec<&str>>();
        let old_c_amounts = old_c_amounts_str_vec.into_iter().map(|item| item.parse::<u128>().unwrap()).collect::<Vec<u128>>();
        let total_fee_string: String = matches.value_of("total_fee").unwrap().into();
        let total_fee = total_fee_string.parse::<u32>().unwrap();
        let exchange_fee_string: String = matches.value_of("exchange_fee").unwrap().into();
        let exchange_fee = exchange_fee_string.parse::<u32>().unwrap();

        let mut context = VMContextBuilder::new();
        testing_env!(context.predecessor_account_id(accounts(0)).build());
        let ss = StableSwap::new( amp, amp, 0, 0, 0);
        let res = ss.swap_to(in_token_idx, in_c_amount, out_token_idx, &old_c_amounts, &Fees::new(total_fee, &AdminFees::new(exchange_fee))).unwrap();
        println!("swap_out : {}", res.amount_swapped);
        println!("fee_part : {}", res.fee);
    }
}
'''
'''--- src/math.rs ---
///! Calculator to maintain the invariant on adding/removing liquidity and on swapping.
///! Large part of the code was taken from https://github.com/saber-hq/stable-swap/blob/master/stable-swap-math/src/curve.rs
use near_sdk::{Balance, Timestamp};
use uint::construct_uint;

use crate::admin_fee::AdminFees;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Fee divisor, allowing to provide fee in bps.
pub const FEE_DIVISOR: u32 = 10_000;

/// Minimum ramp duration.
pub const MIN_RAMP_DURATION: Timestamp = 86400;
/// Min amplification coefficient.
pub const MIN_AMP: u128 = 1;
/// Max amplification coefficient.
pub const MAX_AMP: u128 = 1_000_000;
/// Max amplification change.
pub const MAX_AMP_CHANGE: u128 = 10;

/// Stable Swap Fee calculator.
pub struct Fees {
    pub trade_fee: u32,
    pub admin_fee: u32,
}

impl Fees {
    pub fn new(total_fee: u32, fees: &AdminFees) -> Self {
        Self {
            trade_fee: total_fee,
            admin_fee: fees.exchange_fee + fees.referral_fee,
        }
    }

    pub fn zero() -> Self {
        Self {
            trade_fee: 0,
            admin_fee: 0,
        }
    }

    pub fn trade_fee(&self, amount: Balance) -> Balance {
        amount * (self.trade_fee as u128) / (FEE_DIVISOR as u128)
    }

    pub fn admin_trade_fee(&self, amount: Balance) -> Balance {
        amount * (self.admin_fee as u128) / (FEE_DIVISOR as u128)
    }

    pub fn normalized_trade_fee(&self, num_coins: u32, amount: Balance) -> Balance {
        let adjusted_trade_fee = (self.trade_fee * num_coins) / (4 * (num_coins - 1));
        amount * (adjusted_trade_fee as u128) / (FEE_DIVISOR as u128)
    }
}

/// Encodes all results of swapping from a source token to a destination token.
#[derive(Debug)]
pub struct SwapResult {
    /// New amount of source token.
    pub new_source_amount: Balance,
    /// New amount of destination token.
    pub new_destination_amount: Balance,
    /// Amount of destination token swapped.
    pub amount_swapped: Balance,
    /// Admin fee for the swap.
    pub admin_fee: Balance,
    /// Fee for the swap.
    pub fee: Balance,
}

/// The StableSwap invariant calculator.
pub struct StableSwap {
    /// Initial amplification coefficient (A)
    initial_amp_factor: u128,
    /// Target amplification coefficient (A)
    target_amp_factor: u128,
    /// Current unix timestamp
    current_ts: Timestamp,
    /// Ramp A start timestamp
    start_ramp_ts: Timestamp,
    /// Ramp A stop timestamp
    stop_ramp_ts: Timestamp,
}

impl StableSwap {
    pub fn new(
        initial_amp_factor: u128,
        target_amp_factor: u128,
        current_ts: Timestamp,
        start_ramp_ts: Timestamp,
        stop_ramp_ts: Timestamp,
    ) -> Self {
        Self {
            initial_amp_factor,
            target_amp_factor,
            current_ts,
            start_ramp_ts,
            stop_ramp_ts,
        }
    }

    /// Compute the amplification coefficient (A)
    pub fn compute_amp_factor(&self) -> Option<Balance> {
        if self.current_ts < self.stop_ramp_ts {
            let time_range = self.stop_ramp_ts.checked_sub(self.start_ramp_ts)?;
            let time_delta = self.current_ts.checked_sub(self.start_ramp_ts)?;

            // Compute amp factor based on ramp time
            if self.target_amp_factor >= self.initial_amp_factor {
                // Ramp up
                let amp_range = self
                    .target_amp_factor
                    .checked_sub(self.initial_amp_factor)?;
                let amp_delta = (amp_range as u128)
                    .checked_mul(time_delta as u128)?
                    .checked_div(time_range as u128)?;
                self.initial_amp_factor
                    .checked_add(amp_delta)
                    .map(|x| x as u128)
            } else {
                // Ramp down
                let amp_range = self
                    .initial_amp_factor
                    .checked_sub(self.target_amp_factor)?;
                let amp_delta = (amp_range as u128)
                    .checked_mul(time_delta as u128)?
                    .checked_div(time_range as u128)?;
                self.initial_amp_factor
                    .checked_sub(amp_delta)
                    .map(|x| x as u128)
            }
        } else {
            // when stop_ramp_ts == 0 or current_ts >= stop_ramp_ts
            Some(self.target_amp_factor as u128)
        }
    }

    /// Compute stable swap invariant (D)
    /// Equation:
    /// A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))
    pub fn compute_d(&self, c_amounts: &Vec<Balance>) -> Option<U256> {
        let n_coins = c_amounts.len() as u128;
        let sum_x = c_amounts.iter().fold(0, |sum, i| sum + i);
        if sum_x == 0 {
            Some(0.into())
        } else {
            let amp_factor = self.compute_amp_factor()?;
            // println!("#Debug amp_factor: {}", amp_factor);
            let mut d_prev: U256;
            let mut d: U256 = sum_x.into();
            for _ in 0..256 {
                // $ D_{k,prod} = \frac{D_k^{n+1}}{n^n \prod x_{i}} = \frac{D^3}{4xy} $
                let mut d_prod = d;
                for c_amount in c_amounts {
                    d_prod = d_prod.checked_mul(d)?
                    .checked_div((c_amount * n_coins + 1).into())?; // +1 to prevent divided by zero
                }
                d_prev = d;
                // println!("#Debug d_prod: {:?}", d_prod);

                let ann = amp_factor.checked_mul(n_coins.checked_pow(n_coins as u32)?.into())?;
                // println!("#Debug ann: {}", ann);
                // println!("#Debug sum_x: {}", sum_x);
                // let ann = amp_factor.checked_mul(n_coins.into())?;
                let leverage = (U256::from(sum_x)).checked_mul(ann.into())?;
                // println!("#Debug leverage: {:?}", leverage);
                // d = (ann * sum_x + d_prod * n_coins) * d_prev / ((ann - 1) * d_prev + (n_coins + 1) * d_prod)
                let numerator = d_prev.checked_mul(
                    d_prod
                        .checked_mul(n_coins.into())?
                        .checked_add(leverage.into())?,
                )?;
                // println!("#Debug numerator: {:?}", numerator);
                let denominator = d_prev
                    .checked_mul(ann.checked_sub(1)?.into())?
                    .checked_add(d_prod.checked_mul((n_coins + 1).into())?)?;
                // println!("#Debug denominator: {:?}", denominator);
                d = numerator.checked_div(denominator)?;

                // Equality with the precision of 1
                if d > d_prev {
                    if d.checked_sub(d_prev)? <= 1.into() {
                        break;
                    }
                } else if d_prev.checked_sub(d)? <= 1.into() {
                    break;
                }
            }
            // println!("D: {:?}", d);
            Some(d)
        }
    }

    /// Compute the amount of LP tokens to mint after a deposit
    /// return <lp_amount_to_mint, lp_fees_part>
    pub fn compute_lp_amount_for_deposit(
        &self,
        deposit_c_amounts: &Vec<Balance>, // deposit tokens in comparable precision,
        old_c_amounts: &Vec<Balance>, // current in-pool tokens in comparable precision,
        pool_token_supply: Balance, // current share supply
        fees: &Fees,
    ) -> Option<(Balance, Balance)> {
        let n_coins = old_c_amounts.len();
        
        // Initial invariant
        let d_0 = self.compute_d(old_c_amounts)?;
        // println!("[compute_lp_amount_for_deposit] d_0: {:?}", d_0);
        // println!("[compute_lp_amount_for_deposit] deposit_c_amounts: {:?}", deposit_c_amounts);

        let mut new_balances = vec![0_u128; n_coins];
        for (index, value) in deposit_c_amounts.iter().enumerate() {
            new_balances[index] = old_c_amounts[index].checked_add(*value)?;
        }
        // println!("[compute_lp_amount_for_deposit] new_balances: {:?}", new_balances);
        // Invariant after change
        let d_1 = self.compute_d(&new_balances)?;
        // println!("[compute_lp_amount_for_deposit] d_1: {:?}", d_1);
        if d_1 <= d_0 {
            None
        } else {
            // Recalculate the invariant accounting for fees
            for i in 0..new_balances.len() {
                let ideal_balance = d_1
                    .checked_mul(old_c_amounts[i].into())?
                    .checked_div(d_0)?
                    .as_u128();
                let difference = if ideal_balance > new_balances[i] {
                    ideal_balance.checked_sub(new_balances[i])?
                } else {
                    new_balances[i].checked_sub(ideal_balance)?
                };
                let fee = fees.normalized_trade_fee(n_coins as u32, difference);
                println!("fee {} : {}", i, fee);
                new_balances[i] = new_balances[i].checked_sub(fee)?;
            }

            let d_2 = self.compute_d(&new_balances)?;

            // d1 > d2 > d0, 
            // (d2-d0) => mint_shares (charged fee),
            // (d1-d0) => diff_shares (without fee),
            // (d1-d2) => fee part,
            // diff_shares = mint_shares + fee part

            let mint_shares = U256::from(pool_token_supply)
                .checked_mul(d_2.checked_sub(d_0)?)?
                .checked_div(d_0)?
                .as_u128();
            
            let diff_shares = U256::from(pool_token_supply)
                .checked_mul(d_1.checked_sub(d_0)?)?
                .checked_div(d_0)?
                .as_u128();

            // println!(
            //     "[compute_lp_amount_for_deposit] mint_shares: {}, fee_parts: {}", 
            //     mint_shares, diff_shares-mint_shares
            // );
            Some((mint_shares, diff_shares-mint_shares))
        }
    }

    /// Compute new amount of token 'y' with new amount of token 'x'
    /// return new y_token amount according to the equation
    pub fn compute_y(
        &self, 
        x_c_amount: Balance, // new x_token amount in comparable precision, 
        current_c_amounts: &Vec<Balance>,  // in-pool tokens amount in comparable precision,
        index_x: usize, // x token's index
        index_y: usize, // y token's index
    ) -> Option<U256> {
        let n_coins = current_c_amounts.len() as u128;
        let amp_factor = self.compute_amp_factor()?;
        // let ann = amp_factor.checked_mul(n_coins as u128)?;
        let ann = amp_factor.checked_mul(n_coins.checked_pow(n_coins as u32)?.into())?;
        // invariant
        let d = self.compute_d(current_c_amounts)?;
        let mut s_ = x_c_amount;
        let mut c = d.checked_mul(d)?.checked_div(x_c_amount.into())?;
        for (idx, c_amount) in current_c_amounts.iter().enumerate() {
            if idx != index_x && idx != index_y {
                s_ += *c_amount;
                c = c.checked_mul(d)?
                    .checked_div((*c_amount).into())?;
            }
        }
        c = c
            .checked_mul(d)?
            .checked_div(ann.checked_mul((n_coins as u128).checked_pow(n_coins as u32)?.into())?.into())?;

        let b = d.checked_div(ann.into())?.checked_add(s_.into())?; // d will be subtracted later

        // Solve for y by approximating: y**2 + b*y = c
        let mut y_prev: U256;
        let mut y = d;
        for _ in 0..256 {
            y_prev = y;
            // $ y_{k+1} = \frac{y_k^2 + c}{2y_k + b - D} $
            let y_numerator = y.checked_pow(2.into())?.checked_add(c)?;
            let y_denominator = y.checked_mul(2.into())?.checked_add(b)?.checked_sub(d)?;
            y = y_numerator.checked_div(y_denominator)?;
            if y > y_prev {
                if y.checked_sub(y_prev)? <= 1.into() {
                    break;
                }
            } else if y_prev.checked_sub(y)? <= 1.into() {
                break;
            }
        }
        Some(y)
    }

    /// given token_out user want get and total tokens in pool and lp token supply,
    /// return <lp_amount_to_burn, lp_fees_part>
    /// all amounts are in c_amount (comparable amount)
    pub fn compute_lp_amount_for_withdraw(
        &self,
        withdraw_c_amounts: &Vec<Balance>, // withdraw tokens in comparable precision,
        old_c_amounts: &Vec<Balance>, // in-pool tokens comparable amounts vector, 
        pool_token_supply: Balance, // total share supply
        fees: &Fees,
    ) -> Option<(Balance, Balance)> {
        let n_coins = old_c_amounts.len();
        // Initial invariant, D0
        let d_0 = self.compute_d(old_c_amounts)?;
        // println!("[compute_lp_amount_for_withdraw] d_0: {:?}", d_0);

        // real invariant after withdraw, D1
        let mut new_balances = vec![0_u128; n_coins];
        for (index, value) in withdraw_c_amounts.iter().enumerate() {
            new_balances[index] = old_c_amounts[index].checked_sub(*value)?;
        }
        // println!("[compute_lp_amount_for_withdraw] new_balances: {:?}", new_balances);
        let d_1 = self.compute_d(&new_balances)?;
        // println!("[compute_lp_amount_for_withdraw] d_1: {:?}", d_1);

        // compare ideal token portions from D1 with withdraws, to calculate diff fee.
        if d_1 >= d_0 {
            None
        } else {
            // Recalculate the invariant accounting for fees
            for i in 0..new_balances.len() {
                let ideal_balance = d_1
                    .checked_mul(old_c_amounts[i].into())?
                    .checked_div(d_0)?
                    .as_u128();
                let difference = if ideal_balance > new_balances[i] {
                    ideal_balance.checked_sub(new_balances[i])?
                } else {
                    new_balances[i].checked_sub(ideal_balance)?
                };
                let fee = fees.normalized_trade_fee(n_coins as u32, difference);
                println!("fee {} : {}", i, fee);
                // new_balance is for calculation D2, the one with fee charged
                new_balances[i] = new_balances[i].checked_sub(fee)?;
            }

            let d_2 = self.compute_d(&new_balances)?;

            // d0 > d1 > d2, 
            // (d0-d2) => burn_shares (plus fee),
            // (d0-d1) => diff_shares (without fee),
            // (d1-d2) => fee part,
            // burn_shares = diff_shares + fee part
            let burn_shares = U256::from(pool_token_supply)
                .checked_mul(d_0.checked_sub(d_2)?)?
                .checked_div(d_0)?
                .as_u128();
            let diff_shares = U256::from(pool_token_supply)
                .checked_mul(d_0.checked_sub(d_1)?)?
                .checked_div(d_0)?
                .as_u128();

            // println!("[compute_lp_amount_for_withdraw] burn_shares: {}, fee_parts: {}", 
            //     burn_shares, burn_shares-diff_shares);
            Some((burn_shares, burn_shares-diff_shares))
        }

    }

    /// Compute SwapResult after an exchange
    /// all tokens in and out with comparable precision
    pub fn swap_to(
        &self,
        token_in_idx: usize, // token_in index in token vector,
        token_in_amount: Balance, // token_in amount in comparable precision (1e18),
        token_out_idx: usize, // token_out index in token vector,
        current_c_amounts: &Vec<Balance>, // in-pool tokens comparable amounts vector, 
        fees: &Fees,
    ) -> Option<SwapResult> {
        let y = self.compute_y(
            token_in_amount + current_c_amounts[token_in_idx], 
            current_c_amounts,
            token_in_idx,
            token_out_idx,
        )?.as_u128();

        let dy = current_c_amounts[token_out_idx].checked_sub(y)?;
        let trade_fee = fees.trade_fee(dy);
        let admin_fee = fees.admin_trade_fee(trade_fee);
        let amount_swapped = dy.checked_sub(trade_fee)?;

        let new_destination_amount = current_c_amounts[token_out_idx]
            .checked_sub(amount_swapped)?
            .checked_sub(admin_fee)?;
        let new_source_amount = current_c_amounts[token_in_idx]
            .checked_add(token_in_amount)?;

        Some(SwapResult {
            new_source_amount,
            new_destination_amount,
            amount_swapped,
            admin_fee,
            fee: trade_fee,
        })
    }
}

'''