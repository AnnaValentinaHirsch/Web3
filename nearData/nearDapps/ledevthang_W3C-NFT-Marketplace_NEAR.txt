*GitHub Repository "ledevthang/W3C-NFT-Marketplace_NEAR"*

'''--- .github/dependabot.yml ---
version: 2
updates:
- package-ecosystem: cargo
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10

'''
'''--- .github/scripts/readme.sh ---
#!/bin/bash
echo ==== Quick Deploy ====
TEXT=$(printf 'y\n' | near dev-deploy --wasmFile res/status_message.wasm --helperUrl https://near-contract-helper.onrender.com)
if [[ ! "$TEXT" =~ .*"Done deploying to".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Set dev account env variable ====
source neardev/dev-account.env
TEXT=$(echo $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"dev-".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Set status ====
TEXT=$(near call $CONTRACT_NAME set_status '{"message": "aloha!"}' --accountId $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Get status ====
TEXT=$(near view $CONTRACT_NAME get_status '{"account_id": "'$CONTRACT_NAME'"}')
if [[ ! "$TEXT" =~ .*"aloha!".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1
else
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

'''
'''--- .github/workflows/readme.yml ---
name: Readme CI
on:
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  readme-ci:
    strategy:
      matrix:
        platform: [ubuntu-latest] # mac-os lags out
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Install NEAR CLI
        run: npm install near-cli -g
      - name: Building this contract
        run: npm run build
      - name: Run Readme Quick Deploy Commands
        run: bash .github/scripts/readme.sh
'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: 
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest]  # mac-os in development
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Install modules
        run: yarn
      - name: Run unit tests
        run: yarn test:unit
      - name: Run integration tests
        run: yarn test:integration

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for all branches in this repo (defaults to false)
    branches: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli && nvm use default
    init: yarn && yarn dev
    command: source ~/.bashrc; gp open README-Gitpod.md && yarn dev

vscode:
  extensions:
    - hbenl.vscode-test-explorer@2.15.0:koqDUMWDPJzELp/hdS/lWw==
    - Swellaby.vscode-rust-test-adapter@0.11.0:Xg+YeZZQiVpVUsIkH+uiiw==
    - bungcip.better-toml@0.3.2:3QfgGxxYtGHfJKQU7H0nEw==

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12.0
os:
  - linux
  - osx
  - windows
before_install:
  - curl https://sh.rustup.rs -sSf -m 60 | sh -s -- -y -v --default-toolchain stable
  - if [[ "$TRAVIS_OS_NAME" == "windows" ]]; then HOME="/c/Users/travis"; fi
  - export PATH="$HOME/.cargo/bin:$PATH"
  - rustup target add wasm32-unknown-unknown
script:
  - npm run build
  - cargo test --package status-message -- --nocapture
'''
'''--- Cargo.toml ---
[package]
name = "status-message"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "*", features = ["derive"] }
serde_json = "*"
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README-Gitpod.md ---
Status Message in Rust - Gitpod version
=======================================

This smart contract saves and records the status messages of NEAR accounts that call it.

**Note**: this README is specific to Gitpod and this example. For local development, please see [README.md](README.md).

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

In the project root, login with `near-cli` by following the instructions after this command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

If all is successful the app should be live at `localhost:1234`!

### CLI

In Gitpod, a process has automatically created a new NEAR account that's useful for a quick (and likely temporary) usage.
We've set an environment variable in Gitpod with the account name. At the bottom of this screen there's a Terminal.

You may see the NEAR account by running this command:
```bash
echo $CONTRACT_NAME
```

The next command will call the contract's `set_status` method:

```bash
near call $CONTRACT_NAME set_status '{"message": "aloha!"}' --accountId $CONTRACT_NAME
```

To retrieve the message from the contract, call `get_status` with the following:

```bash
near view $CONTRACT_NAME get_status '{"account_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```

Note that these status messages are stored per account in a `HashMap`. See `src/lib.rs` for the code. We can try the same steps with another account to verify.
**Note**: we're adding `NEW_ACCOUNT_NAME` for the next couple steps.

There are two ways to create a new account:
 - the NEAR Wallet (as we did before)
 - `near create_account NEW_ACCOUNT_NAME --masterAccount $CONTRACT_NAME`

Now call the contract on the first account (where it's deployed):

```bash
near call $CONTRACT_NAME set_status '{"message": "bonjour"}' --accountId NEW_ACCOUNT_NAME
```

```bash
near view $CONTRACT_NAME get_status '{"account_id": "NEW_ACCOUNT_NAME"}'
```

Returns `bonjour`.

Make sure the original status remains:

```bash
near view $CONTRACT_NAME get_status '{"account_id": "$CONTRACT_NAME"}'
```

Now that you've seen this working in Gitpod, feel free to clone this repository and use it as a starting point for your own project.

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

## Data collection
By using Gitpod in this project, you agree to opt-in to basic, anonymous analytics. No personal information is transmitted. Instead, these usage statistics aid in discovering potential bugs and user flow information.

'''
'''--- README-Windows.md ---
Status Message
==============

This smart contract saves and records the status messages of NEAR accounts that call it.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

## Prerequisites
Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

Ensure `Rust` is installed by running:

```
rustc --version
```

If needed, install `Rust`:

```
curl https://sh.rustup.rs -sSf | sh
```

Install dependencies

```
npm install
```

## Building this contract
To make the build process compatible with multiple operating systems, the build process exists as a script in `package.json`.
There are a number of special flags used to compile the smart contract into the wasm file.
Run this command to build and place the wasm file in the `res` directory:
```bash
npm run build
```

**Note**: Instead of `npm`, users of [yarn](https://yarnpkg.com) may run:
```bash
yarn build
```

### Important
If you encounter an error similar to:
>note: the `wasm32-unknown-unknown` target may not be installed

Then run:

```bash
rustup target add wasm32-unknown-unknown
```

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

If all is successful the app should be live at `localhost:1234`!

### Quickest deploy
Build and deploy this smart contract to an development account. This development account will be created automatically and is not intended to be permanent. Please see the "Standard deploy" section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/status_message.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing the key to the account, located at `neardev/dev-account.env`. To make the next few steps easier, we're going to set an environment variable containing this development account id and use that when copy/pasting commands.

If the account name is not immediately visible on the Command Prompt, you may find it by running:

```bash
type neardev\dev-account.env
```

It will display something similar to `CONTRACT_NAME=dev-12345678901234`.
Please set the Windows environment variable by copying that value and running `set` like so:

```bash
set CONTRACT_NAME=dev-12345678901234
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo %CONTRACT_NAME%
```

The next command will call the contract's `set_status` method:

```bash
near call %CONTRACT_NAME% set_status "{\"message\": \"aloha!\"}" --accountId %CONTRACT_NAME%
```

**Note**: at the time of this writing, Windows does not handle single quotes `'` well, so these commands must use escaped double-quotes `\"` which, as you may know, equates to a regular double quote `"` when parsed. Apologies for some of the unsightly commands, but it's out of necessity.

To retrieve the message from the contract, call `get_status` with the following:

```bash
near view %CONTRACT_NAME% get_status "{\"account_id\": \""%CONTRACT_NAME%"\"}" --accountId %CONTRACT_NAME%
```

### Standard deploy
In this option, the smart contract will get deployed to a specific account created with the NEAR Wallet.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Set a status for your account:

```bash
near call YOUR_ACCOUNT_NAME set_status "{\"message\": \"aloha friend\"}" --accountId YOUR_ACCOUNT_NAME
```

Get the status:

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"YOUR_ACCOUNT_NAME\"}"
```

Note that these status messages are stored per account in a `HashMap`. See `src/lib.rs` for the code. We can try the same steps with another account to verify.
**Note**: we're adding `NEW_ACCOUNT_NAME` for the next couple steps.

There are two ways to create a new account:
 - the NEAR Wallet (as we did before)
 - `near create_account NEW_ACCOUNT_NAME --masterAccount YOUR_ACCOUNT_NAME`

Now call the contract on the first account (where it's deployed):

```bash
near call YOUR_ACCOUNT_NAME set_status "{\"message\": \"bonjour\"}" --accountId NEW_ACCOUNT_NAME
```

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"NEW_ACCOUNT_NAME\"}"
```

Returns `bonjour`.

Make sure the original status remains:

```bash
near view YOUR_ACCOUNT_NAME get_status "{\"account_id\": \"YOUR_ACCOUNT_NAME\"}"
```

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

'''
'''--- README.md ---
Status Message
==============

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/rust-status-message)

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

This smart contract saves and records the status messages of NEAR accounts that call it.

Windows users: please visit the [Windows-specific README file](README-Windows.md).

## Prerequisites
Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

Ensure `Rust` is installed by running:

```
rustc --version
```

If needed, install `Rust`:

```
curl https://sh.rustup.rs -sSf | sh
```

Install dependencies

```
npm install
```

## Quick Start
To run this project locally:

1. Prerequisites: Make sure you have Node.js ≥ 12 installed (https://nodejs.org), then use it to install yarn: `npm install --global yarn` (or just `npm i -g yarn`)
2. Run the local development server: `yarn && yarn dev` (see package.json for a full list of scripts you can run with yarn)
Now you'll have a local development environment backed by the NEAR TestNet! Running yarn dev will tell you the URL you can visit in your browser to see the app.

## Building this contract
To make the build process compatible with multiple operating systems, the build process exists as a script in `package.json`.
There are a number of special flags used to compile the smart contract into the wasm file.
Run this command to build and place the wasm file in the `res` directory:
```bash
npm run build
```

**Note**: Instead of `npm`, users of [yarn](https://yarnpkg.com) may run:
```bash
yarn build
```

### Important
If you encounter an error similar to:
>note: the `wasm32-unknown-unknown` target may not be installed

Then run:

```bash
rustup target add wasm32-unknown-unknown
```

## Using this contract

### Web app

Deploy the smart contract to a specific account created with the NEAR Wallet. Then interact with the smart contract using near-api-js on the frontend.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract to your NEAR account:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Build the frontend:

```bash
npm start
```

If all is successful the app should be live at `localhost:1234`!

### Quickest deploy
Build and deploy this smart contract to an development account. This development account will be created automatically and is not intended to be permanent. Please see the "Standard deploy" section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/status_message.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing the key to the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will call the contract's `set_status` method:

```bash
near call $CONTRACT_NAME set_status '{"message": "aloha!"}' --accountId $CONTRACT_NAME
```

To retrieve the message from the contract, call `get_status` with the following:

```bash
near view $CONTRACT_NAME get_status '{"account_id": "'$CONTRACT_NAME'"}'
```

### Standard deploy
In this option, the smart contract will get deployed to a specific account created with the NEAR Wallet.

If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

Make sure you have credentials saved locally for the account you want to deploy the contract to. To perform this run the following `near-cli` command:

```
near login
```

Deploy the contract:

```bash
near deploy --wasmFile res/status_message.wasm --accountId YOUR_ACCOUNT_NAME
```

Set a status for your account:

```bash
near call YOUR_ACCOUNT_NAME set_status '{"message": "aloha friend"}' --accountId YOUR_ACCOUNT_NAME
```

Get the status:

```bash
near view YOUR_ACCOUNT_NAME get_status '{"account_id": "YOUR_ACCOUNT_NAME"}'
```

Note that these status messages are stored per account in a `HashMap`. See `src/lib.rs` for the code. We can try the same steps with another account to verify.
**Note**: we're adding `NEW_ACCOUNT_NAME` for the next couple steps.

There are two ways to create a new account:
 - the NEAR Wallet (as we did before)
 - `near create_account NEW_ACCOUNT_NAME --masterAccount YOUR_ACCOUNT_NAME`

Now call the contract on the first account (where it's deployed):

```bash
near call YOUR_ACCOUNT_NAME set_status '{"message": "bonjour"}' --accountId NEW_ACCOUNT_NAME
```

```bash
near view YOUR_ACCOUNT_NAME get_status '{"account_id": "NEW_ACCOUNT_NAME"}'
```

Returns `bonjour`.

Make sure the original status remains:

```bash
near view YOUR_ACCOUNT_NAME get_status '{"account_id": "YOUR_ACCOUNT_NAME"}'
```

## Testing
To test run:
```bash
cargo test --package status-message -- --nocapture
```

'''
'''--- borsh.js ---
const borsh = require("borsh");

class Assignable {
  constructor(properties) {
    Object.keys(properties).map((key) => {
      this[key] = properties[key];
    });
  }
}

class StatusMessage extends Assignable {}

class Record extends Assignable {}

const schema = new Map([
  [StatusMessage, { kind: "struct", fields: [["records", [Record]]] }],
  [
    Record,
    {
      kind: "struct",
      fields: [
        ["k", "string"],
        ["v", "string"],
      ],
    },
  ],
]);

const stateKey = "U1RBVEU=";
console.log(Buffer.from(stateKey, "base64"));
console.log(Buffer.from(stateKey, "base64").toString());
const stateValue =
  "AgAAAA8AAABhbGljZS50ZXN0Lm5lYXIFAAAAaGVsbG8NAAAAYm9iLnRlc3QubmVhcgUAAAB3b3JsZA==";
const stateValueBuffer = Buffer.from(stateValue, "base64");
let statusMessage = borsh.deserialize(schema, StatusMessage, stateValueBuffer);
console.log(statusMessage);

console.log(
  Buffer.from(borsh.serialize(schema, statusMessage)).toString("base64")
);
statusMessage.records.push(new Record({ k: "alice.near", v: "hello world" }));
console.log(statusMessage);

console.log(
  Buffer.from(borsh.serialize(schema, statusMessage)).toString("base64")
);

'''
'''--- frontend/App.js ---
import "regenerator-runtime/runtime";
import React, { useState, useEffect } from "react";
import PropTypes from "prop-types";
import Big from "big.js";
import Form from "./components/Form";

const BOATLOAD_OF_GAS = Big(3).times(10 ** 13).toFixed();

const App = ({ contract, currentUser, nearConfig, wallet }) => {
  const [status, setStatus] = useState(null);

  useEffect(async () => {
    if (currentUser) {
      const status = await contract.get_status({
        account_id: currentUser.accountId
      });

      setStatus(status);
    }
  });

  const onSubmit = async event => {
    event.preventDefault();

    const { fieldset, message } = event.target.elements;
    fieldset.disabled = true;

    await contract.set_status(
      {
        message: message.value,
        account_id: currentUser.accountId
      },
      BOATLOAD_OF_GAS
    );

    const status = await contract.get_status({
      account_id: currentUser.accountId
    });

    setStatus(status);

    message.value = "";
    fieldset.disabled = false;
    message.focus();
  };

  const signIn = () => {
    wallet.requestSignIn(
      {contractId: nearConfig.contractName, methodNames: ['set_status']},
      "NEAR Status Message"
    );
  };

  const signOut = () => {
    wallet.signOut();
    window.location.replace(window.location.origin + window.location.pathname);
  };

  return (
    <main>
      <header>
        <h1>NEAR Status Message</h1>

        {currentUser ?
          <p>Currently signed in as: <code>{currentUser.accountId}</code></p>
        :
          <p>Update or add a status message! Please login to continue.</p>
        }

        { currentUser
          ? <button onClick={signOut}>Log out</button>
          : <button onClick={signIn}>Log in</button>
        }
      </header>

      {currentUser &&
        <Form
          onSubmit={onSubmit}
          currentUser={currentUser}
        />
      }

      {status ?
        <>
          <p>Your current status:</p>
          <p>
            <code>
              {status}
            </code>
          </p>
        </>
      :
        <p>No status message yet!</p>
      }
    </main>
  );
};

App.propTypes = {
  contract: PropTypes.shape({
    set_status: PropTypes.func.isRequired,
    get_status: PropTypes.func.isRequired
  }).isRequired,
  currentUser: PropTypes.shape({
    accountId: PropTypes.string.isRequired,
    balance: PropTypes.string.isRequired
  }),
  nearConfig: PropTypes.shape({
    contractName: PropTypes.string.isRequired
  }).isRequired,
  wallet: PropTypes.shape({
    requestSignIn: PropTypes.func.isRequired,
    signOut: PropTypes.func.isRequired
  }).isRequired
};

export default App;

'''
'''--- frontend/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || "testnet";

function getConfig(env) {
  switch(env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in frontend/config.js.`);
  }
}

module.exports = getConfig;

'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />

    <link href="global.scss" rel="stylesheet" />

    <title>NEAR Status Message</title>
    <meta property="og:title" content="NEAR Status Message">
    <meta property="og:description" content="Update a user's status message on the NEAR blockchain">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- frontend/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import getConfig from './config.js';
import * as nearAPI from 'near-api-js';

// Initializing contract
async function initContract() {
  const nearConfig = getConfig(process.env.NODE_ENV || 'testnet');

  // Initializing connection to the NEAR TestNet
  const near = await nearAPI.connect({
    keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore(),
    ...nearConfig
  });

  // Needed to access wallet
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in account data
  let currentUser;
  if(walletConnection.getAccountId()) {
    currentUser = {
      accountId: walletConnection.getAccountId(),
      balance: (await walletConnection.account().state()).amount
    };
  }

  // Initializing our contract APIs by contract name and configuration
  const contract = await new nearAPI.Contract(walletConnection.account(), nearConfig.contractName, {
    // View methods are read-only – they don't modify the state, but usually return some value
    viewMethods: ['get_status'],
    // Change methods can modify the state, but you don't receive the returned value when called
    changeMethods: ['set_status'],
    // Sender is the account ID to initialize transactions.
    // getAccountId() will return empty string if user is still unauthorized
    sender: walletConnection.getAccountId()
  });

  return { contract, currentUser, nearConfig, walletConnection };
}

window.nearInitPromise = initContract()
  .then(({ contract, currentUser, nearConfig, walletConnection }) => {
    ReactDOM.render(
      <App
        contract={contract}
        currentUser={currentUser}
        nearConfig={nearConfig}
        wallet={walletConnection}
      />,
      document.getElementById('root')
    );
  });

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "rust-status-message-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/rs/src/tests.rs ---
use serde_json::json;
use near_units::parse_near;
use workspaces::prelude::*; 
use workspaces::{network::Sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../../res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let owner = worker.root_account().unwrap();
    let alice = owner
    .create_subaccount(&worker, "alice")
    .initial_balance(parse_near!("30 N"))
    .transact()
    .await?
    .into_result()?;

    // begin tests  
    test_set_message(&owner, &alice, &contract, &worker).await?;
    test_null_messages(&owner, &alice, &contract, &worker).await?;
    test_differing_statuses(&owner, &alice, &contract, &worker).await?;
    Ok(())
}   

async fn test_set_message(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    user
        .call(&worker, contract.id(), "set_status")
        .args_json(json!({ "message": "hello" }))?
        .transact()
        .await?;

    let alice_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": user.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(alice_status, "hello");
    println!("      Passed ✅ set get message");
    Ok(())
}

async fn test_null_messages(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let owner_status: Option<String> = user
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": owner.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(owner_status, None);
    println!("      Passed ✅ get nonexistent message");
    Ok(())
}

async fn test_differing_statuses(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, contract.id(), "set_status")
        .args_json(json!({ "message": "world" }))?
        .transact()
        .await?;

    let alice_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": user.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(alice_status, "hello");

    let owner_status: String = owner
        .call(&worker, contract.id(), "get_status")
        .args_json(json!({ "account_id": owner.id() }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(owner_status, "world");
    println!("      Passed ✅ root and alice have different statuses");
    Ok(())
}
'''
'''--- integration-tests/ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // deploy contract
  const root = worker.rootAccount;
  const contract = await root.devDeploy(
    "./res/status_message.wasm",
    { initialBalance: NEAR.parse("30 N").toJSON() }
  );

  // some test accounts
  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const charlie = await root.createSubAccount("charlie", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, alice, bob, charlie };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("set get message", async (t) => {
  const { contract, alice } = t.context.accounts;
  await alice.call(contract, "set_status", { message: "hello" });
  const aliceStatus = await contract.view("get_status", { account_id: alice });
  t.is(aliceStatus, "hello");
});

test("get nonexistent message", async (t) => {
  const { root, contract } = t.context.accounts;
  const message: null = await contract.view("get_status", {
    account_id: root,
  });
  t.is(message, null);
});

test("root and alice have different statuses", async (t) => {
  const { root, contract, alice } = t.context.accounts;
  await root.call(contract, "set_status", { message: "world" });
  const rootStatus = await contract.view("get_status", { account_id: root });
  t.is(rootStatus, "world");
  const aliceStatus = await contract.view("get_status", { account_id: alice });
  t.is(aliceStatus, null);
});

'''
'''--- package.json ---
{
  "name": "rust-status-message-builder",
  "version": "1.0.0",
  "description": "Compiles NEAR Protocol example of setting and retrieving a status message per NEAR account",
  "scripts": {
    "build": "rustup target add wasm32-unknown-unknown && cargo build --target wasm32-unknown-unknown --release",
    "build:web": "parcel build ./frontend/index.html --public-url ./ --no-minify",
    "postbuild": "cp ./target/wasm32-unknown-unknown/release/status_message.wasm ./res/",
    "deploy:dev": "npm run build && near dev-deploy res/status_message.wasm",
    "dev": "npm run deploy:dev && npm start",
    "start": "npm run build && npm run build:web && env-cmd -f ./neardev/dev-account.env parcel ./frontend/index.html",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cargo test -- --nocapture",
    "test:integration": "npm run test:integration:rs && npm run test:integration:ts",
    "test:integration:rs": "npm run build && npm run postbuild && cd integration-tests/rs && cargo run --example integration-tests",
    "test:integration:ts": "npm run build && npm run postbuild && ava --verbose"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/near-examples/rust-status-message.git"
  },
  "keywords": [
    "near-protocol",
    "blockchain",
    "rust",
    "smart-contract"
  ],
  "author": "Mike Purvis",
  "license": "(MIT AND Apache-2.0)",
  "bugs": {
    "url": "https://github.com/near-examples/rust-status-message/issues"
  },
  "homepage": "https://github.com/near-examples/rust-status-message#readme",
  "dependencies": {
    "big.js": "^5.2.2",
    "borsh": "^0.4.0",
    "env-cmd": "^10.1.0",
    "near-api-js": "^0.43.1",
    "prop-types": "^15.7.2",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "regenerator-runtime": "^0.13.9"
  },
  "devDependencies": {
    "@babel/core": "^7.14.0",
    "@babel/preset-env": "^7.14.2",
    "@babel/preset-react": "^7.13.13",
    "cssnano": "^5.0.7",
    "gh-pages": "^3.1.0",
    "parcel-bundler": "^1.12.5",
    "postcss": "^8.3.6",
    "sass": "^1.37.0",
    "near-workspaces": "^3.1.0",
    "ava": "^4.2.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.7.0"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/external.rs ---
use crate::*;

/// external contract calls

//initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
//a payout object used for the market to distribute funds to the appropriate accounts.
#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId, //purchaser (person to transfer the NFT to)
        token_id: TokenId, //token ID to transfer
        approval_id: u64, //market contract's approval ID in order to transfer the token on behalf of the owner
        memo: String, //memo (to include some context)
        /*
            the price that the token was purchased for. This will be used in conjunction with the royalty percentages
            for the token in order to determine how much money should go to which account. 
        */
        balance: U128,
        //the maximum amount of accounts the market can payout at once (this is limited by GAS)
		max_len_payout: u32,
    );
}
'''
'''--- src/internal.rs ---
use crate::*;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Marketplace {
    //internal method for removing a listing from the market. This returns the previously removed listing object
    pub(crate) fn internal_remove_listing(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Listing {
        //get the unique listing ID (contract + DELIMITER + token ID)
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        //get the listing object by removing the unique listing ID. If there was no listing, panic
        let listing = self.listings.remove(&contract_and_token_id).expect("No listing");

        //get the set of listings for the listing's owner. If there's no listing, panic. 
        let mut by_owner_id = self.by_owner_id.get(&listing.seller).expect("No listing by_owner_id");
        //remove the unique listing ID from the set of listings
        by_owner_id.remove(&contract_and_token_id);
        
        //if the set of listings is now empty after removing the unique listing ID, we simply remove that owner from the map
        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&listing.seller);
        //if the set of listings is not empty after removing, we insert the set back into the map for the owner
        } else {
            self.by_owner_id.insert(&listing.seller, &by_owner_id);
        }

        //get the set of token IDs for listing for the nft contract ID. If there's no listing, panic. 
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No listing by nft_contract_id");
        
        //remove the token ID from the set 
        by_nft_contract_id.remove(&token_id);
        
        //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
        if by_nft_contract_id.is_empty() {
            self.by_nft_contract_id.remove(&nft_contract_id);
        //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
        } else {
            self.by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        //return the listing object
        listing
    }
}
'''
'''--- src/lib.rs ---
use external::ext_contract;
use near_contract_standards::non_fungible_token::{NonFungibleToken, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::json_types::{U128, U64};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, promise_result_as_success, AccountId,
    Balance, BorshStorageKey, CryptoHash, Gas, PanicOnDefault, Promise,
};
use serde::{Deserialize, Serialize};

mod external;
mod internal;
mod nft_callback;
mod sale_views;

#[cfg(test)]
mod test;

const GAS_FOR_RESOLVE_PURCHASE: Gas = Gas(115_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(15_000_000_000_000);

//the minimum storage to have a sale on the contract.
const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
static DELIMETER: &str = ".";

pub type ContractAndTokenId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Listing {
    //owner of the sale
    pub seller: AccountId,
    //market contract's approval ID to transfer the token on behalf of the owner
    pub approval_id: u64,
    //nft contract where the token was minted
    pub nft_contract_id: String,
    //actual token ID for sale
    pub token_id: String,
    //sale price in yoctoNEAR that the token is listed for
    pub starting_price: u128,

    pub started_at: u64,

    pub end_at: u64,

    pub highest_bidder: Option<AccountId>,

    pub highest_price: u128,

    pub is_auction: bool,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Marketplace {
    pub owner: AccountId,
    pub owner_cut: u16,
    pub listings: UnorderedMap<ContractAndTokenId, Listing>,
    //keep track of the storage that accounts have payed
    pub storage_deposits: LookupMap<AccountId, Balance>,
    //keep track of all the Sale IDs for every account ID
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,
    //keep track of all the token IDs for sale for a given contract
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    ByNFTTokenType,
    ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
}

#[near_bindgen]
impl Marketplace {
    #[init]
    pub fn new(_owner_cut: u16) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let owner_id = env::signer_account_id();
        Self {
            owner: owner_id,
            owner_cut: _owner_cut,
            listings: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
        }
    }

    //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        //get the account ID to pay for storage for
        let storage_account_id = account_id
            //convert the valid account ID into an account ID
            .map(|a| a.into())
            //if we didn't specify an account ID, we simply use the caller of the function
            .unwrap_or_else(env::predecessor_account_id);

        //get the deposit value which is how much the user wants to add to their storage
        let deposit = env::attached_deposit();

        //make sure the deposit is greater than or equal to the minimum storage for a sale
        assert!(
            deposit >= STORAGE_PER_SALE,
            "Requires minimum deposit of {}",
            STORAGE_PER_SALE
        );

        //get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        //add the deposit to their balance
        balance += deposit;
        //insert the balance back into the map for that account ID
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    //Bob could then withdraw this 0.01N back into his account.
    #[payable]
    pub fn storage_withdraw(&mut self) {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key).
        assert_one_yocto();

        //the account to withdraw storage to is always the function caller
        let owner_id = env::predecessor_account_id();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);

        //how many sales is that user taking up currently. This returns a set
        let sales = self.by_owner_id.get(&owner_id);
        //get the length of that set.
        let len = sales.map(|s| s.len()).unwrap_or_default();
        //how much NEAR is being used up for all the current sales on the account
        let diff = u128::from(len) * STORAGE_PER_SALE;

        //the excess to withdraw is the total storage paid - storage being used up.
        amount -= diff;

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }
        //we need to add back the storage being used up into the map if it's greater than 0.
        //this is so that if the user had 500 sales on the market, we insert that value here so
        //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
        if diff > 0 {
            self.storage_deposits.insert(&owner_id, &diff);
        }
    }

    pub fn create_listing(
        &mut self,
        _nft_address: AccountId,
        _token_id: String,

        _starting_price: u128,
        _end_at: u64,
        _started_at: u64,
        _highest_price: u128,
        _is_auction: bool,
    ) {
        let seller = env::signer_account_id();
        let contract_and_token_id = format!("{}{}{}", _nft_address, DELIMETER, _token_id);
        assert!(
            self.listings.get(&contract_and_token_id) != None,
            "NFT not approved yet"
        );
        let mut listing = self.listings.get(&contract_and_token_id).unwrap();

        listing.seller = seller;
        listing.starting_price = _starting_price;
        listing.end_at = _end_at;
        listing.started_at = _started_at;
        listing.is_auction = _is_auction;

        self.listings.insert(&contract_and_token_id, &listing);
    }

    #[payable]
    pub fn bid(&mut self, _nft_address: AccountId, _token_id: String, _price: u128) {
        assert_one_yocto();
        let signer = env::signer_account_id();

        let contract_and_token_id = format!("{}{}{}", _nft_address, DELIMETER, _token_id);
        assert!(
            self.listings.get(&contract_and_token_id) != None,
            "NFT not listed yet"
        );
        let mut listing = self.listings.get(&contract_and_token_id).unwrap();
        assert!(listing.is_auction == true, "Not auction");
        assert!(
            Self::is_on_auction(listing.clone()) == true,
            "Auction not on"
        );
        assert!(listing.seller != signer, "Invalid bid");
        assert!(_price > listing.highest_price, "Invalid price");
        listing.highest_price = _price;
        listing.highest_bidder = Some(signer);
    }

    pub fn cancel_listing(&mut self, _nft_address: AccountId, _token_id: String) {
        let signer = env::signer_account_id();

        let contract_and_token_id = format!("{}{}{}", _nft_address, DELIMETER, _token_id);
        assert!(
            self.listings.get(&contract_and_token_id) != None,
            "NFT not listed yet"
        );
        let listing = self.listings.get(&contract_and_token_id).unwrap();
        assert!(signer == listing.seller, "Not authorized");
        self.listings.remove(&contract_and_token_id);
    }

    #[payable]
    pub fn purchase_nft(&mut self, _nft_address: AccountId, _token_id: String) {
        let signer = env::signer_account_id();
        let deposit = env::attached_deposit();

        let contract_and_token_id = format!("{}{}{}", _nft_address, DELIMETER, _token_id);
        assert!(
            self.listings.get(&contract_and_token_id) != None,
            "NFT not listed yet"
        );
        let listing = self.listings.get(&contract_and_token_id).unwrap();
        if listing.is_auction == true {
            assert!(
                Self::is_on_auction(listing.clone()) == true && listing.highest_price > 0,
                "Auction not on"
            );
            assert!(listing.highest_bidder.unwrap() == signer, "not winner");
            assert!(listing.highest_price <= deposit);
        } else {
            assert!(listing.starting_price <= deposit);
        }

        self.process_purchase(
            _nft_address,
            _token_id,
            U128(deposit),
            listing.seller,
            signer,
        );
    }

    pub fn set_price(&mut self, _nft_address: AccountId, _token_id: String, _price: u128) {
        let signer = env::signer_account_id();

        let contract_and_token_id = format!("{}{}{}", _nft_address, DELIMETER, _token_id);
        assert!(
            self.listings.get(&contract_and_token_id) != None,
            "NFT not listed yet"
        );
        let mut listing = self.listings.get(&contract_and_token_id).unwrap();
        assert!(listing.is_auction == false, "is auction");
        assert!(signer == listing.seller, "Not authorized");
        listing.starting_price = _price;

        self.listings.insert(&contract_and_token_id, &listing);
    }

    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    }

    fn is_on_auction(listing: Listing) -> bool {
        return env::block_timestamp() > listing.started_at
            && env::block_timestamp() < listing.end_at;
    }

    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
        seller: AccountId,
        buyer: AccountId,
    ) -> Promise {
        //get the sale object by removing the sale
        let sale =
            self.internal_remove_listing(nft_contract_id.clone(), token_id.to_string().clone());

        //a payout object used for the market to distribute funds to the appropriate accounts.
        ext_contract::ext(nft_contract_id)
            // Attach 1 yoctoNEAR with static GAS equal to the GAS for nft transfer. Also attach an unused GAS weight of 1 by default.
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer_payout(
                buyer.clone(),                    //purchaser (person to transfer the NFT to)
                token_id.to_string(),             //token ID to transfer
                sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
                "payout from market".to_string(), //memo (to include some context)
                /*
                    the price that the token was purchased for. This will be used in conjunction with the royalty percentages
                    for the token in order to determine how much money should go to which account.
                */
                price,
                10, //the maximum amount of accounts the market can payout at once (this is limited by GAS)
            )
            //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function.
            //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
            .then(
                // No attached deposit with static GAS equal to the GAS for resolving the purchase. Also attach an unused GAS weight of 1 by default.
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_PURCHASE)
                    .resolve_purchase(seller, price.into()),
            )
    }

    #[private]
    pub fn resolve_purchase(&mut self, seller: AccountId, price: u128) -> u128 {
        let owner_cut = price
            .saturating_mul(self.owner_cut.into())
            .saturating_div(10000);

        // NEAR payouts
        Promise::new(seller).transfer(price.saturating_sub(owner_cut));
        Promise::new(self.owner.clone()).transfer(owner_cut);

        //return the price payout out
        price
    }
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
    ) -> Promise;
}
'''
'''--- src/nft_callback.rs ---
use crate::{*, internal::hash_account_id};

/// approval callbacks from NFT Contracts

/*
    trait that will be used as the callback from the NFT contract. When nft_approve is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked. 
*/
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

//implementation of the trait
#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Marketplace {
    /// where we add the sale because we know nft owner can only call nft_approve

    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // get the contract ID which is the predecessor
        let nft_contract_id = env::predecessor_account_id();
        //get the signer which is the person who initiated the transaction
        let signer_id = env::signer_account_id();

        //make sure that the signer isn't the predecessor. This is so that we're sure
        //this was called via a cross-contract call
        assert_ne!(
            nft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        //make sure the owner ID is the signer. 
        assert_eq!(
            owner_id,
            signer_id,
            "owner_id should be signer_id"
        );

        //we need to enforce that the user has enough storage for 1 EXTRA sale.  

        //get the storage for a sale. dot 0 converts from U128 to u128
        // let storage_amount = self.storage_minimum_balance();
        let storage_amount = 0;
        //get the total storage paid by the owner
        let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
        //get the storage required which is simply the storage for the number of sales they have + 1 
        let signer_storage_required = (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;
        
        //make sure that the total paid is >= the required storage
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage, signer_storage_required / STORAGE_PER_SALE, STORAGE_PER_SALE
        );

        //create the unique sale ID which is the contract + DELIMITER + token ID
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        
        //insert the key value pair into the sales map. Key is the unique ID. value is the sale object
        self.listings.insert(
            &contract_and_token_id,
            &Listing {
                seller: owner_id.clone(), //owner of the sale / token
                approval_id, //approval ID for that token that was given to the market
                nft_contract_id: nft_contract_id.to_string(), //NFT contract the token was minted on
                token_id: token_id.clone(), //the actual token ID

                starting_price: 0,
                end_at: 0,
                started_at: 0,
                highest_bidder: None,
                highest_price: 0,
                is_auction: false
           },
        );

        //Extra functionality that populates collections necessary for the view calls 

        //get the sales by owner ID for the given owner. If there are none, we create a new empty set
        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    //we get a new unique prefix for the collection by hashing the owner
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        
        //insert the unique sale ID into the set
        by_owner_id.insert(&contract_and_token_id);
        //insert that set back into the collection for the owner
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        //get the token IDs for the given nft contract ID. If there are none, we create a new empty set
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByNFTContractIdInner {
                        //we get a new unique prefix for the collection by hashing the owner
                        account_id_hash: hash_account_id(&nft_contract_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        
        //insert the token ID into the set
        by_nft_contract_id.insert(&token_id);
        //insert the set back into the collection for the given nft contract ID
        self.by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);
    }
}
'''
'''--- src/sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Marketplace {
    /// views
    
    //returns the number of sales the marketplace has up (as a string)
    pub fn get_supply_sales(
        &self,
    ) -> U64 {
        //returns the sales object length wrapped as a U64
        U64(self.listings.len())
    }
    
    //returns the number of sales for a given account (result is a string)
    pub fn get_supply_by_owner_id(
        &self,
        account_id: AccountId,
    ) -> U64 {
        //get the set of sales for the given owner Id
        let by_owner_id = self.by_owner_id.get(&account_id);
        
        //if there as some set, we return the length but if there wasn't a set, we return 0
        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects for a given account. (result is a vector of sales)
    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Listing> {
        //get the set of token IDs for sale for the given account ID
        let by_owner_id = self.by_owner_id.get(&account_id);
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        
        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Sale objects
            .map(|token_id| self.listings.get(&token_id).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the number of sales for an nft contract. (returns a string)
    pub fn get_supply_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
    ) -> U64 {
        //get the set of tokens for associated with the given nft contract
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, return it's length. Otherwise return 0
        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Listing> {
        //get the set of token IDs for sale for the given contract ID
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };

        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Sale objects by passing in the unique sale ID (contract + DELIMITER + token ID)
            .map(|token_id| self.listings.get(&format!("{}{}{}", nft_contract_id, DELIMETER, token_id)).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Listing> {
        //try and get the sale object for the given unique sale ID. Will return an option since
        //we're not guaranteed that the unique sale ID passed in will be valid.
        self.listings.get(&nft_contract_token)
    }
}
'''
'''--- src/test.rs ---
use crate::*;
#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]

const MIN_REQUIRED_APPROVAL_YOCTO: u128 = 170000000000000000000;
const MIN_REQUIRED_STORAGE_YOCTO: u128 = 10000000000000000000000;

mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    // Allows for modifying the environment of the mocked blockchain
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    #[should_panic(expected = "Requires minimum deposit of 10000000000000000000000")]
    fn test_storage_deposit_insufficient_deposit() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));
    }

    #[test]
    fn test_storage_deposit() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));
        let outcome = contract.storage_deposits.get(&accounts(0));
        let expected = MIN_REQUIRED_STORAGE_YOCTO;
        assert_eq!(outcome, Some(expected));
    }

    #[test]
    fn test_storage_balance_of() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));
        let balance = contract.storage_balance_of(accounts(0));
        assert_eq!(balance, U128(MIN_REQUIRED_STORAGE_YOCTO));
    }

    #[test]
    fn test_storage_withdraw() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);

        // deposit amount
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));

        // withdraw amount
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(U128(1).0) // below func requires a min of 1 yocto attached
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_withdraw();

        let remaining_amount = contract.storage_balance_of(accounts(0));
        assert_eq!(remaining_amount, U128(0))
    }

    #[test]
    fn test_remove_sale() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);

        // deposit amount
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));

        // add sale
        let token_id = String::from("0n3C0ntr4ctT0Rul3Th3m4ll");
        let sale = Listing {
            seller: accounts(0).clone(), //owner of the sale / token
            approval_id: U64(1).0,       //approval ID for that token that was given to the market
            nft_contract_id: env::predecessor_account_id().to_string(), //NFT contract the token was minted on
            token_id: token_id.clone(),                                 //the actual token ID

            starting_price: 0,
            end_at: 0,
            started_at: 0,
            highest_bidder: None,
            highest_price: 0,
            is_auction: false,
        };
        let nft_contract_id = env::predecessor_account_id();
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        contract.listings.insert(&contract_and_token_id, &sale);
        let owner_token_set = UnorderedSet::new(contract_and_token_id.as_bytes());
        contract.by_owner_id.insert(&sale.seller, &owner_token_set);
        let nft_token_set = UnorderedSet::new(token_id.as_bytes());
        contract
            .by_nft_contract_id
            .insert(&sale.seller, &nft_token_set);
        assert_eq!(
            contract.listings.len(),
            1,
            "Failed to insert sale to contract"
        );

        // remove sale
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(U128(1).0) // below func requires a min of 1 yocto attached
            .predecessor_account_id(accounts(0))
            .build());
        contract.cancel_listing(nft_contract_id, token_id);
        assert_eq!(
            contract.listings.len(),
            0,
            "Failed to remove sale from contract"
        );
    }

    #[test]
    fn test_update_price() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Marketplace::new(10);

        // deposit amount
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.storage_deposit(Some(accounts(0)));

        // add sale
        let token_id = String::from("0n3C0ntr4ctT0Rul3Th3m4ll");
        let nft_bid_yocto = U128(100);
        let sale = Listing {
            seller: accounts(0).clone(), //owner of the sale / token
            approval_id: U64(1).0,       //approval ID for that token that was given to the market
            nft_contract_id: env::predecessor_account_id().to_string(), //NFT contract the token was minted on
            token_id: token_id.clone(),                                 //the actual token ID

            starting_price: 0,
            end_at: 0,
            started_at: 0,
            highest_bidder: None,
            highest_price: 0,
            is_auction: false,
        };
        let nft_contract_id = env::predecessor_account_id();
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        contract.listings.insert(&contract_and_token_id, &sale);
        let owner_token_set = UnorderedSet::new(contract_and_token_id.as_bytes());
        contract.by_owner_id.insert(&sale.seller, &owner_token_set);
        let nft_token_set = UnorderedSet::new(token_id.as_bytes());
        contract
            .by_nft_contract_id
            .insert(&sale.seller, &nft_token_set);
        assert_eq!(
            contract.listings.len(),
            1,
            "Failed to insert sale to contract"
        );

        // update price
        let new_price = U128(150);
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(U128(1).0)
            .predecessor_account_id(accounts(0)) // bob to buy NFT from alice
            .build());
        contract.set_price(nft_contract_id.clone(), token_id.clone(), new_price.into());

        // test update price success
        let sale = contract
            .listings
            .get(&contract_and_token_id)
            .expect("No sale");
        assert_eq!(sale.starting_price, new_price.into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(new_price.into())
            .predecessor_account_id(accounts(0))
            .build());
        contract.purchase_nft(nft_contract_id, token_id);
        
    }
}

'''