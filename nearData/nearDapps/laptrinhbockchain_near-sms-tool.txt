*GitHub Repository "laptrinhbockchain/near-sms-tool"*

'''--- README.md ---
near-sms-tool
==================

The small tool to send short messages between NEAR accounts.
<br />After being supported by the NEAR Foundation and LNC, the project changed its name to NEAR Messaging Service (NMS) and continued to develop with more features. Please see at new repo: https://github.com/Learn-NEAR-Club/nms

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies:
   <br />`npm install --global near-sdk-as`
   <br />`npm install --global near-cli`
   <br />`npm install`
3. Run the local development server: `npm run dev` (see `package.json` for a
   full list of `scripts` you can run with `npm`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

Exploring The Code
==================

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `npm
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `npm run dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `npm install`, but for best ergonomics you may want to install it globally:

    npm install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `sms-tool.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `sms-tool.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account sms-tool.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'sms-tool.YOUR-NAME.testnet'

Step 3: deploy!
---------------

One command:

    npm run deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- contract/README.md ---
sms-tool Smart Contract
==================

A [smart contract] written in [AssemblyScript] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install [Node.js] ≥ 12

Exploring The Code
==================

1. The main smart contract code lives in `assembly/index.ts`. You can compile
   it with the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard AssemblyScript tests using [as-pect].

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [AssemblyScript]: https://www.assemblyscript.org/
  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [as-pect]: https://www.npmjs.com/package/@as-pect/cli

'''
'''--- contract/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- contract/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- contract/assembly/__tests__/main.spec.ts ---
import { getSentMsgNum, getSentMessages, getInboxMsgNum, getInboxMessages, sendMessage, getStatics, getMessage } from '..'
import { logging, Context } from 'near-sdk-as'

describe('Send Message ', () => {
    it('should be set and read', () => {
        let now = Date.now().toString();
        let fromAccount = Context.sender;
        let toAccount = "a.testnet";
        // let toAccount = Context.sender;
        sendMessage(toAccount, "Testing", 'QmcT7Jwz5Ckt7dfnMdcNsvRiYEf3H5xn8No5JkqoKPP3uy', "https://nms.kiemtienonline360.com", 0, 0);
        logging.log(`sentMsgNum of ${fromAccount}: ${getSentMsgNum(fromAccount)}`);
        logging.log(`inboxMsgNum of ${toAccount}: ${getInboxMsgNum(toAccount)}`);
        getSentMessages(fromAccount, 0, 0);
        getInboxMessages(toAccount, 0, 0);
        getMessage(0);
        getStatics();
    })
})

'''
'''--- contract/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- contract/assembly/index.ts ---
import { Context, PersistentVector, ContractPromiseBatch, env, u128, logging } from 'near-sdk-as'
import { Message, StaticsInfo, messages, staticsInfos, sentInfos, inboxInfos } from './model';

const STATICS_KEY = "statics";
const NEAR_SEND_MIN = u128.from("10000000000000000000000");

// Get StaticsInfo, auto created if not existed in the Map
function getStaticsInfo(): StaticsInfo {
    let staticsInfo = staticsInfos.get(STATICS_KEY, null);
    if (staticsInfo==null) {
        staticsInfo = new StaticsInfo();
    }
    return staticsInfo;
}

/**
 * Get number of sent messages corresponding to account id.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 * @param accountId Account id
 * @returns Number of sent messages
 */
export function getSentMsgNum(accountId: string): i32 {
    let items = sentInfos.get(accountId, null);
    return (items ? items.length : 0);
}

/**
 * Returns an array of sent messages corresponding to account id.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 * @param accountId Account id
 * @param fromIndex The starting position to get data
 * @param toIndex The ending position to get data
 * @returns Array of sent messages
 */
export function getSentMessages(accountId: string, fromIndex: i32, toIndex: i32): Message[] {
    // Checking fromIndex anđ toIndex
    let sentMsgIndexes = sentInfos.get(accountId, null);
    let numMsg = (sentMsgIndexes?sentMsgIndexes.length:0);
    if (fromIndex>numMsg) fromIndex = numMsg-1;
    if (fromIndex<0) fromIndex = 0;
    if (toIndex>numMsg) toIndex = numMsg-1;
    if (toIndex<0) toIndex = 0;
    if (toIndex<fromIndex) toIndex = fromIndex;

    // Get sent messages
    let itemNum = 0;
    if (numMsg>0) itemNum = toIndex - fromIndex + 1;
    let results = new Array<Message>(itemNum);
    if (numMsg>0 && sentMsgIndexes!=null) {
        let now = env.block_timestamp();
        for (let idx=fromIndex; idx<=toIndex; idx++) {
            let item = messages[sentMsgIndexes[idx]];
            if (item.expiredTime>0 && item.expiredTime<now) {
                // Message exprired
                item = new Message(item.id, item.from, item.to, item.title, "#EXPIRED", item.baseSite, item.prevMsgId, item.expiredTime);
            }
            results[idx-fromIndex] = item;
        }
    }
    return results;
}

/**
 * Get number of inbox messages corresponding to account id.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 * @param accountId Account id
 * @returns Number of inbox messages
 */
export function getInboxMsgNum(accountId: string): i32 {
    let items = inboxInfos.get(accountId, null);
    return (items ? items.length : 0);
}

/**
 * Returns an array of inbox messages corresponding to account id.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 * @param accountId Account id
 * @param fromIndex The starting position to get data
 * @param toIndex The ending position to get data
 * @returns Array of inbox messages
 */
export function getInboxMessages(accountId: string, fromIndex: i32, toIndex: i32): Message[] {
    // Checking fromIndex anđ toIndex
    let inboxMsgIndexes = inboxInfos.get(accountId, null);
    let numMsg = (inboxMsgIndexes?inboxMsgIndexes.length:0);
    if (fromIndex>numMsg) fromIndex = numMsg-1;
    if (fromIndex<0) fromIndex = 0;
    if (toIndex>numMsg) toIndex = numMsg-1;
    if (toIndex<0) toIndex = 0;
    if (toIndex<fromIndex) toIndex = fromIndex;

    // Get inbox messages
    let itemNum = 0;
    if (numMsg>0) itemNum = toIndex - fromIndex + 1;
    let results = new Array<Message>(itemNum);
    if (numMsg>0 && inboxMsgIndexes!=null) {
        let now = env.block_timestamp();
        for (let idx=fromIndex; idx<=toIndex; idx++) {
            let item = messages[inboxMsgIndexes[idx]];
            if (item.expiredTime>0 && item.expiredTime<now) {
                // Message exprired
                item = new Message(item.id, item.from, item.to, item.title, "#EXPIRED", item.baseSite, item.prevMsgId, item.expiredTime);
            }
            results[idx-fromIndex] = item;
        }
    }
    return results;
}

/**
 * Get message from index
 * @param index Index of message 
 * @returns Return a message or null
 */
 export function getMessage(msgId: i32): Message | null {
    // Checking msgIndex
    let index = msgId - 1;
    if (index<0 || index>=messages.length) {
        // Invalid input
        return null
    };

    // Return message
    return messages[index];
}

/**
 * Sends new message to other account.
 * NOTE: This is a change method. Which means it will modify the state.
 * @param to The account id that will receive the message
 * @param title Title of message
 * @param content Content of message
 */
export function sendMessage(to: string, title: string, data: string, baseSite: string, prevMsgId: i32, expiredTime: u64): boolean {
    // Checking input
    if (!env.isValidAccountID(to)) {
        logging.log("To account is invalid!");
        return false;
    }
    let attachedDeposit = Context.attachedDeposit;
    if (u128.lt(attachedDeposit, NEAR_SEND_MIN)) {
        logging.log("Attached deposit is too small!");
        return false;
    }

    // Get static info
    let staticsInfo = getStaticsInfo();

    // Store new message into blockchain
    let accountId = Context.sender;
    let msgId = messages.length + 1;
    let msg = new Message(msgId, accountId, to, title, data, baseSite, prevMsgId, expiredTime);
    let index = messages.push(msg);
    staticsInfo.messageNum = messages.length;

    // Store the index of new message for sender account
    let items1 = sentInfos.get(accountId, null);
    if (items1) {
        items1.push(index);
    } else {
        items1 = new PersistentVector<i32>("psentinfos-" + accountId);
        items1.push(index);
        staticsInfo.sentAccountNum++;
        if (inboxInfos.get(accountId, null)==null) staticsInfo.accountNum++;
    }
    sentInfos.set(accountId, items1);

    // Store the index of new message for receive account
    let items2 = inboxInfos.get(to, null);
    if (items2) {
        items2.push(index);
    } else {
        items2 = new PersistentVector<i32>("pinboxinfos-" + to);
        items2.push(index);
        staticsInfo.inboxAccountNum++;
        if (sentInfos.get(to, null)==null) staticsInfo.accountNum++;
    }
    inboxInfos.set(to, items2);

    // Store StaticInfo
    staticsInfos.set(STATICS_KEY, staticsInfo);

    // Send NEAR to receiver
    if (!attachedDeposit.isZero()) {
        let userAmount = attachedDeposit*staticsInfo.userRate/u128.from(1000);
        ContractPromiseBatch.create(to).transfer(userAmount);
        let feeAmount = attachedDeposit - userAmount;
        ContractPromiseBatch.create(staticsInfo.feeAddress).transfer(feeAmount);
    }

    return true;
}

export function getStatics(): StaticsInfo | null {
    return staticsInfos.get(STATICS_KEY, null);
}

'''
'''--- contract/assembly/model.ts ---
import { env, u128, PersistentVector, PersistentMap } from "near-sdk-as";

const DEFAULT_USER_RATE =  u128.from("850");         // 850:150
const DEFAULT_FEE_ADDRESS = "learnnear-nms-sputnikdao.testnet";

/**
 * A data structure that stores the information of a message
 */
@nearBindgen
export class Message {
    id: i32;                                // Must be greater than 0
    from: string;
    to: string;
    title: string;
    data: string;
    baseSite: string;
    prevMsgId: i32;                         // 0: No previous message
    timestamp: u64;
    expiredTime: u64;

    constructor(_id: i32, _from: string, _to: string, _title: string, _data: string, _baseSite: string, _prevMsgId: i32, _expiredTime: u64) {
        this.id = _id;
        this.from = _from;
        this.to = _to;
        this.title = _title;
        this.data = _data;
        this.baseSite = _baseSite;
        this.timestamp = env.block_timestamp();
        this.prevMsgId = _prevMsgId;
        this.expiredTime = _expiredTime;
    }
}

/**
 * A data structure that stores statics information
 */
@nearBindgen
export class StaticsInfo {
    messageNum: i32;
    sentAccountNum: i32;
    inboxAccountNum: i32;
    accountNum: i32;
    feeAddress: string;
    userRate: u128;

    constructor() {
        this.messageNum = 0;
        this.sentAccountNum = 0;
        this.inboxAccountNum = 0;
        this.accountNum = 0;
        this.feeAddress = DEFAULT_FEE_ADDRESS;
        this.userRate = DEFAULT_USER_RATE;
    }
}

// An array that stores messages on the blockchain
export const messages = new PersistentVector<Message>("psms");

// Stores static information
export const staticsInfos = new PersistentMap<string, StaticsInfo>("pstatics");

// Store list of message indexes for each sender's account.\
// Note: This avoids using a for loop to search for data, and also reduces duplication of message data
export const sentInfos = new PersistentMap<string, PersistentVector<i32>>("psent");

// Store list of message indexes for each sender's account.\
// Note: This avoids using a for loop to search for data, and also reduces duplication of message data
export const inboxInfos = new PersistentMap<string, PersistentVector<i32>>("pinbox");
'''
'''--- contract/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./build/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/package.json ---
{
  "name": "sms-tool",
  "version": "0.0.1",
  "license": "UNLICENSED",
  "private": true,
  "scripts": {
    "build": "asb",
    "build:debug": "asb --target debug",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "3.1.0"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''
'''--- package.json ---
{
  "name": "near-messaging-service",
  "version": "0.0.1",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch contract -e ts --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && npm run test && cd .. && jest test --runInBand"
  },
  "devDependencies": {
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "^27.2.0",
    "jest-environment-node": "~26.6.2",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "shelljs": "^0.8.4"
  },
  "dependencies": {
    "aes256": "^1.1.0",
    "ipfs-http-client": "^53.0.1",
    "near-api-js": "^0.42.0",
    "near-cli": "^2.0.0",
    "near-sdk-as": "^3.2.3",
    "regenerator-runtime": "~0.13.5"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'nearsms3.near-demo.testnet';
// const CONTRACT_NAME = process.env.CONTRACT_NAME;

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 25em;
}

.header {
  background-color: #00FF53;
  padding: 5px;
  border-bottom: solid 1px #cccccc;
  color: black;
}

.footer {
  background-color: blanchedalmond(248, 225, 194);
  padding: 5px;
  border-top: solid 1px #cccccc;
  color: black;
}

.main-body {
  color: black;
}

.sms-link {
  color: black;
  text-decoration: underline;
}

h1 {
  background-image: url(assets/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 2.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  /* background-color: var(--shadow); */
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

textarea {
  /* background-color: var(--shadow); */
  font-size: 18px;
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
textarea::selection {
  background-color: var(--secondary);
  color: #efefef;
}
textarea:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(assets/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

.msgItem0 {
    background-color: beige;
    padding: 5px;
    border: 1px solid #ccc;
    word-wrap: break-word;
}

.msgItem1 {
    background-color: azure;
    padding: 5px;
    border: 1px solid #ccc;
    word-wrap: break-word;
}

.seperatorInMessage {
  background-color:#cccccc;
  width:100%;
  height:1px;
  margin-top:5px;
  margin-bottom:5px
}

.originMessage {
    padding: 10px;
    margin-left: 10px;
    font-size: smaller;
}

.div-column1 {
  float: left;
  width: 230px;
  height: 100%;
}

.div-column2 {
  float: left;
  width: 800px;
  height: 100%;
}

/* Clear floats after the columns */
.div-row:after {
  content: "";
  display: table;
  clear: both;
}
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="./assets/favicon.ico" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>NEAR Messaging Service</title>
    <link rel="stylesheet" href="global.css">
</head>

<body style="align-items: center;">
    <main id="signed-out-flow" style="display: none">
        <h1>Welcome to NEAR Messaging Service on NEAR!</h1>
        <p>
            To make use NEAR Messaging Service on NEAR blockchain, you need to sign in. The button
            below will sign you in using NEAR Wallet.
        </p>
        <p>
            By default, when your app runs in "development" mode, it connects
            to a test network ("testnet") wallet. This works just like the main
            network ("mainnet") wallet, but the NEAR Tokens on testnet aren't
            convertible to other currencies – they're just for testing!
        </p>
        <p>
            Go ahead and click the button below to try it out:
        </p>
        <p style="text-align: center; margin-top: 2.5em">
            <button id="sign-in-button">Sign in</button>
        </p>
    </main>

    <div id="signed-in-flow" style="display: none; border: 1px solid #cccccc;background-color: rgb(239,239,239);">
        <div class="header">
            <span><strong>NEAR Messaging Service</strong></span>
            <button class="link" style="float: right; padding: 0px; color: black;" id="sign-out-button">
                <u>Sign out</u>
            </button>
            <span style="float: right; padding-right: 10px;">
                <label for="smsapp" data-behavior="smsapp"
                    style="color: var(--secondary); border-bottom: 2px solid var(--secondary);">
                </label>
                <span data-behavior="account-id" style="font-weight: bold;"></span>!
            </span>
            <span style="float: right; padding-right: 5px;">
                <img id="userAvatar" src="./assets/default_user_avatar.png" width="30px" style="border-radius: 50%;" alt="User avatar" />
            </span>
        </div>
        <div class="main-body">
            <div class="div-row">
                <div class="div-column1" style="background-color: aqua;">
                    <div style="text-align: center; padding: 5px;">
                        <button style="padding: 0px; color: black; background-color: rgb(53, 205, 211); padding: 5px; width: 100%;" id="sign-out-button" onclick="onClickMenuItem('compose');">
                            Compose
                        </button>
                    </div>
                    <div style="border: #cccccc solid 1px; margin: 5px;">
                        <div style="padding: 5px; background-color: rgb(224, 224, 244); cursor: pointer;" onclick="onClickMenuItem('inbox');">
                            Inbox
                        </div>
                        <div style="width: 100%; height: 1px;"></div>
                        <div style="padding: 5px; background-color: rgb(224, 224, 244); cursor: pointer;" onclick="onClickMenuItem('sent');">
                            Sent
                        </div>
                    </div>
                </div>
                <div class="div-column2">
                    <div id="bodyHeader" style="border-bottom: #cccccc solid 1px; padding: 5px;">
                        <span id="bodyTitle" style="font-weight: bold;">Inbox</span> <span id="bodyTitleInfo"></span>
                        <span id="pagingInfo" style="float: right; margin-right: 10px;;"></span>
                    </div>
                    <div id="bodyMain">
                        <div id="inboxMessages" style="margin: 5px; padding-left: 10px;"></div>
                        <div id="sentMessages" style="display: none; margin: 5px; padding-left: 10px;"></div>
                        <div id="newMsgBoard" style="display: none; margin: 5px; padding-left: 10px;">
                            <form>
                                <input type="hidden" id="originMsgId" data-behavior="originMsgId" value="-1" />
                                <div>
                                    <label for="toAccount" style="display: block; color: var(--gray); margin-bottom: 0.5em">
                                        To Account
                                    </label>
                                    <div style="display: flex">
                                        <input style="flex: 1" autocomplete="off" id="toAccount" data-behavior="toAccount" maxlength="50" />
                                    </div>
                                </div>
                                <div>
                                    <label for="title" style="display: block; color: var(--gray); margin-bottom: 0.5em">
                                        Title
                                    </label>
                                    <div style="display: flex">
                                        <input style="flex: 1" autocomplete="off" id="title" data-behavior="title" maxlength="100" />
                                    </div>
                                </div>
                                <div>
                                    <label for="content" style="display: block; color: var(--gray); margin-bottom: 0.5em">
                                        Content
                                    </label>
                                    <div style="display: flex">
                                        <textarea style="flex: 1" autocomplete="off" id="content" data-behavior="content" rows="6" maxlength="1024"></textarea>
                                    </div>
                                </div>
                                <div id="originMessage" style="display: hidden; margin-top: 10px; font-size: small; margin-left: 15px; padding: 5px; background-color: white;">
                                    <b>Origin Message:</b>
                                    <div id="originMessageContent" style="max-height: 200px; padding: 15px; overflow: scroll;">
                                    </div>
                                </div>
                                <div>
                                    <label style="display: block; color: var(--gray); margin-bottom: 0.5em">
                                        Select NEAR to send:
                                    </label>
                                    <div style="display: flex; padding-left: 10px;">
                                        <input type="radio" style="height: 25px;" name="attachedNear" value="10000000000000000000000" checked /> <label>0.01 NEAR</label> &nbsp;&nbsp;&nbsp;
                                        <input type="radio" style="height: 25px;" name="attachedNear" value="20000000000000000000000"> <label>0.02 NEAR</label> &nbsp;&nbsp;&nbsp;
                                        <input type="radio" style="height: 25px;" name="attachedNear" value="100000000000000000000000"> <label>0.1 NEAR</label>
                                    </div>
                                </div>
                                <div style="padding-top: 10px;">
                                    <button disabled style="border-radius: 5px 5px 5px 5px" data-behavior="sendmessage">Send
                                        Message</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer" style="font-size: small;">
            <span id="staticsInfo">&nbsp;</span>
            
            <span id="sourcecode-github" style="float: right; margin-right: 20px;"><a class="sms-link" href="https://github.com/Learn-NEAR-Club/nms" target="_blank">Source Code</a></span>
            <span id="list-join-lnc" style="float: right; margin-right: 20px;"><a class="sms-link" href="https://kiemtienonline360.com/go/learner-near" target="_blank">Join LNC</a></span>
            <span id="list-join-lnc" style="float: right; margin-right: 20px;"><a class="sms-link" href="https://nms-v1.kiemtienonline360.com" target="_blank">NMS V1.0</a></span>
        </div>
    </div>

    <aside data-behavior="notification" style="display: none">
        <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
        called method: 'sendMessage' in contract:
        <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
        <footer>
            <div>✔ Succeeded</div>
            <div>Just now</div>
        </footer>
    </aside>
    <aside data-behavior="notification-error" style="display: none">
        <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
        called method: 'sendMessage' in contract:
        <a target="_blank" href="https://explorer.testnet.near.org/accounts/"></a>
        <footer>
            <div>❌ Error. The transaction may be expired. Please re-send the message!</div>
            <div>&nbsp;</div>
        </footer>
    </aside>

    <script src="./index.js"></script>
</body>

</html>
'''
'''--- src/index.js ---
import 'regenerator-runtime/runtime'

import { initContract, login, logout, isAccountExist, getTransaction, getAvatar } from './utils';
import message from './message';
import getConfig from './config';
// const { networkId } = getConfig(process.env.NODE_ENV || 'development');
const { networkId } = getConfig('development');

let APP_FEE = "1000000000000000000000";
const ONE_YOCTO_NEAR = 1;
const BOATLOAD_OF_GAS = (60*10**12).toFixed();

const submitButton = document.querySelector('form button');
let appInfo = {
    currentMenu: "INBOX",
    itemPerPage: 5,
    inbox: {
        currentPage: 1,
        messages: [],
        msgNum: 0
    },
    sent: {
        currentPage: 1,
        messages: [],
        msgNum: 0
    }
};

window.addEventListener('resize', function(e) {
    updateWidthForDivColumn2();
});
window.onPageChange = function(type, page) {
    if (type=="inbox") {
        appInfo.inbox.currentPage = page;
        updateInboxUI();
    } else if (type=="sent") {
        appInfo.sent.currentPage = page;
        updateSentUI();
    }
}
window.onClickMenuItem = function(type) {
    if (type=="inbox") {
        appInfo.currentMenu = "INBOX";
        updateInboxUI();
    } else if (type=="sent") {
        appInfo.currentMenu = "SENT";
        updateSentUI();
    } else if (type=="compose") {
        appInfo.currentMenu = "COMPOSE";
        updateComposeUI();
    }
}
window.replyMessage = function(type, msgIndex) {
    updateComposeUI("reply", type, msgIndex);
}
window.forwardMessage = function(type, msgIndex) {
    updateComposeUI("forward", type, msgIndex);
}

let initTransHash = findGetParameter("transactionHashes");

document.querySelector('form').onsubmit = async (event) => {
    event.preventDefault()

    // get elements from the form using their id attribute
    const { toAccount, title, content } = event.target.elements
    let attachedNear = document.querySelector('input[name="attachedNear"]:checked').value;

    // Check input
    if (title.value==null || title.value.length<=0) {
        alert("Please enter the field 'Title'!");
        return;
    }
    if (content.value==null || content.value.length<=0) {
        alert("Please enter the field 'Content'!");
        return;
    }
    if (toAccount.value==null || toAccount.value.length<=0) {
        alert("Please enter the field 'To Account'!");
        return;
    }
    if (window.accountId==toAccount.value) {
        alert("Don't allow sender to yourself!");
        return;
    }
    if (!await isAccountExist(toAccount.value)) {
        alert(`The account '${toAccount.value}' is not existed. Please enter the other account!`);
        return;
    }
    let originMsgId = Number(document.querySelector('input#originMsgId').value);
    if (originMsgId==null) originMsgId = 0;

    // disable the save button, since it now matches the persisted value
    submitButton.disabled = true

    let ret = false;
    try {
        // Send message
        ret = await sendMessage(toAccount.value, title.value, content.value, attachedNear, originMsgId);
    } catch(ex) {
        console.log("ERROR", ex);
    }

    await showNotificationByResult(ret);
}

// Listen for user input events
document.querySelector('input#toAccount').oninput = (event) => { checkSubmitButton(); }
document.querySelector('input#title').oninput = (event) => { checkSubmitButton(); }
document.querySelector('textarea#content').oninput = (event) => { checkSubmitButton(); }

// Handle user action events
document.querySelector('#sign-in-button').onclick = login;
document.querySelector('#sign-out-button').onclick = logout;

// Check user input to enable/disable submit button
function checkSubmitButton() {
    let value1 = document.querySelector('input#toAccount').value;
    let value2 = document.querySelector('input#title').value;
    let value3 = document.querySelector('textarea#content').value;

    if (value1 && value2 && value3) {
        submitButton.disabled = false;
    } else {
        submitButton.disabled = true;
    }
}

function standardHtmlData(text) {
    text = text.replace(/<script[^>]*>(?:(?!<\/script>)[^])*<\/script>/gi, "");
    text = text.replace(/<iframe[^>]*>(?:(?!<\/iframe>)[^])*<\/iframe>/gi, "");
    text = text.replace(/\n/g, "<br />");
    return text;
}

// Reset "new message" box
function resetNewMsgBox() {
    document.querySelector('input#toAccount').value = "";
    document.querySelector('input#title').value = "";
    document.querySelector('textarea#content').value = "";
    submitButton.disabled = false;
}

function updateWidthForDivColumn2() {
    let obj = document.querySelector('.div-column2');
    let width = document.getElementById("signed-in-flow").clientWidth;
    obj.style.width = (width - 230 - 20) + "px";
}

function findGetParameter(parameterName) {
    var result = null,
        tmp = [];
    location.search
        .substr(1)
        .split("&")
        .forEach(function (item) {
          tmp = item.split("=");
          if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
        });
    return result;
}

async function showNotificationByTransHash(transHash) {
    let result = await getTransaction(transHash);
    let ret = false;
    if (result && result.status && result.status.SuccessValue) {
        let returnValue = (new Buffer.from(result.status.SuccessValue, "base64")).toString();
        if (returnValue=="true" || returnValue=="TRUE") {
            ret = true;
        }
    }
    await showNotificationByResult(ret);
}

async function showNotificationByResult(isSuccess) {
    if (isSuccess) {
        // Reset message box if sucess
        resetNewMsgBox();
                
        // Show sucess notification
        document.querySelector('[data-behavior=notification]').style.display = 'block';

        // Remove notification again after css animation completes
        setTimeout(() => {
            document.querySelector('[data-behavior=notification]').style.display = 'none';
        }, 11000);

        // Update the messages in the UI
        await updateAppUI();
    } else {
        submitButton.disabled = false;
        
        // Show error notification
        document.querySelector('[data-behavior=notification-error]').style.display = 'block';
        
        // Remove notification again after css animation completes
        setTimeout(() => {
            document.querySelector('[data-behavior=notification-error]').style.display = 'none';
        }, 11000);
    }
}

// Display the signed-out-flow container
function signedOutFlow() {
    document.querySelector('#signed-out-flow').style.display = 'block';
}

// Displaying the signed in flow container and fill in account-specific data
function signedInFlow() {
    document.querySelector('#signed-in-flow').style.display = 'block';
    updateWidthForDivColumn2();

    document.querySelectorAll('[data-behavior=account-id]').forEach(el => {
        el.innerText = window.accountId
    })

    // populate links in the notification box
    let accountLink = document.querySelector('[data-behavior=notification] a:nth-of-type(1)')
    accountLink.href = accountLink.href + window.accountId
    accountLink.innerText = '@' + window.accountId
    let contractLink = document.querySelector('[data-behavior=notification] a:nth-of-type(2)')
    contractLink.href = contractLink.href + window.contract.contractId
    contractLink.innerText = '@' + window.contract.contractId

    // populate links in the error notification box
    accountLink = document.querySelector('[data-behavior=notification-error] a:nth-of-type(1)')
    accountLink.href = accountLink.href + window.accountId
    accountLink.innerText = '@' + window.accountId
    contractLink = document.querySelector('[data-behavior=notification-error] a:nth-of-type(2)')
    contractLink.href = contractLink.href + window.contract.contractId
    contractLink.innerText = '@' + window.contract.contractId;

    // Update avatar
    getAvatar(window.accountId, function(imageData) {
        window.accountAvatar = imageData;
        if (imageData) {
            document.querySelector('#userAvatar').src = imageData;
            
        }
    });

    // update with selected networkId
    accountLink.href = accountLink.href.replace('testnet', networkId)
    contractLink.href = contractLink.href.replace('testnet', networkId);

    updateAppUI();

    if (initTransHash) {
        showNotificationByTransHash(initTransHash).then(function() {
            initTransHash = null;
        });
    }
}

function getSiteLink() {
    let link = window.location.href;
    return link.toString().replace(/^(.*\/\/[^\/?#]*).*$/,"$1");
}

// Send new message
async function sendMessage(toAccount, title, content, attachedNear, originMsgId=0, expiredTime=0) {
    let ret = false;
    try {
        let msg = {
            title: title,
            content: content,
            attachmentFiles: {
            }
        };
        let resp = await message.packMessage(msg);
        let strExpiredTime = "" + expiredTime;
        if (resp.code==0) {
            if (attachedNear) {
                ret = await contract.sendMessage({
                    to: toAccount,
                    title: resp.title,
                    data: resp.data,
                    baseSite: getSiteLink(),
                    prevMsgId: originMsgId,
                    expiredTime: strExpiredTime
                }, BOATLOAD_OF_GAS, attachedNear);
            } else {
                ret = await contract.sendMessage({
                    to: toAccount,
                    title: resp.title,
                    data: resp.data,
                    baseSite: getSiteLink(),
                    prevMsgId: originMsgId,
                    expiredTime: strExpiredTime
                });
            }
        } else {
            console.error("Error when packing messsage", resp);
        }
    } catch(ex) {
        console.error("Error to send message", ex);
    }
    
    return ret;
}

function getIndexInfo(messageNum, currentPage, itemPerPage) {
    let ret = {
        fromIndex: 0,
        toIndex: -1
    };
    if (messageNum>0) {
        // Page 1 corresponding the lastest messages
        ret.toIndex = messageNum - 1 - (currentPage-1)*itemPerPage;
        ret.fromIndex = ret.toIndex - itemPerPage + 1;
        if (ret.fromIndex<0) ret.fromIndex = 0;
    }
    return ret;
}

async function updateAppUI() {
    if (appInfo.currentMenu=="INBOX") {
        // Update UI for Inbox
        await updateInboxUI();
    } else if (appInfo.currentMenu=="SENT") {
        // Update UI for Sent
        await updateSentUI();
    } else if (appInfo.currentMenu=="COMPOSE") {
        await updateComposeUI();
    }
}

async function updateDataMessage(msg, isLoadPreItem=false) {
    let msgInfo = await message.depackMessage({ title: msg.title, data: msg.data });
    if (msgInfo && msgInfo.code==0) {
        msg.msgData = {
            title: msgInfo.title,
            content: msgInfo.content,
            attachmentFiles: msgInfo.attachmentFiles
        };

        if (msg.prevMsgId>0 && isLoadPreItem) {
            let prevItem = await contract.getMessage({
                msgId: msg.prevMsgId
            });
            if (prevItem!=null) {
                await updateDataMessage(prevItem, false);
                msg.prevMsgItem = prevItem;
            }
        }
        console.log(msg);
    } else {
        msg.msgData = {
            title: "Unable to get message",
            content: "",
            attachmentFiles: {}
        };
    }
}

async function updateDataMessages(messages) {
    // Get data of the messages
    let promises = [];
    for (let idx=0; idx<messages.length; idx++) {
        promises.push(updateDataMessage(messages[idx], true));
    }
    await Promise.all(promises);
}

async function updateInboxUI() {
    // Show inbox block and hide others
    document.querySelector('#inboxMessages').style.display = 'block';
    document.querySelector('#sentMessages').style.display = 'none';
    document.querySelector('#newMsgBoard').style.display = 'none';
    
    // Update title
    document.querySelector('#bodyTitle').innerText = "Inbox";
    document.querySelector('#bodyTitleInfo').innerText = "";
    document.querySelector('#pagingInfo').innerHTML = "";

    // Fetch inbox messages and show messages to UI
    let inboxMsgNum = await contract.getInboxMsgNum({
        accountId: window.accountId
    });
    let inboxMessages = [];
    let indexInfo = getIndexInfo(inboxMsgNum, appInfo.inbox.currentPage, appInfo.itemPerPage);
    if (indexInfo.toIndex>=indexInfo.fromIndex) {
        inboxMessages = await contract.getInboxMessages({
            accountId: window.accountId,
            fromIndex: indexInfo.fromIndex,
            toIndex: indexInfo.toIndex
        });
    }
    console.log("inboxMessages", inboxMessages);
    await updateDataMessages(inboxMessages);
    console.log("inboxMessages 1", inboxMessages);
    
    console.log("Inbox:", inboxMsgNum, inboxMessages);
    appInfo.inbox.messages = inboxMessages;
    appInfo.inbox.msgNum = inboxMsgNum;
    showInboxMessages(inboxMsgNum, inboxMessages);
    await updateStaticInfoUI();
}

async function updateSentUI() {
    // Show sent block and hide others
    document.querySelector('#inboxMessages').style.display = 'none';
    document.querySelector('#sentMessages').style.display = 'block';
    document.querySelector('#newMsgBoard').style.display = 'none';
    
    // Update title
    document.querySelector('#bodyTitle').innerText = "Sent";
    document.querySelector('#bodyTitleInfo').innerText = "";
    document.querySelector('#pagingInfo').innerHTML = "";

    // Fetch sent messages and show messages to UI
    let sentMsgNum = await contract.getSentMsgNum({
        accountId: window.accountId
    });
    let sentMessages = [];
    let indexInfo = getIndexInfo(sentMsgNum, appInfo.sent.currentPage, appInfo.itemPerPage);
    if (indexInfo.toIndex>=indexInfo.fromIndex) {
        sentMessages = await contract.getSentMessages({
            accountId: window.accountId,
            fromIndex: indexInfo.fromIndex,
            toIndex: indexInfo.toIndex
        });
    }
    console.log("sentMessages", indexInfo, sentMessages);
    await updateDataMessages(sentMessages);
    
    // console.log("Sent:", sentMsgNum, sentMessages);
    appInfo.sent.messages = sentMessages;
    appInfo.sent.msgNum = sentMsgNum;
    showSentMessages(sentMsgNum, sentMessages);
    await updateStaticInfoUI();
}

// Sort messages so that recent messages show first
function sortMessages(messages) {
    if (!messages) return;

    messages.sort(function(item1, item2) {
        return item2.timestamp - item1.timestamp;
    });
}

function getPageLinkStr(type, msgNum) {
    let page = "Page: ";
    let currentPage = appInfo[type].currentPage;
    let pageNum = 0;
    if (msgNum>0) {
        pageNum = Math.trunc((msgNum - 1)/appInfo.itemPerPage) + 1;
    }
    if (pageNum<=0) return "";

    for (let idx=1; idx<=pageNum; idx++) {
        if (idx==currentPage) {
            page += `${idx} `;
        } else {
            page += `<a href="#" class="sms-link" onclick="onPageChange('${type}', ${idx});">${idx}</a> `
        }
    }

    return page;
}

function messageItemToHtml(type, msg) {
    let itemHtml = "";
    if (type=="inbox") {
        itemHtml += `<b>From:</b> ${msg.from}`;
    } else if (type=="sent") {
        itemHtml += `<b>To:</b> ${msg.to}`;
    } else {
        itemHtml += `<b>From:</b> ${msg.from}`;
        itemHtml += `<br /><b>To:</b> ${msg.to}`;
    }
    itemHtml += `<br /><b>Time:</b> ${(new Date(msg.timestamp/10**6)).toLocaleString()}`;
    itemHtml += `<br /><b>Title:</b> ${msg.msgData.title}`;
    itemHtml += `<br /><b>Content:</b>`;
    itemHtml += `<div style="padding:5px">${standardHtmlData(msg.msgData.content)}</div>`;
    return itemHtml;
}

// Show sent messages on UI
function showSentMessages(sentMsgNum, sentMessages) {
    // Show number of items
    let fromPosition = (appInfo.sent.currentPage-1)*appInfo.itemPerPage + 1;
    let toPosition = fromPosition + sentMessages.length - 1;
    if (fromPosition<=toPosition) {
        document.querySelector('#bodyTitleInfo').innerText = `(${fromPosition}-${toPosition}/${sentMsgNum})`;
    } else {
        document.querySelector('#bodyTitleInfo').innerText = "";
    }

    // Show sent items
    let html = "";
    sortMessages(sentMessages);
    for (let idx=0; idx<sentMessages.length; idx++) {
        let msg = sentMessages[idx];
        let itemHtml = `<div id="sentMsg-${idx}" class="msgItem${idx%2}">`;
        itemHtml += messageItemToHtml('sent', msg);
        if (msg.prevMsgItem) {
            itemHtml += `<div class="seperatorInMessage"></div>`;
            itemHtml += "<div class='originMessage'>" + messageItemToHtml('all', msg.prevMsgItem) + "</div>";
        }
        if (msg.id>0) {
            itemHtml += `<div class="seperatorInMessage"></div>`;
            itemHtml += `<a href="#" onclick="replyMessage('sent', ${idx})" style="font-weight:bold;color:navy">Reply</a> &nbsp; <a href="#" onclick="forwardMessage('sent', ${idx})" style="font-weight:bold;color:navy">Forward</a>`;
        }
        itemHtml += "</div>";
        html += itemHtml;
    }
    if (sentMessages.length>0) {
        document.querySelector('#sentMessages').innerHTML = html;
    } else {
        document.querySelector('#sentMessages').innerHTML = "You haven't sent any message.<br />Do you want to send a message to someone? Please click <a href='#' onclick='onClickMenuItem(\"compose\");'>here</a> to start!!!";   
    }

    // Show page
    document.querySelector('#pagingInfo').innerHTML = getPageLinkStr("sent", sentMsgNum);
}

// Show inbox messages to UI
function showInboxMessages(inboxMsgNum, inboxMessages) {
    // Show number of items
    let fromPosition = (appInfo.inbox.currentPage-1)*appInfo.itemPerPage + 1;
    let toPosition = fromPosition + inboxMessages.length - 1;
    if (toPosition>=fromPosition) {
        document.querySelector('#bodyTitleInfo').innerText = `(${fromPosition}-${toPosition}/${inboxMsgNum})`;
    } else {
        document.querySelector('#bodyTitleInfo').innerText = "";
    }

    // Show inbox items
    let html = "";
    sortMessages(inboxMessages);
    for (let idx=0; idx<inboxMessages.length; idx++) {
        let msg = inboxMessages[idx];
        let itemHtml = `<div id="inboxMsg-${idx}" class="msgItem${idx%2}">`;
        itemHtml += messageItemToHtml('inbox', msg);
        if (msg.prevMsgItem) {
            itemHtml += `<div class="seperatorInMessage"></div>`;
            itemHtml += "<div class='originMessage'>" + messageItemToHtml('all', msg.prevMsgItem) + "</div>";
        }
        if (msg.id>0) {
            itemHtml += `<div class="seperatorInMessage"></div>`;
            itemHtml += `<a href="#" onclick="replyMessage('inbox', ${idx})" style="font-weight:bold;color:navy">Reply</a> &nbsp; <a href="#" onclick="forwardMessage('inbox', ${idx})" style="font-weight:bold;color:navy">Forward</a>`;
        }
        itemHtml += "</div>";
        html += itemHtml;
    }
    if (inboxMessages.length>0) {
        document.querySelector('#inboxMessages').innerHTML = html;
    } else {
        document.querySelector('#inboxMessages').innerHTML = "You have no message.<br />Do you want to send a message to someone? Please click <a href='#' onclick='onClickMenuItem(\"compose\");'>here</a> to start!!!";   
    }

    // Show page
    document.querySelector('#pagingInfo').innerHTML = getPageLinkStr("inbox", inboxMsgNum);
}

async function updateComposeUI(action, msgType, msgIndex) {
    // Show compose block and hide others
    document.querySelector('#inboxMessages').style.display = 'none';
    document.querySelector('#sentMessages').style.display = 'none';
    document.querySelector('#newMsgBoard').style.display = 'block';

    // Update title
    // console.log(msgType, msgIndex, appInfo[msgType])
    let msgItem = (msgType && msgIndex!=null && msgIndex>=0?appInfo[msgType].messages[msgIndex]:null);
    if (!msgItem) action = "none";
    document.querySelector('input#originMsgId').value = (msgItem?msgItem.id:0);
    if (action=="reply") {
        document.querySelector('#bodyTitle').innerText = "Reply the message";
        document.querySelector('input#toAccount').value = (msgType=="inbox"?msgItem.from:msgItem.to);
        document.querySelector('input#title').value = "Re: " + msgItem.msgData.title;
        document.querySelector('#originMessage').style.display = "block";
        document.querySelector('#originMessageContent').innerHTML = messageItemToHtml(msgType, msgItem);
    } else if (action=="forward") {
        document.querySelector('#bodyTitle').innerText = "Forward the message";
        document.querySelector('input#toAccount').value =  "";
        document.querySelector('input#title').value = "Fw: " + msgItem.msgData.title;
        document.querySelector('#originMessage').style.display = "block";
        document.querySelector('#originMessageContent').innerHTML = messageItemToHtml(msgType, msgItem);
    } else {
        document.querySelector('#bodyTitle').innerText = "Compose new message";
        document.querySelector('input#title').value = "";
        document.querySelector('input#toAccount').value = "";
        document.querySelector('#originMessage').style.display = "none";
    }
    document.querySelector('#bodyTitleInfo').innerText = "";
    document.querySelector('#pagingInfo').innerHTML = "";
    document.querySelector('textarea#content').value = "";

    // Update statics
    await updateStaticInfoUI();
}

async function updateStaticInfoUI() {
    // Get statics information
    let staticsInfo = await contract.getStatics();
    if (!staticsInfo) {
        staticsInfo = {
            messageNum: 0,
            sentAccountNum: 0,
            inboxAccountNum: 0,
            accountNum: 0,
        };
    }
    // console.log("staticsInfo", staticsInfo);

    // Update to UI
    document.querySelector('#staticsInfo').innerHTML = `<b>Statics</b>: ${staticsInfo.sentAccountNum} used accounts, ${staticsInfo.accountNum} total accounts and ${staticsInfo.messageNum} messages`;
}

// `nearInitPromise` gets called on page load
window.nearInitPromise = initContract()
    .then(() => {
        if (window.walletConnection.isSignedIn()) signedInFlow()
        else signedOutFlow()
    })
    .catch(console.error)

'''
'''--- src/main.test.js ---
beforeAll(async function () {
    // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
    const near = await nearlib.connect(nearConfig);
    window.accountId = nearConfig.contractName;
    window.contract = await near.loadContract(nearConfig.contractName, {
        viewMethods: ['getSentMessages', 'getInboxMessages', 'getSentMsgNum', 'getInboxMsgNum', 'getStatics', 'getMessage'],
        changeMethods: ['sendMessage'],
        sender: window.accountId
    })
    console.log("nearConfig.contractName:", nearConfig.contractName);
})

test('Send Message', async () => {
    let fromAccount = window.accountId;
    let toAccount = 'abc.testnet';
    console.log("fromAccount:", fromAccount);
    let ret = await window.contract.sendMessage({
        to: toAccount,
        title: "Test",
        data: 'QmcT7Jwz5Ckt7dfnMdcNsvRiYEf3H5xn8No5JkqoKPP3uy',
        prevMsgId: 0,
        baseSite: 'https://nms.kiemtienonline360.com'
    });
    console.log("Send message return:", ret);
    console.log(`sentMsgNum of ${fromAccount}: ${await window.contract.getSentMsgNum({accountId: fromAccount})}`);
    console.log(`inboxMsgNum of ${toAccount}: ${await window.contract.getInboxMsgNum({accountId: toAccount})}`);
    console.log("Sent Message", await window.contract.getSentMessages({
        accountId: fromAccount,
        fromIndex: 0,
        toIndex: 0
    }));
    console.log("Inbox Message", await window.contract.getInboxMessages({
        accountId: toAccount,
        fromIndex: 0,
        toIndex: 0
    }));
    console.log("Message[0]", await window.contract.getMessage({
        msgId: 1
    }));
    console.log("Statics", await window.contract.getStatics());
})
'''
'''--- src/message.js ---
const IpfsClient = require('ipfs-http-client');
const aes256 = require('aes256');
const axios = require('axios').default;
axios.defaults.adapter = require('axios/lib/adapters/http');
const stream = require('stream');

// Variables
const clientConfig = {
    aesKey: "fc2f83976ad1342659c989ff91bc09d4efb891fd877e77fa03f61006467cff0e",         // SHA256("near-message-service")
    isSupportIpfs: false,
}
let ipfsClient = null;

async function getIpfsClient() {
    if (ipfsClient == null) {
        ipfsClient = await IpfsClient.create({
            host: "ipfs.infura.io",
            port: 5001,
            protocol: "https",
            timeout: '1m'
        });
    }
    return ipfsClient;
}

async function getIpfsData(cid) {
    // return await getIpfsData1(cid);
    // return await getIpfsData2(cid);
    return await getIpfsData3(cid);
}

// Unable to get data after a long time
async function getIpfsData1(cid) {
    let client = await getIpfsClient();
    let stream = client.cat(cid);
    let buffer = null;
    for await (const chunk of stream) {
        if (buffer==null) buffer = chunk;
        else buffer = Buffer.concat(buffer, chunk);
    }
    return buffer;
}

// Only run on Nodejs, not run on client
async function getIpfsData2(cid) {
    let resp = await axios.get(`https://gateway.ipfs.io/ipfs/${cid}`, { timeout: 60*1000, responseType: 'stream' });
    if (!resp || !resp.status || resp.status!=200) {
        console.error("Unable to get data from IPFS", resp);
        return null;
    }
    let buffer = null;
    var writer = new stream.Writable({
        write: function(chunk, encoding, next) {
            if (buffer==null) buffer = chunk;
            else buffer = Buffer.concat(buffer, chunk);
            next();
        }
    });
    resp.data.pipe(writer);

    return new Promise((resolve, reject) => {
        writer.on('finish', function() {
            resolve(buffer);
        })
        writer.on('error', function(err) {
            console.log("Error to get data:", err);
            resolve(null);
        })
    });
}

// Only run on Browser
async function getIpfsData3(cid) {
    let promise = new Promise(function(resolve, reject) {
        try {
            const data = null;
            const url = `https://gateway.ipfs.io/ipfs/${cid}`;
            const xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.overrideMimeType("application/octet-stream");
            xhr.responseType = "arraybuffer";
            xhr.timeout = 60000;
            xhr.onload = function (v) {
                resolve(Buffer.from(xhr.response));
            };
            xhr.onerror = function (e) {
                console.error(`ERROR to get data ${cid}`, e);
                resolve(null);
            };
            xhr.send(data);
        } catch (ex) {
            console.error("Unable to get avatar", ex);
        }
    });
    return (await promise);
}

function encodeMsgTitle(msgTitle) {
    let buffer = Buffer.from(msgTitle, 'utf8');
    buffer = aes256.encrypt(clientConfig.aesKey, buffer);
    return buffer.toString('hex');
}

function decodeMsgTitle(hexaTitle) {
    if (!hexaTitle) return "";
    let buffer = Buffer.from(hexaTitle, "hex");
    buffer = aes256.decrypt(clientConfig.aesKey, buffer);
    return buffer.toString('utf8');
}

function encodeMsgBody(msgBody) {
    let buffer = Buffer.from(JSON.stringify(msgBody), 'utf8');
    buffer = aes256.encrypt(clientConfig.aesKey, buffer);
    return buffer;
}

function decodeMsgBody(bodyBuffer) {
    let buffer = aes256.decrypt(clientConfig.aesKey, bodyBuffer);
    let strBody = buffer.toString("utf8");
    return JSON.parse(strBody);
}

async function decodeMsgData(buffer, aesKey) {
    if (isSupportZip) {
        buffer = await decompressData(buffer);
    }
    if (aesKey) {
        buffer = aes256.decrypt(aesKey, buffer);
    }
    return JSON.parse(buffer.toString("utf8"));
}

async function getMesageData(cid, aesKey) {
    let ret = {
        success: false,
        message: null,
        data: null
    };
    try {
        // Get data from IPFS
        let buffer = await getIpfsData(cid);
        if (buffer) {
            // Decode data
            let data = await decodeMsgData(buffer, aesKey);
            if (data) {
                ret.success = true;
                ret.message = "SUCCESS";
                ret.data = data;
            } else {
                ret.message = "Unable to decode message";
            }
        } else {
            ret.message = "Unable to get data on IPFS for cid: " + cid;
        }
    
    } catch(ex) {
        console.error("Store message on IPFS error", ex);
        ret.message = ex.toString();
    }
    return ret;
}
exports.getMesageData = getMesageData;

// msg: { title, content, attachmentFiles }
// return: { code, message, title, data}
async function packMessage(msg) {
    let resp = {
        code: 1,
        message: "Unknow error"
    };
    try {
        // Encode title
        resp.title = encodeMsgTitle(msg.title);

        // Encode body
        let msgBody = {
            content: msg.content,
            attachmentFiles: content.attachmentFiles
        };
        let bodyBuffer = await encodeMsgBody(msgBody);

        // Check is support IPFS or not?
        if (clientConfig.isSupportIpfs) {
            // Support IPFS => Store body on IPFS
            let client = await getIpfsClient();
            const result = await client.add(bodyBuffer);
            if (result && result.cid) {
                resp.data = "#IPFS:" + result.cid.toString();
                resp.code = 0;
                resp.message = "SUCCESS";
                
            } else {
                resp.message = "Unable to store data on IPFS"
            }
        } else {
            // Not support IPFS
            resp.data = "#NONE:" + bodyBuffer.toString('hex');
            resp.code = 0;
            resp.message = "SUCCESS";
        }
    } catch(ex) {
        console.error("Error to pack message", ex);
        resp.message = ex.toString();
    }
    return resp;
}
exports.packMessage = packMessage;

// msg: { title, data }
// return: { code, message, title, content, attachmentFiles}
async function depackMessage(msg, isLoadFromIpfs=false) {
    let resp = {
        code: 1,
        message: "Unknown error"
    };
    try {
        // Decode title
        resp.title = decodeMsgTitle(msg.title);

        // Decode body
        let data = msg.data;
        if (data) {
            if (data.startsWith("#EXPIRED")) {
                msg.content = "The message has been expired!";
            } else if (data.startsWith("#NONE")) {
                let bodyData = data.substring(6);
                let bodyBuffer = Buffer.from(bodyData, "hex");
                let bodyInfo = decodeMsgBody(bodyBuffer);
                console.log("bodyInfo", bodyInfo);
                resp.content = bodyInfo.content;
                resp.attachmentFiles = bodyInfo.attachmentFiles;
                resp.code = 0;
                resp.message = "SUCCESS";
            } else if (data.startsWith("#IPFS")) {
                if (isLoadFromIpfs) {
                    let cid = data.substring(6);
                }
                resp.code = 0;
                resp.message = "SUCCESS";

            } else {
                resp.message = "Message is invalid format!!!";
            }
        } else {
            resp.content = "";
            resp.code = 0;
            resp.message = "SUCCESS";
        }
    } catch(ex) {
        console.error("Error to depack message", ex);
        resp.message = ex.toString();
    }
    return resp;
}
exports.depackMessage = depackMessage;
'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection, Connection } from 'near-api-js';
import getConfig from './config';

// const nearConfig = getConfig(process.env.NODE_ENV || 'development');
const nearConfig = getConfig('development');
let near = null;

// Initialize contract & set global variables
export async function initContract() {
    // Initialize connection to the NEAR testnet
    // console.log("nearConfig", nearConfig);
    near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig));

    // Initializing Wallet based Account. It can work with NEAR testnet wallet that
    // is hosted at https://wallet.testnet.near.org
    window.walletConnection = new WalletConnection(near)

    // Getting the Account ID. If still unauthorized, it's just empty string
    window.accountId = window.walletConnection.getAccountId()

    // Initializing our contract APIs by contract name and configuration
    window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
        // View methods are read only. They don't modify the state, but usually return some value.
        viewMethods: ['getSentMsgNum', 'getSentMessages', 'getInboxMsgNum', 'getInboxMessages', "getStatics", "getMessage"],
        // Change methods can modify the state. But you don't receive the returned value when called.
        changeMethods: ['sendMessage'],
    });
}

export function logout() {
    window.walletConnection.signOut()
    // reload page
    window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
    // Allow the current app to make calls to the specified contract on the
    // user's behalf.
    // This works by creating a new access key for the user's account and storing
    // the private key in localStorage.
    window.walletConnection.requestSignIn(nearConfig.contractName)
}

export async function isAccountExist(accountId) {
    let ret = false;
    try {
        await near.connection.provider.query(`account/${accountId}`, "");
        ret = true;
    } catch (ex) { }
    return ret;
}

// https://docs.near.org/docs/concepts/transaction
export async function getTransaction(transHash) {
    let result = null;
    try {
        let result = await near.connection.provider.txStatus(transHash, window.accountId);
        // console.log(`Result for ${transHash}`, result);
        return result;
    } catch (ex) {
        console.error("Unable to get transaction info:", ex);
    }
    return result;
}

export function getAvatar(accountId, callback) {
    try {
        const data = `{
            "contract": "alpha.neatar.testnet",
            "method": "avatar_of",
            "params": { "account_id": "${accountId}" },
            "rpc_node": "https://rpc.testnet.near.org"
        }`;
        const url = 'https://rest.nearapi.org/view';
        const xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.timeout = 60000;
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        }
        xhr.send(data);
    } catch (ex) {
        console.error("Unable to get avatar", ex);
        callback(null);
    }
}
'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>Please run the following command in NEAR CLI, then enter account id here. masterAccountId default: test.near
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''