*GitHub Repository "HAPIprotocol/near-proxy-contract"*

'''--- CHANGELOG.md ---
# Changelog

## v0.1.2
* Refactoring
* Fix roles
* Fix tests
* Update rust version in docker build

## v0.1.1
* Update dependencies
* Minor refactoring

## v0.1.0
* LowRiskExchange and MediumRiskExchange merged to category Exchange
'''
'''--- README.md ---
# HAPI Protocol

[HAPI Protocol] is a one-of-a-kind decentralized security protocol that prevents and interrupts any potential malicious activity within the blockchain space. HAPI Protocol works by leveraging both external and off-chain data as well as on-chain data accrued directly by HAPI Protocol and is publicly available.

## HAPI NEAR Proxy

The HAPI NEAR Proxy is a smart contract used for replicating data from [HAPI Protocol] main contract on the NEAR blockchain. It acts as an interface between the HAPI Protocol and the NEAR blockchain, allowing data to be replicated from the protocol by oracles.

Reporters are entities added to the contract by the protocol authority which can report data to the protocol.

To check an address of interest for security data, consumers should call the `get_address` method.

## Methods

Each role can call its methods and the methods of roles below it.

### Owner methods

- new - initialize contract.
- change_owner - transfer ownership to new owner.

### Authority methods

- create_reporter - add new reporter with corresponding permission level.
- update_reporter - update permission level for reporter.

### Reporter methods

- create_address - add new address with corresponding category and risk level
- update_address - update address category and risk.

### User methods

- get_address - return risk level and category.
- get_reporter - return permission level.

## Integration

Consumers can integrate the HAPI NEAR Proxy Contract using the [hapi-near-connector](https://github.com/HAPIProtocol/hapi-near-connector).This crate helps to implement [HAPI Protocol] in your smart contract on the NEAR blockchain.

Alternatively, consumers can do it directly. As an example, [Jumbo Exchange](https://github.com/jumbo-exchange/contracts#hapi-protocol-integration) has integrated the HAPI NEAR Proxy Contract into their platform.

## For developers

### CLI installation

You can install cli via this [tutorial](https://docs.near.org/docs/tools/near-cli#installation)

### Getting started

For creating the new account for deploying contract use next command.

Create variables

```bash
export NEAR_ENV=testnet
export CONTRACT_ID=contract.hapi-test.testnet
export OWNER_ID=hapi-test.testnet
export REPORTER_ID=reporter.hapi-test.testnet
```

```bash
near create-account $CONTRACT_ID --masterAccount $OWNER_ID --initialBalance 10
```

First of all - you will need to compile the wasm file of contract.

```bash
./contract/build_docker.sh
```

Then deploy it.

```bash
near deploy $CONTRACT_ID --wasmFile=contract/res/proxy_contract_release.wasm
```

Then initialize contract with command where OWNER_ID is your admin UI account.

```bash
near call $CONTRACT_ID new '{"owner_id": "'$OWNER_ID'"}' --accountId $CONTRACT_ID
```

## Useful commands

- NEW

```bash
near call $CONTRACT_ID new '{"owner_id": "'$OWNER_ID'"}' --account_id=$OWNER_ID
```

- CHANGE OWNER

```bash
near call $CONTRACT_ID change_owner '{"owner_id": "NEW_OWNER_ID"}' --account_id=$OWNER_ID
```

- CREATE REPORTER

  - address - account_id of reporter
  - permission_level - permission level corresponding to the table

| Role | permission_level |
| ------ | ------ |
| Reporter | 1 |
| Authority | 2 |

```bash
near call $CONTRACT_ID create_reporter '{"address": "'$REPORTER_ID'", "permission_level": 2}' --account_id=$OWNER_ID
```

- UPDATE REPORTER

  - address - account_id of reporter
  - permission_level - permission level corresponding to the table

| Role | permission_level |
| ------ | ------ |
| Reporter | 1 |
| Authority | 2 |

```bash
near call $CONTRACT_ID update_reporter '{"address": "'$REPORTER_ID'", "permission_level": 1 }' --accountId=$OWNER_ID
```

- GET REPORTER

Returns permission level of reporter

| Role | permission_level |
| ------ | ------ |
| Reporter | 1 |
| Authority | 2 |

```bash
near call $CONTRACT_ID get_reporter '{"address": "'$REPORTER_ID'" }' --accountId=$OWNER_ID
```

- CREATE ADDRESS

  - address - address which should be updated
  - category - category from list of [Categories]
  - risk - risk level also described in [Categories] section

```bash
near call $CONTRACT_ID create_address '{"address": "address.id", "category": "Scam", "risk": 6}' --accountId=$REPORTER_ID
```

- UPDATE ADDRESS

  - address - address which should be updated
  - category - category from list of [Categories]
  - risk - risk level also described in [Categories] section

```bash
near call $CONTRACT_ID update_address '{"address": "address.id", "category": "WalletService", "risk": 6}' --accountId=$REPORTER_ID
```

- GET ADDRESS

This method returns tuple of Category and u8 (risk level). List of [Categories].

```bash
near view $CONTRACT_ID get_address '{"address": "address.id"}'
```

## Categories

If the address belongs to some category, it will have a
Risk score (on a scale from 0..10, i.e. max risk).

| Category | Description |
|----------|-------|
| None | |
| WalletService | Wallet service - custodial or mixed wallets |
| MerchantService | Merchant service |
| MiningPool | Mining pool |
| LowRiskExchange | Low-risk exchange - Exchange with high KYC standards |
| MediumRiskExchange | Medium risk exchange |
| DeFi | DeFi application |
| OTCBroker | OTC Broker |
| ATM | Cryptocurrency ATM |
| Gambling | Gambling |
| IllicitOrganization | Illicit organization |
| Mixer | Mixer |
| DarknetService | Darknet market or service |
| Scam | Scam |
| Ransomware | Ransomware |
| Theft | Theft - stolen funds |
| Counterfeit | Counterfeit - fake assets |
| TerroristFinancing | Terrorist financing |
| ChildAbuse | Child abuse and porn materials |

[HAPI Protocol]: https://hapi-one.gitbook.io/hapi-protocol/
[Categories]: (#categories)

'''
'''--- contract/Cargo.toml ---
[package]
name = "proxy_contract"
version = "0.1.2"
authors = ["HAPI Developers"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

NAME="contract"

if docker ps -a --format '{{.Names}}' | grep -Eq "^${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$DIR/..,target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=$NAME \
     -w /host/contract \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it \
     nearprotocol/contract-builder \
     /bin/bash
fi

docker start $NAME
docker exec -it $NAME /bin/bash -c "rustup toolchain install stable-2023-03-09; rustup default stable-2023-03-09; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $DIR/target/wasm32-unknown-unknown/release/proxy_contract.wasm $DIR/res/proxy_contract_release.wasm

'''
'''--- contract/build_local.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/proxy_contract.wasm ./res/proxy_contract_local.wasm

'''
'''--- contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1642436928997-32263330864376
'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault};

use near_sdk::collections::LookupMap;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Category {
    None,
    // Wallet service - custodial or mixed wallets
    WalletService,
    // Merchant service
    MerchantService,
    // Mining pool
    MiningPool,
    // Exchange
    Exchange,
    // DeFi application
    DeFi,
    // OTC Broker
    OTCBroker,
    // Cryptocurrency ATM
    ATM,
    // Gambling
    Gambling,
    // Illicit organization
    IllicitOrganization,
    // Mixer
    Mixer,
    // Darknet market or service
    DarknetService,
    // Scam
    Scam,
    // Ransomware
    Ransomware,
    // Theft - stolen funds
    Theft,
    // Counterfeit - fake assets
    Counterfeit,
    // Terrorist financing
    TerroristFinancing,
    // Sanctions
    Sanctions,
    // Child abuse and porn materials
    ChildAbuse,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct AddressInfo {
    category: Category,
    risk: u8,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Proxy {
    owner_id: AccountId,
    pub reporters: LookupMap<AccountId, u8>,
    pub addresses: LookupMap<AccountId, AddressInfo>,
}
#[derive(PartialEq)]
pub enum Roles {
    Reporter = 1,
    Authority = 2,
}

const MAX_RISK: u8 = 10;

#[near_bindgen]
impl Proxy {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            reporters: LookupMap::new(b"r"),
            addresses: LookupMap::new(b"a"),
        }
    }

    pub fn change_owner(&mut self, owner_id: AccountId) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "HapiProxy: Only the owner may call this method"
        );
        self.owner_id = owner_id;
    }

    pub fn create_reporter(&mut self, address: AccountId, permission_level: u8) -> Option<u8> {
        self.validate_permission_level(&permission_level);

        self.assert_owner_or_authority();

        assert!(
            !self.reporters.contains_key(&address),
            "HapiProxy: Reporter already exist"
        );

        self.reporters.insert(&address, &permission_level)
    }

    pub fn get_reporter(&self, address: AccountId) -> u8 {
        self.reporters
            .get(&address)
            .expect("HapiProxy: This account is not a reporter")
    } // return permission level

    pub fn update_reporter(&mut self, address: AccountId, permission_level: u8) -> bool {
        self.validate_permission_level(&permission_level);

        self.assert_owner_or_authority();

        assert!(
            self.reporters.contains_key(&address),
            "HapiProxy: This account is not a reporter"
        );
        self.reporters.insert(&address, &permission_level);
        true
    }

    pub fn create_address(&mut self, address: AccountId, category: Category, risk: u8) -> bool {
        self.assert_reporter();

        assert!(risk <= MAX_RISK, "HapiProxy: Invalid risk");
        assert!(
            !self.addresses.contains_key(&address),
            "HapiProxy: Address already exist"
        );
        let address_info = AddressInfo { category, risk };
        self.addresses.insert(&address, &address_info);
        true
    }

    pub fn get_address(&self, address: AccountId) -> (Category, u8) {
        if let Some(address_info) = self.addresses.get(&address) {
            (address_info.category, address_info.risk)
        } else {
            (Category::None, 0)
        }
    } // return risk level and category

    pub fn update_address(&mut self, address: AccountId, category: Category, risk: u8) {
        self.assert_reporter();

        assert!(risk <= MAX_RISK, "HapiProxy: Invalid risk");
        assert!(
            self.addresses.contains_key(&address),
            "HapiProxy: Address does not exist"
        );
        let address_info = AddressInfo { category, risk };
        self.addresses.insert(&address, &address_info);
    }
}

impl Proxy {
    pub fn validate_permission_level(&self, permission_level: &u8) {
        assert!(
            permission_level.eq(&Roles::Reporter) || permission_level.eq(&Roles::Authority),
            "HapiProxy: Invalid permission level"
        );
    }

    pub fn assert_owner_or_authority(&self) {
        let predecessor = env::predecessor_account_id();

        require!(
            self.owner_id.eq(&predecessor)
                || self
                    .reporters
                    .get(&predecessor)
                    .unwrap_or_default()
                    .eq(&Roles::Authority),
            "HapiProxy: Only the owner or authority may call this method"
        );
    }

    pub fn assert_reporter(&self) {
        require!(
            self.reporters.contains_key(&env::predecessor_account_id()),
            "HapiProxy: You must be a reporter to perform this action"
        );
    }
}

impl PartialEq<Roles> for u8 {
    fn eq(&self, other: &Roles) -> bool {
        match other {
            Roles::Reporter => *self == 1_u8,
            Roles::Authority => *self == 2_u8,
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use super::*;

    use crate::Category;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    pub fn get_account_id(account_id: &str) -> AccountId {
        AccountId::from_str(account_id)
            .unwrap_or_else(|_| panic!("ERR: can't get account_id from str: {account_id}"))
    }

    #[test]
    fn test_new() {
        let owner_id: AccountId = get_account_id("owner");
        let contract = Proxy::new(owner_id.clone());
        assert_eq!(contract.owner_id, owner_id);
    }

    #[test]
    fn test_get_reporter() {
        let mut context = VMContextBuilder::new();
        let owner_id: AccountId = get_account_id("owner");
        let reporter_id: AccountId = get_account_id("reporter");
        let mut contract = Proxy::new(owner_id.clone());
        testing_env!(context.predecessor_account_id(owner_id).build());

        contract.create_reporter(reporter_id.clone(), Roles::Authority as u8);
        assert_eq!(
            contract.get_reporter(reporter_id.clone()),
            Roles::Authority as u8,
            "reporter permission_level is: {}",
            contract.get_reporter(reporter_id)
        );
    }

    #[test]
    fn test_update_reporter() {
        let mut context = VMContextBuilder::new();
        let owner_id: AccountId = get_account_id("owner");
        let reporter_id: AccountId = get_account_id("reporter");
        let mut contract = Proxy::new(owner_id.clone());
        testing_env!(context.predecessor_account_id(owner_id).build());
        contract.create_reporter(reporter_id.clone(), Roles::Authority as u8);
        assert!(
            contract.update_reporter(reporter_id.clone(), Roles::Authority as u8),
            "Reporter update failed"
        );

        assert_eq!(
            contract.get_reporter(reporter_id.clone()),
            Roles::Authority as u8,
            "reporter value is: {}",
            contract.get_reporter(reporter_id)
        );
    }

    #[test]
    fn test_get_address() {
        let mut context = VMContextBuilder::new();
        let owner_id: AccountId = get_account_id("owner");
        let reporter_id: AccountId = get_account_id("reporter");
        let address_id: AccountId = get_account_id("mining.pool");
        let mut contract = Proxy::new(owner_id.clone());
        testing_env!(context.predecessor_account_id(owner_id).build());

        contract.create_reporter(reporter_id.clone(), Roles::Authority as u8);
        testing_env!(context.predecessor_account_id(reporter_id).build());
        contract.create_address(address_id.clone(), Category::MiningPool, 7);

        assert_eq!(
            contract.get_address(address_id),
            (Category::MiningPool, 7),
            "Address not added"
        );
    }
}

'''
'''--- contract/tests/sim/main.rs ---
extern crate proxy_contract;
use std::str::FromStr;

use near_sdk::test_utils::{accounts, VMContextBuilder};
use near_sdk::testing_env;
use near_sdk::AccountId;
use proxy_contract::{Category, Proxy, Roles};

pub fn get_account_id(account_id: &str) -> AccountId {
    AccountId::from_str(account_id)
        .unwrap_or_else(|_| panic!("ERR: can't get account_id from str: {account_id}"))
}

#[test]
#[should_panic(expected = "HapiProxy: Only the owner or authority may call this method")]
fn test_change_owner() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("alice");
    let second_account_id: AccountId = get_account_id("james.bond");
    let reporter_id: AccountId = get_account_id("reporter");
    let mut contract = Proxy::new(owner_id.clone());
    testing_env!(context.predecessor_account_id(owner_id).build());

    contract.change_owner(second_account_id);
    contract.create_reporter(reporter_id, Roles::Reporter as u8);
}

#[test]
fn test_get_reporter() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    let mut contract = Proxy::new(owner_id.clone());
    testing_env!(context.predecessor_account_id(owner_id).build());

    contract.create_reporter(reporter_id.clone(), Roles::Reporter as u8);
    assert_eq!(
        contract.get_reporter(reporter_id.clone()),
        Roles::Reporter as u8,
        "reporter value is: {}",
        contract.get_reporter(reporter_id)
    );
}

#[test]
#[should_panic(expected = "HapiProxy: Reporter already exist")]
fn test_twice_create_reporter() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    let mut contract = Proxy::new(owner_id.clone());
    testing_env!(context.predecessor_account_id(owner_id).build());

    contract.create_reporter(reporter_id.clone(), Roles::Reporter as u8);
    contract.create_reporter(reporter_id, Roles::Reporter as u8);
}

#[test]
fn test_update_reporter() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    testing_env!(context.predecessor_account_id(owner_id.clone()).build());

    let mut contract = Proxy::new(owner_id);
    contract.create_reporter(reporter_id.clone(), Roles::Reporter as u8);
    assert!(
        contract.update_reporter(reporter_id.clone(), Roles::Authority as u8),
        "Reporter update failed"
    );

    assert_eq!(
        contract.get_reporter(reporter_id.clone()),
        Roles::Authority as u8,
        "reporter value is: {}",
        contract.get_reporter(reporter_id)
    );
}

#[test]
#[should_panic(expected = "HapiProxy: Only the owner or authority may call this method")]
fn test_not_owner_updates_reporter() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    testing_env!(context.predecessor_account_id(owner_id.clone()).build());

    let mut contract = Proxy::new(owner_id);
    contract.create_reporter(reporter_id.clone(), Roles::Reporter as u8);

    testing_env!(context.predecessor_account_id(reporter_id.clone()).build());
    assert!(
        contract.update_reporter(reporter_id.clone(), Roles::Authority as u8),
        "Reporter update failed"
    );

    assert_eq!(
        contract.get_reporter(reporter_id.clone()),
        Roles::Reporter as u8,
        "reporter value is: {}",
        contract.get_reporter(reporter_id)
    );
}

#[test]
fn test_get_address() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    let address_id: AccountId = get_account_id("mining.pool");
    testing_env!(context.predecessor_account_id(owner_id.clone()).build());

    let mut contract = Proxy::new(owner_id);
    contract.create_reporter(reporter_id.clone(), Roles::Reporter as u8);

    testing_env!(context.predecessor_account_id(reporter_id).build());
    contract.create_address(address_id.clone(), Category::MiningPool, 7);
    assert_eq!(
        contract.get_address(address_id),
        (Category::MiningPool, 7),
        "Address not added"
    );
}

#[test]
#[should_panic(expected = "HapiProxy: Invalid permission level")]
fn test_invalid_permission_level() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");

    let mut contract = Proxy::new(owner_id);
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    contract.create_reporter(reporter_id, 3);
}

#[test]
#[should_panic(expected = "HapiProxy: Invalid risk")]
fn test_create_address_wrong_risk() {
    let mut context = VMContextBuilder::new();
    let owner_id: AccountId = get_account_id("owner");
    let reporter_id: AccountId = get_account_id("reporter");
    let address_id: AccountId = get_account_id("mining.pool");
    let mut contract = Proxy::new(owner_id.clone());
    testing_env!(context.predecessor_account_id(owner_id).build());
    contract.create_reporter(reporter_id.clone(), Roles::Authority as u8);

    testing_env!(context.predecessor_account_id(reporter_id).build());
    contract.create_address(address_id, Category::MiningPool, 11);
}

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1642436906627-71002247030340
'''