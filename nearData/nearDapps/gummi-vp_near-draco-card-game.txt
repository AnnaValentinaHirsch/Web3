*GitHub Repository "gummi-vp/near-draco-card-game"*

'''--- README.md ---
# Draco Card Game

This project is a card game similar to blackjack, played against the computer (dealer). At the start of the game, you have two cards with a random number from 1 to 11. We can see one card in the dealer's hand. We can ask for a new card as the next move or continue with the two cards we have. Then, if the sum of our cards is less than 23 and is greater than the sum of the three cards in the dealer's hand, we win the game.

## Cloning The Project
```
git clone https://github.com/gummi-vp/near-draco-card-game.git
```
After cloning the project
```
yarn
```

## Building and Deploying The Contract
```
yarn build:release
near dev-deploy ./build/release/simple.wasm
export CONTRACT=<accountId>
near login
```
accountId --> Which is generated after the contract deployment

## Functions

### playGame
Player calls the playGame function to start the game.

```
near call <contract-id> playGame --account_id <account-id>
```

### getCard
If player wants to get a new card, player calls the getCard function.

```
near call <contract-id> getCard --account_id <account-id>
```

### standCard
If player wants to continue with the cards in his hand, player calls the standCard function.

```
near call <contract-id> standCard --account_id <account-id>
```

### getWinStreak
- Takes ***playerName*** as a parameter
- Returns the player's highest winning streak in the game

```
near call <contract-id> getWinStreak '{"playerName": "<playerName>"}' --account_id <account-id>
```
playerName --> Sender's account ID

## Loom Video

https://www.loom.com/share/835b14c70091458bbd148935ff2a8d08
'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Building the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Deploying the contract"
echo ---------------------------------------------------------
echo

near dev-deploy ./build/release/simple.wasm

echo
echo
echo ---------------------------------------------------------
echo "    Find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo ---------------------------------------------------------
echo 
echo "Run the following commands"
echo
echo 'export CONTRACT=<dev-123-456>'
echo 'export OWNER=<account owner>'
echo ---------------------------------------------------------
echo

exit 0
'''
'''--- scripts/2.play-game.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable" && exit 1

echo
echo
echo ---------------------------------------------------------
echo "Calling playGame function on the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT playGame --account_id $OWNER
'''
'''--- scripts/3.get-card.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable" && exit 1

echo
echo
echo ---------------------------------------------------------
echo "Calling getCard function on the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT getCard --account_id $OWNER
'''
'''--- scripts/4.stand-card.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable" && exit 1

echo
echo
echo ---------------------------------------------------------
echo "Calling standCard function on the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT standCard --account_id $OWNER
'''
'''--- scripts/5.get-streak.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable" && exit 1

echo
echo
echo ---------------------------------------------------------
echo "Calling getWinStreak function on the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT getWinStreak '{"playerName": "'"$1"'"}' --account_id $OWNER
'''
'''--- scripts/README.md ---
## Environment

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # For example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=gummi.testnet
```

## Commands

  _helper scripts_

  ```sh
  1.dev-deploy.sh                  # helper: build and deploy contracts
  2.play-game.sh                   # helper: call the playGame function, to start the game
  3.get-card.sh                    # helper: call the getCard function, to get a new card
  4.stand-card.sh                  # helper: call the standCard function, to continue the game with the cards in your hand
  5.get-streak.sh <account-id>     # helper: call the getWinStreak function, to see the highest score by account ID
  ```
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { storage, Context, PersistentVector, PersistentMap, RNG, logging } from "near-sdk-as"

let playerCards = new PersistentVector<u32>("pcards");
let dealerCards = new PersistentVector<u32>("dcards");
let winStreak = new PersistentMap<string, u32>("wstr");

let player = Context.sender;

// playGame function to start the game
export function playGame(): string {
  assert(playerCards.isEmpty, "Please, call the getCard or standCard function.");

  playerCards.push(new RNG<u32>(1, 11).next() + 1);
  playerCards.push(new RNG<u32>(1, 11).next() + 1);
  dealerCards.push(new RNG<u32>(1, 11).next() + 1);

  return 'Your Cards: Card 1 --> ' + playerCards[0].toString() + ',  Card 2 --> ' + playerCards[1].toString()
    + ' // Dealer Card 1 --> ' + dealerCards[0].toString() + '. Do you want another card? (If you want, call getCard function. If not, call standCard function.)';
}

// if player wants one more card
export function getCard(): string {
  pushCards(true);

  let playerCard1 = playerCards[0];
  let playerCard2 = playerCards[1];
  let playerCard3 = playerCards[2];

  let dealerCard1 = dealerCards[0];
  let dealerCard2 = dealerCards[1];
  let dealerCard3 = dealerCards[2];

  let gameMessage = "";

  if (((playerCard1 + playerCard2 + playerCard3) > (dealerCard1 + dealerCard2 + dealerCard3) && (playerCard1 + playerCard2 + playerCard3) < 23)) {
    gameMessage = "Congratulations, You Won! Current Win Streak: " + writeStreak(true);
  }
  else if ((playerCard1 + playerCard2 + playerCard3) < (dealerCard1 + dealerCard2 + dealerCard3) && (dealerCard1 + dealerCard2 + dealerCard3) < 23) {
    gameMessage = "Dealer Won! Current Win Streak: " + writeStreak(false);
  }
  else if ((playerCard1 + playerCard2 + playerCard3) >= 23 && (dealerCard1 + dealerCard2 + dealerCard3) < 23) {
    gameMessage = "Dealer Won! Current Win Streak: " + writeStreak(false);
  }
  else if ((playerCard1 + playerCard2 + playerCard3) < 23 && (dealerCard1 + dealerCard2 + dealerCard3) >= 23) {
    gameMessage = "Congratulations, You Won! Current Win Streak: " + writeStreak(true);
  }
  else {
    gameMessage = "Draw!";
  }

  popCards(true);

  return gameMessage + ' // Your Cards: Card 1 --> ' + playerCard1.toString() + ',  Card 2 --> ' + playerCard2.toString()
    + ', Card 3 --> ' + playerCard3.toString() + ' // Dealer Cards: Card 1 --> ' + dealerCard1.toString() + ', Card 2 --> ' + dealerCard2.toString() + ', Card 3 --> ' + dealerCard3.toString();
}

// if player wants to stand
export function standCard(): string {
  pushCards(false);

  let playerCard1 = playerCards[0];
  let playerCard2 = playerCards[1];

  let dealerCard1 = dealerCards[0];
  let dealerCard2 = dealerCards[1];
  let dealerCard3 = dealerCards[2];

  let gameMessage = "";

  if (((playerCard1 + playerCard2) > (dealerCard1 + dealerCard2 + dealerCard3) && (playerCard1 + playerCard2) < 23)) {
    gameMessage = "Congratulations, You Won! Current Win Streak: " + writeStreak(true);
  }
  else if ((playerCard1 + playerCard2) < (dealerCard1 + dealerCard2 + dealerCard3) && (dealerCard1 + dealerCard2 + dealerCard3) < 23) {
    gameMessage = "Dealer Won! Current Win Streak: " + writeStreak(false);
  }
  else if ((playerCard1 + playerCard2) >= 23 && (dealerCard1 + dealerCard2 + dealerCard3) < 23) {
    gameMessage = "Dealer Won! Current Win Streak: " + writeStreak(false);
  }
  else if ((playerCard1 + playerCard2) < 23 && (dealerCard1 + dealerCard2 + dealerCard3) >= 23) {
    gameMessage = "Congratulations, You Won! Current Win Streak: " + writeStreak(true);
  }
  else {
    gameMessage = "Draw!";
  }

  popCards(false);

  return gameMessage + ' // Your Cards: Card 1 --> ' + playerCard1.toString() + ',  Card 2 --> ' + playerCard2.toString()
    + ' // Dealer Cards: Card 1 --> ' + dealerCard1.toString() + ', Card 2 --> ' + dealerCard2.toString() + ', Card 3 --> ' + dealerCard3.toString();
}

// push cards to persistentMap
function pushCards(key: bool): void {
  assert(!playerCards.isEmpty, "Please, call the playGame function first.");

  dealerCards.push(new RNG<u32>(1, 11).next() + 1);
  dealerCards.push(new RNG<u32>(1, 11).next() + 1);
  if (key) {
    // logging.log(playerCards.length);
    playerCards.push(new RNG<u32>(1, 11).next() + 1);
  }
}

// pop cards in persistentMap
function popCards(key: bool): void {
  playerCards.pop();
  playerCards.pop();
  if (key) {
    // logging.log(playerCards.length);
    playerCards.pop();
  }

  dealerCards.pop();
  dealerCards.pop();
  dealerCards.pop();
}

// Storing the highest scores in a persistentMap and Storage
function writeStreak(key: bool): string {
  if (winStreak.contains(player)) {
    let playerWins = winStreak.getSome(player);
    if (key) {
      playerWins++;
      winStreak.set(player, playerWins);
      if(read(player) < playerWins){
        write(player, playerWins);
      }
    }
    else {
      playerWins = 0;
      winStreak.set(player, 0);
    }
    return playerWins.toString() + " - Player: " + player;
  }
  else {
    if (key) {
      winStreak.set(player, 1);
      if(read(player) < 1){
        write(player, 1);
      }
      return "1" + " - Player: " + player;
    }
    else {
      winStreak.set(player, 0);
      return "0" + " - Player: " + player;
    }
  }
}

// Fetching Highest Winning Streak according to the player (sender)
export function getWinStreak(playerName: string): string {
  if (storage.hasKey(playerName)) {
    return playerName + " --> Highest Winning Streak is " + storage.getSome<u32>(playerName).toString();
  } else {
    return playerName + " --> Highest Winning Streak is 0";
  }
}

// read the given key from account (contract) storage
function read(key: string): u32 {
  if (storage.hasKey(key)) {
    return storage.getSome<u32>(key);
  } else {
    return 0;
  }
}

// write the given value at the given key to account (contract) storage
function write(key: string, value: u32): string {
  storage.set(key, value)
  return `✅ Data saved.`
}
'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { storage, Context } from "near-sdk-core"

@nearBindgen
export class Contract {
  private message: string = 'hello world'

  // return the string 'hello world'
  helloWorld(): string {
    return this.message
  }

  // read the given key from account (contract) storage
  read(key: string): string {
    if (isKeyInStorage(key)) {
      return `✅ Key [ ${key} ] has value [ ${storage.getString(key)!} ] and "this.message" is [ ${this.message} ]`
    } else {
      return `🚫 Key [ ${key} ] not found in storage. ( ${this.storageReport()} )`
    }
  }

  /**
  write the given value at the given key to account (contract) storage
  ---
  note: this is what account storage will look like AFTER the write() method is called the first time
  ╔════════════════════════════════╤══════════════════════════════════════════════════════════════════════════════════╗
  ║                            key │ value                                                                            ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                          STATE │ {                                                                                ║
  ║                                │   "message": "data was saved"                                                    ║
  ║                                │ }                                                                                ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                       some-key │ some value                                                                       ║
  ╚════════════════════════════════╧══════════════════════════════════════════════════════════════════════════════════╝
   */
  @mutateState()
  write(key: string, value: string): string {
    storage.set(key, value)
    this.message = 'data was saved' // this is why we need the deorator @mutateState() above the method name
    return `✅ Data saved. ( ${this.storageReport()} )`
  }

  // private helper method used by read() and write() above
  private storageReport(): string {
    return `storage [ ${Context.storageUsage} bytes ]`
  }
}

/**
 * This function exists only to avoid a compiler error
 *

ERROR TS2339: Property 'contains' does not exist on type 'src/singleton/assembly/index/Contract'.

     return this.contains(key);
                 ~~~~~~~~
 in ~lib/near-sdk-core/storage.ts(119,17)

/Users/sherif/Documents/code/near/_projects/edu.t3/starter--near-sdk-as/node_modules/asbuild/dist/main.js:6
        throw err;
        ^

 * @param key string key in account storage
 * @returns boolean indicating whether key exists
 */
function isKeyInStorage(key: string): bool {
  return storage.hasKey(key)
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''