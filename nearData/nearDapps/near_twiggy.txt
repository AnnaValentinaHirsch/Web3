*GitHub Repository "near/twiggy"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug Report 🐛
about: Something not working as expected?
---

## 🐛 Bug Description

Describe your issue in detail.

twiggy version: (replace this with the output of `twiggy --version`)

#### 🌍 Test Case

Upload the test case and link to it here. For example, a `.wasm` file that
Twiggy fails to parse.

#### 👟 Steps to Reproduce

Precise steps describing how to reproduce the issue, including commands and
flags run. For example:

* Run `twiggy top -n 25 test_case.wasm`
* ...

#### 😲 Actual Behavior

What happens after you follow the steps to reproduce? Include console output,
error messages, stack traces, etc.

#### 🤔 Expected Behavior

What should have happened instead?

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature Request 💡
about: Suggest a new feature for Twiggy
---

## 💡 Feature Description

Explanation of the requested feature. What use case does it solve?

#### 💻 Example Usage

Include a strawman example of how a user might use this new feature, and what
the output would look like.

#### 🙌 Are you interested in implementing this feature?

Add an "X" to one of the following:

* [ ] Yes
* [ ] Yes if I had a mentor to help me
* [ ] No

'''
'''--- .rustfmt.toml ---
# We do not merge derives because of `twiggy-opt` and its build script.
# Merging derives in `opt/definitions` will break the wasm api.
merge_derives = false

'''
'''--- .travis.yml ---
language: rust
cache: cargo

rust:
  - stable
  - beta
  - nightly

env:
  matrix:
    - JOB="test"

matrix:
  fast_finish: true
  include:
    - rust: nightly
      env: JOB="wasm"
    # Build and deploy the mdbook guide.
    - rust: stable
      env: JOB="guide"
      before_script:
        - (test -x $HOME/.cargo/bin/cargo-install-update || cargo install cargo-update)
        - (test -x $HOME/.cargo/bin/mdbook || cargo install --vers "^0.2" mdbook)
        - cargo install-update -a
      script:
        - cd guide && mdbook build
      deploy:
        provider: pages
        skip-cleanup: true
        github-token: $GITHUB_TOKEN
        local-dir: guide/book
        keep-history: false
        on:
          branch: master
    - rust: stable
      env: JOB="format"
      before_script:
        - rustup component add rustfmt --toolchain stable
      script:
        - cargo fmt -- --check
    - rust: stable
      env: JOB="lint"
      before_script:
        - rustup component add clippy --toolchain stable
      script:
        - cargo clippy -- -D warnings
  allow_failures:
    - rust: stable
      env: JOB="lint"

script:
  - ./ci/script.sh

'''
'''--- CHANGELOG.md ---
### 0.6.0

Released 2019-06-27.

* Merge Wasm function and code entries into a single item in results. This
  means that output that used to look like:

      387 ┊     13.74% ┊ func[2]
      378 ┊     13.42% ┊   ⤷ wee_alloc::alloc_with_refill::hb32c1bbce9ebda8e
      226 ┊      8.02% ┊       ⤷ func[3]
      225 ┊      7.99% ┊           ⤷ wee_alloc::alloc_first_fit::h9a72de3af77ef93f

  Will simply appear like this from now on:

      387 ┊     13.74% ┊ wee_alloc::alloc_with_refill::hb32c1bbce9ebda8e
      226 ┊      8.02% ┊   ⤷ wee_alloc::alloc_first_fit::h9a72de3af77ef93f

  Why merge them into a single item? They are physically split at the binary
  level to allow parallel type checking of individual functions, since the
  checker knows all function's types by the time it has their code bodies. But
  despite being split, there is always a one-to-one relationship between
  function entries and code entries. They are logically part of the "same"
  thing, and there is no deduplication or sharing going on here that makes it so
  it makes sense for Twiggy to talk about them separately. Finally, merging them
  together means that results are presented in a more readable and more compact
  way. Win-win!

### 0.5.0

Released 2019-05-15.

* Switched from using the `parity-wasm` crate to the `wasmparser` crate for
  parsing WebAssembly binaries. The `wasmparser` crate is lower-level and
  (crucially) exposes byte offsets for the things it parses. **Ultimately, this
  enables Twiggy to account for a much higher percentage (near 100% now) of
  where the Wasm binary's size is coming from.**

* Added a summary of unreachable items to the dominator tree output. These are
  the items that are not children anywhere in the dominator tree.

* Properly detects Wasm binaries when the extension is not `.wasm` by using the
  Wasm magic header.

### 0.4.0

Released 2019-02-02.

* Add the ability to explicitly opt into using the experimental DWARF support.

* Summarize and hide potential false-positive garbage items.

* Fix a bug where non-C++ symbols were being demangled as C++ symbols
  incorrectly.

### 0.3.0

Released 2018/10/03.

* Twiggy has [a users guide](https://rustwasm.github.io/twiggy) now! [#170][]

* Added experimental, work-in-progress support for ELF and Mach-O binaries when
  they have DWARF debug info. [#74][]

* All subcommands default to displaying a maximum of 10 items at a time
  now. Additionally, they show a summary of the size and count of all the items
  that are not displayed. [#94][] [#98][] [#103][] [#113][]

* Added the `-a`/`--all` flag to `twiggy garbage` to display all garbage items
  without any max limit. [#118][]

* Added the `-a`/`--all`, `--all-generics`, and `--all-monos` flags to `twiggy
  monos` to list all generic functions, all monomorphizations of generic
  functions, and all of both generics and their monomorphizations. [#120][]

* Added support for using regexes to find the difference in particular function
  sizes with `twiggy diff --regex`. [#129][]

* Fixed a bug where wasm table elements referencing imported functions would
  cause integer underflow. [#151][]

* Consider wasm tables roots in the graph, and make edges table -> element,
  rather than element -> table. The latter is because a table logically owns its
  elements, not the other way around. The former is because dynamic virtual
  calls are not statically analyzable, so we have to consider all virtual
  functions (aka function table elements) as psuedo-roots in the graph. These
  two changes allow us to see when the table is heavy in the dominator tree
  because a bunch of dynamic indirect calls that may or may not be possible at
  run time are entrained in the function table because the compiler/linker
  couldn't statically prove that they won't happen. [#153][]

[#74]: https://github.com/rustwasm/twiggy/pull/74
[#94]: https://github.com/rustwasm/twiggy/pull/94
[#98]: https://github.com/rustwasm/twiggy/pull/98
[#103]: https://github.com/rustwasm/twiggy/pull/103
[#113]: https://github.com/rustwasm/twiggy/pull/113
[#118]: https://github.com/rustwasm/twiggy/pull/118
[#120]: https://github.com/rustwasm/twiggy/pull/120
[#129]: https://github.com/rustwasm/twiggy/pull/129
[#151]: https://github.com/rustwasm/twiggy/pull/151
[#153]: https://github.com/rustwasm/twiggy/pull/153
[#170]: https://github.com/rustwasm/twiggy/pull/170

### 0.2.0

Released 2018/06/25.

* Added [@data-pup][] to the Twiggy team! \o/

* Added the `twiggy diff` subcommand to compare two versions of the same
  binary. [#49][] [#12][]

* Added the `twiggy garbage` subcommand to list code and data that is not
  transitively referenced by any exports / public functions. [#48][] [#50][]

* Added the ability to emit results as CSV. Pass the `--format csv` flags. [#44][]

* `twiggy paths` will now default to printing the paths to all items if no
  specific item is given as an argument. [#57][] [#63][]

* Added a `--regex` option to `twiggy paths` and `twiggy dominators`. This
  allows you to filter items by regexp, for example to only list items matching
  `std::.*`. [#58][] [#65][] [#59][] [#68][]

[#49]: https://github.com/rustwasm/twiggy/pull/49
[#12]: https://github.com/rustwasm/twiggy/issues/12
[#50]: https://github.com/rustwasm/twiggy/pull/50
[#48]: https://github.com/rustwasm/twiggy/issues/48
[#57]: https://github.com/rustwasm/twiggy/issues/57
[#63]: https://github.com/rustwasm/twiggy/pull/63
[#44]: https://github.com/rustwasm/twiggy/pull/44
[#65]: https://github.com/rustwasm/twiggy/pull/65
[#58]: https://github.com/rustwasm/twiggy/issues/58
[#58]: https://github.com/rustwasm/twiggy/issues/59
[#68]: https://github.com/rustwasm/twiggy/pull/68
[@data-pup]: https://github.com/data-pup

### 0.1.0

Released 2018/05/03.

* Initial release!

'''
'''--- CONTRIBUTING.md ---
# Contributing to `twiggy`

[Read the "Contributing to Twiggy" section of the Twiggy guide!](https://rustwasm.github.io/twiggy/contributing/index.html)

'''
'''--- Cargo.toml ---
[workspace]
members = [
  "./analyze",
  "./ir",
  "./opt",
  "./parser",
  "./twiggy",
  "./traits",
  "./wasm-api"
]

[profile.release]
codegen-units = 1
debug = true
incremental = false
lto = true
opt-level = "s"

'''
'''--- README.md ---
<div align="center">

  <h1>Twiggy🌱</h1>

  <strong>A code size profiler for Wasm</strong>

  <p>
    <a href="https://docs.rs/twiggy/"><img src="https://docs.rs/twiggy/badge.svg"/></a>
    <a href="https://crates.io/crates/twiggy"><img src="https://img.shields.io/crates/v/twiggy.svg"/></a>
    <a href="https://crates.io/crates/twiggy"><img src="https://img.shields.io/crates/d/twiggy.svg"/></a>
    <a href="https://travis-ci.org/rustwasm/twiggy"><img src="https://travis-ci.org/rustwasm/twiggy.svg?branch=master"/></a>
  </p>

  <h3>
    <a href="https://rustwasm.github.io/twiggy">Guide</a>
    <span> | </span>
    <a href="https://rustwasm.github.io/twiggy/contributing/index.html">Contributing</a>
    <span> | </span>
    <a href="https://discordapp.com/channels/442252698964721669/443151097398296587">Chat</a>
  </h3>

  <sub>Built with 🦀🕸 by <a href="https://rustwasm.github.io/">The Rust and WebAssembly Working Group</a></sub>
</div>

## About

Twiggy is a code size profiler for Wasm. It analyzes a binary's call graph to
answer questions like:

* Why was this function included in the binary in the first place? Who calls it?

* What is the *retained size* of this function? I.e. how much space would be
  saved if I removed it and all the functions that become dead code after its
  removal.

Use Twiggy to make your binaries slim!

## Install Twiggy

Ensure that you have [the Rust toolchain installed](https://www.rust-lang.org/),
then run:

```
cargo install twiggy
```

## Learn More!

[**Read the Twiggy guide!**](https://rustwasm.github.io/twiggy)

<div align="center">
  <img src="./guide/src/twiggy.png"/>
</div>

'''
'''--- analyze/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = []
description = "Analyses for the Twiggy code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy-analyze"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[lib]
path = "./analyze.rs"

[dependencies]
twiggy-ir = { version = "=0.6.0", path = "../ir" }
twiggy-opt = { version = "=0.6.0", path = "../opt", default-features = false }
twiggy-traits = { version = "=0.6.0", path = "../traits" }
csv = "1.1.3"
regex = "1.3.9"
serde = "1.0.114"
serde_derive = "1.0.114"
petgraph = "0.5.1"

[features]
default = ["emit_csv", "emit_json", "emit_text"]
emit_json = ["twiggy-traits/emit_json"]
emit_csv = ["twiggy-traits/emit_csv"]
emit_text = ["twiggy-traits/emit_text"]

'''
'''--- analyze/analyses/diff.rs ---
use std::cmp;
use std::collections::{HashMap, HashSet};
use std::io;

use csv;
use regex;
use serde::{self, ser::SerializeStruct};

use crate::formats::json;
use crate::formats::table::{Align, Table};
use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

#[derive(Debug)]
struct Diff {
    deltas: Vec<DiffEntry>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct DiffEntry {
    name: String,
    delta: i64,
}

impl PartialOrd for DiffEntry {
    fn partial_cmp(&self, rhs: &DiffEntry) -> Option<cmp::Ordering> {
        Some(self.cmp(rhs))
    }
}

impl Ord for DiffEntry {
    fn cmp(&self, rhs: &DiffEntry) -> cmp::Ordering {
        rhs.delta
            .abs()
            .cmp(&self.delta.abs())
            .then(self.name.cmp(&rhs.name))
    }
}

impl serde::Serialize for DiffEntry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut state = serializer.serialize_struct("DiffEntry", 2)?;
        state.serialize_field("DeltaBytes", &format!("{:+}", self.delta))?;
        state.serialize_field("Item", &self.name)?;
        state.end()
    }
}

impl traits::Emit for Diff {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, _items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut table = Table::with_header(vec![
            (Align::Right, "Delta Bytes".into()),
            (Align::Left, "Item".to_string()),
        ]);

        self.deltas
            .iter()
            .map(|entry| vec![format!("{:+}", entry.delta), entry.name.clone()])
            .for_each(|row| table.add_row(row));

        write!(dest, "{}", &table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, _items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut arr = json::array(dest)?;

        for entry in &self.deltas {
            let mut obj = arr.object()?;
            obj.field("delta_bytes", entry.delta as f64)?;
            obj.field("name", entry.name.as_str())?;
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, _items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut wtr = csv::Writer::from_writer(dest);

        for entry in &self.deltas {
            wtr.serialize(entry)?;
            wtr.flush()?;
        }

        Ok(())
    }
}

/// Compute the diff between two sets of items.
pub fn diff(
    old_items: &mut ir::Items,
    new_items: &mut ir::Items,
    opts: &opt::Diff,
) -> Result<Box<dyn traits::Emit>, traits::Error> {
    let max_items = opts.max_items() as usize;

    // Given a set of items, create a HashMap of the items' names and sizes.
    fn get_names_and_sizes(items: &ir::Items) -> HashMap<&str, i64> {
        items
            .iter()
            .map(|item| (item.name(), i64::from(item.size())))
            .collect()
    }

    // Collect the names and sizes of the items in the old and new collections.
    let old_sizes = get_names_and_sizes(old_items);
    let new_sizes = get_names_and_sizes(new_items);

    // Given an item name, create a `DiffEntry` object representing the
    // change in size, or an error if the name could not be found in
    // either of the item collections.
    let get_item_delta = |name: String| -> Result<DiffEntry, traits::Error> {
        let old_size = old_sizes.get::<str>(&name);
        let new_size = new_sizes.get::<str>(&name);
        let delta: i64 = match (old_size, new_size) {
            (Some(old_size), Some(new_size)) => new_size - old_size,
            (Some(old_size), None) => -old_size,
            (None, Some(new_size)) => *new_size,
            (None, None) => {
                return Err(traits::Error::with_msg(format!(
                    "Could not find item with name `{}`",
                    name
                )));
            }
        };
        Ok(DiffEntry { name, delta })
    };

    // Given a result returned by `get_item_delta`, return false if the result
    // represents an unchanged item. Ignore errors, these are handled separately.
    let unchanged_items_filter = |res: &Result<DiffEntry, traits::Error>| -> bool {
        if let Ok(DiffEntry { delta: 0, .. }) = res {
            false
        } else {
            true
        }
    };

    // Create a set of item names from the new and old item collections.
    let names = old_sizes
        .keys()
        .chain(new_sizes.keys())
        .map(|k| k.to_string());

    // If arguments were given to the command, we should filter out items that
    // do not match any of the given names or expressions.
    let names: HashSet<String> = if !opts.items().is_empty() {
        if opts.using_regexps() {
            let regexps = regex::RegexSet::new(opts.items())?;
            names.filter(|name| regexps.is_match(name)).collect()
        } else {
            let item_names = opts.items().iter().collect::<HashSet<_>>();
            names.filter(|name| item_names.contains(&name)).collect()
        }
    } else {
        names.collect()
    };

    // Iterate through the set of item names, and use the closure above to map
    // each item into a `DiffEntry` object. Then, sort the collection.
    let mut deltas = names
        .into_iter()
        .map(get_item_delta)
        .filter(unchanged_items_filter)
        .collect::<Result<Vec<_>, traits::Error>>()?;
    deltas.sort();

    // Create an entry to summarize the diff rows that will be truncated.
    let (rem_cnt, rem_delta): (u32, i64) = deltas
        .iter()
        .skip(max_items)
        .fold((0, 0), |(cnt, rem_delta), DiffEntry { delta, .. }| {
            (cnt + 1, rem_delta + delta)
        });
    let remaining = DiffEntry {
        name: format!("... and {} more.", rem_cnt),
        delta: rem_delta,
    };

    // Create a `DiffEntry` representing the net change, and total row count.
    // If specifying arguments were not given, calculate the total net changes,
    // otherwise find the total values only for items in the the deltas collection.
    let (total_cnt, total_delta) = if opts.items().is_empty() {
        (
            deltas.len(),
            i64::from(new_items.size()) - i64::from(old_items.size()),
        )
    } else {
        deltas
            .iter()
            .fold((0, 0), |(cnt, rem_delta), DiffEntry { delta, .. }| {
                (cnt + 1, rem_delta + delta)
            })
    };
    let total = DiffEntry {
        name: format!("Σ [{} Total Rows]", total_cnt),
        delta: total_delta,
    };

    // Now that the 'remaining' and 'total' summary entries have been created,
    // truncate the vector of deltas before we box up the result, and push
    // the remaining and total rows to the deltas vector.
    deltas.truncate(max_items);
    if rem_cnt > 0 {
        deltas.push(remaining);
    }
    deltas.push(total);

    // Return the results so that they can be emitted.
    let diff = Diff { deltas };
    Ok(Box::new(diff) as Box<_>)
}

'''
'''--- analyze/analyses/dominators/emit.rs ---
use std::collections::BTreeMap;
use std::io;

use csv;
use serde_derive::Serialize;

use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

use super::UnreachableItemsSummary;
use crate::analyses::dominators::DominatorTree;
use crate::formats::json;
use crate::formats::table::{Align, Table};

impl traits::Emit for DominatorTree {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut table = Table::with_header(vec![
            (Align::Right, "Retained Bytes".to_string()),
            (Align::Right, "Retained %".to_string()),
            (Align::Left, "Dominator Tree".to_string()),
        ]);

        let opts = &self.opts;
        let mut row = 0 as u32;

        fn recursive_add_rows(
            table: &mut Table,
            items: &ir::Items,
            dominator_tree: &BTreeMap<ir::Id, Vec<ir::Id>>,
            depth: u32,
            mut row: &mut u32,
            opts: &opt::Dominators,
            id: ir::Id,
        ) {
            assert_eq!(id == items.meta_root(), depth == 0);

            if *row > opts.max_rows() || depth > opts.max_depth() {
                return;
            }

            if depth > 0 {
                add_text_item(items, depth, id, table);
            }

            if let Some(children) = dominator_tree.get(&id) {
                let mut children = children.to_vec();
                children.sort_by(|a, b| items.retained_size(*b).cmp(&items.retained_size(*a)));
                for child in children {
                    *row += 1;
                    recursive_add_rows(
                        table,
                        items,
                        dominator_tree,
                        depth + 1,
                        &mut row,
                        &opts,
                        child,
                    );
                }
            }
        }

        for id in &self.items {
            let start_depth = if *id == items.meta_root() { 0 } else { 1 };
            recursive_add_rows(
                &mut table,
                items,
                &self.tree,
                start_depth,
                &mut row,
                &opts,
                *id,
            );
        }

        if let Some(UnreachableItemsSummary {
            count,
            size,
            size_percent,
        }) = self.unreachable_items_summary
        {
            table.add_row(vec![
                size.to_string(),
                format!("{:.2}%", size_percent),
                format!("[{} Unreachable Items]", count),
            ]);
        }

        write!(dest, "{}", &table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        fn recursive_add_children(
            items: &ir::Items,
            opts: &opt::Dominators,
            dominator_tree: &BTreeMap<ir::Id, Vec<ir::Id>>,
            id: ir::Id,
            obj: &mut json::Object,
        ) -> Result<(), traits::Error> {
            add_json_item(items, id, obj)?;

            if let Some(children) = dominator_tree.get(&id) {
                let mut children = children.to_vec();
                children.sort_by(|a, b| items.retained_size(*b).cmp(&items.retained_size(*a)));

                let mut arr = obj.array("children")?;
                for child in children {
                    let mut obj = arr.object()?;
                    recursive_add_children(items, opts, dominator_tree, child, &mut obj)?;
                }
            }

            Ok(())
        }

        // Scoping the borrow of `arr` so we can get another object in the next block
        let mut obj = json::object(dest)?;
        {
            let mut arr = obj.array("items")?;
            for curr_id in &self.items {
                let mut item = arr.object()?;
                recursive_add_children(items, &self.opts, &self.tree, *curr_id, &mut item)?;
            }
        }

        if let Some(UnreachableItemsSummary {
            count,
            size,
            size_percent,
        }) = self.unreachable_items_summary
        {
            let mut summary_obj = obj.array("summary")?;
            let mut unreachable_items_obj = summary_obj.object()?;
            unreachable_items_obj
                .field("name", format!("[{} Unreachable Items]", count).as_ref())?;
            unreachable_items_obj.field("retained_size", size)?;
            unreachable_items_obj.field("retained_size_percent", size_percent)?;
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        fn recursive_add_children(
            items: &ir::Items,
            opts: &opt::Dominators,
            dominator_tree: &BTreeMap<ir::Id, Vec<ir::Id>>,
            id: ir::Id,
            wtr: &mut csv::Writer<&mut dyn io::Write>,
        ) -> Result<(), traits::Error> {
            add_csv_item(items, id, wtr)?;
            if let Some(children) = dominator_tree.get(&id) {
                let mut children = children.to_vec();
                children.sort_by(|a, b| items.retained_size(*b).cmp(&items.retained_size(*a)));
                for child in children {
                    recursive_add_children(items, opts, dominator_tree, child, wtr)?;
                }
            }
            Ok(())
        }

        let mut wtr = csv::Writer::from_writer(dest);
        recursive_add_children(items, &self.opts, &self.tree, items.meta_root(), &mut wtr)?;

        if let Some(UnreachableItemsSummary {
            count,
            size,
            size_percent,
        }) = self.unreachable_items_summary
        {
            let rc = CsvRecord {
                id: None,
                name: format!("[{} Unreachable Items]", count),
                shallow_size: size,
                shallow_size_percent: size_percent,
                retained_size: size,
                retained_size_percent: size_percent,
                immediate_dominator: None,
            };
            wtr.serialize(rc)?;
            wtr.flush()?;
        }

        Ok(())
    }
}

#[cfg(feature = "emit_text")]
fn add_text_item(items: &ir::Items, depth: u32, id: ir::Id, table: &mut Table) {
    let item = &items[id];

    let size = items.retained_size(id);
    let size_percent = (f64::from(size)) / (f64::from(items.size())) * 100.0;

    let mut label = String::with_capacity(depth as usize * 4 + item.name().len() + "⤷ ".len());
    for _ in 2..depth {
        label.push_str("    ");
    }
    if depth != 1 {
        label.push_str("  ⤷ ");
    }
    label.push_str(item.name());

    table.add_row(vec![
        size.to_string(),
        format!("{:.2}%", size_percent),
        label,
    ]);
}

#[cfg(feature = "emit_json")]
fn add_json_item(
    items: &ir::Items,
    id: ir::Id,
    obj: &mut json::Object,
) -> Result<(), traits::Error> {
    let item = &items[id];

    obj.field("name", item.name())?;

    let shallow_size = item.size();
    let shallow_size_percent = f64::from(shallow_size) / f64::from(items.size()) * 100.0;
    obj.field("shallow_size", shallow_size)?;
    obj.field("shallow_size_percent", shallow_size_percent)?;

    let retained_size = items.retained_size(id);
    let retained_size_percent = f64::from(retained_size) / f64::from(items.size()) * 100.0;
    obj.field("retained_size", retained_size)?;
    obj.field("retained_size_percent", retained_size_percent)?;
    Ok(())
}

#[cfg(feature = "emit_csv")]
#[derive(Serialize, Debug)]
#[serde(rename_all = "PascalCase")]
struct CsvRecord {
    pub id: Option<u64>,
    pub name: String,
    pub shallow_size: u32,
    pub shallow_size_percent: f64,
    pub retained_size: u32,
    pub retained_size_percent: f64,
    pub immediate_dominator: Option<u64>,
}

#[cfg(feature = "emit_csv")]
fn add_csv_item(
    items: &ir::Items,
    id: ir::Id,
    wtr: &mut csv::Writer<&mut dyn io::Write>,
) -> Result<(), traits::Error> {
    let item = &items[id];
    let (shallow_size, shallow_size_percent) = (
        item.size(),
        f64::from(item.size()) / f64::from(items.size()) * 100.0,
    );
    let (retained_size, retained_size_percent) = (
        items.retained_size(id),
        f64::from(items.retained_size(id)) / f64::from(items.size()) * 100.0,
    );
    let idom = if let Some(idom) = items.immediate_dominators().get(&id) {
        idom.serializable()
    } else {
        id.serializable()
    };

    let rc = CsvRecord {
        id: Some(item.id().serializable()),
        name: item.name().to_string(),
        shallow_size,
        shallow_size_percent,
        retained_size,
        retained_size_percent,
        immediate_dominator: Some(idom),
    };

    wtr.serialize(rc)?;
    wtr.flush()?;
    Ok(())
}

'''
'''--- analyze/analyses/dominators/mod.rs ---
use std::collections::BTreeMap;

use regex;

use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

use crate::analyses::garbage;

mod emit;

struct DominatorTree {
    tree: BTreeMap<ir::Id, Vec<ir::Id>>,
    items: Vec<ir::Id>,
    opts: opt::Dominators,
    unreachable_items_summary: Option<UnreachableItemsSummary>,
}

struct UnreachableItemsSummary {
    count: usize,
    size: u32,
    size_percent: f64,
}

/// Compute the dominator tree for the given IR graph.
pub fn dominators(
    items: &mut ir::Items,
    opts: &opt::Dominators,
) -> Result<Box<dyn traits::Emit>, traits::Error> {
    items.compute_dominator_tree();
    items.compute_dominators();
    items.compute_retained_sizes();
    items.compute_predecessors();

    let arguments = opts.items();
    let dominator_items = if arguments.is_empty() {
        vec![items.meta_root()]
    } else if opts.using_regexps() {
        let regexps = regex::RegexSet::new(arguments)?;
        let mut sorted_items: Vec<_> = items
            .iter()
            .filter(|item| regexps.is_match(&item.name()))
            .map(|item| item.id())
            .collect();
        sorted_items.sort_by_key(|id| -i64::from(items.retained_size(*id)));
        sorted_items
    } else {
        arguments
            .iter()
            .filter_map(|name| items.get_item_by_name(name))
            .map(|item| item.id())
            .collect()
    };

    let tree = DominatorTree {
        tree: items.dominator_tree().clone(),
        items: dominator_items,
        opts: opts.clone(),
        unreachable_items_summary: summarize_unreachable_items(items, opts),
    };

    Ok(Box::new(tree) as Box<_>)
}

fn summarize_unreachable_items(
    items: &mut ir::Items,
    opts: &opt::Dominators,
) -> Option<UnreachableItemsSummary> {
    let (size, count) = garbage::get_unreachable_items(&items)
        .map(|item| item.size())
        .fold((0, 0), |(s, c), curr| (s + curr, c + 1));
    if opts.items().is_empty() && size > 0 {
        Some(UnreachableItemsSummary {
            count,
            size,
            size_percent: (f64::from(size)) / (f64::from(items.size())) * 100.0,
        })
    } else {
        None
    }
}

'''
'''--- analyze/analyses/garbage.rs ---
use std::collections::BTreeSet;
use std::io;

use petgraph::visit::Walker;

use crate::formats::json;
use crate::formats::table::{Align, Table};
use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

#[derive(Debug)]
struct Garbage {
    items: Vec<ir::Id>,
    data_segments: Vec<ir::Id>,
    limit: usize,
}

impl traits::Emit for Garbage {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut table = Table::with_header(vec![
            (Align::Right, "Bytes".to_string()),
            (Align::Right, "Size %".to_string()),
            (Align::Left, "Garbage Item".to_string()),
        ]);
        let items_iter = self.items.iter().map(|id| &items[*id]);

        for item in items_iter.clone().take(self.limit) {
            let size = item.size();
            let size_percent = (f64::from(size)) / (f64::from(items.size())) * 100.0;
            table.add_row(vec![
                size.to_string(),
                format!("{:.2}%", size_percent),
                item.name().to_string(),
            ]);
        }

        match items_iter
            .clone()
            .skip(self.limit)
            .fold((0, 0), |(size, cnt), item| (size + item.size(), cnt + 1))
        {
            (size, cnt) if cnt > 0 => {
                let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;
                table.add_row(vec![
                    size.to_string(),
                    format!("{:.2}%", size_percent),
                    format!("... and {} more", cnt),
                ]);
            }
            _ => {}
        }

        let total_size: u32 = items_iter.map(|item| item.size()).sum();
        let total_percent = (f64::from(total_size)) / (f64::from(items.size())) * 100.0;
        table.add_row(vec![
            total_size.to_string(),
            format!("{:.2}%", total_percent),
            format!("Σ [{} Total Rows]", self.items.len()),
        ]);

        if !self.data_segments.is_empty() {
            let total_size: u32 = self.data_segments.iter().map(|&id| items[id].size()).sum();
            let size_percent = f64::from(total_size) / f64::from(items.size()) * 100.0;
            table.add_row(vec![
                total_size.to_string(),
                format!("{:.2}%", size_percent),
                format!(
                    "{} potential false-positive data segments",
                    self.data_segments.len()
                ),
            ]);
        }

        write!(dest, "{}", &table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut arr = json::array(dest)?;

        for &id in self.items.iter().take(self.limit) {
            let item = &items[id];

            let mut obj = arr.object()?;
            obj.field("name", item.name())?;

            let size = item.size();
            let size_percent = (f64::from(size)) / (f64::from(items.size())) * 100.0;
            obj.field("bytes", size)?;
            obj.field("size_percent", size_percent)?;
        }

        let (total_size, total_cnt) = self
            .items
            .iter()
            .skip(self.limit)
            .map(|id| &items[*id])
            .fold((0, 0), |(size, cnt), item| (size + item.size(), cnt + 1));
        if total_cnt > 0 {
            let name = format!("... and {} more", total_cnt);
            let total_size_percent = (f64::from(total_size)) / (f64::from(items.size())) * 100.0;
            let mut obj = arr.object()?;
            obj.field("name", name.as_str())?;
            obj.field("bytes", total_size)?;
            obj.field("size_percent", total_size_percent)?;
        }

        // Scoping the borrow of `arr` so we can get another object in the next block
        {
            let total_name = format!("Σ [{} Total Rows]", self.items.len());
            let total_size: u32 = self.items.iter().map(|&id| items[id].size()).sum();
            let total_size_percent = (f64::from(total_size)) / (f64::from(items.size())) * 100.0;
            let mut obj = arr.object()?;
            obj.field("name", total_name.as_str())?;
            obj.field("bytes", total_size)?;
            obj.field("size_percent", total_size_percent)?;
        }

        if !self.data_segments.is_empty() {
            let name = format!(
                "{} potential false-positive data segments",
                self.data_segments.len()
            );
            let size: u32 = self.data_segments.iter().map(|&id| items[id].size()).sum();
            let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;

            let mut obj = arr.object()?;
            obj.field("name", name.as_str())?;
            obj.field("bytes", size)?;
            obj.field("size_percent", size_percent)?;
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, _items: &ir::Items, _dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        unimplemented!();
    }
}

/// Find items that are not transitively referenced by any exports or public functions.
pub fn garbage(
    items: &ir::Items,
    opts: &opt::Garbage,
) -> Result<Box<dyn traits::Emit>, traits::Error> {
    let mut unreachable_items = get_unreachable_items(&items).collect::<Vec<_>>();
    unreachable_items.sort_by(|a, b| b.size().cmp(&a.size()));

    // Split the items into two categories if necessary
    let (data_segments, items_non_data) = if opts.show_data_segments() {
        (
            vec![],
            unreachable_items.iter().map(|item| item.id()).collect(),
        )
    } else {
        (
            unreachable_items
                .iter()
                .filter(|item| item.kind().is_data())
                .map(|item| item.id())
                .collect(),
            unreachable_items
                .iter()
                .filter(|item| !item.kind().is_data())
                .map(|item| item.id())
                .collect(),
        )
    };

    let garbage_items = Garbage {
        items: items_non_data,
        data_segments,
        limit: opts.max_items() as usize,
    };

    Ok(Box::new(garbage_items) as Box<_>)
}

pub(crate) fn get_unreachable_items(items: &ir::Items) -> impl Iterator<Item = &ir::Item> {
    let reachable_items = petgraph::visit::Dfs::new(items, items.meta_root())
        .iter(&items)
        .collect::<BTreeSet<ir::Id>>();
    items
        .iter()
        .filter(move |item| !reachable_items.contains(&item.id()))
}

'''
'''--- analyze/analyses/mod.rs ---
pub mod diff;
pub mod dominators;
pub mod garbage;
pub mod monos;
pub mod paths;
pub mod top;

'''
'''--- analyze/analyses/monos/emit.rs ---
use std::io;
use std::iter;

use csv;
use serde_derive::Serialize;

use crate::formats::json;
use crate::formats::table::{Align, Table};
use twiggy_ir as ir;
use twiggy_traits as traits;

use super::entry::MonosEntry;
use super::Monos;

impl traits::Emit for Monos {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        struct TableRow {
            bloat: Option<u32>,
            bloat_percent: Option<f64>,
            size: u32,
            size_percent: f64,
            name: String,
        };

        // Given an entry representing a generic function and its various
        // monomorphizations, return a vector of table rows.
        fn process_entry<'a>(
            entry: &'a MonosEntry,
            total_size: f64,
        ) -> impl Iterator<Item = TableRow> + 'a {
            let MonosEntry {
                name,
                insts,
                size,
                bloat,
            } = entry;

            let get_size_percent = move |x: u32| f64::from(x) / total_size * 100.0;

            iter::once(TableRow {
                bloat: Some(*bloat),
                bloat_percent: Some(get_size_percent(*bloat)),
                size: *size,
                size_percent: get_size_percent(*size),
                name: name.to_string(),
            })
            .chain(insts.iter().map(move |(name, size)| TableRow {
                bloat: None,
                bloat_percent: None,
                size: *size,
                size_percent: get_size_percent(*size),
                name: format!("    {}", name),
            }))
        }

        let mut table = Table::with_header(vec![
            (Align::Right, "Apprx. Bloat Bytes".into()),
            (Align::Right, "Apprx. Bloat %".into()),
            (Align::Right, "Bytes".into()),
            (Align::Right, "%".into()),
            (Align::Left, "Monomorphizations".to_string()),
        ]);

        for TableRow {
            bloat,
            bloat_percent,
            size,
            size_percent,
            name,
        } in self
            .monos
            .iter()
            .flat_map(|mono| process_entry(mono, f64::from(items.size())))
        {
            table.add_row(vec![
                bloat.map(|b| b.to_string()).unwrap_or_default(),
                bloat_percent
                    .map(|b| format!("{:.2}%", b))
                    .unwrap_or_default(),
                size.to_string(),
                format!("{:.2}%", size_percent),
                name.clone(),
            ]);
        }
        write!(dest, "{}", &table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        // Given an entry representing a generic function and its various
        // monomorphizations, add its information to the given JSON object.
        fn process_entry(
            entry: &MonosEntry,
            obj: &mut json::Object,
            total_size: f64,
        ) -> Result<(), traits::Error> {
            let get_size_percent = |size: u32| (f64::from(size)) / total_size * 100.0;
            let MonosEntry {
                name,
                insts,
                size,
                bloat,
            } = entry;
            obj.field("generic", name.as_str())?;
            obj.field("approximate_monomorphization_bloat_bytes", *bloat)?;
            obj.field(
                "approximate_monomorphization_bloat_percent",
                get_size_percent(*bloat),
            )?;
            obj.field("total_size", *size)?;
            obj.field("total_size_percent", get_size_percent(*size))?;
            let mut monos = obj.array("monomorphizations")?;
            for (name, size, size_percent) in insts
                .iter()
                .map(|(name, size)| (name, size, get_size_percent(*size)))
            {
                let mut obj = monos.object()?;
                obj.field("name", name.as_str())?;
                obj.field("shallow_size", *size)?;
                obj.field("shallow_size_percent", size_percent)?;
            }
            Ok(())
        };

        let items_size = f64::from(items.size());
        let mut arr = json::array(dest)?;
        for entry in &self.monos {
            let mut obj = arr.object()?;
            process_entry(entry, &mut obj, items_size)?;
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        // Calculate the total size of the collection of items, and define a
        // helper closure to calculate a percent value for a given u32 size.
        let items_size = f64::from(items.size());
        let get_size_percent = |size: u32| (f64::from(size)) / items_size * 100.0;

        #[derive(Debug, Default, Serialize)]
        #[serde(rename_all = "PascalCase")]
        struct Record {
            generic: Option<String>,
            approximate_monomorphization_bloat_bytes: Option<u32>,
            approximate_monomorphization_bloat_percent: Option<f64>,
            total_size: Option<u32>,
            total_size_percent: Option<f64>,
            monomorphizations: Option<String>,
        }

        // Given a single `MonosEntry` object, create a record object.
        let process_entry = |entry: &MonosEntry| -> Record {
            let monos = entry
                .insts
                .iter()
                .map(|(name, _)| name.as_str())
                .collect::<Vec<_>>();
            Record {
                generic: Some(entry.name.clone()),
                approximate_monomorphization_bloat_bytes: Some(entry.bloat),
                approximate_monomorphization_bloat_percent: Some(get_size_percent(entry.bloat)),
                total_size: Some(entry.size),
                total_size_percent: Some(get_size_percent(entry.size)),
                monomorphizations: Some(monos.join(", ")),
            }
        };

        // Create a CSV writer and iterate through the monomorphization entries.
        // Process each record and pass it to the destination to be serialized.
        let mut wtr = csv::Writer::from_writer(dest);
        for entry in &self.monos {
            let record = process_entry(entry);
            wtr.serialize(record)?;
            wtr.flush()?;
        }
        Ok(())
    }
}

'''
'''--- analyze/analyses/monos/entry.rs ---
#[derive(Debug, PartialEq, Eq)]
pub(super) struct MonosEntry {
    pub name: String,
    pub insts: Vec<(String, u32)>,
    pub size: u32,
    pub bloat: u32,
}

impl PartialOrd for MonosEntry {
    fn partial_cmp(&self, rhs: &MonosEntry) -> Option<std::cmp::Ordering> {
        Some(self.cmp(rhs))
    }
}

impl Ord for MonosEntry {
    fn cmp(&self, rhs: &MonosEntry) -> std::cmp::Ordering {
        rhs.bloat
            .cmp(&self.bloat)
            .then(rhs.size.cmp(&self.size))
            .then(self.insts.cmp(&rhs.insts))
            .then(self.name.cmp(&rhs.name))
    }
}

'''
'''--- analyze/analyses/monos/mod.rs ---
use std::cmp;
use std::collections::{BTreeMap, BTreeSet};

use regex;
use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

mod emit;
mod entry;

use self::entry::MonosEntry;

#[derive(Debug)]
struct Monos {
    monos: Vec<MonosEntry>,
}

/// Type alias used to represent a map of generic function names and instantiations.
type MonosMap<'a> = BTreeMap<&'a str, Vec<(String, u32)>>;

/// Collect the monomorphizations of generic functions into a map, then
/// process the entries and sort the resulting vector.
fn collect_monomorphizations<'a>(
    items: &'a ir::Items,
    opts: &opt::Monos,
) -> Result<MonosMap<'a>, traits::Error> {
    let args_given = !opts.functions().is_empty();
    let using_regexps = opts.using_regexps();
    let regexps = regex::RegexSet::new(opts.functions())?;

    let unsorted_monos: BTreeMap<&'a str, BTreeSet<(String, u32)>> = items
        .iter()
        .filter_map(|item| {
            if let Some(generic) = item.monomorphization_of() {
                Some((generic, item))
            } else {
                None
            }
        })
        .filter(|(generic, _)| match (args_given, using_regexps) {
            (true, true) => regexps.is_match(generic),
            (true, false) => opts.functions().iter().any(|name| name == generic),
            (false, _) => true,
        })
        .fold(BTreeMap::new(), |mut monos, (generic, inst)| {
            monos
                .entry(generic)
                .or_insert_with(BTreeSet::new)
                .insert((inst.name().to_string(), inst.size()));
            monos
        });

    Ok(unsorted_monos
        .into_iter()
        .map(|(generic, inst_set)| {
            let mut insts = inst_set.into_iter().collect::<Vec<_>>();
            insts.sort_by(|(a_name, a_size), (b_name, b_size)| {
                b_size.cmp(a_size).then(a_name.cmp(b_name))
            });
            (generic, insts)
        })
        .collect())
}

/// Helper function usedd to summarize a sequence of `MonosEntry` objects.
/// Returns a tuple representing the number of items summarized, the total
/// size of the items, and the total approximate potential savings.
fn summarize_entries<'a>(entries: impl Iterator<Item = &'a MonosEntry>) -> (usize, u32, u32) {
    entries.fold(
        (0, 0, 0),
        |(total_cnt, total_size, total_savings),
         MonosEntry {
             insts, size, bloat, ..
         }| {
            (
                total_cnt + 1 + insts.len(),
                total_size + size,
                total_savings + bloat,
            )
        },
    )
}

/// Helper function used to summarize a sequence of tuples representing
/// instantiations of a generic function. Returns a tuple representing the
/// number of instantiations found, and the total size.
fn summarize_insts<'a>(entries: impl Iterator<Item = &'a (String, u32)>) -> (u32, u32) {
    entries.fold((0, 0), |(total_cnt, total_size), (_, size)| {
        (total_cnt + 1, total_size + size)
    })
}

/// Find the approximate potential savings by calculating the benefits of
/// removing the largest instantiation, and the benefits of removing an
/// average instantiation. Returns a tuple containing total size, and bloat.
fn calculate_total_and_bloat(insts: &[(String, u32)]) -> Option<(u32, u32)> {
    if let Some(max) = insts.iter().map(|(_, size)| size).max() {
        let total_size = insts.iter().map(|(_, size)| size).sum::<u32>();
        let inst_cnt = insts.len() as u32;
        let size_per_inst = total_size / inst_cnt;
        let avg_savings = size_per_inst * (inst_cnt - 1);
        let removing_largest_savings = total_size - max;
        let approx_potential_savings = cmp::min(avg_savings, removing_largest_savings);
        Some((total_size, approx_potential_savings))
    } else {
        None
    }
}

/// Process all of the monorphizations, into a vector of `MonosEntry` objects.
fn process_monomorphizations(monos_map: MonosMap, opts: &opt::Monos) -> Vec<MonosEntry> {
    let mut monos = monos_map
        .into_iter()
        .filter_map(|(g, insts)| {
            calculate_total_and_bloat(&insts).map(|(total, bloat)| (g, insts, total, bloat))
        })
        .map(|(g, mut insts, t, b)| {
            // Truncate `insts` according to the relevant options before
            // we map these values into `MonosEntry` objects.
            if opts.only_generics() {
                insts.truncate(0);
            } else {
                let max_monos = opts.max_monos() as usize;
                let (rem_cnt, rem_size) = summarize_insts(insts.iter().skip(max_monos));
                insts.truncate(max_monos);
                if rem_cnt > 0 {
                    insts.push((format!("... and {} more.", rem_cnt), rem_size));
                }
            };
            (g, insts, t, b)
        })
        .map(|(name, insts, size, bloat)| MonosEntry {
            name: name.to_string(),
            insts,
            size,
            bloat,
        })
        .collect::<Vec<_>>();
    monos.sort();
    monos
}

/// Adds entries to summarize remaining rows that will be truncated, and
/// totals for the entire set of monomorphizations.
fn add_stats(mut monos: Vec<MonosEntry>, opts: &opt::Monos) -> Vec<MonosEntry> {
    let max_generics = opts.max_generics() as usize;

    // Create an entry to represent the remaining rows that will be truncated,
    // only if there are more generics than we will display.
    let remaining: Option<MonosEntry> = {
        if monos.len() > max_generics {
            let (rem_cnt, rem_size, rem_savings) =
                summarize_entries(monos.iter().skip(max_generics));
            Some(MonosEntry {
                name: format!("... and {} more.", rem_cnt),
                size: rem_size,
                insts: vec![],
                bloat: rem_savings,
            })
        } else {
            None
        }
    };

    // Create an entry to represent the 'total' summary.
    let total = {
        let (total_cnt, total_size, total_savings) = summarize_entries(monos.iter());
        MonosEntry {
            name: format!("Σ [{} Total Rows]", total_cnt),
            size: total_size,
            insts: vec![],
            bloat: total_savings,
        }
    };

    // Truncate the vector, and add the 'remaining' and 'total' summary entries.
    monos.truncate(max_generics);
    if let Some(remaining) = remaining {
        monos.push(remaining);
    }
    monos.push(total);
    monos
}

/// Find bloaty monomorphizations of generic functions.
pub fn monos(
    items: &mut ir::Items,
    opts: &opt::Monos,
) -> Result<Box<dyn traits::Emit>, traits::Error> {
    let monos_map = collect_monomorphizations(&items, &opts)?;
    let mut monos = process_monomorphizations(monos_map, &opts);
    monos = add_stats(monos, &opts);
    Ok(Box::new(Monos { monos }) as Box<_>)
}

'''
'''--- analyze/analyses/paths/mod.rs ---
use std::collections::BTreeSet;

use regex;

use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

mod paths_emit;
mod paths_entry;

use self::paths_entry::PathsEntry;

#[derive(Debug)]
struct Paths {
    opts: opt::Paths,
    entries: Vec<PathsEntry>,
}

/// Find all retaining paths for the given items.
pub fn paths(
    items: &mut ir::Items,
    opts: &opt::Paths,
) -> Result<Box<dyn traits::Emit>, traits::Error> {
    // The predecessor tree only needs to be computed if we are ascending
    // through the retaining paths.
    if !opts.descending() {
        items.compute_predecessors();
    }

    // Initialize the collection of Id values whose retaining paths we will emit.
    let opts = opts.clone();
    let entries = get_starting_positions(&items, &opts)?
        .iter()
        .map(|id| create_entry(*id, &items, &opts, &mut BTreeSet::new()))
        .collect();

    let paths = Paths { opts, entries };

    Ok(Box::new(paths) as Box<_>)
}

/// This helper function is used to collect the `ir::Id` values for the top-most
/// path entries for the `Paths` object, based on the given options.
fn get_starting_positions(
    items: &ir::Items,
    opts: &opt::Paths,
) -> Result<Vec<ir::Id>, traits::Error> {
    // Collect Id's if no arguments are given and we are ascending the retaining paths.
    let get_functions_default = || -> Vec<ir::Id> {
        let mut sorted_items = items
            .iter()
            .filter(|item| item.id() != items.meta_root())
            .collect::<Vec<_>>();
        sorted_items.sort_by(|a, b| b.size().cmp(&a.size()));
        sorted_items.iter().map(|item| item.id()).collect()
    };

    // Collect Id's if no arguments are given and we are descending the retaining paths.
    let get_functions_default_desc = || -> Vec<ir::Id> {
        let mut roots = items
            .neighbors(items.meta_root())
            .map(|id| &items[id])
            .collect::<Vec<_>>();
        roots.sort_by(|a, b| b.size().cmp(&a.size()));
        roots.into_iter().map(|item| item.id()).collect()
    };

    // Collect Id's if arguments were given that should be used as regular expressions.
    let get_regexp_matches = || -> Result<Vec<ir::Id>, traits::Error> {
        let regexps = regex::RegexSet::new(opts.functions())?;
        let matches = items
            .iter()
            .filter(|item| regexps.is_match(&item.name()))
            .map(|item| item.id())
            .collect();
        Ok(matches)
    };

    // Collect Id's if arguments were given that should be used as exact names.
    let get_exact_matches = || -> Vec<ir::Id> {
        opts.functions()
            .iter()
            .filter_map(|s| items.get_item_by_name(s))
            .map(|item| item.id())
            .collect()
    };

    // Collect the starting positions based on the relevant options given.
    // If arguments were given, search for matches depending on whether or
    // not these should be treated as regular expressions. Otherwise, collect
    // the starting positions based on the direction we will be traversing.
    let args_given = !opts.functions().is_empty();
    let using_regexps = opts.using_regexps();
    let descending = opts.descending();
    let res = match (args_given, using_regexps, descending) {
        (true, true, _) => get_regexp_matches()?,
        (true, false, _) => get_exact_matches(),
        (false, _, true) => get_functions_default_desc(),
        (false, _, false) => get_functions_default(),
    };

    Ok(res)
}

/// Create a `PathsEntry` object for the given item.
fn create_entry(
    id: ir::Id,
    items: &ir::Items,
    opts: &opt::Paths,
    seen: &mut BTreeSet<ir::Id>,
) -> PathsEntry {
    // Determine the item's name and size.
    let item = &items[id];
    let name = item.name().to_string();
    let size = item.size();

    // Collect the `ir::Id` values of this entry's children, depending on
    // whether we are ascending or descending the IR-tree.
    let children_ids: Vec<ir::Id> = if opts.descending() {
        items
            .neighbors(id)
            .map(|id| id as ir::Id)
            .filter(|id| !seen.contains(id))
            .filter(|&id| id != items.meta_root())
            .collect()
    } else {
        items
            .predecessors(id)
            .map(|id| id as ir::Id)
            .filter(|id| !seen.contains(id))
            .filter(|&id| id != items.meta_root())
            .collect()
    };

    // Temporarily add the current item to the set of discovered nodes, and
    // create an entry for each child. Collect these into a `children` vector.
    seen.insert(id);
    let children = children_ids
        .into_iter()
        .map(|id| create_entry(id, &items, &opts, seen))
        .collect();
    seen.remove(&id);

    PathsEntry {
        name,
        size,
        children,
    }
}

'''
'''--- analyze/analyses/paths/paths_emit.rs ---
use std::io;

use csv;

use crate::analyses::paths::Paths;
use crate::formats::json;
use crate::formats::table::{Align, Table};
use twiggy_ir as ir;
use twiggy_traits as traits;

impl traits::Emit for Paths {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        use self::emit_text_helpers::{process_entry, TableRow};

        // Flat map each entry and its children into a sequence of table rows.
        // Convert these `TableRow` objects into vectors of strings, and add
        // each of these to the table before writing the table to `dest`.
        let table = self
            .entries
            .iter()
            .flat_map(|entry| {
                process_entry(entry, 0, self.opts.max_paths() as usize, &items, &self.opts)
            })
            .map(
                |TableRow {
                     size,
                     size_percent,
                     name,
                 }| {
                    vec![
                        size.map(|size| size.to_string())
                            .unwrap_or_else(String::new),
                        size_percent
                            .map(|size_percent| format!("{:.2}%", size_percent))
                            .unwrap_or_else(String::new),
                        name,
                    ]
                },
            )
            .fold(
                Table::with_header(vec![
                    (Align::Right, "Shallow Bytes".to_string()),
                    (Align::Right, "Shallow %".to_string()),
                    (Align::Left, "Retaining Paths".to_string()),
                ]),
                |mut table, row| {
                    table.add_row(row);
                    table
                },
            );

        write!(dest, "{}", table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        use self::emit_json_helpers::process_entry;

        // Initialize a JSON array. For each path entry, add a object to the
        // array, and add that entry's information to the new JSON object.
        let mut arr = json::array(dest)?;
        for entry in &self.entries {
            let mut obj = arr.object()?;
            process_entry(
                entry,
                &mut obj,
                0,
                self.opts.max_paths() as usize,
                items,
                &self.opts,
            )?;
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        use self::emit_csv_helpers::process_entry;

        // First, initialize a CSV writer. Then, flat map each entry and its
        // children into a sequence of `CsvRecord` objects. Send each record
        // to the CSV writer to be serialized.
        let mut wtr = csv::Writer::from_writer(dest);
        for record in self.entries.iter().flat_map(|entry| {
            process_entry(entry, 0, self.opts.max_paths() as usize, &items, &self.opts)
        }) {
            wtr.serialize(record)?;
            wtr.flush()?;
        }

        Ok(())
    }
}

/// This module contains helper functions and structs used by the `emit_text`
/// method in Path's implementation of the `traits::Emit` trait.
#[cfg(feature = "emit_text")]
mod emit_text_helpers {
    use crate::analyses::paths::paths_entry::PathsEntry;
    use std::iter;
    use twiggy_ir::Items;
    use twiggy_opt::Paths;

    /// This structure represents a row in the emitted text table. Size, and size
    /// percentage are only shown for the top-most rows.
    pub(super) struct TableRow {
        pub size: Option<u32>,
        pub size_percent: Option<f64>,
        pub name: String,
    }

    /// Process a given path entry, and return an iterator of table rows,
    /// representing its related call paths, according to the given options.
    pub(super) fn process_entry<'a>(
        entry: &'a PathsEntry,
        depth: u32,
        paths: usize,
        items: &'a Items,
        opts: &'a Paths,
    ) -> Box<dyn Iterator<Item = TableRow> + 'a> {
        // Get the row's name and size columns using the current depth.
        let name = get_indented_name(&entry.name, depth, opts.descending());
        let (size, size_percent) = if depth == 0 {
            (
                Some(entry.size),
                Some(f64::from(entry.size) / f64::from(items.size()) * 100.0),
            )
        } else {
            (None, None)
        };

        // Create an iterator containing the current entry's table row.
        let row_iter = iter::once(TableRow {
            size,
            size_percent,
            name,
        });

        if depth < opts.max_depth() {
            // Process each child entry, and chain together the resulting iterators.
            let children_iter = entry
                .children
                .iter()
                .take(paths)
                .flat_map(move |child_entry| {
                    process_entry(child_entry, depth + 1, paths, &items, &opts)
                });
            Box::new(row_iter.chain(children_iter))
        } else if depth == opts.max_depth() {
            // TODO: Create a summary row, and chain it to the row iterator.
            Box::new(row_iter)
        } else {
            // If we are beyond the maximum depth, return an empty iterator.
            Box::new(iter::empty())
        }
    }

    /// Given the name of an item, its depth, and the traversal direction,
    /// return an indented version of the name for its corresponding table row.
    fn get_indented_name(name: &str, depth: u32, descending: bool) -> String {
        (1..depth)
            .map(|_| "    ")
            .chain(iter::once(if depth > 0 && descending {
                "  ↳ "
            } else if depth > 0 {
                "  ⬑ "
            } else {
                ""
            }))
            .chain(iter::once(name))
            .fold(
                String::with_capacity(depth as usize * 4 + name.len()),
                |mut res, s| {
                    res.push_str(s);
                    res
                },
            )
    }
}

/// This module contains helper functions and structs used by the `emit_json`
/// method in Path's implementation of the `traits::Emit` trait.
#[cfg(feature = "emit_json")]
mod emit_json_helpers {
    use crate::analyses::paths::paths_entry::PathsEntry;
    use crate::formats::json::Object;
    use std::io;
    use twiggy_ir::Items;
    use twiggy_opt::Paths;

    // Process a paths entry, by adding its name and size to the given JSON object.
    pub(super) fn process_entry(
        entry: &PathsEntry,
        obj: &mut Object,
        depth: u32,
        paths: usize,
        items: &Items,
        opts: &Paths,
    ) -> io::Result<()> {
        let PathsEntry {
            name,
            size,
            children,
        } = entry;
        obj.field("name", name.as_str())?;
        obj.field("shallow_size", *size)?;
        let size_percent = f64::from(*size) / f64::from(items.size()) * 100.0;
        obj.field("shallow_size_percent", size_percent)?;

        let mut callers = obj.array("callers")?;
        if depth < opts.max_depth() {
            for child in children.iter().take(paths) {
                let mut obj = callers.object()?;
                process_entry(child, &mut obj, depth + 1, paths, items, &opts)?;
            }
        }

        Ok(())
    }
}

/// This module contains helper functions and structs used by the `emit_csv`
/// method in Path's implementation of the `traits::Emit` trait.
#[cfg(feature = "emit_csv")]
mod emit_csv_helpers {
    use crate::analyses::paths::paths_entry::PathsEntry;
    use serde_derive::Serialize;
    use std::iter;
    use twiggy_ir::Items;
    use twiggy_opt::Paths;

    /// This structure represents a row in the CSV output.
    #[derive(Serialize, Debug)]
    #[serde(rename_all = "PascalCase")]
    pub(super) struct CsvRecord {
        pub name: String,
        pub shallow_size: u32,
        pub shallow_size_percent: f64,
        pub path: Option<String>,
    }

    // Process a given entry and its children, returning an iterator of CSV records.
    pub(super) fn process_entry<'a>(
        entry: &'a PathsEntry,
        depth: u32,
        paths: usize,
        items: &'a Items,
        opts: &'a Paths,
    ) -> Box<dyn Iterator<Item = CsvRecord> + 'a> {
        let name = entry.name.clone();
        let shallow_size = entry.size;
        let shallow_size_percent = f64::from(entry.size) / f64::from(items.size()) * 100.0;
        let path = get_path(entry);

        // Create an iterator containing the current entry's CSV record.
        let record_iter = iter::once(CsvRecord {
            name,
            shallow_size,
            shallow_size_percent,
            path,
        });

        if depth < opts.max_depth() {
            // Process each child entry, and chain together the resulting iterators.
            let children_iter = entry
                .children
                .iter()
                .take(paths)
                .flat_map(move |child_entry| {
                    process_entry(child_entry, depth + 1, paths, &items, &opts)
                });
            Box::new(record_iter.chain(children_iter))
        } else if depth == opts.max_depth() {
            // Create a summary row, and chain it to the row iterator.
            Box::new(record_iter)
        } else {
            // If we are beyond the maximum depth, return an empty iterator.
            Box::new(iter::empty())
        }
    }

    // Given a path entry, return the value for its corresponding CsvRecord's `path` field.
    fn get_path(entry: &PathsEntry) -> Option<String> {
        if entry.children.is_empty() {
            None
        } else {
            Some(
                entry
                    .children
                    .iter()
                    .map(|child| child.name.as_str())
                    .chain(iter::once(entry.name.as_str()))
                    .collect::<Vec<_>>()
                    .join(" -> "),
            )
        }
    }
}

'''
'''--- analyze/analyses/paths/paths_entry.rs ---
use std::cmp;

#[derive(Debug, PartialEq, Eq)]
pub(super) struct PathsEntry {
    pub name: String,
    pub size: u32,
    pub children: Vec<PathsEntry>,
}

impl PathsEntry {
    pub fn _count(&self) -> u32 {
        1 + self.children.iter().map(|c| c._count()).sum::<u32>()
    }
}

impl PartialOrd for PathsEntry {
    fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
        Some(self.cmp(rhs))
    }
}

impl Ord for PathsEntry {
    fn cmp(&self, rhs: &Self) -> cmp::Ordering {
        rhs.size.cmp(&self.size).then(self.name.cmp(&rhs.name))
    }
}

'''
'''--- analyze/analyses/top.rs ---
use std::io;

use csv;
use serde_derive::Serialize;

use crate::formats::json;
use crate::formats::table::{Align, Table};
use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_traits as traits;

struct Top {
    items: Vec<ir::Id>,
    opts: opt::Top,
}

impl traits::Emit for Top {
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        // A struct used to represent a row in the table that will be emitted.
        struct TableRow {
            size: u32,
            size_percent: f64,
            name: String,
        };

        // Helper function used to process an item, and return a struct
        // representing a row containing its size and name.
        fn process_item(id: ir::Id, items: &ir::Items, retained: bool) -> TableRow {
            let item = &items[id];
            let size = if retained {
                items.retained_size(id)
            } else {
                item.size()
            };
            let size_percent = (f64::from(size)) / (f64::from(items.size())) * 100.0;
            let name = item.name().to_string();
            TableRow {
                size,
                size_percent,
                name,
            }
        };

        // Helper function used to summnarize a sequence of table rows. This is
        // used to generate the remaining summary and total rows. Returns a tuple
        // containing the total size, total size percentage, and number of items.
        fn summarize_rows(rows: impl Iterator<Item = TableRow>) -> (u32, f64, u32) {
            rows.fold(
                (0, 0.0, 0),
                |(total_size, total_percent, remaining_count),
                 TableRow {
                     size, size_percent, ..
                 }| {
                    (
                        total_size + size,
                        total_percent + size_percent,
                        remaining_count + 1,
                    )
                },
            )
        }

        // Access the options that are relevant to emitting the correct output.
        let max_items = self.opts.max_items() as usize;
        let retained = self.opts.retained();
        let sort_label = if retained { "Retained" } else { "Shallow" };

        // Initialize a new table.
        let mut table = Table::with_header(vec![
            (Align::Right, format!("{} Bytes", sort_label)),
            (Align::Right, format!("{} %", sort_label)),
            (Align::Left, "Item".to_string()),
        ]);

        // Process the number of items specified, and add them to the table.
        self.items
            .iter()
            .take(max_items)
            .map(|&id| process_item(id, items, retained))
            .for_each(
                |TableRow {
                     size,
                     size_percent,
                     name,
                 }| {
                    table.add_row(vec![
                        size.to_string(),
                        format!("{:.2}%", size_percent),
                        name,
                    ])
                },
            );

        // Find the summary statistics by processing the remaining items.
        let remaining_rows = self
            .items
            .iter()
            .skip(max_items)
            .map(|&id| process_item(id, items, retained));
        let (rem_size, rem_size_percent, rem_count) = summarize_rows(remaining_rows);

        // If there were items remaining, add a summary row to the table.
        if rem_count > 0 {
            let rem_name_col = format!("... and {} more.", rem_count);
            let (rem_size_col, rem_size_percent_col) = if retained {
                ("...".to_string(), "...".to_string())
            } else {
                (rem_size.to_string(), format!("{:.2}%", rem_size_percent))
            };
            table.add_row(vec![rem_size_col, rem_size_percent_col, rem_name_col]);
        }

        // Add a row containing the totals to the table.
        let all_rows = self
            .items
            .iter()
            .map(|&id| process_item(id, items, retained));
        let (total_size, total_size_percent, total_count) = summarize_rows(all_rows);
        let total_name_col = format!("Σ [{} Total Rows]", total_count);
        let (total_size_col, total_size_percent_col) = if retained {
            ("...".to_string(), "...".to_string())
        } else {
            (
                total_size.to_string(),
                format!("{:.2}%", total_size_percent),
            )
        };
        table.add_row(vec![total_size_col, total_size_percent_col, total_name_col]);

        // Write the generated table out to the destination and return.
        write!(dest, "{}", &table)?;
        Ok(())
    }

    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut arr = json::array(dest)?;

        let max_items = self.opts.max_items() as usize;
        let items_iter = self.items.iter();

        for &id in items_iter.take(max_items) {
            let item = &items[id];

            let mut obj = arr.object()?;
            obj.field("name", item.name())?;

            let size = item.size();
            let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;
            obj.field("shallow_size", size)?;
            obj.field("shallow_size_percent", size_percent)?;

            if self.opts.retained() {
                let size = items.retained_size(id);
                let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;
                obj.field("retained_size", size)?;
                obj.field("retained_size_percent", size_percent)?;
            }
        }

        Ok(())
    }

    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, items: &ir::Items, dest: &mut dyn io::Write) -> Result<(), traits::Error> {
        let mut wtr = csv::Writer::from_writer(dest);

        #[derive(Serialize, Debug)]
        #[serde(rename_all = "PascalCase")]
        struct CsvRecord {
            name: String,
            shallow_size: u32,
            shallow_size_percent: f64,
            retained_size: Option<u32>,
            retained_size_percent: Option<f64>,
        }

        let max_items = self.opts.max_items() as usize;
        let items_iter = self.items.iter();

        for &id in items_iter.take(max_items) {
            let item = &items[id];

            let (shallow_size, shallow_size_percent) = {
                let size = item.size();
                let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;
                (size, size_percent)
            };
            let (retained_size, retained_size_percent) = if self.opts.retained() {
                let size = items.retained_size(id);
                let size_percent = f64::from(size) / f64::from(items.size()) * 100.0;
                (Some(size), Some(size_percent))
            } else {
                (None, None)
            };

            wtr.serialize(CsvRecord {
                name: item.name().to_string(),
                shallow_size,
                shallow_size_percent,
                retained_size,
                retained_size_percent,
            })?;
            wtr.flush()?;
        }
        Ok(())
    }
}

/// Run the `top` analysis on the given IR items.
pub fn top(items: &mut ir::Items, opts: &opt::Top) -> Result<Box<dyn traits::Emit>, traits::Error> {
    if opts.retaining_paths() {
        return Err(traits::Error::with_msg(
            "retaining paths are not yet implemented",
        ));
    }

    if opts.retained() {
        items.compute_retained_sizes();
    }

    let mut top_items: Vec<_> = items
        .iter()
        .filter(|item| item.id() != items.meta_root())
        .collect();

    top_items.sort_by(|a, b| {
        if opts.retained() {
            items
                .retained_size(b.id())
                .cmp(&items.retained_size(a.id()))
        } else {
            b.size().cmp(&a.size())
        }
    });

    let top_items: Vec<_> = top_items.into_iter().map(|i| i.id()).collect();

    let top = Top {
        items: top_items,
        opts: opts.clone(),
    };

    Ok(Box::new(top) as Box<_>)
}

'''
'''--- analyze/analyze.rs ---
//! Implementations of the analyses that `twiggy` runs on its IR.

#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

mod analyses;
mod formats;

pub use analyses::{
    diff::diff, dominators::dominators, garbage::garbage, monos::monos, paths::paths, top::top,
};

'''
'''--- analyze/formats/json.rs ---
// A couple methods are dead, but removing them would make the API oddly
// imbalanced and we might want to use them in some future analysis.
#![allow(dead_code)]

use std::io;

pub trait JsonPrimitive {
    fn json_primitive(&self, w: &mut dyn io::Write) -> io::Result<()>;
}

impl<'a> JsonPrimitive for &'a str {
    fn json_primitive(&self, w: &mut dyn io::Write) -> io::Result<()> {
        write!(w, "\"")?;
        for c in self.chars() {
            match c {
                '"' => write!(w, "\\\"")?,
                '\\' => write!(w, "\\")?,
                '\n' => writeln!(w,)?,
                c => write!(w, "{}", c)?,
            }
        }
        write!(w, "\"")
    }
}

impl JsonPrimitive for f64 {
    fn json_primitive(&self, w: &mut dyn io::Write) -> io::Result<()> {
        write!(w, "{}", self)
    }
}

impl JsonPrimitive for u32 {
    fn json_primitive(&self, w: &mut dyn io::Write) -> io::Result<()> {
        write!(w, "{}", self)
    }
}

pub fn array(w: &mut dyn io::Write) -> io::Result<Array> {
    write!(w, "[")?;
    Ok(Array {
        w,
        need_comma: false,
    })
}

pub fn object(w: &mut dyn io::Write) -> io::Result<Object> {
    write!(w, "{{")?;
    Ok(Object {
        w,
        need_comma: false,
    })
}

pub struct Array<'a> {
    w: &'a mut dyn io::Write,
    need_comma: bool,
}

impl<'a> Drop for Array<'a> {
    fn drop(&mut self) {
        let _ = write!(self.w, "]");
    }
}

impl<'a> Array<'a> {
    fn comma(&mut self) -> io::Result<()> {
        if self.need_comma {
            write!(self.w, ",")?;
        }
        self.need_comma = true;
        Ok(())
    }

    pub fn object(&mut self) -> io::Result<Object> {
        self.comma()?;
        object(&mut *self.w)
    }

    pub fn array(&mut self) -> io::Result<Array> {
        self.comma()?;
        array(&mut *self.w)
    }

    pub fn elem<P>(&mut self, elem: P) -> io::Result<()>
    where
        P: JsonPrimitive,
    {
        self.comma()?;
        elem.json_primitive(self.w)
    }
}

pub struct Object<'a> {
    w: &'a mut dyn io::Write,
    need_comma: bool,
}

impl<'a> Drop for Object<'a> {
    fn drop(&mut self) {
        let _ = write!(self.w, "}}");
    }
}

impl<'a> Object<'a> {
    fn comma_and_name<S>(&mut self, name: S) -> io::Result<()>
    where
        S: AsRef<str>,
    {
        if self.need_comma {
            write!(self.w, ",")?;
        }
        self.need_comma = true;
        name.as_ref().json_primitive(self.w)?;
        write!(self.w, ":")
    }

    pub fn object<S>(&mut self, name: S) -> io::Result<Object>
    where
        S: AsRef<str>,
    {
        self.comma_and_name(name)?;
        object(&mut *self.w)
    }

    pub fn array<S>(&mut self, name: S) -> io::Result<Array>
    where
        S: AsRef<str>,
    {
        self.comma_and_name(name)?;
        array(&mut *self.w)
    }

    pub fn field<S, P>(&mut self, name: S, val: P) -> io::Result<()>
    where
        S: AsRef<str>,
        P: JsonPrimitive,
    {
        self.comma_and_name(name)?;
        val.json_primitive(self.w)
    }
}

'''
'''--- analyze/formats/mod.rs ---
pub mod json;
pub mod table;

'''
'''--- analyze/formats/table.rs ---
use std::cmp;
use std::fmt;

#[derive(Debug, Clone, Copy)]
pub enum Align {
    Left,
    Right,
}

#[derive(Debug, Clone)]
pub struct Table {
    header: Vec<(Align, String)>,
    rows: Vec<Vec<String>>,
}

impl Table {
    pub(crate) fn with_header(header: Vec<(Align, String)>) -> Table {
        assert!(!header.is_empty());
        Table {
            header,
            rows: vec![],
        }
    }

    pub(crate) fn add_row(&mut self, row: Vec<String>) {
        assert_eq!(self.header.len(), row.len());
        self.rows.push(row);
    }
}

impl fmt::Display for Table {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut maxs: Vec<_> = self.header.iter().map(|h| h.1.len()).collect();

        for row in &self.rows {
            for (i, x) in row.iter().enumerate() {
                maxs[i] = cmp::max(maxs[i], x.len());
            }
        }

        let last = self.header.len() - 1;

        for (i, h) in self.header.iter().map(|h| &h.1).enumerate() {
            if i == 0 {
                write!(f, " ")?;
            } else {
                write!(f, " │ ")?;
            }

            write!(f, "{}", h)?;
            if i != last {
                for _ in 0..maxs[i] - h.len() {
                    write!(f, " ")?;
                }
            }
        }
        writeln!(f)?;

        for (i, max_len) in maxs.iter().enumerate().take(self.header.len()) {
            if i == 0 {
                write!(f, "─")?;
            } else {
                write!(f, "─┼─")?;
            }
            for _ in 0..*max_len {
                write!(f, "─")?;
            }
        }
        writeln!(f)?;

        for row in &self.rows {
            for (i, (x, align)) in row.iter().zip(self.header.iter().map(|h| h.0)).enumerate() {
                if i == 0 {
                    write!(f, " ")?;
                } else {
                    write!(f, " ┊ ")?;
                }

                match align {
                    Align::Left => {
                        write!(f, "{}", x)?;
                        if i != last {
                            for _ in 0..maxs[i] - x.len() {
                                write!(f, " ")?;
                            }
                        }
                    }
                    Align::Right => {
                        for _ in 0..maxs[i] - x.len() {
                            write!(f, " ")?;
                        }
                        write!(f, "{}", x)?;
                    }
                }
            }
            writeln!(f)?;
        }

        Ok(())
    }
}

'''
'''--- ci/script.sh ---
#!/usr/bin/env bash

set -eux

ROOT="$(dirname "$0")/.."
cd "$ROOT"

function main {
    case "$JOB" in
        "test")
            cargo test --all --exclude twiggy-wasm-api
            ;;

        "wasm")
            rustup update nightly
            rustup target add wasm32-unknown-unknown --toolchain nightly

            cd ./wasm-api
            cargo +nightly build --release --target wasm32-unknown-unknown

            # Install wasm-bindgen at the correct version, if necessary.
            local version="$(get_wasm_bindgen_version)"
            test -x ./bin/wasm-bindgen \
                && test "$(./bin/wasm-bindgen --version | xargs)" == "wasm-bindgen $version" \
                    || cargo +nightly install -f wasm-bindgen-cli --version "$version" --root "$(pwd)"

            ./bin/wasm-bindgen --out-dir . ../target/wasm32-unknown-unknown/release/twiggy_wasm_api.wasm

            if [[ $(which wasm-opt) != "" ]]; then
                local temp=$(mktemp "twiggy-XXXXXX.wasm")
                cp twiggy_wasm_api_bg.wasm "$temp"
                wasm-opt -Oz -g "$temp" -o twiggy_wasm_api_bg.wasm
                rm "$temp"
            fi

            wc -c twiggy_wasm_api_bg.wasm
            ;;

        *)
            echo "Error: unknown \$JOB = $JOB"
            exit 1
            ;;
    esac
}

function get_wasm_bindgen_version {
    grep wasm-bindgen -A 1 Cargo.toml \
        | grep version \
        | cut -f2 -d '=' \
        | tr '"' ' ' \
        | xargs
}

main

'''
'''--- guide/book.toml ---
[book]
authors = ["Nick Fitzgerald"]
multilingual = false
src = "src"
title = "Twiggy🌱"
[output.html]
theme = "src/theme"

'''
'''--- guide/src/SUMMARY.md ---
# Summary

[Introduction](./index.md)

--------------------------------------------------------------------------------

- [📦 Install](./install.md)
- [💡 Concepts](./concepts/index.md)
    - [Call Graph](./concepts/call-graph.md)
    - [Paths](./concepts/paths.md)
    - [Dominators and Retained Size](./concepts/dominators-and-retained-size.md)
    - [Generic Functions and Monomorphization](./concepts/generic-functions-and-monomorphization.md)
- [🏋️‍♀️ Usage](./usage/index.md)
    - [⌨ Command Line Interface](./usage/command-line-interface/index.md)
        - [`twiggy top`](./usage/command-line-interface/top.md)
        - [`twiggy paths`](./usage/command-line-interface/paths.md)
        - [`twiggy monos`](./usage/command-line-interface/monos.md)
        - [`twiggy dominators`](./usage/command-line-interface/dominators.md)
        - [`twiggy diff`](./usage/command-line-interface/diff.md)
        - [`twiggy garbage`](./usage/command-line-interface/garbage.md)
    - [🦀 As a Crate](./usage/as-a-crate.md)
    - [🕸 On the Web with WebAssembly](./usage/on-the-web-with-webassembly.md)
- [🔎 Supported Binary Formats](./supported-binary-formats.md)

--------------------------------------------------------------------------------

- [🙌 Contributing to Twiggy](./contributing/index.md)
  - [Building](./contributing/building.md)
  - [Testing](./contributing/testing.md)
  - [Code Formatting](./contributing/code-formatting.md)
  - [Pull Requests](./contributing/pull-requests.md)
  - [Team](./contributing/team.md)

'''
'''--- guide/src/chapter_1.md ---
# Chapter 1

'''
'''--- guide/src/concepts/call-graph.md ---
# Call Graph

Consider the following functions:

```rust
pub fn shred() {
    gnar_gnar();
    bluebird();
}

fn gnar_gnar() {
    weather_report();
    pow();
}

fn bluebird() {
    weather_report();
}

fn weather_report() {
    shred();
}

fn pow() {
    fluffy();
    soft();
}

fn fluffy() {}

fn soft() {}

pub fn baker() {
    hood();
}

fn hood() {}
```

If we treat every function as a *vertex* in a graph, and if we add an *edge*
from *A* to *B* if function *A* calls function *B*, then we get the following
*call graph*:

[<img alt="Call Graph" src="./call-graph.svg"/>](./call-graph.svg)

'''
'''--- guide/src/concepts/call-graph.svg ---
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: call&#45;graph Pages: 1 -->
<svg width="314pt" height="260pt"
 viewBox="0.00 0.00 313.84 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<title>call&#45;graph</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-256 309.844,-256 309.844,4 -4,4"/>
<!-- shred -->
<g id="node1" class="node"><title>shred</title>
<ellipse fill="none" stroke="black" cx="108.296" cy="-234" rx="29.795" ry="18"/>
<text text-anchor="middle" x="108.296" y="-230.3" font-family="Times,serif" font-size="14.00">shred</text>
</g>
<!-- gnar_gnar -->
<g id="node2" class="node"><title>gnar_gnar</title>
<ellipse fill="none" stroke="black" cx="182.296" cy="-162" rx="46.2923" ry="18"/>
<text text-anchor="middle" x="182.296" y="-158.3" font-family="Times,serif" font-size="14.00">gnar_gnar</text>
</g>
<!-- shred&#45;&gt;gnar_gnar -->
<g id="edge1" class="edge"><title>shred&#45;&gt;gnar_gnar</title>
<path fill="none" stroke="black" d="M123.629,-218.496C133.535,-209.125 146.641,-196.728 157.952,-186.028"/>
<polygon fill="black" stroke="black" points="160.576,-188.364 165.435,-178.95 155.765,-183.279 160.576,-188.364"/>
</g>
<!-- bluebird -->
<g id="node3" class="node"><title>bluebird</title>
<ellipse fill="none" stroke="black" cx="40.2964" cy="-162" rx="40.0939" ry="18"/>
<text text-anchor="middle" x="40.2964" y="-158.3" font-family="Times,serif" font-size="14.00">bluebird</text>
</g>
<!-- shred&#45;&gt;bluebird -->
<g id="edge2" class="edge"><title>shred&#45;&gt;bluebird</title>
<path fill="none" stroke="black" d="M93.8754,-218.155C84.8404,-208.854 73.0073,-196.673 62.7602,-186.124"/>
<polygon fill="black" stroke="black" points="65.1201,-183.531 55.6417,-178.797 60.0991,-188.408 65.1201,-183.531"/>
</g>
<!-- weather_report -->
<g id="node4" class="node"><title>weather_report</title>
<ellipse fill="none" stroke="black" cx="90.2964" cy="-90" rx="63.8893" ry="18"/>
<text text-anchor="middle" x="90.2964" y="-86.3" font-family="Times,serif" font-size="14.00">weather_report</text>
</g>
<!-- gnar_gnar&#45;&gt;weather_report -->
<g id="edge3" class="edge"><title>gnar_gnar&#45;&gt;weather_report</title>
<path fill="none" stroke="black" d="M161.879,-145.465C149.516,-136.058 133.539,-123.902 119.817,-113.461"/>
<polygon fill="black" stroke="black" points="121.694,-110.491 111.616,-107.222 117.455,-116.062 121.694,-110.491"/>
</g>
<!-- pow -->
<g id="node5" class="node"><title>pow</title>
<ellipse fill="none" stroke="black" cx="199.296" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="199.296" y="-86.3" font-family="Times,serif" font-size="14.00">pow</text>
</g>
<!-- gnar_gnar&#45;&gt;pow -->
<g id="edge4" class="edge"><title>gnar_gnar&#45;&gt;pow</title>
<path fill="none" stroke="black" d="M186.412,-144.055C188.304,-136.261 190.597,-126.822 192.72,-118.079"/>
<polygon fill="black" stroke="black" points="196.142,-118.819 195.101,-108.275 189.34,-117.167 196.142,-118.819"/>
</g>
<!-- bluebird&#45;&gt;weather_report -->
<g id="edge5" class="edge"><title>bluebird&#45;&gt;weather_report</title>
<path fill="none" stroke="black" d="M52.1457,-144.411C58.1596,-135.992 65.5929,-125.585 72.2959,-116.201"/>
<polygon fill="black" stroke="black" points="75.2205,-118.128 78.1848,-107.956 69.5243,-114.059 75.2205,-118.128"/>
</g>
<!-- weather_report&#45;&gt;shred -->
<g id="edge6" class="edge"><title>weather_report&#45;&gt;shred</title>
<path fill="none" stroke="black" d="M92.4753,-108.189C95.5474,-132.424 101.184,-176.888 104.833,-205.679"/>
<polygon fill="black" stroke="black" points="101.395,-206.391 106.125,-215.871 108.34,-205.511 101.395,-206.391"/>
</g>
<!-- fluffy -->
<g id="node6" class="node"><title>fluffy</title>
<ellipse fill="none" stroke="black" cx="161.296" cy="-18" rx="30.5947" ry="18"/>
<text text-anchor="middle" x="161.296" y="-14.3" font-family="Times,serif" font-size="14.00">fluffy</text>
</g>
<!-- pow&#45;&gt;fluffy -->
<g id="edge7" class="edge"><title>pow&#45;&gt;fluffy</title>
<path fill="none" stroke="black" d="M190.483,-72.7646C185.944,-64.4043 180.305,-54.0159 175.197,-44.6059"/>
<polygon fill="black" stroke="black" points="178.173,-42.7521 170.326,-35.6334 172.021,-46.0918 178.173,-42.7521"/>
</g>
<!-- soft -->
<g id="node7" class="node"><title>soft</title>
<ellipse fill="none" stroke="black" cx="237.296" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="237.296" y="-14.3" font-family="Times,serif" font-size="14.00">soft</text>
</g>
<!-- pow&#45;&gt;soft -->
<g id="edge8" class="edge"><title>pow&#45;&gt;soft</title>
<path fill="none" stroke="black" d="M208.11,-72.7646C212.714,-64.2831 218.451,-53.7144 223.618,-44.1974"/>
<polygon fill="black" stroke="black" points="226.836,-45.6057 228.531,-35.1473 220.684,-42.266 226.836,-45.6057"/>
</g>
<!-- baker -->
<g id="node8" class="node"><title>baker</title>
<ellipse fill="none" stroke="black" cx="275.296" cy="-234" rx="30.5947" ry="18"/>
<text text-anchor="middle" x="275.296" y="-230.3" font-family="Times,serif" font-size="14.00">baker</text>
</g>
<!-- hood -->
<g id="node9" class="node"><title>hood</title>
<ellipse fill="none" stroke="black" cx="275.296" cy="-162" rx="28.6953" ry="18"/>
<text text-anchor="middle" x="275.296" y="-158.3" font-family="Times,serif" font-size="14.00">hood</text>
</g>
<!-- baker&#45;&gt;hood -->
<g id="edge9" class="edge"><title>baker&#45;&gt;hood</title>
<path fill="none" stroke="black" d="M275.296,-215.697C275.296,-207.983 275.296,-198.712 275.296,-190.112"/>
<polygon fill="black" stroke="black" points="278.797,-190.104 275.296,-180.104 271.797,-190.104 278.797,-190.104"/>
</g>
</g>
</svg>

'''
'''--- guide/src/concepts/dominator-tree.svg ---
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: dominator&#45;tree Pages: 1 -->
<svg width="366pt" height="260pt"
 viewBox="0.00 0.00 366.24 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<title>dominator&#45;tree</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-256 362.242,-256 362.242,4 -4,4"/>
<!-- shred -->
<g id="node1" class="node"><title>shred</title>
<ellipse fill="none" stroke="black" cx="172.547" cy="-234" rx="29.795" ry="18"/>
<text text-anchor="middle" x="172.547" y="-230.3" font-family="Times,serif" font-size="14.00">shred</text>
</g>
<!-- gnar_gnar -->
<g id="node2" class="node"><title>gnar_gnar</title>
<ellipse fill="none" stroke="black" cx="68.5473" cy="-162" rx="46.2923" ry="18"/>
<text text-anchor="middle" x="68.5473" y="-158.3" font-family="Times,serif" font-size="14.00">gnar_gnar</text>
</g>
<!-- shred&#45;&gt;gnar_gnar -->
<g id="edge1" class="edge"><title>shred&#45;&gt;gnar_gnar</title>
<path fill="none" stroke="black" d="M152.986,-219.834C137.954,-209.716 116.901,-195.545 99.5772,-183.885"/>
<polygon fill="black" stroke="black" points="101.16,-180.732 90.9098,-178.052 97.2514,-186.539 101.16,-180.732"/>
</g>
<!-- bluebird -->
<g id="node3" class="node"><title>bluebird</title>
<ellipse fill="none" stroke="black" cx="172.547" cy="-162" rx="40.0939" ry="18"/>
<text text-anchor="middle" x="172.547" y="-158.3" font-family="Times,serif" font-size="14.00">bluebird</text>
</g>
<!-- shred&#45;&gt;bluebird -->
<g id="edge2" class="edge"><title>shred&#45;&gt;bluebird</title>
<path fill="none" stroke="black" d="M172.547,-215.697C172.547,-207.983 172.547,-198.712 172.547,-190.112"/>
<polygon fill="black" stroke="black" points="176.047,-190.104 172.547,-180.104 169.047,-190.104 176.047,-190.104"/>
</g>
<!-- weather_report -->
<g id="node4" class="node"><title>weather_report</title>
<ellipse fill="none" stroke="black" cx="294.547" cy="-162" rx="63.8893" ry="18"/>
<text text-anchor="middle" x="294.547" y="-158.3" font-family="Times,serif" font-size="14.00">weather_report</text>
</g>
<!-- shred&#45;&gt;weather_report -->
<g id="edge3" class="edge"><title>shred&#45;&gt;weather_report</title>
<path fill="none" stroke="black" d="M193.52,-220.967C211.403,-210.705 237.505,-195.729 258.697,-183.57"/>
<polygon fill="black" stroke="black" points="260.509,-186.565 267.441,-178.553 257.025,-180.494 260.509,-186.565"/>
</g>
<!-- pow -->
<g id="node5" class="node"><title>pow</title>
<ellipse fill="none" stroke="black" cx="68.5473" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="68.5473" y="-86.3" font-family="Times,serif" font-size="14.00">pow</text>
</g>
<!-- gnar_gnar&#45;&gt;pow -->
<g id="edge4" class="edge"><title>gnar_gnar&#45;&gt;pow</title>
<path fill="none" stroke="black" d="M68.5473,-143.697C68.5473,-135.983 68.5473,-126.712 68.5473,-118.112"/>
<polygon fill="black" stroke="black" points="72.0474,-118.104 68.5473,-108.104 65.0474,-118.104 72.0474,-118.104"/>
</g>
<!-- fluffy -->
<g id="node6" class="node"><title>fluffy</title>
<ellipse fill="none" stroke="black" cx="30.5473" cy="-18" rx="30.5947" ry="18"/>
<text text-anchor="middle" x="30.5473" y="-14.3" font-family="Times,serif" font-size="14.00">fluffy</text>
</g>
<!-- pow&#45;&gt;fluffy -->
<g id="edge5" class="edge"><title>pow&#45;&gt;fluffy</title>
<path fill="none" stroke="black" d="M59.7338,-72.7646C55.1953,-64.4043 49.5559,-54.0159 44.4477,-44.6059"/>
<polygon fill="black" stroke="black" points="47.4238,-42.7521 39.5768,-35.6334 41.2718,-46.0918 47.4238,-42.7521"/>
</g>
<!-- soft -->
<g id="node7" class="node"><title>soft</title>
<ellipse fill="none" stroke="black" cx="106.547" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="106.547" y="-14.3" font-family="Times,serif" font-size="14.00">soft</text>
</g>
<!-- pow&#45;&gt;soft -->
<g id="edge6" class="edge"><title>pow&#45;&gt;soft</title>
<path fill="none" stroke="black" d="M77.3608,-72.7646C81.965,-64.2831 87.7023,-53.7144 92.8687,-44.1974"/>
<polygon fill="black" stroke="black" points="96.0866,-45.6057 97.7816,-35.1473 89.9346,-42.266 96.0866,-45.6057"/>
</g>
</g>
</svg>

'''
'''--- guide/src/concepts/dominators-and-retained-size.md ---
# Dominators and Retained Size

Let's continue to use this example call graph:

[<img alt="Call Graph" src="./call-graph.svg"/>](./call-graph.svg)

Imagine the `pow` function itself might is not very large. But it calls
functions `soft` and `fluffy`, both of which are **huge**. And they are both
*only* called by `pow`, so if `pow` were removed, then `soft` and `fluffy` would
both become dead code and get removed as well. Therefore, `pow`'s "real" size is
huge, even though it doesn't look like it at a glance.

The *dominator* relationship gives us a way to reason about the *retained size*
of a function.

In a graph that is rooted at vertex *R*, vertex *A* is said to
[*dominate*][dominators] vertex *B* if every path in the graph from *R* to *B*
includes *A*. It follows that if *A* were removed from the graph, then *B* would
become unreachable.

In our call graphs, the roots are the `main` function (for executables) or
publicly exported functions (for libraries).

*V* is the *immediate dominator* of a vertex *U* if *V != U*, and there does not
exist another distinct vertex *W* that is dominated by *V* but also dominates
*U*. If we take all the vertices from a graph, remove the edges, and then add
edges for each immediate dominator relationship, then we get a tree. Here is the
dominator tree for our call graph from earlier, where `shred` is the root:

[<img alt="Dominator Tree" src="./dominator-tree.svg"/>](./dominator-tree.svg)

Using the dominator relationship, we can find the *retained size* of some
function by taking its shallow size and adding the retained sizes of each
function that it immediately dominates.

[dominators]: https://en.wikipedia.org/wiki/Dominator_(graph_theory)

'''
'''--- guide/src/concepts/generic-functions-and-monomorphization.md ---
# Generic Functions and Monomorphization

Generic functions with type parameters in Rust and template functions in C++ can
lead to code bloat if you aren't careful. Every time you instantiate these
generic functions with a concrete set of types, the compiler will *monomorphize*
the function, creating a copy of its body replacing its generic placeholders
with the specific operations that apply to the concrete types. This presents
many opportunities for compiler optimizations based on which particular concrete
types each copy of the function is working with, but these copies add up quickly
in terms of code size.

Example of monomorphization in Rust:

```rust
fn generic_function<T: MyTrait>(t: T) { ... }

// Each of these will generate a new copy of `generic_function`!
generic_function::<MyTraitImpl>(...);
generic_function::<AnotherMyTraitImpl>(...);
generic_function::<MyTraitImplAlso>(...);
```

Example of monomorphization in C++:

```c++
template<typename T>
void generic_function(T t) { ... }

// Each of these will also generate a new copy of `generic_function`!
generic_function<uint32_t>(...);
generic_function<bool>(...);
generic_function<MyClass>(...);
```

If you can afford the runtime cost of dynamic dispatch, then changing these
functions to use trait objects in Rust or virtual methods in C++ can likely save
a significant amounts of code size. With dynamic dispatch, the generic
function's body is not copied, and the generic bits within the function become
indirect function calls.

Example of dynamic dispatch in Rust:

```rust
fn generic_function(t: &MyTrait) { ... }
// or
fn generic_function(t: Box<MyTrait>) { ... }
// etc...

// No more code bloat!
let x = MyTraitImpl::new();
generic_function(&x);
let y = AnotherMyTraitImpl::new();
generic_function(&y);
let z = MyTraitImplAlso::new();
generic_function(&z);
```

Example of dynamic dispatch in C++:

```c++
class GenericBase {
  public:
    virtual void generic_impl() = 0;
};

class MyThing : public GenericBase {
  public
    virtual void generic_impl() override { ... }
};

class AnotherThing : public GenericBase {
  public
    virtual void generic_impl() override { ... }
};

class AlsoThing : public GenericBase {
  public
    virtual void generic_impl() override { ... }
};

void generic(GenericBase& thing) { ... }

// No more code bloat!
MyThing x;
generic(x);
AnotherThing y;
generic(y);
AlsoThing z;
generic(z);
```

`twiggy` can analyze a binary to find which generic functions are being
monomorphized repeatedly, and calculate an estimation of how much code size
could be saved by switching from monomorphization to dynamic dispatch.

'''
'''--- guide/src/concepts/index.md ---
# 💡 Concepts

This section provides some background knowledge on concepts that are useful to
understand when using Twiggy.

'''
'''--- guide/src/concepts/paths.md ---
# Paths

If there is a *path* where *A → B → ... → C* through the [call
graph](./call-graph.md), then we say that *C* is *reachable* through from
*A*. *Dead code* is code that is not *reachable* in the call graph from any
publicly exported functions (for libraries) or the `main` function (for
executables).

Recall our example call graph:

[<img alt="Call Graph" src="./call-graph.svg"/>](./call-graph.svg)

Imagine that `shred` was our executable's `main` function. In this scenario,
there is no path through the call graph from `shred` to `baker` or `hood`, so
they are dead code. We would expect that the linker would remove them, and they
wouldn't show up in the final binary.

But what if some function that you *thought* was dead code is appearing inside
your binary? Maybe it is deep down in some library you depend on, but inside a
submodule of that library that you aren't using, and you wouldn't expect it to
be included in the final binary.

In this scenario, `twiggy` can show you all the paths in the call graph that
lead to the unexpected function. This lets you understand why the unwelcome
function is present, and decide what you can do about it. Maybe if you
refactored your code to avoid calling *Y*, then there wouldn't be any paths to
the unwelcome function anymore, it would be dead code, and the linker would
remove it.

'''
'''--- guide/src/contributing.md ---
# 🙌 Contributing to Twiggy

'''
'''--- guide/src/contributing/building.md ---
# Building

## Building for the Native Target

```
$ cargo build --all --exclude twiggy-wasm-api
```

## Building for the `wasm32-unknown-unknown` Target

```
$ JOB=wasm ./ci/script.sh
```

'''
'''--- guide/src/contributing/code-formatting.md ---
# Code Formatting

We use [`rustfmt`](https://github.com/rust-lang-nursery/rustfmt) to enforce a
consistent code style across the whole code base.

You can install the latest version of `rustfmt` with this command:

```
$ rustup update
$ rustup component add rustfmt --toolchain stable
```

Ensure that `~/.rustup/toolchains/$YOUR_HOST_TARGET/bin/` is on your `$PATH`.

Once that is taken care of, you can (re)format all code by running this command
from the root of the repository:

```
$ cargo fmt --all
```

# Linting

We use [`clippy`](https://github.com/rust-lang/rust-clippy) to lint the codebase.
This helps avoid common mistakes, and ensures that code is correct,
performant, and idiomatic.

You can install the latest version of `clippy` with this command:

```
$ rustup update
$ rustup component add clippy --toolchain stable
```

Once that is complete, you can lint your code to check for mistakes by running
this command from the root of the repository:

```
$ cargo clippy
```

'''
'''--- guide/src/contributing/code-of-conduct.md ---
# Code of Conduct

'''
'''--- guide/src/contributing/index.md ---
# 🙌 Contributing to Twiggy

Hi! We'd love to have your contributions! If you want help or mentorship, reach
out to us in a GitHub issue, or ping `fitzgen` in [`#rust-wasm` on
`irc.mozilla.org`](irc://irc.mozilla.org#rust-wasm) and introduce yourself.

## Code of Conduct

We abide by the [Rust Code of Conduct][coc] and ask that you do as well.

[coc]: https://www.rust-lang.org/en-US/conduct.html

'''
'''--- guide/src/contributing/pull-requests.md ---
# Pull Requests

All pull requests must be reviewed and approved of by at least one
[team](./team.html) member before merging. See [Contributions We
Want](#contributions-we-want) for details on what should be included in what
kind of pull request.

## Contributions We Want

* **Bug fixes!** Include a regression test.

* **Support for more binary formats!** See [this issue][more-formats] for
  details.

* **New analyses and queries!** Help expose information about monomorphizations
  or inlining. Report diffs between two versions of the same binary. Etc...

If you make two of these kinds of contributions, you should seriously consider
joining our [team](./team.html)!

## Where We Need Help

* Issues labeled ["help wanted"][help-wanted] are issues where we could use a
  little help from you.

* Issues labeled ["mentored"][mentored] are issues that don't really involve any
  more investigation, just implementation. We've outlined what needs to be done,
  and a [team](./team.html) member has volunteered to help whoever claims the
  issue to implement it, and get the implementation merged.

* Issues labeled ["good first issue"][gfi] are issues where fixing them would be
  a great introduction to the code base.

[more-formats]: https://github.com/rustwasm/twiggy/issues/4
[help-wanted]: https://github.com/rustwasm/twiggy/labels/help%20wanted
[mentored]: https://github.com/rustwasm/twiggy/labels/mentored
[gfi]: https://github.com/rustwasm/twiggy/labels/good%20first%20issue

'''
'''--- guide/src/contributing/team.md ---
# Team

## Members

| [<img alt="fitzgen" src="https://github.com/fitzgen.png" width="117">](https://github.com/fitzgen) | [<img alt="data-pup" src="https://github.com/data-pup.png" width="117">](https://github.com/data-pup) |
|:---:|:---:|
| [`fitzgen`](https://github.com/fitzgen) | [`data-pup`](https://github.com/data-pup) |

## Responsibilities

Team members review pull requests, triage new issues, mentor new contributors,
and maintain the Twiggy project.

Larger, more nuanced decisions about design, architecture, breaking changes,
trade offs, etc are made by team consensus. In other words, decisions on things
that aren't straightforward improvements or bug fixes to things that already
exist in `twiggy`. If consensus can't be made, then `fitzgen` has the last
word.

**We need more team members!**
[Drop a comment on this issue if you are interested in joining.][join]

[join]: https://github.com/rustwasm/twiggy/issues/3

'''
'''--- guide/src/contributing/testing.md ---
# Testing

```
$ cargo test --all --exclude twiggy-wasm-api
```

## Authoring New Tests

Integration tests live in the `twiggy/tests` directory:

```
twiggy/tests
├── expectations
├── fixtures
└── tests.rs
```

* The `twiggy/tests/tests.rs` file contains the `#[test]` definitions.

* The `twiggy/tests/fixtures` directory contains input binaries for tests.

* The `twiggy/tests/expectations` directory contains the expected output of test
  commands.

## Updating Test Expectations

To automatically update all test expectations, you can run the tests with the
`TWIGGY_UPDATE_TEST_EXPECTATIONS=1` environment variable set. Make sure that you
look at the changes before committing them, and that they match your intentions!

TIP: You can use `git add -p` to examine individual hunks when staging changes
before committing!

'''
'''--- guide/src/index.md ---
<div align="center">

  <h1>Twiggy🌱</h1>

  <strong>A code size profiler for Wasm</strong>

  <p>
    <a href="https://docs.rs/twiggy/"><img src="https://docs.rs/twiggy/badge.svg"/></a>
    <a href="https://crates.io/crates/twiggy"><img src="https://img.shields.io/crates/v/twiggy.svg"/></a>
    <a href="https://crates.io/crates/twiggy"><img src="https://img.shields.io/crates/d/twiggy.svg"/></a>
    <a href="https://travis-ci.org/rustwasm/twiggy"><img src="https://travis-ci.org/rustwasm/twiggy.svg?branch=master"/></a>
  </p>

  <h3>
    <a href="https://rustwasm.github.io/twiggy">Guide</a>
    <span> | </span>
    <a href="https://rustwasm.github.io/twiggy/contributing/index.html">Contributing</a>
    <span> | </span>
    <a href="https://discordapp.com/channels/442252698964721669/443151097398296587">Chat</a>
  </h3>

  <sub>Built with 🦀🕸 by <a href="https://rustwasm.github.io/">The Rust and WebAssembly Working Group</a></sub>
</div>

## About

Twiggy is a code size profiler for Wasm. It analyzes a binary's call graph to
answer questions like:

* Why was this function included in the binary in the first place? Who calls it?

* What is the *retained size* of this function? I.e. how much space would be
  saved if I removed it and all the functions that become dead code after its
  removal.

Use Twiggy to make your binaries slim!

<div align="center">
  <img src="./twiggy.png"/>
</div>

'''
'''--- guide/src/install.md ---
# 📦 Install

Ensure that you have the [Rust toolchain installed](https://www.rust-lang.org/),
then run:

```
cargo install twiggy
```

'''
'''--- guide/src/supported-binary-formats.md ---
# 🔎 Supported Binary Formats

## Full Support

`twiggy` currently supports these binary formats:

* ✔️ WebAssembly's `.wasm` format

## Partial, Work-in-Progress Support

`twiggy` has partial, work-in-progress support for these binary formats *when
they have [DWARF][dwarf] debug info*:

* ⚠ ELF
* ⚠ Mach-O

## Unsupported

* ❌ PE/COFF

Although `twiggy` doesn't currently support these binary formats, it is designed
with extensibility in mind. The input is translated into a format-agnostic
internal representation (IR), and adding support for new formats only requires
parsing them into this IR. The vast majority of `twiggy` will not need
modification.

We would love to gain support for new binary formats! If you're interested in
helping out with that implementation work, [read this to learn how to contribute
to Twiggy!](./contributing/index.html)

[dwarf]: http://dwarfstd.org/

'''
'''--- guide/src/theme/book.js ---
"use strict";

// Fix back button cache problem
window.onunload = function () { };

// Global variable, shared between modules
function playpen_text(playpen) {
    let code_block = playpen.querySelector("code");

    if (window.ace && code_block.classList.contains("editable")) {
        let editor = window.ace.edit(code_block);
        return editor.getValue();
    } else {
        return code_block.textContent;
    }
}

(function codeSnippets() {
    // Hide Rust code lines prepended with a specific character
    var hiding_character = "#";

    function fetch_with_timeout(url, options, timeout = 6000) {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
        ]);
    }

    var playpens = Array.from(document.querySelectorAll(".playpen"));
    if (playpens.length > 0) {
        fetch_with_timeout("https://play.rust-lang.org/meta/crates", {
            headers: {
                'Content-Type': "application/json",
            },
            method: 'POST',
            mode: 'cors',
        })
        .then(response => response.json())
        .then(response => {
            // get list of crates available in the rust playground
            let playground_crates = response.crates.map(item => item["id"]);
            playpens.forEach(block => handle_crate_list_update(block, playground_crates));
        });
    }

    function handle_crate_list_update(playpen_block, playground_crates) {
        // update the play buttons after receiving the response
        update_play_button(playpen_block, playground_crates);

        // and install on change listener to dynamically update ACE editors
        if (window.ace) {
            let code_block = playpen_block.querySelector("code");
            if (code_block.classList.contains("editable")) {
                let editor = window.ace.edit(code_block);
                editor.addEventListener("change", function (e) {
                    update_play_button(playpen_block, playground_crates);
                });
            }
        }
    }

    // updates the visibility of play button based on `no_run` class and
    // used crates vs ones available on http://play.rust-lang.org
    function update_play_button(pre_block, playground_crates) {
        var play_button = pre_block.querySelector(".play-button");

        // skip if code is `no_run`
        if (pre_block.querySelector('code').classList.contains("no_run")) {
            play_button.classList.add("hidden");
            return;
        }

        // get list of `extern crate`'s from snippet
        var txt = playpen_text(pre_block);
        var re = /extern\s+crate\s+([a-zA-Z_0-9]+)\s*;/g;
        var snippet_crates = [];
        var item;
        while (item = re.exec(txt)) {
            snippet_crates.push(item[1]);
        }

        // check if all used crates are available on play.rust-lang.org
        var all_available = snippet_crates.every(function (elem) {
            return playground_crates.indexOf(elem) > -1;
        });

        if (all_available) {
            play_button.classList.remove("hidden");
        } else {
            play_button.classList.add("hidden");
        }
    }

    function run_rust_code(code_block) {
        var result_block = code_block.querySelector(".result");
        if (!result_block) {
            result_block = document.createElement('code');
            result_block.className = 'result hljs language-bash';

            code_block.append(result_block);
        }

        let text = playpen_text(code_block);

        var params = {
            version: "stable",
            optimize: "0",
            code: text
        };

        if (text.indexOf("#![feature") !== -1) {
            params.version = "nightly";
        }

        result_block.innerText = "Running...";

        fetch_with_timeout("https://play.rust-lang.org/evaluate.json", {
            headers: {
                'Content-Type': "application/json",
            },
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify(params)
        })
        .then(response => response.json())
        .then(response => result_block.innerText = response.result)
        .catch(error => result_block.innerText = "Playground Communication: " + error.message);
    }

    // Syntax highlighting Configuration
    hljs.configure({
        tabReplace: '    ', // 4 spaces
        languages: [],      // Languages used for auto-detection
    });

    if (window.ace) {
        // language-rust class needs to be removed for editable
        // blocks or highlightjs will capture events
        Array
            .from(document.querySelectorAll('code.editable'))
            .forEach(function (block) { block.classList.remove('language-rust'); });

        Array
            .from(document.querySelectorAll('code:not(.editable)'))
            .forEach(function (block) { hljs.highlightBlock(block); });
    } else {
        Array
            .from(document.querySelectorAll('code'))
            .forEach(function (block) { hljs.highlightBlock(block); });
    }

    // Adding the hljs class gives code blocks the color css
    // even if highlighting doesn't apply
    Array
        .from(document.querySelectorAll('code'))
        .forEach(function (block) { block.classList.add('hljs'); });

    Array.from(document.querySelectorAll("code.language-rust")).forEach(function (block) {

        var code_block = block;
        var pre_block = block.parentNode;
        // hide lines
        var lines = code_block.innerHTML.split("\n");
        var first_non_hidden_line = false;
        var lines_hidden = false;
        var trimmed_line = "";

        for (var n = 0; n < lines.length; n++) {
            trimmed_line = lines[n].trim();
            if (trimmed_line[0] == hiding_character && trimmed_line[1] != hiding_character) {
                if (first_non_hidden_line) {
                    lines[n] = "<span class=\"hidden\">" + "\n" + lines[n].replace(/(\s*)# ?/, "$1") + "</span>";
                }
                else {
                    lines[n] = "<span class=\"hidden\">" + lines[n].replace(/(\s*)# ?/, "$1") + "\n" + "</span>";
                }
                lines_hidden = true;
            }
            else if (first_non_hidden_line) {
                lines[n] = "\n" + lines[n];
            }
            else {
                first_non_hidden_line = true;
            }
            if (trimmed_line[0] == hiding_character && trimmed_line[1] == hiding_character) {
                lines[n] = lines[n].replace("##", "#")
            }
        }
        code_block.innerHTML = lines.join("");

        // If no lines were hidden, return
        if (!lines_hidden) { return; }

        var buttons = document.createElement('div');
        buttons.className = 'buttons';
        buttons.innerHTML = "<button class=\"fa fa-expand\" title=\"Show hidden lines\" aria-label=\"Show hidden lines\"></button>";

        // add expand button
        pre_block.insertBefore(buttons, pre_block.firstChild);

        pre_block.querySelector('.buttons').addEventListener('click', function (e) {
            if (e.target.classList.contains('fa-expand')) {
                var lines = pre_block.querySelectorAll('span.hidden');

                e.target.classList.remove('fa-expand');
                e.target.classList.add('fa-compress');
                e.target.title = 'Hide lines';
                e.target.setAttribute('aria-label', e.target.title);

                Array.from(lines).forEach(function (line) {
                    line.classList.remove('hidden');
                    line.classList.add('unhidden');
                });
            } else if (e.target.classList.contains('fa-compress')) {
                var lines = pre_block.querySelectorAll('span.unhidden');

                e.target.classList.remove('fa-compress');
                e.target.classList.add('fa-expand');
                e.target.title = 'Show hidden lines';
                e.target.setAttribute('aria-label', e.target.title);

                Array.from(lines).forEach(function (line) {
                    line.classList.remove('unhidden');
                    line.classList.add('hidden');
                });
            }
        });
    });

    Array.from(document.querySelectorAll('pre code')).forEach(function (block) {
        var pre_block = block.parentNode;
        if (!pre_block.classList.contains('playpen')) {
            var buttons = pre_block.querySelector(".buttons");
            if (!buttons) {
                buttons = document.createElement('div');
                buttons.className = 'buttons';
                pre_block.insertBefore(buttons, pre_block.firstChild);
            }

            var clipButton = document.createElement('button');
            clipButton.className = 'fa fa-copy clip-button';
            clipButton.title = 'Copy to clipboard';
            clipButton.setAttribute('aria-label', clipButton.title);
            clipButton.innerHTML = '<i class=\"tooltiptext\"></i>';

            buttons.insertBefore(clipButton, buttons.firstChild);
        }
    });

    // Process playpen code blocks
    Array.from(document.querySelectorAll(".playpen")).forEach(function (pre_block) {
        // Add play button
        var buttons = pre_block.querySelector(".buttons");
        if (!buttons) {
            buttons = document.createElement('div');
            buttons.className = 'buttons';
            pre_block.insertBefore(buttons, pre_block.firstChild);
        }

        var runCodeButton = document.createElement('button');
        runCodeButton.className = 'fa fa-play play-button';
        runCodeButton.hidden = true;
        runCodeButton.title = 'Run this code';
        runCodeButton.setAttribute('aria-label', runCodeButton.title);

        var copyCodeClipboardButton = document.createElement('button');
        copyCodeClipboardButton.className = 'fa fa-copy clip-button';
        copyCodeClipboardButton.innerHTML = '<i class="tooltiptext"></i>';
        copyCodeClipboardButton.title = 'Copy to clipboard';
        copyCodeClipboardButton.setAttribute('aria-label', copyCodeClipboardButton.title);

        buttons.insertBefore(runCodeButton, buttons.firstChild);
        buttons.insertBefore(copyCodeClipboardButton, buttons.firstChild);

        runCodeButton.addEventListener('click', function (e) {
            run_rust_code(pre_block);
        });

        let code_block = pre_block.querySelector("code");
        if (window.ace && code_block.classList.contains("editable")) {
            var undoChangesButton = document.createElement('button');
            undoChangesButton.className = 'fa fa-history reset-button';
            undoChangesButton.title = 'Undo changes';
            undoChangesButton.setAttribute('aria-label', undoChangesButton.title);

            buttons.insertBefore(undoChangesButton, buttons.firstChild);

            undoChangesButton.addEventListener('click', function () {
                let editor = window.ace.edit(code_block);
                editor.setValue(editor.originalCode);
                editor.clearSelection();
            });
        }
    });
})();

(function themes() {
    var html = document.querySelector('html');
    var themeToggleButton = document.getElementById('theme-toggle');
    var themePopup = document.getElementById('theme-list');
    var themeColorMetaTag = document.querySelector('meta[name="theme-color"]');
    var stylesheets = {
        ayuHighlight: document.querySelector("[href$='ayu-highlight.css']"),
        tomorrowNight: document.querySelector("[href$='tomorrow-night.css']"),
        highlight: document.querySelector("[href$='highlight.css']"),
    };

    function showThemes() {
        themePopup.style.display = 'block';
        themeToggleButton.setAttribute('aria-expanded', true);
        themePopup.querySelector("button#" + document.body.className).focus();
    }

    function hideThemes() {
        themePopup.style.display = 'none';
        themeToggleButton.setAttribute('aria-expanded', false);
        themeToggleButton.focus();
    }

    function set_theme(theme) {
        let ace_theme;

        if (theme == 'coal' || theme == 'navy') {
            stylesheets.ayuHighlight.disabled = true;
            stylesheets.tomorrowNight.disabled = false;
            stylesheets.highlight.disabled = true;

            ace_theme = "ace/theme/tomorrow_night";
        } else if (theme == 'ayu') {
            stylesheets.ayuHighlight.disabled = false;
            stylesheets.tomorrowNight.disabled = true;
            stylesheets.highlight.disabled = true;

            ace_theme = "ace/theme/tomorrow_night";
        } else {
            stylesheets.ayuHighlight.disabled = true;
            stylesheets.tomorrowNight.disabled = true;
            stylesheets.highlight.disabled = false;

            ace_theme = "ace/theme/dawn";
        }

        setTimeout(function () {
            themeColorMetaTag.content = getComputedStyle(document.body).backgroundColor;
        }, 1);

        if (window.ace && window.editors) {
            window.editors.forEach(function (editor) {
                editor.setTheme(ace_theme);
            });
        }

        var previousTheme;
        try { previousTheme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (previousTheme === null || previousTheme === undefined) { previousTheme = 'light'; }

        try { localStorage.setItem('mdbook-theme', theme); } catch (e) { }

        document.body.className = theme;
        html.classList.remove(previousTheme);
        html.classList.add(theme);
    }

    // Set theme
    var theme;
    try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
    if (theme === null || theme === undefined) { theme = 'light'; }

    set_theme(theme);

    themeToggleButton.addEventListener('click', function () {
        if (themePopup.style.display === 'block') {
            hideThemes();
        } else {
            showThemes();
        }
    });

    themePopup.addEventListener('click', function (e) {
        var theme = e.target.id || e.target.parentElement.id;
        set_theme(theme);
    });

    themePopup.addEventListener('focusout', function(e) {
        // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
        if (!!e.relatedTarget && !themeToggleButton.contains(e.relatedTarget) && !themePopup.contains(e.relatedTarget)) {
            hideThemes();
        }
    });

    // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
    document.addEventListener('click', function(e) {
        if (themePopup.style.display === 'block' && !themeToggleButton.contains(e.target) && !themePopup.contains(e.target)) {
            hideThemes();
        }
    });

    document.addEventListener('keydown', function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
        if (!themePopup.contains(e.target)) { return; }

        switch (e.key) {
            case 'Escape':
                e.preventDefault();
                hideThemes();
                break;
            case 'ArrowUp':
                e.preventDefault();
                var li = document.activeElement.parentElement;
                if (li && li.previousElementSibling) {
                    li.previousElementSibling.querySelector('button').focus();
                }
                break;
            case 'ArrowDown':
                e.preventDefault();
                var li = document.activeElement.parentElement;
                if (li && li.nextElementSibling) {
                    li.nextElementSibling.querySelector('button').focus();
                }
                break;
            case 'Home':
                e.preventDefault();
                themePopup.querySelector('li:first-child button').focus();
                break;
            case 'End':
                e.preventDefault();
                themePopup.querySelector('li:last-child button').focus();
                break;
        }
    });
})();

(function sidebar() {
    var html = document.querySelector("html");
    var sidebar = document.getElementById("sidebar");
    var sidebarLinks = document.querySelectorAll('#sidebar a');
    var sidebarToggleButton = document.getElementById("sidebar-toggle");
    var firstContact = null;

    function showSidebar() {
        html.classList.remove('sidebar-hidden')
        html.classList.add('sidebar-visible');
        Array.from(sidebarLinks).forEach(function (link) {
            link.setAttribute('tabIndex', 0);
        });
        sidebarToggleButton.setAttribute('aria-expanded', true);
        sidebar.setAttribute('aria-hidden', false);
        try { localStorage.setItem('mdbook-sidebar', 'visible'); } catch (e) { }
    }

    function hideSidebar() {
        html.classList.remove('sidebar-visible')
        html.classList.add('sidebar-hidden');
        Array.from(sidebarLinks).forEach(function (link) {
            link.setAttribute('tabIndex', -1);
        });
        sidebarToggleButton.setAttribute('aria-expanded', false);
        sidebar.setAttribute('aria-hidden', true);
        try { localStorage.setItem('mdbook-sidebar', 'hidden'); } catch (e) { }
    }

    // Toggle sidebar
    sidebarToggleButton.addEventListener('click', function sidebarToggle() {
        if (html.classList.contains("sidebar-hidden")) {
            showSidebar();
        } else if (html.classList.contains("sidebar-visible")) {
            hideSidebar();
        } else {
            if (getComputedStyle(sidebar)['transform'] === 'none') {
                hideSidebar();
            } else {
                showSidebar();
            }
        }
    });

    document.addEventListener('touchstart', function (e) {
        firstContact = {
            x: e.touches[0].clientX,
            time: Date.now()
        };
    }, { passive: true });

    document.addEventListener('touchmove', function (e) {
        if (!firstContact)
            return;

        var curX = e.touches[0].clientX;
        var xDiff = curX - firstContact.x,
            tDiff = Date.now() - firstContact.time;

        if (tDiff < 250 && Math.abs(xDiff) >= 150) {
            if (xDiff >= 0 && firstContact.x < Math.min(document.body.clientWidth * 0.25, 300))
                showSidebar();
            else if (xDiff < 0 && curX < 300)
                hideSidebar();

            firstContact = null;
        }
    }, { passive: true });

    // Scroll sidebar to current active section
    var activeSection = sidebar.querySelector(".active");
    if (activeSection) {
        sidebar.scrollTop = activeSection.offsetTop;
    }
})();

(function chapterNavigation() {
    document.addEventListener('keydown', function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
        if (window.search && window.search.hasFocus()) { return; }

        switch (e.key) {
            case 'ArrowRight':
                e.preventDefault();
                var nextButton = document.querySelector('.nav-chapters.next');
                if (nextButton) {
                    window.location.href = nextButton.href;
                }
                break;
            case 'ArrowLeft':
                e.preventDefault();
                var previousButton = document.querySelector('.nav-chapters.previous');
                if (previousButton) {
                    window.location.href = previousButton.href;
                }
                break;
        }
    });
})();

(function clipboard() {
    var clipButtons = document.querySelectorAll('.clip-button');

    function hideTooltip(elem) {
        elem.firstChild.innerText = "";
        elem.className = 'fa fa-copy clip-button';
    }

    function showTooltip(elem, msg) {
        elem.firstChild.innerText = msg;
        elem.className = 'fa fa-copy tooltipped';
    }

    var clipboardSnippets = new Clipboard('.clip-button', {
        text: function (trigger) {
            hideTooltip(trigger);
            let playpen = trigger.closest("pre");
            return playpen_text(playpen);
        }
    });

    Array.from(clipButtons).forEach(function (clipButton) {
        clipButton.addEventListener('mouseout', function (e) {
            hideTooltip(e.currentTarget);
        });
    });

    clipboardSnippets.on('success', function (e) {
        e.clearSelection();
        showTooltip(e.trigger, "Copied!");
    });

    clipboardSnippets.on('error', function (e) {
        showTooltip(e.trigger, "Clipboard error!");
    });
})();

(function scrollToTop () {
    var menuTitle = document.querySelector('.menu-title');

    menuTitle.addEventListener('click', function () {
        document.scrollingElement.scrollTo({ top: 0, behavior: 'smooth' });
    });
})();

(function autoHideMenu() {
    var menu = document.getElementById('menu-bar');

    var previousScrollTop = document.scrollingElement.scrollTop;

    document.addEventListener('scroll', function () {
        if (menu.classList.contains('folded') && document.scrollingElement.scrollTop < previousScrollTop) {
            menu.classList.remove('folded');
        } else if (!menu.classList.contains('folded') && document.scrollingElement.scrollTop > previousScrollTop) {
            menu.classList.add('folded');
        }

        if (!menu.classList.contains('bordered') && document.scrollingElement.scrollTop > 0) {
            menu.classList.add('bordered');
        }

        if (menu.classList.contains('bordered') && document.scrollingElement.scrollTop === 0) {
            menu.classList.remove('bordered');
        }

        previousScrollTop = document.scrollingElement.scrollTop;
    }, { passive: true });
})();

'''
'''--- guide/src/theme/css/chrome.css ---
/* CSS for UI elements (a.k.a. chrome) */

@import 'variables.css';

::-webkit-scrollbar {
    background: var(--bg);
}
::-webkit-scrollbar-thumb {
    background: var(--scrollbar);
}

#searchresults a,
.content a:link,
a:visited,
a > .hljs {
    color: var(--links);
}

/* Menu Bar */

#menu-bar {
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    z-index: 101;
    margin: auto calc(0px - var(--page-padding));
}
#menu-bar > #menu-bar-sticky-container {
    display: flex;
    flex-wrap: wrap;
    background-color: var(--bg);
    border-bottom-color: var(--bg);
    border-bottom-width: 1px;
    border-bottom-style: solid;
}
.js #menu-bar > #menu-bar-sticky-container {
    transition: transform 0.3s;
}
#menu-bar.bordered > #menu-bar-sticky-container  {
    border-bottom-color: var(--table-border-color);
}
#menu-bar i, #menu-bar .icon-button {
    position: relative;
    padding: 0 8px;
    z-index: 10;
    line-height: 50px;
    cursor: pointer;
    transition: color 0.5s;
}
@media only screen and (max-width: 420px) {
    #menu-bar i, #menu-bar .icon-button {
        padding: 0 5px;
    }
}

.icon-button {
    border: none;
    background: none;
    padding: 0;
    color: inherit;
}
.icon-button i {
    margin: 0;
}

#print-button {
    margin: 0 15px;
}

html:not(.sidebar-visible) #menu-bar:not(:hover).folded > #menu-bar-sticky-container {
    transform: translateY(-60px);
}

.left-buttons {
    display: flex;
    margin: 0 5px;
}
.no-js .left-buttons { 
    display: none;
}

.menu-title {
    display: inline-block;
    font-weight: 200;
    font-size: 20px;
    line-height: 50px;
    text-align: center;
    margin: 0;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.js .menu-title {
    cursor: pointer;
}

.menu-bar,
.menu-bar:visited,
.nav-chapters,
.nav-chapters:visited,
.mobile-nav-chapters,
.mobile-nav-chapters:visited,
.menu-bar .icon-button,
.menu-bar a i {
    color: var(--icons);
}

.menu-bar i:hover,
.menu-bar .icon-button:hover,
.nav-chapters:hover,
.mobile-nav-chapters i:hover {
    color: var(--icons-hover);
}

/* Nav Icons */

.nav-chapters {
    font-size: 2.5em;
    text-align: center;
    text-decoration: none;

    position: fixed;
    top: 50px; /* Height of menu-bar */
    bottom: 0;
    margin: 0;
    max-width: 150px;
    min-width: 90px;

    display: flex;
    justify-content: center;
    align-content: center;
    flex-direction: column;

    transition: color 0.5s;
}

.nav-chapters:hover { text-decoration: none; }

.nav-wrapper {
    margin-top: 50px;
    display: none;
}

.mobile-nav-chapters { 
    font-size: 2.5em;
    text-align: center;
    text-decoration: none;
    width: 90px;
    border-radius: 5px;
    background-color: var(--sidebar-bg);
}

.previous {
    float: left;
}

.next {
    float: right;
    right: var(--page-padding);
}

@media only screen and (max-width: 1080px) {
    .nav-wide-wrapper { display: none; }
    .nav-wrapper { display: block; }
}

@media only screen and (max-width: 1380px) {
    .sidebar-visible .nav-wide-wrapper { display: none; }
    .sidebar-visible .nav-wrapper { display: block; }
}

/* Inline code */

:not(pre) > .hljs {
    display: inline-block;
    vertical-align: middle;
    padding: 0.1em 0.3em;
    border-radius: 3px;
    color: var(--inline-code-color);
}

a:hover > .hljs {
    text-decoration: underline;
}

pre {
    position: relative;
}
pre > .buttons {
    position: absolute;
    z-index: 100;
    right: 5px;
    top: 5px;

    color: var(--sidebar-fg);
    cursor: pointer;
}
pre > .buttons :hover {
    color: var(--sidebar-active);
}
pre > .buttons i {
    margin-left: 8px;
}
pre > .buttons button {
    color: inherit;
    background: transparent;
    border: none;
    cursor: inherit;
}
pre > .result {
    margin-top: 10px;
}

/* Search */

#searchresults a {
    text-decoration: none;
}

mark {
    border-radius: 2px;
    padding: 0 3px 1px 3px;
    margin: 0 -3px -1px -3px;
    background-color: var(--search-mark-bg);
    transition: background-color 300ms linear;
    cursor: pointer;
}

mark.fade-out {
    background-color: rgba(0,0,0,0) !important;
    cursor: auto;
}

.searchbar-outer {
    margin-left: auto;
    margin-right: auto;
    max-width: var(--content-max-width);
}

#searchbar {
    width: 100%;
    margin: 5px auto 0px auto;
    padding: 10px 16px;
    transition: box-shadow 300ms ease-in-out;
    border: 1px solid var(--searchbar-border-color);
    border-radius: 3px;
    background-color: var(--searchbar-bg);
    color: var(--searchbar-fg);
}
#searchbar:focus,
#searchbar.active {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

.searchresults-header {
    font-weight: bold;
    font-size: 1em;
    padding: 18px 0 0 5px;
    color: var(--searchresults-header-fg);
}

.searchresults-outer {
    margin-left: auto;
    margin-right: auto;
    max-width: var(--content-max-width);
    border-bottom: 1px dashed var(--searchresults-border-color);
}

ul#searchresults {
    list-style: none;
    padding-left: 20px;
}
ul#searchresults li {
    margin: 10px 0px;
    padding: 2px;
    border-radius: 2px;
}
ul#searchresults li.focus {
    background-color: var(--searchresults-li-bg);
}
ul#searchresults span.teaser {
    display: block;
    clear: both;
    margin: 5px 0 0 20px;
    font-size: 0.8em;
}
ul#searchresults span.teaser em {
    font-weight: bold;
    font-style: normal;
}

/* Sidebar */

.sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: var(--sidebar-width);
    overflow-y: auto;
    padding: 10px 10px;
    font-size: 0.875em;
    box-sizing: border-box;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-y: contain;
    background-color: var(--sidebar-bg);
    color: var(--sidebar-fg);
}
.js .sidebar {
    transition: transform 0.3s; /* Animation: slide away */
}
.sidebar code {
    line-height: 2em;
}
.sidebar-hidden .sidebar {
    transform: translateX(calc(0px - var(--sidebar-width)));
}
.sidebar::-webkit-scrollbar {
    background: var(--sidebar-bg);
}
.sidebar::-webkit-scrollbar-thumb {
    background: var(--scrollbar);
}

.sidebar-visible .page-wrapper {
    transform: translateX(var(--sidebar-width));
}
@media only screen and (min-width: 620px) {
    .sidebar-visible .page-wrapper {
        transform: none;
        margin-left: var(--sidebar-width);
    }
}

.chapter {
    list-style: none outside none;
    padding-left: 0;
    line-height: 2.2em;
}
.chapter li {
    color: var(--sidebar-non-existant);
}
.chapter li a {
    color: var(--sidebar-fg);
    display: block;
    padding: 0;
    text-decoration: none;
}
.chapter li a:hover { text-decoration: none }
.chapter li .active,
a:hover {
    /* Animate color change */
    color: var(--sidebar-active);
}

.spacer {
    width: 100%;
    height: 3px;
    margin: 5px 0px;
}
.chapter .spacer {
    background-color: var(--sidebar-spacer);
}

@media (-moz-touch-enabled: 1), (pointer: coarse) { 
    .chapter li a { padding: 5px 0; }
    .spacer { margin: 10px 0; }
}

.section {
    list-style: none outside none;
    padding-left: 20px;
    line-height: 1.9em;
}

/* Theme Menu Popup */

.theme-popup {
    position: absolute;
    left: 10px;
    top: 50px;
    z-index: 1000;
    border-radius: 4px;
    font-size: 0.7em;
    color: var(--fg);
    background: var(--theme-popup-bg);
    border: 1px solid var(--theme-popup-border);
    margin: 0;
    padding: 0;
    list-style: none;
    display: none;
}
.theme-popup .default {
    color: var(--icons);
}
.theme-popup .theme {
    width: 100%;
    border: 0;
    margin: 0;
    padding: 2px 10px;
    line-height: 25px;
    white-space: nowrap;
    text-align: left;
    cursor: pointer;
    color: inherit;
    background: inherit;
    font-size: inherit;
}
.theme-popup .theme:hover {
    background-color: var(--theme-hover);
}
.theme-popup .theme:hover:first-child,
.theme-popup .theme:hover:last-child {
    border-top-left-radius: inherit;
    border-top-right-radius: inherit;
}

'''
'''--- guide/src/theme/css/general.css ---
/* Base styles and content styles */

@import 'variables.css';

html {
    font-family: "Open Sans", sans-serif;
    color: var(--fg);
    background-color: var(--bg);
    text-size-adjust: none;
}

body {
    margin: 0;
    font-size: 1rem;
    overflow-x: hidden;
}

/* code { */
/*     font-family: "Source Code Pro", Consolas, "Ubuntu Mono", Menlo, "DejaVu Sans Mono", monospace, monospace; */
/*     font-size: 0.875em; /\* please adjust the ace font size accordingly in editor.js *\/ */
/* } */

.left { float: left; }
.right { float: right; }
.hidden { display: none; }
.play-button.hidden { display: none; }

h2, h3 { margin-top: 2.5em; }
h4, h5 { margin-top: 2em; }

.header + .header h3,
.header + .header h4,
.header + .header h5 {
    margin-top: 1em;
}

a.header:target h1:before,
a.header:target h2:before,
a.header:target h3:before,
a.header:target h4:before {
    display: inline-block;
    content: "»";
    margin-left: -30px;
    width: 30px;
}

.page {
    outline: 0;
    padding: 0 var(--page-padding);
}
.page-wrapper {
    box-sizing: border-box;
}
.js .page-wrapper {
    transition: margin-left 0.3s ease, transform 0.3s ease; /* Animation: slide away */
}

.content {
    overflow-y: auto;
    padding: 0 15px;
    padding-bottom: 50px;
}
.content main {
    margin-left: auto;
    margin-right: auto;
    max-width: var(--content-max-width);
}
.content a { text-decoration: none; }
.content a:hover { text-decoration: underline; }
.content img { max-width: 100%; }
.content .header:link,
.content .header:visited {
    color: var(--fg);
}
.content .header:link,
.content .header:visited:hover {
    text-decoration: none;
}

table {
    margin: 0 auto;
    border-collapse: collapse;
}
table td {
    padding: 3px 20px;
    border: 1px var(--table-border-color) solid;
}
table thead {
    background: var(--table-header-bg);
}
table thead td {
    font-weight: 700;
    border: none;
}
table thead tr {
    border: 1px var(--table-header-bg) solid;
}
/* Alternate background colors for rows */
table tbody tr:nth-child(2n) {
    background: var(--table-alternate-bg);
}

blockquote {
    margin: 20px 0;
    padding: 0 20px;
    color: var(--fg);
    background-color: var(--quote-bg);
    border-top: .1em solid var(--quote-border);
    border-bottom: .1em solid var(--quote-border);
}

:not(.footnote-definition) + .footnote-definition,
.footnote-definition + :not(.footnote-definition) {
    margin-top: 2em;
}
.footnote-definition {
    font-size: 0.9em;
    margin: 0.5em 0;
}
.footnote-definition p {
    display: inline;
}

.tooltiptext {
    position: absolute;
    visibility: hidden;
    color: #fff;
    background-color: #333;
    transform: translateX(-50%); /* Center by moving tooltip 50% of its width left */
    left: -8px; /* Half of the width of the icon */
    top: -35px;
    font-size: 0.8em;
    text-align: center;
    border-radius: 6px;
    padding: 5px 8px;
    margin: 5px;
    z-index: 1000;
}
.tooltipped .tooltiptext {
    visibility: visible;
}

'''
'''--- guide/src/theme/css/print.css ---

#sidebar,
#menu-bar,
.nav-chapters,
.mobile-nav-chapters {
    display: none;
}

#page-wrapper.page-wrapper {
    transform: none;
    margin-left: 0px;
    overflow-y: initial;
}

#content {
    max-width: none;
    margin: 0;
    padding: 0;
}

.page {
    overflow-y: initial;
}

code {
    background-color: #666666;
    border-radius: 5px;

    /* Force background to be printed in Chrome */
    -webkit-print-color-adjust: exact;
}

pre > .buttons {
    z-index: 2;
}

a, a:visited, a:active, a:hover {
    color: #4183c4;
    text-decoration: none;
}

h1, h2, h3, h4, h5, h6 {
    page-break-inside: avoid;
    page-break-after: avoid;
}

pre, code {
    page-break-inside: avoid;
    white-space: pre-wrap;
}

.fa {
    display: none !important;
}

'''
'''--- guide/src/theme/css/variables.css ---

/* Globals */

:root {
    --sidebar-width: 300px;
    --page-padding: 15px;
    --content-max-width: 750px;
}

/* Themes */

.ayu {
    --bg: hsl(210, 25%, 8%);
    --fg: #c5c5c5;

    --sidebar-bg: #14191f;
    --sidebar-fg: #c8c9db;
    --sidebar-non-existant: #5c6773;
    --sidebar-active: #ffb454;
    --sidebar-spacer: #2d334f;

    --scrollbar: var(--sidebar-fg);

    --icons: #737480;
    --icons-hover: #b7b9cc;

    --links: #0096cf;

    --inline-code-color: #ffb454;

    --theme-popup-bg: #14191f;
    --theme-popup-border: #5c6773;
    --theme-hover: #191f26;

    --quote-bg: hsl(226, 15%, 17%);
    --quote-border: hsl(226, 15%, 22%);

    --table-border-color: hsl(210, 25%, 13%);
    --table-header-bg: hsl(210, 25%, 28%);
    --table-alternate-bg: hsl(210, 25%, 11%);

    --searchbar-border-color: #848484;
    --searchbar-bg: #424242;
    --searchbar-fg: #fff;
    --searchbar-shadow-color: #d4c89f;
    --searchresults-header-fg: #666;
    --searchresults-border-color: #888;
    --searchresults-li-bg: #252932;
    --search-mark-bg: #e3b171;
}

.coal {
    --bg: hsl(200, 7%, 8%);
    --fg: #98a3ad;

    --sidebar-bg: #292c2f;
    --sidebar-fg: #a1adb8;
    --sidebar-non-existant: #505254;
    --sidebar-active: #3473ad;
    --sidebar-spacer: #393939;

    --scrollbar: var(--sidebar-fg);

    --icons: #43484d;
    --icons-hover: #b3c0cc;

    --links: #2b79a2;

    --inline-code-color: #c5c8c6;;

    --theme-popup-bg: #141617;
    --theme-popup-border: #43484d;
    --theme-hover: #1f2124;

    --quote-bg: hsl(234, 21%, 18%);
    --quote-border: hsl(234, 21%, 23%);

    --table-border-color: hsl(200, 7%, 13%);
    --table-header-bg: hsl(200, 7%, 28%);
    --table-alternate-bg: hsl(200, 7%, 11%);

    --searchbar-border-color: #aaa;
    --searchbar-bg: #b7b7b7;
    --searchbar-fg: #000;
    --searchbar-shadow-color: #aaa;
    --searchresults-header-fg: #666;
    --searchresults-border-color: #98a3ad;
    --searchresults-li-bg: #2b2b2f;
    --search-mark-bg: #355c7d;
}

.light {
    --bg: hsl(0, 0%, 100%);
    --fg: #333333;

    --sidebar-bg: #fafafa;
    --sidebar-fg: #364149;
    --sidebar-non-existant: #aaaaaa;
    --sidebar-active: #008cff;
    --sidebar-spacer: #f4f4f4;

    --scrollbar: #cccccc;

    --icons: #cccccc;
    --icons-hover: #333333;

    --links: #4183c4;

    --inline-code-color: #6e6b5e;

    --theme-popup-bg: #fafafa;
    --theme-popup-border: #cccccc;
    --theme-hover: #e6e6e6;

    --quote-bg: hsl(197, 37%, 96%);
    --quote-border: hsl(197, 37%, 91%);

    --table-border-color: hsl(0, 0%, 95%);
    --table-header-bg: hsl(0, 0%, 80%);
    --table-alternate-bg: hsl(0, 0%, 97%);

    --searchbar-border-color: #aaa;
    --searchbar-bg: #fafafa;
    --searchbar-fg: #000;
    --searchbar-shadow-color: #aaa;
    --searchresults-header-fg: #666;
    --searchresults-border-color: #888;
    --searchresults-li-bg: #e4f2fe;
    --search-mark-bg: #a2cff5;
}

.navy {
    --bg: hsl(226, 23%, 11%);
    --fg: #bcbdd0;

    --sidebar-bg: #282d3f;
    --sidebar-fg: #c8c9db;
    --sidebar-non-existant: #505274;
    --sidebar-active: #2b79a2;
    --sidebar-spacer: #2d334f;

    --scrollbar: var(--sidebar-fg);

    --icons: #737480;
    --icons-hover: #b7b9cc;

    --links: #2b79a2;

    --inline-code-color: #c5c8c6;;

    --theme-popup-bg: #161923;
    --theme-popup-border: #737480;
    --theme-hover: #282e40;

    --quote-bg: hsl(226, 15%, 17%);
    --quote-border: hsl(226, 15%, 22%);

    --table-border-color: hsl(226, 23%, 16%);
    --table-header-bg: hsl(226, 23%, 31%);
    --table-alternate-bg: hsl(226, 23%, 14%);

    --searchbar-border-color: #aaa;
    --searchbar-bg: #aeaec6;
    --searchbar-fg: #000;
    --searchbar-shadow-color: #aaa;
    --searchresults-header-fg: #5f5f71;
    --searchresults-border-color: #5c5c68;
    --searchresults-li-bg: #242430;
    --search-mark-bg: #a2cff5;
}

.rust {
    --bg: hsl(60, 9%, 87%);
    --fg: #262625;

    --sidebar-bg: #3b2e2a;
    --sidebar-fg: #c8c9db;
    --sidebar-non-existant: #505254;
    --sidebar-active: #e69f67;
    --sidebar-spacer: #45373a;

    --scrollbar: var(--sidebar-fg);

    --icons: #737480;
    --icons-hover: #262625;

    --links: #2b79a2;

    --inline-code-color: #6e6b5e;

    --theme-popup-bg: #e1e1db;
    --theme-popup-border: #b38f6b;
    --theme-hover: #99908a;

    --quote-bg: hsl(60, 5%, 75%);
    --quote-border: hsl(60, 5%, 70%);

    --table-border-color: hsl(60, 9%, 82%);
    --table-header-bg: #b3a497;
    --table-alternate-bg: hsl(60, 9%, 84%);

    --searchbar-border-color: #aaa;
    --searchbar-bg: #fafafa;
    --searchbar-fg: #000;
    --searchbar-shadow-color: #aaa;
    --searchresults-header-fg: #666;
    --searchresults-border-color: #888;
    --searchresults-li-bg: #dec2a2;
    --search-mark-bg: #e69f67;
}

'''
'''--- guide/src/theme/highlight.css ---
/* Base16 Atelier Dune Light - Theme */
/* by Bram de Haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune) */
/* Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16) */

/* Atelier-Dune Comment */
.hljs-comment,
.hljs-quote {
  color: #AAA;
}

/* Atelier-Dune Red */
.hljs-variable,
.hljs-template-variable,
.hljs-attribute,
.hljs-tag,
.hljs-name,
.hljs-regexp,
.hljs-link,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #d73737;
}

/* Atelier-Dune Orange */
.hljs-number,
.hljs-meta,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params {
  color: #b65611;
}

/* Atelier-Dune Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet {
  color: #60ac39;
}

/* Atelier-Dune Blue */
.hljs-title,
.hljs-section {
  color: #6684e1;
}

/* Atelier-Dune Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #b854d4;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #f1f1f1;
  color: #6e6b5e;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

'''
'''--- guide/src/theme/highlight.js ---
/*! highlight.js v9.12.0 | BSD3 License | git.io/hljslicense */
!function(e){var n="object"==typeof window&&window||"object"==typeof self&&self;"undefined"!=typeof exports?e(exports):n&&(n.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return n.hljs}))}(function(e){function n(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0===t.index}function a(e){return k.test(e)}function i(e){var n,t,r,i,o=e.className+" ";if(o+=e.parentNode?e.parentNode.className:"",t=B.exec(o))return w(t[1])?t[1]:"no-highlight";for(o=o.split(/\s+/),n=0,r=o.length;r>n;n++)if(i=o[n],a(i)||w(i))return i}function o(e){var n,t={},r=Array.prototype.slice.call(arguments,1);for(n in e)t[n]=e[n];return r.forEach(function(e){for(n in e)t[n]=e[n]}),t}function u(e){var n=[];return function r(e,a){for(var i=e.firstChild;i;i=i.nextSibling)3===i.nodeType?a+=i.nodeValue.length:1===i.nodeType&&(n.push({event:"start",offset:a,node:i}),a=r(i,a),t(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:i}));return a}(e,0),n}function c(e,r,a){function i(){return e.length&&r.length?e[0].offset!==r[0].offset?e[0].offset<r[0].offset?e:r:"start"===r[0].event?e:r:e.length?e:r}function o(e){function r(e){return" "+e.nodeName+'="'+n(e.value).replace('"',"&quot;")+'"'}s+="<"+t(e)+E.map.call(e.attributes,r).join("")+">"}function u(e){s+="</"+t(e)+">"}function c(e){("start"===e.event?o:u)(e.node)}for(var l=0,s="",f=[];e.length||r.length;){var g=i();if(s+=n(a.substring(l,g[0].offset)),l=g[0].offset,g===e){f.reverse().forEach(u);do c(g.splice(0,1)[0]),g=i();while(g===e&&g.length&&g[0].offset===l);f.reverse().forEach(o)}else"start"===g[0].event?f.push(g[0].node):f.pop(),c(g.splice(0,1)[0])}return s+n(a.substr(l))}function l(e){return e.v&&!e.cached_variants&&(e.cached_variants=e.v.map(function(n){return o(e,{v:null},n)})),e.cached_variants||e.eW&&[o(e)]||[e]}function s(e){function n(e){return e&&e.source||e}function t(t,r){return new RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var o={},u=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");o[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?u("keyword",a.k):x(a.k).forEach(function(e){u(e,a.k[e])}),a.k=o}a.lR=t(a.l||/\w+/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),null==a.r&&(a.r=1),a.c||(a.c=[]),a.c=Array.prototype.concat.apply([],a.c.map(function(e){return l("self"===e?a:e)})),a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var c=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=c.length?t(c.join("|"),!0):{exec:function(){return null}}}}r(e)}function f(e,t,a,i){function o(e,n){var t,a;for(t=0,a=n.c.length;a>t;t++)if(r(n.c[t].bR,e))return n.c[t]}function u(e,n){if(r(e.eR,n)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?u(e.parent,n):void 0}function c(e,n){return!a&&r(n.iR,e)}function l(e,n){var t=N.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function p(e,n,t,r){var a=r?"":I.classPrefix,i='<span class="'+a,o=t?"":C;return i+=e+'">',i+n+o}function h(){var e,t,r,a;if(!E.k)return n(k);for(a="",t=0,E.lR.lastIndex=0,r=E.lR.exec(k);r;)a+=n(k.substring(t,r.index)),e=l(E,r),e?(B+=e[1],a+=p(e[0],n(r[0]))):a+=n(r[0]),t=E.lR.lastIndex,r=E.lR.exec(k);return a+n(k.substr(t))}function d(){var e="string"==typeof E.sL;if(e&&!y[E.sL])return n(k);var t=e?f(E.sL,k,!0,x[E.sL]):g(k,E.sL.length?E.sL:void 0);return E.r>0&&(B+=t.r),e&&(x[E.sL]=t.top),p(t.language,t.value,!1,!0)}function b(){L+=null!=E.sL?d():h(),k=""}function v(e){L+=e.cN?p(e.cN,"",!0):"",E=Object.create(e,{parent:{value:E}})}function m(e,n){if(k+=e,null==n)return b(),0;var t=o(n,E);if(t)return t.skip?k+=n:(t.eB&&(k+=n),b(),t.rB||t.eB||(k=n)),v(t,n),t.rB?0:n.length;var r=u(E,n);if(r){var a=E;a.skip?k+=n:(a.rE||a.eE||(k+=n),b(),a.eE&&(k=n));do E.cN&&(L+=C),E.skip||(B+=E.r),E=E.parent;while(E!==r.parent);return r.starts&&v(r.starts,""),a.rE?0:n.length}if(c(n,E))throw new Error('Illegal lexeme "'+n+'" for mode "'+(E.cN||"<unnamed>")+'"');return k+=n,n.length||1}var N=w(e);if(!N)throw new Error('Unknown language: "'+e+'"');s(N);var R,E=i||N,x={},L="";for(R=E;R!==N;R=R.parent)R.cN&&(L=p(R.cN,"",!0)+L);var k="",B=0;try{for(var M,j,O=0;;){if(E.t.lastIndex=O,M=E.t.exec(t),!M)break;j=m(t.substring(O,M.index),M[0]),O=M.index+j}for(m(t.substr(O)),R=E;R.parent;R=R.parent)R.cN&&(L+=C);return{r:B,value:L,language:e,top:E}}catch(T){if(T.message&&-1!==T.message.indexOf("Illegal"))return{r:0,value:n(t)};throw T}}function g(e,t){t=t||I.languages||x(y);var r={r:0,value:n(e)},a=r;return t.filter(w).forEach(function(n){var t=f(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}),a.language&&(r.second_best=a),r}function p(e){return I.tabReplace||I.useBR?e.replace(M,function(e,n){return I.useBR&&"\n"===e?"<br>":I.tabReplace?n.replace(/\t/g,I.tabReplace):""}):e}function h(e,n,t){var r=n?L[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),-1===e.indexOf(r)&&a.push(r),a.join(" ").trim()}function d(e){var n,t,r,o,l,s=i(e);a(s)||(I.useBR?(n=document.createElementNS("http://www.w3.org/1999/xhtml","div"),n.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):n=e,l=n.textContent,r=s?f(s,l,!0):g(l),t=u(n),t.length&&(o=document.createElementNS("http://www.w3.org/1999/xhtml","div"),o.innerHTML=r.value,r.value=c(t,u(o),l)),r.value=p(r.value),e.innerHTML=r.value,e.className=h(e.className,s,r.language),e.result={language:r.language,re:r.r},r.second_best&&(e.second_best={language:r.second_best.language,re:r.second_best.r}))}function b(e){I=o(I,e)}function v(){if(!v.called){v.called=!0;var e=document.querySelectorAll("pre code");E.forEach.call(e,d)}}function m(){addEventListener("DOMContentLoaded",v,!1),addEventListener("load",v,!1)}function N(n,t){var r=y[n]=t(e);r.aliases&&r.aliases.forEach(function(e){L[e]=n})}function R(){return x(y)}function w(e){return e=(e||"").toLowerCase(),y[e]||y[L[e]]}var E=[],x=Object.keys,y={},L={},k=/^(no-?highlight|plain|text)$/i,B=/\blang(?:uage)?-([\w-]+)\b/i,M=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,C="</span>",I={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0};return e.highlight=f,e.highlightAuto=g,e.fixMarkup=p,e.highlightBlock=d,e.configure=b,e.initHighlighting=v,e.initHighlightingOnLoad=m,e.registerLanguage=N,e.listLanguages=R,e.getLanguage=w,e.inherit=o,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},e.C=function(n,t,r){var a=e.inherit({cN:"comment",b:n,e:t,c:[]},r||{});return a.c.push(e.PWM),a.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),a},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.METHOD_GUARD={b:"\\.\\s*"+e.UIR,r:0},e});hljs.registerLanguage("diff",function(e){return{aliases:["patch"],c:[{cN:"meta",r:10,v:[{b:/^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"comment",v:[{b:/Index: /,e:/$/},{b:/={3,}/,e:/$/},{b:/^\-{3}/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+{3}/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"addition",b:"^\\!",e:"$"}]}});hljs.registerLanguage("nginx",function(e){var r={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},b={eW:!0,l:"[a-z/_]+",k:{literal:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,r],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0,c:[r]},{cN:"regexp",c:[e.BE,r],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},r]};return{aliases:["nginxconf"],c:[e.HCM,{b:e.UIR+"\\s+{",rB:!0,e:"{",c:[{cN:"section",b:e.UIR}],r:0},{b:e.UIR+"\\s",e:";|{",rB:!0,c:[{cN:"attribute",b:e.UIR,starts:b}],r:0}],i:"[^\\s\\}]"}});hljs.registerLanguage("objectivec",function(e){var t={cN:"built_in",b:"\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"},_={keyword:"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required @encode @package @import @defs @compatibility_alias __bridge __bridge_transfer __bridge_retained __bridge_retain __covariant __contravariant __kindof _Nonnull _Nullable _Null_unspecified __FUNCTION__ __PRETTY_FUNCTION__ __attribute__ getter setter retain unsafe_unretained nonnull nullable null_unspecified null_resettable class instancetype NS_DESIGNATED_INITIALIZER NS_UNAVAILABLE NS_REQUIRES_SUPER NS_RETURNS_INNER_POINTER NS_INLINE NS_AVAILABLE NS_DEPRECATED NS_ENUM NS_OPTIONS NS_SWIFT_UNAVAILABLE NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_REFINED_FOR_SWIFT NS_SWIFT_NAME NS_SWIFT_NOTHROW NS_DURING NS_HANDLER NS_ENDHANDLER NS_VALUERETURN NS_VOIDRETURN",literal:"false true FALSE TRUE nil YES NO NULL",built_in:"BOOL dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once"},i=/[a-zA-Z@][a-zA-Z0-9_]*/,n="@interface @class @protocol @implementation";return{aliases:["mm","objc","obj-c"],k:_,l:i,i:"</",c:[t,e.CLCM,e.CBCM,e.CNM,e.QSM,{cN:"string",v:[{b:'@"',e:'"',i:"\\n",c:[e.BE]},{b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"}]},{cN:"meta",b:"#",e:"$",c:[{cN:"meta-string",v:[{b:'"',e:'"'},{b:"<",e:">"}]}]},{cN:"class",b:"("+n.split(" ").join("|")+")\\b",e:"({|$)",eE:!0,k:n,l:i,c:[e.UTM]},{b:"\\."+e.UIR,r:0}]}});hljs.registerLanguage("xml",function(s){var e="[A-Za-z0-9\\._:-]+",t={eW:!0,i:/</,r:0,c:[{cN:"attr",b:e,r:0},{b:/=\s*/,r:0,c:[{cN:"string",endsParent:!0,v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s"'=<>`]+/}]}]}]};return{aliases:["html","xhtml","rss","atom","xjb","xsd","xsl","plist"],cI:!0,c:[{cN:"meta",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},s.C("<!--","-->",{r:10}),{b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{b:/<\?(php)?/,e:/\?>/,sL:"php",c:[{b:"/\\*",e:"\\*/",skip:!0}]},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{name:"style"},c:[t],starts:{e:"</style>",rE:!0,sL:["css","xml"]}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{name:"script"},c:[t],starts:{e:"</script>",rE:!0,sL:["actionscript","javascript","handlebars","xml"]}},{cN:"meta",v:[{b:/<\?xml/,e:/\?>/,r:10},{b:/<\?\w+/,e:/\?>/}]},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"name",b:/[^\/><\s]+/,r:0},t]}]}});hljs.registerLanguage("handlebars",function(e){var a={"builtin-name":"each in with if else unless bindattr action collection debugger log outlet template unbound view yield"};return{aliases:["hbs","html.hbs","html.handlebars"],cI:!0,sL:"xml",c:[e.C("{{!(--)?","(--)?}}"),{cN:"template-tag",b:/\{\{[#\/]/,e:/\}\}/,c:[{cN:"name",b:/[a-zA-Z\.-]+/,k:a,starts:{eW:!0,r:0,c:[e.QSM]}}]},{cN:"template-variable",b:/\{\{/,e:/\}\}/,k:a}]}});hljs.registerLanguage("ini",function(e){var b={cN:"string",c:[e.BE],v:[{b:"'''",e:"'''",r:10},{b:'"""',e:'"""',r:10},{b:'"',e:'"'},{b:"'",e:"'"}]};return{aliases:["toml"],cI:!0,i:/\S/,c:[e.C(";","$"),e.HCM,{cN:"section",b:/^\s*\[+/,e:/\]+/},{b:/^[a-z0-9\[\]_-]+\s*=\s*/,e:"$",rB:!0,c:[{cN:"attr",b:/[a-z0-9\[\]_-]+/},{b:/=/,eW:!0,r:0,c:[{cN:"literal",b:/\bon|off|true|false|yes|no\b/},{cN:"variable",v:[{b:/\$[\w\d"][\w\d_]*/},{b:/\$\{(.*?)}/}]},b,{cN:"number",b:/([\+\-]+)?[\d]+_[\d_]+/},e.NM]}]}]}});hljs.registerLanguage("javascript",function(e){var r="[A-Za-z$_][0-9A-Za-z$_]*",t={keyword:"in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await static import from as",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"},a={cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},n={cN:"subst",b:"\\$\\{",e:"\\}",k:t,c:[]},c={cN:"string",b:"`",e:"`",c:[e.BE,n]};n.c=[e.ASM,e.QSM,c,a,e.RM];var s=n.c.concat([e.CBCM,e.CLCM]);return{aliases:["js","jsx"],k:t,c:[{cN:"meta",r:10,b:/^\s*['"]use (strict|asm)['"]/},{cN:"meta",b:/^#!/,e:/$/},e.ASM,e.QSM,c,e.CLCM,e.CBCM,a,{b:/[{,]\s*/,r:0,c:[{b:r+"\\s*:",rB:!0,r:0,c:[{cN:"attr",b:r,r:0}]}]},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{cN:"function",b:"(\\(.*?\\)|"+r+")\\s*=>",rB:!0,e:"\\s*=>",c:[{cN:"params",v:[{b:r},{b:/\(\s*\)/},{b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,c:s}]}]},{b:/</,e:/(\/\w+|\w+\/)>/,sL:"xml",c:[{b:/<\w+\s*\/>/,skip:!0},{b:/<\w+/,e:/(\/\w+|\w+\/)>/,skip:!0,c:[{b:/<\w+\s*\/>/,skip:!0},"self"]}]}],r:0},{cN:"function",bK:"function",e:/\{/,eE:!0,c:[e.inherit(e.TM,{b:r}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,c:s}],i:/\[|%/},{b:/\$[(.]/},e.METHOD_GUARD,{cN:"class",bK:"class",e:/[{;=]/,eE:!0,i:/[:"\[\]]/,c:[{bK:"extends"},e.UTM]},{bK:"constructor",e:/\{/,eE:!0}],i:/#(?!!)/}});hljs.registerLanguage("python",function(e){var r={keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10 None True False",built_in:"Ellipsis NotImplemented"},b={cN:"meta",b:/^(>>>|\.\.\.) /},c={cN:"subst",b:/\{/,e:/\}/,k:r,i:/#/},a={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[b],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[b],r:10},{b:/(fr|rf|f)'''/,e:/'''/,c:[b,c]},{b:/(fr|rf|f)"""/,e:/"""/,c:[b,c]},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},{b:/(fr|rf|f)'/,e:/'/,c:[c]},{b:/(fr|rf|f)"/,e:/"/,c:[c]},e.ASM,e.QSM]},s={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},i={cN:"params",b:/\(/,e:/\)/,c:["self",b,s,a]};return c.c=[a,s,b],{aliases:["py","gyp"],k:r,i:/(<\/|->|\?)|=>/,c:[b,s,a,e.HCM,{v:[{cN:"function",bK:"def"},{cN:"class",bK:"class"}],e:/:/,i:/[${=;\n,]/,c:[e.UTM,i,{b:/->/,eW:!0,k:"None"}]},{cN:"meta",b:/^[\t ]*@/,e:/$/},{b:/\b(print|exec)\(/}]}});hljs.registerLanguage("markdown",function(e){return{aliases:["md","mkdown","mkd"],c:[{cN:"section",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"quote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"^```w*s*$",e:"^```s*$"},{b:"`.+?`"},{b:"^( {4}|	)",e:"$",r:0}]},{b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].*?[\\)\\]]",rB:!0,c:[{cN:"string",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"symbol",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:/^\[[^\n]+\]:/,rB:!0,c:[{cN:"symbol",b:/\[/,e:/\]/,eB:!0,eE:!0},{cN:"link",b:/:\s*/,e:/$/,eB:!0}]}]}});hljs.registerLanguage("php",function(e){var c={b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},i={cN:"meta",b:/<\?(php)?|\?>/},t={cN:"string",c:[e.BE,i],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},a={v:[e.BNM,e.CNM]};return{aliases:["php3","php4","php5","php6"],cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.HCM,e.C("//","$",{c:[i]}),e.C("/\\*","\\*/",{c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.C("__halt_compiler.+?;",!1,{eW:!0,k:"__halt_compiler",l:e.UIR}),{cN:"string",b:/<<<['"]?\w+['"]?$/,e:/^\w+;?$/,c:[e.BE,{cN:"subst",v:[{b:/\$\w+/},{b:/\{\$/,e:/\}/}]}]},i,{cN:"keyword",b:/\$this\b/},c,{b:/(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/},{cN:"function",bK:"function",e:/[;{]/,eE:!0,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",c,e.CBCM,t,a]}]},{cN:"class",bK:"class interface",e:"{",eE:!0,i:/[:\(\$"]/,c:[{bK:"extends implements"},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},t,a]}});hljs.registerLanguage("d",function(e){var t={keyword:"abstract alias align asm assert auto body break byte case cast catch class const continue debug default delete deprecated do else enum export extern final finally for foreach foreach_reverse|10 goto if immutable import in inout int interface invariant is lazy macro mixin module new nothrow out override package pragma private protected public pure ref return scope shared static struct super switch synchronized template this throw try typedef typeid typeof union unittest version void volatile while with __FILE__ __LINE__ __gshared|10 __thread __traits __DATE__ __EOF__ __TIME__ __TIMESTAMP__ __VENDOR__ __VERSION__",built_in:"bool cdouble cent cfloat char creal dchar delegate double dstring float function idouble ifloat ireal long real short string ubyte ucent uint ulong ushort wchar wstring",literal:"false null true"},r="(0|[1-9][\\d_]*)",a="(0|[1-9][\\d_]*|\\d[\\d_]*|[\\d_]+?\\d)",i="0[bB][01_]+",n="([\\da-fA-F][\\da-fA-F_]*|_[\\da-fA-F][\\da-fA-F_]*)",_="0[xX]"+n,c="([eE][+-]?"+a+")",d="("+a+"(\\.\\d*|"+c+")|\\d+\\."+a+a+"|\\."+r+c+"?)",o="(0[xX]("+n+"\\."+n+"|\\.?"+n+")[pP][+-]?"+a+")",s="("+r+"|"+i+"|"+_+")",l="("+o+"|"+d+")",u="\\\\(['\"\\?\\\\abfnrtv]|u[\\dA-Fa-f]{4}|[0-7]{1,3}|x[\\dA-Fa-f]{2}|U[\\dA-Fa-f]{8})|&[a-zA-Z\\d]{2,};",b={cN:"number",b:"\\b"+s+"(L|u|U|Lu|LU|uL|UL)?",r:0},f={cN:"number",b:"\\b("+l+"([fF]|L|i|[fF]i|Li)?|"+s+"(i|[fF]i|Li))",r:0},g={cN:"string",b:"'("+u+"|.)",e:"'",i:"."},h={b:u,r:0},p={cN:"string",b:'"',c:[h],e:'"[cwd]?'},m={cN:"string",b:'[rq]"',e:'"[cwd]?',r:5},w={cN:"string",b:"`",e:"`[cwd]?"},N={cN:"string",b:'x"[\\da-fA-F\\s\\n\\r]*"[cwd]?',r:10},A={cN:"string",b:'q"\\{',e:'\\}"'},F={cN:"meta",b:"^#!",e:"$",r:5},y={cN:"meta",b:"#(line)",e:"$",r:5},L={cN:"keyword",b:"@[a-zA-Z_][a-zA-Z_\\d]*"},v=e.C("\\/\\+","\\+\\/",{c:["self"],r:10});return{l:e.UIR,k:t,c:[e.CLCM,e.CBCM,v,N,p,m,w,A,f,b,g,F,y,L]}});hljs.registerLanguage("json",function(e){var i={literal:"true false null"},n=[e.QSM,e.CNM],r={e:",",eW:!0,eE:!0,c:n,k:i},t={b:"{",e:"}",c:[{cN:"attr",b:/"/,e:/"/,c:[e.BE],i:"\\n"},e.inherit(r,{b:/:/})],i:"\\S"},c={b:"\\[",e:"\\]",c:[e.inherit(r)],i:"\\S"};return n.splice(n.length,0,t,c),{c:n,k:i,i:"\\S"}});hljs.registerLanguage("go",function(e){var t={keyword:"break default func interface select case map struct chan else goto package switch const fallthrough if range type continue for import return var go defer bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 uint16 uint32 uint64 int uint uintptr rune",literal:"true false iota nil",built_in:"append cap close complex copy imag len make new panic print println real recover delete"};return{aliases:["golang"],k:t,i:"</",c:[e.CLCM,e.CBCM,{cN:"string",v:[e.QSM,{b:"'",e:"[^\\\\]'"},{b:"`",e:"`"}]},{cN:"number",v:[{b:e.CNR+"[dflsi]",r:1},e.CNM]},{b:/:=/},{cN:"function",bK:"func",e:/\s*\{/,eE:!0,c:[e.TM,{cN:"params",b:/\(/,e:/\)/,k:t,i:/["']/}]}]}});hljs.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},s={b:"->{",e:"}"},n={v:[{b:/\$\d/},{b:/[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/},{b:/[\$%@][^\s\w{]/,r:0}]},i=[e.BE,r,n],o=[n,e.HCM,e.C("^\\=\\w","\\=cut",{eW:!0}),s,{cN:"string",c:i,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"function",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",eE:!0,r:5,c:[e.TM]},{b:"-\\w\\b",r:0},{b:"^__DATA__$",e:"^__END__$",sL:"mojolicious",c:[{b:"^@@.*",e:"$",cN:"comment"}]}];return r.c=o,s.c=o,{aliases:["pl","pm"],l:/[\w\.]+/,k:t,c:o}});hljs.registerLanguage("rust",function(e){var t="([ui](8|16|32|64|128|size)|f(32|64))?",r="alignof as be box break const continue crate do else enum extern false fn for if impl in let loop match mod mut offsetof once priv proc pub pure ref return self Self sizeof static struct super trait true type typeof unsafe unsized use virtual while where yield move default",n="drop i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize f32 f64 str char bool Box Option Result String Vec Copy Send Sized Sync Drop Fn FnMut FnOnce ToOwned Clone Debug PartialEq PartialOrd Eq Ord AsRef AsMut Into From Default Iterator Extend IntoIterator DoubleEndedIterator ExactSizeIterator SliceConcatExt ToString assert! assert_eq! bitflags! bytes! cfg! col! concat! concat_idents! debug_assert! debug_assert_eq! env! panic! file! format! format_args! include_bin! include_str! line! local_data_key! module_path! option_env! print! println! select! stringify! try! unimplemented! unreachable! vec! write! writeln! macro_rules! assert_ne! debug_assert_ne!";return{aliases:["rs"],k:{keyword:r,literal:"true false Some None Ok Err",built_in:n},l:e.IR+"!?",i:"</",c:[e.CLCM,e.C("/\\*","\\*/",{c:["self"]}),e.inherit(e.QSM,{b:/b?"/,i:null}),{cN:"string",v:[{b:/r(#*)"(.|\n)*?"\1(?!#)/},{b:/b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/}]},{cN:"symbol",b:/'[a-zA-Z_][a-zA-Z0-9_]*/},{cN:"number",v:[{b:"\\b0b([01_]+)"+t},{b:"\\b0o([0-7_]+)"+t},{b:"\\b0x([A-Fa-f0-9_]+)"+t},{b:"\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)"+t}],r:0},{cN:"function",bK:"fn",e:"(\\(|<)",eE:!0,c:[e.UTM]},{cN:"meta",b:"#\\!?\\[",e:"\\]",c:[{cN:"meta-string",b:/"/,e:/"/}]},{cN:"class",bK:"type",e:";",c:[e.inherit(e.UTM,{endsParent:!0})],i:"\\S"},{cN:"class",bK:"trait enum struct union",e:"{",c:[e.inherit(e.UTM,{endsParent:!0})],i:"[\\w\\d]"},{b:e.IR+"::",k:{built_in:n}},{b:"->"}]}});hljs.registerLanguage("ruby",function(e){var b="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?",r={keyword:"and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",literal:"true false nil"},c={cN:"doctag",b:"@[A-Za-z]+"},a={b:"#<",e:">"},s=[e.C("#","$",{c:[c]}),e.C("^\\=begin","^\\=end",{c:[c],r:10}),e.C("^__END__","\\n$")],n={cN:"subst",b:"#\\{",e:"}",k:r},t={cN:"string",c:[e.BE,n],v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/`/,e:/`/},{b:"%[qQwWx]?\\(",e:"\\)"},{b:"%[qQwWx]?\\[",e:"\\]"},{b:"%[qQwWx]?{",e:"}"},{b:"%[qQwWx]?<",e:">"},{b:"%[qQwWx]?/",e:"/"},{b:"%[qQwWx]?%",e:"%"},{b:"%[qQwWx]?-",e:"-"},{b:"%[qQwWx]?\\|",e:"\\|"},{b:/\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/},{b:/<<(-?)\w+$/,e:/^\s*\w+$/}]},i={cN:"params",b:"\\(",e:"\\)",endsParent:!0,k:r},d=[t,a,{cN:"class",bK:"class module",e:"$|;",i:/=/,c:[e.inherit(e.TM,{b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?"}),{b:"<\\s*",c:[{b:"("+e.IR+"::)?"+e.IR}]}].concat(s)},{cN:"function",bK:"def",e:"$|;",c:[e.inherit(e.TM,{b:b}),i].concat(s)},{b:e.IR+"::"},{cN:"symbol",b:e.UIR+"(\\!|\\?)?:",r:0},{cN:"symbol",b:":(?!\\s)",c:[t,{b:b}],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{cN:"params",b:/\|/,e:/\|/,k:r},{b:"("+e.RSR+"|unless)\\s*",k:"unless",c:[a,{cN:"regexp",c:[e.BE,n],i:/\n/,v:[{b:"/",e:"/[a-z]*"},{b:"%r{",e:"}[a-z]*"},{b:"%r\\(",e:"\\)[a-z]*"},{b:"%r!",e:"![a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}].concat(s),r:0}].concat(s);n.c=d,i.c=d;var l="[>?]>",o="[\\w#]+\\(\\w+\\):\\d+:\\d+>",u="(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>",w=[{b:/^\s*=>/,starts:{e:"$",c:d}},{cN:"meta",b:"^("+l+"|"+o+"|"+u+")",starts:{e:"$",c:d}}];return{aliases:["rb","gemspec","podspec","thor","irb"],k:r,i:/\/\*/,c:s.concat(w).concat(d)}});hljs.registerLanguage("makefile",function(e){var i={cN:"variable",v:[{b:"\\$\\("+e.UIR+"\\)",c:[e.BE]},{b:/\$[@%<?\^\+\*]/}]},r={cN:"string",b:/"/,e:/"/,c:[e.BE,i]},a={cN:"variable",b:/\$\([\w-]+\s/,e:/\)/,k:{built_in:"subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"},c:[i]},n={b:"^"+e.UIR+"\\s*[:+?]?=",i:"\\n",rB:!0,c:[{b:"^"+e.UIR,e:"[:+?]?=",eE:!0}]},t={cN:"meta",b:/^\.PHONY:/,e:/$/,k:{"meta-keyword":".PHONY"},l:/[\.\w]+/},l={cN:"section",b:/^[^\s]+:/,e:/$/,c:[i]};return{aliases:["mk","mak"],k:"define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath",l:/[\w-]+/,c:[e.HCM,i,r,a,n,t,l]}});hljs.registerLanguage("yaml",function(e){var b="true false yes no null",a="^[ \\-]*",r="[a-zA-Z_][\\w\\-]*",t={cN:"attr",v:[{b:a+r+":"},{b:a+'"'+r+'":'},{b:a+"'"+r+"':"}]},c={cN:"template-variable",v:[{b:"{{",e:"}}"},{b:"%{",e:"}"}]},l={cN:"string",r:0,v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/\S+/}],c:[e.BE,c]};return{cI:!0,aliases:["yml","YAML","yaml"],c:[t,{cN:"meta",b:"^---s*$",r:10},{cN:"string",b:"[\\|>] *$",rE:!0,c:l.c,e:t.v[0].b},{b:"<%[%=-]?",e:"[%-]?%>",sL:"ruby",eB:!0,eE:!0,r:0},{cN:"type",b:"!!"+e.UIR},{cN:"meta",b:"&"+e.UIR+"$"},{cN:"meta",b:"\\*"+e.UIR+"$"},{cN:"bullet",b:"^ *-",r:0},e.HCM,{bK:b,k:{literal:b}},e.CNM,l]}});hljs.registerLanguage("css",function(e){var c="[a-zA-Z-][a-zA-Z0-9_-]*",t={b:/[A-Z\_\.\-]+\s*:/,rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:/\S/,e:":",eE:!0,starts:{eW:!0,eE:!0,c:[{b:/[\w-]+\(/,rB:!0,c:[{cN:"built_in",b:/[\w-]+/},{b:/\(/,e:/\)/,c:[e.ASM,e.QSM]}]},e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"number",b:"#[0-9A-Fa-f]+"},{cN:"meta",b:"!important"}]}}]};return{cI:!0,i:/[=\/|'\$]/,c:[e.CBCM,{cN:"selector-id",b:/#[A-Za-z0-9_-]+/},{cN:"selector-class",b:/\.[A-Za-z0-9_-]+/},{cN:"selector-attr",b:/\[/,e:/\]/,i:"$"},{cN:"selector-pseudo",b:/:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/},{b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{b:"@",e:"[{;]",i:/:/,c:[{cN:"keyword",b:/\w+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[e.ASM,e.QSM,e.CSSNM]}]},{cN:"selector-tag",b:c,r:0},{b:"{",e:"}",i:/\S/,c:[e.CBCM,t]}]}});hljs.registerLanguage("java",function(e){var a="[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*",t=a+"(<"+a+"(\\s*,\\s*"+a+")*>)?",r="false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private module requires exports do",s="\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",c={cN:"number",b:s,r:0};return{aliases:["jsp"],k:r,i:/<\/|#/,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{b:/\w+@/,r:0},{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:"class",bK:"class interface",e:/[{;=]/,eE:!0,k:"class interface",i:/[:"\[\]]/,c:[{bK:"extends implements"},e.UTM]},{bK:"new throw return else",r:0},{cN:"function",b:"("+t+"\\s+)+"+e.UIR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:r,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"params",b:/\(/,e:/\)/,k:r,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},c,{cN:"meta",b:"@[A-Za-z]+"}]}});hljs.registerLanguage("armasm",function(s){return{cI:!0,aliases:["arm"],l:"\\.?"+s.IR,k:{meta:".2byte .4byte .align .ascii .asciz .balign .byte .code .data .else .end .endif .endm .endr .equ .err .exitm .extern .global .hword .if .ifdef .ifndef .include .irp .long .macro .rept .req .section .set .skip .space .text .word .arm .thumb .code16 .code32 .force_thumb .thumb_func .ltorg ALIAS ALIGN ARM AREA ASSERT ATTR CN CODE CODE16 CODE32 COMMON CP DATA DCB DCD DCDU DCDO DCFD DCFDU DCI DCQ DCQU DCW DCWU DN ELIF ELSE END ENDFUNC ENDIF ENDP ENTRY EQU EXPORT EXPORTAS EXTERN FIELD FILL FUNCTION GBLA GBLL GBLS GET GLOBAL IF IMPORT INCBIN INCLUDE INFO KEEP LCLA LCLL LCLS LTORG MACRO MAP MEND MEXIT NOFP OPT PRESERVE8 PROC QN READONLY RELOC REQUIRE REQUIRE8 RLIST FN ROUT SETA SETL SETS SN SPACE SUBT THUMB THUMBX TTL WHILE WEND ",built_in:"r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 pc lr sp ip sl sb fp a1 a2 a3 a4 v1 v2 v3 v4 v5 v6 v7 v8 f0 f1 f2 f3 f4 f5 f6 f7 p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 cpsr_c cpsr_x cpsr_s cpsr_f cpsr_cx cpsr_cxs cpsr_xs cpsr_xsf cpsr_sf cpsr_cxsf spsr_c spsr_x spsr_s spsr_f spsr_cx spsr_cxs spsr_xs spsr_xsf spsr_sf spsr_cxsf s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21 s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 {PC} {VAR} {TRUE} {FALSE} {OPT} {CONFIG} {ENDIAN} {CODESIZE} {CPU} {FPU} {ARCHITECTURE} {PCSTOREOFFSET} {ARMASM_VERSION} {INTER} {ROPI} {RWPI} {SWST} {NOSWST} . @"},c:[{cN:"keyword",b:"\\b(adc|(qd?|sh?|u[qh]?)?add(8|16)?|usada?8|(q|sh?|u[qh]?)?(as|sa)x|and|adrl?|sbc|rs[bc]|asr|b[lx]?|blx|bxj|cbn?z|tb[bh]|bic|bfc|bfi|[su]bfx|bkpt|cdp2?|clz|clrex|cmp|cmn|cpsi[ed]|cps|setend|dbg|dmb|dsb|eor|isb|it[te]{0,3}|lsl|lsr|ror|rrx|ldm(([id][ab])|f[ds])?|ldr((s|ex)?[bhd])?|movt?|mvn|mra|mar|mul|[us]mull|smul[bwt][bt]|smu[as]d|smmul|smmla|mla|umlaal|smlal?([wbt][bt]|d)|mls|smlsl?[ds]|smc|svc|sev|mia([bt]{2}|ph)?|mrr?c2?|mcrr2?|mrs|msr|orr|orn|pkh(tb|bt)|rbit|rev(16|sh)?|sel|[su]sat(16)?|nop|pop|push|rfe([id][ab])?|stm([id][ab])?|str(ex)?[bhd]?|(qd?)?sub|(sh?|q|u[qh]?)?sub(8|16)|[su]xt(a?h|a?b(16)?)|srs([id][ab])?|swpb?|swi|smi|tst|teq|wfe|wfi|yield)(eq|ne|cs|cc|mi|pl|vs|vc|hi|ls|ge|lt|gt|le|al|hs|lo)?[sptrx]?",e:"\\s"},s.C("[;@]","$",{r:0}),s.CBCM,s.QSM,{cN:"string",b:"'",e:"[^\\\\]'",r:0},{cN:"title",b:"\\|",e:"\\|",i:"\\n",r:0},{cN:"number",v:[{b:"[#$=]?0x[0-9a-f]+"},{b:"[#$=]?0b[01]+"},{b:"[#$=]\\d+"},{b:"\\b\\d+"}],r:0},{cN:"symbol",v:[{b:"^[a-z_\\.\\$][a-z0-9_\\.\\$]+"},{b:"^\\s*[a-z_\\.\\$][a-z0-9_\\.\\$]+:"},{b:"[=#]\\w+"}],r:0}]}});hljs.registerLanguage("swift",function(e){var i={keyword:"__COLUMN__ __FILE__ __FUNCTION__ __LINE__ as as! as? associativity break case catch class continue convenience default defer deinit didSet do dynamic dynamicType else enum extension fallthrough false fileprivate final for func get guard if import in indirect infix init inout internal is lazy left let mutating nil none nonmutating open operator optional override postfix precedence prefix private protocol Protocol public repeat required rethrows return right self Self set static struct subscript super switch throw throws true try try! try? Type typealias unowned var weak where while willSet",literal:"true false nil",built_in:"abs advance alignof alignofValue anyGenerator assert assertionFailure bridgeFromObjectiveC bridgeFromObjectiveCUnconditional bridgeToObjectiveC bridgeToObjectiveCUnconditional c contains count countElements countLeadingZeros debugPrint debugPrintln distance dropFirst dropLast dump encodeBitsAsWords enumerate equal fatalError filter find getBridgedObjectiveCType getVaList indices insertionSort isBridgedToObjectiveC isBridgedVerbatimToObjectiveC isUniquelyReferenced isUniquelyReferencedNonObjC join lazy lexicographicalCompare map max maxElement min minElement numericCast overlaps partition posix precondition preconditionFailure print println quickSort readLine reduce reflect reinterpretCast reverse roundUpToAlignment sizeof sizeofValue sort split startsWith stride strideof strideofValue swap toString transcode underestimateCount unsafeAddressOf unsafeBitCast unsafeDowncast unsafeUnwrap unsafeReflect withExtendedLifetime withObjectAtPlusZero withUnsafePointer withUnsafePointerToObject withUnsafeMutablePointer withUnsafeMutablePointers withUnsafePointer withUnsafePointers withVaList zip"},t={cN:"type",b:"\\b[A-Z][\\wÀ-ʸ']*",r:0},n=e.C("/\\*","\\*/",{c:["self"]}),r={cN:"subst",b:/\\\(/,e:"\\)",k:i,c:[]},a={cN:"number",b:"\\b([\\d_]+(\\.[\\deE_]+)?|0x[a-fA-F0-9_]+(\\.[a-fA-F0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b",r:0},o=e.inherit(e.QSM,{c:[r,e.BE]});return r.c=[a],{k:i,c:[o,e.CLCM,n,t,a,{cN:"function",bK:"func",e:"{",eE:!0,c:[e.inherit(e.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{b:/</,e:/>/},{cN:"params",b:/\(/,e:/\)/,endsParent:!0,k:i,c:["self",a,o,e.CBCM,{b:":"}],i:/["']/}],i:/\[|%/},{cN:"class",bK:"struct protocol class extension enum",k:i,e:"\\{",eE:!0,c:[e.inherit(e.TM,{b:/[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/})]},{cN:"meta",b:"(@warn_unused_result|@exported|@lazy|@noescape|@NSCopying|@NSManaged|@objc|@convention|@required|@noreturn|@IBAction|@IBDesignable|@IBInspectable|@IBOutlet|@infix|@prefix|@postfix|@autoclosure|@testable|@available|@nonobjc|@NSApplicationMain|@UIApplicationMain)"},{bK:"import",e:/$/,c:[e.CLCM,n]}]}});hljs.registerLanguage("cpp",function(t){var e={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[{b:'(u8?|U)?L?"',e:'"',i:"\\n",c:[t.BE]},{b:'(u8?|U)?R"',e:'"',c:[t.BE]},{b:"'\\\\?.",e:"'",i:"."}]},s={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},i={cN:"meta",b:/#\s*[a-z]+\b/,e:/$/,k:{"meta-keyword":"if else elif endif define undef warning error line pragma ifdef ifndef include"},c:[{b:/\\\n/,r:0},t.inherit(r,{cN:"meta-string"}),{cN:"meta-string",b:/<[^\n>]*>/,e:/$/,i:"\\n"},t.CLCM,t.CBCM]},a=t.IR+"\\s*\\(",c={keyword:"int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and or not",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",literal:"true false nullptr NULL"},n=[e,t.CLCM,t.CBCM,s,r];return{aliases:["c","cc","h","c++","h++","hpp"],k:c,i:"</",c:n.concat([i,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:c,c:["self",e]},{b:t.IR+"::",k:c},{v:[{b:/=/,e:/;/},{b:/\(/,e:/\)/},{bK:"new throw return else",e:/;/}],k:c,c:n.concat([{b:/\(/,e:/\)/,k:c,c:n.concat(["self"]),r:0}]),r:0},{cN:"function",b:"("+t.IR+"[\\*&\\s]+)+"+a,rB:!0,e:/[{;=]/,eE:!0,k:c,i:/[^\w\s\*&]/,c:[{b:a,rB:!0,c:[t.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:c,r:0,c:[t.CLCM,t.CBCM,r,s,e]},t.CLCM,t.CBCM,i]},{cN:"class",bK:"class struct",e:/[{;:]/,c:[{b:/</,e:/>/,c:["self"]},t.TM]}]),exports:{preprocessor:i,strings:r,k:c}}});hljs.registerLanguage("x86asm",function(s){return{cI:!0,l:"[.%]?"+s.IR,k:{keyword:"lock rep repe repz repne repnz xaquire xrelease bnd nobnd aaa aad aam aas adc add and arpl bb0_reset bb1_reset bound bsf bsr bswap bt btc btr bts call cbw cdq cdqe clc cld cli clts cmc cmp cmpsb cmpsd cmpsq cmpsw cmpxchg cmpxchg486 cmpxchg8b cmpxchg16b cpuid cpu_read cpu_write cqo cwd cwde daa das dec div dmint emms enter equ f2xm1 fabs fadd faddp fbld fbstp fchs fclex fcmovb fcmovbe fcmove fcmovnb fcmovnbe fcmovne fcmovnu fcmovu fcom fcomi fcomip fcomp fcompp fcos fdecstp fdisi fdiv fdivp fdivr fdivrp femms feni ffree ffreep fiadd ficom ficomp fidiv fidivr fild fimul fincstp finit fist fistp fisttp fisub fisubr fld fld1 fldcw fldenv fldl2e fldl2t fldlg2 fldln2 fldpi fldz fmul fmulp fnclex fndisi fneni fninit fnop fnsave fnstcw fnstenv fnstsw fpatan fprem fprem1 fptan frndint frstor fsave fscale fsetpm fsin fsincos fsqrt fst fstcw fstenv fstp fstsw fsub fsubp fsubr fsubrp ftst fucom fucomi fucomip fucomp fucompp fxam fxch fxtract fyl2x fyl2xp1 hlt ibts icebp idiv imul in inc incbin insb insd insw int int01 int1 int03 int3 into invd invpcid invlpg invlpga iret iretd iretq iretw jcxz jecxz jrcxz jmp jmpe lahf lar lds lea leave les lfence lfs lgdt lgs lidt lldt lmsw loadall loadall286 lodsb lodsd lodsq lodsw loop loope loopne loopnz loopz lsl lss ltr mfence monitor mov movd movq movsb movsd movsq movsw movsx movsxd movzx mul mwait neg nop not or out outsb outsd outsw packssdw packsswb packuswb paddb paddd paddsb paddsiw paddsw paddusb paddusw paddw pand pandn pause paveb pavgusb pcmpeqb pcmpeqd pcmpeqw pcmpgtb pcmpgtd pcmpgtw pdistib pf2id pfacc pfadd pfcmpeq pfcmpge pfcmpgt pfmax pfmin pfmul pfrcp pfrcpit1 pfrcpit2 pfrsqit1 pfrsqrt pfsub pfsubr pi2fd pmachriw pmaddwd pmagw pmulhriw pmulhrwa pmulhrwc pmulhw pmullw pmvgezb pmvlzb pmvnzb pmvzb pop popa popad popaw popf popfd popfq popfw por prefetch prefetchw pslld psllq psllw psrad psraw psrld psrlq psrlw psubb psubd psubsb psubsiw psubsw psubusb psubusw psubw punpckhbw punpckhdq punpckhwd punpcklbw punpckldq punpcklwd push pusha pushad pushaw pushf pushfd pushfq pushfw pxor rcl rcr rdshr rdmsr rdpmc rdtsc rdtscp ret retf retn rol ror rdm rsdc rsldt rsm rsts sahf sal salc sar sbb scasb scasd scasq scasw sfence sgdt shl shld shr shrd sidt sldt skinit smi smint smintold smsw stc std sti stosb stosd stosq stosw str sub svdc svldt svts swapgs syscall sysenter sysexit sysret test ud0 ud1 ud2b ud2 ud2a umov verr verw fwait wbinvd wrshr wrmsr xadd xbts xchg xlatb xlat xor cmove cmovz cmovne cmovnz cmova cmovnbe cmovae cmovnb cmovb cmovnae cmovbe cmovna cmovg cmovnle cmovge cmovnl cmovl cmovnge cmovle cmovng cmovc cmovnc cmovo cmovno cmovs cmovns cmovp cmovpe cmovnp cmovpo je jz jne jnz ja jnbe jae jnb jb jnae jbe jna jg jnle jge jnl jl jnge jle jng jc jnc jo jno js jns jpo jnp jpe jp sete setz setne setnz seta setnbe setae setnb setnc setb setnae setcset setbe setna setg setnle setge setnl setl setnge setle setng sets setns seto setno setpe setp setpo setnp addps addss andnps andps cmpeqps cmpeqss cmpleps cmpless cmpltps cmpltss cmpneqps cmpneqss cmpnleps cmpnless cmpnltps cmpnltss cmpordps cmpordss cmpunordps cmpunordss cmpps cmpss comiss cvtpi2ps cvtps2pi cvtsi2ss cvtss2si cvttps2pi cvttss2si divps divss ldmxcsr maxps maxss minps minss movaps movhps movlhps movlps movhlps movmskps movntps movss movups mulps mulss orps rcpps rcpss rsqrtps rsqrtss shufps sqrtps sqrtss stmxcsr subps subss ucomiss unpckhps unpcklps xorps fxrstor fxrstor64 fxsave fxsave64 xgetbv xsetbv xsave xsave64 xsaveopt xsaveopt64 xrstor xrstor64 prefetchnta prefetcht0 prefetcht1 prefetcht2 maskmovq movntq pavgb pavgw pextrw pinsrw pmaxsw pmaxub pminsw pminub pmovmskb pmulhuw psadbw pshufw pf2iw pfnacc pfpnacc pi2fw pswapd maskmovdqu clflush movntdq movnti movntpd movdqa movdqu movdq2q movq2dq paddq pmuludq pshufd pshufhw pshuflw pslldq psrldq psubq punpckhqdq punpcklqdq addpd addsd andnpd andpd cmpeqpd cmpeqsd cmplepd cmplesd cmpltpd cmpltsd cmpneqpd cmpneqsd cmpnlepd cmpnlesd cmpnltpd cmpnltsd cmpordpd cmpordsd cmpunordpd cmpunordsd cmppd comisd cvtdq2pd cvtdq2ps cvtpd2dq cvtpd2pi cvtpd2ps cvtpi2pd cvtps2dq cvtps2pd cvtsd2si cvtsd2ss cvtsi2sd cvtss2sd cvttpd2pi cvttpd2dq cvttps2dq cvttsd2si divpd divsd maxpd maxsd minpd minsd movapd movhpd movlpd movmskpd movupd mulpd mulsd orpd shufpd sqrtpd sqrtsd subpd subsd ucomisd unpckhpd unpcklpd xorpd addsubpd addsubps haddpd haddps hsubpd hsubps lddqu movddup movshdup movsldup clgi stgi vmcall vmclear vmfunc vmlaunch vmload vmmcall vmptrld vmptrst vmread vmresume vmrun vmsave vmwrite vmxoff vmxon invept invvpid pabsb pabsw pabsd palignr phaddw phaddd phaddsw phsubw phsubd phsubsw pmaddubsw pmulhrsw pshufb psignb psignw psignd extrq insertq movntsd movntss lzcnt blendpd blendps blendvpd blendvps dppd dpps extractps insertps movntdqa mpsadbw packusdw pblendvb pblendw pcmpeqq pextrb pextrd pextrq phminposuw pinsrb pinsrd pinsrq pmaxsb pmaxsd pmaxud pmaxuw pminsb pminsd pminud pminuw pmovsxbw pmovsxbd pmovsxbq pmovsxwd pmovsxwq pmovsxdq pmovzxbw pmovzxbd pmovzxbq pmovzxwd pmovzxwq pmovzxdq pmuldq pmulld ptest roundpd roundps roundsd roundss crc32 pcmpestri pcmpestrm pcmpistri pcmpistrm pcmpgtq popcnt getsec pfrcpv pfrsqrtv movbe aesenc aesenclast aesdec aesdeclast aesimc aeskeygenassist vaesenc vaesenclast vaesdec vaesdeclast vaesimc vaeskeygenassist vaddpd vaddps vaddsd vaddss vaddsubpd vaddsubps vandpd vandps vandnpd vandnps vblendpd vblendps vblendvpd vblendvps vbroadcastss vbroadcastsd vbroadcastf128 vcmpeq_ospd vcmpeqpd vcmplt_ospd vcmpltpd vcmple_ospd vcmplepd vcmpunord_qpd vcmpunordpd vcmpneq_uqpd vcmpneqpd vcmpnlt_uspd vcmpnltpd vcmpnle_uspd vcmpnlepd vcmpord_qpd vcmpordpd vcmpeq_uqpd vcmpnge_uspd vcmpngepd vcmpngt_uspd vcmpngtpd vcmpfalse_oqpd vcmpfalsepd vcmpneq_oqpd vcmpge_ospd vcmpgepd vcmpgt_ospd vcmpgtpd vcmptrue_uqpd vcmptruepd vcmplt_oqpd vcmple_oqpd vcmpunord_spd vcmpneq_uspd vcmpnlt_uqpd vcmpnle_uqpd vcmpord_spd vcmpeq_uspd vcmpnge_uqpd vcmpngt_uqpd vcmpfalse_ospd vcmpneq_ospd vcmpge_oqpd vcmpgt_oqpd vcmptrue_uspd vcmppd vcmpeq_osps vcmpeqps vcmplt_osps vcmpltps vcmple_osps vcmpleps vcmpunord_qps vcmpunordps vcmpneq_uqps vcmpneqps vcmpnlt_usps vcmpnltps vcmpnle_usps vcmpnleps vcmpord_qps vcmpordps vcmpeq_uqps vcmpnge_usps vcmpngeps vcmpngt_usps vcmpngtps vcmpfalse_oqps vcmpfalseps vcmpneq_oqps vcmpge_osps vcmpgeps vcmpgt_osps vcmpgtps vcmptrue_uqps vcmptrueps vcmplt_oqps vcmple_oqps vcmpunord_sps vcmpneq_usps vcmpnlt_uqps vcmpnle_uqps vcmpord_sps vcmpeq_usps vcmpnge_uqps vcmpngt_uqps vcmpfalse_osps vcmpneq_osps vcmpge_oqps vcmpgt_oqps vcmptrue_usps vcmpps vcmpeq_ossd vcmpeqsd vcmplt_ossd vcmpltsd vcmple_ossd vcmplesd vcmpunord_qsd vcmpunordsd vcmpneq_uqsd vcmpneqsd vcmpnlt_ussd vcmpnltsd vcmpnle_ussd vcmpnlesd vcmpord_qsd vcmpordsd vcmpeq_uqsd vcmpnge_ussd vcmpngesd vcmpngt_ussd vcmpngtsd vcmpfalse_oqsd vcmpfalsesd vcmpneq_oqsd vcmpge_ossd vcmpgesd vcmpgt_ossd vcmpgtsd vcmptrue_uqsd vcmptruesd vcmplt_oqsd vcmple_oqsd vcmpunord_ssd vcmpneq_ussd vcmpnlt_uqsd vcmpnle_uqsd vcmpord_ssd vcmpeq_ussd vcmpnge_uqsd vcmpngt_uqsd vcmpfalse_ossd vcmpneq_ossd vcmpge_oqsd vcmpgt_oqsd vcmptrue_ussd vcmpsd vcmpeq_osss vcmpeqss vcmplt_osss vcmpltss vcmple_osss vcmpless vcmpunord_qss vcmpunordss vcmpneq_uqss vcmpneqss vcmpnlt_usss vcmpnltss vcmpnle_usss vcmpnless vcmpord_qss vcmpordss vcmpeq_uqss vcmpnge_usss vcmpngess vcmpngt_usss vcmpngtss vcmpfalse_oqss vcmpfalsess vcmpneq_oqss vcmpge_osss vcmpgess vcmpgt_osss vcmpgtss vcmptrue_uqss vcmptruess vcmplt_oqss vcmple_oqss vcmpunord_sss vcmpneq_usss vcmpnlt_uqss vcmpnle_uqss vcmpord_sss vcmpeq_usss vcmpnge_uqss vcmpngt_uqss vcmpfalse_osss vcmpneq_osss vcmpge_oqss vcmpgt_oqss vcmptrue_usss vcmpss vcomisd vcomiss vcvtdq2pd vcvtdq2ps vcvtpd2dq vcvtpd2ps vcvtps2dq vcvtps2pd vcvtsd2si vcvtsd2ss vcvtsi2sd vcvtsi2ss vcvtss2sd vcvtss2si vcvttpd2dq vcvttps2dq vcvttsd2si vcvttss2si vdivpd vdivps vdivsd vdivss vdppd vdpps vextractf128 vextractps vhaddpd vhaddps vhsubpd vhsubps vinsertf128 vinsertps vlddqu vldqqu vldmxcsr vmaskmovdqu vmaskmovps vmaskmovpd vmaxpd vmaxps vmaxsd vmaxss vminpd vminps vminsd vminss vmovapd vmovaps vmovd vmovq vmovddup vmovdqa vmovqqa vmovdqu vmovqqu vmovhlps vmovhpd vmovhps vmovlhps vmovlpd vmovlps vmovmskpd vmovmskps vmovntdq vmovntqq vmovntdqa vmovntpd vmovntps vmovsd vmovshdup vmovsldup vmovss vmovupd vmovups vmpsadbw vmulpd vmulps vmulsd vmulss vorpd vorps vpabsb vpabsw vpabsd vpacksswb vpackssdw vpackuswb vpackusdw vpaddb vpaddw vpaddd vpaddq vpaddsb vpaddsw vpaddusb vpaddusw vpalignr vpand vpandn vpavgb vpavgw vpblendvb vpblendw vpcmpestri vpcmpestrm vpcmpistri vpcmpistrm vpcmpeqb vpcmpeqw vpcmpeqd vpcmpeqq vpcmpgtb vpcmpgtw vpcmpgtd vpcmpgtq vpermilpd vpermilps vperm2f128 vpextrb vpextrw vpextrd vpextrq vphaddw vphaddd vphaddsw vphminposuw vphsubw vphsubd vphsubsw vpinsrb vpinsrw vpinsrd vpinsrq vpmaddwd vpmaddubsw vpmaxsb vpmaxsw vpmaxsd vpmaxub vpmaxuw vpmaxud vpminsb vpminsw vpminsd vpminub vpminuw vpminud vpmovmskb vpmovsxbw vpmovsxbd vpmovsxbq vpmovsxwd vpmovsxwq vpmovsxdq vpmovzxbw vpmovzxbd vpmovzxbq vpmovzxwd vpmovzxwq vpmovzxdq vpmulhuw vpmulhrsw vpmulhw vpmullw vpmulld vpmuludq vpmuldq vpor vpsadbw vpshufb vpshufd vpshufhw vpshuflw vpsignb vpsignw vpsignd vpslldq vpsrldq vpsllw vpslld vpsllq vpsraw vpsrad vpsrlw vpsrld vpsrlq vptest vpsubb vpsubw vpsubd vpsubq vpsubsb vpsubsw vpsubusb vpsubusw vpunpckhbw vpunpckhwd vpunpckhdq vpunpckhqdq vpunpcklbw vpunpcklwd vpunpckldq vpunpcklqdq vpxor vrcpps vrcpss vrsqrtps vrsqrtss vroundpd vroundps vroundsd vroundss vshufpd vshufps vsqrtpd vsqrtps vsqrtsd vsqrtss vstmxcsr vsubpd vsubps vsubsd vsubss vtestps vtestpd vucomisd vucomiss vunpckhpd vunpckhps vunpcklpd vunpcklps vxorpd vxorps vzeroall vzeroupper pclmullqlqdq pclmulhqlqdq pclmullqhqdq pclmulhqhqdq pclmulqdq vpclmullqlqdq vpclmulhqlqdq vpclmullqhqdq vpclmulhqhqdq vpclmulqdq vfmadd132ps vfmadd132pd vfmadd312ps vfmadd312pd vfmadd213ps vfmadd213pd vfmadd123ps vfmadd123pd vfmadd231ps vfmadd231pd vfmadd321ps vfmadd321pd vfmaddsub132ps vfmaddsub132pd vfmaddsub312ps vfmaddsub312pd vfmaddsub213ps vfmaddsub213pd vfmaddsub123ps vfmaddsub123pd vfmaddsub231ps vfmaddsub231pd vfmaddsub321ps vfmaddsub321pd vfmsub132ps vfmsub132pd vfmsub312ps vfmsub312pd vfmsub213ps vfmsub213pd vfmsub123ps vfmsub123pd vfmsub231ps vfmsub231pd vfmsub321ps vfmsub321pd vfmsubadd132ps vfmsubadd132pd vfmsubadd312ps vfmsubadd312pd vfmsubadd213ps vfmsubadd213pd vfmsubadd123ps vfmsubadd123pd vfmsubadd231ps vfmsubadd231pd vfmsubadd321ps vfmsubadd321pd vfnmadd132ps vfnmadd132pd vfnmadd312ps vfnmadd312pd vfnmadd213ps vfnmadd213pd vfnmadd123ps vfnmadd123pd vfnmadd231ps vfnmadd231pd vfnmadd321ps vfnmadd321pd vfnmsub132ps vfnmsub132pd vfnmsub312ps vfnmsub312pd vfnmsub213ps vfnmsub213pd vfnmsub123ps vfnmsub123pd vfnmsub231ps vfnmsub231pd vfnmsub321ps vfnmsub321pd vfmadd132ss vfmadd132sd vfmadd312ss vfmadd312sd vfmadd213ss vfmadd213sd vfmadd123ss vfmadd123sd vfmadd231ss vfmadd231sd vfmadd321ss vfmadd321sd vfmsub132ss vfmsub132sd vfmsub312ss vfmsub312sd vfmsub213ss vfmsub213sd vfmsub123ss vfmsub123sd vfmsub231ss vfmsub231sd vfmsub321ss vfmsub321sd vfnmadd132ss vfnmadd132sd vfnmadd312ss vfnmadd312sd vfnmadd213ss vfnmadd213sd vfnmadd123ss vfnmadd123sd vfnmadd231ss vfnmadd231sd vfnmadd321ss vfnmadd321sd vfnmsub132ss vfnmsub132sd vfnmsub312ss vfnmsub312sd vfnmsub213ss vfnmsub213sd vfnmsub123ss vfnmsub123sd vfnmsub231ss vfnmsub231sd vfnmsub321ss vfnmsub321sd rdfsbase rdgsbase rdrand wrfsbase wrgsbase vcvtph2ps vcvtps2ph adcx adox rdseed clac stac xstore xcryptecb xcryptcbc xcryptctr xcryptcfb xcryptofb montmul xsha1 xsha256 llwpcb slwpcb lwpval lwpins vfmaddpd vfmaddps vfmaddsd vfmaddss vfmaddsubpd vfmaddsubps vfmsubaddpd vfmsubaddps vfmsubpd vfmsubps vfmsubsd vfmsubss vfnmaddpd vfnmaddps vfnmaddsd vfnmaddss vfnmsubpd vfnmsubps vfnmsubsd vfnmsubss vfrczpd vfrczps vfrczsd vfrczss vpcmov vpcomb vpcomd vpcomq vpcomub vpcomud vpcomuq vpcomuw vpcomw vphaddbd vphaddbq vphaddbw vphadddq vphaddubd vphaddubq vphaddubw vphaddudq vphadduwd vphadduwq vphaddwd vphaddwq vphsubbw vphsubdq vphsubwd vpmacsdd vpmacsdqh vpmacsdql vpmacssdd vpmacssdqh vpmacssdql vpmacsswd vpmacssww vpmacswd vpmacsww vpmadcsswd vpmadcswd vpperm vprotb vprotd vprotq vprotw vpshab vpshad vpshaq vpshaw vpshlb vpshld vpshlq vpshlw vbroadcasti128 vpblendd vpbroadcastb vpbroadcastw vpbroadcastd vpbroadcastq vpermd vpermpd vpermps vpermq vperm2i128 vextracti128 vinserti128 vpmaskmovd vpmaskmovq vpsllvd vpsllvq vpsravd vpsrlvd vpsrlvq vgatherdpd vgatherqpd vgatherdps vgatherqps vpgatherdd vpgatherqd vpgatherdq vpgatherqq xabort xbegin xend xtest andn bextr blci blcic blsi blsic blcfill blsfill blcmsk blsmsk blsr blcs bzhi mulx pdep pext rorx sarx shlx shrx tzcnt tzmsk t1mskc valignd valignq vblendmpd vblendmps vbroadcastf32x4 vbroadcastf64x4 vbroadcasti32x4 vbroadcasti64x4 vcompresspd vcompressps vcvtpd2udq vcvtps2udq vcvtsd2usi vcvtss2usi vcvttpd2udq vcvttps2udq vcvttsd2usi vcvttss2usi vcvtudq2pd vcvtudq2ps vcvtusi2sd vcvtusi2ss vexpandpd vexpandps vextractf32x4 vextractf64x4 vextracti32x4 vextracti64x4 vfixupimmpd vfixupimmps vfixupimmsd vfixupimmss vgetexppd vgetexpps vgetexpsd vgetexpss vgetmantpd vgetmantps vgetmantsd vgetmantss vinsertf32x4 vinsertf64x4 vinserti32x4 vinserti64x4 vmovdqa32 vmovdqa64 vmovdqu32 vmovdqu64 vpabsq vpandd vpandnd vpandnq vpandq vpblendmd vpblendmq vpcmpltd vpcmpled vpcmpneqd vpcmpnltd vpcmpnled vpcmpd vpcmpltq vpcmpleq vpcmpneqq vpcmpnltq vpcmpnleq vpcmpq vpcmpequd vpcmpltud vpcmpleud vpcmpnequd vpcmpnltud vpcmpnleud vpcmpud vpcmpequq vpcmpltuq vpcmpleuq vpcmpnequq vpcmpnltuq vpcmpnleuq vpcmpuq vpcompressd vpcompressq vpermi2d vpermi2pd vpermi2ps vpermi2q vpermt2d vpermt2pd vpermt2ps vpermt2q vpexpandd vpexpandq vpmaxsq vpmaxuq vpminsq vpminuq vpmovdb vpmovdw vpmovqb vpmovqd vpmovqw vpmovsdb vpmovsdw vpmovsqb vpmovsqd vpmovsqw vpmovusdb vpmovusdw vpmovusqb vpmovusqd vpmovusqw vpord vporq vprold vprolq vprolvd vprolvq vprord vprorq vprorvd vprorvq vpscatterdd vpscatterdq vpscatterqd vpscatterqq vpsraq vpsravq vpternlogd vpternlogq vptestmd vptestmq vptestnmd vptestnmq vpxord vpxorq vrcp14pd vrcp14ps vrcp14sd vrcp14ss vrndscalepd vrndscaleps vrndscalesd vrndscaless vrsqrt14pd vrsqrt14ps vrsqrt14sd vrsqrt14ss vscalefpd vscalefps vscalefsd vscalefss vscatterdpd vscatterdps vscatterqpd vscatterqps vshuff32x4 vshuff64x2 vshufi32x4 vshufi64x2 kandnw kandw kmovw knotw kortestw korw kshiftlw kshiftrw kunpckbw kxnorw kxorw vpbroadcastmb2q vpbroadcastmw2d vpconflictd vpconflictq vplzcntd vplzcntq vexp2pd vexp2ps vrcp28pd vrcp28ps vrcp28sd vrcp28ss vrsqrt28pd vrsqrt28ps vrsqrt28sd vrsqrt28ss vgatherpf0dpd vgatherpf0dps vgatherpf0qpd vgatherpf0qps vgatherpf1dpd vgatherpf1dps vgatherpf1qpd vgatherpf1qps vscatterpf0dpd vscatterpf0dps vscatterpf0qpd vscatterpf0qps vscatterpf1dpd vscatterpf1dps vscatterpf1qpd vscatterpf1qps prefetchwt1 bndmk bndcl bndcu bndcn bndmov bndldx bndstx sha1rnds4 sha1nexte sha1msg1 sha1msg2 sha256rnds2 sha256msg1 sha256msg2 hint_nop0 hint_nop1 hint_nop2 hint_nop3 hint_nop4 hint_nop5 hint_nop6 hint_nop7 hint_nop8 hint_nop9 hint_nop10 hint_nop11 hint_nop12 hint_nop13 hint_nop14 hint_nop15 hint_nop16 hint_nop17 hint_nop18 hint_nop19 hint_nop20 hint_nop21 hint_nop22 hint_nop23 hint_nop24 hint_nop25 hint_nop26 hint_nop27 hint_nop28 hint_nop29 hint_nop30 hint_nop31 hint_nop32 hint_nop33 hint_nop34 hint_nop35 hint_nop36 hint_nop37 hint_nop38 hint_nop39 hint_nop40 hint_nop41 hint_nop42 hint_nop43 hint_nop44 hint_nop45 hint_nop46 hint_nop47 hint_nop48 hint_nop49 hint_nop50 hint_nop51 hint_nop52 hint_nop53 hint_nop54 hint_nop55 hint_nop56 hint_nop57 hint_nop58 hint_nop59 hint_nop60 hint_nop61 hint_nop62 hint_nop63",built_in:"ip eip rip al ah bl bh cl ch dl dh sil dil bpl spl r8b r9b r10b r11b r12b r13b r14b r15b ax bx cx dx si di bp sp r8w r9w r10w r11w r12w r13w r14w r15w eax ebx ecx edx esi edi ebp esp eip r8d r9d r10d r11d r12d r13d r14d r15d rax rbx rcx rdx rsi rdi rbp rsp r8 r9 r10 r11 r12 r13 r14 r15 cs ds es fs gs ss st st0 st1 st2 st3 st4 st5 st6 st7 mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 xmm0  xmm1  xmm2  xmm3  xmm4  xmm5  xmm6  xmm7  xmm8  xmm9 xmm10  xmm11 xmm12 xmm13 xmm14 xmm15 xmm16 xmm17 xmm18 xmm19 xmm20 xmm21 xmm22 xmm23 xmm24 xmm25 xmm26 xmm27 xmm28 xmm29 xmm30 xmm31 ymm0  ymm1  ymm2  ymm3  ymm4  ymm5  ymm6  ymm7  ymm8  ymm9 ymm10  ymm11 ymm12 ymm13 ymm14 ymm15 ymm16 ymm17 ymm18 ymm19 ymm20 ymm21 ymm22 ymm23 ymm24 ymm25 ymm26 ymm27 ymm28 ymm29 ymm30 ymm31 zmm0  zmm1  zmm2  zmm3  zmm4  zmm5  zmm6  zmm7  zmm8  zmm9 zmm10  zmm11 zmm12 zmm13 zmm14 zmm15 zmm16 zmm17 zmm18 zmm19 zmm20 zmm21 zmm22 zmm23 zmm24 zmm25 zmm26 zmm27 zmm28 zmm29 zmm30 zmm31 k0 k1 k2 k3 k4 k5 k6 k7 bnd0 bnd1 bnd2 bnd3 cr0 cr1 cr2 cr3 cr4 cr8 dr0 dr1 dr2 dr3 dr8 tr3 tr4 tr5 tr6 tr7 r0 r1 r2 r3 r4 r5 r6 r7 r0b r1b r2b r3b r4b r5b r6b r7b r0w r1w r2w r3w r4w r5w r6w r7w r0d r1d r2d r3d r4d r5d r6d r7d r0h r1h r2h r3h r0l r1l r2l r3l r4l r5l r6l r7l r8l r9l r10l r11l r12l r13l r14l r15l db dw dd dq dt ddq do dy dz resb resw resd resq rest resdq reso resy resz incbin equ times byte word dword qword nosplit rel abs seg wrt strict near far a32 ptr",meta:"%define %xdefine %+ %undef %defstr %deftok %assign %strcat %strlen %substr %rotate %elif %else %endif %if %ifmacro %ifctx %ifidn %ifidni %ifid %ifnum %ifstr %iftoken %ifempty %ifenv %error %warning %fatal %rep %endrep %include %push %pop %repl %pathsearch %depend %use %arg %stacksize %local %line %comment %endcomment .nolist __FILE__ __LINE__ __SECT__  __BITS__ __OUTPUT_FORMAT__ __DATE__ __TIME__ __DATE_NUM__ __TIME_NUM__ __UTC_DATE__ __UTC_TIME__ __UTC_DATE_NUM__ __UTC_TIME_NUM__  __PASS__ struc endstruc istruc at iend align alignb sectalign daz nodaz up down zero default option assume public bits use16 use32 use64 default section segment absolute extern global common cpu float __utf16__ __utf16le__ __utf16be__ __utf32__ __utf32le__ __utf32be__ __float8__ __float16__ __float32__ __float64__ __float80m__ __float80e__ __float128l__ __float128h__ __Infinity__ __QNaN__ __SNaN__ Inf NaN QNaN SNaN float8 float16 float32 float64 float80m float80e float128l float128h __FLOAT_DAZ__ __FLOAT_ROUND__ __FLOAT__"},c:[s.C(";","$",{r:0}),{cN:"number",v:[{b:"\\b(?:([0-9][0-9_]*)?\\.[0-9_]*(?:[eE][+-]?[0-9_]+)?|(0[Xx])?[0-9][0-9_]*\\.?[0-9_]*(?:[pP](?:[+-]?[0-9_]+)?)?)\\b",r:0},{b:"\\$[0-9][0-9A-Fa-f]*",r:0},{b:"\\b(?:[0-9A-Fa-f][0-9A-Fa-f_]*[Hh]|[0-9][0-9_]*[DdTt]?|[0-7][0-7_]*[QqOo]|[0-1][0-1_]*[BbYy])\\b"},{b:"\\b(?:0[Xx][0-9A-Fa-f_]+|0[DdTt][0-9_]+|0[QqOo][0-7_]+|0[BbYy][0-1_]+)\\b"}]},s.QSM,{cN:"string",v:[{b:"'",e:"[^\\\\]'"},{b:"`",e:"[^\\\\]`"}],r:0},{cN:"symbol",v:[{b:"^\\s*[A-Za-z._?][A-Za-z0-9_$#@~.?]*(:|\\s+label)"},{b:"^\\s*%%[A-Za-z0-9_$#@~.?]*:"}],r:0},{cN:"subst",b:"%[0-9]+",r:0},{cN:"subst",b:"%!S+",r:0},{cN:"meta",b:/^\s*\.[\w_-]+/}]}});hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},s={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/\b-?[a-z\._]+\b/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"meta",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,s,a,t]}});hljs.registerLanguage("shell",function(s){return{aliases:["console"],c:[{cN:"meta",b:"^\\s{0,3}[\\w\\d\\[\\]()@-]*[>%$#]",starts:{e:"$",sL:"bash"}}]}});hljs.registerLanguage("http",function(e){var t="HTTP/[0-9\\.]+";return{aliases:["https"],i:"\\S",c:[{b:"^"+t,e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{b:"^[A-Z]+ (.*?) "+t+"$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0},{b:t},{cN:"keyword",b:"[A-Z]+"}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{e:"$",r:0}},{b:"\\n\\n",starts:{sL:[],eW:!0}}]}});hljs.registerLanguage("cs",function(e){var i={keyword:"abstract as base bool break byte case catch char checked const continue decimal default delegate do double enum event explicit extern finally fixed float for foreach goto if implicit in int interface internal is lock long nameof object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this try typeof uint ulong unchecked unsafe ushort using virtual void volatile while add alias ascending async await by descending dynamic equals from get global group into join let on orderby partial remove select set value var where yield",literal:"null false true"},t={cN:"string",b:'@"',e:'"',c:[{b:'""'}]},r=e.inherit(t,{i:/\n/}),a={cN:"subst",b:"{",e:"}",k:i},c=e.inherit(a,{i:/\n/}),n={cN:"string",b:/\$"/,e:'"',i:/\n/,c:[{b:"{{"},{b:"}}"},e.BE,c]},s={cN:"string",b:/\$@"/,e:'"',c:[{b:"{{"},{b:"}}"},{b:'""'},a]},o=e.inherit(s,{i:/\n/,c:[{b:"{{"},{b:"}}"},{b:'""'},c]});a.c=[s,n,t,e.ASM,e.QSM,e.CNM,e.CBCM],c.c=[o,n,r,e.ASM,e.QSM,e.CNM,e.inherit(e.CBCM,{i:/\n/})];var l={v:[s,n,t,e.ASM,e.QSM]},b=e.IR+"(<"+e.IR+"(\\s*,\\s*"+e.IR+")*>)?(\\[\\])?";return{aliases:["csharp"],k:i,i:/::/,c:[e.C("///","$",{rB:!0,c:[{cN:"doctag",v:[{b:"///",r:0},{b:"<!--|-->"},{b:"</?",e:">"}]}]}),e.CLCM,e.CBCM,{cN:"meta",b:"#",e:"$",k:{"meta-keyword":"if else elif endif define undef warning error line region endregion pragma checksum"}},l,e.CNM,{bK:"class interface",e:/[{;=]/,i:/[^\s:]/,c:[e.TM,e.CLCM,e.CBCM]},{bK:"namespace",e:/[{;=]/,i:/[^\s:]/,c:[e.inherit(e.TM,{b:"[a-zA-Z](\\.?\\w)*"}),e.CLCM,e.CBCM]},{cN:"meta",b:"^\\s*\\[",eB:!0,e:"\\]",eE:!0,c:[{cN:"meta-string",b:/"/,e:/"/}]},{bK:"new return throw await else",r:0},{cN:"function",b:"("+b+"\\s+)+"+e.IR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:i,c:[{b:e.IR+"\\s*\\(",rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:i,r:0,c:[l,e.CNM,e.CBCM]},e.CLCM,e.CBCM]}]}});hljs.registerLanguage("coffeescript",function(e){var c={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super yield import export from as default await then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",built_in:"npm require console print module global window document"},n="[A-Za-z$_][0-9A-Za-z$_]*",r={cN:"subst",b:/#\{/,e:/}/,k:c},i=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,r]},{b:/"/,e:/"/,c:[e.BE,r]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[r,e.HCM]},{b:"//[gim]*",r:0},{b:/\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/}]},{b:"@"+n},{sL:"javascript",eB:!0,eE:!0,v:[{b:"```",e:"```"},{b:"`",e:"`"}]}];r.c=i;var s=e.inherit(e.TM,{b:n}),t="(\\(.*\\))?\\s*\\B[-=]>",o={cN:"params",b:"\\([^\\(]",rB:!0,c:[{b:/\(/,e:/\)/,k:c,c:["self"].concat(i)}]};return{aliases:["coffee","cson","iced"],k:c,i:/\/\*/,c:i.concat([e.C("###","###"),e.HCM,{cN:"function",b:"^\\s*"+n+"\\s*=\\s*"+t,e:"[-=]>",rB:!0,c:[s,o]},{b:/[:\(,=]\s*/,r:0,c:[{cN:"function",b:t,e:"[-=]>",rB:!0,c:[o]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[s]},s]},{b:n+":",e:":",rB:!0,rE:!0,r:0}])}});hljs.registerLanguage("sql",function(e){var t=e.C("--","$");return{cI:!0,i:/[<>{}*#]/,c:[{bK:"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke comment",e:/;/,eW:!0,l:/[\w\.]+/,k:{keyword:"abort abs absolute acc acce accep accept access accessed accessible account acos action activate add addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias allocate allow alter always analyze ancillary and any anydata anydataset anyschema anytype apply archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound buffer_cache buffer_pool build bulk by byte byteordermark bytes cache caching call calling cancel capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base char_length character_length characters characterset charindex charset charsetform charsetid check checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation collect colu colum column column_value columns columns_updated comment commit compact compatibility compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection consider consistent constant constraint constraints constructor container content contents context contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime customdatum cycle data database databases datafile datafiles datalength date_add date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor deterministic diagnostics difference dimension direct_load directory disable disable_all disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div do document domain dotnet double downgrade drop dumpfile duplicate duration each edition editionable editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding execu execut execute exempt exists exit exp expire explain export export_set extended extent external external_1 external_2 externally extract failed failed_login_attempts failover failure far fast feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final finish first first_value fixed flash_cache flashback floor flush following follows for forall force form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ftp full function general generated get get_format get_lock getdate getutcdate global global_name globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex hierarchy high high_priority hosts hour http id ident_current ident_incr ident_seed identified identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile initial initialized initially initrans inmemory inner innodb input insert install instance instantiable instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists keep keep_duplicates key keys kill language large last last_day last_insert_id last_value lax lcase lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call logoff logon logs long loop low low_priority lower lpad lrtrim ltrim main make_set makedate maketime managed management manual map mapping mask master master_pos_wait match matched materialized max maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans md5 measures median medium member memcompress memory merge microsecond mid migration min minextents minimum mining minus minute minvalue missing mod mode model modification modify module monitoring month months mount move movement multiset mutex name name_const names nan national native natural nav nchar nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck noswitch not nothing notice notrim novalidate now nowait nth_value nullif nulls num numb numbe nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary out outer outfile outline output over overflow overriding package pad parallel parallel_enable parameters parent parse partial partition partitions pascal passing password password_grace_time password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction prediction_cost prediction_details prediction_probability prediction_set prepare present preserve prior priority private private_sga privileges procedural procedure procedure_analyze processlist profiles project prompt protection public publishingservername purge quarter query quick quiesce quota quotename radians raise rand range rank raw read reads readsize rebuild record records recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename repair repeat replace replicate replication required reset resetlogs resize resource respect restore restricted result result_cache resumable resume retention return returning returns reuse reverse revoke right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll sdo_georaster sdo_topo_geometry search sec_to_time second section securefile security seed segment select self sequence sequential serializable server servererror session session_user sessions_per_user set sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone standby start starting startup statement static statistics stats_binomial_test stats_crosstab stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime table tables tablespace tan tdo template temporary terminated tertiary_weights test than then thread through tier ties time time_format time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unpivot unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear wellformed when whene whenev wheneve whenever where while whitespace with within without work wrapped xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek",literal:"true false null",built_in:"array bigint binary bit blob boolean char character date dec decimal float int int8 integer interval number numeric real record serial serial8 smallint text varchar varying void"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM,e.CBCM,t]},e.CBCM,t]}});hljs.registerLanguage("apache",function(e){var r={cN:"number",b:"[\\$%]\\d+"};return{aliases:["apacheconf"],cI:!0,c:[e.HCM,{cN:"section",b:"</?",e:">"},{cN:"attribute",b:/\w+/,r:0,k:{nomarkup:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"meta",b:"\\s\\[",e:"\\]$"},{cN:"variable",b:"[\\$%]\\{",e:"\\}",c:["self",r]},r,e.QSM]}}],i:/\S/}});hljs.registerLanguage("haskell",function(e){var i={v:[e.C("--","$"),e.C("{-","-}",{c:["self"]})]},a={cN:"meta",b:"{-#",e:"#-}"},l={cN:"meta",b:"^#",e:"$"},c={cN:"type",b:"\\b[A-Z][\\w']*",r:0},n={b:"\\(",e:"\\)",i:'"',c:[a,l,{cN:"type",b:"\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?"},e.inherit(e.TM,{b:"[_a-z][\\w']*"}),i]},s={b:"{",e:"}",c:n.c};return{aliases:["hs"],k:"let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",c:[{bK:"module",e:"where",k:"module where",c:[n,i],i:"\\W\\.|;"},{b:"\\bimport\\b",e:"$",k:"import qualified as hiding",c:[n,i],i:"\\W\\.|;"},{cN:"class",b:"^(\\s*)?(class|instance)\\b",e:"where",k:"class family instance where",c:[c,n,i]},{cN:"class",b:"\\b(data|(new)?type)\\b",e:"$",k:"data family type newtype deriving",c:[a,c,n,s,i]},{bK:"default",e:"$",c:[c,n,i]},{bK:"infix infixl infixr",e:"$",c:[e.CNM,i]},{b:"\\bforeign\\b",e:"$",k:"foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",c:[c,e.QSM,i]},{cN:"meta",b:"#!\\/usr\\/bin\\/env runhaskell",e:"$"},a,l,e.QSM,e.CNM,c,e.inherit(e.TM,{b:"^[_a-z][\\w']*"}),i,{b:"->|<-"}]}});hljs.registerLanguage("scala",function(e){var t={cN:"meta",b:"@[A-Za-z]+"},a={cN:"subst",v:[{b:"\\$[A-Za-z0-9_]+"},{b:"\\${",e:"}"}]},r={cN:"string",v:[{b:'"',e:'"',i:"\\n",c:[e.BE]},{b:'"""',e:'"""',r:10},{b:'[a-z]+"',e:'"',i:"\\n",c:[e.BE,a]},{cN:"string",b:'[a-z]+"""',e:'"""',c:[a],r:10}]},c={cN:"symbol",b:"'\\w[\\w\\d_]*(?!')"},i={cN:"type",b:"\\b[A-Z][A-Za-z0-9_]*",r:0},s={cN:"title",b:/[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,r:0},n={cN:"class",bK:"class object trait type",e:/[:={\[\n;]/,eE:!0,c:[{bK:"extends with",r:10},{b:/\[/,e:/\]/,eB:!0,eE:!0,r:0,c:[i]},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,r:0,c:[i]},s]},l={cN:"function",bK:"def",e:/[:={\[(\n;]/,eE:!0,c:[s]};return{k:{literal:"true false null",keyword:"type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit"},c:[e.CLCM,e.CBCM,r,c,i,l,n,e.CNM,t]}});
'''
'''--- guide/src/twiggy.svg ---
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="210mm"
   height="297mm"
   viewBox="0 0 210 297"
   version="1.1"
   id="svg3772"
   inkscape:version="0.92.2 (5c3e80d, 2017-08-06)"
   sodipodi:docname="twiggy.svg">
  <defs
     id="defs3766" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1.4"
     inkscape:cx="326.86452"
     inkscape:cy="623.69701"
     inkscape:document-units="mm"
     inkscape:current-layer="layer4"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1136"
     inkscape:window-x="0"
     inkscape:window-y="27"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata3769">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Twiggy outline"
     inkscape:groupmode="layer"
     id="layer1"
     style="display:inline">
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.031397,115.9583 c -5.31458,4.0393 -10.461872,8.99867 -15.601857,13.99824"
       id="path4622"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 50.848027,113.2522 c 1.256102,1.8892 2.439345,4.09375 3.510599,6.33311 1.650604,3.45045 3.789215,6.56171 3.070914,10.37123 -0.525901,0.225 -0.210702,0.46813 -1.804069,0.20046 -0.257659,0.29233 -0.841705,-1.2723 -1.09254,-3.37632 -0.244291,-2.04913 -0.675381,-4.3316 -1.112434,-5.84448 -0.892639,-2.21407 -1.785927,-4.42789 -3.374278,-6.38106 -1.379383,-1.33068 -2.882609,-1.29909 -4.34313,-1.73725 -1.136983,-0.33761 -2.289115,-0.56918 -3.340869,-1.50339 -0.222033,-1.45096 0.172185,-3.62502 0.483934,-4.72013 0.582907,-0.55992 0.242511,-0.43236 2.42598,-1.27624 0.852499,-0.32794 2.043138,-0.36499 3.070242,-0.51833 0.285125,0.31214 0.37006,0.56709 0.03341,0.70158 -1.880901,0.98881 -6.532493,1.08645 -3.240644,2.93997"
       id="path4624"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="csccsccccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 45.135142,108.44135 c 3.078143,0.58926 3.490652,2.09246 3.340866,-1.20272 0.102499,-0.5412 0.101249,-1.17267 0.734993,-1.5368 l 0.768398,-0.36749 c 0.281511,0.009 0.620142,-0.12491 0.734993,0.30068 -0.62636,0.45053 -1.352104,1.71439 -1.202714,2.23838 -0.12151,0.46772 0.312965,0.7684 0.634766,1.23612 0.597256,0.61777 0.431091,1.30136 0.601357,2.00452 l 0.100225,2.13816"
       id="path4626"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.16500001;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 47.373524,110.47928 c 0.842351,0.98843 1.593802,2.295 2.77292,2.10474"
       id="path4628"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 42.36222,111.3145 c -3.487858,-2.33266 -4.342825,-2.84398 -7.450137,-4.91108 -0.547895,-0.56755 0.05717,-0.93567 0.601355,-0.90204 2.547459,0.78408 5.080886,3.4242 6.614922,4.34313"
       id="path4630"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 42.462445,108.44134 c -2.286754,-1.63398 -6.497918,-4.80299 -6.247424,-2.60587"
       id="path4632"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 97.87076,136.93896 c -2.381385,5.92219 -5.041079,11.60818 -7.850184,17.24058 -1.577321,3.16261 -3.167705,6.43634 -4.716074,9.77284 -0.799312,2.2436 -1.342716,3.95129 -1.869316,5.54408 -2.407595,7.28217 -5.964528,14.21621 -9.280982,21.23317 -0.310535,1.05084 -0.02554,1.53891 0.777549,1.34249 0.615543,0.10499 0.813239,-0.11313 1.187603,-0.16893 1.250669,-0.19734 1.765313,-1.15958 1.873669,-1.75234 2.424805,-10.38747 6.519741,-18.83547 9.413967,-24.78106 -0.105555,-1.37808 4.008276,-10.07691 5.865868,-14.45434 2.265245,-5.33807 4.272411,-8.83227 6.452082,-13.40854"
       id="path4683"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cscscccccsc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 74.154204,190.72963 c 0.0016,0.62406 -0.112325,0.41704 -0.167391,1.05901 -3.072742,3.58997 -8.635318,4.68749 -13.014529,7.03204 -1.770787,0.58312 -3.517513,2.11331 -3.897879,3.11831 0.232975,0.76861 1.155355,0.0941 3.590772,-0.75596 0.80449,-0.005 0.489925,0.42544 0.188989,0.85045 -1.481706,1.06541 -1.372315,1.17617 -1.322917,1.32292 -0.14629,0.79518 0.810931,0.67076 1.771764,0.54334 2.192664,-0.4348 1.028015,0.0417 6.709077,-1.93713 3.556179,-2.25238 6.660112,-3.45782 8.858817,-6.14212 0.26289,-0.36118 0.980147,-1.13925 1.299294,-2.05524 0.172915,-0.75186 -0.544527,-1.90898 -1.252046,-2.22061"
       id="path4685"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 99.502231,136.9507 c 4.006209,7.90954 6.599869,16.05815 8.942379,23.90889 0.40444,2.25849 0.67775,2.94357 1.00226,4.2429 l 4.62366,11.93494 c 2.27406,4.95465 2.93408,9.26401 5.07025,15.67455 1.2352,0.97366 3.01596,2.02126 2.70926,0.1083 -1.60683,-3.44413 -1.77918,-4.41521 -4.46886,-11.77427 -1.68538,-5.72509 -3.3473,-11.53387 -5.12225,-17.09363 -1.30419,-3.3099 -2.96185,-6.88704 -4.55806,-10.63834 -2.25644,-5.30292 -3.47883,-11.26204 -4.96915,-17.00984"
       id="path4687"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccccsc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 119.14078,192.71198 c -1.01539,1.34597 -2.26184,3.9925 -0.59803,4.85666 1.82139,0.32635 3.53063,0.37194 5.1263,1.48828 1.98958,0.80874 3.51152,2.08903 5.10268,3.47265 1.60238,0.71617 3.36671,0.51602 5.14993,0.56697 0.66845,0.0122 0.84009,-0.0465 1.08668,-0.0945 0.90654,-0.0346 0.93263,-0.32075 0.51972,-0.73233 -1.03468,-0.57328 -1.50091,-1.21746 -1.06306,-1.46465 0.87923,-0.11404 1.75301,0.20174 2.64583,0.37795 1.11445,0.25305 1.28948,-0.0754 1.08668,-0.63784 -0.56068,-0.79059 -1.29872,-1.4925 -2.36235,-2.03162 -2.42112,-1.57267 -5.08761,-2.29032 -7.81938,-3.09468 -2.29991,-0.66231 -4.23522,-1.62846 -6.16574,-2.59859"
       id="path4689"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 103.1875,138.01376 c 3.07005,0.8657 4.03167,0.67717 5.43341,0.70871 1.6379,0.0967 3.27579,0.011 4.91369,-0.51972 1.61903,-0.38237 2.58176,-1.02727 3.59077,-1.65365 1.29756,-0.96389 2.6476,-1.91029 3.2128,-3.1183 0.46746,-0.68519 2.71226,-6.26746 -1.70094,-2.69308 l -2.5041,2.36235 c -4.33693,1.51241 -8.96188,0.14713 -12.80394,-1.46466"
       id="path4691"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 88.666665,125.14569 c 1.987847,-3.55566 1.143054,-4.68335 11.292137,-15.23436"
       id="path4695"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 85.993969,122.60663 c 6.526266,-5.29442 9.575037,-11.08562 13.831199,-16.70434 0.826202,-0.75405 1.408022,0.6913 2.071342,1.40316 -2.625966,6.87278 -2.967507,14.2532 -4.142682,21.44838"
       id="path4697"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 98.822906,110.84677 c -0.900695,6.06492 -1.400714,10.46053 -2.255341,13.35505 -0.799239,2.70692 -1.514666,3.7276 -1.553249,5.15337 0.323124,1.72405 1.561557,2.38025 2.939965,2.87314 2.819689,0.4449 3.896869,-0.19928 5.374909,-0.59292 2.7624,-0.7724 3.75722,-2.29465 5.31587,-4.55201 1.86733,-5.35798 -2.38666,2.35887 -4.6104,2.73951"
       id="path4699"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="csccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 106.44754,129.86365 c 0.8605,-0.0291 4.85259,0.14908 6.18936,-1.53553 0.23807,-0.66541 -0.28207,-0.50943 -0.77957,-0.37797 l -1.06306,0.37797 c -2.15906,0.43616 -3.4585,0.37351 -3.26004,0.37798"
       id="path4701"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 111.21949,128.02102 c 0.59376,-0.67912 -1.27152,-0.51699 -3.00018,-0.4016"
       id="path4703"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 106.61291,127.73754 -4.34673,0.49609"
       id="path4705"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 105.59709,128.80059 -2.05524,0.21262"
       id="path4707"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 98.439172,129.95815 c 1.387921,-0.44655 2.859768,-0.79719 3.827008,-1.72452 1.41828,-1.04062 1.09942,-4.55346 -0.23623,-1.98437 -0.88717,1.50857 -2.516079,1.35432 -4.15774,1.67727"
       id="path4709"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 89.060638,124.35938 c 1.894417,1.78608 3.925874,3.11379 6.071796,4.14536"
       id="path4711"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 86.402994,122.14467 c -2.593197,-2.84591 -5.124822,-5.75339 -7.190989,-9.12633 1.697699,-4.12254 4.704666,-8.30787 8.833657,-12.1806 1.561878,-1.46494 2.711747,-2.562579 3.694602,-3.488079 3.329505,-6.827307 6.761908,-9.495195 11.592816,-14.866866 0.66646,0.990464 1.57377,1.123677 2.50565,1.369756 2.55155,-0.06532 4.84802,0.552119 7.28309,1.202712 0.89569,0.218495 1.40662,0.0978 2.0516,0.149152 1.10987,-0.07798 5.45113,-1.832652 4.69696,-2.420942 -0.95115,-0.370703 -2.92536,1.240789 -5.07812,1.469982 -1.16392,-0.02191 -3.31327,-0.576154 -2.93996,-0.567949"
       id="path4713"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccscccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 115.87804,85.055262 c 1.42658,0.397095 2.66166,0.609047 4.12598,0.551248 0.77068,-0.243237 -0.10266,-0.67752 -0.40093,-0.734989 -0.79704,-0.121146 -1.62259,-0.233736 -1.98781,-0.484428"
       id="path4715"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 116.1119,83.936071 c -1.05682,-0.34189 -2.52713,-0.803777 -3.842,-1.219416"
       id="path4717"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 119.66993,84.838108 c 0.52872,-0.232234 0.11056,-0.882974 -0.71829,-0.985557"
       id="path4719"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 117.49837,83.334715 c -6.35744,-1.988053 -9.2458,-2.938116 -11.526,-2.672695 2.50318,0.01107 2.6789,-0.124574 4.2262,-0.835216 0.84073,-0.786539 0.78121,-1.661469 -0.88534,-0.734992 -0.8018,0.483726 -1.60361,0.496431 -2.40542,0.50113 -2.77722,-0.323001 -3.46573,-0.01615 -4.79415,2.03793 -5.51722,6.248656 -9.021131,11.018471 -12.342134,14.823878 -3.904965,4.57364 -8.202879,10.43982 -12.864719,14.49225 -0.807045,-0.10175 -1.501953,-0.30147 -4.409947,-3.99234 -0.860444,-2.90983 -0.927889,-5.47591 -1.286237,-8.30206 0.548941,-1.998161 -0.147135,-2.211551 -1.135895,-3.574729 -1.180265,-1.075314 -0.912658,-4.638626 -2.328968,-7.76515 0.562348,-4.876862 2.094114,-6.527418 4.693655,-9.002549 3.062353,-2.915794 12.034814,-3.900932 17.545215,-1.000484 2.068881,0.737716 3.861148,0.737792 5.395505,0.05011 1.16837,-0.515066 2.41581,-0.887414 3.406004,-1.937007 1.263221,-1.4929 0.760466,-1.87237 -0.03173,-1.036365 -0.06894,0.07275 0,0 0,0 -1.509877,1.659037 -3.807624,2.973037 -6.07692,2.86462 -2.313574,-0.110532 -5.236883,-2.091118 -8.24601,-2.376688 -2.938219,-0.278841 -6.288181,-0.295336 -8.461797,0.581145 -7.210696,3.128572 -8.305288,7.665259 -8.838135,11.089453 -0.509865,-0.310107 -1.341247,-0.722733 -2.072177,-0.184238 -1.191368,-2.318262 -2.42465,-4.350882 -3.370226,-6.751074 -0.894279,-2.806604 -1.863771,-5.223783 -2.054633,-8.118314 -0.775473,-6.695903 1.841484,-12.750015 8.819894,-13.213135 1.384553,0.256249 2.678174,0.717096 3.708365,1.770661 1.62593,0.838134 1.363473,2.484309 2.438834,3.123713 0.731602,0.610192 0.442021,-0.244573 0.517836,-0.618061 -1.089086,-2.470412 -2.491631,-3.264833 -4.944487,-4.927783 -1.173152,-0.529732 -3.312918,-0.350698 -4.092564,10e-7 -6.178758,2.159025 -6.685092,5.056913 -7.550366,10.991458 0.172024,7.083107 2.574581,12.0915 5.746296,18.157623 -1.121994,1.350063 -1.072928,2.159636 -1.069078,2.990078"
       id="path4721"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccccccccscccscsscccccccccccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 63.209243,89.765885 -0.937667,0.07954 c -1.221994,0.445539 -1.137814,1.838867 -0.755946,2.669458 0.738222,1.090468 1.790474,1.903049 2.740326,1.157552 0.847984,-1.541666 0.02818,-2.8181 -1.046707,-3.906546 z"
       id="path4725"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 64.58668,92.160525 c 2.603368,1.897228 2.960201,-0.261752 2.923615,-2.313249 -0.0323,-1.811095 -2.80547,-2.793988 -3.608695,0.683228"
       id="path4727"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="csc" />
    <path
       style="fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 63.641739,94.00316 c 3.284986,4.894957 0.08236,7.30285 1.27567,8.45722 3.111438,-0.28073 4.38605,-2.633777 5.055434,-5.669646 -0.103686,3.486736 -0.674671,5.425696 -3.554532,6.783096 -0.367551,0.13137 -0.572624,0.22266 -0.645086,0.37734 -0.09603,0.63906 0.506707,0.95433 0.915209,1.30179 2.084466,1.77385 5.388785,4.75161 5.507747,8.80105"
       id="path4729"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccc" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:0.66500002;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 42.462444,108.44134 c -0.160528,0.85674 -0.19571,1.69902 -0.06681,2.52237"
       id="path4745"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 63.641739,94.003158 c 0.240567,-1.317355 -0.207011,-2.330734 -1.441032,-2.551335 -2.127686,0.793028 0.423384,1.837827 1.441032,2.551335 z"
       id="path4758"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 64.58668,92.160523 1.417413,0.543345 c 0.868252,-0.883678 0.138181,-2.538994 -0.810572,-2.886502 -1.549179,0.119361 -1.309786,1.625892 -0.606841,2.343157 z"
       id="path4775"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 72.196182,114.05401 c -4.565623,5.11211 -9.422036,9.49724 -14.699824,12.82893"
       id="path3811"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.031398,115.9583 c 3.364566,4.69755 6.769424,8.71016 10.22306,11.8935"
       id="path4634"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 82.786736,127.35067 c -1.036435,3.28532 -4.896438,6.40336 -7.984678,8.61944 -0.161899,0.83282 0.408014,1.28956 0.734991,1.60361 0.639021,0.19865 1.332161,0.58671 1.80407,0.20046 1.544973,-3.21152 4.348692,-6.40171 7.049236,-9.15398"
       id="path4636"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 78.944738,135.03466 c 3.751646,0.74865 8.372086,-0.24028 12.895754,-1.03567"
       id="path4657"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 77.341119,137.77418 c 5.623992,-1.44985 11.167991,-2.01979 16.704347,-2.50565"
       id="path4659"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 83.889223,128.15247 c 4.880867,4.16722 10.010378,7.67857 15.83572,9.35444"
       id="path4661"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 94.045466,135.26853 c -0.222723,0.97172 -0.445447,2.00355 -0.668173,3.24064 -0.343093,0.5754 -0.358267,1.44369 -2.190441,1.84391 -0.979987,0.21691 -2.078095,0.33229 -3.058083,0.10427 -1.076045,-0.18733 -1.484387,-0.76124 -1.788433,-0.47039 0.297908,2.05199 2.551653,1.28802 4.230624,1.66262 1.406965,-0.12224 2.734689,-0.48221 3.875411,-1.40317 1.019786,-1.077 2.171427,-1.99578 2.77292,-3.57473"
       id="path4663"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccccc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 93.811604,135.90329 c -0.467728,0.61254 -0.81714,0.51516 -1.202712,0.63477 l -1.403164,-0.0668 c -0.306914,0.14373 -0.327793,0.33514 -0.100227,0.56795 0.790673,0.46274 1.581343,0.60585 2.372016,0.53453"
       id="path4665"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc" />
    <path
       style="display:inline;fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 92.391556,141.3683 c -2.319772,2.18927 -12.655038,3.53674 -7.323289,1.77176 l 2.078869,-0.54333 c 3.745206,-1.39981 1.65413,-0.7985 2.291482,-1.18118"
       id="path4693"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccc" />
    <path
       style="display:inline;fill:#ffffff;stroke:#ffffff;stroke-width:0.66500002;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 78.510425,135.73625 c -0.744578,1.01698 -0.86989,1.17341 -1.155727,1.67431"
       id="path4737"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:#ffffff;stroke:#ffffff;stroke-width:0.56500006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 57.162271,129.63916 c 0.753802,-0.551 0.461238,-1.68639 0.467721,-2.3052"
       id="path4739"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#ffffff;stroke-width:0.66500002;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 74.121357,191.77933 c 1.007663,0.48952 1.929216,0.0709 2.796799,-0.23469"
       id="path4741"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="display:inline;fill:none;stroke:#ffffff;stroke-width:0.56500006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 119.14946,192.85346 c 0.76526,0.39127 2.7339,2.19084 2.58428,0.21228"
       id="path4743"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
  </g>
  <g
     inkscape:groupmode="layer"
     id="layer3"
     inkscape:label="Fill"
     style="display:inline">
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:1.07986498;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 489.8348,765.18268 c -1.17857,-0.45842 -5.35714,-3.22815 -9.28571,-6.15497 -9.59485,-7.14823 -17.74708,-11.092 -25.22605,-12.20353 -3.4114,-0.50701 -6.94855,-1.85392 -7.86037,-2.99315 -2.84221,-3.5511 2.12084,-15.93897 5.53932,-13.82625 0.77818,0.48096 0.42491,-0.65112 -0.78505,-2.51572 -1.20997,-1.86459 -4.7579,-12.19572 -7.88428,-22.95806 -3.1264,-10.76233 -11.17112,-33.66709 -17.87717,-50.89947 -6.70605,-17.23237 -13.21252,-35.74826 -14.45883,-41.1464 -3.53322,-15.30335 -18.71526,-59.45802 -26.89912,-78.23203 -6.51551,-14.94674 -7.84893,-17.0353 -11.09417,-17.37696 -8.81144,-0.92763 -29.35159,-12.33251 -47.02571,-26.11094 -6.18318,-4.8203 -9.52437,-6.63304 -10,-5.42547 -0.39286,0.99743 -4.17797,5.72527 -8.41135,10.50631 -4.23339,4.78104 -8.8557,10.52239 -10.2718,12.75854 l -2.57473,4.06573 12.41465,-0.39994 c 6.82806,-0.21997 18.38591,-1.36303 25.6841,-2.54013 8.23057,-1.32747 14.13996,-1.653 15.56186,-0.85726 1.58122,0.88489 -2.31393,1.82885 -12.55516,3.04263 -8.16616,0.96785 -20.82553,2.88295 -28.13192,4.25577 -12.04237,2.26269 -13.20276,2.28249 -12.41176,0.21178 0.53594,-1.403 -0.28522,-1.04419 -2.12845,0.93001 -3.44498,3.68979 -3.56439,3.7183 -7.26936,1.73546 -2.78036,-1.48802 -3.87109,-5.66403 -1.47938,-5.66403 2.43123,0 22.40696,-19.73077 25.16991,-24.86124 1.52207,-2.82632 3.32426,-5.13876 4.00487,-5.13876 0.68061,0 -3.08268,-4.66072 -8.36287,-10.35714 -5.28018,-5.69643 -14.09648,-15.98215 -19.59177,-22.85715 -5.49529,-6.875 -10.45768,-12.5 -11.02754,-12.5 -0.56985,0 -5.62992,3.85715 -11.24459,8.57143 -5.61468,4.71429 -10.60197,8.57143 -11.08287,8.57143 -0.48091,0 4.06515,-5.25074 10.10233,-11.66831 10.4546,-11.1133 10.93225,-11.91171 10.042,-16.78571 -1.37924,-7.55114 -7.38061,-16.98441 -16.08228,-25.27897 l -7.69821,-7.33804 5.13536,-3.17383 c 6.21539,-3.84132 9.22774,-9.28524 10.34149,-18.68909 1.03007,-8.69729 -1.21541,-9.34429 -3.45196,-0.99462 -1.70588,6.36852 -7.5025,12.9504 -12.81776,14.55416 -3.06714,0.92544 -3.11909,0.72966 -2.32683,-8.76808 0.59921,-7.18356 0.21185,-11.1441 -1.48678,-15.20103 -3.01218,-7.19419 -1.33974,-10.72064 4.66627,-9.83914 3.7768,0.55431 4.40302,0.13702 5.17808,-3.45053 2.11515,-9.7904 3.00808,-9.87182 4.84735,-0.442 0.98888,5.06992 3.24791,11.14662 5.02006,13.50376 2.52059,3.35263 3.40904,6.92946 4.08068,16.42857 1.53099,21.65283 3.26235,26.89017 11.6884,35.35715 4.10506,4.125 8.36514,7.50568 9.46685,7.51263 1.10171,0.007 7.62811,-5.9309 14.50311,-13.19522 13.23589,-13.98543 15.87398,-15.54784 7.3107,-4.32978 -2.85411,3.73895 -7.13733,10.74836 -9.51827,15.57647 l -4.32898,8.7784 6.97592,9.79303 c 3.83675,5.38617 9.38541,12.41435 12.33034,15.61819 2.94494,3.20383 5.919,7.35131 6.60902,9.21662 1.23286,3.33273 1.39761,3.25658 9.51255,-4.39658 9.87531,-9.31337 20.73968,-22.56313 34.87306,-42.52983 9.94484,-14.04941 10.55859,-14.62987 13.06779,-12.35907 2.13551,1.93261 2.35972,3.09817 1.18697,6.17034 -3.00604,7.8747 -7.00691,27.49168 -10.48714,51.4203 -1.98186,13.62653 -3.60339,25.39512 -3.60339,26.15244 0,0.75731 1.42875,0.37618 3.17501,-0.84694 1.74625,-1.22312 4.66981,-2.22386 6.49678,-2.22386 1.82698,0 4.89822,-1.70102 6.82499,-3.78003 1.92678,-2.07902 3.50322,-3.00105 3.50322,-2.04894 0,3.92963 -3.15932,7.03695 -10.30013,10.13068 -4.15636,1.80072 -6.76159,3.54892 -5.7894,3.88489 0.97218,0.33597 5.38915,-1.04714 9.81549,-3.07359 4.42632,-2.02644 10.05948,-3.58813 12.5181,-3.4704 l 4.47022,0.21405 -4.04084,0.60597 c -2.89001,0.43338 -3.80544,1.21941 -3.21428,2.75993 0.4546,1.18468 0.82655,2.42282 0.82655,2.75142 0,2.24386 4.04132,-0.4696 10.08055,-6.7684 3.88427,-4.05121 7.06231,-6.62051 7.06231,-5.70955 0,0.91097 -3.05357,4.80563 -6.78571,8.6548 -9.98532,10.29843 -26.24939,14.49977 -36.20375,9.35217 -6.90197,-3.56914 -7.36196,-7.18496 -2.74181,-21.55242 2.23995,-6.96568 5.47413,-21.9863 7.18708,-33.37915 1.94468,-12.93421 3.95197,-21.65655 5.34436,-23.22305 1.22646,-1.37981 1.81208,-2.92661 1.30137,-3.43732 -2.30909,-2.30909 -31.47423,32.8778 -38.78894,46.79772 -5.58506,10.62838 -5.95065,11.95138 -2.98848,10.81469 1.12113,-0.43022 2.82263,0.16271 3.78112,1.31762 0.95849,1.15491 5.50549,4.42236 10.10445,7.26099 6.22332,3.84126 8.36174,5.99012 8.36174,8.40255 0,4.17901 6.93431,10.01313 13.32679,11.21237 2.72776,0.51173 8.00579,0.24774 11.72897,-0.58664 5.84701,-1.31035 8.05625,-1.0722 16.21395,1.74772 7.43636,2.57058 12.54519,3.26478 24.0266,3.26478 h 14.58202 l 6.13227,-5.90459 c 3.37274,-3.24751 7.67481,-6.69659 9.56017,-7.66459 3.38446,-1.7377 3.41663,-1.69044 2.5373,3.72823 -2.45889,15.15226 -23.02224,27.70947 -45.34464,27.69012 -11.90263,-0.01 -20.02102,-2.26502 -20.95027,-5.81849 -0.3948,-1.50974 -1.32902,-2.74497 -2.07605,-2.74497 -0.74703,0 -1.02365,1.125 -0.61475,2.5 0.4089,1.375 2.39494,9.1009 4.41342,17.16866 5.89735,23.57135 10.37872,36.65244 21.40268,62.4742 6.25425,14.64955 13.88337,36.1892 19.22741,54.28571 11.2031,37.93697 28.52274,86.9265 28.65154,81.0424 0.0289,-1.317 1.50912,-1.07731 5.39687,0.87382 2.94643,1.47871 11.78572,4.79632 19.64286,7.37248 16.8078,5.51086 28.87479,11.28699 32.85714,15.72783 l 2.85715,3.18609 -7.5,-1.02108 c -8.16942,-1.11221 -9.56936,0.30688 -5.13573,5.20598 2.26948,2.50775 1.96886,2.60797 -7.5,2.4997 -5.42536,-0.062 -10.82856,-0.48786 -12.00713,-0.94628 z"
       id="path4976"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 340.64075,534.40935 c -0.11031,-0.11032 -1.54334,-0.19533 -3.18452,-0.18892 -4.64665,0.0181 -7.34039,-0.56497 -8.72652,-1.88905 -1.22241,-1.16768 -1.92555,-2.72146 -1.23156,-2.72146 0.21749,0 0.99172,0.29961 1.7205,0.6658 4.65165,2.33731 14.27015,2.08122 19.41392,-0.51689 3.33871,-1.68638 4.51303,-4.02579 6.25973,-12.47034 0.56882,-2.75 1.18916,-4.96722 1.37853,-4.92715 0.36404,0.077 9.89934,4.40624 10.1108,4.59051 0.068,0.0593 -0.39649,1.0836 -1.0322,2.27632 -1.43182,2.68638 -7.91355,9.7123 -10.65448,11.54901 -2.3498,1.57462 -4.91429,2.59357 -8.34233,3.31468 -2.49674,0.52521 -5.34579,0.68357 -5.71187,0.31749 z"
       id="path4978"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 347.83157,518.72988 c -2.20535,-0.81193 -3.57026,-1.63575 -3.33658,-2.01386 0.14087,-0.22793 1.24398,-0.27967 2.95811,-0.13874 1.97205,0.16214 3.21803,0.0748 4.47306,-0.31364 l 1.73959,-0.53837 -0.21781,1.31732 c -0.11979,0.72453 -0.21957,1.51822 -0.22173,1.76375 -0.005,0.60246 -3.69253,0.5502 -5.39464,-0.0765 z"
       id="path4980"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d=""
       id="path4982"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 318.22228,543.08451 c 0,-0.26465 4.65909,-1.77296 8.92857,-2.8905 1.86607,-0.48845 5.16071,-1.64766 7.32143,-2.57604 3.76816,-1.61903 4.07732,-1.69025 7.57164,-1.74427 4.23726,-0.0655 4.17961,0.0856 -0.78593,2.05923 -3.84918,1.52995 -7.83571,2.70503 -13.44046,3.96174 -4.04524,0.90704 -9.59525,1.59526 -9.59525,1.18984 z"
       id="path4984"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 226.14011,770.01212 c -0.26762,-0.16965 -0.42356,-0.74372 -0.35715,-1.31475 0.0876,-0.75329 0.74561,-1.52344 2.56203,-2.99868 3.57492,-2.90346 4.43733,-5.11015 2.27703,-5.82636 -0.82113,-0.27223 -2.0091,0.0476 -6.86002,1.84703 -3.22681,1.19695 -6.10524,2.17627 -6.39653,2.17627 -1.6254,0 -0.63537,-1.97302 2.53317,-5.04833 2.75254,-2.67154 5.82401,-4.69614 9.64728,-6.35913 1.72735,-0.75134 4.82814,-2.17181 6.89064,-3.15661 2.0625,-0.9848 7.36607,-3.26615 11.78572,-5.06968 15.76306,-6.43243 23.4539,-10.69625 29.14334,-16.1571 2.80437,-2.6917 2.90495,-2.84579 3.27058,-5.01098 0.2853,-1.68944 1.91809,-5.45448 6.69946,-15.44817 17.43657,-36.44476 22.09507,-47.51224 30.56006,-72.60329 5.70709,-16.91638 5.92637,-17.41353 23.19034,-52.57528 9.77969,-19.91842 14.34755,-29.56354 19.36657,-40.89286 2.48638,-5.61246 9.07411,-21.1284 9.64029,-22.7056 0.17813,-0.49621 0.54012,-0.45675 3.06212,0.33378 l 2.8601,0.89652 -7.43402,14.86476 c -8.73988,17.47589 -11.47893,23.26786 -17.14443,36.2534 -2.31391,5.30357 -6.16594,14.0625 -8.56008,19.46429 -7.82257,17.64974 -11.66306,27.23464 -12.84198,32.05034 -0.44414,1.81423 -2.24079,6.0391 -5.20318,12.23537 -14.21116,29.7247 -22.60191,52.03126 -29.27347,77.82262 -1.9947,7.71122 -2.75178,9.46752 -4.47978,10.39232 -0.87908,0.47047 -0.66698,0.97549 1.2498,2.97596 1.02151,1.06611 1.76804,2.28796 2.16254,3.53946 l 0.60248,1.91129 -0.97938,1.94704 c -1.41161,2.80632 -3.14508,5.10867 -6.4111,8.51508 -3.70322,3.8624 -8.26996,7.26268 -15.28384,11.37996 -17.52655,10.28842 -15.76823,9.41176 -24.91071,12.42003 -10.45617,3.44054 -19.65961,5.22425 -21.36788,4.1413 z m 55.65359,-43.39626 c 0,-0.0753 -0.32165,-0.22103 -0.71477,-0.32384 -0.39313,-0.1028 -0.62472,-0.0412 -0.51464,0.13692 0.19223,0.31104 1.22941,0.46873 1.22941,0.18692 z"
       id="path4986"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 405.41409,488.58451 c 1.14338,-1.3619 1.20712,-1.38605 4.26744,-1.61707 4.3207,-0.32617 8.56689,-1.1172 11.82945,-2.20374 1.52392,-0.50751 3.01892,-0.87027 3.32222,-0.80612 0.49225,0.1041 0.4896,0.2045 -0.0247,0.93508 -1.9902,2.82719 -9.60726,5.06967 -17.23139,5.07296 l -3.32374,10e-4 z"
       id="path4988"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 408.08119,485.23492 c 1.33727,-2.31207 1.28624,-2.28876 5.49494,-2.51079 4.42874,-0.23363 6.43186,-0.0297 6.43186,0.65482 0,0.64406 -1.70737,1.13825 -6.07143,1.75733 -4.73838,0.67219 -6.20136,0.69683 -5.85537,0.0986 z"
       id="path4990"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 211.34524,491.49248 c -1.03601,-0.1083 -1.45978,-0.36927 -1.86171,-1.14652 -1.00829,-1.94982 -1.97935,-6.3085 -3.05785,-13.72546 -1.08919,-7.49043 -2.40326,-14.37854 -3.44956,-18.08201 -1.51585,-5.36545 -6.76347,-16.48181 -10.29257,-21.8034 -4.14465,-6.24979 -6.35034,-7.62338 -16.26399,-10.1284 -3.42815,-0.86623 -7.54804,-2.05648 -9.15531,-2.64498 -3.25402,-1.19146 -6.18603,-3.02922 -6.4513,-4.04362 -0.0987,-0.37727 -0.49239,-0.66532 -0.90942,-0.66532 -0.67631,0 -25.47428,-16.00919 -27.30625,-17.6285 -1.08596,-0.95989 -1.0107,-1.51513 0.26565,-1.96007 0.89387,-0.3116 1.46494,-0.20908 3.48214,0.62516 4.1635,1.72187 7.26378,3.784 16.26457,10.81831 5.87123,4.58849 6.32692,4.86967 6.32692,3.90391 0,-1.12185 -13.00999,-11.10619 -18.49509,-14.19381 -1.62766,-0.91622 -2.90381,-1.83258 -2.83589,-2.03634 0.77429,-2.32288 6.61166,0.33187 17.04527,7.75193 2.65178,1.88587 5.1722,3.42994 5.60093,3.43128 0.86227,0.003 0.92559,-0.14766 1.55886,-3.70113 0.63219,-3.54739 1.51515,-4.40623 6.63736,-6.45601 3.97768,-1.59176 4.6302,-1.73923 12.72974,-2.8767 1.03169,-0.14489 1.40035,-0.0538 1.5699,0.38807 0.35382,0.92203 0.0698,1.03412 -11.19794,4.41883 -5.43272,1.63193 -7.00627,3.42008 -5.11993,5.81818 0.88596,1.12632 3.96402,3.12546 4.81224,3.12546 0.34967,0 2.79239,0.717 5.42827,1.59333 4.88261,1.62328 6.00601,1.7032 6.77932,0.48228 0.1632,-0.25766 0.38586,-2.56501 0.49482,-5.12745 0.15935,-3.74781 0.33608,-4.89527 0.90366,-5.86711 0.78873,-1.35048 3.35382,-2.84108 4.91596,-2.8567 l 1.00606,-0.0101 -1.25575,1.53247 c -1.87041,2.28259 -3.07019,5.10984 -3.0743,7.2445 -0.003,1.64374 0.17673,2.05057 1.93025,4.36513 1.06356,1.40385 2.02465,2.99886 2.13576,3.54446 0.33675,1.65366 0.9305,8.26147 0.9305,10.35548 0,1.86079 0.20207,2.30459 3.76342,8.26574 3.62981,6.07571 13.75958,25.73154 17.05064,33.08508 1.87479,4.18903 3.29683,8.36188 3.95553,11.60714 0.33158,1.63359 0.64717,2.35564 1.06509,2.4369 0.38516,0.0749 0.59389,-0.12198 0.59389,-0.56012 0,-0.46693 1.40645,-1.62337 4.55357,-3.74415 9.98657,-6.72973 20.90175,-15.48991 30,-24.07705 2.60268,-2.45647 4.73215,-4.32155 4.73215,-4.14463 0,0.17693 -0.40931,0.7062 -0.90956,1.17617 -1.29113,1.21296 -3.7333,4.43666 -3.7333,4.92801 0,0.2274 0.36161,0.41746 0.80357,0.42237 0.92235,0.0103 1.67792,-0.74841 -8.31508,8.34907 -3.43117,3.12369 -11.20327,10.43619 -17.27134,16.25 -6.06807,5.81382 -11.452,10.85076 -11.96429,11.19322 -0.90319,0.60377 -1.5984,0.66156 -4.41561,0.36706 z m 5.70106,-8.03911 c -0.0854,-0.44426 -0.15857,-0.16488 -0.16253,0.62083 -0.004,0.78572 0.0659,1.1492 0.15532,0.80774 0.0894,-0.34146 0.0926,-0.98432 0.007,-1.42857 z m -27.39545,-57.90415 c 0,-0.31344 -0.56584,-0.55304 -1.57452,-0.66674 -2.07554,-0.23394 -3.28595,-1.14906 -6.31222,-4.77228 -1.38439,-1.65748 -2.66928,-2.91953 -2.85531,-2.80456 -0.46505,0.28742 -0.16999,0.73623 2.7495,4.18221 1.63982,1.93553 3.09871,3.27677 4.10715,3.77593 1.78792,0.88499 3.8854,1.03908 3.8854,0.28544 z"
       id="path4992"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 255.66374,339.52669 c -0.45413,-7.13201 -8.45047,-9.2229 -12.41007,-3.24498 -0.61461,0.92788 -1.30128,2.3006 -1.52595,3.05048 l -0.4085,1.36343 -0.83418,-0.78368 c -1.6571,-1.55676 -0.84898,-6.16886 1.70607,-9.73695 l 1.48055,-2.06756 -5.55556,-11.30233 c -10.84618,-22.06564 -14.60739,-34.41697 -15.94877,-52.37376 -0.30078,-4.02651 -0.25185,-5.25919 0.3686,-9.28571 3.08439,-20.01677 7.01078,-26.86877 18.90063,-32.98368 7.6363,-3.92733 13.11962,-5.37855 18.37556,-4.86329 3.59748,0.35267 4.5186,0.75035 9.49497,4.09931 5.58653,3.75959 9.97474,8.04016 12.25507,11.95448 1.55866,2.67552 2.20272,5.18604 1.33044,5.18604 -0.81042,0 -2.64905,-2.45949 -4.1025,-5.48781 -1.66664,-3.47249 -2.45368,-4.35328 -7.13773,-7.98788 -4.59344,-3.56429 -10.56437,-5.68264 -14.85867,-5.27153 -8.0535,0.77101 -15.00474,3.85578 -20.48325,9.08992 -6.19495,5.91863 -10.03733,14.0615 -11.4649,24.29672 -1.29202,9.26342 -0.20323,22.2792 2.70403,32.32486 1.98705,6.86599 5.56747,17.18446 7.24098,20.86791 1.54361,3.39754 10.30141,20.22675 10.77041,20.6967 0.0747,0.0748 0.72519,-0.14366 1.4456,-0.48552 1.5822,-0.7508 3.18717,-0.56185 5.52345,0.65026 l 1.64928,0.85567 0.95095,-4.80361 c 1.14856,-5.80185 2.25903,-9.22409 4.38941,-13.52724 4.37687,-8.84084 12.40271,-16.26827 23.69647,-21.92966 7.37994,-3.69945 12.12286,-4.64068 23.399,-4.64353 13.13908,-0.003 16.71589,0.64794 29.17259,5.31174 9.08301,3.40068 11.41222,3.99882 15.59775,4.00547 7.50014,0.0119 14.29164,-3.12408 21.50756,-9.93122 2.61656,-2.46833 3.14615,-2.46108 1.43932,0.0197 -1.33169,1.93554 -3.74226,4.14921 -5.88692,5.40607 -2.3802,1.39489 -9.42921,4.33879 -11.95805,4.99408 -4.30963,1.11673 -11.33303,0.46372 -15.94367,-1.48239 -12.25533,-5.17287 -20.75127,-6.81619 -33.21429,-6.42447 -13.51771,0.42489 -24.40011,3.38153 -31.78572,8.63588 -2.46503,1.75371 -8.8653,8.23548 -11.37385,11.5187 -3.62746,4.74765 -6.28201,10.95271 -7.71551,18.03512 -1.1067,5.46779 -1.04644,6.98195 0.44412,11.1589 0.70096,1.96428 1.38699,4.19103 1.52452,4.94833 0.23304,1.28323 0.20304,1.35174 -0.441,1.00706 -0.77501,-0.41477 -1.25332,-0.20344 -1.79877,0.79475 -0.29581,0.54135 -0.40096,0.20642 -0.51947,-1.65479 z"
       id="path4994"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 317.61233,391.84206 c 2.42145,-2.89732 7.43297,-8.96429 11.13672,-13.48214 3.70375,-4.51786 9.25105,-11.1875 12.32734,-14.82143 3.07629,-3.63393 9.17327,-11.02679 13.54885,-16.42857 11.89506,-14.6848 18.42646,-22.57476 25.57349,-30.89286 3.54426,-4.125 6.94305,-8.22322 7.55285,-9.10714 1.66024,-2.40654 3.6721,-4.29342 5.4707,-5.13085 1.46909,-0.68401 2.25137,-0.74888 9.10714,-0.75515 l 7.5,-0.007 3.24705,-1.51786 c 3.0344,-1.41845 4.79045,-1.87696 4.78733,-1.25 -7.2e-4,0.14732 -0.30896,0.77235 -0.68495,1.38896 -1.29823,2.12906 -6.91926,4.11239 -11.98244,4.2279 -4.85513,0.11076 -4.83128,0.10642 -4.83128,0.87914 0,0.64491 0.26348,0.68944 3.83929,0.64877 5.75426,-0.0654 11.59049,1.30634 30.90081,7.26316 l 7.41866,2.2885 -1.34723,0.59851 c -0.74098,0.32919 -1.66867,0.60924 -2.06153,0.62235 -0.39285,0.0131 -3.73581,-0.93926 -7.42878,-2.11637 -3.69298,-1.17711 -6.84989,-2.1402 -7.01536,-2.1402 -0.50553,0 -0.75197,1.08858 -0.28198,1.2456 0.24223,0.0809 3.0922,0.99012 6.33327,2.02044 l 5.89285,1.87331 -1.54401,0.31366 c -1.65746,0.3367 -7.6027,-0.4226 -10.72245,-1.36942 -2.13346,-0.64748 -2.19782,-0.64244 -2.19782,0.17236 0,0.56834 0.53046,0.80512 3.125,1.39492 8.40393,1.9104 10.47732,1.69158 19.55357,-2.0637 5.17377,-2.14064 7.15472,-2.71728 7.48711,-2.17946 0.56207,0.90945 -5.09359,4.02242 -11.77282,6.47995 -2.97612,1.09502 -3.53185,1.18254 -7.5,1.1812 -3.89284,-10e-4 -4.7985,-0.13786 -9.87935,-1.48943 -7.65229,-2.03561 -12.87591,-2.94875 -18.15637,-3.17389 -7.0236,-0.29946 -10.9284,-1.59172 -13.26105,-4.38861 l -1.20323,-1.4427 -3.03572,3.33931 c -1.66964,1.83663 -6.62969,7.17014 -11.02233,11.85225 -14.71786,15.68776 -21.25449,24.3604 -27.86402,36.96926 l -2.45934,4.69162 -9.1824,8.6767 c -8.68829,8.2098 -13.48078,13.08953 -17.48088,17.7991 -1.42362,1.67612 -1.81852,1.96453 -2.07132,1.5128 -0.46349,-0.82822 -1.18063,-0.68351 -2.54372,0.5133 -0.67116,0.58928 -1.32244,1.07143 -1.44728,1.07143 -0.12485,0 1.75418,-2.37054 4.17563,-5.26786 z"
       id="path4996"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#00ff00;fill-opacity:1;stroke:#00ff00;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 446.79371,322.62349 c -0.29465,-0.0648 -1.7009,-0.30177 -3.125,-0.52656 -1.42411,-0.22478 -2.58929,-0.52314 -2.58929,-0.66302 0,-0.13987 0.76339,-0.524 1.69643,-0.85361 1.63488,-0.57756 1.85023,-0.56837 5.93598,0.25318 2.39024,0.48063 4.48781,1.10074 4.80868,1.4216 0.52072,0.52073 0.28172,0.5656 -2.81099,0.52769 -1.85905,-0.0228 -3.62117,-0.0945 -3.91581,-0.15928 z"
       id="path4998"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#aaffff;fill-opacity:1;stroke:#aaffff;stroke-width:0.26996624;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 448.24242,319.47668 -1.94414,-0.41021 1.56916,-0.70759 c 0.86303,-0.38918 1.88685,-0.65377 2.27515,-0.58799 1.03578,0.17548 2.3654,1.13193 2.3654,1.70153 0,0.59423 -1.46263,0.59569 -4.26557,0.004 z"
       id="path5000"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#ccffff;fill-opacity:1;stroke:#ccffff;stroke-width:0.19089496;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 250.94617,349.24062 c 1.11118,-2.512 0.39477,-6.05784 -1.69312,-8.38007 -1.89545,-2.10821 -3.19657,-2.40816 -5.48343,-1.26414 -0.52086,0.26057 -0.94702,0.41085 -0.94702,0.33396 0,-0.3491 1.40136,-2.86695 2.06393,-3.7083 1.07634,-1.36678 3.16498,-2.31876 4.75265,-2.1662 1.5487,0.14881 3.03094,1.08578 3.97727,2.51414 0.64598,0.97502 0.70281,1.27045 0.78147,4.06269 0.13848,4.91507 -0.82275,8.54342 -2.49202,9.40663 -1.33729,0.69154 -1.54315,0.52021 -0.95973,-0.79871 z"
       id="path5006"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#ccffff;fill-opacity:1;stroke:#ccffff;stroke-width:0.19089496;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 250.65128,350.09338 c 0,-0.20644 0.17047,-0.78332 0.37881,-1.28196 1.12133,-2.68372 -0.31959,-7.04489 -2.97212,-8.99558 -1.24611,-0.9164 -2.54859,-1.00021 -4.16208,-0.26782 -1.34756,0.61168 -1.37456,0.35214 -0.17162,-1.64955 1.22101,-2.03175 1.78402,-2.6006 3.26521,-3.29909 2.22563,-1.04956 4.49928,-0.59019 6.09948,1.23234 1.24639,1.41955 1.42884,2.32384 1.28034,6.34556 -0.14717,3.98554 -0.60867,5.9817 -1.66483,7.20108 -0.75819,0.87535 -2.05319,1.32633 -2.05319,0.71502 z"
       id="path5008"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
    <path
       style="fill:#ccffff;fill-opacity:1;stroke:#ccffff;stroke-width:0.19089496;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 241.26078,352.10763 c -0.0886,-1.68789 -0.24719,-2.33243 -0.84351,-3.42808 -0.87129,-1.60085 -2.06976,-2.65369 -3.62329,-3.18303 -1.54368,-0.52599 -2.03491,-0.48954 -3.43498,0.25488 l -1.20507,0.64074 0.11013,-1.46148 c 0.22976,-3.04928 1.75744,-4.63023 4.71396,-4.87832 1.64791,-0.13828 1.64964,-0.13772 2.49344,0.79625 1.58416,1.75349 1.90728,2.28594 2.02506,3.33711 0.14381,1.28335 0.63253,2.51224 1.49686,3.76382 0.57745,0.83618 0.63228,1.09755 0.47676,2.27285 -0.22001,1.66271 -0.95082,3.34882 -1.60268,3.69769 -0.47286,0.25306 -0.50299,0.16303 -0.60668,-1.81243 z"
       id="path5010"
       inkscape:connector-curvature="0"
       transform="scale(0.26458333)" />
  </g>
  <g
     inkscape:groupmode="layer"
     id="layer4"
     inkscape:label="Binary">
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
       x="48.097469"
       y="106.35825"
       id="text5015"><tspan
         sodipodi:role="line"
         x="48.097469"
         y="106.35825"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:5.29166651px;font-family:'Latin Modern Mono Light';-inkscape-font-specification:'Latin Modern Mono Light, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;stroke-width:0.26458332"
         id="tspan5017">01110</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
       x="100.07777"
       y="44.714355"
       id="text5023"
       transform="rotate(42)"><tspan
         sodipodi:role="line"
         id="tspan5021"
         x="100.07777"
         y="44.714355"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:5.99722242px;font-family:'Latin Modern Mono Light';-inkscape-font-specification:'Latin Modern Mono Light, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;stroke-width:0.26458332">01010</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:5.99722195px;line-height:1.25;font-family:'Latin Modern Mono Light';-inkscape-font-specification:'Latin Modern Mono Light, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332"
       x="99.480774"
       y="24.387804"
       id="text5031"
       transform="rotate(18)"><tspan
         sodipodi:role="line"
         x="99.480774"
         y="29.755318"
         style="stroke-width:0.26458332"
         id="tspan5035" /><tspan
         sodipodi:role="line"
         x="99.480774"
         y="37.251846"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777767px;font-family:'Latin Modern Mono Light';-inkscape-font-specification:'Latin Modern Mono Light, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;stroke-width:0.26458332"
         id="tspan5053">3251 ┊ 6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc</tspan></text>
    <rect
       style="fill:#101011;fill-opacity:0;stroke:#ccffff;stroke-width:0.2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5103"
       width="147.22171"
       height="153.8363"
       x="29.482143"
       y="53.772324"
       inkscape:export-filename="/home/fitzgen/Downloads/twiggy.png"
       inkscape:export-xdpi="96"
       inkscape:export-ydpi="96" />
  </g>
</svg>

'''
'''--- guide/src/usage/as-a-crate.md ---
# 🦀 As a Crate

`twiggy` is divided into a collection of crates that you can use
programmatically, but no long-term stability is promised. We will follow semver
as best as we can, but will err on the side of being more conservative with
breaking version bumps than might be strictly necessary.

Here is a simple example:

```rust
extern crate twiggy_analyze;
extern crate twiggy_opt;
extern crate twiggy_parser;

use std::fs;
use std::io;

fn main() {
    let mut file = fs::File::open("path/to/some/binary").unwrap();
    let mut data = vec![];
    file.read_to_end(&mut data).unwrap();

    let items = twiggy_parser::parse(&data).unwrap();

    let options = twiggy_opt::Top::default();
    let top = twiggy_analyze::top(&mut items, &options).unwrap();

    let mut stdout = io::stdout();
    top.emit_text(&items, &mut stdout).unwrap();
}
```

For a more in-depth example, take a look at the implementation of the
`twiggy` CLI crate.

'''
'''--- guide/src/usage/command-line-interface/diff.md ---
# `twiggy diff`

The `twiggy diff` sub-command computes the delta size of each item between old
and new versions of a binary.

```
 Delta Bytes │ Item
─────────────┼──────────────────────────────────────────────
       -1034 ┊ data[3]
        -593 ┊ "function names" subsection
        +396 ┊ wee_alloc::alloc_first_fit::he2a4ddf96981c0ce
        +243 ┊ goodbye
        -226 ┊ wee_alloc::alloc_first_fit::h9a72de3af77ef93f
        -262 ┊ ... and 29 more.
       -1476 ┊ Σ [34 Total Rows]
```

'''
'''--- guide/src/usage/command-line-interface/dominators.md ---
# `twiggy dominators`

The `twiggy dominators` sub-command displays the dominator tree of a binary's
call graph.

```
 Retained Bytes │ Retained % │ Dominator Tree
────────────────┼────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
         175726 ┊     14.99% ┊ export "items_parse"
         175712 ┊     14.98% ┊   ⤷ items_parse
         131407 ┊     11.21% ┊       ⤷ twiggy_parser::wasm_parse::<impl twiggy_parser::Parse for wasmparser::readers::module::ModuleReader>::parse_items::h39c45381d868d181
          18492 ┊      1.58% ┊       ⤷ wasmparser::binary_reader::BinaryReader::read_operator::hb1c7cde18e148939
           2677 ┊      0.23% ┊       ⤷ alloc::collections::btree::map::BTreeMap<K,V>::insert::hd2463626e5ac3441
           1349 ┊      0.12% ┊       ⤷ wasmparser::readers::module::ModuleReader::read::hb76af8efd547784f
           1081 ┊      0.09% ┊       ⤷ core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once::h1ff7fe5b944492c3
            776 ┊      0.07% ┊       ⤷ <wasmparser::readers::import_section::ImportSectionReader as wasmparser::readers::section_reader::SectionReader>::read::h12903e6d8d4091bd
```

'''
'''--- guide/src/usage/command-line-interface/garbage.md ---
# `twiggy garbage`

The `twiggy garbage` sub-command finds and displays dead code and data that is
not transitively referenced by any exports or public functions.

```
 Bytes │ Size % │ Garbage Item
───────┼────────┼────────────────────────────────
    12 ┊  6.09% ┊ unusedAddThreeNumbers
     9 ┊  4.57% ┊ unusedAddOne
     7 ┊  3.55% ┊ type[2]: (i32, i32, i32) -> i32
     6 ┊  3.05% ┊ unusedChild
     5 ┊  2.54% ┊ type[1]: (i32) -> i32
     4 ┊  2.03% ┊ type[0]: () -> i32
    43 ┊ 21.83% ┊ Σ [6 Total Rows]
```

'''
'''--- guide/src/usage/command-line-interface/index.md ---
# ⌨ Command Line Interface

`twiggy` is primarily a command line tool.

To get the most up-to-date usage for the version of `twiggy` that you have
installed, you can always run:

```
twiggy --help
```

Or, to get more information about a sub-command, run:

```
twiggy subcmd --help
```

'''
'''--- guide/src/usage/command-line-interface/monos.md ---
# `twiggy monos`

The `twiggy monos` sub-command lists the generic function monomorphizations that
are contributing to code bloat.

```
 Apprx. Bloat Bytes │ Apprx. Bloat % │ Bytes │ %      │ Monomorphizations
────────────────────┼────────────────┼───────┼────────┼────────────────────────────────────────────────────────
               2141 ┊          3.68% ┊  3249 ┊  5.58% ┊ alloc::slice::merge_sort
                    ┊                ┊  1108 ┊  1.90% ┊     alloc::slice::merge_sort::hb3d195f9800bdad6
                    ┊                ┊  1108 ┊  1.90% ┊     alloc::slice::merge_sort::hfcf2318d7dc71d03
                    ┊                ┊  1033 ┊  1.77% ┊     alloc::slice::merge_sort::hcfca67f5c75a52ef
               1457 ┊          2.50% ┊  4223 ┊  7.26% ┊ <&'a T as core::fmt::Debug>::fmt
                    ┊                ┊  2766 ┊  4.75% ┊     <&'a T as core::fmt::Debug>::fmt::h1c27955d8de3ff17
                    ┊                ┊   636 ┊  1.09% ┊     <&'a T as core::fmt::Debug>::fmt::hea6a77c4dcddb7ac
                    ┊                ┊   481 ┊  0.83% ┊     <&'a T as core::fmt::Debug>::fmt::hfbacf6f5c9f53bb2
                    ┊                ┊   340 ┊  0.58% ┊     ... and 1 more.
               3759 ┊          6.46% ┊ 31160 ┊ 53.54% ┊ ... and 214 more.
               7357 ┊         12.64% ┊ 38632 ┊ 66.37% ┊ Σ [223 Total Rows]
```

'''
'''--- guide/src/usage/command-line-interface/paths.md ---
# `twiggy paths`

The `twiggy paths` sub-command finds the call paths to a function in the given
binary's call graph. This tells you what other functions are calling this
function, why this function is not dead code, and therefore why it wasn't
removed by the linker.

```
 Shallow Bytes │ Shallow % │ Retaining Paths
───────────────┼───────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
           153 ┊     5.43% ┊ wee_alloc::alloc_with_refill::hb32c1bbce9ebda8e
               ┊           ┊   ⬑ <wee_alloc::size_classes::SizeClassAllocPolicy<'a> as wee_alloc::AllocPolicy>::new_cell_for_free_list::h3987e3054b8224e6
               ┊           ┊       ⬑ elem[0]
               ┊           ┊           ⬑ table[0]
               ┊           ┊   ⬑ hello
               ┊           ┊       ⬑ export "hello"

```

'''
'''--- guide/src/usage/command-line-interface/top.md ---
# `twiggy top`

The `twiggy top` sub-command summarizes and lists the top code size offenders in
a binary.

```
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
          1034 ┊    36.71% ┊ data[3]
           777 ┊    27.58% ┊ "function names" subsection
           226 ┊     8.02% ┊ wee_alloc::alloc_first_fit::h9a72de3af77ef93f
           165 ┊     5.86% ┊ hello
           153 ┊     5.43% ┊ wee_alloc::alloc_with_refill::hb32c1bbce9ebda8e
           137 ┊     4.86% ┊ <wee_alloc::size_classes::SizeClassAllocPolicy<'a> as wee_alloc::AllocPolicy>::new_cell_for_free_list::h3987e3054b8224e6
            77 ┊     2.73% ┊ <wee_alloc::LargeAllocPolicy as wee_alloc::AllocPolicy>::new_cell_for_free_list::h8f071b7bce0301ba
            45 ┊     1.60% ┊ goodbye
            25 ┊     0.89% ┊ data[1]
            25 ┊     0.89% ┊ data[2]
           153 ┊     5.43% ┊ ... and 27 more.
          2817 ┊   100.00% ┊ Σ [37 Total Rows]
```

'''
'''--- guide/src/usage/index.md ---
# 🏋️‍♀️ Usage

Twiggy is primarily a command line tool, but it can also be used as a library
crate from within other Rust projects, or compiled to WebAssembly and used from
JavaScript on the Web or from Node.js

'''
'''--- guide/src/usage/on-the-web-with-webassembly.md ---
# 🕸 On the Web with WebAssembly

First, ensure you have the `wasm32-unknown-unknown` Rust target installed and
up-to-date:

```
rustup target add wasm32-unknown-unknown
```

Next, install `wasm-bindgen`:

```
cargo install wasm-bindgen-cli
```

Finally, build `twiggy`'s WebAssembly API with `wasm-bindgen`:

```
cd twiggy/wasm-api
cargo build --release --target wasm32-unknown-unknown
wasm-bindgen ../target/wasm32-unknown-unknown/release/twiggy_wasm_api.wasm --out-dir .
```

This should produce two artifacts in the current directory:

1. `twiggy_wasm_api_bg.wasm`: The WebAssembly file containing `twiggy`.
2. `twiggy_wasm_api.js`: The JavaScript bindings to `twiggy`'s WebAssembly.

You can now use `twiggy` from JavaScript like this:

```js
import { Items, Monos } from './twiggy_wasm_api';

// Parse a binary's data into a collection of items.
const items = Items.parse(myData);

// Configure an analysis and its options.
const opts = Monos.new();
opts.set_max_generics(10);
opts.set_max_monos(10);

// Run the analysis on the parsed items.
const monos = JSON.parse(items.monos(opts));
```

'''
'''--- ir/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = []
description = "Intermediate representation for the Twiggy code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy-ir"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[lib]
path = "./ir.rs"

[dependencies]
cpp_demangle = { version = "0.3.0", default-features = false }
frozen = "1"
petgraph = "0.5.1"
rustc-demangle = "0.1.16"
serde = "1.0.114"
serde_derive = "1.0.114"

'''
'''--- ir/graph_impl.rs ---
use super::{Id, Items, Neighbors};
use petgraph::visit;
use std::collections::HashSet;

impl visit::GraphBase for Items {
    type EdgeId = ();
    type NodeId = Id;
}

impl visit::Visitable for Items {
    type Map = HashSet<Id>;

    #[inline]
    fn visit_map(&self) -> Self::Map {
        HashSet::with_capacity(self.items.len())
    }

    #[inline]
    fn reset_map(&self, map: &mut Self::Map) {
        map.clear();
    }
}

impl<'a> visit::IntoNeighbors for &'a Items {
    type Neighbors = Neighbors<'a>;

    #[inline]
    fn neighbors(self, id: Id) -> Self::Neighbors {
        self.neighbors(id)
    }
}

impl visit::NodeCount for Items {
    #[inline]
    fn node_count(&self) -> usize {
        self.items.len()
    }
}

'''
'''--- ir/ir.rs ---
//! The `twiggy` code size profiler.

#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

mod graph_impl;

use frozen::Frozen;
use std::cmp;
use std::collections::btree_map;
use std::collections::{BTreeMap, BTreeSet};
use std::ops;
use std::slice;
use std::u32;

/// Build up a a set of `Items`.
#[derive(Debug)]
pub struct ItemsBuilder {
    size: u32,
    size_added: u32,
    parsed: BTreeSet<Id>,
    items: BTreeMap<Id, Item>,
    edges: BTreeMap<Id, BTreeSet<Id>>,
    roots: BTreeSet<Id>,

    // Maps the offset some data begins at to its IR item's identifier, and the
    // byte length of the data.
    data: BTreeMap<u32, (Id, u32)>,
}

impl ItemsBuilder {
    /// Construct a new builder, with the given size.
    pub fn new(size: u32) -> ItemsBuilder {
        ItemsBuilder {
            size,
            size_added: 0,
            parsed: Default::default(),
            items: Default::default(),
            edges: Default::default(),
            roots: Default::default(),
            data: Default::default(),
        }
    }

    /// Add the given item to to the graph and return the `Id` that it was
    /// assigned.
    pub fn add_item(&mut self, item: Item) -> Id {
        let id = item.id;
        self.size_added += item.size;
        self.items.insert(id, item);
        id
    }

    /// Add the given item to the graph as a root and return the `Id` that it
    /// was assigned.
    pub fn add_root(&mut self, item: Item) -> Id {
        let id = self.add_item(item);
        self.roots.insert(id);
        id
    }

    /// Add an edge between the given keys that have already been parsed into
    /// items.
    pub fn add_edge(&mut self, from: Id, to: Id) {
        debug_assert!(self.items.contains_key(&from), "`from` is not known");
        debug_assert!(self.items.contains_key(&to), "`to` is not known");

        self.edges
            .entry(from)
            .or_insert_with(BTreeSet::new)
            .insert(to);
    }

    /// Add a range of static data and the `Id` that defines it.
    pub fn link_data(&mut self, offset: i64, len: usize, id: Id) {
        if offset >= 0 && offset <= i64::from(u32::MAX) && offset as usize + len < u32::MAX as usize
        {
            self.data.insert(offset as u32, (id, len as u32));
        }
    }

    /// Locate the data section defining memory at the given offset.
    pub fn get_data(&self, offset: u32) -> Option<Id> {
        self.data
            .range(offset..)
            .next()
            .and_then(
                |(start, &(id, len))| {
                    if offset < start + len {
                        Some(id)
                    } else {
                        None
                    }
                },
            )
    }

    /// Return the size of all added items so far
    pub fn size_added(&self) -> u32 {
        self.size_added
    }

    /// Finish building the IR graph and return the resulting `Items`.
    pub fn finish(mut self) -> Items {
        let meta_root_id = Id::root();
        let meta_root = Item::new(meta_root_id, "<meta root>", 0, Misc::new());
        self.items.insert(meta_root_id, meta_root);
        self.edges.insert(meta_root_id, self.roots.clone());

        Items {
            size: self.size,
            dominator_tree: None,
            retained_sizes: None,
            predecessors: None,
            immediate_dominators: None,
            items: Frozen::freeze(self.items),
            edges: Frozen::freeze(
                self.edges
                    .into_iter()
                    .map(|(from, tos)| (from, tos.into_iter().collect::<Vec<_>>()))
                    .collect(),
            ),
            roots: Frozen::freeze(self.roots),
            meta_root: meta_root_id,
        }
    }
}

/// The architecture- and target-independent internal representation of
/// functions, sections, etc in a file that is being size profiled.
///
/// Constructed with `ItemsBuilder`.
#[derive(Debug)]
pub struct Items {
    size: u32,
    dominator_tree: Option<BTreeMap<Id, Vec<Id>>>,
    immediate_dominators: Option<BTreeMap<Id, Id>>,
    retained_sizes: Option<BTreeMap<Id, u32>>,
    predecessors: Option<BTreeMap<Id, Vec<Id>>>,
    items: Frozen<BTreeMap<Id, Item>>,
    edges: Frozen<BTreeMap<Id, Vec<Id>>>,
    roots: Frozen<BTreeSet<Id>>,
    meta_root: Id,
}

impl ops::Index<Id> for Items {
    type Output = Item;

    fn index(&self, id: Id) -> &Item {
        &self.items[&id]
    }
}

impl Items {
    /// Iterate over all of the IR items.
    pub fn iter(&self) -> Iter {
        Iter {
            inner: self.items.iter(),
        }
    }

    /// Iterate over an item's neighbors.
    pub fn neighbors(&self, id: Id) -> Neighbors {
        Neighbors {
            inner: self
                .edges
                .get(&id)
                .map_or_else(|| [].iter(), |edges| edges.iter()),
        }
    }

    /// Iterate over an item's predecessors.
    pub fn predecessors(&self, id: Id) -> Predecessors {
        Predecessors {
            inner: self
                .predecessors
                .as_ref()
                .expect("To access predecessors, must have already called compute_predecessors")
                .get(&id)
                .map_or_else(|| [].iter(), |edges| edges.iter()),
        }
    }

    /// The size of the total binary, containing all items.
    pub fn size(&self) -> u32 {
        self.size
    }

    /// Get the id of the "meta root" which is a single root item with edges to
    /// all of the real roots.
    pub fn meta_root(&self) -> Id {
        self.meta_root
    }

    /// Force computation of predecessors.
    pub fn compute_predecessors(&mut self) {
        if self.predecessors.is_some() {
            return;
        }

        let mut predecessors = BTreeMap::new();

        for (from, tos) in self.edges.iter() {
            for to in tos {
                predecessors
                    .entry(*to)
                    .or_insert_with(BTreeSet::new)
                    .insert(*from);
            }
        }

        self.predecessors = Some(
            predecessors
                .into_iter()
                .map(|(k, v)| (k, v.into_iter().collect()))
                .collect(),
        );
    }

    /// Compute dominators for each item.
    pub fn compute_dominators(&mut self) {
        if self.immediate_dominators.is_some() {
            return;
        }

        let mut immediate_dominators = BTreeMap::new();
        let dominators = petgraph::algo::dominators::simple_fast(&*self, self.meta_root);

        for item in self.iter() {
            if let Some(idom) = dominators.immediate_dominator(item.id()) {
                immediate_dominators.insert(item.id(), idom);
            }
        }

        self.immediate_dominators = Some(immediate_dominators);
    }

    /// Get a refercence to immediate dominators
    pub fn immediate_dominators(&self) -> &BTreeMap<Id, Id> {
        self.immediate_dominators
            .as_ref()
            .expect("must call compute_immediate_dominators before calling immediate_dominators")
    }

    /// Force computation of the dominator tree.
    pub fn compute_dominator_tree(&mut self) {
        if self.dominator_tree.is_some() {
            return;
        }

        let mut dominator_tree = BTreeMap::new();
        let dominators = petgraph::algo::dominators::simple_fast(&*self, self.meta_root);
        for item in self.iter() {
            if let Some(idom) = dominators.immediate_dominator(item.id()) {
                dominator_tree
                    .entry(idom)
                    .or_insert_with(BTreeSet::new)
                    .insert(item.id());
            }
        }

        self.dominator_tree = Some(
            dominator_tree
                .into_iter()
                .map(|(k, v)| (k, v.into_iter().collect()))
                .collect(),
        );
    }

    /// Get a reference to the dominator tree.
    ///
    /// Must have already called `compute_dominator_tree`.
    pub fn dominator_tree(&self) -> &BTreeMap<Id, Vec<Id>> {
        self.dominator_tree
            .as_ref()
            .expect("must call compute_dominator_tree before calling dominator_tree")
    }

    /// Force computation of the retained sizes of each IR item.
    pub fn compute_retained_sizes(&mut self) {
        if self.retained_sizes.is_some() {
            return;
        }
        self.compute_dominator_tree();

        fn recursive_retained_size(
            retained_sizes: &mut BTreeMap<Id, u32>,
            items: &Items,
            item: &Item,
            dominator_tree: &BTreeMap<Id, Vec<Id>>,
        ) -> u32 {
            // Although the dominator tree cannot have cycles, because we
            // compute retained sizes in item iteration order, rather than from
            // the bottom of the dominator tree up, it is possible we have
            // already computed the retained sizes for subtrees.
            if let Some(rsize) = retained_sizes.get(&item.id()) {
                return *rsize;
            }

            let mut rsize = item.size();
            if let Some(children) = dominator_tree.get(&item.id()) {
                for child in children {
                    rsize += recursive_retained_size(
                        retained_sizes,
                        items,
                        &items[*child],
                        dominator_tree,
                    );
                }
            }

            let old_value = retained_sizes.insert(item.id(), rsize);
            // The dominator tree is a proper tree, so there shouldn't be
            // any cycles.
            assert!(old_value.is_none());
            rsize
        }

        let mut retained_sizes = BTreeMap::new();
        {
            let dominator_tree = self.dominator_tree.as_ref().unwrap();
            for item in self.iter() {
                recursive_retained_size(&mut retained_sizes, self, item, dominator_tree);
            }
        }
        self.retained_sizes = Some(retained_sizes);
    }

    /// Get the given item's retained size.
    pub fn retained_size(&self, id: Id) -> u32 {
        self.retained_sizes
            .as_ref()
            .expect(
                "Cannot call retained_sizes unless compute_retained_sizes \
                 has already been called",
            )
            .get(&id)
            .cloned()
            .unwrap()
    }

    /// Get an item with the given name.
    pub fn get_item_by_name(&self, name: &str) -> Option<&Item> {
        for item in self.iter() {
            if item.name() == name {
                return Some(item);
            }
        }

        None // Return `None` if `name` did not match any items.
    }
}

/// An iterator over an item's neighbors.
#[derive(Debug)]
pub struct Neighbors<'a> {
    inner: slice::Iter<'a, Id>,
}

impl<'a> Iterator for Neighbors<'a> {
    type Item = Id;

    #[inline]
    fn next(&mut self) -> Option<Id> {
        self.inner.next().cloned()
    }
}

/// An iterator over an item's predecessors.
#[derive(Debug)]
pub struct Predecessors<'a> {
    inner: slice::Iter<'a, Id>,
}

impl<'a> Iterator for Predecessors<'a> {
    type Item = Id;

    #[inline]
    fn next(&mut self) -> Option<Id> {
        self.inner.next().cloned()
    }
}

/// An iterator over IR items. Created by `Items::iter`.
#[derive(Clone, Debug)]
pub struct Iter<'a> {
    inner: btree_map::Iter<'a, Id, Item>,
}

impl<'a> Iterator for Iter<'a> {
    type Item = &'a Item;

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next().map(|(_, item)| item)
    }
}

/// An item's unique identifier.
/// (section index, item within that section index)
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Id(u32, u32);

impl Id {
    /// Create an `Id` for a the given section.
    pub fn section(section: usize) -> Id {
        assert!(section < u32::MAX as usize);
        Id(section as u32, u32::MAX)
    }

    /// Create an `Id` for a given entry in a given section.
    pub fn entry(section: usize, index: usize) -> Id {
        assert!(section < u32::MAX as usize);
        assert!(index < u32::MAX as usize);
        Id(section as u32, index as u32)
    }

    /// Create the `Id` for the "meta root".
    pub fn root() -> Id {
        Id(u32::MAX, u32::MAX)
    }

    /// Get the real id of a item.
    pub fn serializable(self) -> u64 {
        let top = (u64::from(self.0)) << 32;
        top | u64::from(self.1)
    }
}

/// An item in the binary.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Item {
    id: Id,
    name: String,
    size: u32,
    kind: ItemKind,
}

impl Item {
    /// Construct a new `Item` of the given kind.
    pub fn new<S, K>(id: Id, name: S, size: u32, kind: K) -> Item
    where
        S: Into<String>,
        K: Into<ItemKind>,
    {
        let name = name.into();
        Item {
            id,
            name,
            size,
            kind: kind.into(),
        }
    }

    /// Get this item's identifier.
    #[inline]
    pub fn id(&self) -> Id {
        self.id
    }

    /// Get this item's size.
    #[inline]
    pub fn size(&self) -> u32 {
        self.size
    }

    /// Get this item's name.
    #[inline]
    pub fn name(&self) -> &str {
        if let ItemKind::Code(ref code) = self.kind {
            code.demangled().unwrap_or(&self.name)
        } else {
            &self.name
        }
    }

    /// Get this item's kind.
    #[inline]
    pub fn kind(&self) -> &ItemKind {
        &self.kind
    }

    /// The the name of the generic function that this is a monomorphization of
    /// (if any).
    #[inline]
    pub fn monomorphization_of(&self) -> Option<&str> {
        if let ItemKind::Code(ref code) = self.kind {
            code.monomorphization_of()
        } else {
            None
        }
    }
}

impl PartialOrd for Item {
    fn partial_cmp(&self, rhs: &Item) -> Option<cmp::Ordering> {
        self.id.partial_cmp(&rhs.id)
    }
}

impl Ord for Item {
    fn cmp(&self, rhs: &Item) -> cmp::Ordering {
        self.id.cmp(&rhs.id)
    }
}

/// The kind of item in the binary.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ItemKind {
    /// Executable code. Function bodies.
    Code(Code),

    /// Data inside the binary that may or may not end up loaded into memory
    /// with the executable code.
    Data(Data),

    /// Debugging symbols and information, such as a DWARF section.
    Debug(DebugInfo),

    /// Miscellaneous item. Perhaps metadata. Perhaps something else.
    Misc(Misc),
}

impl ItemKind {
    /// Returns true if `self` is the `Data` variant
    pub fn is_data(&self) -> bool {
        match self {
            ItemKind::Data(_) => true,
            _ => false,
        }
    }
}

impl From<Code> for ItemKind {
    fn from(c: Code) -> ItemKind {
        ItemKind::Code(c)
    }
}

impl From<Data> for ItemKind {
    fn from(d: Data) -> ItemKind {
        ItemKind::Data(d)
    }
}

impl From<DebugInfo> for ItemKind {
    fn from(d: DebugInfo) -> ItemKind {
        ItemKind::Debug(d)
    }
}

impl From<Misc> for ItemKind {
    fn from(m: Misc) -> ItemKind {
        ItemKind::Misc(m)
    }
}

/// Executable code. Function bodies.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Code {
    demangled: Option<String>,
    monomorphization_of: Option<String>,
}

impl Code {
    /// Construct a new IR item for executable code.
    pub fn new(name: &str) -> Code {
        let demangled = Self::demangle(&name);
        let monomorphization_of =
            Self::extract_generic_function(demangled.as_ref().map(|s| s.as_str()).unwrap_or(name));
        Code {
            demangled,
            monomorphization_of,
        }
    }

    /// Get the demangled name of this function, if any.
    pub fn demangled(&self) -> Option<&str> {
        self.demangled.as_ref().map(|s| s.as_str())
    }

    /// Get the name of the generic function that this is a monomorphization of,
    /// if any.
    pub fn monomorphization_of(&self) -> Option<&str> {
        self.monomorphization_of.as_ref().map(|s| s.as_str())
    }

    fn demangle(s: &str) -> Option<String> {
        if let Ok(sym) = rustc_demangle::try_demangle(s) {
            return Some(sym.to_string());
        }

        // If the Rust demangle failed, we'll try C or C++.  C++
        // symbols almost all start with the prefixes "_Z", "__Z", and
        // ""_GLOBAL_", except for a special case.
        //
        // Per cpp_mangle::ast::MangledName::parse:
        //
        // > The libiberty tests also specify that a type can be top level,
        // > and they are not prefixed with "_Z".
        //
        // Therefore cpp_demangle will parse unmangled symbols, at
        // least sometimes incorrectly (e.g. with OpenSSL's RC4
        // function, which is incorrectly parsed as a type ctor/dtor),
        // which confuses a subsequent `demangle` function, resulting
        // in panic.
        //
        // To avoid that, only pass C++-mangled symbols to the C++
        // demangler
        if !s.starts_with("_Z") && !s.starts_with("__Z") && !s.starts_with("_GLOBAL_") {
            return Some(s.to_string());
        }

        if let Ok(sym) = cpp_demangle::Symbol::new(s) {
            return Some(sym.to_string());
        }

        None
    }

    fn extract_generic_function(demangled: &str) -> Option<String> {
        // XXX: This is some hacky, ad-hoc parsing shit! This should
        // approximately work for Rust and C++ symbols, but who knows for other
        // languages. Also, it almost definitely has bugs!

        // First, check for Rust-style symbols by looking for Rust's
        // "::h1234567890" hash from the end of the symbol. If it's there, the
        // generic function is just the symbol without that hash, so remove it.
        //
        // I know what you're thinking, and it's true: mangled (and therefore
        // also demangled) Rust symbols don't include the concrete type(s) used
        // to instantiate the generic function, which gives us much less to work
        // with than we have with C++ demangled symbols. It would sure be nice
        // if we could tell the user more about the monomorphization, but
        // alas... :(
        if let Some(idx) = demangled.rfind("::h") {
            let idx2 = demangled.rfind("::").unwrap();
            assert!(idx2 >= idx);
            if idx2 == idx {
                let generic = demangled[..idx].to_string();
                return Some(generic);
            }
        }

        // From here on out, we assume we are dealing with C++ symbols.
        //
        // Find the '<' and '>' that hug the generic type(s).
        let open_bracket = match demangled.char_indices().find(|&(_, ch)| ch == '<') {
            None => return None,
            Some((idx, _)) => idx,
        };
        let close_bracket = match demangled.char_indices().rev().find(|&(_, ch)| ch == '>') {
            None => return None,
            Some((idx, _)) => idx,
        };

        // If the '<' doesn't come before the '>', then we aren't looking at a
        // generic function instantiation. If there isn't anything proceeding
        // the '<', then we aren't looking at a generic function instantiation
        // (most likely looking at a Rust trait method's implementation, like
        // `<MyType as SomeTrait>::trait_method()`).
        if close_bracket < open_bracket || open_bracket == 0 {
            return None;
        }

        // And now we say that the generic function is the thing proceeding the
        // '<'. Good enough!
        Some(demangled[..open_bracket].to_string())
    }
}

/// Data inside the binary that may or may not end up loaded into memory
/// with the executable code.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Data {
    ty: Option<String>,
}

impl Data {
    /// Construct a new `Data` that has a type of the given type name, if known.
    pub fn new(ty: Option<String>) -> Data {
        Data { ty }
    }
}

/// Debugging symbols and information, such as DWARF sections.
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub struct DebugInfo;

impl DebugInfo {
    /// Construct a new IR item for debug information and symbols.
    pub fn new() -> DebugInfo {
        DebugInfo
    }
}

/// Miscellaneous item. Perhaps metadata. Perhaps something else.
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub struct Misc;

impl Misc {
    /// Construct a new miscellaneous IR item.
    pub fn new() -> Misc {
        Misc
    }
}

'''
'''--- opt/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = []
description = "Options for the Twiggy code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy-opt"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[lib]
path = "opt.rs"

[build-dependencies]
regex = "1.3.9"

[dependencies]
structopt = { version = "0.3", optional = true }
twiggy-traits = { version = "=0.6.0", path = "../traits" }
wasm-bindgen = { version = "0.2.64", optional = true }
cfg-if = "0.1.10"

[features]
default = ["cli", "emit_csv", "emit_json", "emit_text"]
cli = ["structopt"]
wasm = ["wasm-bindgen"]
emit_json = ["twiggy-traits/emit_json"]
emit_text = ["twiggy-traits/emit_text"]
emit_csv = ["twiggy-traits/emit_csv"]

'''
'''--- opt/build.rs ---
use std::env;
use std::fs;
use std::io::{self, BufRead, Write};
use std::path::{Path, PathBuf};

fn main() {
    let mut cli = PathBuf::new();
    cli.push(env::var("OUT_DIR").expect("should have OUT_DIR env var"));

    let mut wasm = cli.clone();
    wasm.push("wasm.rs");

    cli.push("cli.rs");

    println!("cargo:rerun-if-changed=./definitions.rs");
    println!("cargo:rerun-if-changed=./build.rs");

    copy_without_lines_matching_pattern("definitions.rs", cli, ".*\\bwasm_bindgen\\b.*");
    copy_without_lines_matching_pattern("definitions.rs", wasm, ".*\\bstructopt\\b.*");
}

fn copy_without_lines_matching_pattern<P1, P2, S>(from: P1, to: P2, pattern: S)
where
    P1: AsRef<Path>,
    P2: AsRef<Path>,
    S: AsRef<str>,
{
    let from = from.as_ref();
    let from = fs::File::open(from).expect(&format!("should open `{}` OK", from.display()));
    let from = io::BufReader::new(from);

    let to = to.as_ref();
    let to = fs::File::create(to).expect(&format!("should open `{}` OK", to.display()));
    let mut to = io::BufWriter::new(to);

    let pattern_str = pattern.as_ref();
    let pattern = regex::RegexBuilder::new(pattern_str)
        .case_insensitive(true)
        .build()
        .expect(&format!("should create regex from '{}' OK", pattern_str));

    for line in from.lines() {
        let line = line.expect("should read line OK");

        if pattern.is_match(&line) {
            continue;
        }

        to.write_all(line.as_bytes()).expect("should write line OK");
        to.write_all(b"\n").expect("should write newline OK");
    }
}

'''
'''--- opt/definitions.rs ---
// Fun times ahead!
//
// Apparently, proc-macros don't play well with `cfg_attr` yet, and their
// combination is buggy. So we can't use cfg_attr to choose between
// `wasm-bindgen` and `structopt` depending on if we're building the CLI or the
// wasm API respectively. Instead, we have `build.rs` remove unwanted attributes
// for us by invoking `grep`.
//
// It's terrible! But it works for now.

use structopt::StructOpt;

/// Options for configuring `twiggy`.
#[derive(Clone, Debug)]
#[derive(StructOpt)]
#[structopt(about = "\n`twiggy` is a code size profiler.\n\nIt analyzes a binary's call graph to answer questions like:\n\n* Why was this function included in the binary in the first place?\n\n* What is the retained size of this function? I.e. how much space\n  would be saved if I removed it and all the functions that become\n  dead code after its removal.\n\nUse `twiggy` to make your binaries slim!")]
pub enum Options {
    /// List the top code size offenders in a binary.
    #[structopt(name = "top")]
    Top(Top),

    /// Compute and display the dominator tree for a binary's call graph.
    #[structopt(name = "dominators")]
    Dominators(Dominators),

    /// Find and display the call paths to a function in the given binary's call
    /// graph.
    #[structopt(name = "paths")]
    Paths(Paths),

    /// List the generic function monomorphizations that are contributing to
    /// code bloat.
    #[structopt(name = "monos")]
    Monos(Monos),

    /// Diff the old and new versions of a binary to see what sizes changed.
    #[structopt(name = "diff")]
    Diff(Diff),

    /// Find and display code and data that is not transitively referenced by
    /// any exports or public functions.
    #[structopt(name = "garbage")]
    Garbage(Garbage),
}

/// List the top code size offenders in a binary.
#[wasm_bindgen]
#[derive(Clone, Debug)]
#[derive(StructOpt)]
pub struct Top {
    /// The path to the input binary to size profile.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    input: path::PathBuf,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// The maximum number of items to display.
    #[structopt(short = "n", default_value = "4294967295")]
    max_items: u32,

    /// Display retaining paths.
    #[structopt(short = "r", long = "retaining-paths")]
    retaining_paths: bool,

    /// Sort list by retained size, rather than shallow size.
    #[structopt(long = "retained")]
    retained: bool,
}

impl Default for Top {
    fn default() -> Top {
        Top {
            #[cfg(feature = "cli")]
            input: Default::default(),
            #[cfg(feature = "cli")]
            parse_mode: Default::default(),
            #[cfg(feature = "cli")]
            output_destination: Default::default(),
            #[cfg(feature = "cli")]
            output_format: Default::default(),

            max_items: 4_294_967_295,
            retaining_paths: false,
            retained: false,
        }
    }
}

#[wasm_bindgen]
impl Top {
    /// Construct a new, default `Top`.
    pub fn new() -> Top {
        Top::default()
    }

    /// The maximum number of items to display.
    pub fn max_items(&self) -> u32 {
        self.max_items
    }

    /// Display retaining paths.
    pub fn retaining_paths(&self) -> bool {
        self.retaining_paths
    }

    /// Sort list by retained size, rather than shallow size.
    pub fn retained(&self) -> bool {
        self.retained
    }

    /// Set the maximum number of items to display.
    pub fn set_max_items(&mut self, n: u32) {
        self.max_items = n;
    }

    /// Set whether to display and compute retaining paths.
    pub fn set_retaining_paths(&mut self, do_it: bool) {
        self.retaining_paths = do_it;
    }

    /// Set whether to sort list by retained size, rather than shallow size.
    pub fn set_retained(&mut self, do_it: bool) {
        self.retained = do_it;
    }
}

/// Compute and display the dominator tree for a binary's call graph.
#[wasm_bindgen]
#[derive(Clone, Debug, Default)]
#[derive(StructOpt)]
pub struct Dominators {
    /// The path to the input binary to size profile.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    input: path::PathBuf,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// The name of the function whose dominator subtree should be printed.
    items: Vec<String>,

    /// The maximum depth to print the dominators tree.
    #[structopt(short = "d")]
    max_depth: Option<u32>,

    /// The maximum number of rows, regardless of depth in the tree, to display.
    #[structopt(short = "r")]
    max_rows: Option<u32>,

    /// Whether or not `items` should be treated as regular expressions.
    #[structopt(long = "regex")]
    using_regexps: bool,
}

impl Dominators {
    // TODO: wasm-bindgen does not support sending Vec<String> across
    // the wasm ABI boundary yet.

    /// The items whose dominators subtree should be printed.
    pub fn items(&self) -> &[String] {
        &self.items
    }
}

#[wasm_bindgen]
impl Dominators {
    /// Construct a new, default `Dominators`.
    pub fn new() -> Dominators {
        Dominators::default()
    }

    /// The maximum depth to print the dominators tree.
    pub fn max_depth(&self) -> u32 {
        self.max_depth.unwrap_or(u32::MAX)
    }

    /// The maximum number of rows, regardless of depth in the tree, to display.
    pub fn max_rows(&self) -> u32 {
        self.max_rows.unwrap_or(u32::MAX)
    }

    /// Whether or not `items` should be treated as regular expressions.
    pub fn using_regexps(&self) -> bool {
        self.using_regexps
    }

    /// Set the maximum depth to print the dominators tree.
    pub fn set_max_depth(&mut self, max_depth: u32) {
        self.max_depth = Some(max_depth);
    }

    /// Set the maximum number of rows, regardless of depth in the tree, to display.
    pub fn set_max_rows(&mut self, max_rows: u32) {
        self.max_rows = Some(max_rows);
    }

    /// Set whether or not `items` should be treated as regular expressions.
    pub fn set_using_regexps(&mut self, using_regexps: bool) {
        self.using_regexps = using_regexps;
    }
}

/// Find and display the call paths to a function in the given binary's call
/// graph.
#[wasm_bindgen]
#[derive(Clone, Debug)]
#[derive(StructOpt)]
pub struct Paths {
    /// The path to the input binary to size profile.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    input: path::PathBuf,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// The functions to find call paths to.
    functions: Vec<String>,

    /// The maximum depth to print the paths.
    #[structopt(short = "d", default_value = "10")]
    max_depth: u32,

    /// The maximum number of paths, regardless of depth in the tree, to display.
    #[structopt(short = "r", default_value = "10")]
    max_paths: u32,

    /// This direction of the path traversal.
    #[structopt(long = "descending")]
    descending: bool,

    /// Whether or not `functions` should be treated as regular expressions.
    #[structopt(long = "regex")]
    using_regexps: bool,
}

impl Default for Paths {
    fn default() -> Paths {
        Paths {
            #[cfg(feature = "cli")]
            input: Default::default(),
            #[cfg(feature = "cli")]
            parse_mode: Default::default(),
            #[cfg(feature = "cli")]
            output_destination: Default::default(),
            #[cfg(feature = "cli")]
            output_format: Default::default(),

            functions: Default::default(),
            max_depth: 10,
            max_paths: 10,
            descending: false,
            using_regexps: false,
        }
    }
}

impl Paths {
    // TODO: wasm-bindgen doesn't support sending Vec<String> across the wasm
    // ABI boundary yet.

    /// The functions to find call paths to.
    pub fn functions(&self) -> &[String] {
        &self.functions
    }
}

#[wasm_bindgen]
impl Paths {
    /// Construct a new, default `Paths`.
    pub fn new() -> Paths {
        Paths::default()
    }

    /// Add a function to find call paths for.
    pub fn add_function(&mut self, function: String) {
        self.functions.push(function);
    }

    /// The maximum depth to print the paths.
    pub fn max_depth(&self) -> u32 {
        self.max_depth
    }

    /// The maximum number of paths, regardless of depth in the tree, to display.
    pub fn max_paths(&self) -> u32 {
        self.max_paths
    }

    /// The direction in which the call paths are traversed.
    pub fn descending(&self) -> bool {
        self.descending
    }

    /// Whether or not `functions` should be treated as regular expressions.
    pub fn using_regexps(&self) -> bool {
        self.using_regexps
    }

    /// Set the maximum depth to print the paths.
    pub fn set_max_depth(&mut self, max_depth: u32) {
        self.max_depth = max_depth;
    }

    /// Set the maximum number of paths, regardless of depth in the tree, to display.
    pub fn set_max_paths(&mut self, max_paths: u32) {
        self.max_paths = max_paths;
    }

    /// Set the call path traversal direction.
    pub fn set_descending(&mut self, descending: bool) {
        self.descending = descending;
    }

    /// Set Whether or not `functions` should be treated as regular expressions.
    pub fn set_using_regexps(&mut self, using_regexps: bool) {
        self.using_regexps = using_regexps;
    }
}

/// List the generic function monomorphizations that are contributing to
/// code bloat.
#[wasm_bindgen]
#[derive(Clone, Debug)]
#[derive(StructOpt)]
pub struct Monos {
    /// The path to the input binary to size profile.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    input: path::PathBuf,

    /// The names of the generic functions whose monomorphizations
    /// should be printed.
    functions: Vec<String>,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(short = "d", long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// Hide individual monomorphizations and only show the generic functions.
    #[structopt(short = "g", long = "only-generics")]
    only_generics: bool,

    /// The maximum number of generics to list.
    #[structopt(short = "m", long = "max-generics", default_value = "10")]
    max_generics: u32,

    /// The maximum number of individual monomorphizations to list for each
    /// listed generic function.
    #[structopt(short = "n", long = "max-monos", default_value = "10")]
    max_monos: u32,

    /// List all generics and all of their individual monomorphizations.
    /// If combined with -g then monomorphizations are hidden.
    /// Overrides -m <max_generics> and -n <max_monos>
    #[structopt(short = "a", long = "all")]
    all_generics_and_monos: bool,

    /// List all generics. Overrides -m <max_generics>
    #[structopt(long = "all-generics")]
    all_generics: bool,

    /// List all individual monomorphizations for each listed generic
    /// function. Overrides -n <max_monos>
    #[structopt(long = "all-monos")]
    all_monos: bool,

    /// Whether or not `names` should be treated as regular expressions.
    #[structopt(long = "regex")]
    using_regexps: bool,
}

impl Default for Monos {
    fn default() -> Monos {
        Monos {
            #[cfg(feature = "cli")]
            input: Default::default(),
            #[cfg(feature = "cli")]
            parse_mode: Default::default(),
            #[cfg(feature = "cli")]
            output_destination: Default::default(),
            #[cfg(feature = "cli")]
            output_format: Default::default(),

            functions: Default::default(),

            only_generics: false,
            max_generics: 10,
            max_monos: 10,

            all_generics_and_monos: false,
            all_generics: false,
            all_monos: false,

            using_regexps: false,
        }
    }
}

impl Monos {
    // TODO: wasm-bindgen doesn't support sending Vec<String> across the wasm
    // ABI boundary yet.

    /// The functions to find call paths to.
    pub fn functions(&self) -> &[String] {
        &self.functions
    }
}

#[wasm_bindgen]
impl Monos {
    /// Construct a new, default `Monos`.
    pub fn new() -> Monos {
        Monos::default()
    }

    /// Hide individual monomorphizations and only show the generic functions.
    pub fn only_generics(&self) -> bool {
        self.only_generics
    }

    /// The maximum number of generics to list.
    pub fn max_generics(&self) -> u32 {
        if self.all_generics_and_monos || self.all_generics {
            u32::MAX
        } else {
            self.max_generics
        }
    }

    /// The maximum number of individual monomorphizations to list for each
    /// generic function.
    pub fn max_monos(&self) -> u32 {
        if self.all_generics_and_monos || self.all_monos {
            u32::MAX
        } else {
            self.max_monos
        }
    }

    /// Whether or not `functions` should be treated as regular expressions.
    pub fn using_regexps(&self) -> bool {
        self.using_regexps
    }

    /// Set whether to hide individual monomorphizations and only show the
    /// generic functions.
    pub fn set_only_generics(&mut self, do_it: bool) {
        self.only_generics = do_it;
    }

    /// Set the maximum number of generics to list.
    pub fn set_max_generics(&mut self, max: u32) {
        self.max_generics = max;
        self.all_generics = false;
        if self.all_generics_and_monos {
            self.all_generics_and_monos = false;
            self.all_monos = true;
        }
    }

    /// Set the maximum number of individual monomorphizations to list for each
    /// generic function.
    pub fn set_max_monos(&mut self, max: u32) {
        self.max_monos = max;
        self.all_monos = false;
        if self.all_generics_and_monos {
            self.all_generics_and_monos = false;
            self.all_generics = true;
        }
    }
}

/// Diff the old and new versions of a binary to see what sizes changed.
#[wasm_bindgen]
#[derive(Clone, Debug)]
#[derive(StructOpt)]
pub struct Diff {
    /// The path to the old version of the input binary.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    old_input: path::PathBuf,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The path to the new version of the input binary.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    new_input: path::PathBuf,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// The name of the item(s) whose diff should be printed.
    items: Vec<String>,

    /// The maximum number of items to display.
    #[structopt(short = "n", default_value = "20")]
    max_items: u32,

    /// Whether or not `items` should be treated as regular expressions.
    #[structopt(long = "regex")]
    using_regexps: bool,

    /// Displays all items. Overrides -n <max_items>
    #[structopt(short = "a", long = "all")]
    all_items: bool,
}

impl Default for Diff {
    fn default() -> Diff {
        Diff {
            #[cfg(feature = "cli")]
            old_input: Default::default(),
            #[cfg(feature = "cli")]
            parse_mode: Default::default(),
            #[cfg(feature = "cli")]
            new_input: Default::default(),
            #[cfg(feature = "cli")]
            output_destination: Default::default(),
            #[cfg(feature = "cli")]
            output_format: Default::default(),

            items: Default::default(),
            max_items: 20,
            using_regexps: false,
            all_items: false,
        }
    }
}

impl Diff {
    // TODO: wasm-bindgen does not support sending Vec<String> across
    // the wasm ABI boundary yet.

    /// The items whose dominators subtree should be printed.
    pub fn items(&self) -> &[String] {
        &self.items
    }
}

#[wasm_bindgen]
impl Diff {
    /// The maximum number of items to display.
    pub fn max_items(&self) -> u32 {
        if self.all_items {
            u32::MAX
        } else {
            self.max_items
        }
    }

    /// Whether or not `items` should be treated as regular expressions.
    pub fn using_regexps(&self) -> bool {
        self.using_regexps
    }

    /// Set the maximum number of items to display.
    pub fn set_max_items(&mut self, n: u32) {
        self.max_items = n;
        self.all_items = false;
    }

    /// Set whether or not `items` should be treated as regular expressions.
    pub fn set_using_regexps(&mut self, using_regexps: bool) {
        self.using_regexps = using_regexps;
    }
}

/// Find and display code and data that is not transitively referenced by any
/// exports or public functions.
#[wasm_bindgen]
#[derive(Clone, Debug)]
#[derive(StructOpt)]
pub struct Garbage {
    /// The path to the input binary to size profile.
    #[cfg(feature = "cli")]
    #[structopt(parse(from_os_str))]
    input: path::PathBuf,

    /// The parse mode for the input binary data.
    #[cfg(feature = "cli")]
    #[structopt(long = "mode", default_value = "auto")]
    parse_mode: traits::ParseMode,

    /// The destination to write the output to. Defaults to `stdout`.
    #[cfg(feature = "cli")]
    #[structopt(short = "o", default_value = "-")]
    output_destination: OutputDestination,

    /// The format the output should be written in.
    #[cfg(feature = "cli")]
    #[structopt(short = "f", long = "format", default_value = "text")]
    output_format: traits::OutputFormat,

    /// The maximum number of items to display.
    #[structopt(short = "n", default_value = "10")]
    max_items: u32,

    /// Display all items. Overrides -n <max_items>
    #[structopt(short = "a", long = "all")]
    all_items: bool,

    /// Show data segments rather than summarizing them in a single line.
    #[structopt(long = "show-data-segments")]
    show_data_segments: bool,
}

impl Default for Garbage {
    fn default() -> Garbage {
        Garbage {
            #[cfg(feature = "cli")]
            input: Default::default(),
            #[cfg(feature = "cli")]
            parse_mode: Default::default(),
            #[cfg(feature = "cli")]
            output_destination: Default::default(),
            #[cfg(feature = "cli")]
            output_format: Default::default(),

            max_items: 10,
            all_items: false,
            show_data_segments: false,
        }
    }
}

#[wasm_bindgen]
impl Garbage {
    /// Construct a new, default `Garbage`
    pub fn new() -> Garbage {
        Garbage::default()
    }

    /// The maximum number of items to display.
    pub fn max_items(&self) -> u32 {
        if self.all_items {
            u32::MAX
        } else {
            self.max_items
        }
    }

    /// Set the maximum number of items to display.
    pub fn set_max_items(&mut self, max: u32) {
        self.max_items = max;
        self.all_items = false;
    }

    /// Should data segments be shown normally or summarized in a single line?
    pub fn show_data_segments(&self) -> bool {
        self.show_data_segments
    }
}

'''
'''--- opt/opt.rs ---
//! Options for running `twiggy`.

#![deny(missing_debug_implementations)]

use cfg_if::cfg_if;
use twiggy_traits as traits;

cfg_if! {
    if #[cfg(feature = "cli")] {
        include!(concat!(env!("OUT_DIR"), "/cli.rs"));
    } else if #[cfg(feature = "wasm")] {
        use wasm_bindgen::prelude::*;
        include!(concat!(env!("OUT_DIR"), "/wasm.rs"));
    } else {
        compile_error!("Must enable one of either `cli` or `wasm` features");
    }
}

use std::u32;

cfg_if! {
    if #[cfg(feature = "cli")] {
        use std::fs;
        use std::io;
        use std::path;
        use std::str::FromStr;

        /// Options that are common to all commands.
        pub trait CommonCliOptions {
            /// Get the input file path.
            fn input(&self) -> &path::Path;

            /// Get the input data parse mode.
            fn parse_mode(&self) -> traits::ParseMode;

            /// Get the output destination.
            fn output_destination(&self) -> &OutputDestination;

            /// Get the output format.
            fn output_format(&self) -> traits::OutputFormat;
        }

        impl CommonCliOptions for Options {
            fn input(&self) -> &path::Path {
                match *self {
                    Options::Top(ref top) => top.input(),
                    Options::Dominators(ref doms) => doms.input(),
                    Options::Paths(ref paths) => paths.input(),
                    Options::Monos(ref monos) => monos.input(),
                    Options::Diff(ref diff) => diff.input(),
                    Options::Garbage(ref garbo) => garbo.input(),
                }
            }

            fn parse_mode(&self) -> traits::ParseMode {
                match *self {
                    Options::Top(ref top) => top.parse_mode(),
                    Options::Dominators(ref doms) => doms.parse_mode(),
                    Options::Paths(ref paths) => paths.parse_mode(),
                    Options::Monos(ref monos) => monos.parse_mode(),
                    Options::Diff(ref diff) => diff.parse_mode(),
                    Options::Garbage(ref garbo) => garbo.parse_mode(),
                }
            }

            fn output_destination(&self) -> &OutputDestination {
                match *self {
                    Options::Top(ref top) => top.output_destination(),
                    Options::Dominators(ref doms) => doms.output_destination(),
                    Options::Paths(ref paths) => paths.output_destination(),
                    Options::Monos(ref monos) => monos.output_destination(),
                    Options::Diff(ref diff) => diff.output_destination(),
                    Options::Garbage(ref garbo) => garbo.output_destination(),
                }
            }

            fn output_format(&self) -> traits::OutputFormat {
                match *self {
                    Options::Top(ref top) => top.output_format(),
                    Options::Dominators(ref doms) => doms.output_format(),
                    Options::Paths(ref paths) => paths.output_format(),
                    Options::Monos(ref monos) => monos.output_format(),
                    Options::Diff(ref diff) => diff.output_format(),
                    Options::Garbage(ref garbo) => garbo.output_format(),
                }
            }
        }

        impl CommonCliOptions for Top {
            fn input(&self) -> &path::Path {
                &self.input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        impl CommonCliOptions for Dominators {
            fn input(&self) -> &path::Path {
                &self.input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        impl CommonCliOptions for Paths {
            fn input(&self) -> &path::Path {
                &self.input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        impl CommonCliOptions for Monos {
            fn input(&self) -> &path::Path {
                &self.input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        impl CommonCliOptions for Diff {
            fn input(&self) -> &path::Path {
                &self.old_input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        impl Diff {
            /// The path to the new version of the input binary.
            pub fn new_input(&self) -> &path::Path {
                &self.new_input
            }
        }

        impl CommonCliOptions for Garbage {
            fn input(&self) -> &path::Path {
                &self.input
            }

            fn parse_mode(&self) -> traits::ParseMode {
                self.parse_mode
            }

            fn output_destination(&self) -> &OutputDestination {
                &self.output_destination
            }

            fn output_format(&self) -> traits::OutputFormat {
                self.output_format
            }
        }

        /// Where to output results.
        #[derive(Clone, Debug)]
        pub enum OutputDestination {
            /// Emit the results to `stdout`.
            Stdout,

            /// Write the results to a file at the given path.
            Path(path::PathBuf),
        }

        impl Default for OutputDestination {
            fn default() -> OutputDestination {
                OutputDestination::Stdout
            }
        }

        impl FromStr for OutputDestination {
            type Err = traits::Error;

            fn from_str(s: &str) -> Result<Self, traits::Error> {
                if s == "-" {
                    Ok(OutputDestination::Stdout)
                } else {
                    let path = path::PathBuf::from(s.to_string());
                    Ok(OutputDestination::Path(path))
                }
            }
        }

        impl OutputDestination {
            /// Open the output destination as an `io::Write`.
            pub fn open(&self) -> Result<Box<dyn io::Write>, traits::Error> {
                Ok(match *self {
                    OutputDestination::Path(ref path) => {
                        Box::new(io::BufWriter::new(fs::File::create(path)?)) as Box<_>
                    }
                    OutputDestination::Stdout => Box::new(io::stdout()) as Box<_>,
                })
            }
        }
    }
}

'''
'''--- parser/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = []
description = "Common traits for the Twiggy code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy-parser"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[lib]
path = "./parser.rs"

[dependencies]
fallible-iterator = { version = "0.2.0", optional = true }
gimli = { version = "0.22.0", optional = true, default-features = false, features = ["std", "read"] }
object = { version = "0.17.0", optional = true }
wasmparser = "0.35.3"
typed-arena = { version = "2.0.1", optional = true }
twiggy-ir = { version = "=0.6.0", path = "../ir" }
twiggy-traits = { version = "=0.6.0", path = "../traits" }

[features]
default = ["dwarf"]
dwarf = ["fallible-iterator", "gimli", "object", "typed-arena", "twiggy-traits/dwarf"]

'''
'''--- parser/object_parse/compilation_unit_parse/mod.rs ---
use gimli;
use twiggy_ir as ir;
use twiggy_traits as traits;

use super::die_parse;

pub(super) fn parse_items<R: gimli::Reader>(
    items: &mut ir::ItemsBuilder,
    dwarf: &gimli::Dwarf<R>,
    unit: &gimli::Unit<R>,
    unit_id: usize,
) -> Result<(), traits::Error> {
    // Initialize an entry ID counter.
    let mut entry_id = 0;

    // Create an entries cursor, and move it to the root.
    let mut die_cursor = unit.entries();

    if die_cursor.next_dfs()?.is_none() {
        let e = traits::Error::with_msg(
            "Unexpected error while traversing debugging information entries.",
        );
        return Err(e);
    }

    // Parse the contained debugging information entries in depth-first order.
    let mut depth = 0;
    while let Some((delta, entry)) = die_cursor.next_dfs()? {
        // Update depth value, and break out of the loop when we
        // return to the original starting position.
        depth += delta;
        if depth <= 0 {
            break;
        }

        die_parse::parse_items(items, dwarf, unit, unit_id, entry, entry_id)?;
        entry_id += 1;
    }

    Ok(())
}

pub(super) fn parse_edges<R: gimli::Reader>(
    items: &mut ir::ItemsBuilder,
    unit: &gimli::Unit<R>,
    unit_id: usize,
) -> Result<(), traits::Error> {
    // Initialize an entry ID counter.
    let mut entry_id = 0;

    // Create an entries cursor, and move it to the root.
    let mut die_cursor = unit.entries();

    if die_cursor.next_dfs()?.is_none() {
        let e = traits::Error::with_msg(
            "Unexpected error while traversing debugging information entries.",
        );
        return Err(e);
    }

    // Parse the contained debugging information entries in depth-first order.
    let mut depth = 0;
    while let Some((delta, entry)) = die_cursor.next_dfs()? {
        // Update depth value, and break out of the loop when we
        // return to the original starting position.
        depth += delta;
        if depth <= 0 {
            break;
        }

        let _ir_id = ir::Id::entry(unit_id, entry_id);
        die_parse::parse_edges(items, entry)?;
        entry_id += 1;
    }

    Ok(())
}

'''
'''--- parser/object_parse/die_parse/item_name.rs ---
use gimli;
use twiggy_traits as traits;

use super::FallilbleOption;

/// Calculate the item's name. If no name was assigned, a name will be
/// decided elsewhere using the `ir::ItemKind` variant that was determined
/// for the entity.
///
/// For more information on identifier names and linkage names, refer to
/// Section 2.15 and Section 2.22 of the DWARF v5 specification, respectively.
///
/// > _"Any debugging information entry representing a program entity that
/// > has been given a name may have a DW_AT_name attribute, whose value
/// > is a string representing the name as it appears in the source program."_
///
/// - DWARF v5 Spec. Section 2.15
///
/// > _"A debugging information entry may have a DW_AT_linkage_name attribute
/// > whose value is a null-terminated string describing the object file
/// > linkage name associated with the corresponding entity."_
///
/// -- DWARF v5 Spec. Section 2.22
pub fn item_name<R>(
    die: &gimli::DebuggingInformationEntry<R, R::Offset>,
    dwarf: &gimli::Dwarf<R>,
    unit: &gimli::Unit<R>,
) -> FallilbleOption<String>
where
    R: gimli::Reader,
{
    let attr: Option<gimli::read::AttributeValue<R>> =
        match die.attr_value(gimli::DW_AT_linkage_name)? {
            x @ Some(_) => x,
            None => die.attr_value(gimli::DW_AT_name)?,
        };
    attr.map(|attr| -> Result<String, traits::Error> {
        Ok(
            dwarf
                .attr_string(unit, attr)?
                .to_string()? // This `to_string()` creates a `Result<Cow<'_, str>, _>`.
                .to_string(), // This `to_string()` creates the String we return.
        )
    })
    .transpose()
}

'''
'''--- parser/object_parse/die_parse/location_attrs.rs ---
use fallible_iterator::FallibleIterator;
use gimli;
use twiggy_traits as traits;

use super::FallilbleOption;

/// This struct holds the values for DWARF attributes related to an object's
/// location in a binary. This is intended to help consolidate the error
/// checking involved in reading attributes, and simplify the process of
/// size calculations for the entity that a debugging information entry (DIE)
/// describes.
///
/// For more information about these attributes, refer to Chapter 2.17 'Code
/// Addresses, Ranges, and Base Addresses' (pg. 51) in the DWARF5 specification.
pub struct DieLocationAttributes<R: gimli::Reader> {
    dw_at_low_pc: Option<gimli::AttributeValue<R, R::Offset>>,
    dw_at_high_pc: Option<gimli::AttributeValue<R, R::Offset>>,
    dw_at_ranges: Option<gimli::AttributeValue<R, R::Offset>>,
}

impl<R: gimli::Reader> DieLocationAttributes<R> {
    /// Try to create a new location attributes instance using the given
    /// debugging information entry (DIE). Reading these attributes may fail,
    /// so this will return a Result rather than a plain `Self`.
    /// TODO: Use the TryFrom trait once it is stable.
    pub fn try_from(
        die: &gimli::DebuggingInformationEntry<R, R::Offset>,
    ) -> Result<Self, traits::Error> {
        Ok(Self {
            dw_at_low_pc: die.attr_value(gimli::DW_AT_low_pc)?,
            dw_at_high_pc: die.attr_value(gimli::DW_AT_high_pc)?,
            dw_at_ranges: die.attr_value(gimli::DW_AT_ranges)?,
        })
    }

    /// Compute the size of a subprogram described by this DIE.
    pub fn entity_size(
        &self,
        dwarf: &gimli::Dwarf<R>,
        unit: &gimli::Unit<R>,
    ) -> FallilbleOption<u64> {
        if let Some(size) = self.contiguous_entity_size()? {
            Ok(Some(size))
        } else if let Some(size) = self.noncontiguous_entity_size(dwarf, unit)? {
            Ok(Some(size))
        } else {
            Ok(None)
        }
    }

    /// Compute the size of an entity occupying a contiguous range of machine
    /// code addresses in the binary.
    fn contiguous_entity_size(&self) -> FallilbleOption<u64> {
        let dw_at_low_pc: Option<u64> = self.dw_at_low_pc()?;
        match (dw_at_low_pc, &self.dw_at_high_pc) {
            // If DW_AT_high_pc is encoded as an address, return the difference
            // between that value and the DW_AT_low_pc address.
            (Some(low_pc), Some(gimli::AttributeValue::Addr(high_pc))) => {
                Ok(Some(high_pc - low_pc))
            }
            // DWARF 4 allows the DW_AT_high_pc to be encoded as an offset from the
            // address in DW_AT_low_pc. If so, return the offset as the contiguous size.
            (Some(_), Some(gimli::AttributeValue::Udata(offset))) => Ok(Some(*offset)),
            // Return an error if DW_AT_high_pc is not encoded as expected.
            (Some(_), Some(_)) => Err(traits::Error::with_msg(
                "Unexpected DW_AT_high_pc attribute value",
            )),
            // If none of the above conditions were met, this is either a
            // noncontiguous entity, or the DIE does not represent a defintion.
            _ => Ok(None),
        }
    }

    /// Compute the size of an entity occupying a series of non-contigous
    /// ranges of machine code addresses in the binary.
    fn noncontiguous_entity_size(
        &self,
        dwarf: &gimli::Dwarf<R>,
        unit: &gimli::Unit<R>,
    ) -> FallilbleOption<u64> {
        if let Some(offset) = self.dw_at_ranges()? {
            let ranges = dwarf.ranges(unit, offset)?;
            let size = ranges
                .map(|r| Ok(r.end - r.begin))
                .fold(0, |res, size| Ok(res + size))?;
            Ok(Some(size))
        } else {
            Ok(None)
        }
    }

    /// Return the DW_AT_low_pc attribute as a u64 value representing an address.
    fn dw_at_low_pc(&self) -> FallilbleOption<u64> {
        match &self.dw_at_low_pc {
            Some(gimli::AttributeValue::Addr(address)) => Ok(Some(*address)),
            Some(_) => Err(traits::Error::with_msg(
                "Unexpected base address attribute value",
            )),
            None => Ok(None),
        }
    }

    /// Return the DW_AT_ranges attribute as a u64 value representing an offset
    /// into the `.debug_ranges` section of the file.
    fn dw_at_ranges(
        &self,
    ) -> FallilbleOption<gimli::RangeListsOffset<<R as gimli::Reader>::Offset>> {
        match &self.dw_at_ranges {
            Some(gimli::AttributeValue::RangeListsRef(offset)) => Ok(Some(*offset)),
            Some(_) => Err(traits::Error::with_msg("Unexpected DW_AT_ranges value")),
            None => Ok(None),
        }
    }
}

'''
'''--- parser/object_parse/die_parse/mod.rs ---
use gimli;
use twiggy_ir as ir;
use twiggy_traits as traits;

mod item_name;
mod location_attrs;

use self::item_name::item_name;
use self::location_attrs::DieLocationAttributes;

/// This type alias is used to represent an option return value for
/// a procedure that could return an Error.
type FallilbleOption<T> = Result<Option<T>, traits::Error>;

pub(super) fn parse_items<R: gimli::Reader>(
    items: &mut ir::ItemsBuilder,
    dwarf: &gimli::Dwarf<R>,
    unit: &gimli::Unit<R>,
    unit_id: usize,
    entry: &gimli::DebuggingInformationEntry<R>,
    entry_id: usize,
) -> Result<(), traits::Error> {
    let item: ir::Item = match entry.tag() {
        gimli::DW_TAG_subprogram => {
            if let Some(size) = DieLocationAttributes::try_from(entry)?.entity_size(dwarf, unit)? {
                let id = ir::Id::entry(unit_id, entry_id);
                let name = item_name(entry, dwarf, unit)?
                    .unwrap_or_else(|| format!("Subroutine[{}][{}]", unit_id, entry_id));
                let kind: ir::ItemKind = ir::Code::new(&name).into();
                ir::Item::new(id, name, size as u32, kind)
            } else {
                return Ok(());
            }
        }
        _ => return Ok(()),
    };

    items.add_item(item);
    Ok(())
}

pub(super) fn parse_edges<R: gimli::Reader>(
    _items: &mut ir::ItemsBuilder,
    _entry: &gimli::DebuggingInformationEntry<R>,
) -> Result<(), traits::Error> {
    // TODO: Add edges representing the call graph.
    Ok(())
}

'''
'''--- parser/object_parse/mod.rs ---
use std::borrow::{Borrow, Cow};

use fallible_iterator::FallibleIterator;
use gimli;
use object::{self, Object};
use twiggy_ir as ir;
use twiggy_traits as traits;
use typed_arena::Arena;

mod compilation_unit_parse;
mod die_parse;

// Helper function used to load a given section of the file.
fn load_section<'a, 'file, 'input, Sect, Endian>(
    arena: &'a Arena<Cow<'file, [u8]>>,
    file: &'file object::File<'input>,
    endian: Endian,
) -> Sect
where
    Sect: gimli::Section<gimli::EndianSlice<'a, Endian>>,
    Endian: gimli::Endianity,
    'file: 'input,
    'a: 'file,
{
    let data = file
        .section_data_by_name(Sect::section_name())
        .unwrap_or(Cow::Borrowed(&[]));
    let data_ref = (*arena.alloc(data)).borrow();
    Sect::from(gimli::EndianSlice::new(data_ref, endian))
}

pub fn parse(items: &mut ir::ItemsBuilder, data: &[u8]) -> Result<(), traits::Error> {
    let file: object::File = object::File::parse(data)?;

    // Identify the file's endianty and create a typed arena to load sections.
    let arena = Arena::new();
    let endian = if file.is_little_endian() {
        gimli::RunTimeEndian::Little
    } else {
        gimli::RunTimeEndian::Big
    };

    // Load the sections of the file containing debugging information.
    let debug_abbrev: gimli::DebugAbbrev<_> = load_section(&arena, &file, endian);
    let debug_addr: gimli::DebugAddr<_> = load_section(&arena, &file, endian);
    let debug_info: gimli::DebugInfo<_> = load_section(&arena, &file, endian);
    let debug_line: gimli::DebugLine<_> = load_section(&arena, &file, endian);
    let debug_line_str: gimli::DebugLineStr<_> = load_section(&arena, &file, endian);
    let debug_str: gimli::DebugStr<_> = load_section(&arena, &file, endian);
    let debug_str_offsets: gimli::DebugStrOffsets<_> = load_section(&arena, &file, endian);
    let debug_ranges: gimli::DebugRanges<_> = load_section(&arena, &file, endian);
    let debug_rnglists: gimli::DebugRngLists<_> = load_section(&arena, &file, endian);
    let ranges = gimli::RangeLists::new(debug_ranges, debug_rnglists);
    let dwarf = gimli::Dwarf {
        debug_abbrev,
        debug_addr,
        debug_info,
        debug_line,
        debug_line_str,
        debug_str,
        debug_str_offsets,
        ranges,
        ..Default::default()
    };

    parse_items(items, &dwarf)?;
    parse_edges(items, &dwarf)?;
    Ok(())
}

fn parse_items<R: gimli::Reader>(
    items: &mut ir::ItemsBuilder,
    dwarf: &gimli::Dwarf<R>,
) -> Result<(), traits::Error> {
    // Parse the items in each compilation unit.
    let mut headers = dwarf.units().enumerate();
    while let Some((unit_id, header)) = headers.next()? {
        let unit = dwarf.unit(header)?;
        compilation_unit_parse::parse_items(items, dwarf, &unit, unit_id)?
    }

    Ok(())
}

fn parse_edges<R: gimli::Reader>(
    items: &mut ir::ItemsBuilder,
    dwarf: &gimli::Dwarf<R>,
) -> Result<(), traits::Error> {
    // Parse the edges in each compilation unit.
    let mut headers = dwarf.units().enumerate();
    while let Some((unit_id, header)) = headers.next()? {
        let unit = dwarf.unit(header)?;
        compilation_unit_parse::parse_edges(items, &unit, unit_id)?
    }

    Ok(())
}

'''
'''--- parser/parser.rs ---
//! Parses binaries into `twiggy_ir::Items`.

#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

use std::ffi::OsStr;
use std::fs;
use std::io::Read;
use std::path;

use twiggy_ir as ir;
use twiggy_traits as traits;

#[cfg(feature = "dwarf")]
mod object_parse;
mod wasm_parse;

const WASM_MAGIC_NUMBER: [u8; 4] = [0x00, 0x61, 0x73, 0x6D];

/// Parse the file at the given path into IR items.
pub fn read_and_parse<P: AsRef<path::Path>>(
    path: P,
    mode: traits::ParseMode,
) -> Result<ir::Items, traits::Error> {
    let path = path.as_ref();
    let mut file = fs::File::open(path)?;
    let mut data = vec![];
    file.read_to_end(&mut data)?;

    match mode {
        traits::ParseMode::Wasm => parse_wasm(&data),
        #[cfg(feature = "dwarf")]
        traits::ParseMode::Dwarf => parse_other(&data),
        traits::ParseMode::Auto => parse_auto(path.extension(), &data),
    }
}

/// Parse the given data into IR items.
pub fn parse(data: &[u8]) -> Result<ir::Items, traits::Error> {
    parse_fallback(data)
}

/// A trait for parsing things into `ir::Item`s.
pub(crate) trait Parse<'a> {
    /// Any extra data needed to parse this type's items.
    type ItemsExtra;

    /// Parse `Self` into one or more `ir::Item`s and add them to the builder.
    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        extra: Self::ItemsExtra,
    ) -> Result<(), traits::Error>;

    /// Any extra data needed to parse this type's edges.
    type EdgesExtra;

    /// Parse edges between items. This is only called *after* we have already
    /// parsed items.
    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        extra: Self::EdgesExtra,
    ) -> Result<(), traits::Error>;
}

fn parse_auto(extension: Option<&OsStr>, data: &[u8]) -> Result<ir::Items, traits::Error> {
    if sniff_wasm(extension, &data) {
        parse_wasm(&data)
    } else {
        #[cfg(feature = "dwarf")]
        let res = parse_other(&data);
        #[cfg(not(feature = "dwarf"))]
        let res = parse_fallback(&data);
        res
    }
}

fn sniff_wasm(extension: Option<&OsStr>, data: &[u8]) -> bool {
    match extension.and_then(|s| s.to_str()) {
        Some("wasm") => true,
        _ => data.get(0..4) == Some(&WASM_MAGIC_NUMBER),
    }
}

fn parse_wasm(data: &[u8]) -> Result<ir::Items, traits::Error> {
    let mut items = ir::ItemsBuilder::new(data.len() as u32);

    let mut module1 = wasmparser::ModuleReader::new(data)?;
    module1.parse_items(&mut items, ())?;
    let mut module2 = wasmparser::ModuleReader::new(data)?;
    module2.parse_edges(&mut items, ())?;

    Ok(items.finish())
}

#[cfg(feature = "dwarf")]
fn parse_other(data: &[u8]) -> Result<ir::Items, traits::Error> {
    let mut items = ir::ItemsBuilder::new(data.len() as u32);

    object_parse::parse(&mut items, data)?;

    Ok(items.finish())
}

fn parse_fallback(data: &[u8]) -> Result<ir::Items, traits::Error> {
    parse_wasm(data)
}

'''
'''--- parser/wasm_parse/mod.rs ---
use super::Parse;
use std::collections::HashMap;
use twiggy_ir::{self as ir, Id};
use twiggy_traits as traits;
use wasmparser::SectionWithLimitedItems;
use wasmparser::{self, Operator, SectionReader, Type};

#[derive(Default)]
pub struct SectionIndices {
    type_: Option<usize>,
    code: Option<usize>,
    functions: Vec<Id>,
    tables: Vec<Id>,
    memories: Vec<Id>,
    globals: Vec<Id>,
}

struct IndexedSection<'a>(usize, wasmparser::Section<'a>);

impl<'a> Parse<'a> for wasmparser::ModuleReader<'a> {
    type ItemsExtra = ();

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        _extra: (),
    ) -> Result<(), traits::Error> {
        let initial_offset = self.current_position();
        let mut sections: Vec<IndexedSection<'_>> = Vec::new();
        let mut code_section: Option<IndexedSection<'_>> = None;
        let mut function_section: Option<IndexedSection<'_>> = None;
        let mut sizes: HashMap<usize, u32> = HashMap::new();

        // The function and code sections must be handled differently, so these
        // are not placed in the same `sections` array as the rest.
        let mut idx = 0;
        while !self.eof() {
            let start = self.current_position();
            let section = self.read()?;
            let size = self.current_position() - start;
            let indexed_section = IndexedSection(idx, section);
            match indexed_section.1.code {
                wasmparser::SectionCode::Code => code_section = Some(indexed_section),
                wasmparser::SectionCode::Function => function_section = Some(indexed_section),
                _ => sections.push(indexed_section),
            };
            sizes.insert(idx, size as u32);
            idx += 1;
        }

        let sections_cnt = sections.len()
            + if code_section.is_some() { 1 } else { 0 }
            + if function_section.is_some() { 1 } else { 0 };
        let id = Id::section(sections_cnt);
        items.add_root(ir::Item::new(
            id,
            "wasm magic bytes".to_string(),
            initial_offset as u32,
            ir::Misc::new(),
        ));

        // Before we actually parse any items prepare to parse a few sections
        // below, namely the code section. When parsing the code section we want
        // to try to assign human-readable names so we need the name section, if
        // present. Additionally we need to look at the number of imported
        // functions to handle the wasm function index space correctly.
        let names = parse_names_section(&sections)?;
        let imported_functions = count_imported_functions(&sections)?;

        // Next, we parse the function and code sections together, so that we
        // can collapse corresponding entries from the code and function
        // sections into a single representative IR item.
        match (function_section, code_section) {
            (Some(function_section), Some(code_section)) => (function_section, code_section)
                .parse_items(items, (imported_functions, &names, &sizes))?,
            _ => Err(traits::Error::with_msg(
                "function or code section is missing",
            ))?,
        };

        for IndexedSection(idx, section) in sections.into_iter() {
            let start = items.size_added();
            let name = get_section_name(&section);
            match section.code {
                wasmparser::SectionCode::Custom { name, .. } => {
                    CustomSectionReader(name, section).parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Type => {
                    section.get_type_section_reader()?.parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Import => {
                    section
                        .get_import_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Table => {
                    section
                        .get_table_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Memory => {
                    section
                        .get_memory_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Global => {
                    section
                        .get_global_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Export => {
                    section
                        .get_export_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Start => {
                    StartSection(section).parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Element => {
                    section
                        .get_element_section_reader()?
                        .parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Data => {
                    section.get_data_section_reader()?.parse_items(items, idx)?;
                }
                wasmparser::SectionCode::DataCount => {
                    DataCountSection(section).parse_items(items, idx)?;
                }
                wasmparser::SectionCode::Code | wasmparser::SectionCode::Function => {
                    unreachable!("unexpected code or function section found");
                }
            };
            let id = Id::section(idx);
            let added = items.size_added() - start;
            let size = sizes
                .get(&idx)
                .ok_or_else(|| traits::Error::with_msg("Could not find section size"))?;
            assert!(added <= *size);
            items.add_root(ir::Item::new(id, name, size - added, ir::Misc::new()));
        }

        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        _extra: (),
    ) -> Result<(), traits::Error> {
        let mut sections: Vec<IndexedSection<'_>> = Vec::new();
        let mut code_section: Option<IndexedSection<'a>> = None;
        let mut function_section: Option<IndexedSection<'a>> = None;

        let mut idx = 0;
        while !self.eof() {
            let section = self.read()?;
            match section.code {
                wasmparser::SectionCode::Code => code_section = Some(IndexedSection(idx, section)),
                wasmparser::SectionCode::Function => {
                    function_section = Some(IndexedSection(idx, section))
                }
                _ => sections.push(IndexedSection(idx, section)),
            };
            idx += 1;
        }

        // Like above we do some preprocessing here before actually drawing all
        // the edges below. Here we primarily want to learn some properties of
        // the wasm module, such as what `Id` is mapped to all index spaces in
        // the wasm module. To handle that we build up all this data in
        // `SectionIndices` here as we parse all the various sections.
        let mut indices = SectionIndices::default();
        for IndexedSection(idx, section) in sections.iter() {
            match section.code {
                wasmparser::SectionCode::Type => {
                    indices.type_ = Some(*idx);
                }
                wasmparser::SectionCode::Import => {
                    let reader = section.get_import_section_reader()?;
                    for (i, import) in reader.into_iter().enumerate() {
                        let id = Id::entry(*idx, i);
                        match import?.ty {
                            wasmparser::ImportSectionEntryType::Function(_) => {
                                indices.functions.push(id);
                            }
                            wasmparser::ImportSectionEntryType::Table(_) => {
                                indices.tables.push(id);
                            }
                            wasmparser::ImportSectionEntryType::Memory(_) => {
                                indices.memories.push(id);
                            }
                            wasmparser::ImportSectionEntryType::Global(_) => {
                                indices.globals.push(id);
                            }
                        }
                    }
                }
                wasmparser::SectionCode::Global => {
                    for i in 0..section.get_global_section_reader()?.get_count() {
                        let id = Id::entry(*idx, i as usize);
                        indices.globals.push(id);
                    }
                }
                wasmparser::SectionCode::Memory => {
                    for i in 0..section.get_memory_section_reader()?.get_count() {
                        let id = Id::entry(*idx, i as usize);
                        indices.memories.push(id);
                    }
                }
                wasmparser::SectionCode::Table => {
                    for i in 0..section.get_table_section_reader()?.get_count() {
                        let id = Id::entry(*idx, i as usize);
                        indices.tables.push(id);
                    }
                }
                wasmparser::SectionCode::Code => {
                    Err(traits::Error::with_msg("unexpected code section"))?
                }
                wasmparser::SectionCode::Function => {
                    Err(traits::Error::with_msg("unexpected function section"))?
                }
                _ => {}
            }
        }
        if let (Some(IndexedSection(_, function_section)), Some(IndexedSection(code_idx, _))) =
            (function_section.as_ref(), code_section.as_ref())
        {
            indices.code = Some(*code_idx);
            for i in 0..function_section.get_function_section_reader()?.get_count() {
                let id = Id::entry(*code_idx, i as usize);
                indices.functions.push(id);
            }
        }

        match (function_section, code_section) {
            (Some(function_section), Some(code_section)) => {
                (function_section, code_section).parse_edges(items, &indices)?
            }
            _ => panic!("function or code section is missing"),
        };
        for IndexedSection(idx, section) in sections.into_iter() {
            match section.code {
                wasmparser::SectionCode::Custom { name, .. } => {
                    CustomSectionReader(name, section).parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Type => {
                    section.get_type_section_reader()?.parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Import => {
                    section
                        .get_import_section_reader()?
                        .parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Table => {
                    section.get_table_section_reader()?.parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Memory => {
                    section
                        .get_memory_section_reader()?
                        .parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Global => {
                    section
                        .get_global_section_reader()?
                        .parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Export => {
                    section
                        .get_export_section_reader()?
                        .parse_edges(items, (&indices, idx))?;
                }
                wasmparser::SectionCode::Start => {
                    StartSection(section).parse_edges(items, (&indices, idx))?;
                }
                wasmparser::SectionCode::Element => {
                    section
                        .get_element_section_reader()?
                        .parse_edges(items, (&indices, idx))?;
                }
                wasmparser::SectionCode::Data => {
                    section.get_data_section_reader()?.parse_edges(items, ())?;
                }
                wasmparser::SectionCode::DataCount => {
                    DataCountSection(section).parse_edges(items, ())?;
                }
                wasmparser::SectionCode::Code | wasmparser::SectionCode::Function => {
                    unreachable!("unexpected code or function section found");
                }
            }
        }

        Ok(())
    }
}

fn get_section_name(section: &wasmparser::Section<'_>) -> String {
    match section.code {
        wasmparser::SectionCode::Custom { name, .. } => {
            format!("custom section '{}' headers", name)
        }
        wasmparser::SectionCode::Type => "type section headers".to_string(),
        wasmparser::SectionCode::Import => "import section headers".to_string(),
        wasmparser::SectionCode::Function => "function section headers".to_string(),
        wasmparser::SectionCode::Table => "table section headers".to_string(),
        wasmparser::SectionCode::Memory => "memory section headers".to_string(),
        wasmparser::SectionCode::Global => "global section headers".to_string(),
        wasmparser::SectionCode::Export => "export section headers".to_string(),
        wasmparser::SectionCode::Start => "start section headers".to_string(),
        wasmparser::SectionCode::Element => "element section headers".to_string(),
        wasmparser::SectionCode::Code => "code section headers".to_string(),
        wasmparser::SectionCode::Data => "data section headers".to_string(),
        wasmparser::SectionCode::DataCount => "data count section headers".to_string(),
    }
}

fn parse_names_section<'a>(
    indexed_sections: &[IndexedSection<'a>],
) -> Result<HashMap<usize, &'a str>, traits::Error> {
    let mut names = HashMap::new();
    for IndexedSection(_, section) in indexed_sections.iter() {
        if let wasmparser::SectionCode::Custom { name: "name", .. } = section.code {
            for subsection in section.get_name_section_reader()? {
                let f = match subsection? {
                    wasmparser::Name::Function(f) => f,
                    _ => continue,
                };
                let mut map = f.get_map()?;
                for _ in 0..map.get_count() {
                    let naming = map.read()?;
                    names.insert(naming.index as usize, naming.name);
                }
            }
        }
    }
    Ok(names)
}

fn count_imported_functions<'a>(
    indexed_sections: &[IndexedSection<'a>],
) -> Result<usize, traits::Error> {
    let mut imported_functions = 0;
    for IndexedSection(_, section) in indexed_sections.iter() {
        if let wasmparser::SectionCode::Import = section.code {
            for import in section.get_import_section_reader()? {
                if let wasmparser::ImportSectionEntryType::Function(_) = import?.ty {
                    imported_functions += 1;
                }
            }
        }
    }
    Ok(imported_functions)
}

impl<'a> Parse<'a> for (IndexedSection<'a>, IndexedSection<'a>) {
    type ItemsExtra = (usize, &'a HashMap<usize, &'a str>, &'a HashMap<usize, u32>);

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        (imported_functions, names, sizes): Self::ItemsExtra,
    ) -> Result<(), traits::Error> {
        let (
            IndexedSection(func_section_idx, func_section),
            IndexedSection(code_section_idx, code_section),
        ) = self;

        let mut func_reader = func_section.get_function_section_reader()?;
        let mut code_reader = code_section.get_code_section_reader()?;

        let func_items: Vec<ir::Item> = iterate_with_size(&mut func_reader)
            .enumerate()
            .map(|(i, func)| {
                let (_func, size) = func?;
                let id = Id::entry(*func_section_idx, i);
                let name = format!("func[{}]", i);
                let item = ir::Item::new(id, name, size, ir::Misc::new());
                Ok(item)
            })
            .collect::<Result<_, traits::Error>>()?;

        let code_items: Vec<ir::Item> = iterate_with_size(&mut code_reader)
            .zip(func_items.into_iter())
            .enumerate()
            .map(|(i, (body, func))| {
                let (_body, size) = body?;
                let id = Id::entry(*code_section_idx, i);
                let name = names
                    .get(&(i + imported_functions))
                    .map_or_else(|| format!("code[{}]", i), |name| name.to_string());
                let code = ir::Code::new(&name);
                let item = ir::Item::new(id, name, size + func.size(), code);
                Ok(item)
            })
            .collect::<Result<_, traits::Error>>()?;

        let start = items.size_added();
        let name = get_section_name(code_section);
        for item in code_items.into_iter() {
            items.add_item(item);
        }
        let id = Id::section(*code_section_idx);
        let added = items.size_added() - start;
        let size = sizes
            .get(&code_section_idx)
            .ok_or_else(|| traits::Error::with_msg("Could not find section size"))?
            + sizes
                .get(&func_section_idx)
                .ok_or_else(|| traits::Error::with_msg("Could not find section size"))?;
        assert!(added <= size);
        items.add_root(ir::Item::new(id, name, size - added, ir::Misc::new()));

        Ok(())
    }

    type EdgesExtra = &'a SectionIndices;

    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        indices: Self::EdgesExtra,
    ) -> Result<(), traits::Error> {
        let (IndexedSection(_, function_section), IndexedSection(code_section_idx, code_section)) =
            self;

        let mut func_reader = function_section.get_function_section_reader()?;
        let mut code_reader = code_section.get_code_section_reader()?;

        type Edge = (ir::Id, ir::Id);

        let mut edges: Vec<Edge> = Vec::new();

        // Function section reader parsing.
        for (func_i, type_ref) in iterate_with_size(&mut func_reader).enumerate() {
            let (type_ref, _) = type_ref?;
            if let Some(type_idx) = indices.type_ {
                let type_id = Id::entry(type_idx, type_ref as usize);
                if let Some(code_idx) = indices.code {
                    let body_id = Id::entry(code_idx, func_i);
                    edges.push((body_id, type_id));
                }
            }
        }

        // Code section reader parsing.
        for (b_i, body) in iterate_with_size(&mut code_reader).enumerate() {
            let (body, _size) = body?;
            let body_id = Id::entry(*code_section_idx, b_i);

            let mut cache = None;
            for op in body.get_operators_reader()? {
                let prev = cache.take();
                match op? {
                    Operator::Call { function_index } => {
                        let f_id = indices.functions[function_index as usize];
                        edges.push((body_id, f_id));
                    }

                    // TODO: Rather than looking at indirect calls, need to look
                    // at where the vtables get initialized and/or vtable
                    // indices get pushed onto the stack.
                    Operator::CallIndirect { .. } => continue,

                    Operator::GetGlobal { global_index } | Operator::SetGlobal { global_index } => {
                        let g_id = indices.globals[global_index as usize];
                        edges.push((body_id, g_id));
                    }

                    Operator::I32Load { memarg }
                    | Operator::I32Load8S { memarg }
                    | Operator::I32Load8U { memarg }
                    | Operator::I32Load16S { memarg }
                    | Operator::I32Load16U { memarg }
                    | Operator::I64Load { memarg }
                    | Operator::I64Load8S { memarg }
                    | Operator::I64Load8U { memarg }
                    | Operator::I64Load16S { memarg }
                    | Operator::I64Load16U { memarg }
                    | Operator::I64Load32S { memarg }
                    | Operator::I64Load32U { memarg }
                    | Operator::F32Load { memarg }
                    | Operator::F64Load { memarg } => {
                        if let Some(Operator::I32Const { value }) = prev {
                            if let Some(data_id) = items.get_data(value as u32 + memarg.offset) {
                                edges.push((body_id, data_id));
                            }
                        }
                    }
                    other => cache = Some(other),
                }
            }
        }

        edges
            .into_iter()
            .for_each(|(from, to)| items.add_edge(from, to));

        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::NameSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        let mut i = 0;
        while !self.eof() {
            let start = self.original_position();
            let subsection = self.read()?;
            let size = (self.original_position() - start) as u32;
            let name = match subsection {
                wasmparser::Name::Module(_) => "\"module name\" subsection",
                wasmparser::Name::Function(_) => "\"function names\" subsection",
                wasmparser::Name::Local(_) => "\"local names\" subsection",
            };
            let id = Id::entry(idx, i);
            items.add_root(ir::Item::new(id, name, size, ir::DebugInfo::new()));
            i += 1;
        }

        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

struct CustomSectionReader<'a>(&'a str, wasmparser::Section<'a>);

impl<'a> Parse<'a> for CustomSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        let name = self.0;
        if name == "name" {
            self.1.get_name_section_reader()?.parse_items(items, idx)?;
        } else {
            let range = self.1.get_binary_reader().range();
            let size = (range.end - range.start) as u32;
            let id = Id::entry(idx, 0);
            let name = format!("custom section '{}'", self.0);
            items.add_item(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::TypeSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, ty) in iterate_with_size(self).enumerate() {
            let (ty, size) = ty?;
            let id = Id::entry(idx, i);

            let mut name = format!("type[{}]: (", i);
            for (i, param) in ty.params.iter().enumerate() {
                if i != 0 {
                    name.push_str(", ");
                }
                name.push_str(ty2str(*param));
            }
            name.push_str(") -> ");

            match ty.returns.len() {
                0 => name.push_str("nil"),
                1 => name.push_str(ty2str(ty.returns[0])),
                _ => {
                    name.push_str("(");
                    for (i, result) in ty.returns.iter().enumerate() {
                        if i != 0 {
                            name.push_str(", ");
                        }
                        name.push_str(ty2str(*result));
                    }
                    name.push_str(")");
                }
            }

            items.add_item(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::ImportSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, imp) in iterate_with_size(self).enumerate() {
            let (imp, size) = imp?;
            let id = Id::entry(idx, i);
            let name = format!("import {}::{}", imp.module, imp.field);
            items.add_item(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, (): ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::TableSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, entry) in iterate_with_size(self).enumerate() {
            let (_entry, size) = entry?;
            let id = Id::entry(idx, i);
            let name = format!("table[{}]", i);
            items.add_root(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::MemorySectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, mem) in iterate_with_size(self).enumerate() {
            let (_mem, size) = mem?;
            let id = Id::entry(idx, i);
            let name = format!("memory[{}]", i);
            items.add_item(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::GlobalSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, g) in iterate_with_size(self).enumerate() {
            let (g, size) = g?;
            let id = Id::entry(idx, i);
            let name = format!("global[{}]", i);
            let ty = ty2str(g.ty.content_type).to_string();
            items.add_item(ir::Item::new(id, name, size, ir::Data::new(Some(ty))));
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::ExportSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, exp) in iterate_with_size(self).enumerate() {
            let (exp, size) = exp?;
            let id = Id::entry(idx, i);
            let name = format!("export \"{}\"", exp.field);
            items.add_root(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = (&'a SectionIndices, usize);

    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        (indices, idx): Self::EdgesExtra,
    ) -> Result<(), traits::Error> {
        for (i, exp) in iterate_with_size(self).enumerate() {
            let (exp, _) = exp?;
            let exp_id = Id::entry(idx, i);
            match exp.kind {
                wasmparser::ExternalKind::Function => {
                    items.add_edge(exp_id, indices.functions[exp.index as usize]);
                }
                wasmparser::ExternalKind::Table => {
                    items.add_edge(exp_id, indices.tables[exp.index as usize]);
                }
                wasmparser::ExternalKind::Memory => {
                    items.add_edge(exp_id, indices.memories[exp.index as usize]);
                }
                wasmparser::ExternalKind::Global => {
                    items.add_edge(exp_id, indices.globals[exp.index as usize]);
                }
            }
        }

        Ok(())
    }
}

struct StartSection<'a>(wasmparser::Section<'a>);

impl<'a> Parse<'a> for StartSection<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        let range = self.0.range();
        let size = (range.end - range.start) as u32;
        let id = Id::section(idx);
        let name = "\"start\" section";
        items.add_root(ir::Item::new(id, name, size, ir::Misc::new()));
        Ok(())
    }

    type EdgesExtra = (&'a SectionIndices, usize);

    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        (indices, idx): Self::EdgesExtra,
    ) -> Result<(), traits::Error> {
        let f_i = self.0.get_start_section_content()?;
        items.add_edge(Id::section(idx), indices.functions[f_i as usize]);
        Ok(())
    }
}

struct DataCountSection<'a>(wasmparser::Section<'a>);

impl<'a> Parse<'a> for DataCountSection<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        let range = self.0.range();
        let size = (range.end - range.start) as u32;
        let id = Id::section(idx);
        let name = "\"data count\" section";
        items.add_root(ir::Item::new(id, name, size, ir::Misc::new()));
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _items: &mut ir::ItemsBuilder, (): ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::ElementSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, elem) in iterate_with_size(self).enumerate() {
            let (_elem, size) = elem?;
            let id = Id::entry(idx, i);
            let name = format!("elem[{}]", i);
            items.add_item(ir::Item::new(id, name, size, ir::Misc::new()));
        }
        Ok(())
    }

    type EdgesExtra = (&'a SectionIndices, usize);

    fn parse_edges(
        &mut self,
        items: &mut ir::ItemsBuilder,
        (indices, idx): Self::EdgesExtra,
    ) -> Result<(), traits::Error> {
        for (i, elem) in iterate_with_size(self).enumerate() {
            let (elem, _size) = elem?;
            let elem_id = Id::entry(idx, i);

            match elem.kind {
                wasmparser::ElementKind::Active { table_index, .. } => {
                    items.add_edge(indices.tables[table_index as usize], elem_id);
                }
                wasmparser::ElementKind::Passive(_ty) => {}
            }
            for func_idx in elem.items.get_items_reader()? {
                let func_idx = func_idx?;
                items.add_edge(elem_id, indices.functions[func_idx as usize]);
            }
        }

        Ok(())
    }
}

impl<'a> Parse<'a> for wasmparser::DataSectionReader<'a> {
    type ItemsExtra = usize;

    fn parse_items(
        &mut self,
        items: &mut ir::ItemsBuilder,
        idx: usize,
    ) -> Result<(), traits::Error> {
        for (i, d) in iterate_with_size(self).enumerate() {
            let (d, size) = d?;
            let id = Id::entry(idx, i);
            let name = format!("data[{}]", i);
            items.add_item(ir::Item::new(id, name, size, ir::Data::new(None)));

            // Get the constant address (if any) from the initialization
            // expression.
            if let wasmparser::DataKind::Active { init_expr, .. } = d.kind {
                let mut iter = init_expr.get_operators_reader();
                let offset = match iter.read()? {
                    Operator::I32Const { value } => Some(i64::from(value)),
                    Operator::I64Const { value } => Some(value),
                    _ => None,
                };

                if let Some(off) = offset {
                    let length = d.data.len(); // size of data
                    items.link_data(off, length, id);
                }
            }
        }
        Ok(())
    }

    type EdgesExtra = ();

    fn parse_edges(&mut self, _: &mut ir::ItemsBuilder, _: ()) -> Result<(), traits::Error> {
        Ok(())
    }
}

fn iterate_with_size<'a, S: SectionWithLimitedItems + SectionReader>(
    s: &'a mut S,
) -> impl Iterator<Item = Result<(S::Item, u32), traits::Error>> + 'a {
    let count = s.get_count();
    (0..count).map(move |i| {
        let start = s.original_position();
        let item = s.read()?;
        let size = (s.original_position() - start) as u32;
        if i == count - 1 {
            s.ensure_end()?;
        }
        Ok((item, size))
    })
}

fn ty2str(t: Type) -> &'static str {
    match t {
        Type::I32 => "i32",
        Type::I64 => "i64",
        Type::F32 => "f32",
        Type::F64 => "f64",
        Type::V128 => "v128",
        Type::AnyFunc => "anyfunc",
        Type::AnyRef => "anyref",
        Type::Func | Type::EmptyBlockType => "?",
    }
}

'''
'''--- publish.sh ---
#!/usr/bin/env bash

set -eux

cd "$(dirname $0)"

for dir in ir traits parser opt analyze twiggy; do
    cd "$dir"

    if [[ "$dir" == "opt" || "$dir" == "analyze" ]]; then
        cargo publish --no-verify
    else
        cargo publish
    fi

    cd -
done

'''
'''--- releases/friends.sh ---
#!/usr/bin/env bash

set -eu
set -o pipefail

cd $(dirname $0)

if [[ -z "${1+x}" ]]; then
    read -p "List friends since which commit/tag? " since
    echo
else
    since=$1
fi

git shortlog -s -n "$since.." \
    | cut -f 2- \
    | sort -u \
    | grep -v bors\-servo \
    | xargs -d '\n' -I{} echo "- {}"

'''
'''--- releases/release-announcement-template.md ---
# Announcing `twiggy` $TODO_VERSION

`twiggy` is a code size profiler for `.wasm` binaries.

* [GitHub][]
* [crates.io][]

Upgrade to this release by reinstalling with `cargo`:

    cargo install -f twiggy

## Changelog

<insert relevant section of CHANGELOG.md here>

## Friends

Thanks to everyone who contributed to this release!

<insert the output of friends.sh here>

## Contributing

Want to join us? Check out our [`CONTRIBUTING.md`][contributing] and take a look
at some of these issues:

* [Issues labeled "good first issue"][good-first-issue]
* [Issues labeled "help wanted"][help-wanted]

[GitHub]: https://github.com/rustwasm/twiggy
[crates.io]: https://crates.io/crates/twiggy
[guide]: https://rustwasm.github.io/twiggy
[contributing]: https://github.com/rustwasm/twiggy/blob/master/CONTRIBUTING.md
[good-first-issue]: https://github.com/rustwasm/twiggy/labels/good%20first%20issue
[help-wanted]: https://github.com/rustwasm/twiggy/labels/help%20wanted

'''
'''--- traits/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = []
description = "Common traits for the Twiggy code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy-traits"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[lib]
path = "./traits.rs"

[dependencies]
failure = "0.1.8"
gimli = { version = "0.22.0", optional = true, default-features = false, features = ["std", "read"] }
wasmparser = "0.35.3"
twiggy-ir = { version = "=0.6.0", path = "../ir" }
csv = "1.1.3"
regex = "1.3.9"

[features]
default = []
dwarf = ["gimli"]
emit_json = []
emit_csv = []
emit_text = []

'''
'''--- traits/traits.rs ---
//! Common traits and types used throughout all of `twiggy`.

#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

use std::fmt;
use std::io;
use std::str::FromStr;

use failure::Fail;

use twiggy_ir as ir;

/// An error that ocurred in `twiggy` when parsing, analyzing, or emitting
/// items.
#[derive(Debug)]
pub struct Error {
    inner: Box<ErrorInner>,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}

impl failure::Fail for Error {
    fn cause(&self) -> Option<&dyn failure::Fail> {
        self.inner.cause()
    }

    fn backtrace(&self) -> Option<&failure::Backtrace> {
        self.inner.backtrace()
    }
}

#[derive(Debug, Fail)]
enum ErrorInner {
    #[fail(display = "{}", _0)]
    Msg(String),

    #[fail(display = "I/O error: {}", _0)]
    Io(#[cause] io::Error),

    #[fail(display = "WASM error: {}", _0)]
    Wasm(#[cause] wasmparser::BinaryReaderError),

    #[fail(display = "formatting error: {}", _0)]
    Fmt(#[cause] fmt::Error),

    #[fail(display = "CSV error: {}", _0)]
    Csv(#[cause] csv::Error),

    #[fail(display = "Regex error: {}", _0)]
    Regex(#[cause] regex::Error),

    #[cfg(feature = "dwarf")]
    #[fail(display = "Gimli error: {}", _0)]
    Gimli(#[cause] gimli::Error),
}

impl<'a> From<&'a str> for Error {
    fn from(msg: &'a str) -> Error {
        Error::with_msg(msg)
    }
}

impl From<io::Error> for Error {
    fn from(e: io::Error) -> Error {
        Error {
            inner: Box::new(ErrorInner::Io(e)),
        }
    }
}

impl From<wasmparser::BinaryReaderError> for Error {
    fn from(e: wasmparser::BinaryReaderError) -> Error {
        Error {
            inner: Box::new(ErrorInner::Wasm(e)),
        }
    }
}

impl From<fmt::Error> for Error {
    fn from(e: fmt::Error) -> Error {
        Error {
            inner: Box::new(ErrorInner::Fmt(e)),
        }
    }
}

impl From<csv::Error> for Error {
    fn from(e: csv::Error) -> Error {
        Error {
            inner: Box::new(ErrorInner::Csv(e)),
        }
    }
}

impl From<regex::Error> for Error {
    fn from(e: regex::Error) -> Error {
        Error {
            inner: Box::new(ErrorInner::Regex(e)),
        }
    }
}

#[cfg(feature = "dwarf")]
impl From<gimli::Error> for Error {
    fn from(e: gimli::Error) -> Error {
        Error {
            inner: Box::new(ErrorInner::Gimli(e)),
        }
    }
}

impl Error {
    /// Create an error with the given message.
    pub fn with_msg<S: Into<String>>(msg: S) -> Error {
        Error {
            inner: Box::new(ErrorInner::Msg(msg.into())),
        }
    }
}

#[test]
fn size_of_error_is_one_word() {
    use std::mem;
    assert_eq!(mem::size_of::<Error>(), mem::size_of::<usize>());
}

/// An analysis takes our IR and returns some kind of data results that can be
/// emitted.
pub trait Analyze {
    /// The resulting data from this analysis.
    type Data: Emit;

    /// Run this analysis on the given IR items.
    fn analyze(items: &mut ir::Items) -> Result<Self::Data, Error>;
}

/// Selects the parse mode for the input data.
#[derive(Clone, Copy, Debug)]
pub enum ParseMode {
    /// WebAssembly file parse mode.
    Wasm,
    /// DWARF sections parse mode.
    #[cfg(feature = "dwarf")]
    Dwarf,
    /// Automatically determined mode of parsing, e.g. based on file extension.
    Auto,
}

impl Default for ParseMode {
    fn default() -> ParseMode {
        ParseMode::Auto
    }
}

impl FromStr for ParseMode {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Error> {
        match s {
            "wasm" => Ok(ParseMode::Wasm),
            #[cfg(feature = "dwarf")]
            "dwarf" => Ok(ParseMode::Dwarf),
            "auto" => Ok(ParseMode::Auto),
            _ => Err(Error::with_msg(format!("Unknown parse mode: {}", s))),
        }
    }
}

/// The format of the output.
#[derive(Clone, Copy, Debug)]
pub enum OutputFormat {
    /// Human readable text.
    #[cfg(feature = "emit_text")]
    Text,
    // /// Hyper Text Markup Language.
    // Html,

    // /// Graphviz dot format.
    // Dot,
    /// Comma-separated values (CSV) format.
    #[cfg(feature = "emit_csv")]
    Csv,
    /// JavaScript Object Notation format.
    #[cfg(feature = "emit_json")]
    Json,
}

#[cfg(feature = "emit_text")]
#[cfg(feature = "emit_csv")]
#[cfg(feature = "emit_json")]
impl Default for OutputFormat {
    fn default() -> OutputFormat {
        OutputFormat::Text
    }
}

impl FromStr for OutputFormat {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Error> {
        match s {
            #[cfg(feature = "emit_text")]
            "text" => Ok(OutputFormat::Text),
            #[cfg(feature = "emit_json")]
            "json" => Ok(OutputFormat::Json),
            #[cfg(feature = "emit_csv")]
            "csv" => Ok(OutputFormat::Csv),
            _ => Err(Error::with_msg(format!("Unknown output format: {}", s))),
        }
    }
}

/// Anything that can write itself in the given output format to the given
/// destination.
pub trait Emit {
    /// Emit this thing to the given destination in the given output format.
    fn emit(
        &self,
        items: &ir::Items,
        destination: &mut dyn io::Write,
        format: OutputFormat,
    ) -> Result<(), Error> {
        match format {
            #[cfg(feature = "emit_text")]
            OutputFormat::Text => self.emit_text(items, destination),
            // OutputFormat::Html => self.emit_html(destination),
            // OutputFormat::Dot => self.emit_dot(destination),
            #[cfg(feature = "emit_csv")]
            OutputFormat::Csv => self.emit_csv(items, destination),
            #[cfg(feature = "emit_json")]
            OutputFormat::Json => self.emit_json(items, destination),
        }
    }

    /// Emit human readable text.
    #[cfg(feature = "emit_text")]
    fn emit_text(&self, items: &ir::Items, destination: &mut dyn io::Write) -> Result<(), Error>;

    // /// Emit HTML.
    // fn emit_html(&self, destination: &mut dyn io::Write) -> Result<(), Error>;

    // /// Emit Graphviz's dot format.
    // fn emit_dot(&self, destination: &mut dyn io::Write) -> Result<(), Error>;

    /// Emit CSV.
    #[cfg(feature = "emit_csv")]
    fn emit_csv(&self, items: &ir::Items, destination: &mut dyn io::Write) -> Result<(), Error>;

    /// Emit JSON.
    #[cfg(feature = "emit_json")]
    fn emit_json(&self, items: &ir::Items, destination: &mut dyn io::Write) -> Result<(), Error>;
}

'''
'''--- twiggy/Cargo.toml ---
[package]
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
categories = ["command-line-utilities", "development-tools", "development-tools::profiling", "wasm"]
description = "Twiggy is a code size profiler."
license = "Apache-2.0/MIT"
name = "twiggy"
readme = "../README.md"
repository = "https://github.com/rustwasm/twiggy"
version = "0.6.0"
edition = "2018"

[badges]
travis-ci = { repository = "rustwasm/twiggy" }

[[bin]]
name = "twiggy"
path = "./twiggy.rs"

[dependencies]
failure = "0.1.8"
structopt = "0.3"
twiggy-analyze = { version = "=0.6.0", path = "../analyze" }
twiggy-ir = { version = "=0.6.0", path = "../ir" }
twiggy-opt = { version = "=0.6.0", path = "../opt", features = ["cli"] }
twiggy-parser = { version = "=0.6.0", path = "../parser" }
twiggy-traits = { version = "=0.6.0", path = "../traits" }

[dev-dependencies]
colored = "2.0.0"
diff = "0.1.12"

'''
'''--- twiggy/tests/all/diff_tests.rs ---
test!(
    diff_wee_alloc,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm"
);

test!(
    diff_wee_alloc_top_5,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-n",
    "5"
);

test!(
    diff_wee_alloc_all,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-a"
);

test!(
    diff_wee_alloc_all_json,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-a",
    "-f",
    "json"
);

test!(
    diff_wee_alloc_json,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-f",
    "json"
);

test!(
    diff_wee_alloc_json_top_5,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-f",
    "json",
    "-n",
    "5"
);

test!(
    diff_wee_alloc_csv,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-f",
    "csv"
);

test!(
    diff_wee_alloc_csv_top_5,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "-f",
    "csv",
    "-n",
    "5"
);

test!(
    diff_test_regex_wee_alloc,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "--regex",
    "(data|type)\\[\\d*\\]"
);

test!(
    diff_test_exact_wee_alloc,
    "diff",
    "./fixtures/wee_alloc.wasm",
    "./fixtures/wee_alloc.2.wasm",
    "hello",
    "goodbye"
);

'''
'''--- twiggy/tests/all/dominators_tests.rs ---
test!(
    dominators_wee_alloc,
    "dominators",
    "./fixtures/wee_alloc.wasm"
);

test!(
    dominators_wee_alloc_json,
    "dominators",
    "./fixtures/wee_alloc.wasm",
    "-f",
    "json"
);

test!(
    dominators_wee_alloc_csv,
    "dominators",
    "./fixtures/wee_alloc.wasm",
    "-f",
    "csv"
);

test!(
    dominators_wee_alloc_with_depth_and_row,
    "dominators",
    "./fixtures/wee_alloc.wasm",
    "-d",
    "5",
    "-r",
    "3"
);

test!(
    dominators_wee_alloc_subtree,
    "dominators",
    "./fixtures/wee_alloc.wasm",
    "hello"
);

test!(
    dominators_wee_alloc_subtree_json,
    "dominators",
    "./fixtures/wee_alloc.wasm",
    "-f",
    "json",
    "hello"
);

test!(
    dominators_json_prints_multiple_root_items,
    "dominators",
    "./fixtures/paths_test.wasm",
    "-f",
    "json",
    "--regex",
    "called.*"
);

test!(
    dominators_regex_any_func,
    "dominators",
    "./fixtures/paths_test.wasm",
    "--regex",
    "func\\[[0-9]+\\]"
);

test!(
    dominators_csv_does_not_summarize_garbage_if_all_items_are_reachable,
    "dominators",
    "./fixtures/paths_test.wasm",
    "-f",
    "csv"
);

test!(
    dominators_summarizes_unreachable_items,
    "dominators",
    "./fixtures/garbage.wasm",
    "-d",
    "1"
);

'''
'''--- twiggy/tests/all/elf_format_tests.rs ---
test!(
    elf_top_25_hello_world_rs,
    "top",
    "-n",
    "25",
    "./fixtures/hello_elf"
);

test!(elf_top_hello_world_rs, "top", "./fixtures/hello_elf");

'''
'''--- twiggy/tests/all/fixtures/cpp-monos.cpp ---
// https://webassembly.studio/?f=zbgxunzkbf

#include <cstddef>
#include <cstdint>

#define WASM_EXPORT __attribute__((visibility("default")))

using CodeFn = uint32_t (*)();

extern "C" {
    void hello(CodeFn f);
}

template <typename T>
__attribute__((noinline))
void generic() { hello(T::code); }

struct Zero {
    static uint32_t code() { return 0; }
};

struct One {
    static uint32_t code() { return 1; }
};

struct Two {
    static uint32_t code() { return 2; }
};

WASM_EXPORT void trigger_generic_monos() {
    generic<Zero>();
    generic<One>();
    generic<Two>();
}

WASM_EXPORT
int main() { return 42; }

'''
'''--- twiggy/tests/all/fixtures/hello_world.rs ---
//! Rebuild `hello_elf` with:
//!
//! ```
//! rustc +nightly -g --target x86_64-unknown-linux-gnu hello_world.rs -o hello_elf -C lto=fat -C opt-level=z
//! ```
//!
//! Rebuild `hello_mach` with:
//!
//! ```
//! rustc +nightly -g --target x86_64-apple-darwin hello_world.rs -o hello_mach.o -C lto=fat -C opt-level=z
//! ```
//! NOTE: The above is not working for me on Ubuntu. This causes an error when `ld` is invoked.

fn main() {
    println!("Hello, world!");
}

'''
'''--- twiggy/tests/all/fixtures/monos.rs ---
//! Rebuild `monos.wasm` with:
//!
//! ```
//! rustc +nightly -g --target wasm32-unknown-unknown monos.rs -o monos.wasm -C lto=fat -C opt-level=z
//! ```

#![cfg(target_arch = "wasm32")]
#![crate_type = "cdylib"]

use std::slice;

extern "C" {
    fn hello(f: extern "C" fn() -> u32);
}

trait Code {
    extern "C" fn code() -> u32;
}

#[inline(never)]
fn generic<C: Code>() {
    unsafe {
        hello(C::code);
    }
}

struct Zero;
impl Code for Zero {
    extern "C" fn code() -> u32 {
        0
    }
}

struct One;
impl Code for One {
    extern "C" fn code() -> u32 {
        1
    }
}

struct Two;
impl Code for Two {
    extern "C" fn code() -> u32 {
        2
    }
}

#[no_mangle]
pub extern "C" fn trigger_generic_monos() {
    generic::<Zero>();
    generic::<One>();
    generic::<Two>();
}

#[no_mangle]
pub extern "C" fn sort_u32s(ptr: *mut u32, len: usize) {
    unsafe {
        let slice = slice::from_raw_parts_mut(ptr, len);
        slice.sort();
    }
}

#[no_mangle]
pub extern "C" fn sort_u8s(ptr: *mut u8, len: usize) {
    unsafe {
        let slice = slice::from_raw_parts_mut(ptr, len);
        slice.sort();
    }
}

#[no_mangle]
pub extern "C" fn sort_i32s(ptr: *mut i32, len: usize) {
    unsafe {
        let slice = slice::from_raw_parts_mut(ptr, len);
        slice.sort();
    }
}

#[no_mangle]
pub extern "C" fn push_and_sort_u32s(ptr: *mut u32, cap: usize, len: usize) {
    unsafe {
        let mut vec = Vec::from_raw_parts(ptr, len, cap);
        vec.push(0);
        vec.push(1);
        vec.push(2);
        vec.sort();
    }
}

#[no_mangle]
pub extern "C" fn push_and_sort_u8s(ptr: *mut u8, cap: usize, len: usize) {
    unsafe {
        let mut vec = Vec::from_raw_parts(ptr, len, cap);
        vec.push(0);
        vec.push(1);
        vec.push(2);
        vec.sort();
    }
}

#[no_mangle]
pub extern "C" fn push_and_sort_i32s(ptr: *mut i32, cap: usize, len: usize) {
    unsafe {
        let mut vec = Vec::from_raw_parts(ptr, len, cap);
        vec.push(0);
        vec.push(1);
        vec.push(2);
        vec.sort();
    }
}

'''
'''--- twiggy/tests/all/garbage_tests.rs ---
test!(garbage, "garbage", "./fixtures/garbage.wasm");

test!(
    garbage_top_2,
    "garbage",
    "./fixtures/garbage.wasm",
    "-n",
    "2"
);

test!(
    garbage_json,
    "garbage",
    "./fixtures/garbage.wasm",
    "-f",
    "json"
);

test!(
    garbage_top_2_json,
    "garbage",
    "./fixtures/garbage.wasm",
    "-f",
    "json",
    "-n",
    "2"
);

test!(
    garbage_wee_alloc_top_10,
    "garbage",
    "./fixtures/wee_alloc.wasm"
);

test!(
    garbage_wee_alloc_all,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "-a"
);

test!(
    garbage_wee_alloc_top_10_json,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "-f",
    "json"
);

test!(
    garbage_wee_alloc_all_json,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "-f",
    "json",
    "-a"
);

test!(
    garbage_wee_alloc_show_data_segments,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "--show-data-segments"
);

test!(
    garbage_wee_alloc_top_2_show_data_segments,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "--show-data-segments",
    "-n",
    "2"
);

test!(
    garbage_wee_alloc_show_data_segments_json,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "--show-data-segments",
    "-f",
    "json"
);

test!(
    garbage_wee_alloc_top_2_show_data_segments_json,
    "garbage",
    "./fixtures/wee_alloc.wasm",
    "--show-data-segments",
    "-f",
    "json",
    "-n",
    "2"
);

'''
'''--- twiggy/tests/all/main.rs ---
use std::fs;
use std::io::{self, Read};
use std::path::Path;

fn slurp<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {
    let mut f = fs::File::open(path)?;
    let mut buf = vec![];
    f.read_to_end(&mut buf)?;
    Ok(buf)
}

macro_rules! test {
    ( $name:ident $( , $args:expr )* ) => {
        #[test]
        fn $name() {
            use std::fs;
            use std::process::Command;
            use colored::Colorize;
            use diff;
            use crate::slurp;

            let output = Command::new("cargo")
                .arg("run")
                .arg("--")
                $(
                    .arg($args)
                )*
                .current_dir(concat!(env!("CARGO_MANIFEST_DIR"), "/tests/all/"))
                .output()
                .unwrap();

            assert!(
                output.status.success(),
                "should have run `twiggy` OK\n\n\
                 ============================== stdout ==============================\n\n\
                 {}\n\n\
                 ============================== stderr ==============================\n\n\
                 {}\n\n",
                String::from_utf8_lossy(&output.stdout),
                String::from_utf8_lossy(&output.stderr),
            );

            let expected_path = concat!(
                env!("CARGO_MANIFEST_DIR"),
                "/tests/all/expectations/",
                stringify!($name)
            );

            // Ignore errors. The diffing will provide a better diagnostic report.
            let expected = slurp(expected_path).unwrap_or(vec![]);
            let expected = String::from_utf8_lossy(&expected);
            let expected_lines = expected.lines().collect::<Vec<&str>>();

            let actual = String::from_utf8_lossy(&output.stdout);

            if ::std::env::var("TWIGGY_UPDATE_TEST_EXPECTATIONS").is_ok() {
                fs::write(expected_path, actual.as_ref()).unwrap();
                return;
            }

            let actual_lines = actual.lines().collect::<Vec<&str>>();

            if actual_lines != expected_lines {
                let mut cmd = "twiggy".to_string();
                $(
                    cmd.push(' ');
                    cmd.push_str($args);
                )*
                println!(
                    "\n{} {}\n",
                    format!("`{}`", cmd).red(),
                    "did not have the expected output!".red()
                );
                println!("--- {}", expected_path);
                println!(
                    "{} {}\n",
                    "+++ actually generated by".red(),
                    format!("`{}`", cmd).red()
                );
                for diff in diff::slice(&expected_lines, &actual_lines) {
                    match diff {
                        diff::Result::Left(l) => {
                            println!("{}", format!("-{}", l).red())
                        }
                        diff::Result::Both(l, _) => println!(" {}", l),
                        diff::Result::Right(r) => {
                            println!("{}", format!("+{}", r).red())
                        }
                    }
                }
                println!();
                panic!();
            }
        }
    }
}

mod diff_tests;
mod dominators_tests;
mod elf_format_tests;
mod garbage_tests;
mod monos_tests;
mod paths_tests;
mod top_tests;

'''
'''--- twiggy/tests/all/monos_tests.rs ---
test!(cpp_monos, "monos", "./fixtures/cpp-monos.wasm");

test!(monos, "monos", "./fixtures/monos.wasm");

test!(
    monos_maxes,
    "monos",
    "./fixtures/monos.wasm",
    "-m",
    "2",
    "-n",
    "1"
);

test!(monos_only_generics, "monos", "./fixtures/monos.wasm", "-g");

test!(
    monos_wasm_csv,
    "monos",
    "./fixtures/monos.wasm",
    "-f",
    "csv"
);

test!(monos_all, "monos", "./fixtures/monos.wasm", "-a");

test!(
    monos_only_all_generics,
    "monos",
    "./fixtures/monos.wasm",
    "-g",
    "-a"
);

test!(
    monos_all_generics,
    "monos",
    "./fixtures/monos.wasm",
    "--all-generics"
);

test!(
    monos_all_monos,
    "monos",
    "./fixtures/monos.wasm",
    "--all-monos"
);

test!(
    monos_json,
    "monos",
    "./fixtures/monos.wasm",
    "-m",
    "2",
    "-n",
    "1",
    "-f",
    "json"
);

test!(
    monos_regex,
    "monos",
    "./fixtures/monos.wasm",
    "--regex",
    "-m",
    "5",
    "^<?alloc::.*"
);

test!(
    monos_functions,
    "monos",
    "./fixtures/monos.wasm",
    "alloc::slice::insert_head",
    "alloc::slice::merge_sort"
);

'''
'''--- twiggy/tests/all/paths_tests.rs ---
test!(
    paths_test_called_once,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledOnce"
);

test!(
    paths_test_called_once_csv,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledOnce",
    "-f",
    "csv"
);

test!(
    paths_test_called_once_json,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledOnce",
    "-f",
    "json"
);

test!(
    paths_test_called_twice,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledTwice"
);

test!(
    paths_test_called_twice_csv,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledTwice",
    "-f",
    "csv"
);

test!(
    paths_test_called_twice_json,
    "paths",
    "./fixtures/paths_test.wasm",
    "calledTwice",
    "-f",
    "json"
);

test!(
    paths_test_default_output,
    "paths",
    "./fixtures/paths_test.wasm"
);

test!(
    paths_test_default_output_csv,
    "paths",
    "./fixtures/paths_test.wasm",
    "-f",
    "csv"
);

test!(
    paths_test_default_output_json,
    "paths",
    "./fixtures/paths_test.wasm",
    "-f",
    "json"
);

test!(
    paths_test_default_output_desc,
    "paths",
    "./fixtures/paths_test.wasm",
    "--descending"
);

test!(
    paths_test_default_output_desc_with_depth,
    "paths",
    "./fixtures/paths_test.wasm",
    "--descending",
    "-d",
    "2"
);

test!(
    paths_wee_alloc,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye"
);

test!(
    paths_wee_alloc_csv,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye",
    "-f",
    "csv"
);

test!(
    paths_wee_alloc_with_depth_and_paths,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye",
    "-d",
    "1",
    "-r",
    "2"
);

test!(
    paths_wee_alloc_with_depth_and_paths_json,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye",
    "-d",
    "1",
    "-r",
    "2",
    "-f",
    "json"
);

test!(
    paths_wee_alloc_with_depth_and_paths_csv,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye",
    "-d",
    "1",
    "-r",
    "2",
    "-f",
    "csv"
);

test!(
    paths_wee_alloc_json,
    "paths",
    "./fixtures/wee_alloc.wasm",
    "wee_alloc::alloc_first_fit::h9a72de3af77ef93f",
    "hello",
    "goodbye",
    "-d",
    "3",
    "-f",
    "json"
);

test!(
    paths_test_regex_called_any,
    "paths",
    "./fixtures/paths_test.wasm",
    "called.*",
    "--regex"
);

test!(
    paths_test_regex_exports,
    "paths",
    "./fixtures/paths_test.wasm",
    "export \".*\"",
    "--regex"
);

test!(
    paths_test_regex_exports_desc,
    "paths",
    "./fixtures/paths_test.wasm",
    "export \".*\"",
    "--descending",
    "--regex"
);

test!(
    issue_16,
    "paths",
    "./fixtures/mappings.wasm",
    "compute_column_spans"
);

test!(
    paths_error_test_no_max_paths,
    "paths",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

test!(
    paths_error_test_no_max_paths_csv,
    "paths",
    "-f",
    "csv",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

test!(
    paths_error_test_no_max_paths_json,
    "paths",
    "-f",
    "json",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

test!(
    paths_error_test_one_path,
    "paths",
    "-r",
    "1",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

test!(
    paths_error_test_one_path_csv,
    "paths",
    "-f",
    "csv",
    "-r",
    "1",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

test!(
    paths_error_test_one_path_json,
    "paths",
    "-f",
    "json",
    "-r",
    "1",
    "./fixtures/mappings.wasm",
    "std::io::error::Error::new::h8c006d5367bc92ed"
);

'''
'''--- twiggy/tests/all/top_tests.rs ---
test!(top_mappings, "top", "-n", "10", "./fixtures/mappings.wasm");

test!(
    top_wee_alloc,
    "top",
    "-n",
    "10",
    "./fixtures/wee_alloc.wasm"
);

test!(
    top_retained_wee_alloc,
    "top",
    "-n",
    "10",
    "--retained",
    "./fixtures/wee_alloc.wasm"
);

test!(
    top_retained_mappings,
    "top",
    "-n",
    "10",
    "--retained",
    "./fixtures/mappings.wasm"
);

test!(
    top_2_json,
    "top",
    "./fixtures/wee_alloc.wasm",
    "-n",
    "2",
    "-f",
    "json"
);

test!(
    top_2_json_retained,
    "top",
    "./fixtures/wee_alloc.wasm",
    "--retained",
    "-n",
    "2",
    "-f",
    "json"
);

test!(
    top_2_csv,
    "top",
    "./fixtures/wee_alloc.wasm",
    "-n",
    "4",
    "-f",
    "csv"
);

test!(
    top_2_csv_retained,
    "top",
    "./fixtures/wee_alloc.wasm",
    "--retained",
    "-n",
    "4",
    "-f",
    "csv"
);

// This should not fail to open and write `whatever-output.txt`.
test!(
    output_to_file,
    "top",
    "./fixtures/wee_alloc.wasm",
    "-o",
    "whatever-output.txt"
);

// Regression test for https://github.com/rustwasm/twiggy/issues/151
test!(top_mono, "top", "./fixtures/mono.wasm", "-n", "10");

'''
'''--- twiggy/twiggy.rs ---
//! The `twiggy` code size profiler.

#![deny(missing_docs)]
#![deny(missing_debug_implementations)]

use std::process;

use failure::Fail;
use structopt::StructOpt;

use twiggy_analyze as analyze;
use twiggy_opt::{self as opt, CommonCliOptions};
use twiggy_parser as parser;
use twiggy_traits as traits;

fn main() {
    let options = opt::Options::from_args();
    if let Err(e) = run(&options) {
        eprintln!("error: {}", e);
        for c in Fail::iter_causes(&e) {
            eprintln!("  caused by: {}", c);
        }
        process::exit(1);
    }
}

fn run(opts: &opt::Options) -> Result<(), traits::Error> {
    let mut items = parser::read_and_parse(opts.input(), opts.parse_mode())?;

    let data = match opts {
        opt::Options::Top(ref top) => analyze::top(&mut items, top)?,
        opt::Options::Dominators(ref doms) => analyze::dominators(&mut items, doms)?,
        opt::Options::Paths(ref paths) => analyze::paths(&mut items, paths)?,
        opt::Options::Monos(ref monos) => analyze::monos(&mut items, monos)?,
        opt::Options::Garbage(ref garbo) => analyze::garbage(&items, garbo)?,
        opt::Options::Diff(ref diff) => {
            let mut new_items = parser::read_and_parse(diff.new_input(), opts.parse_mode())?;
            analyze::diff(&mut items, &mut new_items, diff)?
        }
    };

    let mut dest = opts.output_destination().open()?;

    data.emit(&items, &mut *dest, opts.output_format())
}

'''
'''--- wasm-api/Cargo.toml ---
[package]
name = "twiggy-wasm-api"
version = "0.6.0"
authors = ["Nick Fitzgerald <fitzgen@gmail.com>"]
license = "Apache-2.0/MIT"
edition = "2018"

[lib]
crate-type = ["cdylib"]
path = "./wasm-api.rs"

[dependencies.twiggy-ir]
version = "=0.6.0"
path = "../ir"

[dependencies.twiggy-analyze]
default-features = false
version = "=0.6.0"
path = "../analyze"
features = ["emit_json"]

[dependencies.twiggy-opt]
default-features = false
features = ["wasm"]
version = "=0.6.0"
path = "../opt"

[dependencies.twiggy-parser]
default-features = false
version = "=0.6.0"
path = "../parser"

[dependencies.twiggy-traits]
version = "=0.6.0"
path = "../traits"

[dependencies.wasm-bindgen]
version = "0.2.64"

[features]
default = ["emit_json"]
emit_json = ["twiggy-traits/emit_json"]

'''
'''--- wasm-api/wasm-api.rs ---
#![cfg(target_arch = "wasm32")]
#![cfg(feature = "emit_json")]

use twiggy_analyze as analyze;
use twiggy_ir as ir;
use twiggy_opt as opt;
use twiggy_parser as parser;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct Items {
    items: ir::Items,
}

#[wasm_bindgen]
impl Items {
    pub fn parse(data: &[u8]) -> Items {
        let items = parser::parse(data).unwrap();
        Items { items }
    }

    pub fn top(&mut self, options: &opt::Top) -> String {
        let top = analyze::top(&mut self.items, options).unwrap();
        let mut buf = Vec::new();
        top.emit_json(&self.items, &mut buf).unwrap();
        String::from_utf8(buf).unwrap()
    }

    pub fn dominators(&mut self, options: &opt::Dominators) -> String {
        let dominators = analyze::dominators(&mut self.items, options).unwrap();
        let mut buf = Vec::new();
        dominators.emit_json(&self.items, &mut buf).unwrap();
        String::from_utf8(buf).unwrap()
    }

    pub fn paths(&mut self, options: &opt::Paths) -> String {
        let paths = analyze::paths(&mut self.items, options).unwrap();
        let mut buf = Vec::new();
        paths.emit_json(&self.items, &mut buf).unwrap();
        String::from_utf8(buf).unwrap()
    }

    pub fn monos(&mut self, options: &opt::Monos) -> String {
        let monos = analyze::monos(&mut self.items, options).unwrap();
        let mut buf = Vec::new();
        monos.emit_json(&self.items, &mut buf).unwrap();
        String::from_utf8(buf).unwrap()
    }

    pub fn diff(&mut self, new_items: &mut Items, options: &opt::Diff) -> String {
        let diff = analyze::diff(&mut self.items, &mut new_items.items, options).unwrap();
        let mut buf = Vec::new();
        diff.emit_json(&self.items, &mut buf).unwrap();
        String::from_utf8(buf).unwrap()
    }
}

'''